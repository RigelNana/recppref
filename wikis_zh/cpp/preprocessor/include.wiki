{{title|源文件包含}}
{{cpp/preprocessor/navbar}}
将其他源文件包含到当前源文件中紧随指令之后的一行。

===语法===
{{sdsc begin}}
{{sdsc|num=1|{{ttb|#include &amp;lt;}} {{spar|h字符序列}} {{ttb|&amp;gt;}} {{spar|换行}}}}
{{sdsc|num=2|{{ttb|#include "}} {{spar|q字符序列}} {{ttb|"}} {{spar|换行}}}}
{{sdsc|num=3|{{ttb|#include}} {{spar|记号序列}} {{spar|换行}}}}
{{sdsc|num=4|notes={{mark since c++17}}|{{ttb|__has_include}} {{ttb|(}} {{ttb|"}} {{spar|q字符序列}} {{ttb|"}} {{ttb|)}}&lt;br&gt;{{ttb|__has_include}} {{ttb|(}} {{ttb|&amp;lt;}} {{spar|h字符序列}} {{ttb|&amp;gt;}} {{ttb|)}}}}
{{sdsc|num=5|notes={{mark since c++17}}|{{ttb|__has_include}} {{ttb|(}} {{spar|字符串字面量}} {{ttb|)}}&lt;br&gt;{{ttb|__has_include}} {{ttb|(}} {{ttb|&amp;lt;}} {{spar|h记号序列}} {{ttb|&amp;gt;}} {{ttb|)}}
}}
{{sdsc end}}

@1@ 搜索由{{spar sep|h字符序列}}唯一识别的标头，并将该指令替换为这个标头的全部内容。

@2@ 搜索由{{spar sep|q字符序列}}识别的源文件，并将该指令替换为这个源文件的全部内容。可能退回至语法 {{v|1}} 并将{{spar sep|q字符序列}}视为标头标识符。

@3@ 如果 {{v|1}} 和 {{v|2}} 都不匹配，{{spar sep|记号序列}}会经历宏替换。该指令在替换后会再次尝试匹配 {{v|1}} 和 {{v|2}}。

@4@ 检查是否可以包含一个标头或源文件。

@5@ 如果 {{v|4}} 不匹配，{{spar sep|h记号序列}}会经历宏替换。该指令在替换后会再次尝试匹配 {{v|4}}。

{{par begin}}
{{par|{{spar|换行}}|换行字符}}
{{par|{{spar|h字符序列}}|一个或多个{{spar sep|h字符}}的序列，并且其中以下内容的出现受条件性支持：
* 字符 {{c|'}}
* 字符 {{c|"}}
* 字符 {{c|\}}
* 字符序列 {{c|//}}
* 字符序列 {{c|/*}}}}
{{par|{{spar|h字符}}|{{rev inl|until=c++23|[[cpp/language/translation phases#阶段 5|源字符集]]}}{{rev inl|since=c++23|[[cpp/language/charset#翻译字符集|翻译字符集]]}} 除了换行符和 {{c|&gt;}} 以外的任何成员}}
{{par|{{spar|q字符序列}}|一个或多个{{spar sep|q字符}}的序列，并且其中以下内容的出现受条件性支持：
* 字符 {{c|'}}
* 字符 {{c|\}}
* 字符序列 {{c|//}}
* 字符序列 {{c|/*}}}}
{{par|{{spar|q字符}}|{{rev inl|until=c++23|[[cpp/language/translation phases#阶段 5|源字符集]]}}{{rev inl|since=c++23|{{ls|cpp/language/charset#翻译字符集}}}} 除了换行符和 {{c|"}} 以外的任何成员}}
{{par|{{spar|记号序列}}|一个或多个{{ls|cpp/language/translation phases#预处理记号}}的序列}}
{{par|{{spar|字符串字面量}}|一个[[cpp/language/string literal|字符串字面量]]}}
{{par|{{spar|h记号序列}}|一个或多个除了 {{c|&gt;}} 以外的{{ls|cpp/language/translation phases#预处理记号}}的序列}}
{{par end}}

===解释===
@1@ 在一系列地点中搜索由{{spar sep|h字符序列}}唯一识别的标头，并将该指令替换为这个标头的全部内容。由实现定义如何指定这些地点和识别标头。

@2@ 将该指令替换为由{{spar sep|q字符序列}}识别的源文件的全部内容。所指名的源文件通过由实现定义的方式进行搜索。
@@ 如果不支持这种搜索或者搜索失败，该指令按语法 {{v|1}} 重新处理，将原指令中包含的序列（包括 {{c|&gt;}} 字符，如果存在）作为语法 {{v|1}} 中所需的序列。

@3@ 该指令中 {{ttb|include}} 后面的预处理记号会按在正常文本中进行处理（即每个目前定义为宏名的标识符都会被替换为它的预处理记号替换列表）。
@@ 如果在所有替换都完成后生成的指令不匹配前面两种语法，那么行为未定义。
@@ 将在一对预处理记号 {{c|&lt;}} 和 {{c|&gt;}} 之间或一对 {{c|"}} 字符之前的预处理记号序列合并为单个头名预处理记号的方法由实现定义。

@4@ 搜索由{{spar sep|h字符序列}}或{{spar sep|q字符序列}}识别的标头或源文件，如同通过将该预处理记号序列作为语法 {{v|3}} 中的{{spar sep|记号序列}}的方法进行搜索，但不会实施后续的宏展开。
* 如果刚才的语法 {{v|3}} 指令不满足 {{c/core|#include}} 指令的语法要求，那么程序非良构。
* 否则 {{tt|__has_include}} 表达式在搜索成功时求值为 {{c|1}}，在搜索失败时求值为 {{c|0}}。

@5@ 只有在不匹配 {{v|4}} 才会选择此形式，此时预处理记号会按在正常文本中进行处理。

{{rrev|since=c++20|
如果由{{spar|标头名}}（即 {{ttb|&amp;lt;}} {{spar|h字符序列}} {{ttb|&amp;gt;}} 或 {{ttb|"}} {{spar|q字符序列}} {{ttb|"}}）标识的标头指明了一个可以导入的标头，那么由实现决定要包含这个标头的 {{c/core|#include}} 预处理指令是否要被替换为具有以下形式的[[cpp/language/modules#导入模块和标头|导入指令]]：

{{ttb|import}} {{spar|标头名}} {{ttb|;}} {{spar|换行}}
}}

{{tt|__has_include}} 可以在 {{ltt|cpp/preprocessor/conditional|#if}} 和 {{ltt|cpp/preprocessor/conditional|#elif}} 的表达式中展开。它被 {{ltt|cpp/preprocessor/conditional|#ifdef}}，{{ltt|cpp/preprocessor/conditional|#ifndef}}{{rev inl|since=c++23|，{{ltt|cpp/preprocessor/conditional|#elifdef}}，{{ltt|cpp/preprocessor/conditional|#elifndef}}}} 和 {{ltt|cpp/preprocessor/conditional|defined}} 视为已定义的宏，但不能在其他任何地方使用。

===注解===
语法 {{v|1}} 的意图是搜索由实现所掌控的文件。典型实现仅搜索标准包含目录。这些标准包含目录中隐含地包含标准 C++ 库和标准 C 库。用户通常能通过编译器选项来控制标准包含目录。

语法 {{v|2}} 的意图是搜索不被实现所掌控的文件。典型实现首先于当前文件所在的目录搜索，然后退回使用语法 {{v|1}}。

包含一个文件时，它将经过[[cpp/language/translation phases|翻译阶段]] 1-4 的处理，这可能递归地包含嵌套 {{c/core|#include}} 指令的展开，直到一个由实现定义的嵌套限制。为避免（可能传递性地）重复包含相同文件，和由文件包含自身造成的无限递归，通常使用''头文件防护''：整个头文件被包装在下列结构中
{{source|1=
#ifndef FOO_H_INCLUDED /* 任何唯一地映射到文件名的名称 */
#define FOO_H_INCLUDED
// 文件内容在此
#endif
}}
许多编译器也会实现有类似效果的非标准{{lt|cpp/preprocessor/impl|语用}} {{c|#pragma once}}：在已经包含相同文件（文件的身份以操作系统指定的方式确定）的时候禁止处理该文件。

如果{{spar sep|h字符序列}}或{{spar sep|q字符序列}}中包含了类似转义序列的序列，那么根据实现可能会导致错误，被处理为转义序列对应的字符，或者具有完全不同的含义。

结果是 {{c|1}} 的 {{tt|__has_include}} 只表明存在有指定名称的头或源文件。它并不意味着包含该头或源文件时不会导致错误，或它会包含任何有意义的内容。例如在同时支持 C++14 和 C++17 模式（并在其 C++14 模式作为一项遵从标准的扩展而提供 {{c|__has_include}}）的 C++ 实现上，{{c|__has_include(&lt;optional&gt;)}} 在 C++14 模式中可以是 {{c|1}}，但实际上 {{c|#include &lt;optional&gt;}} 可能导致错误。

===示例===
{{example|code=
#if __has_include(&lt;optional&gt;)
    #include &lt;optional&gt;
    #define has_optional 1
    template&lt;class T&gt;
    using optional_t = std::optional&lt;T&gt;;
#elif __has_include(&lt;experimental/optional&gt;)
    #include &lt;experimental/optional&gt;
    #define has_optional -1
    template&lt;class T&gt;
    using optional_t = std::experimental::optional&lt;T&gt;;
#else
    #define has_optional 0
    template&lt;class V&gt;
    class optional_t
    {
        V v{};
        bool has{};

    public:
        optional_t() = default;
        optional_t(V&amp;&amp; v) : v(v), has{true} {}
        V value_or(V&amp;&amp; alt) const&amp;
        {
            return has ? v : alt;
        }
        // etc.
    };
#endif

#include &lt;iostream&gt;

int main()
{
    if (has_optional &gt; 0)
        std::cout &lt;&lt; "&lt;optional&gt; 存在\n";
    else if (has_optional &lt; 0)
        std::cout &lt;&lt; "&lt;experimental/optional&gt; 存在\n";
    else
        std::cout &lt;&lt; "&lt;optional&gt; 不存在\n";

    optional_t&lt;int&gt; op;
    std::cout &lt;&lt; "op = " &lt;&lt; op.value_or(-1) &lt;&lt; '\n';
    op = 42;
    std::cout &lt;&lt; "op = " &lt;&lt; op.value_or(-1) &lt;&lt; '\n';
}
|output=
&lt;optional&gt; 存在
op = -1
op = 42
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=787|std=C++98|before=如果{{spar sep|h字符序列}}或{{spar sep|q字符序列}}中包含了类似转义序列的序列，那么行为未定义|after=改为受条件性支持}}
{{dr list end}}

===参阅===
* [[cpp/preprocessor/embed|资源包含 {{mark since c++26}}]]
{{dsc begin}}
{{dsc|[[cpp/header|C++ 标准库头文件列表]]}}
{{dsc see c|c/preprocessor/include|源文件包含|nomono=true}}
{{dsc end}}

{{langlinks|ar|de|en|es|fr|it|ja|pl|pt|ru}}