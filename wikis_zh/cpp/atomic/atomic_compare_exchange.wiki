{{cpp/title|atomic_compare_exchange_weak|atomic_compare_exchange_strong|atomic_compare_exchange_weak_explicit|atomic_compare_exchange_strong_explicit}}
{{cpp/thread/navbar}}
{{dcl begin}}
{{dcl header|atomic}}
{{dcl|num=1|since=c++11|
template&lt; class T &gt;
bool atomic_compare_exchange_weak
    ( std::atomic&lt;T&gt;* obj, typename std::atomic&lt;T&gt;::value_type* expected,
      typename std::atomic&lt;T&gt;::value_type desired ) noexcept;
}}
{{dcl|num=2|since=c++11|
template&lt; class T &gt;
bool atomic_compare_exchange_weak
    ( volatile std::atomic&lt;T&gt;* obj,
      typename std::atomic&lt;T&gt;::value_type* expected,
      typename std::atomic&lt;T&gt;::value_type desired ) noexcept;
}}
{{dcl|num=3|since=c++11|
template&lt; class T &gt;
bool atomic_compare_exchange_strong
    ( std::atomic&lt;T&gt;* obj, typename std::atomic&lt;T&gt;::value_type* expected,
      typename std::atomic&lt;T&gt;::value_type desired ) noexcept;
}}
{{dcl|num=4|since=c++11|
template&lt; class T &gt;
bool atomic_compare_exchange_strong
    ( volatile std::atomic&lt;T&gt;* obj,
      typename std::atomic&lt;T&gt;::value_type* expected, 
      typename std::atomic&lt;T&gt;::value_type desired ) noexcept;
}}
{{dcl|num=5|since=c++11|
template&lt; class T &gt;
bool atomic_compare_exchange_weak_explicit
    ( std::atomic&lt;T&gt;* obj, typename std::atomic&lt;T&gt;::value_type* expected, 
      typename std::atomic&lt;T&gt;::value_type desired,
      std::memory_order success, std::memory_order failure ) noexcept;
}}
{{dcl|num=6|since=c++11|
template&lt; class T &gt;
bool atomic_compare_exchange_weak_explicit
    ( volatile std::atomic&lt;T&gt;* obj,
      typename std::atomic&lt;T&gt;::value_type* expected, 
      typename std::atomic&lt;T&gt;::value_type desired,
      std::memory_order success, std::memory_order failure ) noexcept;
}}
{{dcl|num=7|since=c++11|
template&lt; class T &gt;
bool atomic_compare_exchange_strong_explicit
    ( std::atomic&lt;T&gt;* obj, typename std::atomic&lt;T&gt;::value_type* expected, 
      typename std::atomic&lt;T&gt;::value_type desired,
      std::memory_order success, std::memory_order failure ) noexcept;
}}
{{dcl|num=8|since=c++11|
template&lt; class T &gt;
bool atomic_compare_exchange_strong_explicit
    ( volatile std::atomic&lt;T&gt;* obj,
      typename std::atomic&lt;T&gt;::value_type* expected, 
      typename std::atomic&lt;T&gt;::value_type desired,
      std::memory_order success, std::memory_order failure ) noexcept;
}}
{{dcl end}}

原子地比较 {{c|obj}} 指向的对象与 {{c|expected}} 指向的对象的{{rev inl|until=c++20|[[cpp/language/object|对象表示]]}}{{rev inl|since=c++20|[[cpp/language/object|值表示]]}}，如果它们逐位相等，那么以 {{c|desired}} 替换前者（进行读修改写操作）。否则，将 {{c|obj}} 指向的对象的实际值加载到 {{c|*expected}} 中（进行加载操作）。

{|class="wikitable" style="text-align: center;"
!重载
!读修改写操作的内存模型
!加载操作的内存模型
|-
|{{nbsp}}{{v|1-4}}{{nbsp}}
|{{nbsp}}{{c|std::memory_order_seq_cst}}{{nbsp}}
|{{nbsp}}{{c|std::memory_order_seq_cst}}{{nbsp}}
|-
|{{v|5-8}}
|{{c|success}}
|{{c|failure}}
|}

这些函数用 {{lc|std::atomic}} 的[[cpp/atomic/atomic/compare_exchange|成员函数]]定义：
@1,2@ {{c|obj-&gt;compare_exchange_weak(*expected, desired)}}
@3,4@ {{c|obj-&gt;compare_exchange_strong(*expected, desired)}}
@5,6@ {{c|obj-&gt;compare_exchange_weak(*expected, desired, success, failure)}}
@7,8@ {{c|obj-&gt;compare_exchange_strong(*expected, desired, success, failure)}}

如果 {{c|failure}} {{rev inl|until=c++17|强于 {{c|success}} 或者}}是 {{c|std::memory_order_release}} 和 {{c|std::memory_order_acq_rel}} 之一，那么行为未定义。

===参数===
{{par begin}}
{{par|obj|指向要测试和修改的原子对象的指针}}
{{par|expected|指向期待在原子对象中找到的值的指针}}
{{par|desired|在符合期待时存储到原子对象的值}}
{{par|success|读修改写操作所用的内存同步定序}}
{{par|failure|加载操作所用的内存同步定序}}
{{par end}} 

===返回值===
比较结果：如果 {{c|*obj}} 等于 {{c|*expected}}，那么返回 {{c|true}}，否则返回 {{c|false}}。

===注意===
{{tt|std::atomic_compare_exchange_weak}} 和 {{tt|std::atomic_compare_exchange_weak_explicit}}（即弱版本）允许假性失败，即即使它们相等也表现为如同 {{c|1=*obj != *expected}}。当在循环中进行比较并交换时，弱版本在某些平台上会生成更好的性能。

在弱版本会要求循环而强版本不要求时，更偏好强版本，除非 {{tt|T}} 的对象表示可能包含{{rev inl|until=c++20|填充位、}}陷阱位，或者为一个值提供多个对象表示（例如浮点 NaN）。这些情况下，弱的比较并交换经常有用，因为它在某些稳定对象表示上快速收敛。

对于联合体，如果它持有某些只有部分成员的值表示有参与的位，那么比较和交换可能总会失败，因为这种填充位在不参与活跃成员的值表示时拥有不确定值。

{{rrev|since=c++20|
忽略决不参与对象值表示的填充位。
}}

===示例===
{{example
|比较和交换操作通常用作{{enwiki|Non-blocking algorithm|无锁}}数据结构的基本组成部分。
|code=
#include &lt;atomic&gt;

template&lt;class T&gt;
struct node
{
    T data;
    node* next;
    node(const T&amp; data) : data(data), next(nullptr) {}
};

template&lt;class T&gt;
class stack
{
    std::atomic&lt;node&lt;T&gt;*&gt; head;
public:
    void push(const T&amp; data)
    {
        node&lt;T&gt;* new_node = new node&lt;T&gt;(data);
        
        // 将 head 的当前值放入 new_node-&gt;next
        new_node-&gt;next = head.load(std::memory_order_relaxed);
        
        // 现在令 new_node 为新的 head，
        // 但如果 head 不再存储在 new_node-&gt;next 中
        // （某些其他线程必须已在现在插入节点）
        // 那么将新的 head 放入 new_node-&gt;next 并重试
        while (!std::atomic_compare_exchange_weak_explicit(
                   &amp;head, &amp;new_node-&gt;next, new_node,
                   std::memory_order_release, std::memory_order_relaxed))
            ; // 循环体为空
// 注意：上述循环非线程安全，至少在
// 早于 4.8.3 的 GCC（bug 60272），早于 2014-05-05 的 clang（bug 18899）
// 早于 2014-03-17 的 MSVC（bug 819819）是这样。变通方法见成员函数版本。
    }
};

int main()
{
    stack&lt;int&gt; s;
    s.push(1);
    s.push(2);
    s.push(3);
}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|std=C++11|paper=P0558R1|before=要求准确类型匹配，因为会从多个参数推导 {{tt|T}}|after=只会从 {{c|obj}} 推导 {{tt|T}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/atomic/atomic/dsc compare_exchange}}
{{dsc inc|cpp/atomic/dsc atomic_exchange}}
{{dsc break}}
{{dsc tfun|cpp/memory/shared_ptr/atomic|notes={{mark life|deprecated=c++20|removed=c++26|br=yes}}|title=std::atomic_compare_exchange_weak{{dsc small|(std::shared_ptr)}}
&lt;br&gt;std::atomic_compare_exchange_strong{{dsc small|(std::shared_ptr)}}|为 {{lc|std::shared_ptr}} 特化原子操作}}
{{dsc see c|c/atomic/atomic_compare_exchange|atomic_compare_exchange|atomic_compare_exchange_explicit}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}