{{cpp/atomic/atomic_ref/title|atomic_ref}}
{{cpp/atomic/atomic_ref/navbar}}
{{dcl begin}}
{{dcla|num=1|constexpr=c++26|
explicit atomic_ref( T&amp; obj );
}}
{{dcla|num=2|constexpr=c++26|
atomic_ref( const atomic_ref&amp; ref ) noexcept;
}}
{{dcl end}}

构造新的 {{tt|atomic_ref}} 对象。

@1@ 构造引用对象 {{tt|obj}} 的 {{tt|atomic_ref}} 对象。
@@ 如果 {{tt|obj}} 未对齐到 {{rlpt|required_alignment}}，那么行为未定义。

@2@ 构造引用 {{tt|ref}} 所引用对象的 {{tt|atomic_ref}} 对象。

===参数===
{{par begin}}
{{par|obj|所引用的对象}}
{{par|ref|要复制的另一 {{tt|atomic_ref}} 对象}}
{{par end}}

===示例===
{{example
|本程序使用几个线程来增加容器中的各值。然后打印最终的和。非原子访问可能因数据竞争而“丢失”一些运算的结果。
|code=
#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

int main()
{
    using Data = std::vector&lt;char&gt;;
    
    auto inc_atomically = [](Data&amp; data)
    {
        for (Data::value_type&amp; x : data)
        {
            auto xx = std::atomic_ref&lt;Data::value_type&gt;(x);
            ++xx; // 原子读-改-写操作
        }
    };
    
    auto inc_directly = [](Data&amp; data)
    {
        for (Data::value_type&amp; x : data)
            ++x;
    };
    
    auto test_run = [](const auto Fun)
    {
        Data data(10'000'000);
        {
            std::jthread j1{Fun, std::ref(data)};
            std::jthread j2{Fun, std::ref(data)};
            std::jthread j3{Fun, std::ref(data)};
            std::jthread j4{Fun, std::ref(data)};
        }
        std::cout &lt;&lt; "sum = " &lt;&lt; std::accumulate(cbegin(data), cend(data), 0) &lt;&lt; '\n';
    };
    
    test_run(inc_atomically);
    test_run(inc_directly);
}
|p=true
|output=
sum = 40000000
sum = 39994973
}}

{{langlinks|de|en|es|ja|ru}}