{{cpp/atomic/atomic_ref/title|1=operator+=,-=}}
{{cpp/atomic/atomic_ref/navbar}}
{{dcl begin}}
{{dcl h|仅当 {{tt|T}} 为 ''cv'' {{c/core|bool}} 以外的算术类型或指向对象的指针类型时提供}}
{{dcla|num=1|constexpr=c++26|1=
value_type operator+=( difference_type arg ) const noexcept;
}}
{{dcla|num=2|constexpr=c++26|1=
value_type operator-=( difference_type arg ) const noexcept;
}}
{{dcl end}}

原子地以涉及先前被 {{box|{{c/core|*}}{{rlpsi|/#ptr}}}} 引用的值和 {{c|arg}} 的运算的结果替换被引用对象的当前值。这些操作是读修改写操作。
@1@ {{c/core|1=operator+=}} 进行原子加法。等价于 {{c|return fetch_add(arg) + arg;}}。
@2@ {{c/core|1=operator-=}} 进行原子减法。等价于 {{c|return fetch_sub(arg) - arg;}}。

* 对于有符号整数类型，定义算术为使用补码进行。不会有未定义的结果。
* 对于浮点类型，生效的[[cpp/numeric/fenv|浮点环境]]可能异于调用方线程的浮点环境。不需要操作服从对应的 {{lc|std::numeric_limits}} 特性，但鼓励这么做。如果结果无法以它的类型表示，那么结果未指定，但操作不会另有未定义行为。
* 对于指针类型，结果可以是未定义的地址，但操作不会另有未定义行为。
** 如果 {{c/core|std::remove_pointer_t&lt;T&gt;}} 不是完整对象类型，那么程序非良构。

{{cpp/enable if|plural=yes| {{c/core|std::is_const_v&lt;T&gt;}} 是 {{c|false}} }}。

===参数===
{{par begin}}
{{par|arg|算术运算的实参}}
{{par end}}

===返回值===
结果值（即对紧接对应的成员函数生效之前的被 {{box|{{c/core|*}}{{rlpsi|/#ptr}}}} 引用的值应用对应的二元运算符的结果）。

===注解===
与大多数复合赋值运算符不同，{{tt|atomic_ref}} 的复合赋值运算符并不返回到 {{c|arg}} 的引用，而是返回存储的值的副本。

===示例===
{{example}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3508|paper=P3323R1|std=C++20|before=复合赋值运算符对 {{c/core|const T}} 无意义|after=受约束以仅接受非 const 的 {{tt|T}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/atomic/atomic_ref/dsc fetch_add}}
{{dsc inc|cpp/atomic/atomic_ref/dsc fetch_sub}}
{{dsc inc|cpp/atomic/atomic_ref/dsc operator arith}}
{{dsc inc|cpp/atomic/atomic_ref/dsc operator arith3}}
{{dsc end}}

{{langlinks|en|es|ja}}