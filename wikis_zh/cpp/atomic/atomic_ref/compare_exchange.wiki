{{cpp/atomic/atomic_ref/title|compare_exchange_weak|compare_exchange_strong}}
{{cpp/atomic/atomic_ref/navbar}}

{{dcl begin}}
{{dcla|num=1|constexpr=c++26|
bool compare_exchange_weak
    ( value_type&amp; expected, value_type desired,
      std::memory_order success, 
      std::memory_order failure ) const noexcept;
}}
{{dcla|num=2|constexpr=c++26|1=
bool compare_exchange_weak
    ( value_type&amp; expected, value_type desired,
      std::memory_order order =
          std::memory_order_seq_cst ) const noexcept;
}}
{{dcla|num=3|constexpr=c++26|
bool compare_exchange_strong
    ( value_type&amp; expected, value_type desired,
      std::memory_order success,
      std::memory_order failure ) const noexcept;
}}
{{dcla|num=4|constexpr=c++26|1=
bool compare_exchange_strong
    ( value_type&amp; expected, value_type desired,
      std::memory_order order =
          std::memory_order_seq_cst ) const noexcept;
}}
{{dcl end}}

原子地比较被引用对象的[[cpp/language/object|值表示]]与 {{c|expected}} 的值表示，如果它们逐位相等，那么就会以 {{c|desired}} 替换前者（进行读修改写操作）。否则，将存储于被引用对象的实际值加载到 {{c|expected}} 中（进行加载操作）。

@1,3@ 读修改写和加载操作的内存模型分别是 {{c|success}} 和 {{c|failure}}。

@2,4@ {{c|order}} 同时用于读修改写操作和加载操作，除了在 {{c|order}} 是 {{c|std::memory_order_acq_rel}} 或 {{c|std::memory_order_release}} 时会分别将 {{c|std::memory_order_acquire}} 或 {{c|std::memory_order_relaxed}} 用于加载操作。

{{cpp/enable if|plural=yes| {{c|std::is_const_v&lt;T&gt;}} 是 {{c|false}} }}。

如果 {{c|failure}} 不是 {{c|std::memory_order_relaxed}}，{{c|std::memory_order_consume}}，{{c|std::memory_order_acquire}} 或 {{c|std::memory_order_seq_cst}}，那么行为未定义。

===参数===
{{par begin}}
{{par|expected|到期待在 {{tt|atomic_ref}} 所引用对象中找到的值的引用}}
{{par|desired|满足期待时要存储于被引用对象中的值}}
{{par|success|比较成功时用于读修改写操作的内存同步定序}}
{{par|failure|比较失败时用于加载操作的内存同步定序}}
{{par|order|两个操作的内存同步定序}}
{{par end}}

===返回值===
成功更改被引用数据时返回 {{c|true}}，否则返回 {{c|false}}。

===注解===
比较和复制是逐位的（类似 {{lc|std::memcmp}} 和 {{lc|std::memcpy}}）；不使用构造函数、赋值运算符或比较运算符。

允许弱形式 {{v|1,2}} 假性失败，即表现为 {{c|1=*this != expected}}，即使它们相等。在循环中进行比较并交换时，弱版本在某些平台上将产生较好的性能。

在弱比较并交换会要求循环，而强版本不会要求时，最好用强版本，除非 {{tt|value_type}} 的对象表示可能包含陷阱位，或相同值有多种对象表示（例如浮点 NaN）。那些情况下，弱比较并交换通常均可用，因为它在某些稳定的对象表示上快速收敛。

如果联合体存在有参与某些成员的值表示而没有参与另一些成员的值表示的位，那么比较并交换可能始终失败，因为这种填充位在不参与活跃成员的值表示时拥有不确定值。

忽略决不参与对象值表示的填充位。

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3508|paper=P3323R1|std=C++20|before={{tt|compare_exchange_weak}} 与 {{tt|compare_exchange_strong}} 对 {{c/core|const T}} 无意义|after=受约束以仅接受非 const 的 {{tt|T}}}}
{{dr list end}}

===示例===
{{example}}

{{langlinks|en|es|ja}}