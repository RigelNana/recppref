{{cpp/title|atomic_fetch_xor|atomic_fetch_xor_explicit}}
{{cpp/thread/navbar}}
{{dcl begin}}
{{dcl header|atomic}}
{{dcl|num=1|since=c++11|
template&lt; class T &gt;
T atomic_fetch_xor( std::atomic&lt;T&gt;* obj,
                    typename std::atomic&lt;T&gt;::value_type arg ) noexcept;
}}
{{dcl|num=2|since=c++11|
template&lt; class T &gt;
T atomic_fetch_xor( volatile std::atomic&lt;T&gt;* obj,
                    typename std::atomic&lt;T&gt;::value_type arg ) noexcept;
}}
{{dcl|num=3|since=c++11|
template&lt; class T &gt;
T atomic_fetch_xor_explicit( std::atomic&lt;T&gt;* obj,
                             typename std::atomic&lt;T&gt;::value_type arg, 
                             std::memory_order order) noexcept;
}}
{{dcl|num=4|since=c++11|
template&lt; class T &gt;
T atomic_fetch_xor_explicit( volatile std::atomic&lt;T&gt;* obj,
                             typename std::atomic&lt;T&gt;::value_type arg,
                             std::memory_order order) noexcept;
}}
{{dcl end}}

以 {{c|obj}} 的旧值和 {{c|arg}} 的逐位异或结果原子地替换 {{c|obj}} 指向的值。返回 {{c|obj}} 先前保有的值。

如同执行下列内容一般进行运算：
@1,2@ {{c|obj-&gt;fetch_xor(arg)}}
@3,4@ {{c|obj-&gt;fetch_xor(arg, order)}}

如果 {{tt|std::atomic&lt;T&gt;}} 没有 {{tt|fetch_xor}} 成员（此成员仅对 {{c/core|bool}} 以外的{{rlp|atomic#对整数类型的特化|整数类型}}提供），那么程序非良构。

===参数===
{{par begin}}
{{par|obj|指向要修改的原子对象的指针}}
{{par|arg|要和存储到原子对象的值逐位异或的值}}
{{par|order|内存同步定序}}
{{par end}} 

===返回值===
{{c|*obj}} 的{{ls|cpp/atomic/memory order#修改顺序}}中，紧接此函数生效之前的值。

===示例===
{{example}}

===缺陷报告===
{{dr list begin}}
{{dr list item|std=C++11|paper=P0558R1|before=要求准确类型匹配，因为会从多个参数推导 {{tt|T}}|after=只会从 {{c|obj}} 推导 {{tt|T}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/atomic/atomic/dsc fetch_xor|mem=std::atomic&lt;T&gt;}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_or}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_and}}
{{dsc see c|c/atomic/atomic_fetch_xor|atomic_fetch_xor|atomic_fetch_xor_explicit}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}