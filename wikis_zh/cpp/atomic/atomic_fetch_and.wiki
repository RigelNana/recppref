{{cpp/title|atomic_fetch_and|atomic_fetch_and_explicit}}
{{cpp/thread/navbar}}
{{dcl begin}}
{{dcl header|atomic}}
{{dcl|num=1|since=c++11|
template&lt; class T &gt;
T atomic_fetch_and( std::atomic&lt;T&gt;* obj,
                    typename std::atomic&lt;T&gt;::value_type arg ) noexcept;
}}
{{dcl|num=2|since=c++11|
template&lt; class T &gt;
T atomic_fetch_and( volatile std::atomic&lt;T&gt;* obj,
                    typename std::atomic&lt;T&gt;::value_type arg ) noexcept;
}}
{{dcl|num=3|since=c++11|
template&lt; class T &gt;
T atomic_fetch_and_explicit( std::atomic&lt;T&gt;* obj,
                             typename std::atomic&lt;T&gt;::value_type arg, 
                             std::memory_order order ) noexcept;
}}
{{dcl|num=4|since=c++11|
template&lt; class T &gt;
T atomic_fetch_and_explicit( volatile std::atomic&lt;T&gt;* obj,
                             typename std::atomic&lt;T&gt;::value_type arg,
                             std::memory_order order ) noexcept;
}}
{{dcl end}}

以 {{c|obj}} 的旧值和 {{c|arg}} 的逐位与结果原子地替换 {{c|obj}} 所指向的值。返回 {{c|obj}} 先前保有的值。

如同执行下列内容一般进行操作：
@1,2@ {{c|obj-&gt;fetch_and(arg)}}
@3,4@ {{c|obj-&gt;fetch_and(arg, order)}}

如果 {{tt|std::atomic&lt;T&gt;}} 没有 {{tt|fetch_and}} 成员（此成员仅对 {{c/core|bool}} 以外的{{rlp|atomic#对整数类型的特化|整数类型}}提供），那么程序非良构。

===参数===
{{par begin}}
{{par|obj|指向要修改的对象的指针}}
{{par|arg|与存储于原子对象的值逐位与的值}}
{{par|order|内存同步定序}}
{{par end}}

===返回值===
{{c|*obj}} 的{{ls|cpp/atomic/memory order#修改顺序}}中，紧接此函数生效之前的值。

===示例===
{{include|cpp/atomic/atomic fetch cond example}}

===缺陷报告===
{{dr list begin}}
{{dr list item|std=C++11|paper=P0558R1|before=要求准确类型匹配，因为会从多个参数推导 {{tt|T}}|after=只会从 {{c|obj}} 推导 {{tt|T}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/atomic/atomic/dsc fetch_and}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_or}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_xor}}
{{dsc see c|c/atomic/atomic_fetch_and|atomic_fetch_and|atomic_fetch_and_explicit}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}