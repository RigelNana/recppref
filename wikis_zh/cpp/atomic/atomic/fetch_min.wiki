{{cpp/atomic/atomic/title|fetch_min}}
{{cpp/atomic/atomic/navbar}}
{{dcl begin}}
{{dcl h|{{tt|atomic&lt;}}''整数类型''{{sep}}{{tt|&gt;}} 特化才有的成员}}
{{dcl|num=1|since=c++26|1=
T fetch_min( T arg, std::memory_order order =
                        std::memory_order_seq_cst ) noexcept;
}}
{{dcl|num=2|since=c++26|1=
T fetch_min( T arg, std::memory_order order =
                        std::memory_order_seq_cst ) volatile noexcept;
}}
{{dcl h|{{tt|atomic&lt;T*&gt;}} 部分特化才有的成员}}
{{dcl|num=3|since=c++26|1=
T* fetch_min( T* arg, std::memory_order order =
                          std::memory_order_seq_cst ) noexcept;
}}
{{dcl|num=4|since=c++26|1=
T* fetch_min( T* arg, std::memory_order order =
                          std::memory_order_seq_cst ) volatile noexcept;
}}
{{dcl end}}

以值和 {{c|arg}} 的 {{lc|std::min}} 结果原子地替换当前值。运算是读-修改-写操作。按照 {{c|order}} 的值影响内存。

@3,4@ 如果指针指向不同的对象（或不同对象的子对象），那么[[cpp/language/operator comparison#内建指针关系比较|指针比较]]不会建立{{enwiki|strict weak ordering|严格弱序}}。

重载 {{v|2}} 或 {{v|4}} 在参与重载决议且 {{c|std::atomic&lt;T&gt;::is_always_lock_free}} 是 {{c|false}} 时被弃用。

===参数===
{{par begin}}
{{par|arg|{{lc|std::min}} 的另一实参}}
{{par|order|强制的内存定序约束}}
{{par end}}

===返回值===
{{c|*this}} 的{{ls|cpp/atomic/memory order#修改顺序}}中，紧接此函数生效之前的值。

===注解===
{{feature test macro|__cpp_lib_atomic_min_max|原子最小/最大操作|value=202403L|std=C++26}}

===示例===
{{example}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}