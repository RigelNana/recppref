{{cpp/atomic/atomic/title|is_lock_free}}
{{cpp/atomic/atomic/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++11|
bool is_lock_free() const noexcept;
}}
{{dcl|num=2|since=c++11|
bool is_lock_free() const volatile noexcept;
}}
{{dcl end}}

检查此类型所有对象上的原子操作是否免锁。

===参数===
（无）

===返回值===
在此类型所有对象上的原子操作免锁的情况下返回 {{c|true}}，否则返回 {{c|false}}。

===注解===
{{lc|std::atomic_flag}} 以外的所有原子类型可用互斥体或其他锁定操作实现，而不一定用免锁的原子 CPU 指令。也允许原子类型''有时''{{sep}}免锁，例如给定架构上仅对齐的内存访问是天然原子的，此时同类型的未对齐对象就必须用锁。

C++ 标准推荐（但不要求）免锁操作都是免地址的，即适用于使用共享内存的进程间交流。

===示例===
{{example|code=
#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;

struct A { int a[100]; };
struct B { int x, y; };

int main()
{
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; "std::atomic&lt;A&gt; 是否免锁？"
              &lt;&lt; std::atomic&lt;A&gt;{}.is_lock_free() &lt;&lt; '\n'
              &lt;&lt; "std::atomic&lt;B&gt; 是否免锁？"
              &lt;&lt; std::atomic&lt;B&gt;{}.is_lock_free() &lt;&lt; '\n';
}
|p=true
|output=
std::atomic&lt;A&gt; 是否免锁？false
std::atomic&lt;B&gt; 是否免锁？true
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/atomic/dsc atomic_is_lock_free}}
{{dsc tfun|cpp/memory/shared_ptr/atomic|title=atomic_is_lock_free{{dsc small|(std::shared_ptr)}}|对 {{lc|std::shared_ptr}} 特化原子操作}}
{{dsc inc|cpp/atomic/atomic/dsc is_always_lock_free}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}