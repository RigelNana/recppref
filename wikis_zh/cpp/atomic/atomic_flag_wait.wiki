{{cpp/title|atomic_flag_wait|atomic_flag_wait_explicit}}
{{cpp/thread/navbar}}
{{dcl begin}}
{{dcl header|atomic}}
{{dcl|num=1|since=c++20|
void atomic_flag_wait( const atomic_flag* object, bool old ) noexcept;
}}
{{dcl|num=2|since=c++20|
void atomic_flag_wait( const volatile atomic_flag* object,
                       bool old ) noexcept;
}}
{{dcl|num=3|since=c++20|
void atomic_flag_wait_explicit( const atomic_flag* object, 
                                bool old, std::memory_order order ) noexcept;
}}
{{dcl|num=4|since=c++20|
void atomic_flag_wait_explicit( const volatile atomic_flag* object,
                                bool old, std::memory_order order ) noexcept;
}}
{{dcl end}}

进行原子等待操作。

比较 {{c|object-&gt;test(std::memory_order_seq_cst)}} 或 {{c|object-&gt;test(order)}} 与 {{c|old}}，如果它们逐位相等，那么阻塞到加载结果的值表示发生更改或者 {{c|*this}} 被 {{l2tf std|cpp/atomic/atomic_flag/notify_one}} 或 {{l2tf std|cpp/atomic/atomic_flag/notify_all}} 提醒（或线程被虚假解除锁定）。
@1,2@ 内存同步定序是 {{c|std::memory_order_seq_cst}}。
@3,4@ 内存同步定序是 {{c|order}}。
@@ 如果 {{c|order}} 是 {{c|std::memory_order::release}} 和 {{c|std::memory_order::acq_rel}} 之一，那么行为未定义。

这些函数保证只有在值更改了的情况下才返回，即使底层实现发生虚假解除锁定。

===参数===
{{par begin}}
{{par|object|指向要检查并在其上等待的原子标志的指针}}
{{par|old|要检测的原子标志象不再含有的值}}
{{par|order|内存同步定序}}
{{par end}} 

===返回值===
（无）

===注解===
更改检测的这种形式通常比简单轮询或纯自旋锁高效。

由于 {{enwiki|ABA problem|ABA 问题}}，可能错失从 {{c|old}} 到另一值再回到 {{c|old}} 的更改，而不解除锁定。

===示例===
{{dsc begin}}
{{dsc inc|cpp/atomic/atomic/dsc notify_one|atomic_flag}}
{{dsc inc|cpp/atomic/atomic/dsc notify_all|atomic_flag}}
{{dsc inc|cpp/atomic/dsc atomic_flag_notify_one}}
{{dsc inc|cpp/atomic/dsc atomic_flag_notify_all}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}