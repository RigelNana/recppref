{{cpp/title|coroutine_handle|noop_coroutine_handle}}
{{cpp/coroutine/coroutine_handle/navbar}}
{{dcl begin}}
{{dcl header|coroutine}}
{{dcl|num=1|since=c++20|1=
template&lt; class Promise = void &gt;
struct coroutine_handle;
}}
{{dcl|num=2|since=c++20|
template&lt;&gt;
struct coroutine_handle&lt;void&gt;;
}}
{{dcl|num=3|since=c++20|
template&lt;&gt;
struct coroutine_handle&lt;std::noop_coroutine_promise&gt;;
}}
{{dcl|num=4|since=c++20|1=
using noop_coroutine_handle =
    std::coroutine_handle&lt;std::noop_coroutine_promise&gt;;
}}
{{dcl end}}

类模板 {{tt|coroutine_handle}} 能用于指代暂停或执行中的协程。{{tt|coroutine_handle}} 的每个特化均为{{named req|LiteralType}}。

@1@ 主模板，可从 {{tt|Promise}} 类型的承诺对象创建。

@2@ 特化 {{c|std::coroutine_handle&lt;void&gt;}} 擦除承诺类型。它可从其他特化转换。

@3@ 特化 {{c|std::coroutine_handle&lt;std::noop_coroutine_promise&gt;}} 指代无操作协程。不能从承诺对象创建它。

典型实现上，{{c|std::coroutine_handle}} 的每个特化均为{{named req|TriviallyCopyable}}。

{{cpp/types/nospec}}

===数据成员===
{{dsc begin}}
{{dsc hitem|成员名|定义}}
{{dsc|{{tti|ptr}} {{mark|private}}|指向协程状态的 {{c|void*}} 指针。&lt;br&gt;{{mark expos mem obj}}}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc constructor}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc operator{{=}}}}

{{dsc h2|转换}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc operator coroutine_handle void}}

{{dsc h2|观察器}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc done}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc operator bool}}

{{dsc h2|控制}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc resume}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc destroy}}

{{dsc h2|承诺访问}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc promise}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc from_promise}}

{{dsc h2|导出/导入}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc address}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc from_address}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc operator_cmp}}
{{dsc end}}

===辅助类===
{{dsc begin}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc hash}}
{{dsc end}}

===注解===
{{tt|coroutine_handle}} 可能悬垂，该情况下必须谨慎使用该 {{tt|coroutine_handle}} 以避免未定义行为。

===示例===
{{example
|code=
#include &lt;coroutine&gt;
#include &lt;iostream&gt;
#include &lt;optional&gt;

template&lt;std::movable T&gt;
class Generator
{
public:
    struct promise_type
    {
        Generator&lt;T&gt; get_return_object()
        {
            return Generator{Handle::from_promise(*this)};
        }
        static std::suspend_always initial_suspend() noexcept
        {
            return {};
        }
        static std::suspend_always final_suspend() noexcept
        {
            return {};
        }
        std::suspend_always yield_value(T value) noexcept
        {
            current_value = std::move(value);
            return {};
        }
        // 生成器协程中不允许 co_await。
        void await_transform() = delete;
        [[noreturn]]
        static void unhandled_exception() { throw; }

        std::optional&lt;T&gt; current_value;
    };

    using Handle = std::coroutine_handle&lt;promise_type&gt;;

    explicit Generator(const Handle coroutine) :
        m_coroutine{coroutine}
    {}

    Generator() = default;
    ~Generator()
    {
        if (m_coroutine)
            m_coroutine.destroy();
    }

    Generator(const Generator&amp;) = delete;
    Generator&amp; operator=(const Generator&amp;) = delete;

    Generator(Generator&amp;&amp; other) noexcept :
        m_coroutine{other.m_coroutine}
    {
        other.m_coroutine = {};
    }
    Generator&amp; operator=(Generator&amp;&amp; other) noexcept
    {
        if (this != &amp;other)
        {
            if (m_coroutine)
                m_coroutine.destroy();
            m_coroutine = other.m_coroutine;
            other.m_coroutine = {};
        }
        return *this;
    }

    // 基于范围的 for 循环支持。
    class Iter
    {
    public:
        void operator++()
        {
            m_coroutine.resume();
        }
        const T&amp; operator*() const
        {
            return *m_coroutine.promise().current_value;
        }
        bool operator==(std::default_sentinel_t) const
        {
            return !m_coroutine {{!!}} m_coroutine.done();
        }

        explicit Iter(const Handle coroutine) :
            m_coroutine{coroutine}
        {}

    private:
        Handle m_coroutine;
    };

    Iter begin()
    {
        if (m_coroutine)
            m_coroutine.resume();
        return Iter{m_coroutine};
    }

    std::default_sentinel_t end() { return {}; }

private:
    Handle m_coroutine;
};

template&lt;std::integral T&gt;
Generator&lt;T&gt; range(T first, const T last)
{
    while (first &lt; last)
        co_yield first++;
}

int main()
{
    for (const char i : range(65, 91))
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3460|std=C++20|before={{tt|coroutine_handle}} 的公开基类能将它置于不想要的状态|after=移除继承}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc generator}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}