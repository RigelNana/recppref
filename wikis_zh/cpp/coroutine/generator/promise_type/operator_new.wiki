{{cpp/title|{{small|generator&lt;Ref,V,Allocator&gt;::promise_type::}}operator new}}
{{cpp/coroutine/generator/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++23|
void* operator new( std::size_t size )
    requires std::same_as&lt;Allocator, void&gt; {{!!}}
             std::default_initializable&lt;Allocator&gt;;
}}
{{dcla|num=2|since=c++23|
template&lt; class Alloc, class... Args &gt;
void* operator new( std::size_t size, std::allocator_arg_t,
                    const Alloc&amp; alloc, const Args&amp;... );
}}
{{dcl|num=3|since=c++23|
template&lt; class This, class Alloc, class... Args &gt;
void* operator new( std::size_t size, const This&amp;, std::allocator_arg_t,
                    const Alloc&amp; alloc, const Args&amp;... );
}}
{{dcl end}}

使用默认或用户提供的分配器[[cpp/language/coroutines#动态分配|分配]] {{c|size}} 个字节的未初始化存储。

令 {{tt|A}} 为
* {{tt|Allocator}}，若其并非 {{c/core|void}}，
* {{tt|Alloc}} 对于 {{v|2,3}}，
* 否则为 {{c/core|std::allocator&lt;void&gt;}}。

令 {{tt|B}} 为 {{c/core|std::allocator_traits&lt;A&gt;::template rebind_alloc&lt;U&gt;}}，其中 {{tt|U}} 为一种大小和对齐均为 {{ltt|cpp/preprocessor/replace#预定义宏|__STDCPP_DEFAULT_NEW_ALIGNMENT__}} 的未指明类型。

以如下方式初始化一个 {{tt|B}} 类型的分配器 {{c|b}}：
@1@ {{c|A()}}，
@2,3@ {{c|A(alloc)}}。

使用 {{c|b}} 来分配足以为以下内容提供存储的最小的 {{tt|U}} 数组的存储：大小为 {{c|size}} 的[[cpp/language/coroutines#执行|协程状态]]，和为确保 {{rlpt|operator delete}} 可以于此后用等于 {{c|b}} 的分配器解分配此内存块所需的未指明的额外状态。

除非 {{c/core|std::allocator_traits&lt;B&gt;::pointer}} 是指针类型，且对于重载 {{vl|2,3}}，{{c|std::same_as&lt;Allocator, void&gt; {{!!}} std::convertible_to&lt;const Alloc&amp;, Allocator&gt;}} 得以实现，否则程序非良构。

===参数===
{{par begin}}
{{par|size|要分配存储的大小}}
{{par|alloc|用户提供的 {{tt|Alloc}} 类型的分配器}}
{{par end}}

===返回值===
指向已分配存储的指针。

===异常===
@1-3@ 可能抛出。

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3900|std=C++23|before=重载 {{vl|2,3}} 收到 {{tt|Alloc}} 转换为 {{tt|Allocator}} 的约束|after=强制要求}}
{{dr list end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}