{{cpp/title|deque}}
{{cpp/container/deque/navbar}}
{{dcl begin}}
{{dcl header|deque}}
{{dcl|num=1|1=
template&lt;
    class T,
    class Allocator = std::allocator&lt;T&gt;
&gt; class deque;
}}
{{dcl|num=2|since=c++17|1=
namespace pmr {
    template&lt; class T &gt;
    using deque = std::deque&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt;;
}
}}
{{dcl end}}

{{tt|std::deque}}（double-ended queue，双端队列）是有索引的序列容器，允许在它的首尾两端快速插入及删除。另外，在 deque 任一端的插入或删除不会使指向其余元素的指针或引用失效。

与 {{lc|std::vector}} 相反，deque 的元素不是连续存储的：典型实现采用一系列单独分配的固定尺寸数组，外加额外的簿记数据，这表示对 deque 的索引访问必须进行二次指针解引用，与之相比 vector 的索引访问只进行一次。

deque 的存储按需自动扩张及收缩。扩张 deque 比扩张 {{lc|std::vector}} 更轻便，因为它不涉及将既存元素复制到新内存位置。另一方面，deque 典型地拥有较大的最小内存开销；只保有一个元素的 deque 必须分配它的整个内部数组（例如 64 位 libstdc++ 上是对象尺寸的 8 倍；64 位 libc++ 上是对象尺寸的 16 倍和 4096 字节中的较大者）。

deque 上常见操作的复杂度（效率）如下：

* 随机访问——常数 {{math|O(1)}}。
* 在结尾或起始插入或移除元素——常数 {{math|O(1)}}。
* 插入或移除元素——线性 {{math|O(n)}}。

{{tt|std::deque}} 满足{{named req|Container}}、{{named req|AllocatorAwareContainer}}、{{named req|SequenceContainer}}和{{named req|ReversibleContainer}}。

{{cpp/is_constexpr|since=c++26|transient=yes}}

===模板形参===
{{par begin}}
{{par inc|cpp/container/param list T|deque}}
{{par inc|cpp/container/param list Allocator|deque}}
{{par end}}

===迭代器失效===
{{todo|此节仍有少量不准确的地方，更多细节请查看涉及单独成员函数的页面}}

{| class="dsctable" style="font-size:0.9em"
!操作
!失效
|-
|所有只读操作
|决不
|-
|{{lc|swap}}、{{lc|std::swap}}
|尾后迭代器可能失效（由实现定义）
|-
|{{lc|shrink_to_fit}}、{{lc|clear}}、{{lc|insert}}、{{lc|emplace}}、{{lc|push_front}}、&lt;br&gt;{{lc|push_back}}、{{lc|emplace_front}}、{{lc|emplace_back}}
|始终
|-
|{{lc|erase}}
|如果在起始擦除——只有被擦除元素&lt;br&gt;
如果在末尾擦除——只有被擦除元素和尾后迭代器&lt;br&gt;
否则——所有迭代器（包含尾后迭代器）。
{{rrev multi|until1=c++11
|rev1
=未指定尾后迭代器何时失效。
|rev2
=尾后迭代器也会失效，除非所擦除的元素&lt;br&gt;
处于容器开头且最后一个元素未被擦除。
}}
|-
|{{lc|resize}}
|如果新尺寸小于旧尺寸——只有被擦除元素和尾后迭代器&lt;br&gt;
如果新尺寸大于旧尺寸——所有迭代器均失效&lt;br&gt;
否则——无迭代器失效。
|-
|{{lc|pop_front}}、{{lc|pop_back}}
|到被擦除元素的迭代器。
{{rrev multi|until1=c++11
|rev1=尾后迭代器可能失效（实现定义）。
|rev2=尾后迭代器也会失效。}}
|}

====失效相关注解====
* 从 deque 任一端插入时，{{lc|insert}} 和 {{lc|emplace}} 不会使引用失效。
* {{lc|push_front}}、{{lc|push_back}}、{{lc|emplace_front}} 和 {{lc|emplace_back}} 不会使任何到 deque 元素的引用失效。
* 从 deque 任一端擦除时，{{lc|erase}}、{{lc|pop_front}} 和 {{lc|pop_back}} 不会使到未擦除元素的引用失效。
* 以较小的尺寸调用 {{lc|resize}} 不会使任何到未擦除元素的引用失效。
* 以较大的尺寸调用 {{lc|resize}} 不会使任何到 deque 元素的引用失效。

===成员类型===
{{dsc begin}}
{{dsc hitem |成员类型|定义}}
{{dsc inc | cpp/container/dsc value_type | deque}}
{{dsc inc | cpp/container/dsc allocator_type | deque}}
{{dsc inc | cpp/container/dsc size_type | deque}}
{{dsc inc | cpp/container/dsc difference_type | deque}}
{{dsc inc | cpp/container/dsc reference | deque}}
{{dsc inc | cpp/container/dsc const_reference | deque}}
{{dsc inc | cpp/container/dsc pointer | deque}}
{{dsc inc | cpp/container/dsc const_pointer | deque}}
{{dsc inc | cpp/container/dsc iterator | deque}}
{{dsc inc | cpp/container/dsc const_iterator | deque}}
{{dsc inc | cpp/container/dsc reverse_iterator | deque}}
{{dsc inc | cpp/container/dsc const_reverse_iterator | deque}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc | cpp/container/dsc constructor | deque}}
{{dsc inc | cpp/container/dsc destructor | deque}}
{{dsc inc | cpp/container/dsc operator{{=}} | deque}}
{{dsc inc | cpp/container/dsc assign | deque}}
{{dsc inc|cpp/container/dsc assign_range|deque}}
{{dsc inc | cpp/container/dsc get_allocator | deque}}

{{dsc h2 | 元素访问}}
{{dsc inc | cpp/container/dsc at | deque}}
{{dsc inc | cpp/container/dsc operator_at | deque}}
{{dsc inc | cpp/container/dsc front | deque}}
{{dsc inc | cpp/container/dsc back | deque}}

{{dsc h2 | 迭代器}}
{{dsc inc | cpp/container/dsc begin | deque}}
{{dsc inc | cpp/container/dsc end | deque}}
{{dsc inc | cpp/container/dsc rbegin | deque}}
{{dsc inc | cpp/container/dsc rend | deque}}

{{dsc h2 | 容量}}
{{dsc inc | cpp/container/dsc empty | deque}}
{{dsc inc | cpp/container/dsc size | deque}}
{{dsc inc | cpp/container/dsc max_size | deque}}
{{dsc inc | cpp/container/dsc shrink_to_fit | deque}}

{{dsc h2 | 修改器}}
{{dsc inc | cpp/container/dsc clear | deque}}
{{dsc inc | cpp/container/dsc insert | deque}}
{{dsc inc|cpp/container/dsc insert_range|deque}}
{{dsc inc | cpp/container/dsc emplace | deque}}
{{dsc inc | cpp/container/dsc erase | deque}}
{{dsc inc | cpp/container/dsc push_back | deque}}
{{dsc inc | cpp/container/dsc emplace_back | deque}}
{{dsc inc|cpp/container/dsc append_range|deque}}
{{dsc inc | cpp/container/dsc pop_back | deque}}
{{dsc inc | cpp/container/dsc push_front | deque}}
{{dsc inc | cpp/container/dsc emplace_front | deque}}
{{dsc inc|cpp/container/dsc prepend_range|deque}}
{{dsc inc | cpp/container/dsc pop_front | deque}}
{{dsc inc | cpp/container/dsc resize | deque}}
{{dsc inc | cpp/container/dsc swap | deque}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc | cpp/container/dsc operator_cmp | deque}}
{{dsc inc | cpp/container/dsc swap2 | deque}}
{{dsc inc | cpp/container/dsc erase seq | deque}}
{{dsc end}}

{{rrev|since=c++17|
==={{rl|deduction guides|推导指引}}===
}}

===注解===
{{ftm begin|std=1|comment=1}}
{{ftm|__cpp_lib_containers_ranges|value=202202L|std=C++23|容器的范围构造和插入}}
{{ftm|__cpp_lib_constexpr_containers|value=202502L|std=C++26|{{c/core|constexpr}} {{tt|std::deque}}}}
{{ftm end}}

===示例===
{{example
|code=
#include &lt;deque&gt;
#include &lt;iostream&gt;

int main()
{
    // 创建容纳整数的 deque
    std::deque&lt;int&gt; d = {7, 5, 16, 8};

    // 向 deque 的首尾添加整数
    d.push_front(13);
    d.push_back(25);

    // 迭代并打印 deque 的值
    for(int n : d)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
13 7 5 16 8 25
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=230|std=C++98|before={{tt|T}} 不需要满足{{named req|CopyConstructible}}&lt;br&gt;（因此不保证能构造 {{tt|T}} 类型的元素）|after={{tt|T}} 也需要满足&lt;br&gt;{{named req|CopyConstructible}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc queue}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pl|pt|ru}}