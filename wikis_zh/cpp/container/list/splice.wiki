{{cpp/container/list/title|splice}}
{{cpp/container/list/navbar}}
{{dcl begin}}
{{dcl|num=1|
void splice( const_iterator pos, list&amp; other );
}}
{{dcl|num=2|since=c++11|
void splice( const_iterator pos, list&amp;&amp; other );
}}
{{dcl|num=3|
void splice( const_iterator pos, list&amp; other, const_iterator it );
}}
{{dcl|num=4|since=c++11|
void splice( const_iterator pos, list&amp;&amp; other, const_iterator it );
}}
{{dcl|num=5|
void splice( const_iterator pos, list&amp; other, 
             const_iterator first, const_iterator last);
}}
{{dcl|num=6|since=c++11|
void splice( const_iterator pos, list&amp;&amp; other, 
             const_iterator first, const_iterator last );
}}
{{dcl end}}

从一个 list 转移元素给另一个。

不复制或移动元素，仅对链表结点的内部指针进行重指向。没有迭代器或引用会失效，指向被移动元素的迭代器保持有效，但现在指代到 {{c|*this}} 中，而不是到 {{c|other}} 中。

@1,2@ 从 {{c|other}} 转移所有元素到 {{c|*this}} 中。元素被插入到 {{c|pos}} 指向的元素之前。操作后容器 {{c|other}} 变为空。

@3,4@ 从 {{c|other}} 转移 {{c|it}} 指向的元素到 {{c|*this}}。元素被插入到 {{c|pos}} 指向的元素之前。

@5,6@ 从 {{c|other}} 转移范围 {{range|first|last}} 中的元素到 {{c|*this}}。元素被插入到 {{c|pos}} 指向的元素之前。

在以下情况下行为未定义：
* {{c|1=get_allocator() != other.get_allocator()}}。
* 对于重载 {{v|1,2}}，{{c|*this}} 和 {{c|other}} 指代同一对象。
* 对于重载 {{v|3,4}}，{{c|it}} 不是到 {{c|other}} 中的[[cpp/iterator#可解引用性与有效性|可解引用迭代器]]。
* 对于重载 {{v|5,6}}：
:* {{range|first|last}} 不是 {{c|other}} 中的[[cpp/iterator#范围|有效范围]]。
:* {{c|pos}} 在 {{range|first|last}} 中。

===参数===
{{par begin}}
{{par|pos|将插入内容到它之前的元素}}
{{par|other|要从它转移内容的另一容器}}
{{par|it|要从 {{c|other}} 转移到 {{c|*this}} 的元素}}
{{par range|3=要从 {{c|other}} 转移到 {{c|*this}} 的}}
{{par end}} 

===返回值===
（无）

===异常===
不抛出。

===复杂度===
@1-4@ 常数。

@5,6@ 如果 {{c|other}} 和 {{c|*this}} 指代同一对象则为常数，否则与 {{c|std::distance(first, last)}} 成线性。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;list&gt;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; ostr, const std::list&lt;int&gt;&amp; list)
{
    for (auto &amp;i : list)
        ostr &lt;&lt; ' ' &lt;&lt; i;
    
    return ostr;
}

int main ()
{
    std::list&lt;int&gt; list1{1, 2, 3, 4, 5};
    std::list&lt;int&gt; list2{10, 20, 30, 40, 50};
    
    auto it = list1.begin();
    std::advance(it, 2);
    
    list1.splice(it, list2);
    
    std::cout &lt;&lt; "list1:" &lt;&lt; list1 &lt;&lt; '\n';
    std::cout &lt;&lt; "list2:" &lt;&lt; list2 &lt;&lt; '\n';
    
    list2.splice(list2.begin(), list1, it, list1.end());
    
    std::cout &lt;&lt; "list1:" &lt;&lt; list1 &lt;&lt; '\n';
    std::cout &lt;&lt; "list2:" &lt;&lt; list2 &lt;&lt; '\n';
}
|output=
list1： 1 2 10 20 30 40 50 3 4 5
list2：
list1： 1 2 10 20 30 40 50
list2： 3 4 5
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=250|std=C++98|before=到被移动的元素的引用或迭代器都会失效|after=它们指代或指向 {{c|*this}} 中相同的元素}}
{{dr list item|paper=N2525|std=C++98|before=在 {{c|1=get_allocator() != other.get_allocator()}}&lt;br&gt;的情况下无法保证在 O(1) 时间内完成转移|after=此时行为未定义}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc merge|list}}
{{dsc inc|cpp/container/dsc remove|list}}
{{dsc end}}


{{langlinks|de|en|es|fr|it|ja|ko|pl|pt|ru}}