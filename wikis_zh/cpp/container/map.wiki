{{cpp/title|map}}
{{cpp/container/map/navbar}}
{{dcl begin}}
{{dcl header|map}}
{{dcl|num=1|1=
template&lt;
    class Key,
    class T,
    class Compare = std::less&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;
&gt; class map;
}}
{{dcl|num=2|since=c++17|1=
namespace pmr {
    template&lt;
        class Key,
        class T,
        class Compare = std::less&lt;Key&gt;
    &gt; using map = std::map&lt;Key, T, Compare,
                           std::pmr::polymorphic_allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;;
}
}}
{{dcl end}}

{{tt|std::map}} 是一种有序关联容器，它包含具有唯一键的键值对。键之间以比较函数 {{tt|Compare}} 排序。搜索、移除和插入操作拥有对数复杂度。map 通常实现为{{enwiki|Red–black tree|红黑树}}。

{{tt|std::map}} 的迭代器以升序迭代各键，此升序由构造时所用的比较函数定义。就是说，给定
* {{c|m}}，一个 {{tt|std::map}}
* {{c|it_l}} 和 {{c|it_r}}，{{c|m}} 的可解引用迭代器，且 {{c|it_l &lt; it_r}}，
则 {{c|1=m.value_comp()(*it_l, *it_r) == true}}（使用默认比较函数时为从小到大排序）。

标准库使用{{named req|Compare}}概念时，均用等价关系来确定唯一性。不精确地说，如果两个对象 {{c|a}} 与 {{c|b}} 相互比较均不小于对方：{{c|!comp(a, b) &amp;&amp; !comp(b, a)}}，那么认为它们等价。

{{tt|std::map}} 满足{{named req|Container}}、{{named req|AllocatorAwareContainer}}、{{named req|AssociativeContainer}}和{{named req|ReversibleContainer}}。

{{cpp/is_constexpr|since=c++26|transient=yes}}

===模板形参===
{{todo|添加模板形参说明。}}

===成员类型===
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc inc|cpp/container/dsc key_type|map}}
{{dsc inc|cpp/container/dsc mapped_type|map}}
{{dsc inc|cpp/container/dsc value_type|map}}
{{dsc inc|cpp/container/dsc size_type|map}}
{{dsc inc|cpp/container/dsc difference_type|map}}
{{dsc inc|cpp/container/dsc key_compare|map}}
{{dsc inc|cpp/container/dsc allocator_type|map}}
{{dsc inc|cpp/container/dsc reference|map}}
{{dsc inc|cpp/container/dsc const_reference|map}}
{{dsc inc|cpp/container/dsc pointer|map}}
{{dsc inc|cpp/container/dsc const_pointer|map}}
{{dsc inc|cpp/container/dsc iterator|map}}
{{dsc inc|cpp/container/dsc const_iterator|map}}
{{dsc inc|cpp/container/dsc reverse_iterator|map}}
{{dsc inc|cpp/container/dsc const_reverse_iterator|map}}
{{dsc inc|cpp/container/dsc node_type|map}}
{{dsc inc|cpp/container/dsc insert_return_type|map}}
{{dsc end}}

===成员类===
{{dsc begin}}
{{dsc inc|cpp/container/dsc value_compare|map}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc constructor|map}}
{{dsc inc|cpp/container/dsc destructor|map}}
{{dsc inc|cpp/container/dsc operator{{=}}|map}}
{{dsc inc|cpp/container/dsc get_allocator|map}}

{{dsc h2|元素访问}}
{{dsc inc|cpp/container/dsc at|map}}
{{dsc inc|cpp/container/dsc operator_at|map}}

{{dsc h2|迭代器}}
{{dsc inc|cpp/container/dsc begin|map}}
{{dsc inc|cpp/container/dsc end|map}}
{{dsc inc|cpp/container/dsc rbegin|map}}
{{dsc inc|cpp/container/dsc rend|map}}

{{dsc h2|容量}}
{{dsc inc|cpp/container/dsc empty|map}}
{{dsc inc|cpp/container/dsc size|map}}
{{dsc inc|cpp/container/dsc max_size|map}}

{{dsc h2|修改器}}
{{dsc inc|cpp/container/dsc clear|map}}
{{dsc inc|cpp/container/dsc insert|map}}
{{dsc inc|cpp/container/dsc insert_range|map}}
{{dsc inc|cpp/container/dsc insert_or_assign|map}}
{{dsc inc|cpp/container/dsc emplace|map}}
{{dsc inc|cpp/container/dsc emplace_hint|map}}
{{dsc inc|cpp/container/dsc try_emplace|map}}
{{dsc inc|cpp/container/dsc erase|map}}
{{dsc inc|cpp/container/dsc swap|map}}
{{dsc inc|cpp/container/dsc extract|map}}
{{dsc inc|cpp/container/dsc merge|map}}

{{dsc h2|查找}}
{{dsc inc|cpp/container/dsc count|map}}
{{dsc inc|cpp/container/dsc find|map}}
{{dsc inc|cpp/container/dsc contains|map}}
{{dsc inc|cpp/container/dsc equal_range|map}}
{{dsc inc|cpp/container/dsc lower_bound|map}}
{{dsc inc|cpp/container/dsc upper_bound|map}}

{{dsc h2|观察器}}
{{dsc inc|cpp/container/dsc key_comp|map}}
{{dsc inc|cpp/container/dsc value_comp|map}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator_cmp|map}}
{{dsc inc|cpp/container/dsc swap2|map}}
{{dsc inc|cpp/container/dsc erase_if|map}}
{{dsc end}}

{{rrev|since=c++17|
==={{rl|deduction guides|推导指引}}===
}}

===注解===
{{ftm begin|std=1|comment=1}}
{{ftm|__cpp_lib_containers_ranges|value=202202L|std=C++23|容器的范围构造和插入}}
{{ftm|__cpp_lib_constexpr_containers|value=202502L|std=C++26|{{c/core|constexpr}} {{tt|std::map}}}}
{{ftm end}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;

void print_map(std::string_view comment, const std::map&lt;std::string, int&gt;&amp; m)
{
    std::cout &lt;&lt; comment;
    // 使用 C++17 设施进行遍历
    for (const auto&amp; [key, value] : m)
        std::cout &lt;&lt; '[' &lt;&lt; key &lt;&lt; "] = " &lt;&lt; value &lt;&lt; "; ";
    
// C++11 方案：
//  for (const auto&amp; n : m)
//      std::cout &lt;&lt; n.first &lt;&lt; " = " &lt;&lt; n.second &lt;&lt; "; ";
//
// C++98 方案：
//  for (std::map&lt;std::string, int&gt;::const_iterator it = m.begin(); it != m.end(); it++)
//      std::cout &lt;&lt; it-&gt;first &lt;&lt; " = " &lt;&lt; it-&gt;second &lt;&lt; "; ";
    
    std::cout &lt;&lt; '\n';
}

int main()
{
    // 创建包含三对 (string, int) 的 map
    std::map&lt;std::string, int&gt; m{&lt;!----&gt;{"CPU", 10}, {"GPU", 15}, {"RAM", 20}&lt;!----&gt;};

    print_map("1) 初始 map：", m);

    m["CPU"] = 25; // 更新已经存在的值
    m["SSD"] = 30; // 插入新值
    print_map("2) 更新后的 map：", m);

    // 以不存在的键使用 operator[] 总是会执行插入操作
    std::cout &lt;&lt; "3) m[UPS] = " &lt;&lt; m["UPS"] &lt;&lt; '\n';
    print_map("4) 更新后的 map：", m);

    m.erase("GPU");
    print_map("5) 移除后：", m);

    std::erase_if(m, [](const auto&amp; pair){ return pair.second &gt; 25; });
    print_map("6) 移除后：", m);
    std::cout &lt;&lt; "7) m.size() = " &lt;&lt; m.size() &lt;&lt; '\n';

    m.clear();
    std::cout &lt;&lt; std::boolalpha &lt;&lt; "8) map 为空：" &lt;&lt; m.empty() &lt;&lt; '\n';
}
|output=
1) 初始 map：[CPU] = 10; [GPU] = 15; [RAM] = 20; 
2) 更新后的 map[CPU] = 25; [GPU] = 15; [RAM] = 20; [SSD] = 30; 
3) m[UPS] = 0
4) 更新后的 map[CPU] = 25; [GPU] = 15; [RAM] = 20; [SSD] = 30; [UPS] = 0; 
5) 移除后：[CPU] = 25; [RAM] = 20; [SSD] = 30; [UPS] = 0; 
6) 移除后：[CPU] = 25; [RAM] = 20; [UPS] = 0; 
7) m.size() = 3
8) map 为空：true
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=230|std=C++98|before={{tt|Key}} 不需要满足{{named req|CopyConstructible}}&lt;br&gt;（因此不保证能构造 {{tt|Key}} 类型的键）|after={{tt|Key}} 也需要满足&lt;br&gt;{{named req|CopyConstructible}}}}
{{dr list item|wg=lwg|dr=464|std=C++98|before=以键访问 const {{tt|map}} 不方便|after=提供 {{tt|at}} 函数}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc multimap}}
{{dsc inc|cpp/container/dsc unordered_map}}
{{dsc inc|cpp/container/dsc flat_map}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pl|pt|ru}}