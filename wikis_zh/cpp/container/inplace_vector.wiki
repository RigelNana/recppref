{{cpp/title|inplace_vector}}
{{cpp/container/inplace_vector/navbar}}
{{ddcl|header=inplace_vector|since=c++26|
template&lt;
    class T,
    std::size_t N
&gt; struct inplace_vector;
}}

{{tt|inplace_vector}} 是具有连续原位存储的可动态调整大小的数组。在对象自身内部存储 {{tt|T}} 类型的元素并且适当对齐。内部存储的容量是在编译时固定的，等于 {{c|N}}。

各元素连续存储，这表示不仅可以通过迭代器或者随机访问的 {{c/core|operator[]}} 来访问元素，也可以在指向元素的常规指针上使用偏移量。可以将指向 {{tt|inplace_vector}} 元素的指针传递给任何接受指向 C 数组元素指针的函数。

{{tt|inplace_vector}} 实现{{named req|Container}}、{{named req|ReversibleContainer}}、{{named req|ContiguousContainer}} 和{{named req|SequenceContainer}}，包括大多数[[cpp/named_req/SequenceContainer#可选操作|可选序列容器操作]]，但不提供成员函数 {{tt|push_front}}、{{tt|emplace_front}}、{{tt|pop_front}} 和 {{tt|prepend_range}}。

对于任意正数 {{c|N}}，{{c/core|std::inplace_vector&lt;T, N&gt;::iterator}} 和 {{c/core|std::inplace_vector&lt;T, N&gt;::const_iterator}} 满足{{named req|ConstexprIterator}}的要求。

特化 {{c/core|std::inplace_vector&lt;T, 0&gt;}} {{named req|TriviallyCopyable}}，并且为空。同时 {{c|std::is_trivially_default_constructible_v&lt;std::inplace_vector&lt;T, 0&gt;&gt;}} 是 {{c|true}}。

{{c/core|std::inplace_vector&lt;T, N&gt;}} 的任何导致超出容量 {{c|N}} 的插入函数都会抛出 {{lc|std::bad_alloc}}。

{{tt|inplace_vector}} 上一般操作的复杂度如下：
* 通过 {{rlt|operator at|operator[]}} 或 {{rlt|at|at()}} 随机访问元素——常数：{{math|𝓞(1)}}。
* 在末尾插入或移除一个元素——常数：{{math|𝓞(1)}}。
* 在末尾插入或移除多个元素——与插入或移除的元素数量成线性：{{math|𝓞(n)}}。
* 在开头或中间插入或移除多个元素——与插入或移除的元素数量加上到向量末尾的距离成线性：{{math|𝓞(n)}}。

===迭代器失效===
{{tt|std::inplace_vector}} 迭代器的失效保证与 {{lc|std::vector}} 的不同：
* 移动 {{tt|inplace_vector}} 会使所有迭代器失效；
* 交换两个 {{tt|inplace_vector}} 会使所有迭代器失效（交换过程中，迭代器会继续指向相同的数组元素，并可能改变其值）。
这些成员函数潜在地会使迭代器失效：
{{rlt|operator{{=}}}}、{{rlt|assign}}、{{rlt|assign_range}}、{{rlt|clear}}、{{rlt|emplace}}、{{rlt|erase}}、{{rlt|insert}}、{{rlt|insert_range}}、{{rlt|pop_back}}、{{rlt|resize}} 以及 {{rlt|swap}}。

这些成员函数仅会潜在地使 {{rlt|end}} 迭代器失效：
{{rlt|append_range}}、{{rlt|emplace_back}}、{{rlt|push_back}}、{{rlt|try_append_range}}、{{rlt|try_emplace_back}}、{{rlt|try_push_back}}、{{rlt|unchecked_emplace_back}} 以及 {{rlt|unchecked_push_back}}。

===模板形参===
{{par begin}}
{{par|T|元素的类型。必须满足{{named req|MoveConstructible}}和{{named req|MoveAssignable}}。}}
{{par|N|容量，即 {{tt|inplace_vector}} 中元素的最大数量（可能为 {{c|0}}）。}}
{{par end}}

===成员类型===
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc inc|cpp/container/dsc value_type|inplace_vector}}
{{dsc inc|cpp/container/dsc size_type|inplace_vector}}
{{dsc inc|cpp/container/dsc difference_type|inplace_vector}}
{{dsc inc|cpp/container/dsc reference|inplace_vector}}
{{dsc inc|cpp/container/dsc const_reference|inplace_vector}}
{{dsc inc|cpp/container/dsc pointer|inplace_vector}}
{{dsc inc|cpp/container/dsc const_pointer|inplace_vector}}
{{dsc inc|cpp/container/dsc iterator|inplace_vector}}
{{dsc inc|cpp/container/dsc const_iterator|inplace_vector}}
{{dsc inc|cpp/container/dsc reverse_iterator|inplace_vector}}
{{dsc inc|cpp/container/dsc const_reverse_iterator|inplace_vector}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc constructor|inplace_vector}}
{{dsc inc|cpp/container/dsc destructor|inplace_vector}}
{{dsc inc|cpp/container/dsc operator{{=}}|inplace_vector}}
{{dsc inc|cpp/container/dsc assign|inplace_vector}}
{{dsc inc|cpp/container/dsc assign_range|inplace_vector}}

{{dsc h2|元素访问}}
{{dsc inc|cpp/container/dsc at|inplace_vector}}
{{dsc inc|cpp/container/dsc operator_at|inplace_vector}}
{{dsc inc|cpp/container/dsc front|inplace_vector}}
{{dsc inc|cpp/container/dsc back|inplace_vector}}
{{dsc inc|cpp/container/dsc data|inplace_vector}}

{{dsc h2|迭代器}}
{{dsc inc|cpp/container/dsc begin|inplace_vector}}
{{dsc inc|cpp/container/dsc end|inplace_vector}}
{{dsc inc|cpp/container/dsc rbegin|inplace_vector}}
{{dsc inc|cpp/container/dsc rend|inplace_vector}}

{{dsc h2|大小与容量}}
{{dsc inc|cpp/container/dsc empty|inplace_vector}}
{{dsc inc|cpp/container/dsc size|inplace_vector}}
{{dsc inc|cpp/container/dsc max_size|inplace_vector}}
{{dsc inc|cpp/container/dsc capacity|inplace_vector}}
{{dsc inc|cpp/container/dsc resize|inplace_vector}}
{{dsc inc|cpp/container/dsc reserve|inplace_vector}}
{{dsc inc|cpp/container/dsc shrink_to_fit|inplace_vector}}

{{dsc h2|修改器}}
{{dsc inc|cpp/container/dsc insert|inplace_vector}}
{{dsc inc|cpp/container/dsc insert_range|inplace_vector}}
{{dsc inc|cpp/container/dsc emplace|inplace_vector}}
{{dsc inc|cpp/container/dsc emplace_back|inplace_vector}}
{{dsc inc|cpp/container/dsc try_emplace_back|inplace_vector}}
{{dsc inc|cpp/container/dsc unchecked_emplace_back|inplace_vector}}
{{dsc inc|cpp/container/dsc push_back|inplace_vector}}
{{dsc inc|cpp/container/dsc try_push_back|inplace_vector}}
{{dsc inc|cpp/container/dsc unchecked_push_back|inplace_vector}}
{{dsc inc|cpp/container/dsc pop_back|inplace_vector}}
{{dsc inc|cpp/container/dsc append_range|inplace_vector}}
{{dsc inc|cpp/container/dsc try_append_range|inplace_vector}}
{{dsc inc|cpp/container/dsc clear|inplace_vector}}
{{dsc inc|cpp/container/dsc erase|inplace_vector}}
{{dsc inc|cpp/container/dsc swap|inplace_vector}}
{{dsc end}}


===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc swap2|inplace_vector}}
{{dsc inc|cpp/container/dsc erase seq|inplace_vector}}
{{dsc inc|cpp/container/dsc operator cmp|inplace_vector}}
{{dsc end}}

===注解===
{{tt|inplace_vector}} 的元素数量可动态变化，最多到一个固定的容量，这是由于各元素是存储在对象自身内部，这与 {{lc|std::array}} 相似。不过与 C 数组或 {{lc|std::array}} 必须在初始化时构造全部元素不同，对象是在插入到 {{tt|inplace_vector}} 之内时初始化的。

{{tt|inplace_vector}} 在不希望进行动态内存分配的情形中非常有用。 

{{ftm begin|sort=1}}
{{ftm|std=C++26|value=202406L|__cpp_lib_inplace_vector|{{tt|std::inplace_vector}}: 具有固定容量的原位存储的可动态调整大小的向量}}
{{ftm|std=C++26|value=202502L|__cpp_lib_constexpr_inplace_vector|{{c/core|constexpr}} {{tt|std::inplace_vector}} 用于非平凡元素类型}}
{{ftm end}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;inplace_vector&gt;

int main()
{
    std::inplace_vector&lt;int, 4&gt; v1{0, 1, 2};
    assert(v1.max_size() == 4);
    assert(v1.capacity() == 4);
    assert(v1.size() == 3);
    assert(std::ranges::equal(v1, std::array{0, 1, 2}));
    assert(v1[0] == 0);
    assert(v1.at(0) == 0);
    assert(v1.front() == 0);
    assert(*v1.begin() == 0);
    assert(v1.back() == 2);
    v1.push_back(3);
    assert(v1.back() == 3);
    assert(std::ranges::equal(v1, std::array{0, 1, 2, 3}));
    v1.resize(3);
    assert(std::ranges::equal(v1, std::array{0, 1, 2}));
    assert(v1.try_push_back(3) != nullptr);
    assert(v1.back() == 3);
    assert(v1.size() == 4);
    assert(v1.try_push_back(13) == nullptr); // 没有位置
    assert(v1.back() == 3);
    assert(v1.size() == 4);
    v1.clear();
    assert(v1.size() == 0);
    assert(v1.empty());
}
}}

===参见===
{{dsc begin}}
{{dsc inc|cpp/container/dsc vector}}
{{dsc inc|cpp/container/dsc array}}
{{dsc inc|cpp/container/dsc deque}}
{{dsc end}}

===外部链接===
{{elink begin}}
{{elink|[https://godbolt.org/z/5P78aG5xE {{tt|inplace_vector}}] &amp;mdash; {{stddoc|P0843R14}} ({{tt|std::inplace_vector}}) 的一个参考实现。}}
{{elink|[https://www.boost.org/doc/libs/release/doc/html/container/non_standard_containers.html#container.non_standard_containers.static_vector {{tt|static_vector}}] &amp;mdash; Boost.Container 将 inplace vector 实现为一个具有自己的保证的独立类型。}}
{{elink|[https://github.com/questor/eastl/blob/master/fixed_vector.h#L71 {{tt|fixed_vector}}] &amp;mdash; EASTL 通过一个额外的模板参数实现 inplace vector。}}
{{elink|[https://github.com/facebook/folly/blob/master/folly/docs/small_vector.md {{tt|small_vector}}] &amp;mdash; Folly 也通过一个额外的模板参数实现 inplace vector。}}
{{elink|[https://howardhinnant.github.io/stack_alloc.html {{tt|stack_alloc}}] &amp;mdash; Howard Hinnant 在 {{lc|std::vector}} 上模拟 {{tt|std::inplace_vector}} 的自定义分配器。}}
{{elink end}}

{{langlinks|de|en|es|fr|it|ja|pl|pt|ru}}