{{cpp/title|flat_map}}
{{cpp/container/flat_map/navbar}}
{{ddcl|header=flat_map|since=c++23|1=
template&lt;
    class Key,
    class T,
    class Compare = std::less&lt;Key&gt;,
    class KeyContainer = std::vector&lt;Key&gt;,
    class MappedContainer = std::vector&lt;T&gt;
&gt; class flat_map;
}}

平铺映射（flat map）是一种[[cpp/container#容器适配器|容器适配器]]，给出具有唯一键的包含键-值对的关联容器的功能。用比较函数 {{tt|Compare}} 来对键进行排序。

类模板 {{tt|flat_map}} 表现为对分别作为 {{tt|KeyContainer}} 和 {{tt|MappedContainer}} 类型的对象而传递的底层容器的包装器。第一个容器有序，且每个键的对应值在第二个容器中处于相同索引（偏移量）。两个容器的元素数量相同。

每当标准库使用{{named req|Compare}}的要求，都使用等价关系来确定唯一性。非正式而言，如果两个对象 {{c|a}} 和 {{c|b}} 中没有任何一个比较小于另一个，则认为它们等价：{{c|!comp(a, b) &amp;&amp; !comp(b, a)}}。

{{tt|std::flat_map}} 满足{{named req|Container}}、{{named req|ReversibleContainer}}的要求，{{ls|cpp/named_req/Container#可选容器要求}}，以及所有{{named req|AssociativeContainer}}的要求（包括对数阶的搜索复杂度），但：
* 不适用节点相关要求，
* 迭代器失效的要求有所不同，&lt;!--TODO: describe iterator/pointer invalidation properties, maybe per each function --&gt;
* 插入和擦除操作的复杂度呈线性。

平铺映射支持{{named req|AssociativeContainer}}的大多数使用唯一键的操作。

{{cpp/is_constexpr|since=c++26|transient=yes}}

===迭代器失效===
{{todo}} &lt;!-- TODO: see e.g. [[cpp/container/unordered_map#Iterator invalidation]] as a basis --&gt;

===模板形参===
{{par begin}}
{{par|Key|键的类型。如果 {{tt|Key}} 与 {{tt|KeyContainer::value_type}} 不是同一类型则程序非良构。}}
{{par|T|被映射值的类型。如果 {{tt|T}} 与 {{tt|MappedContainer::value_type}} 不是同一类型则程序非良构。}}
{{par|Compare|一种提供严格弱序的{{named req|Compare}}类型。}}
{{par|KeyContainer&lt;br&gt;MappedContainer|用以分别存储键和被映射值的底层{{named req|SequenceContainer}}的类型。这种容器的迭代器应当满足{{named req|RandomAccessIterator}}或实现 {{lconcept|random_access_iterator}}。其成员函数 {{tt|size}} 和 {{tt|max_size}} 的调用不能以异常退出。

标准容器 {{lc|std::vector}} 和 {{lc|std::deque}} 均满足这些要求。}}{{par end}}
&lt;!----&gt;
===成员类型===
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc inc|cpp/container/dsc key_container_type|flat_map}}
{{dsc inc|cpp/container/dsc mapped_container_type|flat_map}}
{{dsc inc|cpp/container/dsc key_type|flat_map}}
{{dsc inc|cpp/container/dsc mapped_type|flat_map}}
{{dsc inc|cpp/container/dsc value_type|flat_map}}
{{dsc inc|cpp/container/dsc key_compare|flat_map}}
{{dsc inc|cpp/container/dsc reference|flat_map}}
{{dsc inc|cpp/container/dsc const_reference|flat_map}}
{{dsc inc|cpp/container/dsc size_type|flat_map}}
{{dsc inc|cpp/container/dsc difference_type|flat_map}}
{{dsc inc|cpp/container/dsc iterator|flat_map}}
{{dsc inc|cpp/container/dsc const_iterator|flat_map}}
{{dsc inc|cpp/container/dsc reverse_iterator|flat_map}}
{{dsc inc|cpp/container/dsc const_reverse_iterator|flat_map}}
{{dsc inc|cpp/container/dsc containers|flat_map}}
{{dsc end}}

===成员类===
{{dsc begin}}
{{dsc inc|cpp/container/dsc value_compare|flat_map}}&lt;!--
{{dsc inc|cpp/container/dsc key_equiv|flat_map}}--&gt;
{{dsc end}}

===成员对象===
{{dsc begin}}
{{dsc hitem|成员|说明}}
{{dsc expos mem obj|c|id=c|private=yes|spec={{tt|containers}}|适配的容器}}
{{dsc expos mem obj|compare|id=compare|private=yes|spec={{tt|key_compare}}|比较函数对象}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc constructor|flat_map}}
{{dsc mem dtor|nolink=true|notes={{mark implicit}}|销毁容器适配器的每个元素}}
{{dsc inc|cpp/container/dsc operator{{=}}|flat_map}}

{{dsc h2|元素访问}}
{{dsc inc|cpp/container/dsc at|flat_map}}
{{dsc inc|cpp/container/dsc operator_at|flat_map}}

{{dsc h2|迭代器}}
{{dsc inc|cpp/container/dsc begin|flat_map}}
{{dsc inc|cpp/container/dsc end|flat_map}}
{{dsc inc|cpp/container/dsc rbegin|flat_map}}
{{dsc inc|cpp/container/dsc rend|flat_map}}

{{dsc h2|容量}}
{{dsc inc|cpp/container/dsc empty|flat_map}}
{{dsc inc|cpp/container/dsc size|flat_map}}
{{dsc inc|cpp/container/dsc max_size|flat_map}}

{{dsc h2|修改器}}
{{dsc inc|cpp/container/dsc emplace|flat_map}}
{{dsc inc|cpp/container/dsc emplace_hint|flat_map}}
{{dsc inc|cpp/container/dsc try_emplace|flat_map}}
{{dsc inc|cpp/container/dsc insert|flat_map}}
{{dsc inc|cpp/container/dsc insert_range|flat_map}}
{{dsc inc|cpp/container/dsc insert_or_assign|flat_map}}
{{dsc inc|cpp/container/dsc extract|flat_map}}
{{dsc inc|cpp/container/dsc replace|flat_map}}
{{dsc inc|cpp/container/dsc erase|flat_map}}
{{dsc inc|cpp/container/dsc swap|flat_map}}
{{dsc inc|cpp/container/dsc clear|flat_map}}

{{dsc h2|查找}}
{{dsc inc|cpp/container/dsc find|flat_map}}
{{dsc inc|cpp/container/dsc count|flat_map}}
{{dsc inc|cpp/container/dsc contains|flat_map}}
{{dsc inc|cpp/container/dsc lower_bound|flat_map}}
{{dsc inc|cpp/container/dsc upper_bound|flat_map}}
{{dsc inc|cpp/container/dsc equal_range|flat_map}}

{{dsc h2|观察器}}
{{dsc inc|cpp/container/dsc key_comp|flat_map}}
{{dsc inc|cpp/container/dsc value_comp|flat_map}}
{{dsc inc|cpp/container/dsc keys|flat_map}}
{{dsc inc|cpp/container/dsc values|flat_map}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator_cmp|flat_map}}
{{dsc inc|cpp/container/dsc swap2|flat_map}}
{{dsc inc|cpp/container/dsc erase_if|flat_map}}
{{dsc end}}

===辅助类===
{{dsc begin}}
{{dsc inc|cpp/container/dsc uses_allocator|flat_map}}
{{dsc end}}

===标签===
{{dsc begin}}
{{dsc inc|cpp/container/dsc sorted_unique}}
{{dsc end}}

==={{rl|deduction guides|推导指引}}===

===注解===
{{cpp/container/assoc_note}}&lt;!-- TODO: is this relevant to flat_map? --&gt;

&lt;!-- TODO: maybe this lyrics is unnecessary:
平铺映射相对于其他标准[[associative containers|关联容器]]的优势有：
* 可能更快的查找（即便搜索操作具有对数复杂度）。
* 更快的遍历：{{lt|cpp/iterator/random access iterator|随机访问迭代器}}而非{{lt|cpp/iterator/bidirectional iterator|双向迭代器}}。
* 对小对象消耗更少内存（而当 {{c|KeyContainer::shrink_to_fit()}} 可用时对大对象同样如此）。
* 更好的缓存性能（取决于 {{tt|KeyContainer}}，各键可存储于连续内存块之中）。

平铺映射的一些缺点有：
* 不稳定的迭代器（迭代器会在插入和擦除元素时失效）。
* 不能存储不可复制和不可移动类型的值。
* 较弱的异常安全性（擦除和插入中进行位移时，复制/移动构造函数可能抛出异常）。
* 更慢（成线性）的插入和擦除，尤其对于不可移动类型。
--&gt;

{{ftm begin}}
{{ftm|__cpp_lib_flat_map|value=202207L|std=C++23|{{tt|std::flat_map}} 和 {{lc|std::flat_multimap}}}}
{{ftm|__cpp_lib_constexpr_containers|value=202502L|std=C++26|{{c/core|constexpr}} {{tt|std::flat_map}}}}
{{ftm end}}

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc flat_multimap}}
{{dsc inc|cpp/container/dsc map}}
{{dsc inc|cpp/container/dsc unordered_map}}
{{dsc end}}

{{langlinks|cs|de|en|es|fr|it|ja|pl|pt|ru}}

&lt;!--TODO: N4950::24.6.9 says:
TODO: add this to the "Exceptions" sections of appropriate member functions:
6. If any member function in 24.6.9.2 exits via an exception, the invariants are restored.
[Note 2 : This can result in the flat_map’s being emptied. — end note].
--&gt;

&lt;!--TODO: N4950::24.6.9.1 says:
TODO: add to constructors:
9. The effect of calling a constructor that takes both key_container_type and mapped_container_type arguments with containers of different sizes is undefined.
10. The effect of calling a constructor or member function that takes a sorted_unique_t argument with a container, containers, or range that is not sorted with respect to key_comp(), or that contains equal elements, is undefined.
--&gt;

&lt;!-- TODO: also complete [[cpp/container#Iterator invalidation]] table for flat_* adaptors --&gt;