{{cpp/title|vector&lt;bool&gt;}}
{{cpp/container/vector bool/navbar}}
{{ddcl|header=vector|
template&lt;
    class Allocator
&gt; class vector&lt;bool, Allocator&gt;;
}}

{{box/core|{{c/core|std::}}{{tt|vector}}{{c/core|&lt;bool&gt;}}}} 是 {{lc|std::vector}} 对类型 {{c/core|bool}} 为空间提效的特化。 

{{box/core|{{c/core|std::}}{{tt|vector}}{{c/core|&lt;bool&gt;}}}} 中对空间提效的行为（以及它是否有优化）是实现定义的。一种潜在优化涉及到 vector 的元素联合，使得每个元素占用一个单独的位，而非 {{c|sizeof(bool)}} 字节。

{{box/core|{{c/core|std::}}{{tt|vector}}{{c/core|&lt;bool&gt;}}}} 表现类似 {{lc|std::vector}}，但为节省空间，它：

* 不必作为连续数组存储元素
* 暴露类 {{box/core|{{c/core|std::}}{{tt|vector}}{{c/core|&lt;bool&gt;::}}{{rlt|reference}}}} 为访问单个位的方法。尤其是，{{ltt|cpp/container/vector/operator at|operator[]}} 以值返回此类型的对象。
* 不使用 {{c/core|std::allocator_traits::construct}} 构造位值。
* 不保证同一容器中的不同元素能由不同线程同时修改。

===成员类型===
{{dsc begin}}
{{dsc hitem|成员类型|定义}}
{{dsc inc|cpp/container/dsc value_type|vector_bool}}
{{dsc inc|cpp/container/dsc allocator_type|vector_bool}}
{{dsc inc|cpp/container/dsc size_type|vector_bool}}
{{dsc inc|cpp/container/dsc difference_type|vector_bool}}
{{dsc class|cpp/container/vector_bool/reference|表示到单个 {{c/core|bool}} 的引用的代理类}}
{{dsc inc|cpp/container/dsc const_reference|vector_bool}}
{{dsc inc|cpp/container/dsc pointer|vector_bool}}
{{dsc inc|cpp/container/dsc const_pointer|vector_bool}}
{{dsc inc|cpp/container/dsc iterator|vector_bool}}
{{dsc inc|cpp/container/dsc const_iterator|vector_bool}}
{{dsc inc|cpp/container/dsc reverse_iterator|vector_bool}}
{{dsc inc|cpp/container/dsc const_reverse_iterator|vector_bool}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc constructor|vector}}
{{dsc inc|cpp/container/dsc destructor|vector}}
{{dsc inc|cpp/container/dsc operator{{=}}|vector}}
{{dsc inc|cpp/container/dsc assign|vector}}
{{dsc inc|cpp/container/dsc assign_range|vector}}
{{dsc inc|cpp/container/dsc get_allocator|vector}}

{{dsc h2|元素访问}}
{{dsc inc|cpp/container/dsc at|vector}}
{{dsc inc|cpp/container/dsc operator_at|vector}}
{{dsc inc|cpp/container/dsc front|vector}}
{{dsc inc|cpp/container/dsc back|vector}}

{{dsc h2|迭代器}}
{{dsc inc|cpp/container/dsc begin|vector}}
{{dsc inc|cpp/container/dsc end|vector}}
{{dsc inc|cpp/container/dsc rbegin|vector}}
{{dsc inc|cpp/container/dsc rend|vector}}

{{dsc h2|容器}}
{{dsc inc|cpp/container/dsc empty|vector}}
{{dsc inc|cpp/container/dsc size|vector}}
{{dsc inc|cpp/container/dsc max_size|vector}}
{{dsc inc|cpp/container/dsc reserve|vector}}
{{dsc inc|cpp/container/dsc capacity|vector}}

{{dsc h2|修改器}}
{{dsc inc|cpp/container/dsc clear|vector}}
{{dsc inc|cpp/container/dsc insert|vector}}
{{dsc inc|cpp/container/dsc insert_range|vector}}
{{dsc inc|cpp/container/dsc append_range|vector}}
{{dsc inc|cpp/container/dsc emplace|vector}}
{{dsc inc|cpp/container/dsc erase|vector}}
{{dsc inc|cpp/container/dsc push_back|vector}}
{{dsc inc|cpp/container/dsc emplace_back|vector}}
{{dsc inc|cpp/container/dsc pop_back|vector}}
{{dsc inc|cpp/container/dsc resize|vector}}
{{dsc inc|cpp/container/dsc swap|vector}}

{{dsc h2|{{tt|vector&lt;bool&gt;}} 特定修改器}}
{{dsc inc|cpp/container/vector_bool/dsc flip}}
{{dsc inc|cpp/container/vector_bool/dsc swap}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator_cmp|vector}}
{{dsc inc|cpp/container/dsc swap2|vector}}
{{dsc inc|cpp/container/dsc erase seq|vector}}
{{dsc end}}

===辅助类===
{{dsc begin}}
{{dsc inc|cpp/container/vector_bool/dsc hash}}
{{dsc end}}

===[[cpp/container/vector/deduction guides|推导指引]]{{mark c++17}}===

===注解===
若位集的大小在编译时已知，则可使用 {{lc|std::bitset}}，它提供一组更丰富的成员函数。另外，[http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html boost::dynamic_bitset] 作为 {{box/core|{{c/core|std::}}{{tt|vector}}{{c/core|&lt;bool&gt;}}}} 的替用者存在。

因为 {{box/core|{{c/core|std::}}{{tt|vector}}{{c/core|&lt;bool&gt;}}}} 的表示可以优化，故它不需要满足所有{{named req|Container}}或{{named req|SequenceContainer}}的要求。例如，因为 {{box/core|{{c/core|std::}}{{tt|vector}}{{c/core|&lt;bool&gt;::iterator}}}} 是实现定义的，故它可以不满足{{named req|ForwardIterator}}的要求。使用要求{{named req|ForwardIterator}}的算法，例如 {{lc|std::search}} 可能导致[http://www.boost.org/doc/libs/1_69_0/libs/dynamic_bitset/dynamic_bitset.html#rationale 编译时或运行时错误]。

[https://www.boost.org/doc/libs/1_69_0/doc/html/boost/container/vector.html {{tt|vector}} 的 Boost.Container 版本]不对 {{c/core|bool}} 特化。

{{ftm begin}}
{{ftm|__cpp_lib_containers_ranges|value=202202L|std=C++23|容器的范围构造和插入}}
{{ftm end}}

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;initializer_list&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
 
void println(auto rem, const std::vector&lt;bool&gt;&amp; vb)
{
    std::cout &lt;&lt; rem &lt;&lt; " = [";
    for (std::size_t t{}; t != vb.size(); ++t)
        std::cout &lt;&lt; (t ? ", " : "") &lt;&lt; vb[t];
    std::cout &lt;&lt; "]\n";
}
 
int main()
{
    std::vector&lt;bool&gt; v1; // 创建空的布尔值向量
    println("1) v1", v1);
 
    std::vector&lt;bool&gt; v2{0, 1, 1, 0, 1}; // 创建已填充向量
    println("2) v2", v2);
 
    v1 = v2; // 复制 v2 给 v1
    println("3) v1", v1);
 
    assert(v1.size() == v2.size()); // 检查 v1 和 v2 的大小是否相等
    assert(v1.front() == false); // 访问第一个元素，等价于：
    assert(v1[0] == false);
    assert(v1.back() == true); // 访问最后元素，等价于：
    assert(v1[v1.size() - 1] == true);
 
    v1 = {true, true, false, false}; // 赋值一个初始化器列表
    println("4) v1", v1);
 
    v1.push_back(true); // 向末尾添加一个元素
    println("5) v1", v1);
 
    v1.pop_back(); // 从末尾移除一个元素
    println("6) v1", v1);
 
    v1.flip(); // 翻转所有元素
    println("7) v1", v1);
 
    v1.resize(8, true); // 重设 v1 大小；新元素被置为 “true”
    println("8) v1", v1);
 
    v1.clear(); // 擦除 v1
    assert(v1.empty()); // 检查 v1 是否为空
}
|output=
1) v1 = []
2) v2 = [0, 1, 1, 0, 1]
3) v1 = [0, 1, 1, 0, 1]
4) v1 = [1, 1, 0, 0]
5) v1 = [1, 1, 0, 0, 1]
6) v1 = [1, 1, 0, 0]
7) v1 = [0, 0, 1, 1]
8) v1 = [0, 0, 1, 1, 1, 1, 1, 1]
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2187|std=C++11|before=对 {{c/core|bool}} 的特化缺少 {{tt|emplace}} 与 {{tt|emplace_back}} 成员函数|after=已添加}}
{{dr list end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}