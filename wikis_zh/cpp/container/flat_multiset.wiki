{{cpp/title|flat_multiset}}
{{cpp/container/flat_multiset/navbar}}
{{ddcl|header=flat_set|since=c++23|1=
template&lt;
    class Key,
    class Compare = std::less&lt;Key&gt;,
    class KeyContainer = std::vector&lt;Key&gt;
&gt; class flat_multiset;
}}

平铺多值集合（flat multiset）是一种[[cpp/container#容器适配器|容器适配器]]，给出存储 {{tt|Key}} 类型的对象的有序集合的关联容器的功能。与 {{lc|std::flat_set}} 不同，它允许多个键具有等价值。用键比较函数 {{tt|Compare}} 来进行排序。

类模板 {{tt|flat_multiset}} 表现为对作为 {{tt|KeyContainer}} 类型的对象而传递的底层有序容器的包装器。

每当标准库使用{{named req|Compare}}的要求，都使用等价关系来确定唯一性。非正式而言，如果两个对象 {{c|a}} 和 {{c|b}} 中没有任何一个比较小于另一个，则认为它们等价：{{c|!comp(a, b) &amp;&amp; !comp(b, a)}}。

&lt;!--For std::multimap the following is true (what about flat_multiset?): The order of the key pairs whose keys compare equivalent is the order of insertion and does not change.--&gt;

{{tt|std::flat_set}} 满足{{named req|Container}}、{{named req|ReversibleContainer}}的要求，{{ls|cpp/named_req/Container#可选容器要求}}，以及所有{{named req|AssociativeContainer}}的要求（包括对数阶的搜索复杂度），但：
* 不适用节点相关要求，
* 迭代器失效的要求有所不同，&lt;!--TODO: describe iterator/pointer invalidation properties, maybe per each function --&gt;
* 插入和擦除操作的复杂度呈线性。

平铺多值集合支持{{named req|AssociativeContainer}}的大多数使用等价键的操作。

{{cpp/is_constexpr|since=c++26|transient=yes}}

===迭代器失效===
{{todo}} &lt;!-- TODO: see e.g. [[cpp/container/unordered_set#Iterator invalidation]] as a basis --&gt;

===模板形参===
{{par begin}}
{{par|Key|所存储元素的类型。如果 {{tt|Key}} 与 {{tt|KeyContainer::value_type}} 不是同一类型则程序非良构。}}
{{par|Compare|一种提供严格弱序的{{named req|Compare}}类型。
{{par|KeyContainer|用以存储元素的底层{{named req|SequenceContainer}}的类型。这种容器的迭代器应当满足{{named req|RandomAccessIterator}}或实现 {{lconcept|random_access_iterator}}。

标准容器 {{lc|std::vector}} 和 {{lc|std::deque}} 均满足这些要求。}}}}{{par end}}
&lt;!----&gt;
===成员类型===
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc inc|cpp/container/dsc container_type|flat_multiset}}
{{dsc inc|cpp/container/dsc key_type|flat_multiset}}
{{dsc inc|cpp/container/dsc value_type|flat_multiset}}
{{dsc inc|cpp/container/dsc key_compare|flat_multiset}}
{{dsc inc|cpp/container/dsc value_compare2|flat_multiset}}
{{dsc inc|cpp/container/dsc reference|flat_multiset}}
{{dsc inc|cpp/container/dsc const_reference|flat_multiset}}
{{dsc inc|cpp/container/dsc size_type|flat_multiset}}
{{dsc inc|cpp/container/dsc difference_type|flat_multiset}}
{{dsc inc|cpp/container/dsc iterator|flat_multiset}}
{{dsc inc|cpp/container/dsc const_iterator|flat_multiset}}
{{dsc inc|cpp/container/dsc reverse_iterator|flat_multiset}}
{{dsc inc|cpp/container/dsc const_reverse_iterator|flat_multiset}}
{{dsc end}}

===成员对象===
{{dsc begin}}
{{dsc hitem|成员|说明}}
{{dsc expos mem obj|c|id=c|private=yes|spec={{tt|container_type}}|适配的容器}}
{{dsc expos mem obj|compare|id=compare|private=yes|spec={{tt|key_compare}}|比较函数对象}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc constructor|flat_multiset}}
{{dsc mem dtor|nolink=true|notes={{mark implicit}}|销毁容器适配器的每个元素}}
{{dsc inc|cpp/container/dsc operator{{=}}|flat_multiset}}

{{dsc h2|迭代器}}
{{dsc inc|cpp/container/dsc begin|flat_multiset}}
{{dsc inc|cpp/container/dsc end|flat_multiset}}
{{dsc inc|cpp/container/dsc rbegin|flat_multiset}}
{{dsc inc|cpp/container/dsc rend|flat_multiset}}

{{dsc h2|容量}}
{{dsc inc|cpp/container/dsc empty|flat_multiset}}
{{dsc inc|cpp/container/dsc size|flat_multiset}}
{{dsc inc|cpp/container/dsc max_size|flat_multiset}}

{{dsc h2|修改器}}
{{dsc inc|cpp/container/dsc emplace|flat_multiset}}
{{dsc inc|cpp/container/dsc emplace_hint|flat_multiset}}
{{dsc inc|cpp/container/dsc insert|flat_multiset}}
{{dsc inc|cpp/container/dsc insert_range|flat_multiset}}
{{dsc inc|cpp/container/dsc extract|flat_multiset}}
{{dsc inc|cpp/container/dsc replace|flat_multiset}}
{{dsc inc|cpp/container/dsc erase|flat_multiset}}
{{dsc inc|cpp/container/dsc swap|flat_multiset}}
{{dsc inc|cpp/container/dsc clear|flat_multiset}}

{{dsc h2|查找}}
{{dsc inc|cpp/container/dsc find|flat_multiset}}
{{dsc inc|cpp/container/dsc count|flat_multiset}}
{{dsc inc|cpp/container/dsc contains|flat_multiset}}
{{dsc inc|cpp/container/dsc lower_bound|flat_multiset}}
{{dsc inc|cpp/container/dsc upper_bound|flat_multiset}}
{{dsc inc|cpp/container/dsc equal_range|flat_multiset}}

{{dsc h2|观察器}}
{{dsc inc|cpp/container/dsc key_comp|flat_multiset}}
{{dsc inc|cpp/container/dsc value_comp|flat_multiset}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator_cmp|flat_multiset}}
{{dsc inc|cpp/container/dsc swap2|flat_multiset}}
{{dsc inc|cpp/container/dsc erase_if|flat_multiset}}
{{dsc end}}

===辅助类===
{{dsc begin}}
{{dsc inc|cpp/container/dsc uses_allocator|flat_multiset}}
{{dsc end}}

===标签===
{{dsc begin}}
{{dsc inc|cpp/container/dsc sorted_equivalent}}
{{dsc end}}

==={{rl|deduction guides|推断指导}}===

===注解===
{{cpp/container/assoc_note}}&lt;!-- TODO: is this relevant to flat_multiset? --&gt;

&lt;!-- TODO: maybe this lyrics is unnecessary:
平铺多值集合相对于其他标准[[associative containers|关联容器]]的优势有：
* 可能更快的查找（即便搜索操作具有对数复杂度）。
* 更快的遍历：{{lt|cpp/iterator/random access iterator|随机访问迭代器}}而非{{lt|cpp/iterator/bidirectional iterator|双向迭代器}}。
* 对小对象消耗更少内存（而当 {{c|KeyContainer::shrink_to_fit()}} 可用时对大对象同样如此）。
* 更好的缓存性能（取决于 {{tt|KeyContainer}}，各键可存储于连续内存块之中）。

平铺多值集合的一些缺点有：
* 不稳定的迭代器（迭代器会在插入和擦除元素时失效）。
* 不能存储不可复制和不可移动类型的值。
* 较弱的异常安全性（擦除和插入中进行位移时，复制/移动构造函数可能抛出异常）。
* 更慢（成线性）的插入和擦除，尤其对于不可移动类型。
--&gt;

{{ftm begin}}
{{ftm|__cpp_lib_flat_set|value=202207L|std=C++23|{{lc|std::flat_set}} 和 {{tt|std::flat_multiset}}}}
{{ftm|__cpp_lib_constexpr_containers|value=202502L|std=C++26|{{c/core|constexpr}} {{tt|std::flat_multiset}}}}
{{ftm end}}

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc flat_set}}
{{dsc inc|cpp/container/dsc multiset}}
{{dsc inc|cpp/container/dsc unordered_multiset}}
{{dsc end}}

{{langlinks|cs|de|en|es|fr|it|ja|pl|pt|ru}}

&lt;!--TODO: N4950::24.6.12 says:
TODO: add this to the "Exceptions" sections of appropriate member functions:
6. If any member function in 24.6.12.2 exits via an exception, the invariant is restored.
[Note 2 : This can result in the flat_multiset’s being emptied. — end note].
--&gt;

&lt;!--TODO: N4950::24.6.12.9 says:
TODO: add to constructors:
9. The effect of calling a constructor or member function that takes a sorted_equivalent_t argument with a range that is not sorted with respect to key_comp(), or that contains equal elements, is undefined.
--&gt;

&lt;!-- TODO: also complete [[cpp/container#Iterator invalidation]] table for flat_* adaptors --&gt;