{{cpp/container/priority_queue/title|priority_queue}}
{{cpp/container/priority_queue/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++11|
priority_queue() : priority_queue(Compare(), Container()) {}
}}
{{dcl|num=2|since=c++11|
explicit priority_queue( const Compare&amp; compare )
    : priority_queue(compare, Container()) {}
}}
{{dcl rev multi|num=3
|dcl1=
explicit priority_queue( const Compare&amp; compare = Compare(),
                         const Container&amp; cont = Container() );
|since2=c++11|dcl2=
priority_queue( const Compare&amp; compare, const Container&amp; cont );
}}
{{dcl|num=4|since=c++11|
priority_queue( const Compare&amp; compare, Container&amp;&amp; cont );
}}
{{dcl|num=5|
priority_queue( const priority_queue&amp; other );
}}
{{dcl|num=6|since=c++11|
priority_queue( priority_queue&amp;&amp; other );
}}
{{dcl|num=7|since=c++11|1=
template&lt; class InputIt &gt;
priority_queue( InputIt first, InputIt last,
                const Compare&amp; compare = Compare() );
}}
{{dcl rev multi|num=8
|dcl1=
template&lt; class InputIt &gt;
priority_queue( InputIt first, InputIt last,
                const Compare&amp; compare = Compare(),
                const Container&amp; cont = Container() );
|since2=c++11|dcl2=
template&lt; class InputIt &gt;
priority_queue( InputIt first, InputIt last,
                const Compare&amp; compare, const Container&amp; cont );
}}
{{dcl|num=9|since=c++11|
template&lt; class InputIt &gt;
priority_queue( InputIt first, InputIt last,
                const Compare&amp; compare, Container&amp;&amp; cont );
}}
{{dcl|num=10|since=c++11|
template&lt; class Alloc &gt;
explicit priority_queue( const Alloc&amp; alloc );
}}
{{dcl|num=11|since=c++11|
template&lt; class Alloc &gt;
priority_queue( const Compare&amp; compare, const Alloc&amp; alloc );
}}
{{dcl|num=12|since=c++11|
template&lt; class Alloc &gt;
priority_queue( const Compare&amp; compare, const Container&amp; cont,
                const Alloc&amp; alloc );
}}
{{dcl|num=13|since=c++11|
template&lt; class Alloc &gt;
priority_queue( const Compare&amp; compare, Container&amp;&amp; cont,
                const Alloc&amp; alloc );
}}
{{dcl|num=14|since=c++11|
template&lt; class Alloc &gt;
priority_queue( const priority_queue&amp; other, const Alloc&amp; alloc );
}}
{{dcl|num=15|since=c++11|
template&lt; class Alloc &gt;
priority_queue( priority_queue&amp;&amp; other, const Alloc&amp; alloc );
}}
{{dcl|num=16|since=c++11|
template&lt; class InputIt, class Alloc &gt;
priority_queue( InputIt first, InputIt last, const Alloc&amp; alloc );
}}
{{dcl|num=17|since=c++11|
template&lt; class InputIt, class Alloc &gt;
priority_queue( InputIt first, InputIt last, const Compare&amp; compare,
                const Alloc&amp; alloc );
}}
{{dcl|num=18|since=c++11|
template&lt; class InputIt, class Alloc &gt;
priority_queue( InputIt first, InputIt last, const Compare&amp; compare,
                const Container&amp; cont, const Alloc&amp; alloc );
}}
{{dcl|num=19|since=c++11|
template&lt; class InputIt, class Alloc &gt;
priority_queue( InputIt first, InputIt last, const Compare&amp; compare,
                Container&amp;&amp; cont, const Alloc&amp; alloc );
}}
{{dcla|num=20|since=c++23|1=
template&lt; container-compatible-range&lt;T&gt; R &gt;
priority_queue( std::from_range_t, R&amp;&amp; rg,
                const Compare&amp; compare = Compare() );
}}
{{dcl|num=21|since=c++23|
template&lt; container-compatible-range&lt;T&gt; R, class Alloc &gt;
priority_queue( std::from_range_t, R&amp;&amp; rg,
                const Compare&amp; compare, const Alloc&amp; alloc );
}}
{{dcl|num=22|since=c++23|
template&lt; container-compatible-range&lt;T&gt; R, class Alloc &gt;
priority_queue( std::from_range_t, R&amp;&amp; rg, const Alloc&amp; alloc );
}}
{{dcl end}}

从多种数据源构造容器适配器的底层容器。

@1@ 默认构造函数。值初始化比较器和底层容器。

@2@ 用 {{c|compare}} 的内容复制构造比较函数对象 {{tt|comp}}。值初始化底层容器 {{c|c}}。

@3@ 用 {{c|cont}} 的内容复制构造底层容器 {{c|c}}。用 {{c|compare}} 的内容复制构造比较函数对象 {{c|comp}}。调用 {{c|std::make_heap(c.begin(), c.end(), comp)}}。{{rev inl|until=c++11|此亦为默认构造函数。}}

@4@ 用 {{c|std::move(cont)}} 移动构造底层容器 {{c|c}}。以 {{c|compare}} 的内容复制构造比较函数对象 {{c|comp}}。调用 {{c|std::make_heap(c.begin(), c.end(), comp)}}。

@5@ [[cpp/language/copy constructor|复制构造函数]]。以 {{c|other.c}} 的内容复制构造底层容器。以 {{c|other.comp}} 复制构造比较函数对象。 {{mark implicit}}

@6@ [[cpp/language/move constructor|移动构造函数]]。以 {{c|std::move(other.c)}} 构造底层容器。以 {{c|std::move(other.comp)}} 构造比较函数对象。 {{mark implicit}}

@7-9@ 迭代器对构造函数。{{cpp/enable_if| {{tt|InputIt}} 满足{{named req|InputIterator}}|plural=yes}}。

@7@ 如同用 {{c|c(first, last)}} 构造 {{c|c}} 并从 {{c|compare}} 构造 {{c|comp}}，然后调用 {{c|std::make_heap(c.begin(), c.end(), comp);}}。

@8@ 从 {{c|cont}} 复制构造 {{c|c}} 并从 {{c|compare}} 复制构造 {{c|comp}}。然后调用 {{c|c.insert(c.end(), first, last);}}，再调用 {{c|std::make_heap(c.begin(), c.end(), comp);}}。

@9@ 从 {{c|std::move(cont)}} 移动构造 {{c|c}} 并从 {{c|compare}} 复制构造 {{c|comp}}。然后调用 {{c|c.insert(c.end(), first, last);}}，再调用 {{c|std::make_heap(c.begin(), c.end(), comp);}}。

@10-15@ 分配器扩展构造函数。{{cpp/enable_if| {{c|std::uses_allocator&lt;container_type, Alloc&gt;::value}} 为 {{c|true}}，即底层容器为知分配器容器（对所有标准库容器为真）|plural=yes}}。

@10@ 以 {{c|alloc}} 为分配器构造底层容器。实际上调用 {{c|c(alloc)}}。值初始化 {{c|comp}}。

@11@ 以 {{c|alloc}} 为分配器构造底层容器。实际上调用 {{c|c(alloc)}}。从 {{c|compare}} 复制构造 {{c|comp}}。

@12@ 用 {{c|cont}} 的内容，以 {{c|alloc}} 为分配器构造底层容器，如同用 {{c|c(cont, alloc)}}。从 {{c|compare}} 复制构造 {{c|comp}}。然后调用 {{c|std::make_heap(c.begin(), c.end(), comp)}}。

@13@ 用 {{c|cont}} 的内容，以 {{c|alloc}} 为分配器并以移动语义构造底层容器，如同用 {{c|c(std::move(cont), alloc)}}。从 {{c|compare}} 复制构造 {{c|comp}}。然后调用 {{c|std::make_heap(c.begin(), c.end(), comp)}}。

@14@ 用 {{c|other.c}} 的内容，以 {{c|alloc}} 为分配器构造底层容器。实际上调用 {{c|c(other.c, alloc)}}。从 {{c|other.comp}} 复制构造 {{c|comp}}。

@15@ 用 {{c|other}} 的内容，同时以 {{c|alloc}} 为分配器，使用移动语义构造底层容器。实际上调用 {{c|c(std::move(other.c), alloc)}}。从 {{c|other.comp}} 移动构造 {{c|comp}}。

@16-19@ 分配器扩展的迭代器对构造函数，同 {{v|7-9}}，但用 {{c|alloc}} 构造底层容器。{{cpp/enable_if| {{c|std::uses_allocator&lt;container_type, Alloc&gt;::value}} 为 {{c|true}} 且 {{tt|InputIt}} 满足{{named req|InputIterator}}|plural=yes}}。

@20@ 以 {{c|compare}} 初始化 {{c|comp}}，并以 {{c|ranges::to&lt;Container&gt;(std::forward&lt;R&gt;(rg))}} 初始化 {{c|c}}。然后调用 {{c|std::make_heap(c.begin(), c.end(), comp)}}。
@21@ 以 {{c|compare}} 初始化 {{c|comp}}，并以 {{c|ranges::to&lt;Container&gt;(std::forward&lt;R&gt;(rg), alloc)}} 初始化 {{c|c}}。然后调用 {{c|std::make_heap(c.begin(), c.end(), comp)}}。
@22@ 以 {{c|ranges::to&lt;Container&gt;(std::forward&lt;R&gt;(rg), alloc)}} 初始化 {{c|c}}。然后调用 {{c|std::make_heap(c.begin(), c.end(), comp)}}。

注意，实现检查类型是否满足{{named req|InputIterator}}的方法是未指明的，但要求拒绝所有整数类型。

===参数===
{{par begin}}
{{par|alloc|用于底层容器所有内存分配的分配器}}
{{par|other|用作初始化底层容器的源的另一容器适配器}}
{{par|cont|用作初始化底层容器的源的容器}}
{{par|compare|用于初始化底层比较函数对象的比较函数对象}}
{{par range|3=要以之初始化的}}
{{par|rg|{{ls|cpp/ranges/to#容器兼容范围}}，即其元素可以转换为 {{tt|T}} 的 {{lconcept|input_range}}}}
{{par hreq}}
{{par req named|Alloc|Allocator}}
{{par req named|Compare|Compare}}
{{par req named|Container|Container|notes=仅若 {{tt|Container}} 满足{{named req|AllocatorAwareContainer}}的要求才定义分配器扩展构造函数}}
{{par req named|InputIt|InputIterator}}
{{par end}} 

===复杂度===
@1,2@ 常数。

@3,5,12@ {{mathjax-or|\(\scriptsize \mathcal{O}{(N)}\)|O(N)}} 次比较和 {{mathjax-or|\(\scriptsize \mathcal{O}{(N)}\)|O(N)}} 次 {{tt|value_type}} 构造函数调用，其中 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|cont.size()}}。

@4@ {{mathjax-or|\(\scriptsize \mathcal{O}{(N)}\)|O(N)}} 次比较，其中 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|cont.size()}}。

@6@ 常数。

@7,16,17@ {{mathjax-or|\(\scriptsize \mathcal{O}{(M)}\)|O(M)}} 次比较，其中 {{mathjax-or|\(\scriptsize M\)|M}} 为 {{c|std::distance(first, last)}}。

@8,18@ {{mathjax-or|\(\scriptsize \mathcal{O}{(N + M)}\)|O(N + M)}} 次比较和 {{mathjax-or|\(\scriptsize \mathcal{O}{(N)}\)|O(N)}} 次 {{tt|value_type}} 构造函数调用，其中 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|cont.size()}}，{{mathjax-or|\(\scriptsize M\)|M}} 为 {{c|std::distance(first, last)}}。

@9@ {{mathjax-or|\(\scriptsize \mathcal{O}{(N + M)}\)|O(N + M)}} 次比较，其中 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|cont.size()}}，{{mathjax-or|\(\scriptsize M\)|M}} 为 {{c|std::distance(first, last)}}。

@10,11@ 常数。

@13@ {{mathjax-or|\(\scriptsize \mathcal{O}{(N)}\)|O(N)}} 次比较，其中 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|cont.size()}}。

@14@ 与 {{tt|other}} 的大小成线性。

@15@ 若 {{tt|Alloc}} 与 {{c|other}} 的分配器比较相等则为常数。否则与 {{c|other}} 的大小成线性。

@19@ {{mathjax-or|\(\scriptsize \mathcal{O}{(N + M)}\)|O(N + M)}} 次比较与可能存在的 {{mathjax-or|\(\scriptsize \mathcal{O}{(N)}\)|O(N)}} 次 {{tt|value_type}} 构造函数调用（若 {{tt|Alloc}} 与 {{c|other}} 的分配器比较不相等则存在），其中 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|cont.size()}}，{{mathjax-or|\(\scriptsize M\)|M}} 为 {{c|std::distance(first, last)}}。

@20@ {{mathjax-or|\(\scriptsize \mathcal{O}{(N)}\)|O(N)}} 次比较和 {{mathjax-or|\(\scriptsize \mathcal{O}{(N)}\)|O(N)}} 次 {{tt|value_type}} 构造函数调用，其中 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|ranges::distance(rg)}}。

@21,22@ {{todo}}

===注解===
{{feature test macro|__cpp_lib_containers_ranges|[[cpp/ranges/to#容器兼容范围|按范围]]构造和插入；重载 {{vl|20-22}}|value=202202L|std=C++23}}

===示例===
{{example
|code=
#include &lt;complex&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

int main()
{
    std::priority_queue&lt;int&gt; pq1;
    pq1.push(5);
    std::cout &lt;&lt; "pq1.size() = " &lt;&lt; pq1.size() &lt;&lt; '\n';

    std::priority_queue&lt;int&gt; pq2 {pq1};
    std::cout &lt;&lt; "pq2.size() = " &lt;&lt; pq2.size() &lt;&lt; '\n';

    std::vector&lt;int&gt; vec {3, 1, 4, 1, 5};
    std::priority_queue&lt;int&gt; pq3 {std::less&lt;int&gt;(), vec};
    std::cout &lt;&lt; "pq3.size() = " &lt;&lt; pq3.size() &lt;&lt; '\n';

    for (std::cout &lt;&lt; "pq3 : "; !pq3.empty(); pq3.pop())
        std::cout &lt;&lt; pq3.top() &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    // 带定制比较器的演示：

    using my_value_t = std::complex&lt;double&gt;;
    using my_container_t = std::vector&lt;my_value_t&gt;;

    auto my_comp = [](const my_value_t&amp; z1, const my_value_t&amp; z2)
    {
        return z2.real() &lt; z1.real();
    };

    std::priority_queue&lt;my_value_t,
                        my_container_t,
                        decltype(my_comp)&gt; pq4{my_comp};

    using namespace std::complex_literals;
    pq4.push(5.0 + 1i);
    pq4.push(3.0 + 2i);
    pq4.push(7.0 + 3i);

    for (; !pq4.empty(); pq4.pop())
    {
        const auto&amp; z = pq4.top();
        std::cout &lt;&lt; "pq4.top() = " &lt;&lt; z &lt;&lt; '\n';
    }

    // TODO: C++23 知范围的构造函数
}
|output=
pq1.size() = 1
pq2.size() = 1
pq3.size() = 5
pq3 : 5 4 3 1 1
pq4.top() = (3,2)
pq4.top() = (5,1)
pq4.top() = (7,3)
}}

===缺陷报告===
{{dr list begin}}
{{dr list item | paper=P0935R0 | std=C++11 | before=默认构造函数和构造函数 {{v|4}} 曾为 explicit | after=使之为隐式}}
{{dr list item | wg=lwg | dr=3506 | std=C++11 | before=分配器扩展迭代器对构造函数缺失 | after=已添加}}
{{dr list item | wg=lwg | dr=3522 | std=C++11 | before=迭代器对构造函数上的约束缺失 | after=已添加}}
{{dr list item | wg=lwg | dr=3529 | std=C++11 | before=从一对迭代器构造调用 {{tt|insert}} | after=从它们构造容器}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator{{=}}|priority_queue}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}