{{cpp/title|priority_queue}}
{{cpp/container/priority_queue/navbar}}
{{ddcl|header=queue|1=
template&lt;
    class T,
    class Container = std::vector&lt;T&gt;,
    class Compare = std::less&lt;typename Container::value_type&gt;
&gt; class priority_queue;
}}

{{enwiki|Queue (abstract data type)|优先级队列}}是一种[[cpp/container#容器适配器|容器适配器]]，它提供常数时间的（默认）最大元素查找，对数代价的插入与提取。

可以通过用户提供的 {{tt|Compare}} 更改顺序，例如，用 {{lc|std::greater&lt;T&gt;}} 将导致最小元素作为 {{lc|top()}} 出现。

{{tt|priority_queue}} 的作用类似于管理某些随机访问容器中的[[cpp/algorithm/make_heap|堆]]，其优势是不可能意外使堆失效。

{{cpp/is_constexpr|since=c++26|transient=yes}}

===模板形参===
{{par begin}}
{{par|T|存储元素的类型。{{tt|T}} 与 {{tt|Container::value_type}} 不是同一类型时非良构。}}
{{par|Container|用于存储元素的底层容器类型。容器必须满足{{named req|SequenceContainer}}的要求，并且它的迭代器必须满足{{named req|RandomAccessIterator}}的要求。另外，它必须提供拥有[[cpp/named req/SequenceContainer#可选操作|通常语义]]的下列函数：
* {{tt|back()}}，例如 {{lc|std::vector::back()}}，
* {{tt|push_back()}}，例如 {{lc|std::deque::push_back()}}，
* {{tt|pop_back()}}，例如 {{lc|std::vector::pop_back()}}。

标准容器 {{lc|std::vector}}（不包括 {{ltt|cpp/container/vector bool|std::vector&lt;bool&gt;}}）和 {{lc|std::deque}} 满足这些要求。}}
{{par|Compare|提供严格弱序的{{named req|Compare}}类型。

注意{{named req|Compare}}形参的定义，使得它的第一实参在弱序中 ''先于'' 它的第二实参时返回 {{c|true}}。但因为优先级队列首先输出最大元素，所以“先来”的元素实际上会在最后输出。即队列头含有按照{{named req|Compare}}所施加弱序的“最后”元素。}}
{{par end}}

===成员类型===
{{dsc begin}}
{{dsc hitem |类型|定义}}
{{dsc inc|cpp/container/dsc container_type|priority_queue}}
{{dsc|{{tt|value_compare}}|{{tt|Compare}}}}
{{dsc inc|cpp/container/dsc value_type|priority_queue}}
{{dsc inc|cpp/container/dsc size_type|priority_queue}}
{{dsc inc|cpp/container/dsc reference|priority_queue}}
{{dsc inc|cpp/container/dsc const_reference|priority_queue}}
{{dsc end}}

===成员对象===
{{dsc begin}}
{{dsc hitem|名字|定义}}
{{dsc inc|cpp/container/dsc c|priority_queue}}
{{dsc prot mem obj|nolink=true|{{dsc small|Compare}} comp|比较函数对象}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc constructor|priority_queue}}
{{dsc inc|cpp/container/dsc destructor|priority_queue}}
{{dsc inc|cpp/container/dsc operator{{=}}|priority_queue}}

{{dsc h2|元素访问}}
{{dsc inc|cpp/container/dsc top|priority_queue}}

{{dsc h2|容量}}
{{dsc inc|cpp/container/dsc empty|priority_queue}}
{{dsc inc|cpp/container/dsc size|priority_queue}}

{{dsc h2|修改器}}
{{dsc inc|cpp/container/dsc push|priority_queue}}
{{dsc inc|cpp/container/dsc push_range|priority_queue}}
{{dsc inc|cpp/container/dsc emplace|priority_queue}}
{{dsc inc|cpp/container/dsc pop|priority_queue}}
{{dsc inc|cpp/container/dsc swap|priority_queue}}

{{dsc h1|成员对象}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc swap2|priority_queue}}
{{dsc end}}

===辅助类===
{{dsc begin}}
{{dsc inc|cpp/container/dsc uses_allocator|priority_queue}}
{{dsc inc|cpp/container/dsc adaptor_formatter|priority_queue}}
{{dsc end}}

{{rrev|since=c++17|
==={{rl|deduction guides|推导指引}}===
}}

===注解===
{{ftm begin|std=1|comment=1}}
{{ftm|__cpp_lib_containers_ranges|value=202202L|std=C++23|容器的[[cpp/ranges/to#容器兼容范围|按范围]]构造和插入}}
{{ftm|__cpp_lib_constexpr_containers|value=202502L|std=C++26|{{c/core|constexpr}} {{tt|std::priority_queue}}}}
{{ftm end}}

===示例===
{{example
|code=
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

template&lt;typename T&gt;
void pop_println(std::string_view rem, T&amp; pq)
{
    std::cout &lt;&lt; rem &lt;&lt; ": ";
    for (; !pq.empty(); pq.pop())
        std::cout &lt;&lt; pq.top() &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

template&lt;typename T&gt;
void println(std::string_view rem, const T&amp; v)
{
    std::cout &lt;&lt; rem &lt;&lt; ": ";
    for (const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    const auto data = {1, 8, 5, 6, 3, 4, 0, 9, 7, 2};
    println("data", data);

    std::priority_queue&lt;int&gt; max_priority_queue;

    // 填充优先级队列。
    for (int n : data)
        max_priority_queue.push(n);

    pop_println("max_priority_queue", max_priority_queue);

    // std::greater&lt;int&gt; 使得最大优先队列表现为最小优先队列。
    std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt;
        min_priority_queue1(data.begin(), data.end());

    pop_println("min_priority_queue1", min_priority_queue1);

    // 定义最小优先队列的另一种方法
    std::priority_queue min_priority_queue2(data.begin(), data.end(), std::greater&lt;int&gt;());

    pop_println("min_priority_queue2", min_priority_queue2);

    // 使用自定义的函数对象来比较元素。
    struct
    {
        bool operator()(const int l, const int r) const { return l &gt; r; }
    } customLess;

    std::priority_queue custom_priority_queue(data.begin(), data.end(), customLess);

    pop_println("custom_priority_queue", custom_priority_queue);

    // 使用 lambda 来比较元素。
    auto cmp = [](int left, int right) { return (left ^ 1) &lt; (right ^ 1); };
    std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(cmp)&gt; lambda_priority_queue(cmp);

    for (int n : data)
        lambda_priority_queue.push(n);

    pop_println("lambda_priority_queue", lambda_priority_queue);
}
|output=
data: 1 8 5 6 3 4 0 9 7 2
max_priority_queue: 9 8 7 6 5 4 3 2 1 0
min_priority_queue1: 0 1 2 3 4 5 6 7 8 9
min_priority_queue2: 0 1 2 3 4 5 6 7 8 9
custom_priority_queue: 0 1 2 3 4 5 6 7 8 9
lambda_priority_queue: 8 9 6 7 4 5 2 3 0 1
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=307|std=C++98|before={{tt|Container}} 不能是 {{tt|std::vector&lt;bool&gt;}}|after=可以是}}
{{dr list item|wg=lwg|dr=2566|std=C++98|before=缺少对 {{tt|Container::value_type}} 的要求|after={{tt|T}} 和 {{tt|Container::value_type}} 不同时非良构}}
{{dr list item|wg=lwg|dr=2684|std=C++98|before={{tt|priority_queue}} 接收比较器但缺少对它的成员 typedef|after=已添加}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc vector}}
{{dsc inc|cpp/container/dsc vector bool}}
{{dsc inc|cpp/container/dsc deque}}
{{dsc end}}

{{langlinks|cs|de|en|es|fr|it|ja|pl|pt|ru|tr}}