{{cpp/container/unordered_set/title|insert}}
{{cpp/container/unordered_set/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++11|
std::pair&lt;iterator,bool&gt; insert( const value_type&amp; value );
}}
{{dcl|num=2|since=c++11|
std::pair&lt;iterator,bool&gt; insert( value_type&amp;&amp; value );
}}
{{dcl|num=3|since=c++11|
iterator insert( const_iterator hint, const value_type&amp; value );
}}
{{dcl|num=4|since=c++11|
iterator insert( const_iterator hint, value_type&amp;&amp; value );
}}
{{dcl|num=5|since=c++11|
template&lt; class InputIt &gt;
void insert( InputIt first, InputIt last );
}}
{{dcl|num=6|since=c++11|
void insert( std::initializer_list&lt;value_type&gt; ilist );
}}
{{dcl|num=7|since=c++17|
insert_return_type insert( node_type&amp;&amp; nh );
}}
{{dcl|num=8|since=c++17|
iterator insert( const_iterator hint, node_type&amp;&amp; nh );
}}
{{dcla|num=9|since=c++23|
template&lt; class K &gt;
std::pair&lt;iterator, bool&gt; insert( K&amp;&amp; obj );
}}
{{dcl|num=10|since=c++23|
template&lt; class K &gt;
iterator insert( const_iterator hint, K&amp;&amp; obj );
}}
{{dcl end}}

若容器尚未含有等价的键的元素，则插入元素到容器中。

@1,2@ 插入 {{c|value}}。

@3,4@ 插入 {{c|value}}，以 {{c|hint}} 为应当开始搜索的位置的非强制建议。

@5@ 插入来自范围 {{range|first|last}} 的元素。{{cpp/container/lwg2488-note}}

@6@ 插入来自 initializer_list {{c|ilist}} 的元素。{{cpp/container/lwg2488-note}}

{{cpp/container/node_handle_insert_desc|unordered_set|7|8}}

@9@ 如果 {{c|*this}} 已经包含了与 {{c|obj}} 透明比较相等的元素，则不做任何事。否则，以 {{c|std::forward&lt;K&gt;(obj)}} 构造一个 {{rlpt|/#成员类型|value_type}} 类型的对象 {{tt|u}}，然后将 {{tt|u}} 插入 {{c|*this}} 中。如果 {{c|1=equal_range(u) != equal_range(obj)}} 为 {{c|true}}，则其行为未定义。{{tt|value_type}} 必须为以 {{c|std::forward&lt;K&gt;(obj)}} 向 {{tt|unordered_set}} 中{{named req|EmplaceConstructible}}。{{cpp/container/unordered_heterogeneous_lookup}}

@10@ 如果 {{c|*this}} 已经包含了与 {{c|obj}} 透明比较相等的元素，则不做任何事。
否则，以 {{c|std::forward&lt;K&gt;(obj)}} 构造一个 {{rlpt|/#成员类型|value_type}} 类型的对象 {{tt|u}}，然后将 {{tt|u}} 插入 {{c|*this}} 中，以 {{c|hint}} 为从何处开始搜索的非强制建议。如果 {{c|1=equal_range(u) != equal_range(obj)}} 为 {{c|true}}，则其行为未定义。
{{tt|value_type}} 必须为以 {{c|std::forward&lt;K&gt;(obj)}} 向 {{tt|unordered_set}} 中{{named req|EmplaceConstructible}}。仅当符合以下条件时，此重载才参与重载决议：
* {{c|std::is_convertible_v&lt;K&amp;&amp;, const_iterator&gt;}} 和 {{c|std::is_convertible_v&lt;K&amp;&amp;, iterator&gt;}} 均为 {{c|false}}，并且
* {{c|Hash::is_transparent}} 和 {{c|KeyEqual::is_transparent}} 均合法且各自代表某个类型。其中假定这个 {{tt|Hash}} 对于类型 {{tt|K}} 和 {{tt|Key}} 均可调用，且 {{tt|KeyEqual}} 是透明的。
这些条件共同允许不构造 {{tt|Key}} 就能调用此函数。

{{cpp/container/note_iterator_invalidation|unordered_set|insert}}

===参数===
{{par begin}}
{{par|hint|迭代器，用作插入内容位置的建议}}
{{par|value|要插入的元素值}}
{{par range|3=要插入的|range=源}}
{{par|ilist|插入值来源的 initializer_list}}
{{par|nh|兼容的[[cpp/container/node_handle|结点句柄]]}}
{{par|obj|可以与键进行透明比较的任意类型的值}}
{{par hreq}}
{{par req named | InputIt | InputIterator}}
{{par end}} 

===返回值===
@1,2@ {{cpp/container/return iterator pair||pair}}

@3,4@ {{cpp/container/return iterator pair}}

@5,6@ （无）

{{cpp/container/node_handle_insert_return|unordered_set|7|8}}

@9@ {{cpp/container/return iterator pair||pair}}

@10@ {{cpp/container/return iterator pair}}

===异常===
@1-4@ 若任何操作抛出异常，则插入无效果。

{{todo|情况 5-10}}

===复杂度===
@1-4@ 平均情况：{{tt|O(1)}}，最坏情况 {{tt|O(size())}}。

@5,6@ 平均情况：{{tt|O(N)}}，其中 N 是要插入的元素数。最坏情况： {{tt|O(N*size()+N)}}。

@7-10@ 平均情况：{{tt|O(1)}}，最坏情况 {{tt|O(size())}}。

===注解===
{{cpp/container/hinted insert note}}

{{ftm begin}}
{{ftm|__cpp_lib_associative_heterogeneous_insertion|std=C++26|value=202311L|[[cpp/container#关联容器|有序]]和[[cpp/container#无序关联容器|无序]]关联{{lt|cpp/container|容器}}中剩余成员函数的异质重载。{{vl|9,10}}}}
{{ftm end}}

===示例===
{{example
|code=
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, std::unordered_set&lt;int&gt; const&amp; s)
{
    for (os &lt;&lt; '[' &lt;&lt; s.size() &lt;&lt; "] { "; int i : s)
        os &lt;&lt; i &lt;&lt; ' ';
    return os &lt;&lt; "}\n";
}

int main ()
{
    std::unordered_set&lt;int&gt; nums{2, 3, 4};

    std::cout &lt;&lt; "1) 起初: " &lt;&lt; nums &lt;&lt; std::boolalpha;
    auto p = nums.insert(1); // 插入元素, 重载 (1)
    std::cout &lt;&lt; "2) '1' 已被插入: " &lt;&lt; p.second &lt;&lt; '\n';
    std::cout &lt;&lt; "3) 插入后: " &lt;&lt; nums;

    nums.insert(p.first, 0); // 按提示插入, 重载 (3)
    std::cout &lt;&lt; "4) 插入后: " &lt;&lt; nums;

    std::array&lt;int, 4&gt; a = {10, 11, 12, 13};
    nums.insert(a.begin(), a.end()); // 插入范围, 重载 (5)
    std::cout &lt;&lt; "5) 插入后: " &lt;&lt; nums;

    nums.insert({20, 21, 22, 23}); // 插入 initializer_list, (6)
    std::cout &lt;&lt; "6) 插入后: " &lt;&lt; nums;

    std::unordered_set&lt;int&gt; other_nums = {42, 43};
    auto node = other_nums.extract(other_nums.find(42));
    nums.insert(std::move(node)); // 插入节点, 重载 (7)
    std::cout &lt;&lt; "7) 插入后: " &lt;&lt; nums;

    node = other_nums.extract(other_nums.find(43));
    nums.insert(nums.begin(), std::move(node)); // 按提示插入节点, (8)
    std::cout &lt;&lt; "8) 插入后: " &lt;&lt; nums;
}
|p=true
|output=
1) 起初: [3] { 4 3 2 }
2) '1' 已被插入: true
3) 插入后: [4] { 1 2 3 4 }
4) 插入后: [5] { 0 1 2 3 4 }
5) 插入后: [9] { 13 12 11 10 4 3 2 1 0 }
6) 插入后: [13] { 23 22 13 12 11 10 21 4 20 3 2 1 0 }
7) 插入后: [14] { 42 23 22 13 12 11 10 21 4 20 3 2 1 0 }
8) 插入后: [15] { 43 42 23 22 13 12 11 10 21 4 20 3 2 1 0 }
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc emplace|unordered_set}}
{{dsc inc|cpp/container/dsc emplace_hint|unordered_set}}
{{dsc inc|cpp/iterator/dsc inserter}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}