{{cpp/container/vector/title|vector}}
{{cpp/container/vector/navbar}}
{{dcl begin}}
{{dcl rev begin|num=1}}
{{dcl|since=c++11|until=c++17|
vector() : vector(Allocator()) {}
}}
{{dcla|since=c++17|constexpr=c++20|
vector() noexcept(noexcept(Allocator())) : vector(Allocator()) {}
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|until=c++11|1=
explicit vector( const Allocator&amp; alloc = Allocator() );
}}
{{dcla|since=c++11|noexcept=c++17|constexpr=c++20|
explicit vector( const Allocator&amp; alloc );
}}
{{dcl rev end}}
{{dcl|num=3|since=c++11|1=
explicit vector( size_type count,
                 const Allocator&amp; alloc = Allocator() );
}}
{{dcl rev begin|num=4}}
{{dcl|until=c++11|1=
explicit vector( size_type count, const T&amp; value = T(),
                 const Allocator&amp; alloc = Allocator() );
}}
{{dcla|since=c++11|constexpr=c++20|1=
vector( size_type count, const T&amp; value,
        const Allocator&amp; alloc = Allocator() );
}}
{{dcl rev end}}
{{dcla|num=5|constexpr=c++20|1=
template&lt; class InputIt &gt;
vector( InputIt first, InputIt last,
        const Allocator&amp; alloc = Allocator() );
}}
{{dcl|num=6|since=c++23|1=
template&lt; container-compatible-range&lt;T&gt; R &gt;
constexpr vector( std::from_range_t, R&amp;&amp; rg,
                  const Allocator&amp; alloc = Allocator() );
}}
{{dcla|num=7|constexpr=c++20|
vector( const vector&amp; other );
}}
{{dcla|num=8|since=c++11|noexcept=c++17|constexpr=c++20|
vector( vector&amp;&amp; other );
}}
{{dcl rev begin|num=9}}
{{dcla|since=c++11|constexpr=c++20|until=c++23|
vector( const vector&amp; other, const Allocator&amp; alloc );
}}
{{dcl|since=c++23|
constexpr vector( const vector&amp; other,
                  const std::type_identity_t&lt;Allocator&gt;&amp; alloc );
}}
{{dcl rev end}}
{{dcl rev begin|num=10}}
{{dcl|since=c++11|constexpr=c++20|until=c++23|
vector( vector&amp;&amp; other, const Allocator&amp; alloc );
}}
{{dcl|since=c++23|
constexpr vector( vector&amp;&amp; other,
                  const std::type_identity_t&lt;Allocator&gt;&amp; alloc );
}}
{{dcl rev end}}
{{dcl|num=11|since=c++11|1=
vector( std::initializer_list&lt;T&gt; init,
        const Allocator&amp; alloc = Allocator() );
}}
{{dcl end}}

从各种数据源构造新 {{tt|vector}}，可以使用用户提供的分配器 {{c|alloc}}。

@1@ C++11 起的默认构造函数。构造拥有默认构造的分配器的空 {{tt|vector}}。
@@ 如果 {{tt|Allocator}} 不{{named req|DefaultConstructible}}，那么行为未定义。

@2@ C++11 前的默认构造函数。构造拥有给定分配器 {{c|alloc}} 的空 {{tt|vector}}。

@3@ 构造拥有 {{c|count}} 个默认插入的 {{tt|T}} 对象的 {{tt|vector}}。不进行复制。
@@ 如果 {{tt|T}} 不{{named req|DefaultInsertable}}到 {{c/core|std::vector&lt;T&gt;}} 中，那么行为未定义。

@4@ 构造拥有 {{c|count}} 个值 {{c|value}} 的元素的 {{tt|vector}}。
{{rrev|since=c++11|
如果 {{tt|T}} 不{{named req|CopyInsertable}}到 {{c/core|std::vector&lt;T&gt;}} 中，那么行为未定义。
}}

@5@ 以范围 {{range|first|last}} 的内容构造 {{tt|vector}}。{{range|first|last}} 中的每个迭代器都只会解引用一次。
{{rev begin}}
{{rev|until=c++11|
如果 {{tt|InputIt}} 不满足{{named req|InputIterator}}，那么就会改为以实参 {{c|static_cast&lt;size_type&gt;(first)}}、{{c|last}} 和 {{c|alloc}} 调用重载 {{v|4}}。
}}
{{rev|since=c++11|
{{cpp/enable if| {{tt|InputIt}} 满足{{named req|InputIterator}}}}。

如果满足以下任意条件，那么行为未定义：
* {{tt|T}} 从 {{c|*first}} 不{{named req|EmplaceConstructible}}到 {{c/core|std::vector&lt;T&gt;}} 中。
* {{tt|Iter}} 不满足{{named req|ForwardIterator}}，并且 {{tt|T}} 不{{named req|MoveInsertable}}到 {{c/core|std::vector&lt;T&gt;}} 中。
}}
{{rev end}}

@6@ 以范围 {{c|rg}} 的内容构造 {{tt|vector}}。{{c|rg}} 中的每个迭代器都只会解引用一次。
@@ 如果满足以下任意条件，那么行为未定义。
* {{tt|T}} 从 {{c|*ranges::begin(rg)}} 不{{named req|EmplaceConstructible}}到 {{c/core|std::vector&lt;T&gt;}} 中。
* {{tt|R}} 既未实现 {{lconcept|sized_range}} 也未实现 {{lconcept|forward_range}}，并且 {{tt|T}} 不{{named req|MoveInsertable}}到 {{c/core|std::vector&lt;T&gt;}} 中。

@7-10@ 以 {{c|other}} 的内容构造 {{tt|vector}}。

:@7@ 复制构造函数。
{{rrev|since=c++11|
如同通过调用 {{c multi|std::allocator_traits&lt;Allocator&gt;::|    select_on_container_copy_construction|        (other.get_allocator())}} 获得分配器。
}}

:@8@ 移动构造函数。如同通过从 {{c|other.get_allocator()}} 移动构造获得分配器。

:@9@ 与构造函数相同，但是会将 {{c|alloc}} 用作分配器。
{{rrev|since=c++11|
如果 {{tt|T}} 不{{named req|CopyInsertable}}到 {{c/core|std::vector&lt;T&gt;}} 中，那么行为未定义。
}}

:@10@ 与移动函数相同，但是会将 {{c|alloc}} 用作分配器。
:@@ 如果 {{tt|T}} 不{{named req|MoveInsertable}}到 {{c/core|std::vector&lt;T&gt;}} 中，那么行为未定义。

@11@ 等价于 {{c|vector(il.begin(), il.end(), alloc)}}。

===参数===
{{par begin}}
{{par|alloc|用于此容器所有内存分配的分配器}}
{{par|count|容器的大小}}
{{par|value|以之初始化容器元素的值}}
{{par range|3=要从中复制元素的}}
{{par|rg|与容器兼容的范围}}
{{par|other|用作初始化容器元素来源的另一容器}}
{{par|init|用作初始化元素来源的初始化器列表}}
{{par end}}

===复杂度===
@1,2@ 常数。

@3,4@ 与 {{c|count}} 成线性。

@5@ 给定 {{c|std::distance(first, last)}} 为 {{math|N}}，
* 如果 {{c|first}} 和 {{c|last}} 都是前向，双向或随机访问迭代器，那么
:* 只会调用 {{math|N}}{{nbsp}} 次 {{tt|T}} 的复制构造函数，并且
:* 不会进行重分配。
* 否则（{{c|first}} 和 {{c|last}} 都只是输入迭代器），
:* 会调用 {{math|O(N)}} 次 {{tt|T}} 的复制构造函数，并且
:* 会进行 {{math|O(log N)}} 次重分配。

@6@ 给定 {{c|ranges::distance(rg)}} 为 {{math|N}}：
* 如果 {{tt|R}} 实现了 {{lc|ranges::forward_range}} 或 {{lc|ranges::sized_range}}，那么
:* 从解引用 {{c|rg}} 的连续 {{math|N}} 个迭代器的结果初始化相同个数的元素，并且
:* 不会有重分配。
* 否则（{{tt|R}} 实现了输入范围）：
:* 调用 {{tt|T}} 的复制或移动构造函数 {{math|O(N)}} 次，并且
:* 会发生 {{math|O(log N)}} 次重分配。

@7@ 与 {{c|other.size()}} 成线性。

@8@ 常数。

@9@ 与 {{c|other.size()}} 成线性。

@10@ {{c|1=alloc != other.get_allocator()}} 时与 {{c|other.size()}} 成线性，否则是常数。

@11@ 与 {{c|init.size()}} 成线性。

===异常===
调用 {{tt|Allocator::allocate}} 可能抛出。

===注解===
{{cpp/container/lwg2321-note|8}}

{{feature test macro|__cpp_lib_containers_ranges|[[cpp/ranges/to#容器兼容范围|按范围]]构造和插入; 重载 {{v|6}}|value=202202L|std=C++23}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

template&lt;typename T&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const std::vector&lt;T&gt;&amp; v)
{
    s.put('{');
    for (char comma[]{'\0', ' ', '\0'}; const auto&amp; e : v)
        s &lt;&lt; comma &lt;&lt; e, comma[0] = ',';
    return s &lt;&lt; "}\n";
}

int main()
{
    // C++11 初始化器列表语法：
    std::vector&lt;std::string&gt; words1{"the", "frogurt", "is", "also", "cursed"};
    std::cout &lt;&lt; "1: " &lt;&lt; words1;
    
    // words2 == words1
    std::vector&lt;std::string&gt; words2(words1.begin(), words1.end());
    std::cout &lt;&lt; "2: " &lt;&lt; words2;
    
    // words3 == words1
    std::vector&lt;std::string&gt; words3(words1);
    std::cout &lt;&lt; "3: " &lt;&lt; words3;
    
    // words4 是 {"Mo", "Mo", "Mo", "Mo", "Mo"}
    std::vector&lt;std::string&gt; words4(5, "Mo");
    std::cout &lt;&lt; "4: " &lt;&lt; words4;
    
    const auto rg = {"cat", "cow", "crow"};
#ifdef __cpp_lib_containers_ranges
    std::vector&lt;std::string&gt; words5(std::from_range, rg); // 重载 (6)
#else
    std::vector&lt;std::string&gt; words5(rg.begin(), rg.end()); // 重载 (5)
#endif
    std::cout &lt;&lt; "5: " &lt;&lt; words5;
}
|output=
1: {the, frogurt, is, also, cursed}
2: {the, frogurt, is, also, cursed}
3: {the, frogurt, is, also, cursed}
4: {Mo, Mo, Mo, Mo, Mo}
5: {cat, cow, crow}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=134|std=C++98|before=重载 {{v|5}} 在迭代器是输入迭代器的情况下&lt;br&gt;最多只能调用 {{math|2N}} 次复制构造函数|after=改成调用 {{math|O(N)}} 次}}
{{dr list item|wg=lwg|dr=438|std=C++98|before=重载 {{v|5}} 只有在 {{tt|InputIt}} 是整数类型时才会调用重载 {{v|4}}|after=会在 {{tt|InputIt}} 不是&lt;br&gt;{{named req|InputIterator}}时调用}}
{{dr list item|wg=lwg|dr=2193|std=C++11|before=默认构造函数是 explicit 的|after=它是非 explicit 的}}
{{dr list item|wg=lwg|dr=2210|std=C++11|before=重载 {{v|3}} 没有分配器参数|after=添加分配器参数}}
{{dr list item|paper=N3346|std=C++11|before=对于重载 {{v|3}}，容器中的元素会被值初始化|after=它们会被默认插入}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc assign|vector}}
{{dsc inc|cpp/container/dsc operator{{=}}|vector}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}