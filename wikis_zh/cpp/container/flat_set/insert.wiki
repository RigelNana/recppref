{{cpp/container/flat_set/title|insert}}
{{cpp/container/flat_set/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++23|
std::pair&lt;iterator, bool&gt; insert( const value_type&amp; value );
}}
{{dcl|num=2|since=c++23|
std::pair&lt;iterator, bool&gt; insert( value_type&amp;&amp; value );
}}
{{dcl|num=3|since=c++23|
iterator insert( const_iterator pos, const value_type&amp; value );
}}
{{dcl|num=4|since=c++23|
iterator insert( const_iterator pos, value_type&amp;&amp; value );
}}
{{dcl|num=5|since=c++23|
template&lt; class K &gt;
iterator insert( const_iterator pos, K&amp;&amp; x );
}}
{{dcl|num=6|since=c++23|
template&lt; class InputIt &gt;
void insert( InputIt first, InputIt last );
}}
{{dcl|num=7|since=c++23|
template&lt; class K &gt;
std::pair&lt;iterator, bool&gt; insert( K&amp;&amp; x );
}}
{{dcl|num=8|since=c++23|
template&lt; class InputIt &gt;
void insert( std::sorted_unique_t, InputIt first, InputIt last );
}}
{{dcl|num=9|since=c++23|
void insert( std::initializer_list&lt;key_type&gt; ilist );
}}
{{dcl|num=10|since=c++23|
void insert( std::sorted_unique_t s, std::initializer_list&lt;key_type&gt; ilist );
}}
{{dcl end}}

如果容器尚未包含带有等价的键的元素，则向容器插入元素。

@1@ 插入 {{c|value}}。等价于 {{c|return emplace(value);}}。

@2@ 插入 {{c|value}}。等价于 {{c|return emplace(std::move(value));}}。

@3@ 插入 {{c|value}} 到尽可能靠近紧接 {{c|pos}} 之前的位置。等价于 {{c|return emplace_hint(pos, value);}}。

@4@ 插入 {{c|value}} 到尽可能靠近紧接 {{c|pos}} 之前的位置。等价于 {{c|return emplace_hint(pos, std::move(value));}}。

@5,7@ 如果 {{c|*this}} 已经包含一个透明比较等价于 {{c|x}} 的元素，则不做任何事。否则，如同以如下方式插入一个新元素：
* {{v|5}} {{c|emplace(pos, std::forward&lt;K&gt;(x))}}（插入到尽可能靠近紧接 {{c|pos}} 之前的位置）
* {{v|7}} {{c|emplace(std::forward&lt;K&gt;(x))}}

@@ 从 {{c|x}} 转换为 {{rlpt|/#成员类型|key_type}} 必然构造一个对象 {{c|u}}，使得 {{c|1=find(k) == find(u)}} 为 {{c|true}}。否则，其行为未定义。

@@ {{cpp/enable if|
* 限定标识 {{c|Compare::is_transparent}} 有效并代表一个类型，并且
* {{c|std::is_constructible_v&lt;value_type, K&gt;}} 为 {{c|true}}
|plural=yes}}。这些条件共同允许不构造 {{tt|Key}} 的实例就可以调用这个函数。

@6@ 等价于下列操作的序列：
# 如同用 {{c|c.insert(c.end(), first, last);}} 插入来自范围 {{range|first|last}} 的元素。
# 将新插入元素的范围按 {{rlpi|/#成员对象|compare}} 排序。
# 合并所得的有序范围和既存元素的有序范围为一个有序范围。（注意：合并操作可能会分配内存。）
# 擦除每个连续等价元素组中除了第一个之外的所有元素。
@@ {{cpp/container/lwg2488-note}}

@8@ 插入范围 {{range|first|last}} 中的元素。等价于 {{c|insert(first, last);}}。
@@ {{cpp/container/lwg2488-note}}

@9@ 插入初始化式列表 {{c|ilist}} 中的元素。等价于 {{c|insert(ilist.begin(), ilist.end());}}。
@@ {{cpp/container/lwg2488-note}}

@10@ 插入初始化式列表 {{c|ilist}} 中的元素。等价于 {{c|insert(s, ilist.begin(), ilist.end());}}。
@@ {{cpp/container/lwg2488-note}}

{{cpp/container/note iterator invalidation|flat_set|insert}}

===参数===
{{par begin}}
{{par|pos|指向要在它之前插入新元素的位置的迭代器}}
{{par|value|要插入的元素值}}
{{par range|3=要插入的|range=源}}
{{par|ilist|要插入其中的值的初始化式列表}}
{{par|x|可以与键进行透明比较的任何类型的值}}
{{par|s|[[cpp/container/sorted_unique|消歧标签]]，指定输入序列（根据 {{rlpi|/#成员对象|compare}}）有序且只包含唯一元素}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par end}}

===返回值===
@1,2@ {{cpp/container/return iterator pair||pair}}
@3-5@ {{cpp/container/return iterator pair}}
@6@ （无）
@7@ {{cpp/container/return iterator pair||pair}}
@8-10@ （无）

===异常===
@1-5,7@ 如果任何操作抛出了异常，则插入无效果。

{{todo|情况 6,8-10}}

===复杂度===
@1-5@ 与 {{rlpt|size|size()}} 成线性。
@6@ {{c|N + M·log(M)}}，其中 {{tt|N}} 为操作前的 {{rlpt|size|size()}} 而 {{tt|M}} 为 {{c|std::distance(first, last)}}。
@7@ 与 {{rlpt|size|size()}} 成线性。
@8@ 与 {{tt|N}} 成线性，其中 {{tt|N}} 为操作后的 {{rlpt|size|size()}}。
@9@ {{c|N + M·log(M)}}，其中 {{tt|N}} 为操作前的 {{rlpt|size|size()}} 而 {{tt|M}} 为 {{c|ilist.size()}}。
@10@ 与 {{tt|N}} 成线性，其中 {{tt|N}} 为操作后的 {{rlpt|size|size()}}。

{{todo|1=再查一下复杂度: 1-5, 7, 9, 10。查找为 log(N)，但底层容器的插入则平均为 N/2 =&gt; 线性。}}

===注解===
{{cpp/container/hinted insert note|3-5}}

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;flat_set&gt;
#include &lt;iostream&gt;

int main()
{
    std::flat_set&lt;int&gt; set;

    auto result_1 = set.insert(3);
    assert(result_1.first != set.end()); // 这是有效迭代器
    assert(*result_1.first == 3);
    if (result_1.second)
        std::cout &lt;&lt; "插入完成\n";

    auto result_2 = set.insert(3);
    assert(result_2.first == result_1.first); // 同一个迭代器
    assert(*result_2.first == 3);
    if (!result_2.second)
        std::cout &lt;&lt; "未插入\n";
}
|output=
插入完成
未插入
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc emplace|flat_set}}
{{dsc inc|cpp/container/dsc emplace_hint|flat_set}}
{{dsc inc|cpp/iterator/dsc inserter}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}