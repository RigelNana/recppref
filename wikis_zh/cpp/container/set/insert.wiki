{{cpp/container/set/title|insert}}
{{cpp/container/set/navbar}}
{{dcl begin}}
{{dcl|num=1|
std::pair&lt;iterator, bool&gt; insert( const value_type&amp; value );
}}
{{dcl|num=2|since=c++11|
std::pair&lt;iterator, bool&gt; insert( value_type&amp;&amp; value );
}}
{{dcl rev multi|num=3|anchor=3|until1=c++11
|dcl1=
iterator insert( iterator pos, const value_type&amp; value );
|dcl2=
iterator insert( const_iterator pos, const value_type&amp; value );
}}
{{dcl|num=4|since=c++11|
iterator insert( const_iterator pos, value_type&amp;&amp; value );
}}
{{dcla|num=5|
template&lt; class InputIt &gt;
void insert( InputIt first, InputIt last );
}}
{{dcl|num=6|since=c++11|
void insert( std::initializer_list&lt;value_type&gt; ilist );
}}
{{dcl|num=7|since=c++17|
insert_return_type insert( node_type&amp;&amp; nh );
}}
{{dcl|num=8|since=c++17|
iterator insert( const_iterator pos, node_type&amp;&amp; nh );
}}
{{dcla|num=9|since=c++23|
template&lt; class K &gt;
std::pair&lt;iterator, bool&gt; insert( K&amp;&amp; x );
}}
{{dcl|num=10|since=c++23|
template&lt; class K &gt;
iterator insert( const_iterator pos, K&amp;&amp; x );
}}
{{dcl end}}

插入元素到容器，如果容器未含拥有等价关键的元素。

@1,2@ 插入 {{c|value}}。

@3,4@ 插入 {{c|value}} 到尽可能接近正好在 {{c|pos}} 之前的位置。

@5@ 插入来自范围 {{range|first|last}} 的元素。{{cpp/container/lwg2488-note}}

@6@ 插入来自 initializer_list {{c|ilist}} 的元素。{{cpp/container/lwg2488-note}}

{{cpp/container/node handle insert desc|set|7|8}}

@9@ 如果 {{c|*this}} 已经包含了与 {{c|x}} 透明比较相等的元素，则不做任何事。否则，以 {{c|std::forward&lt;K&gt;(x)}} 构造一个 {{rlpt|/#成员类型|value_type}} 类型的对象 {{tt|u}}，然后将 {{tt|u}} 插入 {{c|*this}} 中。如果 {{c|1=equal_range(u) == equal_range(x)}} 为 {{c|false}}，则其行为未定义。{{tt|value_type}} 必须为以 {{c|std::forward&lt;K&gt;(x)}} 向 {{tt|set}} 中{{named req|EmplaceConstructible}}。{{cpp/container/ordered_heterogeneous_lookup}}

@10@ 如果 {{c|*this}} 已经包含了与 {{c|x}} 透明比较相等的元素，则不做任何事。否则，以 {{c|std::forward&lt;K&gt;(x)}} 构造一个 {{rlpt|/#成员类型|value_type}} 类型的对象 {{tt|u}}，然后将 {{tt|u}} 插入 {{c|*this}} 中 {{c|pos}} 之前尽可能近的位置。如果 {{c|1=equal_range(u) == equal_range(x)}} 为 {{c|false}}，则其行为未定义。{{tt|value_type}} 必须为以 {{c|std::forward&lt;K&gt;(x)}} 向 {{tt|set}} 中{{named req|EmplaceConstructible}}。仅当符合以下条件时，此重载才参与重载决议：
* {{c|std::is_convertible_v&lt;K&amp;&amp;, const_iterator&gt;}} 和 {{c|std::is_convertible_v&lt;K&amp;&amp;, iterator&gt;}} 均为 {{c|false}}，并且
* 限定标识 {{c|Compare::is_transparent}} 合法且代表某个类型，
这些条件共同允许不构造 {{tt|Key}} 就能调用此函数。

{{cpp/container/note iterator invalidation|set|insert}}

===参数===
{{par begin}}
{{par|pos|指向新元素将被插入位置之前的迭代器}}
{{par|value|要插入的元素值}}
{{par range|3=要插入的|range=源}}
{{par|ilist|插入值来源的 initializer_list}}
{{par|nh|兼容的{{lt|cpp/container/node handle|结点句柄}}}}
{{par|x|可以与键进行透明比较的任何类型的值}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par end}} 

===返回值===
@1,2@ {{cpp/container/return iterator pair||pair}}

@3,4@ {{cpp/container/return iterator pair}}

@5,6@（无）

{{cpp/container/node handle insert return|set|7|8}}

@9@ {{cpp/container/return iterator pair||pair}}

@10@ {{cpp/container/return iterator pair}}

===异常===
@1-4@ 如果任何操作抛出了异常，那么插入无效果。

{{todo|情况 5-8,9,10}}

===复杂度===
@1,2@ 与容器大小成对数，{{tt|O(log(size()))}}。

@3,4@ 如果插入恰好发生在正好在 {{c|pos}} ''之前'' 的位置，那么是均摊常数，否则与容器大小成对数。

@5,6@ {{tt|O(N&amp;middot;log(size() + N))}}，其中 {{tt|N}} 是要插入的元素数。

@7@ 与容器大小成对数，{{tt|O(log(size()))}}。

@8@ 如果插入恰好发生在正好在 {{c|pos}} ''之前'' 的位置，那么是均摊常数，否则与容器大小成对数。

@9@ 与容器大小成对数，{{tt|O(log(size()))}}。

@10@ 如果插入位置刚好位于 {{c|pos}} 之前则为均摊常数，否则与容器大小成对数。

===注解===
{{cpp/container/hinted insert note}}

重载 {{vl|5,6}} 通常实现&lt;!--examined GNU libstdc++ 4.8 and LLVM libc++ --&gt;为循环，其中以 {{lc|end()}} 作为提示调用重载 {{vl|3}}；它们对后附最小元素大于 {{c|*this}} 中最大元素的有序序列（例如另一 {{lc|std::set}}）优化。

{{ftm begin}}
{{ftm|__cpp_lib_associative_heterogeneous_insertion|std=C++26|value=202311L|[[cpp/container#关联容器|有序]]和[[cpp/container#无序关联容器|无序]]关联容器中剩余成员函数的异质重载。{{vl|9,10}}}}
{{ftm end}}

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;

int main()
{
    std::set&lt;int&gt; set;
    
    auto result_1 = set.insert(3);
    assert(result_1.first != set.end()); // 它是有效的迭代器
    assert(*result_1.first == 3);
    if (result_1.second)
        std::cout &lt;&lt; "插入完成\n";
    
    auto result_2 = set.insert(3);
    assert(result_2.first == result_1.first); // 相同的迭代器
    assert(*result_2.first == 3);
    if (!result_2.second)
        std::cout &lt;&lt; "未进行插入\n";
}
|output=
插入完成
未进行插入
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=233|std=C++98|before={{c|pos}} 只是提示，可以完全忽略|after=必须在尽可能接近正好在&lt;br&gt;{{c|pos}} 之前的位置插入}}
{{dr list item|wg=lwg|dr=264|std=C++98|before=重载 {{v|5}} 的复杂度在范围 {{tt|[i, j)}} 已经按 {{tt|Compare}} 排序的情况下要求是线性|after=取消这种情况下的线性复杂度要求}}
{{dr list item|wg=lwg|dr=316|std=C++98|before=未指定重载 {{v|1}} 的返回值中用哪个 {{c/core|bool}} 值表示插入成功|after=用 {{c|true}} 表示插入成功}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc emplace|set}}
{{dsc inc|cpp/container/dsc emplace_hint|set}}
{{dsc inc|cpp/iterator/dsc inserter}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}