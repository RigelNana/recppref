{{cpp/title|unordered_map}}
{{cpp/container/unordered_map/navbar}}
{{dcl begin}}
{{dcl header|unordered_map}}
{{dcl|num=1|since=c++11|1=
template&lt;
    class Key,
    class T,
    class Hash = std::hash&lt;Key&gt;,
    class KeyEqual = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;
&gt; class unordered_map;
}}
{{dcl|num=2|since=c++17|1=
namespace pmr {
    template&lt;
        class Key,
        class T,
        class Hash = std::hash&lt;Key&gt;,
        class KeyEqual = std::equal_to&lt;Key&gt;
    &gt; using unordered_map =
          std::unordered_map&lt;Key, T, Hash, KeyEqual,
              std::pmr::polymorphic_allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;;
}
}}
{{dcl end}}

{{tt|std::unordered_map}} 是一种关联容器，含有带唯一键的键-值对。搜索、插入和元素移除拥有平均常数时间复杂度。

元素在内部不以任何特定顺序排序，而是组织进桶中。元素放进哪个桶完全依赖于对应键的散列。具有相同散列码的键出现于同一个桶。这允许对单独元素的快速访问，因为一旦计算其散列，它即代表包含该元素的桶。

如果映射的键相等性谓词在传递两个键时返回 {{tt|true}}，则它们被认为''等价''。如果两个键等价，则散列函数必须对它们返回相同的值。

{{tt|std::unordered_map}} 满足{{named req|Container}}、{{named req|AllocatorAwareContainer}}和{{named req|UnorderedAssociativeContainer}}。

{{cpp/is_constexpr|since=c++26|transient=yes}}

===迭代器失效===
{| class="dsctable" style="font-size:0.8em"
! 操作
! 失效
|-
| 所有只读操作、{{lc|swap}}、{{lc|std::swap}}
| 决不
|-
| {{lc|clear}}、{{lc|rehash}}、{{lc|reserve}}、{{lc|1=operator=}}
| 始终
|-
| {{lc|insert}}、{{lc|emplace}}、{{lc|emplace_hint}}、{{lc|operator[]}}
| 仅限重散列的情况
|-
| {{lc|erase}}
| 仅限指向被擦除元素的迭代器
|}

====注解====
* swap 函数不会使容器内的任何迭代器失效，但它们会使标记交换区域结尾的迭代器失效。

* 指向在容器中存储的键或数据的引用和指针只会因为擦除该元素而失效，即使对应迭代器失效也是如此。

===模板形参===
{{todo|添加模板形参的说明。}}

===成员类型===
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc inc|cpp/container/dsc key_type|unordered_map}}
{{dsc inc|cpp/container/dsc mapped_type|unordered_map}}
{{dsc inc|cpp/container/dsc value_type|unordered_map}}
{{dsc inc|cpp/container/dsc size_type|unordered_map}}
{{dsc inc|cpp/container/dsc difference_type|unordered_map}}
{{dsc inc|cpp/container/dsc hasher|unordered_map}}
{{dsc inc|cpp/container/dsc key_equal|unordered_map}}
{{dsc inc|cpp/container/dsc allocator_type|unordered_map}}
{{dsc inc|cpp/container/dsc reference|unordered_map}}
{{dsc inc|cpp/container/dsc const_reference|unordered_map}}
{{dsc inc|cpp/container/dsc pointer|unordered_map}}
{{dsc inc|cpp/container/dsc const_pointer|unordered_map}}
{{dsc inc|cpp/container/dsc iterator|unordered_map}}
{{dsc inc|cpp/container/dsc const_iterator|unordered_map}}
{{dsc inc|cpp/container/dsc local_iterator|unordered_map}}
{{dsc inc|cpp/container/dsc const_local_iterator|unordered_map}}
{{dsc inc|cpp/container/dsc node_type|unordered_map}}
{{dsc inc|cpp/container/dsc insert_return_type|unordered_map}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc constructor|unordered_map}}
{{dsc inc|cpp/container/dsc destructor|unordered_map}}
{{dsc inc|cpp/container/dsc operator{{=}}|unordered_map}}
{{dsc inc|cpp/container/dsc get_allocator|unordered_map}}

{{dsc h2|迭代器}}
{{dsc inc|cpp/container/dsc begin|unordered_map}}
{{dsc inc|cpp/container/dsc end|unordered_map}}

{{dsc h2|容量}}
{{dsc inc|cpp/container/dsc empty|unordered_map}}
{{dsc inc|cpp/container/dsc size|unordered_map}}
{{dsc inc|cpp/container/dsc max_size|unordered_map}}

{{dsc h2|修改器}}
{{dsc inc|cpp/container/dsc clear|unordered_map}}
{{dsc inc|cpp/container/dsc insert|unordered_map}}
{{dsc inc|cpp/container/dsc insert_range|unordered_map}}
{{dsc inc|cpp/container/dsc insert_or_assign|unordered_map}}
{{dsc inc|cpp/container/dsc emplace|unordered_map}}
{{dsc inc|cpp/container/dsc emplace_hint|unordered_map}}
{{dsc inc|cpp/container/dsc try_emplace|unordered_map}}
{{dsc inc|cpp/container/dsc erase|unordered_map}}
{{dsc inc|cpp/container/dsc swap|unordered_map}}
{{dsc inc|cpp/container/dsc extract|unordered_map}}
{{dsc inc|cpp/container/dsc merge|unordered_map}}

{{dsc h2|查找}}
{{dsc inc|cpp/container/dsc at|unordered_map}}
{{dsc inc|cpp/container/dsc operator_at|unordered_map}}
{{dsc inc|cpp/container/dsc count|unordered_map}}
{{dsc inc|cpp/container/dsc find|unordered_map}}
{{dsc inc|cpp/container/dsc contains|unordered_map}}
{{dsc inc|cpp/container/dsc equal_range|unordered_map}}

{{dsc h2|桶接口}}
{{dsc inc|cpp/container/dsc begin(int)|unordered_map}}
{{dsc inc|cpp/container/dsc end(int)|unordered_map}}
{{dsc inc|cpp/container/dsc bucket_count|unordered_map}}
{{dsc inc|cpp/container/dsc max_bucket_count|unordered_map}}
{{dsc inc|cpp/container/dsc bucket_size|unordered_map}}
{{dsc inc|cpp/container/dsc bucket|unordered_map}}

{{dsc h2|散列策略}}
{{dsc inc|cpp/container/dsc load_factor|unordered_map}}
{{dsc inc|cpp/container/dsc max_load_factor|unordered_map}}
{{dsc inc|cpp/container/dsc rehash|unordered_map}}
{{dsc inc|cpp/container/dsc reserve|unordered_map}}

{{dsc h2|观察器}}
{{dsc inc|cpp/container/dsc hash_function|unordered_map}}
{{dsc inc|cpp/container/dsc key_eq|unordered_map}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator_cmp_unord|unordered_map}}
{{dsc inc|cpp/container/dsc swap2|unordered_map}}
{{dsc inc|cpp/container/dsc erase_if|unordered_map}}
{{dsc end}}

{{rrev|since=c++17|
==={{rl|deduction guides|推导指引}}===
}}

===注解===
{{ftm begin|std=1|comment=1}}
{{ftm|__cpp_lib_containers_ranges|value=202202L|std=C++23|容器的范围构造和插入}}
{{ftm|__cpp_lib_constexpr_containers|value=202502L|std=C++26|{{c/core|constexpr}} {{tt|std::unordered_map}}}}
{{ftm end}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

int main()
{
    // 创建包含三个字符串的（映射到字符串的）unordered_map
    std::unordered_map&lt;std::string, std::string&gt; u =
    {
        {"红色", "#FF0000"},
        {"绿色", "#00FF00"},
        {"蓝色", "#0000FF"}
    };
    
    // 用于打印键值对的辅助 lambda 函数
    auto print_key_value = [](const auto&amp; key, const auto&amp; value)
    {
        std::cout &lt;&lt; "键：[" &lt;&lt; key &lt;&lt; "] 值：[" &lt;&lt; value &lt;&lt; "]\n";
    };
    
    std::cout &lt;&lt; "遍历并打印 unordered_map 的键值对，显式指定类型：\n";
    for (const std::pair&lt;const std::string, std::string&gt;&amp; n : u)
        print_key_value(n.first, n.second);
    
    std::cout &lt;&lt; "\n通过 C++17 的结构化绑定来遍历并打印 unordered_map 的键值对：\n";
    for (const auto&amp; [key, value] : u)
        print_key_value(key, value);
    
    // 向 unordered_map 中添加两项
    u["黑色"] = "#000000";
    u["白色"] = "#FFFFFF";
    
    std::cout &lt;&lt; "\n通过键输出值：\n"
                 "红色的十六进制表示：[" &lt;&lt; u["红色"] &lt;&lt; "]\n"
                 "黑色的十六进制表示：[" &lt;&lt; u["黑色"] &lt;&lt; "]\n\n";
    
    std::cout &lt;&lt; "通过以先前不存在的键使用 operator[] 来插入新的键值对：\n";
    print_key_value("新键", u["新键"]);
    
    std::cout &lt;&lt; "\n通过使用 auto 来遍历并打印键值对；\n"
                 "现在`新键`是映射中的一个键：\n";
    for (const auto&amp; n : u)
        print_key_value(n.first, n.second);
}
|p=true &lt;!--未指定元素顺序--&gt;
|output=
遍历并打印 unordered_map 的键值对，显式指定类型：
键：[蓝色] 值：[#0000FF]
键：[绿色] 值：[#00FF00]
键：[红色] 值：[#FF0000]

通过 C++17 的结构化绑定来遍历并打印 unordered_map 的键值对：
键：[蓝色] 值：[#0000FF]
键：[绿色] 值：[#00FF00]
键：[红色] 值：[#FF0000]

通过键输出值：
红色的十六进制表示：[#FF0000]
黑色的十六进制表示：[#000000]

通过以先前不存在的键使用 operator[] 来插入新的键值对：
键：[新键] 值：[]

通过使用 auto 来遍历并打印键值对；
现在`新键`是映射中的一个键：
键：[新键] 值：[]
键：[白色] 值：[#FFFFFF]
键：[黑色] 值：[#000000]
键：[蓝色] 值：[#0000FF]
键：[绿色] 值：[#00FF00]
键：[红色] 值：[#FF0000]
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2050|std=C++11|before={{tt|reference}}、{{tt|const_reference}}、{{tt|pointer}} 和&lt;br&gt;{{tt|const_pointer}} 的定义都基于 {{tt|allocator_type}}|after=基于 {{tt|value_type}} 和&lt;br&gt;{{lc|std::allocator_traits}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc unordered_multimap}}
{{dsc inc|cpp/container/dsc map}}
{{dsc inc|cpp/container/dsc flat_map}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|ko|pt|ru}}