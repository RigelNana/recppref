{{cpp/container/forward_list/title|insert_range_after}}
{{cpp/container/forward_list/navbar}}

{{ddcl|since=c++23|
template&lt; container-compatible-range&lt;T&gt; R &gt;
iterator insert_range_after( const_iterator pos, R&amp;&amp; rg );
}}

以非逆序的顺序，将 {{c|rg}} 中各元素的副本插入到 {{c|pos}} 之前。范围 {{c|rg}} 中的每个迭代器均被恰好解引用一次。

{{c|pos}} 必须为范围 {{range/core|{{rlpf|begin}}|{{rlpf|end}}}} 内的任何可解引用迭代器，或为 {{rlpf|before_begin}} 迭代器（因此 {{rlpf|end}} 对于 {{c|pos}} 不是有效的实参）。

不使任何迭代器或引用失效。

若 {{c|rg}} 与容器重叠则其行为未定义。

===参数===
{{par begin}}
{{par|pos|将于其后插入内容的迭代器}}
{{par|rg|{{ls|cpp/ranges/to#容器兼容范围}}，即元素可转换为 {{tt|T}} 的 {{lconcept|input_range}}}}
{{par hreq}}
{{par req|{{tt|T}} 必须为可从 {{c|*ranges::begin(rg)}} 向 {{tt|forward_list}} {{named req|EmplaceConstructible}}。否则，其行为未定义。}}
{{par end}}

===返回值===
指向最后插入到 {{tt|forward_list}} 的元素副本，或当 {{c|rg}} 为空时指向 {{c|pos}} 的{{rlpt|/#成员类型|迭代器}}。

===复杂度===
对于 {{c|rg}} 的大小为线性。

===注解===
{{feature test macro|__cpp_lib_containers_ranges|[[cpp/ranges/to#容器兼容范围|范围感知]]构造和插入|value=202202L|std=C++23}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;forward_list&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

int main()
{
    auto container = std::forward_list{1, 2, 3, 4};
    auto pos = std::next(container.cbegin());
    assert(*pos == 2);
    const auto rg = std::vector{-1, -2, -3};

#ifdef __cpp_lib_containers_ranges
    container.insert_range_after(pos, rg);
#else
    container.insert_after(pos, rg.cbegin(), rg.cend());
#endif
    
    assert(std::ranges::equal(container, std::vector{1, 2, -1, -2, -3, 3, 4}));
}
}}

===参阅===
{{dsc begin}}
{{cpp/container/dsc prepend_range|forward_list}}
{{cpp/container/dsc insert_after|forward_list}}
{{cpp/container/dsc emplace_after|forward_list}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pl|pt|ru}}