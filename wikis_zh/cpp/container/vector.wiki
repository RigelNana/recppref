{{cpp/title|vector}}
{{cpp/container/vector/navbar}}
{{dcl begin}}
{{dcl header|vector}}
{{dcl|num=1|1=
template&lt;
    class T,
    class Allocator = std::allocator&lt;T&gt;
&gt; class vector;
}}
{{dcl|since=c++17|num=2|1=
namespace pmr {
    template&lt; class T &gt;
    using vector = std::vector&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt;;
}
}}
{{dcl end}}

@1@ {{tt|std::vector}} 是封装动态数组的序列容器。
@2@ {{tt|std::pmr::vector}} 是使用[[cpp/memory/polymorphic_allocator|多态分配器]]的模板别名。

元素被连续存储，这意味着不仅可通过迭代器，还能用指向元素的常规指针访问元素。这意味着指向 {{tt|vector}} 元素的指针能传递给任何期待指向数组元素的指针的函数。

vector 的存储是自动管理的，按需扩张收缩。{{tt|vector}} 通常占用多于静态数组的空间，因为要分配更多内存以管理将来的增长。{{tt|vector}} 所用的方式不在每次插入元素时，而只在额外内存耗尽时进行重分配。分配的内存总量可用 {{lc|capacity()}} 函数查询。可以通过调用 {{lc|shrink_to_fit()}}&lt;ref&gt;在 libstdc++ 中，{{tt|shrink_to_fit()}} [https://gcc.gnu.org/onlinedocs/libstdc++/manual/strings.html#strings.string.shrink 不能]在 C++98 模式中使用。&lt;/ref&gt;返回多余的内存给系统。

重分配通常是性能上有开销的操作。如果元素数量已知，那么 {{lc|reserve()}} 函数可用于消除重分配。

{{tt|vector}} 上的常见操作复杂度（效率）如下：

* 随机访问——常数 {{math|𝓞(1)}}。
* 在末尾插入或移除元素——均摊常数 {{math|𝓞(1)}}。
* 插入或移除元素——与到 vector 结尾的距离成线性 {{math|𝓞(n)}}。

{{tt|std::vector}}（对于 {{c/core|bool}} 以外的 {{tt|T}}）满足{{named req|Container}}、{{named req|AllocatorAwareContainer}}、{{named req|SequenceContainer}}{{rev inl|since=c++17|、{{named req|ContiguousContainer}}}}及{{named req|ReversibleContainer}}的要求。

{{cpp/is_constexpr|since=c++20|transient=yes}}

&lt;references/&gt;
{{todo|Add bits from {{stddoc|P2846}} [vector.cons]}}

===模板形参===
{{par begin}}
{{par inc|cpp/container/param list T|vector}}
{{par inc|cpp/container/param list Allocator|vector}}
{{par end}}

===特化===
标准库提供 {{tt|std::vector}} 对类型 {{c/core|bool}} 的特化，它可能为空间效率优化。
{{dsc begin}}
{{dsc inc|cpp/container/dsc vector bool}}
{{dsc end}}

===迭代器失效===
{| class="dsctable" style="font-size:0.8em"
!操作
!失效
|-
|所有只读操作
|决不
|-
|{{lc|swap}}、{{lc|std::swap}}
|{{lc|end()}}
|-
|{{lc|clear}}、{{lc|1=operator=}}、{{lc|assign}}
|始终
|-
|{{lc|reserve}}、{{lc|shrink_to_fit}}
|vector 更改容量时全部失效。否则不失效。
|-
|{{lc|erase}}
|被擦除元素及之后的所有元素（包括 {{lc|end()}}）。
|-
|{{lc|push_back}}、{{lc|emplace_back}}
|vector 更改容量时全部失效。否则只有 {{lc|end()}}。
|-
|{{lc|insert}}、{{lc|emplace}}
|vector 更改容量时全部失效。否则只有在或于插入点后者（包括 {{lc|end()}}）。
|-
|{{lc|resize}}
|vector 更改容量时全部失效。否则只有 {{lc|end()}} 与被擦除元素。
|-
|{{lc|pop_back}}
|被擦除元素和 {{lc|end()}}。
|}

===成员类型===
{{dsc begin}}
{{dsc hitem|成员类型|定义}}
{{dsc inc|cpp/container/dsc value_type|vector}}
{{dsc inc|cpp/container/dsc allocator_type|vector}}
{{dsc inc|cpp/container/dsc size_type|vector}}
{{dsc inc|cpp/container/dsc difference_type|vector}}
{{dsc inc|cpp/container/dsc reference|vector}}
{{dsc inc|cpp/container/dsc const_reference|vector}}
{{dsc inc|cpp/container/dsc pointer|vector}}
{{dsc inc|cpp/container/dsc const_pointer|vector}}
{{dsc inc|cpp/container/dsc iterator|vector}}
{{dsc inc|cpp/container/dsc const_iterator|vector}}
{{dsc inc|cpp/container/dsc reverse_iterator|vector}}
{{dsc inc|cpp/container/dsc const_reverse_iterator|vector}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc constructor|vector}}
{{dsc inc|cpp/container/dsc destructor|vector}}
{{dsc inc|cpp/container/dsc operator{{=}}|vector}}
{{dsc inc|cpp/container/dsc assign|vector}}
{{dsc inc|cpp/container/dsc assign_range|vector}}
{{dsc inc|cpp/container/dsc get_allocator|vector}}

{{dsc h2|元素访问}}
{{dsc inc|cpp/container/dsc at|vector}}
{{dsc inc|cpp/container/dsc operator at|vector}}
{{dsc inc|cpp/container/dsc front|vector}}
{{dsc inc|cpp/container/dsc back|vector}}
{{dsc inc|cpp/container/dsc data|vector}}

{{dsc h2|迭代器}}
{{dsc inc|cpp/container/dsc begin|vector}}
{{dsc inc|cpp/container/dsc end|vector}}
{{dsc inc|cpp/container/dsc rbegin|vector}}
{{dsc inc|cpp/container/dsc rend|vector}}

{{dsc h2|容量}}
{{dsc inc|cpp/container/dsc empty|vector}}
{{dsc inc|cpp/container/dsc size|vector}}
{{dsc inc|cpp/container/dsc max_size|vector}}
{{dsc inc|cpp/container/dsc reserve|vector}}
{{dsc inc|cpp/container/dsc capacity|vector}}
{{dsc inc|cpp/container/dsc shrink_to_fit|vector}}

{{dsc h2|修改器}}
{{dsc inc|cpp/container/dsc clear|vector}}
{{dsc inc|cpp/container/dsc insert|vector}}
{{dsc inc|cpp/container/dsc insert_range|vector}}
{{dsc inc|cpp/container/dsc emplace|vector}}
{{dsc inc|cpp/container/dsc erase|vector}}
{{dsc inc|cpp/container/dsc push_back|vector}}
{{dsc inc|cpp/container/dsc emplace_back|vector}}
{{dsc inc|cpp/container/dsc append_range|vector}}
{{dsc inc|cpp/container/dsc pop_back|vector}}
{{dsc inc|cpp/container/dsc resize|vector}}
{{dsc inc|cpp/container/dsc swap|vector}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator cmp|vector}}
{{dsc inc|cpp/container/dsc swap2|vector}}
{{dsc inc|cpp/container/dsc erase seq|vector}}
{{dsc end}}

{{rrev|since=c++17|
==={{rl|deduction guides|推导指引}}===
}}

===注解===
{{ftm begin|std=1|comment=1}}
{{ftm|__cpp_lib_containers_ranges|value=202202L|std=C++23|容器的范围构造和插入}}
{{ftm end}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    // 创建含有整数的 vector
    std::vector&lt;int&gt; v = {8, 4, 5, 9};

    // 将两个整数添加到 vector
    v.push_back(6);
    v.push_back(9);

    // 覆写位置 2 的元素
    v[2] = -1;
 
    // 打印 vector 的值
    for (int n : v)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
8 4 -1 9 6 9
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=69|std=C++98|before=未要求 {{tt|vector}} 的元素存储的连续性|after=已要求}}
{{dr list item|wg=lwg|dr=230|std=C++98|before={{tt|T}} 不需要满足{{named req|CopyConstructible}}&lt;br&gt;（因此不保证能构造 {{tt|T}} 类型的元素）|after={{tt|T}} 也需要满足&lt;br&gt;{{named req|CopyConstructible}}}}
{{dr list item|wg=lwg|dr=464|std=C++98|before=访问空的 {{tt|vector}} 的底层存储导致未定义行为|after=提供 {{tt|data}} 函数}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc inplace_vector}}
{{dsc inc|cpp/container/dsc array}}
{{dsc inc|cpp/container/dsc deque}}
{{dsc end}}

{{langlinks|cs|de|en|es|fr|it|ja|ko|pl|pt|ru}}