{{cpp/container/flat_map/title|insert_or_assign}}
{{cpp/container/flat_map/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++23|
template&lt; class M &gt;
std::pair&lt;iterator, bool&gt; insert_or_assign( const key_type&amp; k, M&amp;&amp; obj );
}}
{{dcl|num=2|since=c++23|
template&lt; class M &gt;
std::pair&lt;iterator, bool&gt; insert_or_assign( key_type&amp;&amp; k, M&amp;&amp; obj );
}}
{{dcla|num=3|since=c++23|
template&lt; class K, class M &gt;
std::pair&lt;iterator, bool&gt; insert_or_assign( K&amp;&amp; k, M&amp;&amp; obj );
}}
{{dcl|num=4|since=c++23|
template&lt; class M &gt;
iterator insert_or_assign( const_iterator hint, const key_type&amp; k, M&amp;&amp; obj );
}}
{{dcl|num=5|since=c++23|
template&lt; class M &gt;
iterator insert_or_assign( const_iterator hint, key_type&amp;&amp; k, M&amp;&amp; obj );
}}
{{dcla|num=6|since=c++23|
template&lt; class K, class M &gt;
iterator insert_or_assign( const_iterator hint, K&amp;&amp; k, M&amp;&amp; obj );
}}
{{dcl end}}

@1,2@ 如果容器中已经存在等价于 {{c|k}} 的键，则把 {{c|std::forward&lt;M&gt;(obj)}} 赋值给对应于键 {{c|k}} 的 {{rlpt|/#成员类型|mapped_type}}。如果不存在这样的键，则如同以如下来插入新值：
* {{v|1,2}} {{c|try_emplace(std::forward&lt;decltype(k)&gt;(k), std::forward&lt;M&gt;(obj))}}
* {{v|4,5}} {{c|try_emplace(hint, std::forward&lt;decltype(k)&gt;(k), std::forward&lt;M&gt;(obj))}}

@@ 如果 {{c|std::is_assignable_v&lt;mapped_type&amp;, M&gt;}} 或者 {{c|std::is_constructible_v&lt;mapped_type, M&gt;}} 为 {{c|false}}，则程序非良构。

@3,6@ 如果容器中已经存在等价于 {{c|k}} 的键，则把 {{c|std::forward&lt;M&gt;(obj)}} 赋值给对应于键 {{c|k}} 的 {{rlpt|/#成员类型|mapped_type}}。否则，等价于：
* {{v|3}} {{c|try_emplace(std::forward&lt;K&gt;(k), std::forward&lt;M&gt;(obj))}}
* {{v|6}} {{c|try_emplace(hint, std::forward&lt;K&gt;(k), std::forward&lt;M&gt;(obj))}}

@@ {{cpp/precondition|1=从 {{c|k}} 转换为 {{tt|key_type}} 必然构造一个对象 {{c|u}}，使得 {{c|1=find(k) == find(u)}} 为 {{c|true}}。}}

@@ {{cpp/enable if|：
* 限定标识 {{tt|Compare::is_transparent}} 有效且代表一个类型。
* {{c|std::is_constructible_v&lt;key_type, K&gt;}} 为 {{c|true}}。
* {{c|std::is_assignable_v&lt;mapped_type&amp;, M&gt;}} 为 {{c|true}}。
* {{c|std::is_constructible_v&lt;mapped_type, M&gt;}} 为 {{c|true}}。
|plural=yes}}。
&lt;!----&gt;
{{cpp/container/note iterator invalidation|flat_map|insert_or_assign}}

===参数===
{{par begin}}
{{par|k|用于查找也用于未找到时进行插入的键}}
{{par|hint|指向将要在其之前插入新元素的位置的迭代器}}
{{par|obj|要插入或赋值的值}}
{{par end}}

===返回值===
@1-3@ {{c/core|bool}} 组分在发生了插入时为 {{c|true}} 而在发生了赋值时为 {{c|false}}。迭代器组分指向被插入或更新的元素。
@4-6@ 迭代器组分指向被插入或更新的元素。

===复杂度===
@1-3@ 与 {{rlpt|emplace}} 的相同。
@4-6@ 与 {{rlpt|emplace_hint}} 的相同。

===注解===
{{tt|insert_or_assign}} 比 {{rlpt|operator_at|operator}}{{c/core|[]}} 返回更多信息，而且不要求被映射类型可默认构造。

===示例===
{{example
|code=
#include &lt;flat_map&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

void print_node(const auto&amp; node)
{
    std::cout &lt;&lt; '[' &lt;&lt; node.first &lt;&lt; "] = " &lt;&lt; node.second &lt;&lt; '\n';
}

void print_result(auto const&amp; pair)
{
    std::cout &lt;&lt; (pair.second ? "插入: " : "赋值: ");
    print_node(*pair.first);
}

int main()
{
    std::flat_map&lt;std::string, std::string&gt; map;

    print_result(map.insert_or_assign("a", "apple"));
    print_result(map.insert_or_assign("b", "banana"));
    print_result(map.insert_or_assign("c", "cherry"));
    print_result(map.insert_or_assign("c", "clementine"));

    for (const auto&amp; node : map)
        print_node(node);
}
|output=
插入: [a] = apple
插入: [b] = banana
插入: [c] = cherry
赋值: [c] = clementine
[a] = apple
[b] = banana
[c] = clementine
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator_at|flat_map}}
{{dsc inc|cpp/container/dsc at|flat_map}}
{{dsc inc|cpp/container/dsc insert|flat_map}}
{{dsc inc|cpp/container/dsc emplace|flat_map}}
{{dsc inc|cpp/container/dsc try_emplace|flat_map}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}