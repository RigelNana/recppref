{{cpp/title|span}}
{{cpp/container/span/navbar}}
{{ddcl|header=span|since=c++20|1=
template&lt;
    class T,
    std::size_t Extent = std::dynamic_extent
&gt; class span;
}}

类模板 {{tt|span}} 所描述的对象可以指代对象的连续序列，序列的首元素处于位置零。{{tt|span}} 能拥有{{i|静态}}长度，此时序列中的元素数在编译期已知并在类型中编码，也可以拥有{{i|动态}}长度。

对于 {{tt|span}} {{c|s}}，当有操作使得范围 {{range|s.data()|s.data() + s.size()}} 中的指针失效时，到 {{c|s}} 的元素的指针、迭代器和引用也会失效。

{{rrev|since=c++23|
{{tt|std::span}} 的每个特化都{{named req|TriviallyCopyable}}。
}}

===模板形参===
{{par begin}}
{{par|T|元素类型；必须是完整对象类型且非抽象类}}
{{par|Extent|序列中的元素数，{{tt|span}} 拥有动态长度时是 {{tt|std::dynamic_extent}}}}
{{par end}}

===嵌套类型===
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc|{{tt|element_type}}|{{tt|T}}}}
{{dsc|{{tt|value_type}}|{{c/core|std::remove_cv_t&lt;T&gt;}}}}
{{dsc|{{tt|size_type}}|{{lc|std::size_t}}}}
{{dsc|{{tt|difference_type}}|{{lc|std::ptrdiff_t}}}}
{{dsc|{{tt|pointer}}|{{c/core|T*}}}}
{{dsc|{{tt|const_pointer}}|{{c/core|const T*}}}}
{{dsc|{{tt|reference}}|{{c/core|T&amp;}}}}
{{dsc|{{tt|const_reference}}|{{c/core|const T&amp;}}}}
{{dsc|{{tt|iterator}}&lt;ref&gt;如果 {{tt|T}} 没有 const 限定，那么 {{tt|iterator}} 是可变迭代器。&lt;/ref&gt;|由实现定义的{{named req|RandomAccessIterator}}、{{named req|ConstexprIterator}}兼{{named req|ContiguousIterator}}，它的 {{tt|value_type}} 是 {{tt|value_type}}}}
{{dsc|{{tt|const_iterator}} {{mark since c++23}}|{{c/core|std::const_iterator&lt;iterator&gt;}}}}
{{dsc|{{tt|reverse_iterator}}|{{c/core|std::reverse_iterator&lt;iterator&gt;}}}}
{{dsc|{{tt|const_reverse_iterator}} {{mark since c++23}}|{{c/core|std::reverse_iterator&lt;const_iterator&gt;}}}}
{{dsc end}}
&lt;references/&gt;

{{named req|Container}}的迭代器类型上的所有要求同样适用于 {{tt|span}} 的 {{tt|iterator}} 类型。

===数据成员===
{{dsc begin}}
{{dsc hitem|成员|描述}}
{{dsc mem sconst|nolink=true|{{dsc small|{{c/core|constexpr std::size_t}}}} extent|{{c|Extent}}}}
{{dsc expos mem obj|spec={{tt|pointer}}|data_|id=data|指向底层序列的指针}}
{{dsc expos mem obj|spec={{tt|size_type}}|size_|id=size|maybe=（仅当为{{i|动态}}长度时提供）|元素个数}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/span/dsc constructor}}
{{dsc inc|cpp/container/span/dsc operator{{=}}}}
{{dsc mem dtor|nolink=true|notes={{mark implicit}}|析构 {{tt|span}}}}

{{dsc h2|迭代器}}
{{dsc inc|cpp/container/dsc begin|span}}
{{dsc inc|cpp/container/dsc end|span}}
{{dsc inc|cpp/container/dsc rbegin|span}}
{{dsc inc|cpp/container/dsc rend|span}}

{{dsc h2|元素访问}}
{{dsc inc|cpp/container/dsc front|span}}
{{dsc inc|cpp/container/dsc back|span}}
{{dsc inc|cpp/container/dsc at|span}}
{{dsc inc|cpp/container/dsc operator_at|span}}
{{dsc inc|cpp/container/dsc data|span}}

{{dsc h2|观察器}}
{{dsc inc|cpp/container/dsc size|span}}
{{dsc inc|cpp/container/span/dsc size_bytes}}
{{dsc inc|cpp/container/span/dsc empty}}

{{dsc h2|子视图}}
{{dsc inc|cpp/container/span/dsc first}}
{{dsc inc|cpp/container/span/dsc last}}
{{dsc inc|cpp/container/span/dsc subspan}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/container/span/dsc as_bytes}}
{{dsc end}}

===辅助常量===
{{dsc begin}}
{{dsc inc|cpp/container/span/dsc dynamic_extent}}
{{dsc end}}

===辅助模板===
{{ddcl|since=c++20|1=
template&lt; class T, std::size_t Extent &gt;
constexpr bool ranges::enable_borrowed_range&lt;std::span&lt;T, Extent&gt;&gt; = true;
}}
{{lc|ranges::enable_borrowed_range}} 的此特化使得 {{tt|span}} 满足 {{lconcept|borrowed_range}}。

{{ddcl|since=c++20|1=
template&lt; class T, std::size_t Extent &gt;
constexpr bool ranges::enable_view&lt;std::span&lt;T, Extent&gt;&gt; = true;
}}
{{lc|ranges::enable_view}} 的此特化使零或动态长度的 {{tt|span}} 满足 {{lconcept|view}}。

==={{rl|deduction guides|推导指引}}===

===注解===
即使在 C++23 引入正式要求前，所有既存实现中 {{tt|std::span}} 的特化都已经是可平凡复制类型。

{{ftm begin|sort=yes}}
{{ftm|__cpp_lib_span|std=C++20|value=202002L|{{tt|std::span}}}}
{{ftm|__cpp_lib_span_at|std=C++26|value=202311L|{{lc|std::span::at}}}}
{{ftm|__cpp_lib_span_initializer_list|value=202311L|std=C++26|以一个 {{lc|std::initializer_list}} 构造 {{tt|std::span}}}}
{{ftm end}}

===示例===
{{example
|示例用 {{tt|std::span}} 实现连续范围上的算法。
|code=
#include &lt;algorithm&gt;
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;span&gt;

template&lt;class T, std::size_t N&gt;
[[nodiscard]]
constexpr auto slide(std::span&lt;T, N&gt; s, std::size_t offset, std::size_t width)
{
    return s.subspan(offset, offset + width &lt;= s.size() ? width : 0U);
}

template&lt;class T, std::size_t N, std::size_t M&gt;
constexpr bool starts_with(std::span&lt;T, N&gt; data, std::span&lt;T, M&gt; prefix)
{
    return data.size() &gt;= prefix.size()
        &amp;&amp; std::equal(prefix.begin(), prefix.end(), data.begin());
}

template&lt;class T, std::size_t N, std::size_t M&gt;
constexpr bool ends_with(std::span&lt;T, N&gt; data, std::span&lt;T, M&gt; suffix)
{
    return data.size() &gt;= suffix.size()
        &amp;&amp; std::equal(data.end() - suffix.size(), data.end(),
                      suffix.end() - suffix.size());
}

template&lt;class T, std::size_t N, std::size_t M&gt;
constexpr bool contains(std::span&lt;T, N&gt; span, std::span&lt;T, M&gt; sub)
{
    return std::ranges::search(span, sub).begin() != span.end();
}

void println(const auto&amp; seq)
{
    for (const auto&amp; elem : seq)
        std::cout &lt;&lt; elem &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    constexpr int a[]{0, 1, 2, 3, 4, 5, 6, 7, 8};
    constexpr int b[]{8, 7, 6};
    constexpr static std::size_t width{6};

    for (std::size_t offset{}; ; ++offset)
        if (auto s = slide(std::span{a}, offset, width); !s.empty())
            println(s);
        else
            break;

    static_assert(""
        &amp;&amp; starts_with(std::span{a}, std::span{a, 4})
        &amp;&amp; starts_with(std::span{a + 1, 4}, std::span{a + 1, 3})
        &amp;&amp; !starts_with(std::span{a}, std::span{b})
        &amp;&amp; !starts_with(std::span{a, 8}, std::span{a + 1, 3})
        &amp;&amp; ends_with(std::span{a}, std::span{a + 6, 3})
        &amp;&amp; !ends_with(std::span{a}, std::span{a + 6, 2})
        &amp;&amp; contains(std::span{a}, std::span{a + 1, 4})
        &amp;&amp; !contains(std::span{a, 8}, std::span{a, 9})
    );
}
|output=
0 1 2 3 4 5
1 2 3 4 5 6
2 3 4 5 6 7
3 4 5 6 7 8
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3203|std=C++20|before=不明确到 {{tt|span}} 的元素的指针、迭代器和引用在什么时候会失效|after=使之明确}}
{{dr list item|wg=lwg|dr=3903|std=C++20|before={{tt|span}} 的析构函数声明不是必要的|after=移除该声明}}
{{dr list item|paper=P2325R3|std=C++20|before=非零静态长度的 {{tt|span}} 不是 {{tt|view}}|after=所有 {{tt|span}} 都是 {{tt|view}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc mdspan}}
{{dsc inc|cpp/ranges/dsc subrange}}
{{dsc inc|cpp/utility/dsc initializer_list}}
{{dsc inc|cpp/string/dsc basic_string_view}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}