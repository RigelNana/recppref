{{title|1=operator==,&lt;=&gt;{{petty|(std::inplace_vector)}}}}
{{cpp/container/inplace_vector/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++26|1=
constexpr friend bool operator==( const std::inplace_vector&lt;T, N&gt;&amp; lhs,
                                  const std::inplace_vector&lt;T, N&gt;&amp; rhs );
}}
{{dcl|num=2|since=c++26|1=
constexpr friend synth-three-way-result&lt;T&gt;
    operator&lt;=&gt;( const std::inplace_vector&lt;T, N&gt;&amp; lhs,
                 const std::inplace_vector&lt;T, N&gt;&amp; rhs );
}}
{{dcl end}}

比较两个 {{lc|std::inplace_vector}} 的内容。

@1@ 检查 {{c|lhs}} 和 {{c|rhs}} 的内容是否相等，即它们是否具有相同数量的元素且 {{c|lhs}} 中的每个元素与 {{c|rhs}} 中相同位置的元素比较都相等。

@2@ 按字典序比较 {{c|lhs}} 和 {{c|rhs}} 的内容。此比较如同以下调用&lt;br&gt;
{{c multi|
std::lexicographical_compare_three_way(lhs.begin(), lhs.end(),|
                                       rhs.begin(), rhs.end(), synth-three-way);
}}.
@@ 返回类型是 {{lti|cpp/standard library/synth-three-way}} 的返回类型（即 {{lti|cpp/standard library/synth-three-way|synth-three-way-result}}{{sep}}{{c/core|&lt;T&gt;}}）。

@@ {{cpp/precondition|必须满足以下至少一项条件：
* {{tt|T}} 实现 {{lconcept|three_way_comparable}}。
* 针对（可能 const 限定的）{{tt|T}} 类型的值定义了 {{tt|&amp;lt;}}，并且 {{tt|&amp;lt;}} 是一种全序关系。
{{nbsp|2}}}}

{{cpp/note synthesized compare}}

===参数===
{{par begin}}
{{par|lhs, rhs|要比较内容的 {{lc|std::inplace_vector}}}}
{{par req named|T|EqualityComparable|overloads=1}}
{{par end}}

===返回值===
@1@ 当两个 {{lc|std::inplace_vector}} 的内容相等时返回 {{c|true}}，否则返回 {{c|false}}。
@2@ {{c|lhs}} 和 {{c|rhs}} 中首对不等价元素的相对顺序（若存在这种元素），否则返回 {{c|1=lhs.size() &lt;=&gt; rhs.size()}}。

===复杂度===
@1@ 当 {{c|lhs}} 与 {{c|rhs}} 大小不同时是常数，否则与 {{lc|std::inplace_vector}} 的大小成线性。
@2@ 与 {{lc|std::inplace_vector}} 的大小成线性。

===注解===
各关系运算符是基于 {{lti|cpp/standard library/synth-three-way}} 定义的，若可能它会使用 {{c/core|1=operator&lt;=&gt;}}，否则使用 {{c/core|operator&lt;}}。

要注意，如果元素自身未提供 {{c/core|1=operator&lt;=&gt;}} 但可隐式转换为可三路比较的类型，那么就用这项转换取代 {{c/core|operator&lt;}}。

===示例===
{{example
|code=
#include &lt;inplace_vector&gt;

int main()
{
    constexpr std::inplace_vector&lt;int, 4&gt;
        a{1, 2, 3},
        b{1, 2, 3},
        c{7, 8, 9, 10};

    static_assert
    (""
        "比较相等容器：" &amp;&amp;
        (a != b) == false &amp;&amp;
        (a == b) == true &amp;&amp;
        (a &lt; b) == false &amp;&amp;
        (a &lt;= b) == true &amp;&amp;
        (a &gt; b) == false &amp;&amp;
        (a &gt;= b) == true &amp;&amp;
        (a &lt;=&gt; b) &gt;= 0 &amp;&amp;
        (a &lt;=&gt; b) &lt;= 0 &amp;&amp;
        (a &lt;=&gt; b) == 0 &amp;&amp;

        "比较不相等容器：" &amp;&amp;
        (a != c) == true &amp;&amp;
        (a == c) == false &amp;&amp;
        (a &lt; c) == true &amp;&amp;
        (a &lt;= c) == true &amp;&amp;
        (a &gt; c) == false &amp;&amp;
        (a &gt;= c) == false &amp;&amp;
        (a &lt;=&gt; c) &lt; 0 &amp;&amp;
        (a &lt;=&gt; c) != 0 &amp;&amp;
        (a &lt;=&gt; c) &lt;= 0 &amp;&amp;
    "");
}
}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}