{{cpp/container/inplace_vector/title|reserve}}
{{cpp/container/inplace_vector/navbar}}
{{ddcl|since=c++26|
static constexpr void reserve( size_type new_cap );
}}

不做任何事，但可能抛出 {{lc|std::bad_alloc}}。因为 {{c/core|std::inplace_vector&lt;T, N&gt;}} 是固定容量的容器，忽略减少容量（即内部存储大小）的请求。

===参数===
{{par begin}}
{{par|new_cap|{{tt|inplace_vector}} 的新容量，以元素数量计}}
{{par end}}

===返回值===
（无）

===复杂度===
常数。

===异常===
若 {{c|new_cap &gt; capacity()}} 为 {{c|true}} 则抛出 {{lc|std::bad_alloc}}。

===注解===
这个函数是为保持向量式接口的兼容性而存在的。 

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;inplace_vector&gt;
#include &lt;iostream&gt;

int main()
{
    std::inplace_vector&lt;int, 4&gt; v{1, 2, 3};
    assert(v.capacity() == 4 &amp;&amp; v.size() == 3);

    v.reserve(2); // 什么也不做
    assert(v.capacity() == 4 &amp;&amp; v.size() == 3);

    try
    {
        v.reserve(13); // 抛出异常，因为所请求的容量 &gt; N；v 不被改变
    }
    catch(const std::bad_alloc&amp; ex)
    {
        std::cout &lt;&lt; ex.what() &lt;&lt; '\n';
    }
    assert(v.capacity() == 4 &amp;&amp; v.size() == 3);
}
|p=true
|output=
std::bad_alloc
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc size|inplace_vector}}
{{dsc inc|cpp/container/dsc max_size|inplace_vector}}
{{dsc inc|cpp/container/dsc resize|inplace_vector}}
{{dsc inc|cpp/container/dsc capacity|inplace_vector}}
{{dsc inc|cpp/container/dsc shrink_to_fit|inplace_vector}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pl|pt|ru}}