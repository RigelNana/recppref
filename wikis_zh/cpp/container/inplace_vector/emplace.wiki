{{cpp/container/inplace_vector/title|emplace}}
{{cpp/container/inplace_vector/navbar}}
{{ddcl|since=c++26|
template&lt; class... Args &gt;
constexpr iterator emplace( const_iterator position, Args&amp;&amp;... args );
}}

在紧接 {{c|pos}} 之前的位置向容器插入新元素。通常使用布置 {{c/core|new}} 在容器提供的位置原位构造元素。将实参 {{c|args...}} 以 {{c|std::forward&lt;Args&gt;(args)...}} 转发给构造函数。

{{cpp/container/note_iterator_invalidation|inplace_vector|emplace}}

===参数===
{{par begin}}
{{par|pos|将构造新元素到其前的迭代器}}
{{par|args|转发给元素构造函数的实参}}
{{par hreq}}
{{par req named|T|EmplaceConstructible|MoveInsertable|MoveAssignable}}
{{par end}}

===返回值===
指向被插入的元素的迭代器。

===复杂度===
与 {{c|pos}} 和 {{lc|end()}} 距离成线性。

===异常===
如果在调用之前 {{c|1=size() == capacity()}} ，那么就会抛出 {{lc|std::bad_alloc}}。此函数没有效果（[[cpp/language/exceptions#异常安全|强异常保证]]）。

由被插入元素的初始化或任何{{named req|InputIterator}}操作所抛出的任何异常。{{range|0|pos}} 中的元素不会被修改。

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;inplace_vector&gt;
#include &lt;new&gt;
#include &lt;utility&gt;

int main()
{
    using P = std::pair&lt;int, int&gt;;
    using I = std::inplace_vector&lt;P, 3&gt;;
    auto nums = I{&lt;!----&gt;{0, 1}, {2, 3}&lt;!----&gt;};
    
    auto it = nums.emplace(nums.begin() + 1, -1, -2);
    assert((*it == P{-1, -2}));
    assert((nums == I{P{0, 1}, {-1, -2}, {2, 3}&lt;!----&gt;}));
    
    try
    {
        nums.emplace(nums.begin(), 1, 3); // 抛出异常：没有多余的空间
    }
    catch(const std::bad_alloc&amp;)
    {
        /*...*/
    }
}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc insert|inplace_vector}}
{{dsc inc|cpp/container/dsc emplace_back|inplace_vector}}
{{dsc end}}

{{langlinks|en|de|es|fr|it|ja|pt|ru}}