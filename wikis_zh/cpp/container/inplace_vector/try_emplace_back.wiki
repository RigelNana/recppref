{{cpp/container/inplace_vector/title|try_emplace_back}}
{{cpp/container/inplace_vector/navbar}}
{{ddcl|since=c++26|
template&lt; class... Args &gt;
constexpr pointer try_emplace_back( Args&amp;&amp;... args );
}}

有条件地追加 {{tt|T}} 类型对象到容器尾部。 

若 {{c|1=size() == capacity()}} 为 {{c|true}} 那么此函数无效果。否则向容器追加一个以 {{c|std::forward&lt;Args&gt;(args)...}} [[cpp/language/direct initialization|直接初始化]]的 {{tt|T}} 类型的对象。

{{cpp/container/note iterator invalidation|inplace_vector|try_emplace_back}}

===参数===
{{par begin}}
{{par|args|转发给元素构造函数的实参}}
{{par hreq}}
{{par req|{{tt|T}} 必须满足从实参 {{c|std::forward&lt;Args&gt;(args)...}} {{named req|EmplaceConstructible}}到 {{tt|inplace_vector}}。}}
{{par end}}

===返回值===
若 {{c|size() &lt; capacity()}} 则为 {{c|std::addressof(back())}}，否则为 {{c|nullptr}}。

===复杂度===
常数。

===异常===
由被插入元素的初始化抛出的任何异常。{{cpp/strong exception safety guarantee|plural=no}}

===注解===
{{todo|Explain the purpose of this API.}}

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;inplace_vector&gt;

int main()
{
    using namespace std::complex_literals;
    using C = std::complex&lt;double&gt;;
    using I = std::inplace_vector&lt;C, 3&gt;;
    auto v = I{1.0 + 2.0i, 3.0 + 4.0i};

    C* c = v.try_emplace_back(5.0, 6.0);
    assert(*c == 5.0 + 6.0i);
    assert((v == I{1.0 + 2.0i, 3.0 + 4.0i, 5.0 + 6.0i}));

    c = v.try_emplace_back(7.0, 8.0); // 没有空间 =&gt; 未发生插入
    assert(c == nullptr);
    assert((v == I{1.0 + 2.0i, 3.0 + 4.0i, 5.0 + 6.0i}));
}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/container/dsc emplace_back|inplace_vector}}
{{dsc inc|cpp/container/dsc push_back|inplace_vector}}
{{dsc inc|cpp/container/dsc append_range|inplace_vector}}
{{dsc inc|cpp/container/dsc try_append_range|inplace_vector}}
{{dsc inc|cpp/container/dsc unchecked_emplace_back|inplace_vector}}
{{dsc inc|cpp/container/dsc unchecked_push_back|inplace_vector}}
{{dsc inc|cpp/container/dsc pop_back|inplace_vector}}
{{dsc inc|cpp/iterator/dsc back_inserter}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}