{{cpp/title|tuple_element{{small|&lt;std::array&gt;}}}}
{{cpp/container/array/navbar}}
{{dcl begin}}
{{dcl header|array}}
{{dcl|since=c++11|1=
template&lt; std::size_t I, class T, std::size_t N &gt;
struct tuple_element&lt; I, std::array&lt;T, N&gt; &gt;;
}}
{{dcl end}}

使用 tuple 式接口，提供 array 元素类型的编译时索引访问

===成员类型===
{{dsc begin}}
{{dsc hitem | 成员类型 | 定义}}
{{dsc | type | array 的元素类型}}
{{dsc end}}

===可能的实现===
{{eq fun
|1=
template&lt;std::size_t I, class T&gt;
struct tuple_element;

template&lt;std::size_t I, class T, std::size_t N&gt;
struct tuple_element&lt;I, std::array&lt;T,N&gt;&gt;
{
    using type = T;
};
}}

===示例===
{{example
|code=
#include &lt;array&gt;
#include &lt;tuple&gt;
#include &lt;type_traits&gt;

int main()
{
    // 定义 array 并获取位于位置 0 的元素类型
    std::array&lt;int, 10&gt; data{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    using T = std::tuple_element&lt;0, decltype(data)&gt;::type; // int
    static_assert(std::is_same_v&lt;T, int&gt;);

    const auto const_data = data;
    using CT = std::tuple_element&lt;0, decltype(const_data)&gt;::type; // const int

    // tuple_element 的结果取决于 tuple 式类型的 cv 限定
    static_assert(!std::is_same_v&lt;T, CT&gt;);
    static_assert(std::is_same_v&lt;CT, const int&gt;);
}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/language/dsc structured binding}}
{{dsc inc|cpp/utility/tuple/dsc tuple_element}}
{{dsc inc|cpp/utility/pair/dsc tuple_element}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}