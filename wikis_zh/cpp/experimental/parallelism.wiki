{{title|并行扩展}}
{{cpp/experimental/parallelism/navbar}}

{{fmbox | class=noprint | style=font-size: 0.8em | text='''并入 ISO C++''' 此页面上描述的功能自 2016 年 3 月起已并入主线 ISO C++ 标准（除了动态执行策略和 {{tt|exception_list}}）；见[[cpp/algorithm|算法库]] {{mark since c++17}} }}

C++ 并行扩展 (C++ Extensions for Parallelism)，ISO/IEC TS 19570:2015 为 C++ 标准库定义下列新组件：

===执行策略===
并行 TS 描述三种执行策略：[[cpp/experimental/parallelism/execution policy#顺序|顺序]]、[[cpp/experimental/parallelism/execution policy#并行|并行]]和[[cpp/experimental/parallelism/execution policy#并行向量|并行加向量]]，并提供对应的执行策略类型和对象。用户可以通过以对应类型的执行策略对象调用并行算法，静态地选择执行策略，或用类型擦除的 {{tt|execution_policy}} 类动态地选择执行策略。

实现可以定义额外的执行策略为扩展。以实现定义类型执行策略对象调用并行算法的语义是实现定义的。

{{dsc begin}}
{{dsc header | experimental/execution_policy }}
{{dsc class | cpp/experimental/execution_policy_tag_t | title=sequential_execution_policy&lt;br/&gt;parallel_execution_policy&lt;br/&gt;parallel_vector_execution_policy |执行策略类型}}
{{dsc const | cpp/experimental/execution_policy_tag | title=seq&lt;br/&gt;par&lt;br/&gt;par_vec|全局执行策略对象}}
{{dsc class | cpp/experimental/execution_policy |动态执行策略}}
{{dsc tclass | cpp/experimental/is_execution_policy |测试类是否表示执行策略}}
{{dsc end}}

=== 异常列表 ===
{{dsc begin}}
{{dsc header | experimental/exception_list }}
{{dsc class | cpp/experimental/exception_list | 在并行执行期间引发的异常}}
{{dsc end}}

===既存算法的并行化版本===
该 TS 为来自 &lt;algorithm&gt;、&lt;numeric&gt; 和 &lt;memory&gt; 的下列 69 个算法提供[[cpp/experimental/parallelism/existing|并行化版本]]：
{{collapse top|提供了并行化版本的标准库算法}}
{{div col|3}}
* {{lc|std::adjacent_difference}}
* {{lc|std::adjacent_find}}
* {{lc|std::all_of}}
* {{lc|std::any_of}}
* {{lc|std::copy}}
* {{lc|std::copy_if}}
* {{lc|std::copy_n}}
* {{lc|std::count}}
* {{lc|std::count_if}}
* {{lc|std::equal}}
* {{lc|std::fill}}
* {{lc|std::fill_n}}
* {{lc|std::find}}
* {{lc|std::find_end}}
* {{lc|std::find_first_of}}
* {{lc|std::find_if}}
* {{lc|std::find_if_not}}
* {{lc|std::generate}}
* {{lc|std::generate_n}}
* {{lc|std::includes}}
* {{lc|std::inner_product}}
* {{lc|std::inplace_merge}}
* {{lc|std::is_heap}}
* {{lc|std::is_heap_until}}
* {{lc|std::is_partitioned}}
* {{lc|std::is_sorted}}
* {{lc|std::is_sorted_until}}
* {{lc|std::lexicographical_compare}}
* {{lc|std::max_element}}
* {{lc|std::merge}}
* {{lc|std::min_element}}
* {{lc|std::minmax_element}}
* {{lc|std::mismatch}}
* {{ltt|cpp/algorithm/move|std::move}}
* {{lc|std::none_of}}
* {{lc|std::nth_element}}
* {{lc|std::partial_sort}}
* {{lc|std::partial_sort_copy}}
* {{lc|std::partition}}
* {{lc|std::partition_copy}}
* {{ltt|cpp/algorithm/remove|std::remove}}
* {{lc|std::remove_copy}}
* {{lc|std::remove_copy_if}}
* {{lc|std::remove_if}}
* {{lc|std::replace}}
* {{lc|std::replace_copy}}
* {{lc|std::replace_copy_if}}
* {{lc|std::replace_if}}
* {{lc|std::reverse}}
* {{lc|std::reverse_copy}}
* {{lc|std::rotate}}
* {{lc|std::rotate_copy}}
* {{lc|std::search}}
* {{lc|std::search_n}}
* {{lc|std::set_difference}}
* {{lc|std::set_intersection}}
* {{lc|std::set_symmetric_difference}}
* {{lc|std::set_union}}
* {{lc|std::sort}}
* {{lc|std::stable_partition}}
* {{lc|std::stable_sort}}
* {{lc|std::swap_ranges}}
* {{lc|std::transform}}
* {{lc|std::uninitialized_copy}}
* {{lc|std::uninitialized_copy_n}}
* {{lc|std::uninitialized_fill}}
* {{lc|std::uninitialized_fill_n}}
* {{lc|std::unique}}
* {{lc|std::unique_copy}}
{{div col end}}
{{collapse bottom}}

===新算法===
{{dsc begin}}
{{dsc header | experimental/algorithm }}
{{dsc tfun | cpp/experimental/for_each |类似 {{lc|std::for_each}}，但返回 {{tt|void}}}}
{{dsc tfun | cpp/experimental/for_each_n |应用函数对象到序列的前 n 个元素}}
{{dsc header | experimental/numeric }}
{{dsc inc | cpp/experimental/parallelism/dsc reduce}}
{{dsc tfun | cpp/experimental/exclusive_scan |类似 {{lc|std::partial_sum}}，从第 i 个和排除第 i 个输入元素}}
{{dsc tfun | cpp/experimental/inclusive_scan |类似 {{lc|std::partial_sum}}，包含第 i 个元素于第 i 个和}}
{{dsc inc | cpp/experimental/parallelism/dsc transform_reduce}}
{{dsc tfun | cpp/experimental/transform_exclusive_scan |应用函数对象，再计算 exclusive_scan}}
{{dsc tfun | cpp/experimental/transform_inclusive_scan |应用函数对象，再计算 inclusive_scan}}
{{dsc end}}

{{langlinks|en}}