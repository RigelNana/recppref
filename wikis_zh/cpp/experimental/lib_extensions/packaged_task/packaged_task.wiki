{{cpp/experimental/packaged_task/title|packaged_task {{mark since libfund_ts}}}}
{{cpp/experimental/lib extensions/pmr/navbar}}
{{dcl begin}}
{{dcl|num=1|since=libfund_ts|1=
packaged_task() noexcept;
}}
{{dcl|num=2|since=libfund_ts|1=
template&lt; class F &gt;
explicit packaged_task( F&amp;&amp; f );
}}
{{dcl|num=3|since=libfund_ts|1=
template&lt; class F, class Allocator &gt;
explicit packaged_task( std::allocator_arg_t, const Allocator&amp; alloc, F&amp;&amp; f );
}}
{{dcl|num=4|since=libfund_ts|1=
packaged_task( const packaged_task&amp; ) = delete;
}}
{{dcl|num=5|since=libfund_ts|1=
packaged_task( packaged_task&amp;&amp; rhs ) noexcept;
}}
{{dcl end}}

构造新的 {{tt|std::experimental::packaged_task}} 对象。

@1@ 构造无任务且无共享状态的 {{tt|std::experimental::packaged_task}} 对象。
@2@ 构造拥有共享状态和任务副本的 {{tt|std::experimental::packaged_task}} 对象，以 {{c|std::forward&lt;F&gt;(f)}} 初始化。此构造函数仅若 {{c|std::decay&lt;F&gt;::type}} 与 {{c|std::packaged_task&lt;R(ArgTypes...)&gt;}} 为同一类型才参与重载决议。
@3@ 构造拥有共享状态和任务副本的 {{tt|std::experimental::packaged_task}} 对象，以 {{c|std::forward&lt;F&gt;(f)}} 初始化。用提供的分配器分配存储任务所需的内存，分配器被当做类型擦除的分配器（见后述）。此构造函数仅若 {{c|std::decay&lt;F&gt;::type}} 与 {{c|std::packaged_task&lt;R(ArgTypes...)&gt;}} 为相同类型才参与重载决议。
@4@ 复制构造函数被弃置，{{tt|std::experimental::packaged_task}} 仅可移动。
@5@ 构造拥有共享对象和 {{tt|rhs}} 先前占有的任务的 {{tt|std::experimental::packaged_task}}，并使 {{tt|rhs}} 无共享状态并有被移动的任务。

{{cpp/experimental/type erased allocator|packaged_task}}

===参数===
{{par begin}}
{{par | f |要执行的可调用目标（函数、成员函数、lambda 表达式、仿函数）}}
{{par | alloc |存储任务时使用的分配器}}
{{par | rhs |要移动的 {{tt|std::experimental::packaged_task}}}}
{{par end}}

===异常===
@2,3@ {{c|f}} 的复制/移动构造函数可能抛出的任何异常，且若分配失败可能抛出 {{lc|std::bad_alloc}}。

@4@ （无）

{{langlinks|en}}