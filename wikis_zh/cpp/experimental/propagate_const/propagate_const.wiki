{{cpp/experimental/propagate_const/title|propagate_const}}
{{cpp/experimental/lib extensions 2/propagate_const/navbar}}

{{dcl begin}}
{{dcl|num=1|since=libfund_ts_2|1= 
constexpr propagate_const() = default;
}}
{{dcl|num=2|since=libfund_ts_2|1= 
constexpr propagate_const( propagate_const&amp;&amp; p ) = default;
}}
{{dcl|num=3|since=libfund_ts_2|1= 
template&lt; class U &gt;
/* 见下文 */ constexpr propagate_const( propagate_const&lt;U&gt;&amp;&amp; pu );
}}
{{dcl|num=4|since=libfund_ts_2|1= 
template&lt; class U &gt;
/* 见下文 */ constexpr propagate_const( U&amp;&amp; u );
}}
{{dcl|num=5|since=libfund_ts_2|1= 
propagate_const( const propagate_const&amp; ) = delete;
}}
{{dcl end}}

令 {{tt|t_}} 指代私有数据成员，即被包装的指针式对象。

@1@ 构造 {{tt|propagate_const}}，默认初始化 {{c|this-&gt;t_}}。

@2@ 显式预置的移动构造函数，从 {{c|p.t_}} 移动构造 {{c|this-&gt;t_}}。

@3@ 如同以直接非列表初始化，从表达式 {{c|std::move(pu.t_)}} 初始化 {{c|this-&gt;t_}}。&lt;br&gt;&lt;!--
--&gt;此构造函数仅当 {{c|std::is_constructible&lt;T, U&gt;::value}} 为 {{c|true}} 时才参与重载决议，当且仅当 {{c|std::is_convertible&lt;U, T&gt;::value}} 为 {{c|false}} 时才为 {{tt|explicit}}。

@4@ 如同以直接非列表初始化，用表达式 {{c|std::forward&lt;U&gt;(u)}} 初始化 {{c|this-&gt;t_}} 。&lt;br&gt;&lt;!--
--&gt;此构造函数仅当 {{c|std::is_constructible&lt;T, U&gt;::value}} 为 {{c|true}} 而 {{c|std::decay_t&lt;U&gt;}} 不是 {{tt|propagate_const}} 的特化时才参与重载决议。此构造函数当且仅当 {{c|std::is_convertible&lt;U, T&gt;::value}} 为 {{c|false}} 才为 {{tt|explicit}}。

@5@ 复制构造函数被显式弃置。{{tt|propagate_const}} 不可复制。

===参数===
{{par begin}}
{{par | p  | 要移动的另一 {{tt|propagate_const}} 对象}}
{{par | pu | 要移动的另一不同特化的 {{tt|propagate_const}} 对象}}
{{par | u  | 用来初始化所含指针的另一对象}}
{{par end}}

===注解===
在库基础 TS v2（基于 C++14）中，{{v|4}} 与 {{v|5}} 常以 {{tt|explicit}}/非 {{tt|explicit}} 重载对实现。从库基础 TS v3（基于 C++20）起，它们能以条件性 {{tt|explicit}} 说明符实现。

{{langlinks|de|en|es|ja|ru}}