{{cpp/experimental/unique_resource/title|operator{{=}}}}
{{cpp/experimental/unique_resource/navbar}}

{{ddcl|since=libfund_ts_3|1=
unique_resource&amp; operator=( unique_resource&amp;&amp; other )
    noexcept(/* 见下文 */);
}}

移动赋值运算符。替换为 {{c|other}} 的被管理资源和删除器。

正式而言，令 {{tt|RS}} 为存储的资源句柄的类型：
* 首先，调用 {{c|reset()}} 处置当前占有的资源，若存在。
* 然后以 {{c|other}} 存储的资源句柄与删除器赋值其所存储的资源柄与删除器。若 {{c|std::is_nothrow_move_assignable_v&lt;RS&gt;}} 或 {{c|std::is_nothrow_move_assignable_v&lt;D&gt;}} 为 {{c|true}}，则分别应用 {{tt|std::move}} 到 {{c|other}} 所存储的资源句柄或删除器。首先执行存储的资源句柄的赋值，除非 {{c|std::is_nothrow_move_assignable_v&lt;D&gt;}} 为 {{c|false}} 且 {{c|std::is_nothrow_move_assignable_v&lt;RS&gt;}} 为 {{c|true}}。
* 最后，当且仅当赋值前 {{c|other}} 占有资源时，设置 {{c|*this}} 为占有它，并设置 {{tt|other}} 为不占有资源。

若 {{c|std::is_nothrow_move_assignable_v&lt;RS&gt;}} 为 {{c|true}}，则 {{tt|RS}} 应当满足{{named req|MoveAssignable}}要求；否则 {{tt|RS}} 应当满足{{named req|CopyAssignable}}要求。若 {{c|std::is_nothrow_move_assignable_v&lt;D&gt;}} 为 {{c|true}}，则 {{tt|D}} 应当满足{{named req|MoveAssignable}}要求；否则 {{tt|D}} 应当满足{{named req|CopyAssignable}}要求。不满足上述要求导致未定义行为。

===参数===
{{par begin}}
{{par | other | 将要被转移所有权的资源包装器 }}
{{par end}}

===返回值===
{{c|*this}}

===异常===
任何复制赋值中抛出的异常。
{{noexcept|std::is_nothrow_move_assignable_v&lt;RS&gt; &amp;&amp; std::is_nothrow_move_assignable_v&lt;D&gt;}}

===注解===
若复制成员抛出异常，则此机制置 {{c|other}} 于不变并使 {{c|*this}} 处于被释放状态。

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/experimental/unique_resource/dsc reset}}
{{dsc inc|cpp/memory/unique_ptr/dsc operator{{=}}}}
{{dsc end}}

{{langlinks|en|ja}}