{{cpp/experimental/simd/title|operator!,~,+,-}}
{{cpp/experimental/simd/simd/navbar}}
{{dcl begin}}
{{dcl|num=1|since=parallelism_ts_2|1=
mask_type operator!() const noexcept;
}}
{{dcl|num=2|since=parallelism_ts_2|1=
simd operator~() const noexcept;
}}
{{dcl|num=3|since=parallelism_ts_2|1=
simd operator+() const noexcept;
}}
{{dcl|num=4|since=parallelism_ts_2|1=
simd operator-() const noexcept;
}}
{{dcl end}}

对 {{ltt|cpp/experimental/simd/simd}} 的每个元素运用给定的一元运算符。
@1@ 返回一个 {{ltt|cpp/experimental/simd/simd_mask|simd_mask&lt;T, Abi&gt;}}，使得{{simd for all i}}，第 {{math|i}} 个元素等于 {{c|!operator[](i)}}。
@2@ 返回一个 {{tt|simd}}，其每个位均为 {{c|*this}} 中的对应位的反转。{{cpp/enable_if|{{tt|T}} 为整数类型}}。
@3@ 返回其自身的副本。
@4@ 返回一个 {{tt|simd}}，使得{{simd for all i}}，第 {{math|i}} 个元素被初始化为 {{c|-operator[](i)}}。

===示例===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;experimental/simd&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;
namespace stdx = std::experimental;

void println(std::string_view op, const stdx::native_simd_mask&lt;int&gt; x)
{
    std::cout &lt;&lt; op &lt;&lt; ": ";
    for (std::size_t i = 0; i &lt; x.size(); ++i)
        std::cout &lt;&lt; std::boolalpha &lt;&lt; x[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

void println(std::string_view op, const stdx::native_simd&lt;int&gt; x)
{
    std::cout &lt;&lt; op &lt;&lt; ": ";
    for (std::size_t i = 0; i &lt; x.size(); ++i)
        std::cout &lt;&lt; x[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    const stdx::native_simd&lt;int&gt; a([](int i) { return i; });

    println("  a", a);
    println(" !a", !a);
    println(" ~a", ~a);
    println("~~a", ~~a);
    println(" +a", +a);
    println(" -a", -a);
    println("+-a", +-a);
}
|p=true
|output=&lt;nowiki/&gt;
  a: 0 1 2 3 
 !a: true false false false 
 ~a: -1 -2 -3 -4 
~~a: 0 1 2 3 
 +a: 0 1 2 3 
 -a: 0 -1 -2 -3 
+-a: 0 -1 -2 -3
}}