{{cpp/experimental/simd/title|copy_to}}
{{cpp/experimental/simd/simd/navbar}}
{{dcl begin}}
{{dcl|since=parallelism_ts_2|1=
template&lt; class U, class Flags &gt;
void copy_to( U* mem, Flags flags );
}}
{{dcl end}}

存储函数复制 {{ltt|cpp/experimental/simd/simd}} 中的所有元素，使得{{simd_for_all_i}}，第 i 个元素被转换为 {{tt|U}} 随后写入 {{c|mem[i]}}。

===参数===
{{par begin}}
{{par|mem|指向数组的指针，其中 {{range|mem|mem + size()}} 为有效范围}}
{{par|flags|如果为类型 {{ltt|cpp/experimental/simd/vector_aligned|vector_aligned_tag}}，则加载构造函数可能假设 {{c|mem}} 指向按 {{ltt|cpp/experimental/simd/memory_alignment|memory_alignment_v&lt;simd, U&gt;}} 对齐的存储}}
{{par hreq}}
{{par req|{{tt|U}} 必须为''可向量化''类型。}}
{{par req|{{tt|is_simd_flag_type_v&lt;Flags&gt;}} 必须为 {{c/core|true}}。}}
{{par end}}

===示例===
{{example
|code=
#include &lt;experimental/simd&gt;
#include &lt;iostream&gt;
namespace stdx = std::experimental;
 
int main()
{
    alignas(stdx::memory_alignment_v&lt;stdx::native_simd&lt;int&gt;&gt;)
        std::array&lt;int, stdx::native_simd&lt;int&gt;::size()&gt; mem = {};
 
    stdx::native_simd&lt;int&gt; a = 7;
    a.copy_to(&amp;mem[0], stdx::vector_aligned);

    for (int e : mem)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|p=true
|output=
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/experimental/simd/element aligned}}
{{dsc inc|cpp/experimental/simd/vector_aligned}}
{{dsc inc|cpp/experimental/simd/overaligned}}
{{dsc inc|cpp/experimental/simd/dsc memory_alignment}}
{{dsc inc|cpp/experimental/simd/simd/dsc copy_from}}
{{dsc end}}