{{cpp/experimental/simd/title|copy_from}}
{{cpp/experimental/simd/simd/navbar}}
{{dcl begin}}
{{dcl|since=parallelism_ts_2|1=
template&lt; class U, class Flags &gt;
void copy_from( const U* mem, Flags flags );
}}
{{dcl end}}

加载函数替换 {{rlpt|/|simd}} 的所有元素，使得{{simd_for_all_i}}，第 {{math|i}} 元素以 {{c|static_cast&lt;T&gt;(mem[i])}} 赋值。

===参数===
{{par begin}}
{{par|mem|指向数组的指针，其中 {{range|mem|mem + size()}} 是有效范围}}
{{par|flags|若为类型 {{ltt|cpp/experimental/simd/vector_aligned|vector_aligned_tag}}，则加载构造函数可能假设 {{c|mem}} 指向按 {{ltt|cpp/experimental/simd/memory_alignment|memory_alignment_v&lt;simd, U&gt;}} 对齐的存储}}
{{par hreq}}
{{par req|{{tt|U}} 必须为''可向量化''类型。}}
{{par req|{{tt|is_simd_flag_type_v&lt;Flags&gt;}} 必须为 {{c/core|true}}。}}
{{par end}}

===示例===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;experimental/simd&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
namespace stdx = std::experimental;

void print(auto const&amp; a)
{
    for (std::size_t i{}; i != std::size(a); ++i)
        std::cout &lt;&lt; a[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    alignas(stdx::memory_alignment_v&lt;stdx::native_simd&lt;int&gt;&gt;)
        std::array&lt;int, stdx::native_simd&lt;int&gt;::size() * 2&gt; mem = {};
    std::iota(mem.begin(), mem.end(), 0);
    print(mem);

    stdx::native_simd&lt;int&gt; a; // 未初始化

    a.copy_from(&amp;mem[0], stdx::vector_aligned);
    print(a);

    a.copy_from(&amp;mem[1], stdx::element_aligned); // vector_aligned 很可能崩溃
    print(a);
}
|p=true
|output=
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
0 1 2 3 4 5 6 7
1 2 3 4 5 6 7 8
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/experimental/simd/dsc memory_alignment}}
{{dsc inc|cpp/experimental/simd/simd/dsc copy_to}}
{{dsc inc|cpp/experimental/simd/simd/dsc constructor}}
{{dsc end}}