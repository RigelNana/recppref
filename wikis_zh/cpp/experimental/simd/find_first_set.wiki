{{cpp/experimental/title|find_first_set|find_last_set}}
{{cpp/experimental/simd/navbar}}

{{dcl begin}}
{{dcl header|experimental/simd}}
{{dcl|since=parallelism_ts_2|num=1|
template&lt; class T, class Abi &gt;
int find_first_set( const simd_mask&lt;T, Abi&gt;&amp; k );
}}
{{dcl|since=parallelism_ts_2|num=2|
template&lt; class T, class Abi &gt;
int find_last_set( const simd_mask&lt;T, Abi&gt;&amp; k );
}}
{{dcl end}}

@1@ 返回使得 {{c|k[i]}} 为 {{c/core|true}} 的最小索引 {{tt|i}}。
@2@ 返回使得 {{c|k[i]}} 为 {{c/core|true}} 的最大索引 {{tt|i}}。

如果 {{c|any_of(k)}} 为 {{c/core|false}} 则其行为未定义。

===参数===
{{par begin}}
{{par|k|要对其运用归约的 {{rlpt|simd_mask}}}}
{{par end}}

===返回值===
范围 {{range|0|simd_size_v&lt;T, Abi&gt;}} 中的一个 {{c/core|int}} 值。

===示例===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;experimental/simd&gt;
#include &lt;iostream&gt;

namespace stdx = std::experimental;

template&lt;typename Abi&gt;
int find(stdx::simd_mask&lt;Abi&gt; const&amp; v)
{
    if (stdx::any_of(v))
        return find_first_set(v);
    return -1;
}

int main()
{
    stdx::simd_mask&lt;short&gt; a{0};
    a[2] = a[a.size() - 2] = 1;

    for (std::size_t i = 0; i &lt; a.size(); ++i)
        std::cout &lt;&lt; a[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    std::cout &lt;&lt; "find_first_set: " &lt;&lt; stdx::find_first_set(a) &lt;&lt; '\n';
    std::cout &lt;&lt; "find_last_set: " &lt;&lt; stdx::find_last_set(a) &lt;&lt; '\n';
    std::cout &lt;&lt; "find: " &lt;&lt; find(a) &lt;&lt; '\n';
    a[2] = 0;
    std::cout &lt;&lt; "find: " &lt;&lt; find(a) &lt;&lt; '\n';
    a[a.size() - 2] = 0;
    std::cout &lt;&lt; "find: " &lt;&lt; find(a) &lt;&lt; '\n';
}
|p=true
|output=
0 0 1 0 0 0 1 0 
find_first_set: 2
find_last_set: 6
find: 2
find: 6
find: -1
}}