{{cpp/experimental/function/title|function}}
{{cpp/experimental/lib extensions/pmr/navbar}}
{{dcl begin}}
{{dcl|num=1|since=libfund_ts|
function() noexcept;
}}
{{dcl|num=2|since=libfund_ts|
function( std::nullptr_t ) noexcept;
}}
{{dcl|num=3|since=libfund_ts|
function( const function&amp; other );
}}
{{dcl|num=4|since=libfund_ts|
function( function&amp;&amp; other );
}}
{{dcl|num=5|since=libfund_ts|
template&lt; class F &gt; 
function( F f );
}}
{{dcl rev multi|num=6
|since1=libfund_ts|dcl1=
template&lt; class Alloc &gt;
function( std::allocator_arg_t, const Alloc&amp; alloc ) noexcept;
|since2=libfund_ts_3|dcl2=
function( std::allocator_arg_t,
          const allocator_type&amp; alloc ) noexcept;
}}
{{dcl rev multi|num=7 
|since1=libfund_ts|dcl1=
template&lt; class Alloc &gt;
function( std::allocator_arg_t, const Alloc&amp; alloc, 
          std::nullptr_t ) noexcept;
|since2=libfund_ts_3|dcl2=
function( std::allocator_arg_t, const allocator_type&amp; alloc, 
          std::nullptr_t ) noexcept;
}}
{{dcl rev multi|num=8
|since1=libfund_ts|dcl1=
template&lt; class Alloc &gt;
function( std::allocator_arg_t, const Alloc&amp; alloc, 
          const function&amp; other );
|since2=libfund_ts_3|dcl2=
function( std::allocator_arg_t, const allocator_type&amp; alloc, 
          const function&amp; other );
}}
{{dcl rev multi|num=9
|since1=libfund_ts|dcl1=
template&lt; class Alloc &gt;
function( std::allocator_arg_t, const Alloc&amp; alloc, 
          function&amp;&amp; other );
|since2=libfund_ts_3|dcl2=
function( std::allocator_arg_t, const allocator_type&amp; alloc, 
          function&amp;&amp; other );
}}
{{dcl rev multi|num=10
|since1=libfund_ts|dcl1=
template&lt; class F, class Alloc &gt; 
function( std::allocator_arg_t, const Alloc&amp; alloc, F f );
|since2=libfund_ts_3|dcl2= 
function( std::allocator_arg_t, const allocator_type&amp; alloc, F f );
}}
{{dcl end}}

从各种源构造 {{tt|std::experimental::function}}。

@1,2@ 构造''空'' function。

@3@ 复制 {{c|other}} 的''目标''到 {{c|*this}} 的''目标''。若 {{c|other}} 为''空''，则调用后 {{c|*this}} 将亦为''空''。

@4@ 移动 {{c|other}} 的''目标''到 {{c|*this}} 的''目标''。若 {{c|other}} 为''空''，则调用后 {{c|*this}} 将亦为''空''。{{rev inl|since=libfund_ts_3|构造后，{{c|*this}} 存储 {{c|other.get_allocator()}} 的副本。}}

@5@ 以 {{c|f}} 的副本初始化''目标''。若 {{c|f}} 是空函数指针或空成员指针，则调用后 {{c|*this}} 将为''空''。此构造函数仅若 f 对实参类型 {{tt|Args...}} 和返回类型 {{tt|R}} {{named req|Callable|可调用}}才参与重载决议。

@6-10@ 同 {{v|1-5}}，但用 {{c|alloc}} 分配 {{tt|function}} 可能使用的任何内部数据结构的内存。{{rev inl|until=libfund_ts_3|这些构造函数将 {{c|alloc}} 当做类型擦除的分配器（见下文）。}}

{{rrev multi
|since1=libfund_ts|rev1=
以 {{v|1-5}} 构造后，{{c|this-&gt;get_memory_resource()}} 将返回构造中{{c|std::experimental::pmr::get_default_resource()}} 返回的相同值。
|since2=libfund_ts_3|rev2=
以 {{v|1-3}} 和 {{v|5}} 构造后，{{c|*this}} 存储默认构造的 {{c|std::pmr::polymorphic_allocator&lt;&gt;}}。
}}

当''目标''为函数指针或 {{lc|std::reference_wrapper}} 时，保证小对象优化，即始终直接存储这些目标于 {{lc|std::experimental::function}} 对象内，不发生动态分配。其他大对象可能在动态分配的存储中构造，并由 {{lc|std::experimental::function}} 对象通过指针访问。

若构造函数移动或复制了函数对象，包括 {{tt|std::experimental::function}} 的实例，则由[[cpp/memory/uses_allocator|''使用分配器构造'']]用分配器 {{rev inl|until=libfund_ts_3|{{c|this-&gt;get_memory_resource()}}}}{{rev inl|since=libfund_ts_3|{{c|this-&gt;get_allocator()}}}} 进行移动或复制。

{{cpp/experimental/type erased allocator|function}}

===参数===
{{par begin}}
{{par | other |用于初始化 {{c|*this}} 的函数对象}}
{{par | f |用于初始化 {{c|*this}} 的可调用对象}}
{{par | alloc |用于内部内存分配的分配器}}
{{par hreq}}
{{par req named | F |CopyConstructible|Callable}}
{{par end}}

===异常===
@3,8@ 若 {{c|other}} 的''目标''是函数指针或 {{lc|std::reference_wrapper}} 则不抛出，否则可能抛出 {{lc|std::bad_alloc}} 或存储的可调用对象的复制构造函数所抛出的任何异常。

@4@ （无）

@5,10@ 若 {{c|f}} 是函数指针或 {{lc|std::reference_wrapper}} 则不抛出，否则可能抛出 {{lc|std::bad_alloc}} 或存储的可调用对象的复制构造函数所抛出的任何异常。

@9@ （无）

===示例===
{{example
 | code=
 | output=
}}

{{langlinks|en}}