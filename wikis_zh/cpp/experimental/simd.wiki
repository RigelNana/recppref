{{title|SIMD 库}}
{{cpp/experimental/simd/navbar}}

{{fmbox|class=noprint|style=font-size: 0.8em|text='''已并入 ISO C++''' 本页面描述的功能已于 2024 年 11 月并入 ISO C++ 标准主线；参见[[cpp/numeric/simd|数据并行类型 (SIMD)]] {{mark since c++26}}}}

SIMD 库为显式表达数据并行操作和让数据并行操作更高效提供了便捷的类型。

一个 {{ltt|cpp/experimental/simd/simd|simd&lt;T&gt;}} 类型的对象行为和 {{tt|T}} 类型的对象相似。然而 {{tt|T}} 储存和操纵一个值，{{tt|simd&lt;T&gt;}} 储存和操纵多个值（被称为 ''宽度'' 但为了与其它标准库一致，被命名为 {{c|size}}，参见 {{ltt|cpp/experimental/simd/simd_size}}）。

每个在 {{tt|simd&lt;T&gt;}} 上的运算符和操作 都表现为''逐元素''操作（除了被明确标注为''水平''的操作）。这个简单的规则传达了数据并行的语义并会被编译器用来生成数据并行向量指令（SIMD 指令）和 / 或独立的执行流程。

{{tt|simd&lt;T&gt;}} 和 {{ltt|cpp/experimental/simd/simd|native_simd&lt;T&gt;}} 类型的宽度在编译时由实现决定。相反，{{ltt|cpp/experimental/simd/simd|fixed_size_simd&lt;T, N&gt;}} 类型的宽度是由开发者决定的一个特定的固定的值。

要想混用 SIMD 类型，一种推荐的高效的模式是使用 {{ltt|cpp/experimental/simd/simd|native_simd}} 和 {{ltt|cpp/experimental/simd/rebind_simd}}：
{{source|1=
#include &lt;experimental/simd&gt;
namespace stdx = std::experimental;

using floatv  = stdx::native_simd&lt;float&gt;;
using doublev = stdx::rebind_simd_t&lt;double, floatv&gt;;
using intv    = stdx::rebind_simd_t&lt;int, floatv&gt;;
}}
这样可以确保这些类型都有相同的宽度，因而可以相互转换。不同宽度类型的转换是未定义的，因为那样会丢弃或凭空创造一些值。若要改变大小，可以使用 SIMD 库提供的 {{ltt|cpp/experimental/simd/split}} 和 {{ltt|cpp/experimental/simd/concat}} 函数。

{{dsc begin}}
{{dsc header|experimental/simd}}
{{dsc end}}

===主类===
{{dsc begin}}
{{dsc inc|cpp/experimental/simd/dsc simd}}
{{dsc inc|cpp/experimental/simd/dsc simd_mask}}
{{dsc end}}

===ABI 标签===
{{dsc begin}}
{{dsc namespace|std::experimental::simd_abi}}
{{dsc inc|cpp/experimental/simd/dsc scalar}}
{{dsc inc|cpp/experimental/simd/dsc fixed_size}}
{{dsc inc|cpp/experimental/simd/dsc compatible}}
{{dsc inc|cpp/experimental/simd/dsc native}}
{{dsc inc|cpp/experimental/simd/dsc max_fixed_size}}
{{dsc inc|cpp/experimental/simd/dsc deduce}}
{{dsc end}}

===对齐标签===
{{dsc begin}}
{{dsc inc|cpp/experimental/simd/element aligned}}
{{dsc inc|cpp/experimental/simd/vector_aligned}}
{{dsc inc|cpp/experimental/simd/overaligned}}
{{dsc end}}

===where_expression===
{{dsc begin}}
{{dsc tclass | cpp/experimental/simd/const_where_expression |以非修改操作选择的元素| notes={{mark since parallelism_ts_2}}}}
{{dsc tclass | cpp/experimental/simd/where_expression |以修改操作选择的元素| notes={{mark since parallelism_ts_2}}}}
{{dsc tfun | cpp/experimental/simd/where |产生 const_where_expression 和 where_expression | notes={{mark since parallelism_ts_2}}}}
{{dsc end}}

===转型===
{{dsc begin}}
{{dsc tfun | cpp/experimental/simd/simd_cast |逐元素 static_cast | notes={{mark since parallelism_ts_2}} | title=simd_cast &lt;br/&gt; static_simd_cast }}
{{dsc tfun | cpp/experimental/simd/abi_cast |逐元素 ABI 转型| notes={{mark since parallelism_ts_2}} | title=to_fixed_size &lt;br/&gt; to_compatible &lt;br/&gt; to_native }}
{{dsc tfun | cpp/experimental/simd/split |分割单个 simd 对象为多个| notes={{mark since parallelism_ts_2}}}}
{{dsc tfun | cpp/experimental/simd/concat |连接多个 simd 对象为单个| notes={{mark since parallelism_ts_2}}}}
{{dsc end}}

===算法===
{{dsc begin}}
{{dsc tfun | cpp/experimental/simd/min |逐元素 min 操作| notes={{mark since parallelism_ts_2}}}}
{{dsc tfun | cpp/experimental/simd/max |逐元素 max 操作| notes={{mark since parallelism_ts_2}}}}
{{dsc tfun | cpp/experimental/simd/minmax |逐元素 minmax 操作| notes={{mark since parallelism_ts_2}}}}
{{dsc tfun | cpp/experimental/simd/clamp |逐元素 clamp 操作| notes={{mark since parallelism_ts_2}}}}
{{dsc end}}

===规约===
{{dsc begin}}
{{dsc tfun | cpp/experimental/simd/reduce |规约向量为单个元素| notes={{mark since parallelism_ts_2}}|title=reduce&lt;br&gt;hmin&lt;br&gt;hmax}}
{{dsc end}}

===掩码规约===
{{dsc begin}}
{{dsc inc|cpp/experimental/simd/dsc all_of}}
{{dsc inc|cpp/experimental/simd/dsc popcount}}
{{dsc inc|cpp/experimental/simd/dsc find_first_set}}
{{dsc end}}

===特征===
{{dsc begin}}
{{dsc inc|cpp/experimental/simd/dsc is_simd}}
{{dsc inc|cpp/experimental/simd/dsc is_abi_tag}}
{{dsc inc|cpp/experimental/simd/dsc is_simd_flag_type}}
{{dsc inc|cpp/experimental/simd/dsc simd_size}}
{{dsc inc|cpp/experimental/simd/dsc memory_alignment}}
{{dsc inc|cpp/experimental/simd/dsc rebind_simd}}
{{dsc end}}

===数学函数===
{{header|cmath}} 中除特殊数学函数之外的所有函数，都为 {{tt|simd}} 提供了重载。

===示例===
{{example
|code=
#include &lt;experimental/simd&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;
namespace stdx = std::experimental;

void println(std::string_view name, auto const&amp; a)
{
    std::cout &lt;&lt; name &lt;&lt; ": ";
    for (std::size_t i{}; i != std::size(a); ++i)
        std::cout &lt;&lt; a[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

template&lt;class A&gt;
stdx::simd&lt;int, A&gt; my_abs(stdx::simd&lt;int, A&gt; x)
{
    where(x &lt; 0, x) = -x;
    return x;
}

int main()
{
    const stdx::native_simd&lt;int&gt; a = 1;
    println("a", a);

    const stdx::native_simd&lt;int&gt; b([](int i) { return i - 2; });
    println("b", b);

    const auto c = a + b;
    println("c", c);

    const auto d = my_abs(c);
    println("d", d);

    const auto e = d * d;
    println("e", e);

    const auto inner_product = stdx::reduce(e);
    std::cout &lt;&lt; "inner product: " &lt;&lt; inner_product &lt;&lt; '\n';

    const stdx::fixed_size_simd&lt;long double, 16&gt; x([](int i) { return i; });
    println("x", x);
    println("cos²(x) + sin²(x)", stdx::pow(stdx::cos(x), 2) + stdx::pow(stdx::sin(x), 2));
}
|output=
a: 1 1 1 1 
b: -2 -1 0 1 
c: -1 0 1 2 
d: 1 0 1 2 
e: 1 0 1 4 
inner product: 6
x: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
cos²(x) + sin²(x): 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/dsc valarray}}
{{dsc end}}

===外部链接===
{{elink begin}}
{{elink|1=[https://github.com/VcDevel/std-simd ISO/IEC TS 19570:2018 Section 9 "Data-Parallel Types" 的实现] — github.com}}
{{elink|1=[https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=libstdc%2B%2B-v3/include/experimental/simd;hb=HEAD GCC/libstdc++] 的 TS 实现达成（GCC-11 提供 {{tt|std::experimental::simd}}） — gcc.gnu.org}}
{{elink end}}

{{langlinks|en|ja}}