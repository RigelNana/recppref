{{cpp/experimental/reflect/title|ObjectSequence}}
{{cpp/experimental/reflect/navbar}}
{{ddcl | since=reflection_ts | header=experimental/reflect | 1=
template&lt; class T &gt;
concept bool ObjectSequence = Object&lt;T&gt; &amp;&amp; /* 见下文 */;
}}

{{tt|ObjectSequence}} 概念为元对象序列类型所满足。

元对象序列类型是从生成序列的元对象操作（如 {{rlpt|get_data_members}}）获得的元对象类型。元对象序列类型中的每个元素均为元对象类型。

===示例==={{cpp/experimental/reflect/title|ObjectSequence}}
{{cpp/experimental/reflect/navbar}}
{{ddcl|since=reflection_ts|header=experimental/reflect|1=
template&lt; class T &gt;
concept ObjectSequence = Object&lt;T&gt; &amp;&amp; /* see below */;
}}

The {{tt|ObjectSequence}} concept is satisfied by meta-object sequence types.

A meta-object sequence type is a meta-object type that is obtained from a meta-object operation that generates a sequence, e.g. {{rlpt|get_data_members}}. Each element of a meta-object sequence type is a meta-object type.

===Example===
{{example|code=
#include&lt;cmath&gt;
#include&lt;experimental/reflect&gt;
#include&lt;tuple&gt;
#include&lt;type_traits&gt;

namespace reflect = std::experimental::reflect;

template&lt;reflect::Typed... Ms&gt;
using tuple_from_seq_t = std::tuple&lt;reflect::get_reflected_type_t&lt;
    reflect::get_type_t&lt;Ms&gt;&gt;...&gt;;

template&lt;reflect::Record T&gt;
using collect_tuple = reflect::unpack_sequence_t&lt;
    tuple_from_seq_t,
    reflect::get_data_members_t&lt;T&gt;&gt;;

int main()
{
    static_assert(reflect::ObjectSequence&lt;
                      reflect::get_data_members&lt;reflexpr(std::div_t)&gt;&gt;, "");
    static_assert(std::is_same&lt;collect_tuple&lt;reflexpr(std::div_t)&gt;,
                               std::tuple&lt;int, int&gt;&gt;::value, "");
}
}}

===参阅===
{{todo|模板化}}

{{langlinks|en|es|ja|ru}}