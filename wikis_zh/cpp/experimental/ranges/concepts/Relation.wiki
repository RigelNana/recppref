{{cpp/experimental/ranges/title|Relation}}
{{cpp/experimental/ranges/concepts/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/concepts}}
{{dcl|since=ranges|num=1|1=
template&lt; class R, class T, class U &gt;
concept bool Relation =
    Predicate&lt;R, T, T&gt; &amp;&amp;
    Predicate&lt;R, U, U&gt; &amp;&amp;
    CommonReference&lt;
        const std::remove_reference_t&lt;T&gt;&amp;,
        const std::remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
    Predicate&lt;R,
        ranges::common_reference_t&lt;
            const std::remove_reference_t&lt;T&gt;&amp;,
            const std::remove_reference_t&lt;U&gt;&amp;&gt;,
        ranges::common_reference_t&lt;
            const std::remove_reference_t&lt;T&gt;&amp;,
            const std::remove_reference_t&lt;U&gt;&amp;&gt;&gt; &amp;&amp;
    Predicate&lt;R, T, U&gt; &amp;&amp;
    Predicate&lt;R, U, T&gt;;
}}
{{dcl end}}

概念 {{tt|Relation&lt;R, T, U&gt;}} 指定 {{tt|R}} 在类型和值类别由 {{tt|T}} 或 {{tt|U}} 编码的表达式集合上定义二元关系。

给定
* {{tt|r}}，有 {{c|decltype((r))}} 为 {{tt|R}} 的表达式，
* {{tt|t}}，有 {{c|decltype((t))}} 为 {{tt|T}} 的表达式，
* {{tt|u}}，有 {{c|decltype((u))}} 为 {{tt|U}} 的表达式，

并令 {{tt|C}} 为 {{c|ranges::common_reference_t&lt;const std::remove_reference_t&lt;T&gt;&amp;, const std::remove_reference_t&lt;U&gt;&amp;&gt;}}，

则 {{tt|Relation&lt;R, T, U&gt;}} 仅若
* {{c|1=bool(r(t, u)) == bool(r(C(t), C(u)))}} 且
* {{c|1=bool(r(u, t)) == bool(r(C(u), C(t)))}}
才得到满足

{{langlinks|en}}