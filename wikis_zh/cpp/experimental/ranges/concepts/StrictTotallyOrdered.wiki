{{cpp/experimental/ranges/title|StrictTotallyOrdered|StrictTotallyOrderedWith}}
{{cpp/experimental/ranges/concepts/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/concepts}}
{{dcl|since=ranges|num=1|1=
template&lt; class T &gt;
concept bool StrictTotallyOrdered =
    EqualityComparable&lt;T&gt; &amp;&amp;
    requires(const std::remove_reference_t&lt;T&gt;&amp; a,
             const std::remove_reference_t&lt;T&gt;&amp; b) {
        { a &lt; b }  -&gt; Boolean&amp;&amp;;
        { a &gt; b }  -&gt; Boolean&amp;&amp;;
        { a &lt;= b } -&gt; Boolean&amp;&amp;;
        { a &gt;= b } -&gt; Boolean&amp;&amp;;
    };
}}
{{dcl|since=ranges|num=2|1=
template&lt; class T, class U &gt;
concept bool StrictTotallyOrderedWith =
    StrictTotallyOrdered&lt;T&gt; &amp;&amp;
    StrictTotallyOrdered&lt;U&gt; &amp;&amp;
    CommonReference&lt;
        const std::remove_reference_t&lt;T&gt;&amp;,
        const std::remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
    StrictTotallyOrdered&lt;
        ranges::common_reference_t&lt;
            const std::remove_reference_t&lt;T&gt;&amp;,
            const std::remove_reference_t&lt;U&gt;&amp;&gt;&gt; &amp;&amp;
    EqualityComparableWith&lt;T, U&gt; &amp;&amp;
    requires(const std::remove_reference_t&lt;T&gt;&amp; t,
             const std::remove_reference_t&lt;U&gt;&amp; u) {
        { t &lt; u }  -&gt; Boolean&amp;&amp;;
        { t &gt; u }  -&gt; Boolean&amp;&amp;;
        { t &lt;= u } -&gt; Boolean&amp;&amp;;
        { t &gt;= u } -&gt; Boolean&amp;&amp;;
        { u &lt; t }  -&gt; Boolean&amp;&amp;;
        { u &gt; t }  -&gt; Boolean&amp;&amp;;
        { u &lt;= t } -&gt; Boolean&amp;&amp;;
        { u &gt;= t } -&gt; Boolean&amp;&amp;;
    };
}}
{{dcl end}}

@1@ 概念 {{tt|StrictTotallyOrdered&lt;T&gt;}} 指定 {{tt|T}} 上的比较运算符 {{tt|1===,!=,&lt;,&gt;,&lt;=,&gt;=}} 产出的结果与 {{tt|T}} 上的[[enwiki:Total order#Strict total order|严格全序]]一致。
{{tt|StrictTotallyOrdered&lt;T&gt;}} 仅若符合下列条件才得到满足。给定 {{c|const std::remove_reference_t&lt;T&gt;}} 类型左值 {{tt|a}}、{{tt|b}} 和 {{tt|c}}：
* {{c|bool(a &lt; b)}}、{{c|bool(a &gt; b)}} 与 {{c|bool(a {{==}} b)}} 有且只有一个为 {{c|true}}；
* 若 {{c|bool(a &lt; b)}} 与 {{c|bool(b &lt; c)}} 均为 {{c|true}}，则 {{c|bool(a &lt; c)}} 为 {{c|true}}；
* {{c|1=bool(a &gt; b) == bool(b &lt; a)}}
* {{c|1=bool(a &gt;= b) == !bool(a &lt; b)}}
* {{c|1=bool(a &lt;= b) == !bool(b &lt; a)}}

@2@ 概念 {{tt|StrictTotallyOrderedWith&lt;T, U&gt;}} 指定（可混合的）{{tt|T}} 与 {{tt|U}} 操作数上的比较运算符 {{tt|1===,!=,&lt;,&gt;,&lt;=,&gt;=}} 产出的结果与严格全序一致。比较混合的运算数产出的结果等价于比较转换到其共用类型的运算数。
正式而言，{{tt|StrictTotallyOrderedWith&lt;T, U&gt;}} 仅若符合下列条件才得到满足。给定任何 {{c|const std::remove_reference_t&lt;T&gt;}} 类型左值 {{tt|t}} 与任何 {{c|const std::remove_reference_t&lt;U&gt;}} 类型左值 {{tt|u}} ，并令 {{tt|C}} 为 {{c|ranges::common_reference_t&lt;const std::remove_reference_t&lt;T&gt;&amp;, const std::remove_reference_t&lt;U&gt;&amp;&gt;}}：
* {{c|1=bool(t &lt; u) == bool(C(t) &lt; C(u))}}
* {{c|1=bool(t &gt; u) == bool(C(t) &gt; C(u))}}
* {{c|1=bool(t &lt;= u) == bool(C(t) &lt;= C(u))}}
* {{c|1=bool(t &gt;= u) == bool(C(t) &gt;= C(u))}}
* {{c|1=bool(u &lt; t) == bool(C(u) &lt; C(t))}}
* {{c|1=bool(u &gt; t) == bool(C(u) &gt; C(t))}}
* {{c|1=bool(u &lt;= t) == bool(C(u) &lt;= C(t))}}
* {{c|1=bool(u &gt;= t) == bool(C(u) &gt;= C(t))}}

{{cpp/experimental/ranges/equality preservation}}
{{cpp/experimental/ranges/note implicit expression variations}}

{{langlinks|en}}