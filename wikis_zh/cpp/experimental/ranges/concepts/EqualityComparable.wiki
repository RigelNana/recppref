{{cpp/experimental/ranges/title|EqualityComparable|EqualityComparableWith}}
{{cpp/experimental/ranges/concepts/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/concepts}}
{{dcl|since=ranges|num=1|1=
template&lt; class T &gt;
concept bool EqualityComparable = WeaklyEqualityComparableWith&lt;T, T&gt;;
}}
{{dcl|since=ranges|num=2|1=
template&lt; class T, class U &gt;
concept bool EqualityComparableWith =
    EqualityComparable&lt;T&gt; &amp;&amp;
    EqualityComparable&lt;U&gt; &amp;&amp;
    CommonReference&lt;
        const std::remove_reference_t&lt;T&gt;&amp;,
        const std::remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
    EqualityComparable&lt;
        ranges::common_reference_t&lt;
            const std::remove_reference_t&lt;T&gt;&amp;,
            const std::remove_reference_t&lt;U&gt;&amp;&gt;&gt; &amp;&amp;
    WeaklyEqualityComparableWith&lt;T, U&gt;;
}}
{{dcl end}}

@1@ 概念 {{tt|EqualityComparable&lt;T&gt;}} 指定 {{tt|T}} 上的比较运算符 {{tt|1===}} 与 {{tt|1=!=}} 反应相等性： {{tt|1===}} 当且仅当其操作数相等时产出 {{c|true}}。

@@ {{tt|EqualityComparable&lt;T&gt;}} 仅若符合下列条件才得到满足。给定 {{tt|T}} 类型对象 {{tt|a}} 与 {{tt|b}}，若且唯若 {{tt|a}} 与 {{tt|b}} 相等 {{c|1=bool(a == b)}} 才为 {{c|true}}。伴随 {{c|1=a == b}} 保持相等性的要求，这蕴含 {{tt|1===}} 对称且传递，进而 {{tt|1===}} 对所有至少等于一个其他对象的对象 {{tt|a}} 自反。

@2@ 概念 {{tt|EqualityComparableWith&lt;T, U&gt;}} 指定（可能混合的）{{tt|T}} 与 {{tt|U}} 操作数上的 {{tt|1===}} 与 {{tt|1=!=}} 产出的结果与相等性一致。比较混合运算数生成的结果等价于比较转换到其共用类型的运算数。

@@ 正式而言，{{tt|EqualityComparableWith&lt;T, U&gt;}} 仅若符合下列条件才得到满足。给定任何 {{c|const std::remove_reference_t&lt;T&gt;}} 类型的左值 {{tt|t}} 与任何 {{c|const std::remove_reference_t&lt;U&gt;}} 类型的左值 {{tt|u}}，并令 {{tt|C}} 为 {{c|ranges::common_reference_t&lt;const std::remove_reference_t&lt;T&gt;&amp;, const std::remove_reference_t&lt;U&gt;&amp;&gt;}}，有 {{c|1=bool(t == u) == bool(C(t) == C(u))}}。

{{cpp/experimental/ranges/equality preservation|skip-requires=yes}}
{{cpp/experimental/ranges/note implicit expression variations}}

{{langlinks|en}}