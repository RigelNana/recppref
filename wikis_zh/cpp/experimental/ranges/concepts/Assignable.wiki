{{cpp/experimental/ranges/title|Assignable}}
{{cpp/experimental/ranges/concepts/navbar}}
{{ddcl|header=experimental/ranges/concepts|since=ranges|1=
template&lt; class T, class U &gt;
concept bool Assignable =
    std::is_lvalue_reference&lt;T&gt;::value &amp;&amp;
    CommonReference&lt;
        const std::remove_reference_t&lt;T&gt;&amp;,
        const std::remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
    requires(T t, U&amp;&amp; u) {
        { t = std::forward&lt;U&gt;(u) } -&gt; Same&lt;T&gt;&amp;&amp;;
    };
}}
概念 {{tt|Assignable&lt;T, U&gt;}} 指定类型和值类别为 {{tt|U}} 所指定的表达式能被赋值给类型为 {{tt|T}} 所指定的左值表达式。

给定
* {{tt|t}}，{{c|std::remove_reference_t&lt;T&gt;}} 类型的指代对象 {{tt|o}} 的左值，
* {{tt|u}}，使得 {{c|decltype((u))}} 为 {{tt|U}} 的表达式，
* {{tt|u2}}，等于 {{tt|u}} 的另一对象。
{{tt|Assignable&lt;T, U&gt;}} 得到满足，仅若
* {{c|1=std::addressof(t = u) == std::addressof(o)}}（即赋值表达式产生指代左运算数的左值）；
* 求值 {{c|1=t = u}} 后：
** {{tt|t}} 等于 {{tt|u2}}，除非 {{tt|u}} 是指代 {{tt|o}} 的非 const 亡值（即赋值是自移动赋值），
** 若 {{tt|u}} 为泛左值：
*** 若它是非 const 亡值，则其所指代的对象在合法但未指定的状态；
*** 否则，不修改其所指代的对象；

{{tt|Assignable&lt;T, U&gt;}} 与 {{c|std::is_lvalue_reference&lt;T&gt;::value}} 间不必有任何蕴含关系。

{{cpp/experimental/ranges/equality preservation}}

===注解===
{{cpp/experimental/ranges/note Same deduction}}

赋值不需要是全函数。特别是，若赋值给某对象 {{tt|x}} 能导致修改某个其他对象 {{tt|y}}，则 {{c|1=x = y}} 可能不在 {{tt|{{=}}}} 的定义域中。若右运算数直接或间接地为左运算数所占有（例如用基于结点的数据结构中的指向结点的智能指针，或用类似 {{c|std::vector&lt;std::any&gt;}} 的构造），则这通常会发生。

{{langlinks|en}}