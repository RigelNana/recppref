{{cpp/experimental/ranges/title|swap}}
{{cpp/experimental/ranges/utility/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/utility}}
{{dcl|notes={{mark|定制点对象}}|since=ranges|1=
namespace {
    constexpr /* 未指明 */ swap = /* 未指明 */;
}
}}
{{dcl h|调用签名}}
{{dcl|1=
template&lt; class T, class U &gt;
    requires /* 见下文 */
void swap( T&amp;&amp; t, U&amp;&amp; u ) noexcept(/* 见下文 */);
}}
{{dcl end}}

交换 {{c|t}} 和 {{c|u}} 所引用的值。

调用 {{tt|ranges::swap}} 等价于：
@1@ {{c|(void)swap(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u))}}，若该表达式合法，其中以下列候选进行[[cpp/language/overload resolution|重载决议]]：
* {{c|1=template&lt;class T&gt; void swap(T&amp;, T&amp;) = delete;}}
* {{c|1=template&lt;class T, std::size_t N&gt; void swap(T(&amp;)[N], T(&amp;)[N]) = delete;}}
* [[cpp/language/adl|实参依赖查找]]所找到的任何 {{tt|swap}} 的声明。
@@ 若重载决议所选择的函数不交换 {{c|t}} 和 {{c|u}} 所引用的值，则程序非良构；不要求诊断。
@2@ 否则为 {{c|(void)ranges::swap_ranges(t, u)}}，若 {{tt|T}} 和 {{tt|U}} 为到相等长度（但元素类型可能不同）的数组类型的左值引用，且 {{c|ranges::swap(*t, *u)}} 为合法表达式；
@3@ 否则，若 {{tt|T}} 与 {{tt|U}} 均为 {{tt|V&amp;}}，而 {{tt|V}} 是满足 {{c|ranges::MoveConstructible&lt;V&gt;}} 和 {{c|ranges::Assignable&lt;V&amp;, V&gt;}} 要求的某个类型，则如同用 {{c|1= V v{std::move(t)}; t = std::move(u); u = std::move(v);}} 交换其被引用值。若任一概念的语义要求未得到满足，则程序非良构；不要求诊断。
@4@ 所有其他情况下，对 {{tt|ranges::swap}} 的调用非良构。

若 {{c|ranges::swap}} 调用的每个函数（按上述方式指定）都能用于常量表达式中，则亦能如此使用它。

{{cpp/experimental/ranges/cpo}}

=== 异常 ===
@1@ {{noexcept|noexcept((void)swap(std::forward&lt;T&gt;(t), std::forward&lt;T&gt;(u)))}}，其中按上述方式找到 {{tt|swap}}。
@2@ {{noexcept|noexcept(ranges::swap(*t, *u))}}
@3@ {{noexcept|std::is_nothrow_move_constructible&lt;V&gt;::value &amp;&amp;
         std::is_nothrow_move_assignable&lt;V&gt;::value}}

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc swap}}
{{dsc end}}

{{langlinks|en}}