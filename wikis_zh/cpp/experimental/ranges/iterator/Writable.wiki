{{cpp/experimental/ranges/title|Writable}}
{{cpp/experimental/ranges/iterator/navbar}}
{{ddcl|header=experimental/ranges/iterator|since=ranges|1=
template&lt; class Out, class T &gt;
concept bool Writable =
    requires(Out&amp;&amp; o, T&amp;&amp; t) {
        *o = std::forward&lt;T&gt;(t);
        *std::forward&lt;Out&gt;(o) = std::forward&lt;T&gt;(t);
        const_cast&lt;const ranges::reference_t&lt;Out&gt;&amp;&amp;&gt;(*o) =
            std::forward&lt;T&gt;(t); 
        const_cast&lt;const ranges::reference_t&lt;Out&gt;&amp;&amp;&gt;(*std::forward&lt;Out&gt;(o)) =
            std::forward&lt;T&gt;(t);
    };
    /* 上述四个表达式都不要求保持相等性 */
}}

概念 {{tt|Writable&lt;Out, T&gt;}} 指定写入类型和值类别为 {{tt|T}} 所编码的值到迭代器 {{tt|Out}} 所引用对象的要求。

令 {{tt|E}} 为满足 {{c|decltype((E))}} 为 {{tt|T}} 的表达式，而 {{c|o}} 为 {{tt|Out}} 类型的可解引用对象，则 {{tt|Writable&lt;Out, T&gt;}} 仅若符合下列条件才得到满足：
* 若 {{c|ranges::Readable&lt;Out&gt; &amp;&amp; ranges::Same&lt;ranges::value_type_t&lt;Out&gt;, std::decay_t&lt;T&gt;&gt;}} 得到满足，则在任何上述赋值后 {{c|*o}} 等于 {{tt|E}} 在赋值前的值。

不要求 {{c|o}} 在求值任何上述赋值表达式后可解引用。若 {{tt|E}} 为亡值，则其代表的对象的结果状态合法但未指定。

{{cpp/experimental/ranges/equality preservation|skip-requires=yes}}

===注解===
{{c|operator*}} 仅有的合法用法是在赋值表达式左侧。通过可写类型相同值的赋值可以只发生一次。

带 {{c/core|const_cast}} 的要求表达式阻止有纯右值 {{tt|reference}} 类型的 {{rconcept|Readable}} 对象意外地满足 {{tt|Writable}} 的语法要求，同时容许代理引用继续工作，只要其常性是浅的。见[https://github.com/ericniebler/stl2/issues/381 范围 TS 问题 381]。

{{langlinks|en|ja}}