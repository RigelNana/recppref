{{cpp/experimental/ranges/title|lexicographical_compare}}
{{cpp/experimental/ranges/algorithm/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/algorithm}}
{{dcl|since=ranges|num=1|1=
template&lt; InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
          class Proj1 = ranges::identity, class Proj2 = ranges::identity,
          class Comp = ranges::less&lt;&gt; &gt;
    requires IndirectStrictWeakOrder&lt;Comp, projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt;
bool lexicographical_compare( I1 first1, S1 last1, I2 first2, S2 last2,
                              Comp comp = Comp{}, 
                              Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );
}}
{{dcl|since=ranges|num=2|1=
template&lt; InputRange R1, InputRange R2,
          class Proj1 = ranges::identity, class Proj2 = ranges::identity,
          class Comp = ranges::less&lt;&gt; &gt;
    requires IndirectStrictWeakOrder&lt;Comp, projected&lt;ranges::iterator_t&lt;R1&gt;, Proj1&gt;,
                                           projected&lt;ranges::iterator_t&lt;R2&gt;, Proj2&gt;&gt;
bool lexicographical_compare( R1&amp;&amp; r1, R2&amp;&amp; r2, Comp comp = Comp{},
                              Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );
}}
{{dcl end}}

@1@ 检查第一范围 {{range|first1|last1}} 是否按字典序''小于''第二范围 {{range|first2|last2}}。经过分别以 {{c|proj1}} 和 {{c|proj2}} 投射之后，使用给定的二元比较函数 {{c|comp}} 比较各个元素。

@2@ 与 {{v|1}} 相同，但用 {{c|r1}} 为第一源范围并用 {{c|r2}} 为第二源范围，如同以 {{c|ranges::begin(r1)}} 为 {{c|first1}}，以 {{c|ranges::end(r1)}} 为 {{c|last1}}，以 {{c|ranges::begin(r2)}} 为 {{c|first2}}，并以 {{c|ranges::end(r2)}} 为 {{c|last2}}。

字典序比较是具有下列性质的操作：
* 两个范围进行逐元素比较。
* 首个不匹配的元素定义哪个范围按字典序''小于''或''大于''另一个。
* 如果一个范围是另一个的前缀，则较短范围按字典序''小于''另一个。
* 如果两个范围具有等价的元素且长度相同，则两个范围按字典序''相等''。
* 空范围按字典序''小于''非空范围。
* 两个空范围按字典序''相等''。

===参数===
{{par begin}}
{{par|first1, last1|要检验的第一元素范围}}
{{par|r1|要检验的第一元素范围}}
{{par|first2, last2|要检验的第二元素范围}}
{{par|r2|要检验的第二元素范围}}
{{par|comp|运用于投射后元素的比较函数}}
{{par|proj1|运用于第一范围中元素的投射}}
{{par|proj2|运用于第二范围中元素的投射}}
{{par end}}

===返回值===
如果第一范围按字典序''小于''第二范围，则返回 {{c|true}}。

===复杂度===
最多 {{math|2&amp;middot;min(N1, N2)}} 次运用比较运算，其中 {{c|1=N1 = last1 - first1}} 且 {{c|1=N2 = last2 - first2}}。

===可能的实现===
{{eq fun|1=
template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
         class Proj1 = ranges::identity, class Proj2 = ranges::identity,
         class Comp = ranges::less&lt;&gt;&gt;
    requires IndirectStrictWeakOrder&lt;Comp, projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt;
bool lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                             Comp comp = Comp{}, 
                             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{})
{
    for (; (first1 != last1) &amp;&amp; (first2 != last2); (void) ++first1, (void) ++first2)
    {
        if (ranges::invoke(comp, ranges::invoke(proj1, *first1),
                                 ranges::invoke(proj2, *first2)))
            return true;
        if (ranges::invoke(comp, ranges::invoke(proj2, *first2),
                                 ranges::invoke(proj1, *first1)))
            return false;
    }
    return (first1 == last1) &amp;&amp; (first2 != last2);
}
}}

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc lexicographical_compare}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc equal}}
{{dsc end}}