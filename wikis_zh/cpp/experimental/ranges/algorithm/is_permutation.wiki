{{cpp/experimental/ranges/title|is_permutation}}
{{cpp/experimental/ranges/algorithm/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/algorithm}}
{{dcl|since=ranges|num=1|1=
template&lt; ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2, Sentinel&lt;I2&gt; S2,
          class Pred = ranges::equal_to&lt;&gt;, 
          class Proj1 = ranges::identity, class Proj2 = ranges::identity &gt;
    requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
bool is_permutation( I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{}, 
                     Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );
}}
{{dcl|since=ranges|num=2|1=
template&lt; ForwardRange R1, ForwardRange R2, class Pred = ranges::equal_to&lt;&gt;,
          class Proj1 = ranges::identity, class Proj2 = ranges::identity &gt;
    requires IndirectlyComparable&lt;ranges::iterator_t&lt;R1&gt;, ranges::iterator_t&lt;R2&gt;,
                                  Pred, Proj1, Proj2&gt;
bool is_permutation( R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = Pred{},
                     Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );
}}
{{dcl|since=ranges|num=3|notes={{mark deprecated}}|1=
template&lt; ForwardIterator I1, Sentinel&lt;I1&gt; S1, class I2,
          class Pred = ranges::equal_to&lt;&gt;, 
          class Proj1 = ranges::identity, class Proj2 = ranges::identity &gt;
    requires ForwardIterator&lt;std::decay_t&lt;I2&gt;&gt; &amp;&amp; !Range&lt;I2&gt; &amp;&amp;
             IndirectlyComparable&lt;I1, std::decay_t&lt;I2&gt;, Pred, Proj1, Proj2&gt;
bool is_permutation( I1 first1, S1 last1, I2&amp;&amp; first2_, Pred pred = Pred{},
                     Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );

}}
{{dcl|since=ranges|num=4|notes={{mark deprecated}}|1=
template&lt; ForwardRange R1, class I2, class Pred = ranges::equal_to&lt;&gt;,
          class Proj1 = ranges::identity, class Proj2 = ranges::identity &gt;
    requires ForwardIterator&lt;std::decay_t&lt;I2&gt;&gt; &amp;&amp; !Range&lt;I2&gt; &amp;&amp;
             IndirectlyComparable&lt;ranges::iterator_t&lt;R1&gt;, std::decay_t&lt;I2&gt;, Pred, Proj1, Proj2&gt;
bool is_permutation( R1&amp;&amp; r1, I2&amp;&amp; first2_, Pred pred = Pred{}, 
                     Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );
}}
{{dcl end}}

@1@ 如果存在范围 {{range|first1|last1}} 中各元素的一种排列，使其范围等于 {{range|first2|last2}} 则返回 {{c|true}}，否则返回 {{c|false}}。

@2@ 与 {{v|1}} 相同，但用 {{c|r1}} 为第一源范围并用 {{c|r2}} 为第二源范围，如同以 {{c|ranges::begin(r1)}} 为 {{c|first1}}，以 {{c|ranges::end(r1)}} 为 {{c|last1}}，以 {{c|ranges::begin(r2)}} 为 {{c|first2}}，并以 {{c|ranges::end(r2)}} 为 {{c|last2}}。

@3@ 与 {{v|1}} 相同，但 {{c|first2}} 如同以 {{c|std::decay_t&lt;I2&gt; first2 {{=}} std::forward&lt;I2&gt;(first2_);}} 定义且 {{c|last2}} 为 {{c|first2 + (last1 - first1)}}。

@4@ 与 {{v|3}} 相同，但用 {{c|r1}} 为第一源范围，如同以 {{c|ranges::begin(r1)}} 为 {{c|first1}} 并以 {{c|ranges::end(r1)}} 为 {{c|last1}}。

如果两个范围具有相同的元素数量，并且对于范围 {{range|first1|last1}} 中的每个迭代器 {{tt|i}}，{{c|ranges::invoke(pred, ranges::invoke(proj1, *i), ranges::invoke(proj2, *(first2 + (i - first1))))}} 为 {{c|true}}，则认为两范围相等。

{{cpp/experimental/ranges/algorithm/tparams}}

===参数===
{{par begin}}
{{par|first1, last1|第一元素范围}}
{{par|r1|第一元素范围}}
{{par|first2, last2|第二元素范围}}
{{par|r2|第二元素范围}}
{{par|first2_|第二元素范围的开头}}
{{par|pred|运用于投射后元素的谓词}}
{{par|proj1|运用于第一范围中元素的投射}}
{{par|proj2|运用于第二范围中元素的投射}}
{{par end}}

===返回值===
如果范围 {{range|first1|last1}} 是范围 {{range|first2|last2}} 的排列则为 {{c|true}}。

===复杂度===
最多 {{math|O(N&lt;sup&gt;2&lt;/sup&gt;)}} 次运用谓词和各投射，或当两序列已经相等时恰好 {{math|N}} 次，其中 {{c|1=N = last1 - first1}}。

However if {{c|SizedSentinel&lt;S1, I1&gt; &amp;&amp; SizedSentinel&lt;S2, I2&gt;}} is satisfied and {{c|last1 - first1 !{{=}} last2 - first2}}, no applications of the predicate and projections are made.

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc is_permutation}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc next_permutation}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc prev_permutation}}
{{dsc end}}