{{cpp/experimental/ranges/title|all_of|any_of|none_of}}
{{cpp/experimental/ranges/algorithm/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/algorithm}}
{{dcl|since=ranges_ts|num=1|1=
template&lt; InputIterator I, Sentinel&lt;I&gt; S, class Proj = ranges::identity,
          IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred &gt;
bool all_of( I first, S last, Pred pred, Proj proj = Proj{} );}}
{{dcl|since=ranges_ts|num=2|1=
template&lt; InputRange R, class Proj = ranges::identity,
          IndirectUnaryPredicate&lt;projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
bool all_of( R&amp;&amp; r, Pred pred, Proj proj = Proj{} );}}
{{dcl|since=ranges_ts|num=3|1=
template&lt; InputIterator I, Sentinel&lt;I&gt; S, class Proj = ranges::identity,
          IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred &gt;
bool any_of( I first, S last, Pred pred, Proj proj = Proj{} );}}
{{dcl|since=ranges_ts|num=4|1=
template&lt; InputRange R, class Proj = ranges::identity,
          IndirectUnaryPredicate&lt;projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
bool any_of( R&amp;&amp; r, Pred pred, Proj proj = Proj{} );}}
{{dcl|since=ranges_ts|num=5|1=
template&lt; InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
          IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred &gt;
bool none_of( I first, S last, Pred pred, Proj proj = Proj{} );}}
{{dcl|since=ranges_ts|num=6|1=
template&lt; InputRange R, class Proj = ranges::identity,
          IndirectUnaryPredicate&lt;projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
bool none_of( R&amp;&amp; r, Pred pred, Proj proj = Proj{} );}}
{{dcl end}}
@1@ 检查一元谓词 {{c|pred}} 是否对范围 {{range|first|last}} 中的所有元素返回 {{c|true}}。

@3@ 检查一元谓词 {{c|pred}} 是否对范围 {{range|first|last}} 中至少一个元素返回 {{c|true}}。

@5@ 检查一元谓词 {{c|pred}} 是否不对范围 {{range|first|last}} 中任何元素返回 {{c|true}}。

@2,4,6@ 同 {{v|1,3,5}}，但以 {{c|r}} 为源范围，如同以 {{c|ranges::begin(rng)}} 为 {{c|first}} 并以 {{c|ranges::end(rng)}} 为 {{c|last}}。

===参数===
{{par begin}}
{{par | first, last |要检验的元素范围}}
{{par | rng |要检验的元素范围}}
{{par | pred |应用到投影后元素的谓词}}
{{par | proj |应用到元素的投影}}
{{par end}}

===返回值===
@1,2@ 若 {{c|pred}} 对范围中所有元素返回 {{c|true}} 则为 {{c|true}}，否则为 {{c|false}}。若范围为空则返回 {{c|true}}。

@3,4@ 若 {{c|pred}} 对范围中至少一个元素返回 {{c|true}} 则为 {{c|true}}，否则为 {{c|false}}。若范围为空则返回 {{c|false}}。

@5,6@ 若 {{c|pred}} 不对范围中任何元素返回 {{c|true}} 则为 {{c|true}}，否则为 {{c|false}}。若范围为空则返回 {{c|true}}。

===复杂度===
@1-6@ 至多应用 {{c|last - first}} 次谓词，应用 {{c|last - first}} 次投影。

===可能的实现===
{{eq fun|1=
template&lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = ranges::identity,
         IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
bool all_of(I first, S last, Pred pred, Proj proj = Proj{})
{
    return ranges::find_if_not(first, last, std::ref(pred), std::ref(proj)) == last;
}

template&lt;InputRange R, class Proj = ranges::identity,
         IndirectUnaryPredicate&lt;projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
bool all_of(R&amp;&amp; r, Pred pred, Proj proj = Proj{})
{
    return ranges::all_of(ranges::begin(r), ranges::end(r),
                          std::ref(pred), std::ref(proj));
}
|2=
template&lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = ranges::identity,
         IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
bool any_of(I first, S last, Pred pred, Proj proj = Proj{})
{
    return ranges::find_if(first, last, std::ref(pred), std::ref(proj)) != last;
}

template&lt;InputRange R, class Proj = ranges::identity,
         IndirectUnaryPredicate&lt;projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
bool any_of(R&amp;&amp; r, Pred pred, Proj proj = Proj{})
{
    return ranges::any_of(ranges::begin(r), ranges::end(r),
                          std::ref(pred), std::ref(proj));
}
|3=
template&lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
         IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
bool none_of(I first, S last, Pred pred, Proj proj = Proj{})
{
    return ranges::find_if(first, last, std::ref(pred), std::ref(proj)) == last;
}

template&lt;InputRange R, class Proj = ranges::identity,
         IndirectUnaryPredicate&lt;projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
bool none_of(R&amp;&amp; r, Pred pred, Proj proj = Proj{})
{
    return ranges::none_of(ranges::begin(r), ranges::end(r),
                           std::ref(pred), std::ref(proj));
}
}}

===示例===
{{example
|code=
#include &lt;experimental/ranges/algorithm&gt;
#include &lt;experimental/ranges/iterator&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

namespace ranges = std::experimental::ranges;
 
int main()
{
    std::vector&lt;int&gt; v(10, 2);
    std::partial_sum(v.cbegin(), v.cend(), v.begin());
    std::cout &lt;&lt; "这些数中: ";
    ranges::copy(v, ranges::ostream_iterator&lt;int&gt;(std::cout, " "));
    std::cout &lt;&lt; '\n';
 
    if (ranges::all_of(v.cbegin(), v.cend(), [](int i) { return i % 2 == 0; }))
        std::cout &lt;&lt; "所有数均为偶数\n";
    if (ranges::none_of(v, std::bind(std::modulus&lt;int&gt;(), std::placeholders::_1, 2)))
        std::cout &lt;&lt; "其中没有奇数\n";

    struct DivisibleBy
    {
        const int d;
        DivisibleBy(int n) : d(n) {}
        bool operator()(int n) const { return n % d == 0; }
    };
 
    if (ranges::any_of(v, DivisibleBy(7)))
        std::cout &lt;&lt; "至少一个数可被 7 整除\n";
}
|output=这些数中: 2 4 6 8 10 12 14 16 18 20 
所有数均为偶数
其中没有奇数
至少一个数可被 7 整除
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc all_any_none_of}}
{{dsc end}}

{{langlinks|en}}