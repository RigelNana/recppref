{{cpp/experimental/ranges/title|find_first_of}}
{{cpp/experimental/ranges/algorithm/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/algorithm}}
{{dcl|since=ranges|num=1|1=
template&lt; InputIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2, Sentinel&lt;I2&gt; S2,
          class Proj1 = ranges::identity, class Proj2 = ranges::identity,
          IndirectRelation&lt;projected&lt;I1, Proj1&gt;, 
                           projected&lt;I2, Proj2&gt;&gt; Pred = ranges::equal_to&lt;&gt; &gt;
I1 find_first_of( I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
                  Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );

}}
{{dcl|since=ranges|num=2|1=
template&lt; InputRange R1, ForwardRange R2, 
          class Proj1 = ranges::identity, class Proj2 = ranges::identity,
          IndirectRelation&lt;projected&lt;ranges::iterator_t&lt;R1&gt;, Proj1&gt;,
                           projected&lt;ranges::iterator_t&lt;R2&gt;, Proj2&gt;&gt; Pred = ranges::equal_to&lt;&gt; &gt;
ranges::safe_iterator_t&lt;R1&gt; find_first_of( R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = Pred{},
                                           Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );
}}
{{dcl end}}

@1@ 在范围 {{range|first1|last1}} 中，经过以 {{c|proj1}} 和 {{c|proj2}} 分别投射两个范围后，搜索范围 {{range|first2|last2}} 中的任何元素。使用 {{c|pred}} 比较投射后的元素。
@2@ 与 {{v|1}} 相同，但用 {{c|r1}} 为第一源范围并用 {{c|r2}} 为第二源范围，如同以 {{c|ranges::begin(r1)}} 为 {{c|first1}}，以 {{c|ranges::end(r1)}} 为 {{c|last1}}，以 {{c|ranges::begin(r2)}} 为 {{c|first2}}，并以 {{c|ranges::end(r2)}} 为 {{c|last2}}。

===参数===
{{par begin}}
{{par|first1, last1|要检验的元素范围}}
{{par|r1|要检验的元素范围}}
{{par|first2, last2|要搜索的元素范围}}
{{par|r2|要搜索的元素范围}}
{{par|pred|用于比较投射后元素的谓词}}
{{par|proj1|应用于第一范围中元素的投射}}
{{par|proj2|应用于第一范围中元素的投射}}
{{par end}}

===返回值===
指向范围 {{range|first1|last1}} 中首个投射后等于范围 {{range|first2|last2}} 中元素的元素的迭代器。如果未找到这种元素，则返回与 {{c|last1}} 比较相等的迭代器。

===复杂度===
至多 {{tt|(S * N)}} 此运用谓词和各投射，其中 {{c|S {{=}} distance(last2 - first2)}} 且 {{c|N {{=}} last1 - first1}}。

===可能的实现===
{{eq fun
|1=
template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2, Sentinel&lt;I2&gt; S2,
         class Proj1 = ranges::identity, class Proj2 = ranges::identity,
         IndirectRelation&lt;projected&lt;I1, Proj1&gt;, 
                          projected&lt;I2, Proj2&gt;&gt; Pred = ranges::equal_to&lt;&gt;&gt;
I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
                 Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{})
{
    for (; first1 != last1; ++first1)
        for (ForwardIt it = first2; it != last2; ++it)
            if (ranges::invoke(pred, ranges::invoke(proj1, *first1),
                                     ranges::invoke(proj2, *it)))
                return first1;
    return first1;
}
}}

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc find_first_of}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc find}}
{{dsc end}}