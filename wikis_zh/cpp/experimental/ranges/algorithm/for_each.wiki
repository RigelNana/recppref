{{cpp/experimental/ranges/title|for_each}}
{{cpp/experimental/ranges/algorithm/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/algorithm}}
{{dcl|since=ranges|num=1|1=
template&lt; InputIterator I, Sentinel&lt;I&gt; S, class Proj = ranges::identity,
          IndirectUnaryInvocable&lt;projected&lt;I, Proj&gt;&gt; Fun &gt;
ranges::tagged_pair&lt;tag::in(I), tag::fun(Fun)&gt;
    for_each( I first, S last, Fun f, Proj proj = Proj{} );
}}
{{dcl|since=ranges|num=2|1=
template&lt; InputRange R, class Proj = ranges::identity,
          IndirectUnaryInvocable&lt;projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Fun &gt;
ranges::tagged_pair&lt;tag::in(ranges::safe_iterator_t&lt;R&gt;), tag::fun(Fun)&gt;
    for_each( R&amp;&amp; r, Fun f, Proj proj = Proj{} );
}}
{{dcl end}}

@1@ 按顺序，对范围 {{range|first|last}} 中的每个迭代器解引用后调用投影 {{c|proj}} 的结果调用给定的函数对象 {{c|f}}（即 {{c|ranges::invoke(f, ranges::invoke(proj, *i))}}）。
@2@ 同 {{v|1}}，但以 {{c|r}} 为源范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

对于两个重载，若迭代器类型可变，则 {{c|f}} 可以通过解引用后的迭代器修改范围的元素。若 {{c|f}} 返回了结果，则忽略此结果。

不同于另外的算法，不允许 {{tt|for_each}} 复制序列中的元素，即使它们为可平凡复制。

不同于 {{lc|std::for_each}}（它只要求{{named req|MoveConstructible}}），这些函数要求 {{tt|Fun}} 实现 {{rconcept|CopyConstructible}}。

{{cpp/experimental/ranges/algorithm/tparams}}

===参数===
{{par begin}}
{{par | first, last |要应用函数的范围}}
{{par | r |要应用函数的范围}}
{{par | f |应用到每个投射后的范围中元素的可调用对象}}
{{par | proj |应用到元素的投射}}
{{par end}}

===返回值===
含有下列两个成员的 {{tt|tagged_pair}}：
* 第一成员带标签 {{tt|tag::in}}，是源范围的尾后迭代器（即比较等于哨位 {{c|last}} 的 {{tt|I}} 类型的迭代器）。
* 第二成员带标签 {{tt|tag::fun}}，（在该函数对象的所有应用后）从 {{tt|std::move(f)}} 初始化。

===复杂度===
恰好应用 {{c|last}} - {{c|first}} 次 {{c|f}} 和 {{c|proj}}。

===可能的实现===
{{eq fun|1=
template&lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = ranges::identity,
         IndirectUnaryInvocable&lt;ranges::projected&lt;I, Proj&gt;&gt; Fun&gt;
auto for_each(I first, S last, Fun f, Proj proj = Proj{}) 
    -&gt; ranges::tagged_pair&lt;tag::in(I), tag::fun(Fun)&gt;
{
    for (; first != last; ++first)
        ranges::invoke(f, ranges::invoke(proj, *first));
    return {std::move(first), std::move(f)};
}
}}

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc transform}}
{{dsc inc|cpp/language/dsc range-for}}
{{dsc inc|cpp/algorithm/dsc for_each}}
{{dsc inc|cpp/algorithm/dsc for_each_n}}
{{dsc end}}

{{langlinks|en|ja}}