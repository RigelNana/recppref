{{cpp/experimental/ranges/title|search}}
{{cpp/experimental/ranges/algorithm/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/algorithm}}
{{dcl|since=ranges|num=1|1=
template&lt; ForwardIterator I1, Sentinel&lt;I1&gt; S1,
          ForwardIterator I2, Sentinel&lt;I2&gt; S2, class Pred = ranges::equal_to&lt;&gt;,
          class Proj1 = ranges::identity, class Proj2 = ranges::identity &gt;
    requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
I1 search( I1 first1, S1 last1, I2 first2, S2 last2,
           Pred pred = Pred{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );
}}
{{dcl|since=ranges|num=2|1=
template&lt; ForwardRange R1, ForwardRange R2, class Pred = ranges::equal_to&lt;&gt;,
          class Proj1 = ranges::identity, class Proj2 = ranges::identity &gt;
    requires IndirectlyComparable&lt;ranges::iterator_t&lt;R1&gt;, ranges::iterator_t&lt;R2&gt;,
                                  Pred, Proj1, Proj2&gt;
ranges::safe_iterator_t&lt;R1&gt; search( R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = Pred{},
                                    Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );
}}
{{dcl end}}

@1@ 在范围 {{range|first1|last1}} 中搜索首次出现的元素序列 {{range|first2|last2}}。使用 {{c|pred}} 对分别以 {{c|proj2}} 和 {{c|proj1}} 投射后的元素进行比较。
@2@ 与 {{v|1}} 相同，但用 {{c|r1}} 为第一源范围并用 {{c|r2}} 为第二源范围，如同以 {{c|ranges::begin(r1)}} 为 {{c|first1}}，以 {{c|ranges::end(r1)}} 为 {{c|last1}}，以 {{c|ranges::begin(r2)}} 为 {{c|first2}}，并以 {{c|ranges::end(r2)}} 为 {{c|last2}}。

{{cpp/experimental/ranges/algorithm/tparams}}

===Parameters===
{{par begin}}
{{par|first1, last1|要检验的元素范围}}
{{par|r1|要检验的元素范围}}
{{par|first2, last2|要搜索的元素范围}}
{{par|r2|要搜索的元素范围}}
{{par|pred|运用于投射后元素的谓词}}
{{par|proj1|运用于第一范围中元素的投射}}
{{par|proj2|运用于第二范围中元素的投射}}
{{par end}}

===返回值===
指向范围 {{range|first1|last1}} 中首次出现的序列 {{range|first2|last2}} 的开头的迭代器。如果 {{range|first2|last2}} 为空，则返回 {{c|first1}}。如果未找到这种出现，则返回与 {{c|last1}} 比较相等的迭代器。

===复杂度===
最多 {{tt|S * N}} 次运用谓词和各投射，其中 {{c|S {{=}} last2 - first2}} 且 {{c|N {{=}} last1 - first1}}。

===可能的实现===
{{eq fun|1=
template&lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1,
         ForwardIterator I2, Sentinel&lt;I2&gt; S2, class Pred = ranges::equal_to&lt;&gt;,
         class Proj1 = ranges::identity, class Proj2 = ranges::identity&gt;
    requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
I1 search(I1 first1, S1 last1, I2 first2, S2 last2,
          Pred pred = Pred{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{})
{
    for (; ; ++first1)
    {
        I1 it = first1;
        for (I2 it2 = first2; ; (void)++it, (void)++it2)
        {
            if (it2 == last2)
                return first1;
            if (it == last1)
                return it;
            if (!ranges::invoke(pred, ranges::invoke(proj1, *it),
                                      ranges::invoke(proj2, *it2)))
                break;
        }
    }
}
}}

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc search}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc find_end}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc includes}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc equal}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc find}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc lexicographical_compare}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc mismatch}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc search_n}}
{{dsc end}}