{{cpp/experimental/ranges/title|equal}}
{{cpp/experimental/ranges/algorithm/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/algorithm}}
{{dcl|since=ranges|num=1|1=
template&lt; InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
          class Pred = ranges::equal_to&lt;&gt;, 
          class Proj1 = ranges::identity, class Proj2 = ranges::identity &gt;
    requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
bool equal( I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
            Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );
}}
{{dcl|since=ranges|num=2|1=
template&lt; InputRange R1, InputRange R2, class Pred = ranges::equal_to&lt;&gt;,
          class Proj1 = ranges::identity, class Proj2 = ranges::identity &gt;
    requires IndirectlyComparable&lt;ranges::iterator_t&lt;R1&gt;, ranges::iterator_t&lt;R2&gt;,
                                  Pred, Proj1, Proj2&gt;
bool equal( R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = Pred{},
            Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );
}}
{{dcl|since=ranges|num=3|notes={{mark deprecated}}|1=
template&lt; InputIterator I1, Sentinel&lt;I1&gt; S1, class I2,
          class Pred = ranges::equal_to&lt;&gt;, 
          class Proj1 = ranges::identity, class Proj2 = ranges::identity &gt;
    requires InputIterator&lt;std::decay_t&lt;I2&gt;&gt; &amp;&amp; !Range&lt;I2&gt; &amp;&amp;
             IndirectlyComparable&lt;I1, std::decay_t&lt;I2&gt;, Pred, Proj1, Proj2&gt;
bool equal( I1 first1, S1 last1, I2&amp;&amp; first2_, Pred pred = Pred{},
            Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );

}}
{{dcl|since=ranges|num=4|notes={{mark deprecated}}|1=
template&lt; InputRange R1, class I2, class Pred = ranges::equal_to&lt;&gt;,
          class Proj1 = ranges::identity, class Proj2 = ranges::identity &gt;
    requires InputIterator&lt;std::decay_t&lt;I2&gt;&gt; &amp;&amp; !Range&lt;I2&gt; &amp;&amp;
             IndirectlyComparable&lt;ranges::iterator_t&lt;R1&gt;, std::decay_t&lt;I2&gt;, Pred, Proj1, Proj2&gt;
bool equal( R1&amp;&amp; r1, I2&amp;&amp; first2_, Pred pred = Pred{}, 
            Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );
}}
{{dcl end}}

@1@ 若范围 {{range|first1|last1}} 等于范围 {{range|first2|last2}} 则返回 {{c|true}}，否则返回 {{c|false}}。

@2@ 同 {{v|1}}，但以 {{c|r1}} 为第一源范围并以 {{c|r2}} 为第二源范围，如同以 {{c|ranges::begin(r1)}} 为 {{c|first1}}，以 {{c|ranges::end(r1)}} 为 {{c|last1}}，以 {{c|ranges::begin(r2)}} 为 {{c|first2}} 并以 {{c|ranges::end(r2)}} 为 {{c|last2}}。

@3@ 同 {{v|1}}，但在穷尽第一范围或检测到首个不匹配时认为第二范围结束。等价于 {{c|return last1 {{==}} ranges::mismatch(first1, last1, std::forward&lt;I2&gt;(first2_), comp, proj1, proj2).in1();}}。

@4@ 同 {{v|3}}，但以 {{c|r1}} 为第一源范围，如同以 {{c|ranges::begin(r1)}} 为 {{c|first1}} 并以 {{c|ranges::end(r1)}} 为 {{c|last1}}。

若两个范围有相同数量的元素，且对于范围 {{range|first1|last1}} 中的每个迭代器 {{tt|i}}，{{c|ranges::invoke(pred, ranges::invoke(proj1, *i), ranges::invoke(proj2, *(first2 + (i - first1))))}} 为 {{tt|true}}，则认为两个范围相等。

{{cpp/experimental/ranges/algorithm/tparams}}

===参数===
{{par begin}}
{{par | first1, last1 |第一元素范围}}
{{par | r1 |第一元素范围}}
{{par | first2, last2 |第二元素范围}}
{{par | r2 |第二元素范围}}
{{par | first2_ |第二元素范围的起始}}
{{par | pred |应用到投影后元素的谓词}}
{{par | proj1 |应用到第一范围中元素的投影}}
{{par | proj2 |应用到第二范围中元素的投影}}
{{par end}}

===返回值===
若两个范围相等则为 {{c|true}}，否则返回 {{c|false}}。

===注解===
不应该用 {{tt|ranges::equal}} 比较来自 {{lc|std::unordered_set}}、{{lc|std::unordered_multiset}}、{{lc|std::unordered_map}} 或 {{lc|std::unordered_multimap}} 的迭代器所组成的范围，因为即使两个容器存储相同的元素，在容器中存储元素的顺序也可能不同。

比较整个容器是否相等时，通常更偏好使用对应容器的 {{tt|operator{{==}}}}。

===复杂度===
@1,2@ 若满足 {{c|SizedSentinel&lt;S1, I1&gt; &amp;&amp; SizedSentinel&lt;S2, I2&gt;}} 且 {{c|last1 - first1 !{{=}} last2 - first2}}，则不应用谓词和投射。否则至多应用 min({{c|last1}} - {{c|first1}}, {{c|last2}} - {{c|first2}}) 次谓词及各一次投射。
@3,4@ 至多应用 {{c|last1}} - {{c|first1}} 次谓词及各一次投射。

===可能的实现===
{{eq fun|
1=
namespace detail 
{
    template&lt;InputIterator I1, SizedSentinel&lt;I1&gt; S1,
             InputIterator I2, SizedSentinel&lt;I1&gt; S2&gt;
    bool check_size(I1&amp; first1, S1&amp; last1, I2&amp; first2, S2&amp; last2)
    {
        return last1 - first1 != last2 - first2;
    }

    template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I1&gt; S2&gt;
    bool check_size(I1&amp; first1, S1&amp; last1, I2&amp; first2, S2&amp; last2)
    {
        return false;
    }
}

template&lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
         class Pred = ranges::equal_to&lt;&gt;, 
         class Proj1 = ranges::identity, class Proj2 = ranges::identity&gt;
    requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
bool equal(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
           Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{}) 
{
    if (detail::check_size(first1, last1, first2, last2))
        return false;
    for (; first1 != last1 &amp;&amp; first2 != last2; (void) ++first1, (void)++first2)
        if (!ranges::invoke(pred, ranges::invoke(proj1, *first1), 
                                  ranges::invoke(proj2, *first2)))
            return false;
    return first1 == last1 &amp;&amp; first2 == last2;
}
}}

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc equal}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc find}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc lexicographical_compare}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc mismatch}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc search}}
{{dsc end}}

{{langlinks|en|ja}}