{{cpp/experimental/fs/title|create_hard_link}}
{{cpp/experimental/fs/navbar}}
{{dcl begin}}
{{dcl header|experimental/filesystem}}
{{dcl|since=fs_ts|1=
void create_hard_link( const path&amp; target, const path&amp; link );
void create_hard_link( const path&amp; target, const path&amp; link, error_code&amp; ec );
}}
{{dcl end}}

创建硬链接 {{c|link}} 将其目标设为 {{c|target}}，如同调用 POSIX [https://pubs.opengroup.org/onlinepubs/9699919799/functions/link.html link()]：路径名 {{c|target}} 必须已存在。

一旦创建，{{c|link}} 和 {{c|target}} 就是两个代表相同文件的逻辑名称（它们{{ltt|cpp/experimental/fs/equivalent|等价}}）。即便原名称 {{c|target}} 被删除，此文件仍继续存在并可通过 {{c|link}} 访问之。

===参数===
{{par begin}}
{{par|target|要连接到的文件或目录的路径}}
{{par|link|新硬链接的路径}}
{{par|ec|用于无抛出重载中报告错误的输出形参}}
{{par end}}

===返回值===
（无）

===异常===
{{cpp/experimental/fs/error_handling|target|link}}

===注解===
有些操作系统完全不支持硬链接，或仅对常规文件支持硬链接。

有些文件系统不支持硬链接且与操作系统无关：存储卡和闪存盘使用的 FAT 文件系统是一个例子。

有些文件系统限制每个文件的连接数量。

对目录的硬链接通常限制为超级用户使用。

硬链接通常无法跨越文件系统边界。

特殊路径名“点”({{c|"."}}) 是到父目录的硬链接。特殊路径名“点点” {{c|".."}} 是到其父目录的父目录的硬链接。

===示例===
{{example
|code=
#include &lt;experimental/filesystem&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
namespace fs = std::experimental::filesystem;

int main()
{
    fs::create_directories("sandbox/subdir");
    std::ofstream("sandbox/a").put('a'); // create regular file
    fs::create_hard_link("sandbox/a", "sandbox/b");
    fs::remove("sandbox/a");
    // 通过存活的硬链接读取原文件
    char c = std::ifstream("sandbox/b").get();
    std::cout &lt;&lt; c &lt;&lt; '\n';
    fs::remove_all("sandbox");
}
|output=
a
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/experimental/fs/dsc create_symlink}}
{{dsc inc|cpp/experimental/fs/dsc hard_link_count}}
{{dsc end}}