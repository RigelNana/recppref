{{cpp/experimental/fs/title|recursive_directory_iterator}}
{{cpp/experimental/fs/recursive_directory_iterator/navbar}}
{{fmbox|class=noprint|style=font-size: 0.8em|text='''已并入 ISO C++''' 此页面所描述的功能已于 2016 年 3 月并入 ISO C++ 标准主线；参见 [[cpp/filesystem/recursive_directory_iterator|std::filesystem::recursive_directory_iterator]] {{mark since c++17}}}}
{{dcl begin}}
{{dcl header|experimental/filesystem}}
{{dcl|since=fs_ts|1=
class recursive_directory_iterator;
}}
{{dcl end}}

{{tt|recursive_directory_iterator}} 是一种{{named req|InputIterator}}，它在某个目录的 {{ltt|cpp/experimental/fs/directory_entry|directory_entry}} 元素上，以及递归地在其所有子目录的目录项上迭代。未指定迭代顺序，但每个目录项仅被访问一次。

默认情况，并不跟随符号链接，但可以在构造时通过指定目录选项 {{ltt|cpp/experimental/fs/directory_options|follow_directory_symlink}} 来启用之。

特殊路径名 {{spar|点}} 和 {{spar|点点}} 被跳过。

如果 {{tt|recursive_directory_iterator}} 推进到越过顶层目录的最末目录项，则它变为等于默认构造的迭代器，亦称为尾迭代器。两个尾迭代器总是相等，解引用或增加尾迭代器为未定义行为。

如果在已经创建递归目录迭代器之后有文件或目录被删除或加入目录树，则未指明是否能通过该迭代器观察到此变化。

如果目录结构中包含循环，则可能无法抵达尾迭代器。

===成员类型===
{{dsc begin}}
{{dsc hitem|成员类型|定义}}
{{dsc|{{tt|value_type}}|{{tt|filesystem::directory_entry}}}}
{{dsc|{{tt|difference_type}}|{{tt|std::ptrdiff_t}}}}
{{dsc|{{tt|pointer}}|{{tt|const filesystem::directory_entry*}}}}
{{dsc|{{tt|reference}}|{{tt|const filesystem::directory_entry&amp;}}}}
{{dsc|{{tt|iterator_category}}|{{tt|std::input_iterator_tag}}}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/experimental/fs/recursive_directory_iterator/dsc constructor}}
{{dsc inc|cpp/experimental/fs/recursive_directory_iterator/dsc destructor}}

{{dsc h2|观察器}}
{{dsc inc|cpp/experimental/fs/recursive_directory_iterator/dsc operator*}}
{{dsc inc|cpp/experimental/fs/recursive_directory_iterator/dsc options}}
{{dsc inc|cpp/experimental/fs/recursive_directory_iterator/dsc depth}}
{{dsc inc|cpp/experimental/fs/recursive_directory_iterator/dsc recursion_pending}}

{{dsc h2|修改器}}
{{dsc inc|cpp/experimental/fs/recursive_directory_iterator/dsc operator{{=}}}}
{{dsc inc|cpp/experimental/fs/recursive_directory_iterator/dsc increment}}
{{dsc inc|cpp/experimental/fs/recursive_directory_iterator/dsc pop}}
{{dsc inc|cpp/experimental/fs/recursive_directory_iterator/dsc disable_recursion_pending}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/experimental/fs/recursive_directory_iterator/dsc begin}}
{{dsc end}}

此外，还提供了 {{tt|operator{{==}}}} 和 {{tt|operator!{{=}}}}，既为成员也为非成员，此为 {{named req|InputIterator}} 的规定。

===注解===
{{tt|recursive_directory_iterator}} 通常持有指向实现定义对象的引用计数''指针''（以满足 {{named req|InputIterator}} 的浅复制语义），该对象持有：
* 一个存储非递归的 {{ltt|cpp/experimental/fs/directory_iterator|directory_iterator}} 的容器（如 {{lc|std::vector}}），构成递归栈。
* 递归深度计数器（可由 {{ltt|cpp/experimental/fs/recursive_directory_iterator/depth|depth()}} 访问）。
* 构造时所用的目录选项（可由 {{ltt|cpp/experimental/fs/recursive_directory_iterator/options|options()}} 访问）。
* 待定递归标记（可由 {{ltt|cpp/experimental/fs/recursive_directory_iterator/recursion_pending|recursion_pending()}} 访问，可能与目录选项合并以节省空间）。

===示例===
{{example|code=
#include &lt;experimental/filesystem&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
namespace fs = std::experimental::filesystem;

int main()
{
    fs::create_directories("sandbox/a/b");
    std::ofstream("sandbox/file1.txt");
    fs::create_symlink("a", "sandbox/syma");
    for (const fs::directory_entry&amp; entry : fs::recursive_directory_iterator("sandbox"))
        std::cout &lt;&lt; entry &lt;&lt; '\n';
    fs::remove_all("sandbox");
}
|p=true
|output=
"sandbox/a"
"sandbox/a/b"
"sandbox/file1.txt"
"sandbox/syma"
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/experimental/fs/dsc directory_iterator}}
{{dsc inc|cpp/experimental/fs/dsc directory_entry}}
{{dsc inc|cpp/experimental/fs/dsc directory_options}}
{{dsc end}}