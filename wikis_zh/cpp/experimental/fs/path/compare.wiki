{{cpp/experimental/fs/path/title|compare}}
{{cpp/experimental/fs/path/navbar}}
{{dcl begin}}
{{dcl|num=1|since=fs_ts|1=
int compare( const path&amp; p ) const noexcept;
}}
{{dcl|num=2|since=fs_ts|1=
int compare( const string_type&amp; str ) const;
}}
{{dcl|num=3|since=fs_ts|1=
int compare( const value_type* s ) const;
}}
{{dcl end}}

比较路径和另一路径的词法表示。

@1@ 若路径的原生表示（{{rlp|native}}()）按字典序分别小于、等于或大于 {{c|p}} 的原生表示（{{c|p.native()}}），则分别返回小于、等于或大于 {{math|0}} 的值。比较逐元素进行，如同通过从 {{rlp|begin}}() 到 {{rlp|begin|end}}() 迭代两个路径来进行。
@2@ 等价于 {{c|compare(path(str))}}。
@3@ 等价于 {{c|compare(path(s))}}。

===参数===
{{par begin}}
{{par|p|要比较的路径}}
{{par|str|表示要比较的路径的字符串}}
{{par|s|表示要比较的路径的空终止字符串}}
{{par end}}

===返回值===
如果路径按字典序小于给定路径，则为小于 {{math|0}} 的值。

如果路径按字典序等于给定路径，则为等于 {{math|0}} 的值。

如果路径按字典序大于给定路径，则为大于 {{math|0}} 的值。

===异常===
@2,3@ {{cpp/impldef exception item}}

===注解===
对于双路比较，[[cpp/experimental/fs/path/operator_cmp|二元运算符]]可能更为合适。

===示例===
{{example
|code=
#include &lt;experimental/filesystem&gt;
#include &lt;iostream&gt;
namespace fs = std::experimental::filesystem;

void demo(int rc, fs::path p1, fs::path p2)
{
    if (rc &lt; 0)
        std::cout &lt;&lt; p1 &lt;&lt; " &lt; " &lt;&lt; p2 &lt;&lt; '\n';
    else if (rc &gt; 0)
        std::cout &lt;&lt; p1 &lt;&lt; " &gt; " &lt;&lt; p2 &lt;&lt; '\n';
    else if (rc == 0)
        std::cout &lt;&lt; p1 &lt;&lt; " = " &lt;&lt; p2 &lt;&lt; '\n';
}

int main()
{
    fs::path p1 = "/a/b/"; // as if "a/b/." for lexicographical iteration
    fs::path p2 = "/a/b/#";
    demo(p1.compare(p2), p1, p2);
    demo(p1.compare("a/b/_"), p1, "a/b/_");
}
|output=
"/a/b/" &gt; "/a/b/#"
"/a/b/" &lt; "a/b/_"
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/experimental/fs/path/dsc operator_cmp}}
{{dsc end}}