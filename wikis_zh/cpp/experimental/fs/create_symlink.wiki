{{cpp/experimental/fs/title|create_symlink|create_directory_symlink}}
{{cpp/experimental/fs/navbar}}
{{dcl begin}}
{{dcl header|experimental/filesystem}}
{{dcl|num=1|since=fs_ts|1=
void create_symlink( const path&amp; target, const path&amp; link );
void create_symlink( const path&amp; target, const path&amp; link, error_code&amp; ec );
}}
{{dcl|num=2|since=fs_ts|1=
void create_directory_symlink( const path&amp; target, const path&amp; link );
void create_directory_symlink( const path&amp; target, const path&amp; link, error_code&amp; ec );
}}
{{dcl end}}

创建符号链接 {{c|link}} 并将其目标设为 {{c|target}}，如同调用 POSIX [https://pubs.opengroup.org/onlinepubs/9699919799/functions/symlink.html symlink()]：路径名 {{c|target}} 可以无效或尚不存在。

有些操作系统要求符号链接创建时标明其是到目录的链接。可移植代码应当使用 {{v|2}} 来创建目录符号链接而非 {{v|1}}，即便这在 POSIX 系统上没有区别。

===参数===
{{par begin}}
{{par|target|符号链接所指向的路径，不必存在}}
{{par|link|新符号链接的路径}}
{{par|ec|用于无抛出重载中报告错误的输出形参}}
{{par end}}

===返回值===
（无）

===异常===
{{cpp/experimental/fs/error_handling|target|link}}

===注解===
有些操作系统完全不支持符号链接或仅对常规文件支持符号链接。

有些文件系统不支持符号链接且与操作系统无关，例如用于一些存储卡和闪存盘的 FAT 文件系统。

与硬链接类似，符号链接运行一个文件具有多个逻辑名字。硬链接的存在保证文件存在，即便原名称已被移除也是如此。符号链接则不提供这种保证；实际上由 {{c|target}} 实参所指名的文件在创建链接时不必存在。符号链接可以跨越文件系统边界。

===示例===
{{example
|code=
#include &lt;experimental/filesystem&gt;
#include &lt;iostream&gt;
namespace fs = std::experimental::filesystem;

int main()
{
    fs::create_directories("sandbox/subdir");
    fs::create_symlink("target", "sandbox/sym1");
    fs::create_directory_symlink("subdir", "sandbox/sym2");

    for (auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)
        if (is_symlink(it-&gt;symlink_status()))
            std::cout &lt;&lt; *it &lt;&lt; "-&gt;" &lt;&lt; read_symlink(*it) &lt;&lt; '\n';

    fs::remove_all("sandbox");
}
|p=true
|output=
"sandbox/sym1"-&gt;"target"
"sandbox/sym2"-&gt;"subdir"
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/experimental/fs/dsc status}}
{{dsc inc|cpp/experimental/fs/dsc read_symlink}}
{{dsc inc|cpp/experimental/fs/dsc create_hard_link}}
{{dsc end}}