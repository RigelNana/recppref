{{cpp/experimental/fs/title|equivalent}}
{{cpp/experimental/fs/navbar}}
{{dcl begin}}
{{dcl header|experimental/filesystem}}
{{dcl|num=1|since=fs_ts|1=
bool equivalent( const path&amp; p1, const path&amp; p2 );
bool equivalent( const path&amp; p1, const path&amp; p2, error_code&amp; ec );
}}
{{dcl end}}

检查路径 {{c|p1}} 和 {{c|p2}} 是否指代同一个文件或目录，并由如同以 {{ltt|cpp/experimental/fs/status|status}} 确定具有相同的文件状态（跟随符号链接）。

若 {{c|p1}} 或 {{c|p2}} 不存在或它们的文件类型并非文件、目录或符号链接（由 {{ltt|cpp/experimental/fs/is_other|is_other}} 确定），则报告错误。

无抛出重载当发生错误时返回 {{c|false}}。

===参数===
{{par begin}}
{{par|p1, p2|要检查等价性的路径}}
{{par|ec|用于无抛出重载中报告错误的输出形参}}
{{par end}}

===返回值===
如果 {{c|p1}} 和 {{c|p2}} 指代相同文件或目录且它们的文件状态相同，则为 {{c|true}}，否则为 {{c|false}}。

===异常===
{{cpp/experimental/fs/error_handling|p1|p2}}

===注解===
对于两个路径，如果如同以 POSIX [https://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html stat] 获得的 POSIX [https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html stat 结构体]的 {{tt|st_dev}} 和 {{tt|st_ino}} 相等（意为两个文件位于相同设备并处于相同位置），则认为它们解析为相同的文件系统实体。

特别是，同一个文件或目录的所有硬链接均等价，且同一文件系统上的符号链接及其目标等价。

===示例===
{{example
|code=
#include &lt;cstdint&gt;
#include &lt;experimental/filesystem&gt;
#include &lt;iostream&gt;
namespace fs = std::experimental::filesystem;

int main()
{
    // 硬链接等价
    fs::path p1 = ".";
    fs::path p2 = fs::current_path();
    if (fs::equivalent(p1, p2))
        std::cout &lt;&lt; p1 &lt;&lt; " 等价于 " &lt;&lt; p2 &lt;&lt; '\n';

    // 符号链接等价
    fs::path p3 = "/lib/libc.so.6";
    fs::path p4 = p3.parent_path() / fs::read_symlink(p3);
    if (fs::equivalent(p3, p4))
        std::cout &lt;&lt; p3 &lt;&lt; " 等价于 " &lt;&lt; p4 &lt;&lt; '\n';
}
|p=true
|output=
"." 等价于 "/var/tmp/test"
"/lib/libc.so.6" 等价于 "/lib/libc-2.12.so"
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/experimental/fs/dsc status}}
{{dsc end}}