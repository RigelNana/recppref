{{cpp/experimental/title|not_fn}}
{{cpp/experimental/lib_extensions_2/navbar}}
{{fmbox | class=noprint | style=font-size: 0.8em | text='''并入 ISO C++''' 此页面上描述的功能自 2016 年 3 月起已并入主线 ISO C++ 标准；见 {{ltt|cpp/utility/functional/not_fn|std::not_fn}} {{mark since c++17}} }}
{{dcl begin}}
{{dcl header | experimental/functional }}
{{dcl | since=libfund_ts_2 |
template&lt; class F&gt;
/* 未指明 */ not_fn( F&amp;&amp; f );
}}
{{dcl end}}

创建转发调用包装器，它返回其所保有的可调用对象的逻辑补。

===参数===
{{par begin}}
{{par | f | 对象，从该对象构造包装器所保有的{{named req|Callable|可调用}}对象}}
{{par end}}

===返回值===
令 {{tt|FD}} 为 {{c|std::decay_t&lt;F&gt;}}，{{tt|fd}} 为从 {{c|std::forward&lt;F&gt;(f)}} 构造的 {{tt|FD}} 类型的左值。

则 {{tt|not_fn}} 返回未指定类型的转发调用包装器，使得 {{c|fn(a1, a2, ..., aN)}} 等价于 {{c|!INVOKE(fd, a1, ..., aN)}}，其中 {{tt|INVOKE}} 是 {{named req|Callable}} 中描述的操作。

返回的调用包装器始终为{{named req|MoveConstructible}}，且若 FD 为{{named req|CopyConstructible}}则它亦为{{named req|CopyConstructible}}。

===说明===
若 {{tt|fd}} 非{{named req|Callable}}，或 {{c|std::is_constructible&lt;FD, F&gt;::value}} 非 {{tt|true}}，则行为未定义。

===异常===
不抛异常，除非 {{tt|fd}} 的构造抛出。

===可能的实现===
{{eq fun|1=
namespace detail {
    template&lt;class F&gt;
    struct not_fn_t {
        F f;
        template&lt;class... Args&gt;
        auto operator()(Args&amp;&amp;... args)
            noexcept(noexcept(!std::invoke(f, std::forward&lt;Args&gt;(args)...)))
            -&gt; decltype(!std::invoke(f, std::forward&lt;Args&gt;(args)...)) {
            return !std::invoke(f, std::forward&lt;Args&gt;(args)...);
        }

        // cv-qualified overload for QoI
        template&lt;class... Args&gt;
        auto operator()(Args&amp;&amp;... args) const
            noexcept(noexcept(!std::invoke(f, std::forward&lt;Args&gt;(args)...)))
            -&gt; decltype(!std::invoke(f, std::forward&lt;Args&gt;(args)...)) {
            return !std::invoke(f, std::forward&lt;Args&gt;(args)...);
        }

        template&lt;class... Args&gt;
        auto operator()(Args&amp;&amp;... args) volatile
            noexcept(noexcept(!std::invoke(f, std::forward&lt;Args&gt;(args)...)))
            -&gt; decltype(!std::invoke(f, std::forward&lt;Args&gt;(args)...)) {
            return !std::invoke(f, std::forward&lt;Args&gt;(args)...);
        }
        template&lt;class... Args&gt;
        auto operator()(Args&amp;&amp;... args) const volatile
            noexcept(noexcept(!std::invoke(f, std::forward&lt;Args&gt;(args)...)))
            -&gt; decltype(!std::invoke(f, std::forward&lt;Args&gt;(args)...)) {
            return !std::invoke(f, std::forward&lt;Args&gt;(args)...);
        }
    };
}

template&lt;class F&gt;
detail::not_fn_t&lt;std::decay_t&lt;F&gt;&gt; not_fn(F&amp;&amp; f) { return { std::forward&lt;F&gt;(f) }; }
}}

===注解===
{{tt|not_fn}} 的用意是替换 C++03 时代的取反器 {{lc|std::not1}} 和 {{lc|std::not2}}。

===参阅===
{{dsc begin}}
{{dsc inc | cpp/utility/functional/dsc not_fn}}
{{dsc end}}

{{langlinks|en}}