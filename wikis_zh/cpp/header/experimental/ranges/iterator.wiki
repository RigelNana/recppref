{{cpp/header/experimental/title|experimental/ranges/iterator}}
{{cpp/header/experimental/navbar}}

此头文件是[[cpp/experimental/ranges|范围]]库的一部分。

=== 迭代器相关概念 ===
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc end}}

==== 迭代器概念 ====
{{dsc begin}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc Readable}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc Writable}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc WeaklyIncrementable}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc Incrementable}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc Iterator}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc Sentinel}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc SizedSentinel}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc InputIterator}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc OutputIterator}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc ForwardIterator}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc BidirectionalIterator}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc RandomAccessIterator}}
{{dsc end}}

==== 间接可调用概念 ====
{{dsc begin}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc IndirectUnaryInvocable}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc IndirectUnaryPredicate}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc IndirectRelation}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc IndirectStrictWeakOrder}}
{{dsc end}}

==== 常用算法要求 ====
{{dsc begin}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc IndirectlyMovable}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc IndirectlyMovableStorable}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc IndirectlyCopyable}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc IndirectlyCopyableStorable}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc IndirectlySwappable}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc IndirectlyComparable}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc Permutable}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc Mergeable}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc Sortable}}
{{dsc end}}

==== 概念工具 ====
{{dsc begin}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc indirect_result_of}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc projected}}
{{dsc end}}

=== 迭代器原语 ===
==== 迭代器工具 ====
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc iter_move}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc iter_swap}}
{{dsc end}}

==== 迭代器特征 ====
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc difference_type}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc value_type}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc iterator_category}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc iterator_traits}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc reference_t}}
{{dsc end}}

==== 迭代器类别标签 ====
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc iterator_tags}}
{{dsc end}}

==== {{lc | std::iterator_traits}} 的特化 ====
{{dsc begin}}
{{dsc namespace | std}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc std_iter_traits}}
{{dsc end}}

==== 迭代器操作 ====
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc advance}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc distance}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc next}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc prev}}
{{dsc end}}

=== 迭代器适配器 ===
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc reverse_iterator}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc back_insert_iterator}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc front_insert_iterator}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc insert_iterator}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc move_iterator}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc move_sentinel}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc common_iterator}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc counted_iterator}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc default_sentinel}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc dangling}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc safe_iterator_t}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc unreachable}}
{{dsc end}}

=== 流迭代器 ===
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc istream_iterator}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc ostream_iterator}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc istreambuf_iterator}}
{{dsc inc | cpp/experimental/ranges/iterator/dsc ostreambuf_iterator}}
{{dsc end}}

=== 概要 ===
{{source|1=

namespace std { namespace experimental { namespace ranges { inline namespace v1 {

template &lt;class T&gt; concept bool /* dereferenceable */ // 仅用于阐释
  = requires(T&amp; t) { {*t} -&gt; auto&amp;&amp;; };

namespace {
  constexpr /* 未指明 */ iter_move = /* 未指明 */;
  constexpr /* 未指明 */ iter_swap = /* 未指明 */;
}

template &lt;class&gt; struct difference_type;
template &lt;class T&gt; using difference_type_t
  = typename difference_type&lt;T&gt;::type;

template &lt;class&gt; struct value_type;
template &lt;class T&gt; using value_type_t
  = typename value_type&lt;T&gt;::type;

template &lt;class&gt; struct iterator_category;
template &lt;class T&gt; using iterator_category_t
  = typename iterator_category&lt;T&gt;::type;

template &lt;/* dereferenceable */ T&gt; using reference_t
  = decltype(*declval&lt;T&amp;&gt;());

template &lt;/* dereferenceable */ T&gt;
    requires /* 见定义 */ using rvalue_reference_t
  = decltype(ranges::iter_move(declval&lt;T&amp;&gt;()));

template &lt;class In&gt;
concept bool Readable = /* 见定义 */;

template &lt;class Out, class T&gt;
concept bool Writable = /* 见定义 */;

template &lt;class I&gt;
concept bool WeaklyIncrementable = /* 见定义 */;

template &lt;class I&gt;
concept bool Incrementable = /* 见定义 */;

template &lt;class I&gt;
concept bool Iterator = /* 见定义 */;

template &lt;class S, class I&gt;
concept bool Sentinel = /* 见定义 */;

template &lt;class S, class I&gt;
  constexpr bool disable_sized_sentinel = false;

template &lt;class S, class I&gt;
concept bool SizedSentinel = /* 见定义 */;

template &lt;class I&gt;
concept bool InputIterator = /* 见定义 */;

template &lt;class I&gt;
concept bool OutputIterator = /* 见定义 */;

template &lt;class I&gt;
concept bool ForwardIterator = /* 见定义 */;

template &lt;class I&gt;
concept bool BidirectionalIterator = /* 见定义 */;

template &lt;class I&gt;
concept bool RandomAccessIterator = /* 见定义 */;

template &lt;class F, class I&gt;
concept bool IndirectUnaryInvocable = /* 见定义 */;

template &lt;class F, class I&gt;
concept bool IndirectRegularUnaryInvocable = /* 见定义 */;

template &lt;class F, class I&gt;
concept bool IndirectUnaryPredicate = /* 见定义 */;

template &lt;class F, class I1, class I2 = I1&gt;
concept bool IndirectRelation = /* 见定义 */;

template &lt;class F, class I1, class I2 = I1&gt;
concept bool IndirectStrictWeakOrder = /* 见定义 */;

template &lt;class&gt; struct indirect_result_of;

template &lt;class F, class... Is&gt;
  requires Invocable&lt;F, reference_t&lt;Is&gt;...&gt;
struct indirect_result_of&lt;F(Is...)&gt;;

template &lt;class F&gt;
using indirect_result_of_t
  = typename indirect_result_of&lt;F&gt;::type;

template &lt;Readable I, IndirectRegularUnaryInvocable&lt;I&gt; Proj&gt;
struct projected;

template &lt;WeaklyIncrementable I, class Proj&gt;
struct difference_type&lt;projected&lt;I, Proj&gt;&gt;;

template &lt;class In, class Out&gt;
concept bool IndirectlyMovable = /* 见定义 */;

template &lt;class In, class Out&gt;
concept bool IndirectlyMovableStorable = /* 见定义 */;

template &lt;class In, class Out&gt;
concept bool IndirectlyCopyable = /* 见定义 */;

template &lt;class In, class Out&gt;
concept bool IndirectlyCopyableStorable = /* 见定义 */;

template &lt;class I1, class I2 = I1&gt;
concept bool IndirectlySwappable = /* 见定义 */;

template &lt;class I1, class I2, class R = equal_to&lt;&gt;, class P1 = identity,
    class P2 = identity&gt;
concept bool IndirectlyComparable = /* 见定义 */;

template &lt;class I&gt;
concept bool Permutable = /* 见定义 */;

template &lt;class I1, class I2, class Out,
    class R = less&lt;&gt;, class P1 = identity, class P2 = identity&gt;
concept bool Mergeable = /* 见定义 */;

template &lt;class I, class R = less&lt;&gt;, class P = identity&gt;
concept bool Sortable = /* 见定义 */;

template &lt;class Iterator&gt; using iterator_traits = /* 见定义 */;

template &lt;Readable T&gt; using iter_common_reference_t
  = common_reference_t&lt;reference_t&lt;T&gt;, value_type_t&lt;T&gt;&amp;&gt;;

struct output_iterator_tag { };
struct input_iterator_tag { };
struct forward_iterator_tag : input_iterator_tag { };
struct bidirectional_iterator_tag : forward_iterator_tag { };
struct random_access_iterator_tag : bidirectional_iterator_tag { };

namespace {
  constexpr /* 未指明 */ advance = /* 未指明 */;
  constexpr /* 未指明 */ distance = /* 未指明 */;
  constexpr /* 未指明 */ next = /* 未指明 */;
  constexpr /* 未指明 */ prev = /* 未指明 */;
}

template &lt;BidirectionalIterator I&gt; class reverse_iterator;

template &lt;class I1, class I2&gt;
    requires EqualityComparableWith&lt;I1, I2&gt;
  constexpr bool operator==(
    const reverse_iterator&lt;I1&gt;&amp; x,
    const reverse_iterator&lt;I2&gt;&amp; y);
template &lt;class I1, class I2&gt;
    requires EqualityComparableWith&lt;I1, I2&gt;
  constexpr bool operator!=(
    const reverse_iterator&lt;I1&gt;&amp; x,
    const reverse_iterator&lt;I2&gt;&amp; y);
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrderedWith&lt;I1, I2&gt;
  constexpr bool operator&lt;(
    const reverse_iterator&lt;I1&gt;&amp; x,
    const reverse_iterator&lt;I2&gt;&amp; y);
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrderedWith&lt;I1, I2&gt;
  constexpr bool operator&gt;(
    const reverse_iterator&lt;I1&gt;&amp; x,
    const reverse_iterator&lt;I2&gt;&amp; y);
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrderedWith&lt;I1, I2&gt;
  constexpr bool operator&gt;=(
    const reverse_iterator&lt;I1&gt;&amp; x,
    const reverse_iterator&lt;I2&gt;&amp; y);
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrderedWith&lt;I1, I2&gt;
  constexpr bool operator&lt;=(
    const reverse_iterator&lt;I1&gt;&amp; x,
    const reverse_iterator&lt;I2&gt;&amp; y);

template &lt;class I1, class I2&gt;
    requires SizedSentinel&lt;I1, I2&gt;
  constexpr difference_type_t&lt;I2&gt; operator-(
    const reverse_iterator&lt;I1&gt;&amp; x,
    const reverse_iterator&lt;I2&gt;&amp; y);
template &lt;RandomAccessIterator I&gt;
  constexpr reverse_iterator&lt;I&gt; operator+(
    difference_type_t&lt;I&gt; n,
    const reverse_iterator&lt;I&gt;&amp; x);

template &lt;BidirectionalIterator I&gt;
constexpr reverse_iterator&lt;I&gt; make_reverse_iterator(I i);

template &lt;class Container&gt; class back_insert_iterator;
template &lt;class Container&gt;
  back_insert_iterator&lt;Container&gt; back_inserter(Container&amp; x);

template &lt;class Container&gt; class front_insert_iterator;
template &lt;class Container&gt;
  front_insert_iterator&lt;Container&gt; front_inserter(Container&amp; x);

template &lt;class Container&gt; class insert_iterator;
template &lt;class Container&gt;
  insert_iterator&lt;Container&gt; inserter(Container&amp; x, iterator_t&lt;Container&gt; i);

template &lt;InputIterator I&gt; class move_iterator;

template &lt;class I1, class I2&gt;
    requires EqualityComparableWith&lt;I1, I2&gt;
  constexpr bool operator==(
    const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
template &lt;class I1, class I2&gt;
    requires EqualityComparableWith&lt;I1, I2&gt;
  constexpr bool operator!=(
    const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrderedWith&lt;I1, I2&gt;
  constexpr bool operator&lt;(
    const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrderedWith&lt;I1, I2&gt;
  constexpr bool operator&lt;=(
    const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrderedWith&lt;I1, I2&gt;
  constexpr bool operator&gt;(
    const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);
template &lt;class I1, class I2&gt;
    requires StrictTotallyOrderedWith&lt;I1, I2&gt;
  constexpr bool operator&gt;=(
    const move_iterator&lt;I1&gt;&amp; x, const move_iterator&lt;I2&gt;&amp; y);

template &lt;class I1, class I2&gt;
    requires SizedSentinel&lt;I1, I2&gt;
  constexpr difference_type_t&lt;I2&gt; operator-(
    const move_iterator&lt;I1&gt;&amp; x,
    const move_iterator&lt;I2&gt;&amp; y);
template &lt;RandomAccessIterator I&gt;
  constexpr move_iterator&lt;I&gt; operator+(
    difference_type_t&lt;I&gt; n,
    const move_iterator&lt;I&gt;&amp; x);

template &lt;InputIterator I&gt;
  constexpr move_iterator&lt;I&gt; make_move_iterator(I i);

template &lt;Semiregular S&gt; class move_sentinel;

template &lt;class I, Sentinel&lt;I&gt; S&gt;
  constexpr bool operator==(
    const move_iterator&lt;I&gt;&amp; i, const move_sentinel&lt;S&gt;&amp; s);
template &lt;class I, Sentinel&lt;I&gt; S&gt;
  constexpr bool operator==(
    const move_sentinel&lt;S&gt;&amp; s, const move_iterator&lt;I&gt;&amp; i);
template &lt;class I, Sentinel&lt;I&gt; S&gt;
  constexpr bool operator!=(
    const move_iterator&lt;I&gt;&amp; i, const move_sentinel&lt;S&gt;&amp; s);
template &lt;class I, Sentinel&lt;I&gt; S&gt;
  constexpr bool operator!=(
    const move_sentinel&lt;S&gt;&amp; s, const move_iterator&lt;I&gt;&amp; i);

template &lt;class I, SizedSentinel&lt;I&gt; S&gt;
  constexpr difference_type_t&lt;I&gt; operator-(
    const move_sentinel&lt;S&gt;&amp; s, const move_iterator&lt;I&gt;&amp; i);
template &lt;class I, SizedSentinel&lt;I&gt; S&gt;
  constexpr difference_type_t&lt;I&gt; operator-(
    const move_iterator&lt;I&gt;&amp; i, const move_sentinel&lt;S&gt;&amp; s);

template &lt;Semiregular S&gt;
  constexpr move_sentinel&lt;S&gt; make_move_sentinel(S s);

template &lt;Iterator I, Sentinel&lt;I&gt; S&gt;
  requires !Same&lt;I, S&gt;
class common_iterator;

template &lt;Readable I, class S&gt;
struct value_type&lt;common_iterator&lt;I, S&gt;&gt;;

template &lt;InputIterator I, class S&gt;
struct iterator_category&lt;common_iterator&lt;I, S&gt;&gt;;

template &lt;ForwardIterator I, class S&gt;
struct iterator_category&lt;common_iterator&lt;I, S&gt;&gt;;

template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;
bool operator==(
  const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;
  requires EqualityComparableWith&lt;I1, I2&gt;
bool operator==(
  const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);
template &lt;class I1, class I2, Sentinel&lt;I2&gt; S1, Sentinel&lt;I1&gt; S2&gt;
bool operator!=(
  const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);

template &lt;class I2, SizedSentinel&lt;I2&gt; I1, SizedSentinel&lt;I2&gt; S1, SizedSentinel&lt;I1&gt; S2&gt;
difference_type_t&lt;I2&gt; operator-(
  const common_iterator&lt;I1, S1&gt;&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);

class default_sentinel;

template &lt;Iterator I&gt; class counted_iterator;

template &lt;class I1, class I2&gt;
    requires Common&lt;I1, I2&gt;
  constexpr bool operator==(
    const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
constexpr bool operator==(
  const counted_iterator&lt;auto&gt;&amp; x, default_sentinel);
constexpr bool operator==(
  default_sentinel, const counted_iterator&lt;auto&gt;&amp; x);
template &lt;class I1, class I2&gt;
    requires Common&lt;I1, I2&gt;
  constexpr bool operator!=(
    const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
constexpr bool operator!=(
  const counted_iterator&lt;auto&gt;&amp; x, default_sentinel y);
constexpr bool operator!=(
  default_sentinel x, const counted_iterator&lt;auto&gt;&amp; y);
template &lt;class I1, class I2&gt;
    requires Common&lt;I1, I2&gt;
  constexpr bool operator&lt;(
    const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
template &lt;class I1, class I2&gt;
    requires Common&lt;I1, I2&gt;
  constexpr bool operator&lt;=(
    const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
template &lt;class I1, class I2&gt;
    requires Common&lt;I1, I2&gt;
  constexpr bool operator&gt;(
    const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
template &lt;class I1, class I2&gt;
    requires Common&lt;I1, I2&gt;
  constexpr bool operator&gt;=(
    const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);

template &lt;class I1, class I2&gt;
    requires Common&lt;I1, I2&gt;
  constexpr difference_type_t&lt;I2&gt; operator-(
    const counted_iterator&lt;I1&gt;&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
template &lt;class I&gt;
  constexpr difference_type_t&lt;I&gt; operator-(
    const counted_iterator&lt;I&gt;&amp; x, default_sentinel y);
template &lt;class I&gt;
  constexpr difference_type_t&lt;I&gt; operator-(
    default_sentinel x, const counted_iterator&lt;I&gt;&amp; y);
template &lt;RandomAccessIterator I&gt;
  constexpr counted_iterator&lt;I&gt;
    operator+(difference_type_t&lt;I&gt; n, const counted_iterator&lt;I&gt;&amp; x);

template &lt;Iterator I&gt;
  constexpr counted_iterator&lt;I&gt; make_counted_iterator(I i, difference_type_t&lt;I&gt; n);

class unreachable;
template &lt;Iterator I&gt;
  constexpr bool operator==(const I&amp;, unreachable) noexcept;
template &lt;Iterator I&gt;
  constexpr bool operator==(unreachable, const I&amp;) noexcept;
template &lt;Iterator I&gt;
  constexpr bool operator!=(const I&amp;, unreachable) noexcept;
template &lt;Iterator I&gt;
  constexpr bool operator!=(unreachable, const I&amp;) noexcept;

template &lt;class T&gt; class dangling;

template &lt;class T, class charT = char, class traits = char_traits&lt;charT&gt;,
    class Distance = ptrdiff_t&gt;
  class istream_iterator;

template &lt;class T, class charT, class traits, class Distance&gt;
  bool operator==(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
    const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
template &lt;class T, class charT, class traits, class Distance&gt;
  bool operator==(default_sentinel x,
    const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
template &lt;class T, class charT, class traits, class Distance&gt;
  bool operator==(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
    default_sentinel y);
template &lt;class T, class charT, class traits, class Distance&gt;
  bool operator!=(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
    const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
template &lt;class T, class charT, class traits, class Distance&gt;
  bool operator!=(default_sentinel x,
    const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; y);
template &lt;class T, class charT, class traits, class Distance&gt;
  bool operator!=(const istream_iterator&lt;T, charT, traits, Distance&gt;&amp; x,
    default_sentinel y);

template &lt;class T, class charT = char, class traits = char_traits&lt;charT&gt;&gt;
  class ostream_iterator;

template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  class istreambuf_iterator;

template &lt;class charT, class traits&gt;
  bool operator==(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
    const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
template &lt;class charT, class traits&gt;
  bool operator==(default_sentinel a,
    const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
template &lt;class charT, class traits&gt;
  bool operator==(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
    default_sentinel b);
template &lt;class charT, class traits&gt;
  bool operator!=(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
    const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
template &lt;class charT, class traits&gt;
  bool operator!=(default_sentinel a,
    const istreambuf_iterator&lt;charT, traits&gt;&amp; b);
template &lt;class charT, class traits&gt;
  bool operator!=(const istreambuf_iterator&lt;charT, traits&gt;&amp; a,
    default_sentinel b);

template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  class ostreambuf_iterator;

{{))}}{{))}}

namespace std {
  template &lt;experimental::ranges::Iterator Out&gt;
    struct iterator_traits&lt;Out&gt;;
  template &lt;experimental::ranges::InputIterator In&gt;
    struct iterator_traits&lt;In&gt;;
  template &lt;experimental::ranges::InputIterator In&gt;
      requires experimental::ranges::Sentinel&lt;In, In&gt;
    struct iterator_traits;
}

}}

{{langlinks|en|ja}}