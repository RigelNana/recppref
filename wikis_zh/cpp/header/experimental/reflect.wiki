{{cpp/header/experimental/title|experimental/reflect}}
{{cpp/header/experimental/navbar}}

此头文件是[[cpp/experimental/reflect|反射 TS]] 的一部分。

{{dsc begin}}
{{dsc namespace | std::experimental::reflect}}
{{dsc namespace | inline=true | std::experimental::reflect::v1}}

{{dsc h1 | 概念}}
{{dsc concept | cpp/experimental/reflect/Object | notes={{mark since reflection ts}} | 指定类型为元对象类型}}
{{dsc concept | cpp/experimental/reflect/ObjectSequence | notes={{mark since reflection ts}} | 指定元对象类型为元对象序列类型}}
{{dsc concept | cpp/experimental/reflect/TemplateParameterScope | notes={{mark since reflection ts}} | 指定元对象类型反射模板形参作用域}}
{{dsc concept | cpp/experimental/reflect/Named | notes={{mark since reflection ts}} | 指定元对象类型反射具有关联（可能为空的）名字的实体}}
{{dsc concept | cpp/experimental/reflect/Alias | notes={{mark since reflection ts}} | 指定元对象类型反射类型别名、命名空间别名或由 using 声明引入的别名}}
{{dsc concept | cpp/experimental/reflect/RecordMember | notes={{mark since reflection ts}} | 指定元对象类型反射类的 {{spar|成员声明}}}}
{{dsc concept | cpp/experimental/reflect/Enumerator | notes={{mark since reflection ts}} | 指定元对象类型反射枚举项}}
{{dsc concept | cpp/experimental/reflect/Variable | notes={{mark since reflection ts}} | 指定元对象类型反射变量或数据成员}}
{{dsc concept | cpp/experimental/reflect/ScopeMember | notes={{mark since reflection ts}} | 指定元对象类型满足 {{tt|RecordMember}}、{{tt|Enumerator}} 或 {{tt|Variable}}，或反射全局命名空间以外的命名空间}}
{{dsc concept | cpp/experimental/reflect/Typed | notes={{mark since reflection ts}} | 指定元对象类型反射具有类型的实体}}
{{dsc concept | cpp/experimental/reflect/Namespace | notes={{mark since reflection ts}} | 指定元对象类型反射命名空间}}
{{dsc concept | cpp/experimental/reflect/GlobalScope | notes={{mark since reflection ts}} | 指定元对象类型反射全局命名空间}}
{{dsc concept | cpp/experimental/reflect/Class | notes={{mark since reflection ts}} | 指定元对象类型反射非联合体类类型}}
{{dsc concept | cpp/experimental/reflect/Enum | notes={{mark since reflection ts}} | 指定元对象类型反射枚举类型}}
{{dsc concept | cpp/experimental/reflect/Record | notes={{mark since reflection ts}} | 指定元对象类型反射类类型}}
{{dsc concept | cpp/experimental/reflect/Scope | notes={{mark since reflection ts}} | 指定元对象类型反射命名空间、类、枚举、闭包类型、模板实参作用域}}
{{dsc concept | cpp/experimental/reflect/Type | notes={{mark since reflection ts}} | 指定元对象类型反射一个类型}}
{{dsc concept | cpp/experimental/reflect/Constant | notes={{mark since reflection ts}} | 指定元对象类型反射枚举项或 constexpr 变量}}
{{dsc concept | cpp/experimental/reflect/Base | notes={{mark since reflection ts}} | 指定元对象类型反射从 {{tt|get_base_classes}} 获得的直接基类}}
{{dsc concept | cpp/experimental/reflect/FunctionParameter | notes={{mark since reflection ts}} | 指定元对象类型反射模板形参}}
{{dsc concept | cpp/experimental/reflect/Callable | notes={{mark since reflection ts}} | 指定元对象类型反射函数（包括构造函数与析构函数）}}
{{dsc concept | cpp/experimental/reflect/Expression | notes={{mark since reflection ts}} | 指定元对象类型反射表达式}}
{{dsc concept | cpp/experimental/reflect/ParenthesizedExpression | notes={{mark since reflection ts}} | 指定元对象类型反射有括号表达式}}
{{dsc concept | cpp/experimental/reflect/FunctionCallExpression | notes={{mark since reflection ts}} | 指定元对象类型反射 {{spar|函数调用表达式}}}}
{{dsc concept | cpp/experimental/reflect/FunctionalTypeConversion | notes={{mark since reflection ts}} | 指定元对象类型反射 {{spar|函数式类型转换表达式}}}}
{{dsc concept | cpp/experimental/reflect/Function | notes={{mark since reflection ts}} | 指定元对象类型反射函数（不含构造函数与析构函数）}}
{{dsc concept | cpp/experimental/reflect/MemberFunction | notes={{mark since reflection ts}} | 指定元对象类型反射成员函数I（不含构造函数与析构函数）}}
{{dsc concept | cpp/experimental/reflect/SpecialMemberFunction | notes={{mark since reflection ts}} | 指定元对象类型反射特殊成员函数}}
{{dsc concept | cpp/experimental/reflect/Constructor | notes={{mark since reflection ts}} | 指定元对象类型反射构造函数}}
{{dsc concept | cpp/experimental/reflect/Destructor | notes={{mark since reflection ts}} | 指定元对象类型反射析构函数}}
{{dsc concept | cpp/experimental/reflect/Operator | notes={{mark since reflection ts}} | 指定元对象类型反射运算符函数或转换函数}}
{{dsc concept | cpp/experimental/reflect/ConversionOperator | notes={{mark since reflection ts}} | 指定元对象类型反射转换函数}}
{{dsc concept | cpp/experimental/reflect/Lambda | notes={{mark since reflection ts}} | 指定元对象类型反射非泛型 lambda 的闭包类型}}
{{dsc concept | cpp/experimental/reflect/LambdaCapture | notes={{mark since reflection ts}} | 指定元对象类型反射 lambda 捕获}}

{{dsc h1 | 类}}

{{dsc h2 | {{tt|Object}} 操作}}
{{dsc tclass | cpp/experimental/reflect/reflects_same | notes={{mark since reflection ts}} | 检查两个元对象类型是否反射同一实体或别名}}
{{dsc tclass | cpp/experimental/reflect/get_source_line | notes={{mark since reflection ts}} | 获得被反射实体或别名的声明的预设行号}}
{{dsc tclass | cpp/experimental/reflect/get_source_column | notes={{mark since reflection ts}} |获得被反射实体或别名的声明的实现定义列号}}
{{dsc tclass | cpp/experimental/reflect/get_source_file_name | notes={{mark since reflection ts}} | 获得被反射实体或别名的声明的预设文件名}}

{{dsc h2 | {{tt|ObjectSequence}} 操作}}
{{dsc tclass | cpp/experimental/reflect/get_size | notes={{mark since reflection ts}} | 获得元对象序列的大小}}
{{dsc tclass | cpp/experimental/reflect/get_element | notes={{mark since reflection ts}} | 获得元对象序列中拥有给定下标的元对象类型}}
{{dsc tclass | cpp/experimental/reflect/unpack_sequence | notes={{mark since reflection ts}} | 应用模板到元对象序列}}

{{dsc h2 | {{tt|Named}} 操作}}
{{dsc tclass | cpp/experimental/reflect/is_unnamed | notes={{mark since reflection ts}} | 检查被反射实体或别名是否为无名}}
{{dsc tclass | cpp/experimental/reflect/get_name | notes={{mark since reflection ts}} | 获得被反射实体或别名的无限定名}}
{{dsc tclass | cpp/experimental/reflect/get_display_name | notes={{mark since reflection ts}} | 获得被反射实体或别名的实现定义显示名}}

{{dsc h2 | {{tt|Alias}} 操作}}
{{dsc tclass | cpp/experimental/reflect/get_alias | notes={{mark since reflection ts}} | 获得反射被反射别名的关联实体的元对象类型}}

{{dsc h2 | {{tt|Type}} 操作}}
{{dsc tclass | cpp/experimental/reflect/get_type | notes={{mark since reflection ts}} | 获得反射被反射实体或别名的类型的元对象类型}}
{{dsc tclass | cpp/experimental/reflect/get_reflected_type | notes={{mark since reflection ts}} | 获得反射被反射实体或别名的类型}}
{{dsc tclass | cpp/experimental/reflect/is_enum | notes={{mark since reflection ts}} | 检查元对象类型是否反射枚举类型}}
{{dsc tclass | cpp/experimental/reflect/is_union | notes={{mark since reflection ts}} | 检查元对象类型是否反射联合体类型}}
{{dsc tclass | cpp/experimental/reflect/uses_key | title=uses_class_key&lt;br&gt;uses_struct_key | notes={{mark since reflection ts}} | 分别检查元对象类型是否反射声明使用 {{c|class}} 或 {{c|struct}} 的非联合类类型}}

{{dsc h2 | {{tt|ScopeMember}} 操作}}
{{dsc tclass | cpp/experimental/reflect/get_scope | notes={{mark since reflection ts}} | 获得反射被反射实体或别名的作用域的元对象类型}}

{{dsc h2 | {{tt|Base}} 操作}}
{{dsc tclass | cpp/experimental/reflect/get_class | notes={{mark since reflection ts}} | 获得反射给定基类关系中基类的元对象类型}}

{{dsc h2 | {{tt|RecordMember}} 与 {{tt|Base}} 操作}}
{{dsc tclass | cpp/experimental/reflect/is_public | notes={{mark since reflection ts}} | 检查被反射的成员或基类是否为公开}}
{{dsc tclass | cpp/experimental/reflect/is_protected | notes={{mark since reflection ts}} | 检查被反射的成员或基类是否为受保护}}
{{dsc tclass | cpp/experimental/reflect/is_private | notes={{mark since reflection ts}} | 检查被反射的成员或基类是否为私有}}

{{dsc h2 | {{tt|Record}} 操作}}
{{dsc tclass | cpp/experimental/reflect/get_data_members | title=get_public_data_members&lt;br&gt;get_accessible_data_members&lt;br&gt;get_data_members | notes={{mark since reflection ts}} | 获得元素反射被反射类的公开、可访问或全部数据成员的元对象序列类型}}
{{dsc tclass | cpp/experimental/reflect/get_member_functions | title=get_public_member_functions&lt;br&gt;get_accessible_member_functions&lt;br&gt;get_member_functions | notes={{mark since reflection ts}} | 获得元素反射被反射类的公开、可访问或全部成员函数的元对象序列类型}}
{{dsc tclass | cpp/experimental/reflect/get_constructors | notes={{mark since reflection ts}} | 获得元素反射被反射类的全部构造函数的的元对象序列类型}}
{{dsc tclass | cpp/experimental/reflect/get_operators | notes={{mark since reflection ts}} | 获得元素反射声明于被反射类中的所有运算符函数及转换函数的的元对象序列类型}}
{{dsc tclass | cpp/experimental/reflect/get_destructor | notes={{mark since reflection ts}} | 获得反射被反射类的析构函数的元对象类型}}
{{dsc tclass | cpp/experimental/reflect/get_member_types | title=get_public_member_types&lt;br&gt;get_accessible_member_types&lt;br&gt;get_member_types | notes={{mark since reflection ts}} | 获得元素反射被反射类的公开、可访问或全部成员类型的元对象序列类型}}
{{dsc tclass | cpp/experimental/reflect/get_base_classes | title=get_public_base_classes&lt;br&gt;get_accessible_base_classes&lt;br&gt;get_base_classes | notes={{mark since reflection ts}} | 获得元素反射被反射类的公开、可访问或全部基类的元对象序列类型}}

{{dsc h2 | {{tt|Enum}} 操作}}
{{dsc tclass | cpp/experimental/reflect/is_scoped_enum | notes={{mark since reflection ts}} | 检查被反射枚举是否有作用域}}
{{dsc tclass | cpp/experimental/reflect/get_enumerators | notes={{mark since reflection ts}} | 获得元素反射被反射枚举的枚举项的元对象序列类型}}
{{dsc tclass | cpp/experimental/reflect/get_underlying_type | notes={{mark since reflection ts}} | 获得反射被反射枚举的底层类型的元对象类型}}

{{dsc h2 | {{tt|Variable}} 操作}}
{{dsc tclass | cpp/experimental/reflect/get_constant | notes={{mark since reflection ts}} | 获得作为常量表达式的被反射变量的值}}
{{dsc tclass | cpp/experimental/reflect/is_thread_local | notes={{mark since reflection ts}} | 检查变量是否声明带 {{c|thread_local}} }}

{{dsc h2 | {{tt|FunctionParameter}} 操作}}
{{dsc tclass | cpp/experimental/reflect/has_default_argument | notes={{mark since reflection ts}} | 检查被反射的形参是否有默认实参}}

{{dsc h2 | {{tt|Callable}} 操作}}
{{dsc tclass | cpp/experimental/reflect/get_parameters | notes={{mark since reflection ts}} | 获得元素反射被反射函数的形参的元对象序列类型}}
{{dsc tclass | cpp/experimental/reflect/is_vararg | notes={{mark since reflection ts}} | 检查被反射函数的形参列表是否含有省略号形参}}
{{dsc tclass | cpp/experimental/reflect/is_noexcept | notes={{mark since reflection ts}} | 检查被反射函数是否为不抛出}}
{{dsc tclass | cpp/experimental/reflect/is_deleted | notes={{mark since reflection ts}} | 检查被反射函数是否为被弃置}}

{{dsc h2 | {{tt|Variable}} 与 {{tt|Callable}} 操作}}
{{dsc tclass | cpp/experimental/reflect/is_constexpr | notes={{mark since reflection ts}} | 检查被反射变量或函数是否为 constexpr}}

{{dsc h2 | {{tt|Namespace}} 与 {{tt|Callable}} 操作}}
{{dsc tclass | cpp/experimental/reflect/is_inline | notes={{mark since reflection ts}} | 检查被反射的命名空间或函数是否为 inline}}

{{dsc h2 | {{tt|ParenthesizedExpression}} 操作}}
{{dsc tclass | cpp/experimental/reflect/get_subexpression | notes={{mark since reflection ts}} | 获得反射被反射的有括号表达式的无括号表达式的元对象类型}}

{{dsc h2 | {{tt|FunctionCallExpression}} 操作}}
{{dsc tclass | cpp/experimental/reflect/get_callable | notes={{mark since reflection ts}} | 获得反射被反射的 {{spar|函数调用表达式}} 中的函数的元对象类型}}

{{dsc h2 | {{tt|FunctionalTypeConversion}} 操作}}
{{dsc tclass | cpp/experimental/reflect/get_constructor | notes={{mark since reflection ts}} | 获得反射被反射的 {{spar|函数式类型转换表达式}} 中的构造函数的元对象类型}}

{{dsc h2 | {{tt|Variable}} 与 {{tt|Function}} 操作}}
{{dsc tclass | cpp/experimental/reflect/get_pointer | notes={{mark since reflection ts}} | 获得被反射变量或函数的地址，或指向非静态成员的成员指针值}}

{{dsc h2 | {{tt|MemberFunction}} 函数}}
{{dsc tclass | cpp/experimental/reflect/is_qualified | title=is_const&lt;br&gt;is_volatile&lt;br&gt;has_lvalueref_qualifier&lt;br&gt;has_rvalueref_qualifier | notes={{mark since reflection ts}} | 分别检查被反射成员函数是否声明带 {{c|const}}、{{c|volatile}}、{{c|&amp;}} 或 {{c|&amp;&amp;}} 限定符}}
{{dsc tclass | cpp/experimental/reflect/is_override | notes={{mark since reflection ts}} | 检查被反射的成员函数是否重写基类的成员函数}}

{{dsc h2 | {{tt|Record}} 与 {{tt|MemberFunction}} 操作}}
{{dsc tclass | cpp/experimental/reflect/is_final | notes={{mark since reflection ts}} | 检查被反射的类或成员函数是否标记为 {{c|final}} }}

{{dsc h2 | {{tt|Variable}} 与 {{tt|MemberFunction}} 操作}}
{{dsc tclass | cpp/experimental/reflect/is_static | notes={{mark since reflection ts}} | 检查被反射的变量是否拥有静态存储期，或被反射的成员函数是否为静态}}

{{dsc h2 | {{tt|SpecialMemberFunction}} 操作}}
{{dsc tclass | cpp/experimental/reflect/is_implicitly_declared | notes={{mark since reflection ts}} | 检查被反射的特殊成员函数是否为隐式声明}}
{{dsc tclass | cpp/experimental/reflect/is_defaulted | notes={{mark since reflection ts}} | 检查被反射的成员函数是否在其首条声明预置}}

{{dsc h2 | {{tt|Constructor}} 与 {{tt|ConversionOperator}} 操作}}
{{dsc tclass | cpp/experimental/reflect/is_explicit | notes={{mark since reflection ts}} | 检查被反射的构造函数或转换函数是否声明带 {{c|explicit}} }}

{{dsc h2 | {{tt|MemberFunction}} 与 {{tt|Destructor}} 操作}}
{{dsc tclass | cpp/experimental/reflect/is_virtual | notes={{mark since reflection ts}} | 检查被反射的成员函数是否为虚}}
{{dsc tclass | cpp/experimental/reflect/is_pure_virtual | notes={{mark since reflection ts}} | 检查被反射的成员函数是否为纯虚}}

{{dsc h2 | {{tt|Lambda}} 操作}}
{{dsc tclass | cpp/experimental/reflect/get_captures | notes={{mark since reflection ts}} | 获得元素反射被反射闭包类型的捕获的元对象序列类型}}
{{dsc tclass | cpp/experimental/reflect/uses_default_capture | title=uses_default_copy_capture&lt;br&gt;uses_default_reference_capture | notes={{mark since reflection ts}} | 分别检查被反射闭包类型的 lambda 表达式的捕获默认是否为 {{tt|1==}} 或 {{tt|&amp;}} }}
{{dsc tclass | cpp/experimental/reflect/is_call_operator_const | notes={{mark since reflection ts}} | 检查被反射闭包类型的 {{tt|operator()}} 是否声明带 {{c|const}} }}

{{dsc h2 | {{tt|LambdaCapture}} 操作}}
{{dsc tclass | cpp/experimental/reflect/is_explictly_captured | notes={{mark since reflection ts}} | 检查被反射的 lambda 捕获是否被显式捕获}}
{{dsc tclass | cpp/experimental/reflect/is_init_capture | notes={{mark since reflection ts}} | 检查被反射的 lambda 捕获是否为初始化捕获}}
{{dsc end}}

===概要===
{{source|1=
namespace std::experimental::reflect {
inline namespace v1 {

// 21.12.3 元对象类型的概念
template &lt;class T&gt;
concept Object = /* 见描述 */;
template &lt;class T&gt;
concept ObjectSequence = /* 见描述 */; // 细化 Object
template &lt;class T&gt;
concept TemplateParameterScope = /* 见描述 */; // 细化 Scope
template &lt;class T&gt;
concept Named = /* 见描述 */;          // 细化 Object
template &lt;class T&gt;
concept Alias = /* 见描述 */;          // 细化 Named 与 ScopeMember
template &lt;class T&gt;
concept RecordMember = /* 见描述 */;   // 细化 ScopeMember
template &lt;class T&gt;
concept Enumerator = /* 见描述 */;     // 细化 Constant
template &lt;class T&gt;
concept Variable = /* 见描述 */;       // 细化 Typed 与 ScopeMember
template &lt;class T&gt;
concept ScopeMember = /* 见描述 */;    // 细化 Named
template &lt;class T&gt;
concept Typed = /* 见描述 */;          // 细化 Object
template &lt;class T&gt;
concept Namespace = /* 见描述 */;      // 细化 Named 与 Scope
template &lt;class T&gt;
concept GlobalScope = /* 见描述 */;    // 细化 Namespace
template &lt;class T&gt;
concept Class = /* 见描述 */;          // 细化 Record
template &lt;class T&gt;
concept Enum = /* 见描述 */;           // 细化 Type, Scope, 与 ScopeMember
template &lt;class T&gt;
concept Record = /* 见描述 */;         // 细化 Type, Scope, 与 ScopeMember
template &lt;class T&gt;
concept Scope = /* 见描述 */;          // 细化 Object
template &lt;class T&gt;
concept Type = /* 见描述 */;           // 细化 Named
template &lt;class T&gt;
concept Constant = /* 见描述 */;       // 细化 Typed 与 ScopeMember
template &lt;class T&gt;
concept Base = /* 见描述 */;           // 细化 Object
template &lt;class T&gt;
concept FunctionParameter = /* 见描述 */; // 细化 Typed 与 ScopeMember
template &lt;class T&gt;
concept Callable = /* 见描述 */;       // 细化 Scope 与 ScopeMember
template &lt;class T&gt;
concept Expression = /* 见描述 */;     // 细化 Object
template &lt;class T&gt;
concept ParenthesizedExpression = /* 见描述 */; // 细化 Expression
template &lt;class T&gt;
concept FunctionCallExpression = /* 见描述 */; // 细化 Expression
template &lt;class T&gt;
concept FunctionalTypeConversion = /* 见描述 */; // 细化 Expression
template &lt;class T&gt;
concept Function = /* 见描述 */;       // 细化 Typed 与 Callable
template &lt;class T&gt;
concept MemberFunction = /* 见描述 */; // 细化 RecordMember 与 Function
template &lt;class T&gt;
concept SpecialMemberFunction = /* 见描述 */; // 细化 RecordMember
template &lt;class T&gt;
concept Constructor = /* 见描述 */;    // 细化 Callable 与 RecordMember
template &lt;class T&gt;
concept Destructor = /* 见描述 */;     // 细化 Callable 与 SpecialMemberFunction
template &lt;class T&gt;
concept Operator = /* 见描述 */;       // 细化 Function
template &lt;class T&gt;
concept ConversionOperator = /* 见描述 */; // 细化 MemberFunction 与 Operator
template &lt;class T&gt;
concept Lambda = /* 见描述 */;         // 细化 Type 与 Scope
template &lt;class T&gt;
concept LambdaCapture = /* 见描述 */;  // 细化 Variable

// 21.12.4 元对象操作
// 多重概念操作
template &lt;Object T&gt; struct is_public;
template &lt;Object T&gt; struct is_protected;
template &lt;Object T&gt; struct is_private;
template &lt;Object T&gt; struct is_constexpr;
template &lt;Object T&gt; struct is_static;
template &lt;Object T&gt; struct is_final;
template &lt;Object T&gt; struct is_explicit;
template &lt;Object T&gt; struct is_inline;
template &lt;Object T&gt; struct is_virtual;
template &lt;Object T&gt; struct is_pure_virtual;
template &lt;Object T&gt; struct get_pointer;

template &lt;class T&gt;
requires RecordMember&lt;T&gt; {{!!}} Base&lt;T&gt;
  constexpr auto is_public_v = is_public&lt;T&gt;::value;
template &lt;class T&gt;
requires RecordMember&lt;T&gt; {{!!}} Base&lt;T&gt;
  constexpr auto is_protected_v = is_protected&lt;T&gt;::value;
template &lt;class T&gt;
requires RecordMember&lt;T&gt; {{!!}} Base&lt;T&gt;
  constexpr auto is_private_v = is_private&lt;T&gt;::value;
template &lt;class T&gt;
requires Variable&lt;T&gt; {{!!}} Callable&lt;T&gt;
  constexpr auto is_constexpr_v = is_constexpr&lt;T&gt;::value;
template &lt;class T&gt;
requires Variable&lt;T&gt; {{!!}} MemberFunction&lt;T&gt;
  constexpr auto is_static_v = is_static&lt;T&gt;::value;
template &lt;class T&gt;
requires Class&lt;T&gt; {{!!}} MemberFunction&lt;T&gt;
  constexpr auto is_final_v = is_final&lt;T&gt;::value;
template &lt;class T&gt;
requires Constructor&lt;T&gt; {{!!}} ConversionOperator&lt;T&gt;
  constexpr auto is_explicit_v = is_explicit&lt;T&gt;::value;
template &lt;class T&gt;
requires Namespace&lt;T&gt; {{!!}} Callable&lt;T&gt;
  constexpr auto is_inline_v = is_inline&lt;T&gt;::value;
template &lt;class T&gt;
requires Base&lt;T&gt; {{!!}} MemberFunction&lt;T&gt; {{!!}} Destructor&lt;T&gt;
  constexpr auto is_virtual_v = is_virtual&lt;T&gt;::value;
template &lt;class T&gt;
requires MemberFunction&lt;T&gt; {{!!}} Destructor&lt;T&gt;
  constexpr auto is_pure_virtual_v = is_pure_virtual&lt;T&gt;::value;
template &lt;class T&gt;
requires Variable&lt;T&gt; {{!!}} Function&lt;T&gt;
  constexpr auto get_pointer_v = get_pointer&lt;T&gt;::value;

// 21.12.4.1 Object 操作
template &lt;Object T1, Object T2&gt; struct reflects_same;
template &lt;Object T&gt; struct get_source_line;
template &lt;Object T&gt; struct get_source_column;
template &lt;Object T&gt; struct get_source_file_name;

template &lt;Object T1, Object T2&gt;
  constexpr auto reflects_same_v = reflects_same&lt;T1, T2&gt;::value;
template &lt;class T&gt;
  constexpr auto get_source_line_v = get_source_line&lt;T&gt;::value;
template &lt;class T&gt;
  constexpr auto get_source_column_v = get_source_column&lt;T&gt;::value;
template &lt;class T&gt;
  constexpr auto get_source_file_name_v = get_source_file_name&lt;T&gt;::value;

// 21.12.4.2 ObjectSequence 操作
template &lt;ObjectSequence T&gt; struct get_size;
template &lt;size_t I, ObjectSequence T&gt; struct get_element;
template &lt;template &lt;class...&gt; class Tpl, ObjectSequence T&gt;
  struct unpack_sequence;

template &lt;ObjectSequence T&gt;
  constexpr auto get_size_v = get_size&lt;T&gt;::value;
template &lt;size_t I, ObjectSequence T&gt;
  using get_element_t = typename get_element&lt;I, T&gt;::type;
template &lt;template &lt;class...&gt; class Tpl, ObjectSequence T&gt;
  using unpack_sequence_t = typename unpack_sequence&lt;Tpl, T&gt;::type;

// 21.12.4.3 Named 操作
template &lt;Named T&gt; struct is_unnamed;
template &lt;Named T&gt; struct get_name;
template &lt;Named T&gt; struct get_display_name;

template &lt;Named T&gt;
  constexpr auto is_unnamed_v = is_unnamed&lt;T&gt;::value;
template &lt;Named T&gt;
  constexpr auto get_name_v = get_name&lt;T&gt;::value;
template &lt;Named T&gt;
  constexpr auto get_display_name_v = get_display_name&lt;T&gt;::value;

// 21.12.4.4 Alias 操作
template &lt;Alias T&gt; struct get_aliased;

template &lt;Alias T&gt;
  using get_aliased_t = typename get_aliased&lt;T&gt;::type;

// 21.12.4.5 Type 操作
template &lt;Typed T&gt; struct get_type;
template &lt;Type T&gt; struct get_reflected_type;
template &lt;Type T&gt; struct is_enum;
template &lt;Class T&gt; struct uses_class_key;
template &lt;Class T&gt; struct uses_struct_key;
template &lt;Type T&gt; struct is_union;

template &lt;Typed T&gt;
  using get_type_t = typename get_type&lt;T&gt;::type;
template &lt;Type T&gt;
  using get_reflected_type_t = typename get_reflected_type&lt;T&gt;::type;
template &lt;Type T&gt;
  constexpr auto is_enum_v = is_enum&lt;T&gt;::value;
template &lt;Class T&gt;
  constexpr auto uses_class_key_v = uses_class_key&lt;T&gt;::value;
template &lt;Class T&gt;
  constexpr auto uses_struct_key_v = uses_struct_key&lt;T&gt;::value;
template &lt;Type T&gt;
  constexpr auto is_union_v = is_union&lt;T&gt;::value;

// 21.12.4.6 Member 操作
template &lt;ScopeMember T&gt; struct get_scope;
template &lt;RecordMember T&gt; struct is_public&lt;T&gt;;
template &lt;RecordMember T&gt; struct is_protected&lt;T&gt;;
template &lt;RecordMember T&gt; struct is_private&lt;T&gt;;
template &lt;ScopeMember T&gt;
  using get_scope_t = typename get_scope&lt;T&gt;::type;

// 21.12.4.7 Record 操作
template &lt;Record T&gt; struct get_public_data_members;
template &lt;Record T&gt; struct get_accessible_data_members;
template &lt;Record T&gt; struct get_data_members;
template &lt;Record T&gt; struct get_public_member_functions;
template &lt;Record T&gt; struct get_accessible_member_functions;
template &lt;Record T&gt; struct get_member_functions;
template &lt;Record T&gt; struct get_public_member_types;
template &lt;Record T&gt; struct get_accessible_member_types;
template &lt;Record T&gt; struct get_member_types;
template &lt;Record T&gt; struct get_constructors;
template &lt;Record T&gt; struct get_destructor;
template &lt;Record T&gt; struct get_operators;
template &lt;Class T&gt; struct get_public_base_classes;
template &lt;Class T&gt; struct get_accessible_base_classes;
template &lt;Class T&gt; struct get_base_classes;
template &lt;Class T&gt; struct is_final&lt;T&gt;;

template &lt;Record T&gt;
  using get_public_data_members_t = typename get_public_data_members&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_accessible_data_members_t = typename get_accessible_data_members&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_data_members_t = typename get_data_members&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_public_member_functions_t = typename get_public_member_functions&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_accessible_member_functions_t = typename get_accessible_member_functions&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_member_functions_t = typename get_member_functions&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_public_member_types_t = typename get_public_member_types&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_accessible_member_types_t = typename get_accessible_member_types&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_member_types_t = typename get_member_types&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_constructors_t = typename get_constructors&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_destructor_t = typename get_destructor&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_operators_t = typename get_operators&lt;T&gt;::type;
template &lt;Class T&gt;
  using get_public_base_classes_t = typename get_public_base_classes&lt;T&gt;::type;
template &lt;Class T&gt;
  using get_accessible_base_classes_t = typename get_accessible_base_classes&lt;T&gt;::type;
template &lt;Class T&gt;
  using get_base_classes_t = typename get_base_classes&lt;T&gt;::type;

// 21.12.4.8 Enum 操作
template &lt;Enum T&gt; struct is_scoped_enum;
template &lt;Enum T&gt; struct get_enumerators;
template &lt;Enum T&gt; struct get_underlying_type;

template &lt;Enum T&gt;
  constexpr auto is_scoped_enum_v = is_scoped_enum&lt;T&gt;::value;
template &lt;Enum T&gt;
  using get_enumerators_t = typename get_enumerators&lt;T&gt;::type;
template &lt;Enum T&gt;
  using get_underlying_type_t = typename get_underlying_type&lt;T&gt;::type;

// 21.12.4.9 Value 操作
template &lt;Constant T&gt; struct get_constant;
template &lt;Variable T&gt; struct is_constexpr&lt;T&gt;;
template &lt;Variable T&gt; struct is_static&lt;T&gt;;
template &lt;Variable T&gt; struct is_thread_local;
template &lt;Variable T&gt; struct get_pointer&lt;T&gt;;

template &lt;Constant T&gt;
  constexpr auto get_constant_v = get_constant&lt;T&gt;::value;
template &lt;Variable T&gt;
  constexpr auto is_thread_local_v = is_thread_local&lt;T&gt;::value;

// 21.12.4.10 Base 操作
template &lt;Base T&gt; struct get_class;
template &lt;Base T&gt; struct is_virtual&lt;T&gt;;
template &lt;Base T&gt; struct is_public&lt;T&gt;;
template &lt;Base T&gt; struct is_protected&lt;T&gt;;
template &lt;Base T&gt; struct is_private&lt;T&gt;;

template &lt;Base T&gt;
  using get_class_t = typename get_class&lt;T&gt;::type;

// 21.12.4.11 Namespace 操作
template &lt;Namespace T&gt; struct is_inline&lt;T&gt;;

// 21.12.4.12 FunctionParameter 操作
template &lt;FunctionParameter T&gt; struct has_default_argument;

template &lt;FunctionParameter T&gt;
  constexpr auto has_default_argument_v = has_default_argument&lt;T&gt;::value;

// 21.12.4.13 Callable 操作
template &lt;Callable T&gt; struct get_parameters;
template &lt;Callable T&gt; struct is_vararg;
template &lt;Callable T&gt; struct is_constexpr&lt;T&gt;;
template &lt;Callable T&gt; struct is_noexcept;
template &lt;Callable T&gt; struct is_inline&lt;T&gt;;
template &lt;Callable T&gt; struct is_deleted;

template &lt;Callable T&gt;
  using get_parameters_t = typename get_parameters&lt;T&gt;::type;
template &lt;Callable T&gt;
  constexpr auto is_vararg_v = is_vararg&lt;T&gt;::value;
template &lt;Callable T&gt;
  constexpr auto is_deleted_v = is_deleted&lt;T&gt;::value;

// 21.12.4.14 ParenthesizedExpression 操作
template &lt;ParenthesizedExpression T&gt; struct get_subexpression;

template &lt;ParenthesizedExpression T&gt;
  using get_subexpression_t = typename get_subexpression&lt;T&gt;::type;

// 21.12.4.15 FunctionCallExpression 操作
template &lt;FunctionCallExpression T&gt; struct get_callable;

template &lt;FunctionCallExpression T&gt;
  using get_callable_t = typename get_callable&lt;T&gt;::type;

// 21.12.4.16 FunctionalTypeConversion 操作
template &lt;FunctionalTypeConversion T&gt; struct get_constructor;

template &lt;FunctionalTypeConversion T&gt;
  using get_constructor_t = typename get_constructor&lt;T&gt;::type;

// 21.12.4.17 Function 操作
template &lt;Function T&gt; struct get_pointer&lt;T&gt;;

// 21.12.4.18 MemberFunction 操作
template &lt;MemberFunction T&gt; struct is_static&lt;T&gt;;
template &lt;MemberFunction T&gt; struct is_const;
template &lt;MemberFunction T&gt; struct is_volatile;
template &lt;MemberFunction T&gt; struct has_lvalueref_qualifier;
template &lt;MemberFunction T&gt; struct has_rvalueref_qualifier;
template &lt;MemberFunction T&gt; struct is_virtual&lt;T&gt;;
template &lt;MemberFunction T&gt; struct is_pure_virtual&lt;T&gt;;
template &lt;MemberFunction T&gt; struct is_override;
template &lt;MemberFunction T&gt; struct is_final&lt;T&gt;;

template &lt;MemberFunction T&gt;
  constexpr auto is_const_v = is_const&lt;T&gt;::value;
template &lt;MemberFunction T&gt;
  constexpr auto is_volatile_v = is_volatile&lt;T&gt;::value;
template &lt;MemberFunction T&gt;
  constexpr auto has_lvalueref_qualifier_v = has_lvalueref_qualifier&lt;T&gt;::value;
template &lt;MemberFunction T&gt;
  constexpr auto has_rvalueref_qualifier_v = has_rvalueref_qualifier&lt;T&gt;::value;
template &lt;MemberFunction T&gt;
  constexpr auto is_override_v = is_override&lt;T&gt;::value;

// 21.12.4.19 SpecialMemberFunction 操作
template &lt;SpecialMemberFunction T&gt; struct is_implicitly_declared;
template &lt;SpecialMemberFunction T&gt; struct is_defaulted;

template &lt;SpecialMemberFunction T&gt;
  constexpr auto is_implicitly_declared_v = is_implicitly_declared&lt;T&gt;::value;
template &lt;SpecialMemberFunction T&gt;
  constexpr auto is_defaulted_v = is_defaulted&lt;T&gt;::value;

// 21.12.4.20 Constructor 操作
template &lt;Constructor T&gt; struct is_explicit&lt;T&gt;;

// 21.12.4.21 Destructor 操作
template &lt;Destructor T&gt; struct is_virtual&lt;T&gt;;
template &lt;Destructor T&gt; struct is_pure_virtual&lt;T&gt;;

// 21.12.4.22 ConversionOperator 操作
template &lt;ConversionOperator T&gt; struct is_explicit&lt;T&gt;;

// 21.12.4.23 Lambda 操作
template &lt;Lambda T&gt; struct get_captures;
template &lt;Lambda T&gt; struct uses_default_copy_capture;
template &lt;Lambda T&gt; struct uses_default_reference_capture;
template &lt;Lambda T&gt; struct is_call_operator_const;

template &lt;Lambda T&gt;
  using get_captures_t = typename get_captures&lt;T&gt;::type;
template &lt;Lambda T&gt;
  constexpr auto uses_default_copy_capture_v = uses_default_copy_capture&lt;T&gt;::value;
template &lt;Lambda T&gt;
  constexpr auto uses_default_reference_capture_v = uses_default_reference_capture&lt;T&gt;::value;
template &lt;Lambda T&gt;
  constexpr auto is_call_operator_const_v = is_call_operator_const&lt;T&gt;::value;

// 21.12.4.24 LambdaCapture 操作
template &lt;LambdaCapture T&gt; struct is_explicitly_captured;
template &lt;LambdaCapture T&gt; struct is_init_capture;

template &lt;LambdaCapture T&gt;
  constexpr auto is_explicitly_captured_v = is_explicitly_captured&lt;T&gt;::value;
template &lt;LambdaCapture T&gt;
  constexpr auto is_init_capture_v = is_init_capture&lt;T&gt;::value;

} // inline namespace v1
} // namespace std::experimental::reflect
}}

{{langlinks|en|es|ja|ru}}