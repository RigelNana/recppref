{{cpp/text/text_encoding/title|literal}}
{{cpp/text/text_encoding/navbar}}
{{dcl begin}}
{{dcl|since=c++26|
static consteval text_encoding literal() noexcept;
}}
{{dcl end}}

构造一个新的 {{tt|text_encoding}} 对象，表示[[cpp/language/charset#代码单元与字面量编码|普通字符字面量编码]]。它用于确定普通字符或字符串字面量（如 {{c|"This is literal"}}）所应用的字符编码。

除非 {{c|CHAR_BIT}} 为 {{c|8}}，否则这个函数被删除。

===参数===
（无）

===返回值===
保有普通字面量编码的表示的对象。

===注解===
这个函数可以利用特定于编译器的内建宏（如 Clang 的 [https://clang.llvm.org/docs/LanguageExtensions.html#builtin-macros {{tt|__clang_literal_encoding__}}] 或 GCC 的 [https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html {{tt|__GNUC_EXECUTION_CHARSET_NAME}}]）构造 {{tt|text_encoding}} 来予以实现。这些宏是编译时已知的，它们展开为包含所使用的窄执行字符集（普通字面量编码）的名字的窄字符串字面量。

{{c|literal()}} 返回的值可能取决于编译器选项，如 GCC 或 Clang 的 {{tt|1=-fexec-charset=''encoding-name''}} 或者 MSVC 的 {{tt|1=/execution-charset:''encoding-name''}}。

===示例===
{{example
|此示例演示对普通字面量编码应为 UTF-8 的断言。
|code=
#include &lt;text_encoding&gt;

static_assert(std::text_encoding::literal() == std::text_encoding::UTF8);

int main()
{
    // 若字面量编码为 UTF-8，则这个无前缀字符串字面量按 UTF-8 编码
    constexpr char green_heart[] = "\N{GREEN HEART}";
  
    // 这个有前缀字符串字面量，无论字面量编码为何，总是按 UTF-8 编码
    constexpr char8_t green_heart_u8[] = u8"\N{GREEN HEART}";
}
}}

{{langlinks|en|es|ja|ru}}