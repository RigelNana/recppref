{{title|setjmp}}
{{cpp/utility/program/navbar}}
{{ddcl|header=csetjmp|
#define setjmp(env) /* 由实现定义 */
}}

保存当前执行上下文到 {{lc|std::jmp_buf}} 类型的变量 {{c|env}}。{{lc|std::longjmp}} 函数稍后可用此变量恢复当前执行上下文。即在调用 {{lc|std::longjmp}} 函数时，将在构造了传递给 {{lc|std::longjmp}} 的 {{lc|std::jmp_buf}} 变量的特定调用点处继续执行。此时 {{tt|setjmp}} 返回传递给 {{lc|std::longjmp}} 的值。

{{tt|setjmp}} 的调用只能在下列语境出现：
# {{ltt|cpp/language/if}}、{{ltt|cpp/language/switch}}、{{ltt|cpp/language/while}}、{{ltt|cpp/language/do|do-while}}、{{ltt|cpp/language/for}} 语句的整个控制表达式。&lt;!--
--&gt;{{source|1=
switch (setjmp(env)) { // ...
}}
# 关系或相等性运算符的操作数之一，而另一操作数是整数常量表达式，产生的表达式是 {{ltt|cpp/language/if}}、{{ltt|cpp/language/switch}}、{{ltt|cpp/language/while}}、{{ltt|cpp/language/do|do-while}}、{{ltt|cpp/language/for}} 语句的整个控制表达式。&lt;!--
--&gt;{{source|1=
if (setjmp(env) &gt; 0) { // ...
}}
# 一元 ! 运算符的操作数，产生的表达式是 {{ltt|cpp/language/if}}、{{ltt|cpp/language/switch}}、{{ltt|cpp/language/while}}、{{ltt|cpp/language/do|do-while}}、{{ltt|cpp/language/for}} 语句的整个控制表达式。&lt;!--
--&gt;{{source|1=
while (!setjmp(env)) { // ...
}}
# [[cpp/language/statements#表达式语句|表达式语句]]（可以转型到 {{c/core|void}}）的整个表达式。&lt;!--
--&gt;{{source|1=
setjmp(env);
}}
如果 {{tt|setjmp}} 在其他语境出现，那么行为未定义。

{{rev begin}}
{{rev|since=c++20|
此外，在[[cpp/language/coroutines|协程]]中可以使用 {{c/core|co_await}} 运算符的地方调用 {{tt|setjmp}} 的行为未定义。
}}
{{rev end}}

一旦返回到 {{tt|setjmp}} 的作用域：
* 所有可访问对象、浮点状态标志及其他抽象机组件拥有与在执行 {{lc|std::longjmp}} 时相同的值，
* 除了含有 {{tt|setjmp}} 调用的函数中的非 [[cpp/language/cv|volatile]] 局部对象，如果在 {{tt|setjmp}} 调用后更改它们，那么它们的值不确定。

===参数===
{{par begin}}
{{par|env|保存程序执行状态的变量}}
{{par end}}

===返回值===
如果宏被原始代码调用且执行环境在 {{c|env}} 存储，那么返回 {{c|0}}。

如果刚才进行了非局部跳转，那么返回非零值。返回值与传递给 {{lc|std::longjmp}} 的值相同。

===注解===
上述要求禁止在数据流中使用 {{tt|setjmp}} 的返回值（例如用它初始化或赋值对象）。只能将返回值用于控制流或舍弃。

===示例===
{{cpp/utility/program/example setjmp}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/program/dsc longjmp}}
{{dsc see c|c/program/setjmp}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}