{{cpp/title|longjmp}}
{{cpp/utility/program/navbar}}
{{dcl begin}}
{{dcl header|csetjmp}}
{{dcl rev begin}}
{{dcl|until=c++17|
             void longjmp( std::jmp_buf env, int status );
}}
{{dcl|since=c++17|
[[noreturn]] void longjmp( std::jmp_buf env, int status );
}}
{{dcl rev end}}
{{dcl end}}

加载先前的 {{lc|setjmp}} 调用所保存的执行上下文 {{c|env}}。此函数不会返回。控制被转移到设置了 {{c|env}} 的宏 {{lc|setjmp}} 的调用点。该 {{lc|setjmp}} 随后返回作为 {{c|status}} 传递的值。

如果调用了 {{lc|setjmp}} 的函数已退出，那么行为未定义（也就是说只允许沿调用栈向上长跳）。

===C++ 的额外限制===
在 C 的 {{ltt|c/program/longjmp}} 基础上，C++ 的 {{tt|std::longjmp}} 的行为受到更多限制。

如果分别以 {{c/core|throw}} 和 {{c/core|catch}} 替换 {{tt|std::longjmp}} 和 {{lc|setjmp}} 会执行任何自动对象的[[cpp/language/destructor#平凡析构函数|非平凡析构函数]]，那么这种 {{tt|std::longjmp}} 的行为未定义。

{{rev begin}}
{{rev|since=c++20|
在[[cpp/language/coroutines|协程]]中可以使用 {{c/core|co_await}} 运算符的地方调用 {{tt|std::longjmp}} 的行为未定义。
}}
{{rev end}}

===参数===
{{par begin}}
{{par|env|指代 {{lc|setjmp}} 所保存的函数执行状态的变量}}
{{par|status|从 {{lc|setjmp}} 返回的值。如果它等于 {{c|0}}，那么用 {{c|1}} 代替}}
{{par end}}

===返回值===
（无）

===注解===
{{tt|std::longjmp}} 是 C 中处理函数无法有意义返回处的错误条件的机制。C++ 通常为此目的使用[[cpp/language/exceptions|异常处理]]。

===示例===
{{cpp/utility/program/example setjmp}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=619|std=C++98|before=C++ 额外限制的描述措辞比较模糊|after=改进措辞}}
{{dr list item|wg=lwg|dr=894|std=C++98|before=分别以 {{c/core|throw}} 和 {{c/core|catch}} 替换 {{tt|std::longjmp}}&lt;br&gt;和 {{lc|setjmp}} 会销毁任何自动对象时的行为未定义|after=只有在这种情况下会执行任何自动对象&lt;br&gt;的非平凡析构函数时行为才会未定义}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/program/dsc setjmp}}
{{dsc see c|c/program/longjmp}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}