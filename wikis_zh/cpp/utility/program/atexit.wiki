{{cpp/title|atexit}}
{{cpp/utility/program/navbar}}
{{dcl begin}}
{{dcl header|cstdlib}}
{{dcl rev multi|num=1|until1=c++11|dcl1=
int atexit( /* c-atexit-handler */* func );
int atexit( /* atexit-handler */* func );
|dcl2=
int atexit( /* c-atexit-handler */* func ) noexcept;
int atexit( /* atexit-handler */* func ) noexcept;
}}
{{dcl|num=2|notes={{mark expos}}|1=
extern "C" using /* c-atexit-handler */ = void();
extern "C++" using /* atexit-handler */ = void();
}}
{{dcl end}}

注册 {{c|func}} 指向的函数，使得在正常程序中止（通过 {{lc|std::exit()}} 或从 [[cpp/language/main function|main 函数]]返回）时调用它。
{{rrev multi|until1=c++11
|rev1=这些函数将在静态对象析构期间以逆序调用：如果 A 先于 B 被注册，那么对 B 的调用先于对 A 的调用。同样的规则适用于静态对象构造函数和对 {{tt|atexit}} 的调用之间的定序：见 {{lc|std::exit}}。
|rev2=函数可能与拥有静态存储期的对象的析构函数，或彼此间并发调用，这维持了在 A 的注册按顺序早于 B 的注册时，对 B 的调用按顺序早于对 A 的调用的保证，同样的规则适用于静态对象构造函数和对 {{tt|atexit}} 的调用之间的定序：见 {{lc|std::exit}}。
}}

同一函数可以进行多次注册。

如果函数通过异常退出，那么调用 {{lc|std::terminate}}。

{{tt|atexit}} 是线程安全的：从多个线程调用函数不会引入数据竞争。

保证实现支持注册至少 {{tt|32}} 个函数。确切的限制由实现定义。

===参数===
{{par begin}}
{{par|func|指向正常程序终止时要调用的函数的指针}}
{{par end}}

===返回值===
在注册成功时返回 {{c|0}}，否则返回非零值。

===注解===
两个重载有所不同，因为形参 {{c|func}} 的类型不同（[[cpp/language/language linkage|语言链接]]是类型的一部分）。

===示例===
{{example
|code=
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;

void atexit_handler_1()
{
    std::cout &lt;&lt; "At exit #1\n";
}

void atexit_handler_2()
{
    std::cout &lt;&lt; "At exit #2\n";
}

int main()
{
    const int result_1 = std::atexit(atexit_handler_1);
    const int result_2 = std::atexit(atexit_handler_2);
    
    if (result_1 or result_2)
    {
        std::cerr &lt;&lt; "注册失败！\n";
        return EXIT_FAILURE;
    }
    
    std::cout &lt;&lt; "从 main 返回...\n";
    return EXIT_SUCCESS;
}
|output=
从 main 返回...
At exit #2
At exit #1
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/program/dsc abort}}
{{dsc inc|cpp/utility/program/dsc exit}}
{{dsc inc|cpp/utility/program/dsc quick_exit}}
{{dsc inc|cpp/utility/program/dsc at_quick_exit}}
{{dsc see c|c/program/atexit}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}