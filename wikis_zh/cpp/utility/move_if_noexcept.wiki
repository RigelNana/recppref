{{cpp/title|move_if_noexcept}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|utility}}
{{dcla|since=c++11|constexpr=c++14|
template&lt; class T &gt;
/* 见下文 */ move_if_noexcept( T&amp; x ) noexcept;
}}
{{dcl end}}

若实参的移动构造函数不抛异常，则 {{tt|move_if_noexcept}} 获得到实参的右值引用，否则获得左值引用。它典型地用于组合移动语义和强异常保证。

{{tt|std::move_if_noexcept}} 的返回类型为：
* 如果 {{c|std::is_nothrow_move_constructible&lt;T&gt;::value {{!!}} !std::is_copy_constructible&lt;T&gt;::value}} 为 {{c|true}}，则为 {{c|T&amp;&amp;}}，
* 否则为 {{c|const T&amp;}}。

===参数===
{{par begin}}
{{par|x|要移动或复制的对象}}
{{par end}}

===返回值===
为 {{c|std::move(x)}} 或 {{c|x}}，取决于异常保证。

===复杂度===
常数。

===注解===
它可为如 {{c|std::vector::resize}} 这些必须分配新存储然后从旧存储移动或复制元素到新存储的函数所用。若在此操作中发生异常，则 {{c|std::vector::resize}} 撤销直至此点它所做的全部操作，这只有在使用 {{tt|std::move_if_noexcept}} 确定了使用移动构造还是复制构造时（除非复制构造不可用，该情况下还是会使用移动构造，且可能抛弃强异常保证）才可行。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;utility&gt;

struct Bad
{
    Bad() {}
    Bad(Bad&amp;&amp;) // 可能抛出
    {
        std::cout &lt;&lt; "调用了可能抛出的移动构造函数\n";
    }
    Bad(const Bad&amp;) // 亦可能抛出
    {
        std::cout &lt;&lt; "调用了可能抛出的复制构造函数\n";
    }
};

struct Good
{
    Good() {}
    Good(Good&amp;&amp;) noexcept // 将不抛出
    {
        std::cout &lt;&lt; "调用了无抛出的移动构造函数\n";
    }
    Good(const Good&amp;) noexcept // 将不抛出
    {
        std::cout &lt;&lt; "调用了无抛出的复制构造函数\n";
    }
};

int main()
{
    Good g;
    Bad b;
    [[maybe_unused]] Good g2 = std::move_if_noexcept(g);
    [[maybe_unused]] Bad b2 = std::move_if_noexcept(b);
}
|output=
调用了无抛出的移动构造函数
调用了可能抛出的复制构造函数
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/dsc forward}}
{{dsc inc|cpp/utility/dsc move}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}