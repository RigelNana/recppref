{{cpp/title|make_from_tuple}}
{{cpp/utility/navbar}}

{{dcl begin}}
{{dcl header|tuple}}
{{dcl rev multi
|since1=c++17|dcl1=
template&lt; class T, class Tuple &gt;
constexpr T make_from_tuple( Tuple&amp;&amp; t );
|since2=c++23|dcl2=
template&lt; class T, tuple-like Tuple &gt;
constexpr T make_from_tuple( Tuple&amp;&amp; t );
}}
{{dcl end}}

以元组 {{c|t}} 的各元素作为构造函数的实参构造 {{tt|T}} 类型的对象。

给定如下定义的仅用于阐述的函数 {{c|/*make-from-tuple-impl*/}}：
{{box|
{{c/core|template&lt;class T,}}{{nbspt}}{{lti|cpp/utility/tuple/tuple-like}}{{nbspt}}{{c/core|Tuple, std::size_t... I&gt; // C++23 前没有约束 Tuple}}&lt;br&gt;
&lt;!--  LWG 3528 添加的 requires 因为不适用 C++17 而省略，它的条件改为在下面的非良构情况中列出。 --&gt;
{{c/core|constexpr T /*make-from-tuple-impl*/(Tuple&amp;&amp; t, std::index_sequence&lt;I...&gt;)}}&lt;br&gt;
{{tt|{}}&lt;br&gt;
{{nbspt|4}}{{c/core|return T(std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);}}&lt;br&gt;
{{tt|}&lt;!----&gt;}}
}}

效果等价于：&lt;br&gt;{{c multi
|return /*make-from-tuple-impl*/&lt;T&gt;(
|    std::forward&lt;Tuple&gt;(t),
|    std::make_index_sequence&lt;std::tuple_size_v&lt;std::remove_reference_t&lt;Tuple&gt;&gt;&gt;{}
|);
}}。

如果
{{rrev|since=c++23|
* {{c|std::tuple_size_v&lt;std::remove_reference_t&lt;Tuple&gt;&gt;}} 是 {{c|1}}，并且 {{c multi
|std::reference_constructs_from_temporary_v&lt;
|    T, decltype(std::get&lt;0&gt;(std::declval&lt;Tuple&gt;()))&gt;}} 是 {{c|true}}，或者
}}
* {{c|std::is_constructible_v&lt;T, decltype(std::get&lt;I&gt;(std::declval&lt;Tuple&gt;()))...&gt;}} 是 {{c|false}}，
那么程序非良构。

===参数===
{{par begin}}
{{par|t|元素被用作 {{tt|T}} 构造函数的实参的元组}}
{{par end}}

===返回值===
构造的 {{tt|T}} 对象或引用。

===注解===
{{rev begin}}
{{rev|until=c++23|
{{tt|Tuple}} 不必是 {{lc|std::tuple}}，它可以被任何支持 {{ltt std|cpp/utility/tuple/get}} 和 {{ltt std|cpp/utility/tuple_size}} 的类型替代；特别是可以用 {{lc|std::array}} 和 {{lc|std::pair}}。
}}
{{rev|since=c++23|
{{tt|Tuple}} 被约束为元组式类型，即其中每个类型都必须是 {{lc|std::tuple}} 的特化，或者实现了 {{lti|cpp/utility/tuple/tuple-like}} 的其他任何类型（例如 {{lc|std::array}} 和 {{lc|std::pair}}）。
}}
{{rev end}}

因为[[cpp/language/copy_elision|受保证的复制消除]]，{{tt|T}} 不需要可移动。

{{feature test macro|__cpp_lib_make_from_tuple|{{tt|std::make_from_tuple}}|value=201606L|std=C++17}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;tuple&gt;

struct Foo
{
    Foo(int first, float second, int third)
    {
        std::cout &lt;&lt; first &lt;&lt; ", " &lt;&lt; second &lt;&lt; ", " &lt;&lt; third &lt;&lt; "\n";
    }
};

int main()
{
    auto tuple = std::make_tuple(42, 3.14f, 0);
    std::make_from_tuple&lt;Foo&gt;(std::move(tuple));
}
|output=
42, 3.14, 0
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3528|std=C++17|before=在一元组的情况下允许含有 {{c/core|reinterpret_cast}} 等的转型|after=已禁止}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc make_tuple}}
{{dsc inc|cpp/utility/tuple/dsc forward_as_tuple}}
{{dsc inc|cpp/utility/dsc apply}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}