{{cpp/title|strong_order}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|compare}}
{{dcl|since=c++20|1=
inline namespace /* 未指定 */ {
    inline constexpr /* 未指定 */ strong_order = /* 未指定 */;
}
}}
{{dcl h|调用签名}}
{{dcl|1=
template&lt; class T, class U &gt;
    requires /* 见下文 */
constexpr std::strong_ordering strong_order(T&amp;&amp; t, U&amp;&amp; u) noexcept(/* 见下文 */);
}}
{{dcl end}}

用三路比较比较两个值，并产生 {{rlpt|strong_ordering|std::strong_ordering}} 类型的结果。

设 {{c|t}} 与 {{c|u}} 为表达式，而 {{tt|T}} 与 {{tt|U}} 分别代表 {{c|decltype((t))}} 与 {{c|decltype((u))}}，那么 {{c|std::strong_order(t, u)}} [[cpp/language/expressions#表达式等价|表达式等价]]于：
* 如果 {{c|1=std::is_same_v&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;}} 是 {{c|true}}：
** {{c|std::strong_ordering(strong_order(t, u))}}，如果在不包含 {{tt|std::strong_order}} 的声明的语境中进行重载决议的情况下该表达式良构，
** 否则，如果 {{tt|T}} 是浮点类型：
*** 如果 {{c|std::numeric_limits&lt;T&gt;::is_iec559}} 是 {{c|true}}，那么进行浮点值的 ISO/IEC/IEEE 60559 ''totalOrder'' 比较并返回 {{rlpt|strong_ordering|std::strong_ordering}} 类型值作为结果（注意：此比较能区别正与负零，也能区分有不同表示的 NaN），
*** 否则，产生与 {{tt|T}} 的比较运算符所观察的顺序一致的 {{rlpt|strong_ordering|std::strong_ordering}} 类型的值，
** 否则是 {{c|1=std::strong_ordering(std::compare_three_way()(t, u))}}，如果它良构。
* 所有其他情况下，表达式非良构，在出现于模板实例化的立即语境时这会导致[[cpp/language/sfinae|代换失败]]。

{{cpp/ranges/cpo|std}}

====IEEE 浮点类型的严格全序====
令 {{c|x}} 和 {{c|y}} 为相同 IEEE 浮点类型的值，而 {{c|total_order_less(x, y)}} 为指示在 ISO/IEC/IEEE 60559 中的 ''totalOrder'' 所定义的严格全序中 {{c|x}} 是否前趋于 {{c|y}} 的布尔结果。

当且仅当 {{c|x}} 和 {{c|y}} 拥有同一位模式时，{{c|1=total_order_less(x, y) {{!!}} total_order_less(y, x) == false}}。

* 如果 {{c|x}} 和 {{c|y}} 都不是 NaN：
** 如果 {{c|x &lt; y}}，那么 {{c|1=total_order_less(x, y) == true}}；
** 如果 {{c|x &gt; y}}，那么 {{c|1=total_order_less(x, y) == false}}；
** 如果 {{c|1=x == y}}，
*** 如果 {{c|x}} 是负零且 {{c|y}} 是正零，那么 {{c|1=total_order_less(x, y) == true}}；
*** 如果 {{c|x}} 非零且 {{c|x}} 的指数域小于 {{c|y}} 的，那么 {{c|1=total_order_less(x, y) == (x &gt; 0)}}（仅对十进制浮点数有意义）；
* 如果 {{c|x}} 或 {{c|y}} 是 NaN：
** 如果 {{c|x}} 是负 NaN 且 {{c|y}} 不是负 NaN，那么 {{c|1=total_order_less(x, y) == true}}；
** 如果 {{c|x}} 不是正 NaN 且 {{c|y}} 是正 NaN，那么 {{c|1=total_order_less(x, y) == true}}；
** 如果 {{c|x}} 和 {{c|y}} 都是拥有相同符号的 NaN 且 {{c|x}} 的尾数域小于 {{c|y}} 的，那么 {{c|1=total_order_less(x, y) == !std::signbit(x)}}。

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/compare/dsc strong_ordering}}
{{dsc inc|cpp/utility/compare/dsc weak_order}}
{{dsc inc|cpp/utility/compare/dsc partial_order}}
{{dsc inc|cpp/utility/compare/dsc compare_strong_order_fallback}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}