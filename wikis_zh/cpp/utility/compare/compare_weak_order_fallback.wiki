{{cpp/title|compare_weak_order_fallback}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|compare}}
{{dcl|since=c++20|1=
inline namespace /* 未指定 */ {
    inline constexpr /* 未指定 */
        compare_weak_order_fallback = /* 未指定 */;
}
}}
{{dcl h|调用签名}}
{{dcl|since=c++20|1=
template&lt; class T, class U &gt;
    requires /* 见下文 */
constexpr std::weak_ordering
    compare_weak_order_fallback( T&amp;&amp; t, U&amp;&amp; u ) noexcept(/* 见下文 */);
}}
{{dcl end}}

进行[[cpp/language/expressions#完整表达式|子表达式]] {{c|t}} 与 {{c|u}} 上的三路比较并产生 {{ltt std|cpp/utility/compare/weak_ordering}} 类型的结果，即使运算符 {{tt|1=&lt;=&gt;}} 不可用。

如果 {{c/core|std::decay_t&lt;T&gt;}} 和 {{c/core|std::decay_t&lt;U&gt;}} 是相同的类型，那么 {{c|std::compare_weak_order_fallback(t, u)}} [[cpp/language/expressions#表达式等价|表达式等价]]于：
* {{c|std::weak_order(t, u)}}，如果它良构；
* 否则，如果表达式 {{c|1=t == u}} 和 {{c|t &lt; u}} 都良构，并且 {{c/core|1=decltype(t == u)}} 和 {{c/core|decltype(t &lt; u)}} 都实现 {{lti|cpp/concepts/boolean-testable}}，则是 {{c multi
|1=t == u ? std::weak_ordering::equivalent :
|2=t &lt; u  ? std::weak_ordering::less :
|3=         std::weak_ordering::greater
}}
: 但 {{c|t}} 和 {{c|u}} 都只会求值一次。

所有其他情况下 {{c|std::compare_weak_order_fallback(t, u)}} 都非良构，这能在出现于模板实例化的立即语境时导致[[cpp/language/sfinae|代换失败]]。

{{cpp/ranges/cpo|std}}

===示例===
{{example
|code=
#include &lt;compare&gt;
#include &lt;iostream&gt;

// 不支持 &lt;=&gt;
struct Rational_1
{
    int num;
    int den; // &gt; 0
};

inline constexpr bool operator&lt;(Rational_1 lhs, Rational_1 rhs)
{
    return lhs.num * rhs.den &lt; rhs.num * lhs.den;
}

inline constexpr bool operator==(Rational_1 lhs, Rational_1 rhs)
{
    return lhs.num * rhs.den == rhs.num * lhs.den;
}

// 支持 &lt;=&gt;
struct Rational_2
{
    int num;
    int den; // &gt; 0
};

inline constexpr std::weak_ordering operator&lt;=&gt;(Rational_2 lhs, Rational_2 rhs)
{
    return lhs.num * rhs.den &lt;=&gt; rhs.num * lhs.den;
}
 
void print(int id, std::weak_ordering value)
{
    std::cout &lt;&lt; id &lt;&lt; ") ";
    if (value == 0)
        std::cout &lt;&lt; "等于\n";
    else if (value &lt; 0)
        std::cout &lt;&lt; "小于\n";
    else
        std::cout &lt;&lt; "大于\n";
}

int main()
{
    Rational_1 a{1, 2}, b{3, 4};
//  print(1, a &lt;=&gt; b); // 不起效
    print(2, std::compare_weak_order_fallback(a, b)); // 起效，默认到 &lt; 和 ==
    
    Rational_2 c{6, 5}, d{8, 7};
    print(3, c &lt;=&gt; d); // 起效
    print(4, std::compare_weak_order_fallback(c, d)); // 起效
    
    Rational_2 e{2, 3}, f{4, 6};
    print(5, e &lt;=&gt; f); // 起效
    print(6, std::compare_weak_order_fallback(e, f)); // 起效
}
|output=
2) 小于
3) 大于
4) 大于
5) 等于
6) 等于
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2114|paper=P2167R3|std=C++20|before=后备机制仅要求返回类型可隐式转换到 {{c/core|bool}}|after=加强了约束}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/compare/dsc weak_order}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}