{{cpp/title|compare_strong_order_fallback}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|compare}}
{{dcl|since=c++20|1=
inline namespace /* 未指定 */ {
    inline constexpr /* 未指定 */
        compare_strong_order_fallback = /* 未指定 */;
}
}}
{{dcl h|调用签名}}
{{dcl|since=c++20|1=
template&lt; class T, class U &gt;
    requires /* 见下文 */
constexpr std::strong_ordering
    compare_strong_order_fallback( T&amp;&amp; t, U&amp;&amp; u ) noexcept(/* 见下文 */);
}}
{{dcl end}}

进行[[cpp/language/expressions#完整表达式|子表达式]] {{c|t}} 与 {{c|u}} 上的三路比较并产生 {{ltt std|cpp/utility/compare/strong_ordering}} 类型的结果，即使运算符 {{tt|1=&lt;=&gt;}} 不可用。

如果 {{c/core|std::decay_t&lt;T&gt;}} 和 {{c/core|std::decay_t&lt;U&gt;}} 是相同的类型，那么 {{c|std::compare_strong_order_fallback(t, u)}} [[cpp/language/expressions#表达式等价|表达式等价]]于：
* {{c|std::strong_order(t, u)}}，如果它良构；
* 否则，如果表达式 {{c|1=t == u}} 和 {{c|t &lt; u}} 都良构，并且 {{c/core|1=decltype(t == u)}} 和 {{c/core|decltype(t &lt; u)}} 都实现 {{lti|cpp/concepts/boolean-testable}}，则是 {{c multi
|1=t == u ? std::strong_ordering::equal :
|2=t &lt; u  ? std::strong_ordering::less :
|3=         std::strong_ordering::greater
}}
: 但 {{c|t}} 和 {{c|u}} 都只会求值一次。

所有其他情况下，{{c|std::compare_strong_order_fallback(t, u)}} 都非良构，这能在出现于模板实例化的立即语境时导致[[cpp/language/sfinae|代换失败]]。

{{cpp/ranges/cpo|std}}

===示例===
{{example}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2114|paper=P2167R3|std=C++20|before=后备机制仅要求返回类型可隐式转换到 {{c/core|bool}}|after=加强了约束}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/compare/dsc strong_order}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}