{{cpp/utility/basic_stacktrace/title|current}}
{{cpp/utility/basic_stacktrace/navbar}}
{{dcl begin}}
{{dcl | num=1 | since=c++23 | 1=
static basic_stacktrace current( const allocator_type&amp; alloc =
                                     allocator_type() ) noexcept;
}}
{{dcl | num=2 | since=c++23 | 1=
static basic_stacktrace current( size_type skip, const allocator_type&amp; alloc =
                                     allocator_type() ) noexcept;
}}
{{dcl | num=3 | since=c++23 | 1=
static basic_stacktrace current( size_type skip, size_type max_depth,
                                 const allocator_type&amp; alloc =
                                     allocator_type() ) noexcept;
}}
{{dcl end}}

令 {{c|s[i]}} (0 ≤ {{tt|''i''}} &lt; {{tt|''n''}}) 代表当前执行线程中当前求值的第 {{tt|''i''+1}} 个栈踪迹条目，其中 {{tt|''n''}} 为栈踪迹中的栈踪迹条目个数。

@1@ 尝试创建由 {{c|s[0]}}、{{c|s[1]}} …… {{c|s[n - 1]}} 组成的 {{tt|basic_stacktrace}}。

@2@ 尝试创建由 {{c|s[m]}}、{{c|s[m + 1]}} …… {{c|s[n - 1]}} 组成的 {{tt|basic_stacktrace}}，其中 {{tt|''m''}} 为 {{tt|min(skip, ''n'')}}。

@3@ 尝试创建由 {{c|s[m]}}、{{c|s[m + 1]}} …… {{c|s[o - 1]}} 组成的 {{tt|basic_stacktrace}}，其中 {{tt|''m''}} 为 {{tt|min(skip, ''n'')}} 而 {{tt|''o''}} 为 {{tt|min(skip + max_depth, ''n'')}}。若 {{c|skip + max_depth &lt; skip}}（即 {{c|skip + max_depth}} 的数学结果上溢）则行为未定义。

所有情况下，存储 {{tt|alloc}} 到创建的 {{tt|basic_stacktrace}} 中并用它分配栈踪迹条目的存储。

===参数===
{{par begin}}
{{par | alloc | 用于构造的 {{tt|basic_stacktrace}} 的所有内存分配的分配器}}
{{par | skip | 要跳过的栈踪迹条目个数}}
{{par | max_depth | 栈踪迹条目的最大深度}}
{{par end}}

===返回值===
若分配成功则为如上描述的 {{tt|basic_stacktrace}}。

否则为空的 {{tt|basic_stacktrace}}。

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc | cpp/utility/basic_stacktrace/dsc constructor}}
{{dsc inc | cpp/utility/source_location/dsc current}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}