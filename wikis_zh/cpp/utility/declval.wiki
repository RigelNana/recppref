{{cpp/title|declval}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|utility}}
{{dcl rev multi
|since1=c++11|notes1={{mark|仅不求值语境}}|dcl1=
template&lt; class T &gt;
typename std::add_rvalue_reference&lt;T&gt;::type declval() noexcept;
|since2=c++14|notes2={{mark|仅不求值语境}}|dcl2=
template&lt; class T &gt;
std::add_rvalue_reference_t&lt;T&gt; declval() noexcept;
}}
{{dcl end}}

用于在[[cpp/language/expressions#潜在求值表达式|不求值语境]]中编写表达式的辅助模板，通常为 [[cpp/language/decltype|{{tt|decltype}}]] 的操作数。在不求值语境中，这个辅助模板把任意类型 {{tt|T}}（可为不完整类型）转换为该类型的一个表达式，使得可以不经过构造函数即可使用 {{tt|T}} 的成员函数。

{{tt|std::declval}} 只能用于[[cpp/language/expressions#潜在求值表达式|不求值语境]]，且不要求有定义；求值包含这个函数的表达式会报错。正式而言，[[cpp/language/definition#ODR 式使用|ODR 式使用]]此函数的程序非良构。

===参数===
（无）

===返回值===
不可求值因而从不返回值。返回类型为 {{tt|T&amp;&amp;}}（适用引用折叠规则），除非 {{tt|T}} 是（可能 cv 限定的）{{c/core|void}}，此时返回类型为 {{tt|T}}。

===注解===
通常在模板中使用 {{tt|std::declval}}，模板接受的模板实参通常可能无构造函数，但有均返回所需类型的同一成员函数。

===可能的实现===
{{eq fun
|1=
template&lt;typename T&gt;
typename std::add_rvalue_reference&lt;T&gt;::type declval() noexcept
{
    static_assert(false, "declval 不允许出现于求值语境");
}
}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;utility&gt;

struct Default
{
    int foo() const { return 1; }
};

struct NonDefault
{
    NonDefault() = delete;
    int foo() const { return 1; }
};

int main()
{
    decltype(Default().foo())               n1 = 1;     // n1 的类型是 int
    decltype(std::declval&lt;Default&gt;().foo()) n2 = 1;     // 同上

//  decltype(NonDefault().foo())               n3 = n1; // 错误：无默认构造函数
    decltype(std::declval&lt;NonDefault&gt;().foo()) n3 = n1; // n3 的类型是 int
    std::cout &lt;&lt; "n1 = " &lt;&lt; n1 &lt;&lt; '\n'
              &lt;&lt; "n2 = " &lt;&lt; n2 &lt;&lt; '\n'
              &lt;&lt; "n3 = " &lt;&lt; n3 &lt;&lt; '\n';
}
|output=
n1 = 1
n2 = 1
n3 = 1
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/language/dsc decltype}}
{{dsc inc|cpp/types/dsc result_of}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}