{{title|标准格式说明 {{mark since c++20}}}}
{{cpp/utility/format/navbar}}

对于基本类型和字符串类型，格式说明基于 [https://docs.python.org/3/library/string.html#formatspec Python 中的格式说明]。

格式说明的语法是：
{{sdsc begin}}
{{sdsc|
{{spar optional|填充与对齐}} {{spar optional|正负号}} {{ttb|#}}{{mark optional}} {{ttb|0}}{{mark optional}} {{spar optional|宽度}} {{spar optional|精度}} {{ttb|L}}{{mark optional}} {{spar optional|类型}}
}}
{{sdsc end}}

{{spar|正负号}}、{{ttb|#}} 及 {{ttb|0}} 选项只有在使用整数或浮点数显示类型时合法。

===填充与对齐===
{{spar sep|填充与对齐}}是一个可选的''填充''字符（可以是除 {{ttb|{}} 和 {{ttb|}&lt;!----&gt;}} 以外的任何字符），后随''对齐''{{sep}}选项 {{ttb|&lt;}}、{{ttb|&gt;}}、{{ttb|^}} 之一。

如果未指定填充字符，则缺省为空格字符。对于 Unicode 编码的格式说明，填充字符必须对应于单个 Unicode 标量值。

''对齐''{{sep}}选项的意义如下：

* {{ttb|&lt;}}：强制格式化的实参对齐到可用空间开头，通过在格式化的实参的后面插入 {{math|n}} 个字符。这是使用非整数非浮点数显示类型时的默认选项。
* {{ttb|&gt;}}：强制格式化的实参对齐到可用空间末尾，通过在格式化的实参的前面插入 {{math|n}} 个字符。这是使用整数或浮点数显示类型时的默认选项。
* {{ttb|^}}：强制格式化的实参在可用空间中央，通过在格式化的实参的前面插入 {{math|⌊{{mfrac|n|2}}⌋}} 个字符，后面插入 {{math|⌈{{mfrac|n|2}}⌉}} 个字符。

在所有情况下，{{math|n}} 是最小域宽（以 {{spar|宽度}} 指定）和格式化的实参的[[#宽度估计|预计宽度]]的差，或者在差小于 0 时是 0。

{{example
|code=
#include &lt;cassert&gt;
#include &lt;format&gt;

int main()
{
    char c = 120;
    assert(std::format("{:6}", 42)    == "    42");
    assert(std::format("{:6}", 'x')   == "x     ");
    assert(std::format("{:*&lt;6}", 'x') == "x*****");
    assert(std::format("{:*&gt;6}", 'x') == "*****x");
    assert(std::format("{:*^6}", 'x') == "**x***");
    assert(std::format("{:6d}", c)    == "   120");
    assert(std::format("{:6}", true)  == "true  ");
}
}}

{{anchor|正负号}}

===正负号、# 与 0===
{{spar sep|正负号}}选项可以是下列之一：
* {{ttb|+}}：指示应该对于非负数和负数都使用正负号。在非负数的输出值前插入 {{tt|+}} 号。
* {{ttb|-}}：指示应该仅对于负数使用正负号（这是默认行为）。
* 空格：指示应对非负数使用一个前导空格，而对负数使用负号。

负零被当作负数。

{{spar sep|正负号}}选项适用于浮点数无穷大和 NaN。

{{example
|code=
#include &lt;cassert&gt;
#include &lt;format&gt;
#include &lt;limits&gt;

int main()
{
    double inf = std::numeric_limits&lt;double&gt;::infinity();
    double nan = std::numeric_limits&lt;double&gt;::quiet_NaN();
    assert(std::format("{0:},{0:+},{0:-},{0: }", 1)   == "1,+1,1, 1");
    assert(std::format("{0:},{0:+},{0:-},{0: }", -1)  == "-1,-1,-1,-1");
    assert(std::format("{0:},{0:+},{0:-},{0: }", inf) == "inf,+inf,inf, inf");
    assert(std::format("{0:},{0:+},{0:-},{0: }", nan) == "nan,+nan,nan, nan");
}
}}

{{ttb|#}} 选项导致将''代用形式''{{sep}}用于转换。
* 对于整数类型，使用二进制、八进制或十六进制显示类型时，代用形式会在有正负号字符（可以是空格）时将前缀（{{tt|0b}}、{{tt|0}} 或 {{tt|0x}}）插入到输出值中正负号字符之后，否则将前缀插入到输出值之前。
* 对于浮点数类型，代用形式导致转换有限值的结果始终含有小数点字符，即使它后面没有数位。正常情况下，小数点字符只有在它后面有数位时才会在转换结果出现。另外，对于 {{ttb|g}} 与 {{ttb|G}} 转换，不会从结果移除尾随的零。

{{ttb|0}} 选项（在任何正负号或底之后）以前导零填充域到域宽，除了应用到无穷大或 NaN 时。如果 {{tt|0}} 字符与''对齐''{{sep}}选项一同出现，那么忽略 {{tt|0}} 字符。

{{example
|code=
#include &lt;cassert&gt;
#include &lt;format&gt;

int main()
{
    char c = 120;
    assert(std::format("{:+06d}", c)   == "+00120");
    assert(std::format("{:#06x}", 0xa) == "0x000a");
    assert(std::format("{:&lt;06}", -42)  == "-42   "); // 因 '&lt;' 对齐忽略 0
}
}}

===宽度与精度===
{{spar sep|宽度}}是一个正十进制数或嵌套的替换域（{{ttb|{}&lt;!----&gt;}} 或 {{ttb|{}}''n''{{sep}}{{ttb|}&lt;!----&gt;}}）。它存在的情况下会指定最小域宽。

{{spar sep|精度}}是点（{{ttb|.}}）后随非负十进制数或嵌套的替换域。此域指示精度或最大域大小。它只能用于浮点数与字符串类型。
* 对于浮点数类型，此域指定格式化精度。
* 对于字符串类型，它提供要复制到输出的字符串前缀的估计宽度（见[[#宽度估计|下文]]）的上界。对于以 Unicode 编码的字符串，复制到输出的文本是整个扩展字素集群的，使得估计宽度不大于精度的最长前缀。

如果{{spar sep|宽度}}或{{spar sep|精度}}中使用嵌套的替换域，而对应的实参不是{{rev inl|until=c++23|[[cpp/language/type|整数类型]]}}{{rev inl|since=c++23|[[cpp/language/type|标准有符号或无符号整数类型]]}}，为负，或对于{{spar sep|宽度}}为零，那么就会抛出 {{lc|std::format_error}} 类型的异常。

{{source|1=
float pi = 3.14f;
assert(std::format("{:10f}", pi)           == "  3.140000"); // 宽度 = 10
assert(std::format("{:{}f}", pi, 10)       == "  3.140000"); // 宽度 = 10
assert(std::format("{:.5f}", pi)           == "3.14000");    // 精度 = 5
assert(std::format("{:.{}f}", pi, 5)       == "3.14000");    // 精度 = 5
assert(std::format("{:10.5f}", pi)         == "   3.14000"); // 宽度 = 10, 精度 = 5
assert(std::format("{:{}.{}f}", pi, 10, 5) == "   3.14000"); // 宽度 = 10, 精度 = 5

auto b1 = std::format("{:{}f}", pi, 10.0); // 抛出：宽度不是整数类型
auto b2 = std::format("{:{}f}", pi, -10);  // 抛出：宽度为负
auto b3 = std::format("{:.{}f}", pi, 5.0); // 抛出：精度不是整数类型
}}

{{anchor|宽度估计}}
对于字符串类型，宽度定义为适合将它显示到终端的估计列位置个数。

就宽度计算目的，假设字符串用实现定义的编码。未指定宽度计算的方法，但对于以 Unicode 的字符串，实现应该估计字符串的宽度为它的扩展字素集群中首个码位的估计宽度之和。如果 Unicode 码位在下列范围内，那么估计宽度是 2，否则是 1：

* 任意 Unicode 属性 [https://www.unicode.org/reports/tr44/#East_Asian_Width {{tt|East_Asian_Width}}] 具有值 Fullwidth ({{tt|F}}) 或 Wide ({{tt|W}}) 的代码点
* U+4DC0 – U+4DFF（易经六十四卦像）
* U+1F300 – U+1F5FF（杂项符号和象形文字）
* U+1F900 – U+1F9FF（补充符号和象形文字）

{{example
|code=
#include &lt;cassert&gt;
#include &lt;format&gt;

int main()
{
    assert(std::format("{:.^5s}",   "🐱")    == ".🐱..");
    assert(std::format("{:.5s}",    "🐱🐱🐱") == "🐱🐱");
    assert(std::format("{:.&lt;5.5s}", "🐱🐱🐱") == "🐱🐱.");
}
}}

{{anchor|L}}
===L（本地环境特定的格式化）===
{{ttb|L}} 选项导致使用本地环境特定的形式。此选项仅对算术类型合法。

* 对于整数类型，本地环境特定形式会按照上下文的本地环境插入适合的数位组分隔字符。
* 对于浮点数类型，本地环境特定形式会按照上下文的本地环境插入适合的数位组和基数分隔字符。
* 对于 {{c/core|bool}} 的文本表示，本地环境特定形式使用如同通过 {{lc|std::numpunct::truename}} 或 {{lc|std::numpunct::falsename}} 获得的字符串。

===类型===
{{spar sep|类型}}选项确定应该如何显示数据。

可用的字符串显示类型有：
* 无、{{ttb|s}}：复制字符串到输出。
{{rrev|since=c++23|
* {{ttb|?}}：复制转义后的字符串（见[[#格式化经转义字符和字符串|下文]]）到输出。
}}

可用的 {{c/core|char}}、{{c/core|wchar_t}} 与 {{c/core|bool}} 以外的整数类型的整数显示类型有：
* {{ttb|b}}：二进制格式。如同通过调用 {{c|std::to_chars(first, last, value, 2)}} 产生输出。底前缀是 {{tt|0b}}。
* {{ttb|B}}：同 {{ttb|b}}，但底前缀是 {{tt|0B}}。
* {{ttb|c}}：复制字符 {{c|static_cast&lt;CharT&gt;(value)}} 到输出，其中 {{c|CharT}} 是格式字符串的字符类型。如果值不在 {{tt|CharT}} 的可表示值的范围中，那么就会抛出 {{lc|std::format_error}}。
* {{ttb|d}}：十进制格式。如同通过调用 {{c|std::to_chars(first, last, value)}} 产生输出。
* {{ttb|o}}：八进制格式。如同通过调用 {{c|std::to_chars(first, last, value, 8)}} 产生输出。如果对应实参值非零，那么底前缀是 {{tt|0}}，否则为空。
* {{ttb|x}}：十六进制格式。如同通过调用 {{c|std::to_chars(first, last, value, 16)}} 产生输出。底前缀是 {{tt|0x}}。
* {{ttb|X}}：同 {{ttb|x}}，但对 9 以上的数字使用大写字母且底前缀是 {{tt|0X}}。
* 无：同 {{ttb|d}}。

可用的 {{c/core|char}} 和 {{c/core|wchar_t}} 表示类型有：
* 无、{{ttb|c}}：复制字符到输出。
* {{ttb|b}}、{{ttb|B}}、{{ttb|d}}、{{ttb|o}}、{{ttb|x}}、{{ttb|X}}：使用值分别为 {{c|static_cast&lt;unsigned char&gt;(value)}} 或 {{c|static_cast&lt;std::make_unsigned_t&lt;wchar_t&gt;&gt;(value)}} 的整数表示类型。
{{rrev|since=c++23|
* {{ttb|?}}：复制经转义字符（见[[#格式化经转义字符和字符串|下文]]）到输出。
}}

可用的 {{c/core|bool}} 表示类型有：
* 无、{{ttb|s}}：复制文本表示（{{ttb|true}} 或 {{ttb|false}} 或本地环境特定形式）到输出。
* {{ttb|b}}、{{ttb|B}}、{{ttb|c}}、{{ttb|d}}、{{ttb|o}}、{{ttb|x}}、{{ttb|X}}：以值 {{c|static_cast&lt;unsigned char&gt;(value)}} 使用整数表示类型。

可用的浮点数表示类型有：
* {{ttb|a}}：如果有指定''精度''，那么如同通过调用 {{c|std::to_chars(first, last, value, std::chars_format::hex, precision)}} 产生输出，其中 {{c|precision}} 是指定的精度，否则如同通过 {{c|std::to_chars(first, last, value, std::chars_format::hex)}} 产生输出。
* {{ttb|A}}：同 {{ttb|a}}，但对 9 以上的数字使用大写字母并用 {{tt|P}} 指示指数。
* {{ttb|e}}：如同通过调用 {{c|std::to_chars(first, last, value, std::chars_format::scientific, precision)}} 产生输出，其中 {{c|precision}} 是指定的精度，或者在未指定精度时是 6。
* {{ttb|E}}：同 {{ttb|e}}，但用 {{tt|E}} 指示指数。
* {{ttb|f}}、{{ttb|F}}：如同通过调用 {{c|std::to_chars(first, last, value, std::chars_format::fixed, precision)}} 产生输出，其中 {{c|precision}} 是指定的精度，或者在未指定精度时是 6。
* {{ttb|g}}：如同通过调用 {{c|std::to_chars(first, last, value, std::chars_format::general, precision)}} 产生输出，其中 {{c|precision}} 是指定的精度，或者在未指定精度时是 6。
* {{ttb|G}}：同 {{ttb|g}}，但用 {{tt|E}} 指示指数。
* 无：如果有指定''精度''，那么如同通过调用 {{c|std::to_chars(first, last, value, std::chars_format::general, precision)}} 产生输出，其中 {{c|precision}} 为指定的精度；否则如同通过调用 {{c|std::to_chars(first, last, value)}} 产生输出。

对于小写表示类型，分别格式化无穷大和 NaN 为 {{tt|inf}} 与 {{tt|nan}}。
对于大写表示类型，分别格式化无穷大和 NaN 为 {{tt|INF}} 与 {{tt|NAN}}。

可用的指针表示类型（也用于 {{lc|std::nullptr_t}}）有：
* 无、{{ttb|p}}：如果定义了 {{lc|std::uintptr_t}}，那么如同通过调用 {{c|std::to_chars(first, last, reinterpret_cast&lt;std::uintptr_t&gt;(value), 16)}} 产生输出，并添加前缀 {{tt|0x}} 到输出；否则输出由实现定义。
{{rrev|since=c++26|
* {{ttb|P}}：与 {{ttb|p}} 相同，但 9 以上的数位会以大写字母表示，并且底前缀变为 {{tt|0X}}。
}}


{{rrev|since=c++23|
===格式化经转义字符和字符串===
字符或字符串可以在格式化时进行''转义''{{sep}}，适合用于调试或记录日志。

转义通过以下方式进行：

* 对于每个良构的编码了字符 ''C'' 的代码单元序列：
:* 如果 ''C'' 是下表中的字符之一，那么使用对应的转义序列：

{{cpp/utility/format/spec/escape}}

:* 否则，如果 ''C'' 不是空格字符（ASCII 编码中是字节 0x20），并且要么
::* 关联的字符编码是 Unicode 编码，并且
:::* ''C'' 对应的 Unicode 标量具有的 Unicode 属性 [https://www.unicode.org/reports/tr44/#General_Category_Values {{tt|General_Category}}] 是 {{tt|Separator}} ({{tt|Z}}) 或 {{tt|Other}} ({{tt|C}}) 两个组中的某个值，或者
:::* ''C'' 没有紧接在非转义字符之后，并且 ''C'' 对应的 Unicode 标量具有的 Unicode 属性 {{tt|1=Grapheme_Extend=Yes}}，要么
::* 关联的字符编码不是 Unicode 编码，并且 ''C'' 是由实现定义的不可打印字符集合中的字符，
:: 那么转义序列是 {{ttb|\u{}}''十六进制数位转义序列''{{sep}}{{ttb|}&lt;!----&gt;}}，其中''十六进制数位转义序列''{{sep}}是 ''C'' 使用小写十六进制数位的最短十六进制表示。
:* 否则，''C'' 按原样复制。
* 未指定代码单元序列是移位序列时对输出和后续对字符串的解码造成的影响。
* 每个其他代码单元（即在非良构代码单元序列中的代码单元）都会替换成 {{ttb|\x{}}''十六进制数位转义序列''{{sep}}{{ttb|}&lt;!----&gt;}}，其中''十六进制数位转义序列''{{sep}}是代码单元使用小写十六进制数位的最短十六进制表示。

字符串的转义字符串表示会通过以上述方式对字符串中的代码单元序列进行转义来构造，并且用双引号包围结果。

字符的转义表示会通过以上述方式对它进行转义来构造，并且用单引号包围结果。

{{example
|[https://godbolt.org/z/WxhTs6b69 Compiler Explorer demo]:
|code=
#include &lt;print&gt;

int main()
{
    std::println("[{:?}]", "h\tllo");             // 打印: ["h\tllo"]
    std::println("[{:?}]", "Спасибо, Виктор ♥!"); // 打印: ["Спасибо, Виктор ♥!"]
    std::println("[{:?}] [{:?}]", '\'', '"');     // 打印: ['\'', '"']

    // 以下示例假定使用 UTF-8 编码
    std::println("[{:?}]", std::string("\0 \n \t \x02 \x1b", 9));
                                             // 打印: ["\u{0} \n \t \u{2} \u{1b}"]
    std::println("[{:?}]", "\xc3\x28");      // 无效 UTF-8
                                             // 打印: ["\x{c3}("]
    std::println("[{:?}]", "\u0301");        // 打印: ["\u{301}"]
    std::println("[{:?}]", "\\\u0301");      // 打印: ["\\\u{301}"]
    std::println("[{:?}]", "e\u0301\u0323"); // 打印: ["ẹ́"]
}
}}
}}

===注解===
大多数情况下，这个语法与老式的 {{ttb|%}} 格式化类似，添加了 {{ttb|{}&lt;!----&gt;}} 并用 {{ttb|:}} 取代 {{ttb|%}}。例如，{{c/core|'%03.2f'}} 可被翻译成 {{c/core|'{:03.2f}'}}。

{{ftm begin}}
{{ftm|__cpp_lib_format_uchar|格式化编码单元为无符号整数|std=C++20|dr=yes|value=202311L}}
{{ftm end}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3721|std=C++20|before=标准格式说明中不允许指定域宽为零|after=可以通过替换域指定}}
{{dr list item|paper=P2909R4|std=C++20|before={{c/core|char}} 或 {{c/core|wchar_t}} 可能被格式化为范围外的无符号整数值|after=在这种格式化前将编码单元转换为对应的无符号类型}}
{{dr list end}}

{{langlinks|en|es|ja|ru}}