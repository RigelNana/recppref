{{cpp/title|tuple_size}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|tuple}}
{{dcl header|utility}}
{{dcl header|array}}
{{dcl header|ranges|notes={{mark since c++20}}}}
{{dcl header|complex|notes={{mark since c++26}}}}
{{dcl|num=1|since=c++11|1=
template&lt; class T &gt;
struct tuple_size; // 不定义
}}
{{dcl|num=2|since=c++11|1=
template&lt; class T &gt;
struct tuple_size&lt; const T &gt;
    : std::integral_constant&lt;std::size_t, std::tuple_size&lt;T&gt;::value&gt; {};
}}
{{dcl|num=3|since=c++11|deprecated=c++20|1=
template&lt; class T &gt;
struct tuple_size&lt; volatile T &gt;
    : std::integral_constant&lt;std::size_t, std::tuple_size&lt;T&gt;::value&gt; {};
}}
{{dcl|num=4|since=c++11|deprecated=c++20|1=
template&lt; class T &gt;
struct tuple_size&lt; const volatile T &gt;
    : std::integral_constant&lt;std::size_t, std::tuple_size&lt;T&gt;::value&gt; {};
}}
{{dcl end}}

提供对{{lt|cpp/utility/tuple/tuple-like|元组式}}类型中元素个数的访问，作为编译时常量表达式。

@1@ 不定义主模板。为使类型成为元组式，要求进行显式（全）或部分特化。

@2-4@ 对 cv 限定类型的特化，默认复用对应 cv 无限定版本的 {{c|value}}。

{{rrev|since=c++17|
{{tt|std::tuple_size}} 与核心语言交互：它为元组式类型提供[[cpp/language/structured binding|结构化绑定]]支持。

{{v|2-4}} 是 SFINAE 友好的：若 {{c|std::tuple_size&lt;T&gt;::value}} 在作为不求值操作数时非良构，则它们不提供成员 {{c|value}}。访问检查如同在与 {{tt|tuple_size}} 和 {{tt|T}} 无关的场景中进行。仅考虑表达式的立即语境的合法性。这允许
{{source|1=
#include &lt;utility&gt;

struct X { int a, b; };
const auto [x, y] = X(); // 结构化绑定声明首先尝试 tuple_size&lt;const X&gt;，这会尝试使用
                         // tuple_size&lt;X&gt;::value，然后遇到软错误，绑定到公开数据成员
}}
}}

===特化===
标准库为标准库类型提供下列特化：
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc tuple_size}}
{{dsc inc|cpp/utility/pair/dsc tuple_size}}
{{dsc inc|cpp/container/array/dsc tuple_size}}
{{dsc inc|cpp/ranges/subrange/dsc tuple_size}}
{{dsc inc|cpp/numeric/complex/dsc tuple_size}}
{{dsc end}}

{{tt|std::tuple_size}} 的所有特化都满足''基特征''对于某个 {{tt|N}} 为 {{c|std::integral_constant&lt;std::size_t, N&gt;}} 的{{named req|UnaryTypeTrait}}。

用户可以对程序定义类型特化 {{tt|std::tuple_size}} 以令它们为元组式。程序定义特化必须满足上述要求。

通常只需要自定义针对无 cv 限定类型的特化。

===辅助变量模板===
{{ddcl|header=tuple|since=c++17|1=
template&lt; class T &gt;
constexpr std::size_t tuple_size_v = tuple_size&lt;T&gt;::value;
}}

{{cpp/types/integral_constant/inherit2|对于标准特化，为元组式类型 {{tt|T}} 的元素个数|std::size_t}}

===示例===
{{example
|code=
#include &lt;array&gt;
#include &lt;cstddef&gt;
#include &lt;ranges&gt;
#include &lt;tuple&gt;
#include &lt;utility&gt;

template&lt;class T, std::size_t Size&gt; struct Arr { T data[Size]; };

// 程序定义的 std::tuple_size 特化：
template&lt;class T, std::size_t Size&gt; struct std::tuple_size&lt;Arr&lt;T, Size&gt;&gt;
    : public integral_constant&lt;std::size_t, Size&gt; {};

int main()
{
    using tuple1 = std::tuple&lt;int, char, double&gt;;
    static_assert(3 == std::tuple_size_v&lt;tuple1&gt;); // 使用变量模板 (C++17)

    using array3x4 = std::array&lt;std::array&lt;int, 3&gt;, 4&gt;;
    static_assert(4 == std::tuple_size&lt;array3x4&gt;{}); // 使用 operator std::size_t

    using pair = std::pair&lt;tuple1, array3x4&gt;;
    static_assert(2 == std::tuple_size&lt;pair&gt;()); // 使用 operator()

    using sub = std::ranges::subrange&lt;char*, char*&gt;;
    static_assert(2 == std::tuple_size&lt;sub&gt;::value);

    using Arr5 = Arr&lt;int, 5&gt;;
    static_assert(5 == std::tuple_size_v&lt;Arr5&gt;);
}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2212|std=C++11|before=未在某些头文件中要求对 cv 类型的特化，这导致歧义|after=已要求}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/language/dsc structured binding}}
{{dsc inc|cpp/utility/dsc tuple_element}}
{{dsc inc|cpp/utility/tuple/dsc tuple_cat}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}