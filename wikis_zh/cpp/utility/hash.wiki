{{cpp/title|hash}}
{{cpp/utility/hash/navbar}}

{{dcl begin}}
{{dcl header|bitset}}
{{dcl header|coroutine}}
{{dcl header|chrono|notes={{mark since c++26}}}}
{{dcl header|filesystem}}
{{dcl header|functional}}
{{dcl header|memory}}
{{dcl header|optional}}
{{dcl header|stacktrace}}
{{dcl header|string}}
{{dcl header|string_view}}
{{dcl header|system_error}}
{{dcl header|text_encoding}}
{{dcl header|thread}}
{{dcl header|typeindex}}
{{dcl header|variant}}
{{dcl header|vector}}
{{dcl|since=c++11|
template&lt; class Key &gt;
struct hash;
}}
{{dcl end}}

无序关联容器 {{lc|std::unordered_set}}、{{lc|std::unordered_multiset}}、{{lc|std::unordered_map}}、{{lc|std::unordered_multimap}} 以模板 {{tt|std::hash}} 的特化为默认散列函数。

给定类型 {{tt|Key}}，每个特化 {{tt|std::hash&lt;Key&gt;}} 要么被''启用''，要么被''禁用''：
* 如果程序和用户都没有提供 {{tt|std::hash&lt;Key&gt;}}，那么它被禁用。
* 否则，{{tt|std::hash&lt;Key&gt;}} 在满足以下所有条件时被启用：
:* 满足以下所有要求：
::* {{named req|Hash}}（以 {{tt|Key}} 作为函数调用实参类型）
::* {{named req|DefaultConstructible}}
::* {{named req|CopyAssignable}}
::* {{named req|Swappable}}
:* 给定以下值：
::* {{c|h}}，{{tt|std::hash&lt;Key&gt;}} 类型的对象。
::* {{c|k1}} 和 {{c|k2}}，{{tt|Key}} 类型的对象。
:: 满足以下所有要求：
::* 如果 {{c|1=k1 == k2}} 是 {{c|true}}，那么 {{c|1=h(k1) == h(k2)}} 也是 {{c|true}}。
::* 除非 {{tt|std::hash&lt;Key&gt;}} 是[[cpp/language/type#由程序定义的类型|由程序定义的特化]]，那么 {{c|h(k1)}} 不会抛出异常。
* 否则，{{tt|std::hash&lt;Key&gt;}} 被禁用。

被禁用的特化不满足{{named req|Hash}}，不满足{{named req|FunctionObject}}，并且下列值都是 {{c|false}}：
* {{c|std::is_default_constructible&lt;std::hash&lt;Key&gt;&gt;::value}}
* {{c|std::is_copy_constructible&lt;std::hash&lt;Key&gt;&gt;::value}}
* {{c|std::is_move_constructible&lt;std::hash&lt;Key&gt;&gt;::value}}
* {{c|std::is_copy_assignable&lt;std::hash&lt;Key&gt;&gt;::value}}
* {{c|std::is_move_assignable&lt;std::hash&lt;Key&gt;&gt;::value}}

也就是说，它们存在但无法使用。

{{rrev|until=c++20|
===嵌套类型===
{{dsc begin}}
{{dsc hitem|名字|定义}}
{{dsc|{{tt|argument_type}} {{mark deprecated c++17}}|{{tt|Key}}}}
{{dsc|{{tt|result_type}} {{mark deprecated c++17}}|{{lc|std::size_t}}}}
{{dsc end}}
}}

===成员函数===
{{dsc begin}}
{{dsc mem ctor|cpp/utility/hash/hash|构造散列函数对象}}
{{dsc mem fun|cpp/utility/hash/operator()|计算实参的散列值}}
{{dsc end}}

===标准库特化===
每个声明了模板 {{tt|std::hash}} 的标头也会为以下类型提供 {{tt|std::hash}} 的被启用特化：
* 所有无 cv 限定的[[cpp/language/types|算术类型]]
* 所有无 cv 限定的[[cpp/language/enum|枚举类型]]
* 所有无 cv 限定的[[cpp/language/pointer|指针类型]]
* {{lc|std::nullptr_t}}

此外，部分标头也会为库类型提供 {{tt|std::hash}} 的其他被启用特化（见[[#库类型特化|下文]]）。

{{rrev|since=c++17|&lt;!-- P0599R1，P0636R2 中不是 DR --&gt;
对于标准库提供的除以下特化外的 {{tt|std::hash}} 特化，它们的成员函数都是 {{c/core|noexcept}} 的：
* {{ltt|cpp/utility/optional/hash|std::hash&lt;std::optional&gt;}}
* {{ltt|cpp/utility/variant/hash|std::hash&lt;std::variant&gt;}}
* {{ltt|cpp/memory/unique_ptr/hash|std::hash&lt;std::unique_ptr&gt;}}
{{rrev|since=c++26|
* {{ltt|cpp/chrono/duration/hash|std::hash&lt;std::chrono::duration&gt;}}
* {{ltt|cpp/chrono/time_point/hash|std::hash&lt;std::chrono::time_point&gt;}}
* {{ltt|cpp/chrono/zoned_time/hash|std::hash&lt;std::chrono::zoned_time&gt;}}
}}
}}

===库类型特化===
{{dsc begin}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc hash}}
{{dsc inc|cpp/error/error_code/dsc hash}}
{{dsc inc|cpp/error/error_condition/dsc hash}}
{{dsc inc|cpp/utility/stacktrace_entry/dsc hash}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc hash}}
{{dsc inc|cpp/utility/optional/dsc hash}}
{{dsc inc|cpp/utility/variant/dsc hash}}
{{dsc ptclass|cpp/utility/variant/monostate#辅助类|title=std::hash{{dsc small|&lt;std::monostate&gt;}}|notes={{mark c++17}}|{{lc|std::monostate}} 的散列支持}}
{{dsc inc|cpp/utility/bitset/dsc hash}}
{{dsc inc|cpp/memory/unique_ptr/dsc hash}}
{{dsc inc|cpp/memory/shared_ptr/dsc hash}}
{{dsc inc|cpp/types/type_index/dsc hash}}
{{dsc inc|cpp/string/basic_string/dsc hash}}
{{dsc inc|cpp/string/basic_string_view/dsc hash}}
{{dsc inc|cpp/text/text_encoding/dsc hash}}
{{dsc ptclass|cpp/container/vector bool/hash|title=std::hash{{dsc small|&lt;std::vector&lt;bool&gt;&gt;}}|{{ltt|cpp/container/vector bool|std::vector&lt;bool&gt;}} 的散列支持|notes={{mark c++11}}}}
{{dsc inc|cpp/filesystem/path/dsc hash}}
{{dsc inc|cpp/thread/thread/id/dsc hash}}
{{dsc hash|cpp/chrono/duration|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/time_point|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/day|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/month|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/year|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/weekday|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/weekday_indexed|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/weekday_last|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/month_day|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/month_day_last|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/month_weekday|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/month_weekday_last|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/year_month|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/year_month_day|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/year_month_day_last|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/year_month_weekday|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/year_month_weekday_last|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/zoned_time|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/leap_second|nested=true|notes={{mark c++26}}}}
{{dsc end}}

===注解===
除了上述指定的情况外，散列函数的实现方由实现定义。（比如，gcc 的[https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/src/c%2B%2B11/hashtable_c%2B%2B0x.cc 实现]）。需要注意，某些散列函数的实现过于简单，甚至是直接将对象映射至自身。这可能会造成严重的后果。换言之，这些散列函数可以用于无序关联容器，但它们不一定安全/抗碰撞。

散列函数仅要求在程序的单次执行中对同样的输入返回同样的结果；这允许采用避免碰撞拒绝服务攻击的加盐散列。

没有对 C 字符串的特化。{{c/core|std::hash&lt;const char*&gt;}} 产生指针值（内存地址）的散列值，它不检验任何字符数组的内容。

对 {{lc|std::pair}} 和标准容器类型的特化，还有组合散列的工具函数可以参考 [https://www.boost.org/doc/libs/release/doc/html/hash/reference.html boost.hash]。

===示例===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;

struct S
{
    std::string first_name;
    std::string last_name;
    bool operator==(const S&amp;) const = default; // C++20 起
};

// C++20 前
// bool operator==(const S&amp; lhs, const S&amp; rhs)
// {
//     return lhs.first_name == rhs.first_name &amp;&amp; lhs.last_name == rhs.last_name;
// }

// 自定义散列函数可以是独立函数对象：
struct MyHash
{
    std::size_t operator()(S const&amp; s) const 
    {
        std::size_t h1 = std::hash&lt;std::string&gt;{}(s.first_name);
        std::size_t h2 = std::hash&lt;std::string&gt;{}(s.last_name);
        return h1 ^ (h2 &lt;&lt; 1); // 或者使用 boost::hash_combine
    }
};

// std::hash 的自定义特化能注入命名空间 std 中
template&lt;&gt;
struct std::hash&lt;S&gt;
{
    std::size_t operator()(const S&amp; s) const noexcept
    {
        std::size_t h1 = std::hash&lt;std::string&gt;{}(s.first_name);
        std::size_t h2 = std::hash&lt;std::string&gt;{}(s.last_name);
        return h1 ^ (h2 &lt;&lt; 1); // 或者使用 boost::hash_combine
    }
};

int main()
{
    std::string str = "Meet the new boss...";
    std::size_t str_hash = std::hash&lt;std::string&gt;{}(str);
    std::cout &lt;&lt; "hash(" &lt;&lt; std::quoted(str) &lt;&lt; ") = " &lt;&lt; str_hash &lt;&lt; '\n';
    
    S obj = {"Hubert", "Farnsworth"};
    // 使用独立的函数对象
    std::cout &lt;&lt; "hash(" &lt;&lt; std::quoted(obj.first_name) &lt;&lt; ", "
              &lt;&lt; std::quoted(obj.last_name) &lt;&lt; ") = "
              &lt;&lt; MyHash{}(obj) &lt;&lt; "（使用 MyHash）\n" &lt;&lt; std::setw(31) &lt;&lt; "或 "
              &lt;&lt; std::hash&lt;S&gt;{}(obj) &lt;&lt; "（使用注入的特化）\n";
    
    // 自定义散列函数令在无序容器中使用自定义类型可行。
    // 此示例将使用注入的 std::hash 特化，
    // 如果要使用 MyHash 替代，那么将它作为第二模板参数传递。
    std::unordered_set&lt;S&gt; names = {obj, {"Bender", "Rodriguez"}, {"Turanga", "Leela"}&lt;!----&gt;};
    for (auto const&amp; s: names)
        std::cout &lt;&lt; std::quoted(s.first_name) &lt;&lt; ' '
                  &lt;&lt; std::quoted(s.last_name) &lt;&lt; '\n';
}
|p=true
|output=
hash("Meet the new boss...") = 1861821886482076440
hash("Hubert", "Farnsworth") = 17622465712001802105（使用 MyHash）
                            或 17622465712001802105（使用注入的特化） 
"Turanga" "Leela"
"Bender" "Rodriguez"
"Hubert" "Farnsworth"
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2119|std=C++11|before=缺失扩展整数类型的特化|after=已提供}}
{{dr list item|wg=lwg|dr=2148|std=C++11|before=缺失对枚举的特化|after=已提供}}
{{dr list item|wg=lwg|dr=2543|std=C++11|before={{tt|std::hash}} 可能不是 SFINAE 友好的|after=使之为 SFINAE 友好}}
{{dr list item|wg=lwg|dr=2817|std=C++11|before=缺失对 {{lc|std::nullptr_t}} 的特化|after=已提供}}
{{dr list end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}