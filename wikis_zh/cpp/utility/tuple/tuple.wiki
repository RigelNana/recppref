{{cpp/utility/tuple/title|tuple}}
{{cpp/utility/tuple/navbar}}
{{dcl begin}}
{{dcl header|tuple}}
{{dcl|num=1|since=c++11|notes={{mark|条件性 explicit}}|1=
constexpr tuple();
}}
{{dcl|num=2|since=c++11|notes={{mark|C++14 起 constexpr}}&lt;br&gt;{{mark|条件性 explicit}}|1=
tuple( const Types&amp;... args );
}}
{{dcl|num=3|since=c++11|notes={{mark|C++14 起 constexpr}}&lt;br&gt;{{mark|条件性 explicit}}|1=
template&lt; class... UTypes &gt;
tuple( UTypes&amp;&amp;... args );
}}
{{dcl|num=4|since=c++23|notes={{mark|条件性 explicit}}|1=
template&lt; class... UTypes &gt;
constexpr tuple( tuple&lt;UTypes...&gt;&amp; other );
}}
{{dcl|num=5|since=c++11|notes={{mark|C++14 起 constexpr}}&lt;br&gt;{{mark|条件性 explicit}}|1=
template&lt; class... UTypes &gt;
tuple( const tuple&lt;UTypes...&gt;&amp; other );
}}
{{dcl|num=6|since=c++11|notes={{mark|C++14 起 constexpr}}&lt;br&gt;{{mark|条件性 explicit}}|1=
template&lt; class... UTypes &gt;
tuple( tuple&lt;UTypes...&gt;&amp;&amp; other );
}}
{{dcl|num=7|since=c++23|notes={{mark|条件性 explicit}}|1=
template&lt; class... UTypes &gt;
constexpr tuple( const tuple&lt;UTypes...&gt;&amp;&amp; other );
}}
{{dcl|num=8|since=c++23|notes={{mark|条件性 explicit}}|1=
template&lt; class U1, class U2 &gt;
constexpr tuple( std::pair&lt;U1, U2&gt;&amp; p );
}}
{{dcl|num=9|since=c++11|notes={{mark|C++14 起 constexpr}}&lt;br&gt;{{mark|条件性 explicit}}|1=
template&lt; class U1, class U2 &gt;
tuple( const std::pair&lt;U1, U2&gt;&amp; p );
}}
{{dcl|num=10|since=c++11|notes={{mark|C++14 起 constexpr}}&lt;br&gt;{{mark|条件性 explicit}}|1=
template&lt; class U1, class U2 &gt;
tuple( std::pair&lt;U1, U2&gt;&amp;&amp; p );
}}
{{dcl|num=11|since=c++23|notes={{mark|条件性 explicit}}|1=
template&lt; class U1, class U2 &gt;
constexpr tuple( const std::pair&lt;U1, U2&gt;&amp;&amp; p );
}}
{{dcl|num=12|since=c++23|notes={{mark|条件性 explicit}}|1=
template&lt; tuple-like UTuple &gt;
constexpr tuple( UTuple&amp;&amp; u );
}}
{{dcl|num=13|since=c++11|1=
tuple( const tuple&amp; other ) = default;
}}
{{dcl|num=14|since=c++11|1=
tuple( tuple&amp;&amp; other ) = default;
}}
{{dcl h|扩展分配器构造函数}}
{{dcl|num=15|since=c++11|notes={{mark|C++20 起 constexpr}}&lt;br&gt;{{mark|条件性 explicit}}|1=
template&lt; class Alloc &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a );
}}
{{dcl|num=16|since=c++11|notes={{mark|C++20 起 constexpr}}&lt;br&gt;{{mark|条件性 explicit}}|1=
template&lt; class Alloc &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       const Types&amp;... args );
}}
{{dcl|num=17|since=c++11|notes={{mark|C++20 起 constexpr}}&lt;br&gt;{{mark|条件性 explicit}}|1=
template&lt; class Alloc, class... UTypes &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       UTypes&amp;&amp;... args );
}}
{{dcl|num=18|since=c++23|notes={{mark|条件性 explicit}}|1=
template&lt; class Alloc, class... UTypes &gt;
constexpr tuple( std::allocator_arg_t, const Alloc&amp; a,
                 tuple&lt;UTypes...&gt;&amp; other );
}}
{{dcl|num=19|since=c++11|notes={{mark|C++20 起 constexpr}}&lt;br&gt;{{mark|条件性 explicit}}|1=
template&lt; class Alloc, class... UTypes &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       const tuple&lt;UTypes...&gt;&amp; other );
}}
{{dcl|num=20|since=c++11|notes={{mark|C++20 起 constexpr}}&lt;br&gt;{{mark|条件性  explicit}}|1=
template&lt; class Alloc, class... UTypes &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       tuple&lt;UTypes...&gt;&amp;&amp; other );
}}
{{dcl|num=21|since=c++23|notes={{mark|条件性 explicit}}|1=
template&lt; class Alloc, class... UTypes &gt;
constexpr tuple( std::allocator_arg_t, const Alloc&amp; a,
                 const tuple&lt;UTypes...&gt;&amp;&amp; other );
}}
{{dcl|num=22|since=c++23|notes={{mark|条件性 explicit}}|1=
template&lt; class Alloc, class U1, class U2 &gt;
constexpr tuple( std::allocator_arg_t, const Alloc&amp; a,
                 std::pair&lt;U1, U2&gt;&amp; p );
}}
{{dcl|num=23|since=c++11|notes={{mark|C++20 起 constexpr}}&lt;br&gt;{{mark|条件性  explicit}}|1=
template&lt; class Alloc, class U1, class U2 &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       const std::pair&lt;U1, U2&gt;&amp; p );
}}
{{dcl|num=24|since=c++11|notes={{mark|C++20 起 constexpr}}&lt;br&gt;{{mark|条件性 explicit}}|1=
template&lt; class Alloc, class U1, class U2 &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       std::pair&lt;U1, U2&gt;&amp;&amp; p );
}}
{{dcl|num=25|since=c++23|notes={{mark|条件性 explicit}}|1=
template&lt; class Alloc, class U1, class U2 &gt;
constexpr tuple( std::allocator_arg_t, const Alloc&amp; a,
                 const std::pair&lt;U1, U2&gt;&amp;&amp; p );
}}
{{dcl|num=26|since=c++23|notes={{mark|条件性 explicit}}|1=
template&lt; class Alloc, tuple-like UTuple &gt;
constexpr tuple( std::allocator_arg_t, const Alloc&amp; a, UTuple&amp;&amp; u );
}}
{{dcl|num=27|since=c++11|notes={{mark|C++20 起 constexpr}}|1=
template&lt; class Alloc &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       const tuple&amp; other );
}}
{{dcl|num=28|since=c++11|notes={{mark|C++20 起 constexpr}}|1=
template&lt; class Alloc &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       tuple&amp;&amp; other );
}}
{{dcl end}}

构造新的元组。

在以下描述中，令
* {{c|i}} 从范围 {{range|0|sizeof...(Types)}} 中依序取值，
* {{tt|Ti}} 为 {{tt|Types}} 中的第 {{c|i}} 个类型，以及
* {{tt|Ui}} 为名字是 {{tt|UTypes}} 的模板形参包中的第 {{c|i}} 个类型，
其中索引基于零。

@1@ 默认构造函数。[[cpp/language/value initialization|值初始化]]各元素（若存在）。如果 {{c|1=sizeof...(Types) == 0}}，那么默认构造函数平凡。
* {{cpp/enable if| {{c|std::is_default_constructible&lt;Ti&gt;::value}} 对所有 {{c|i}} 都是 {{c|true}} }}。
* 此构造函数当且仅当至少有一个 {{c|i}} 对应的 {{tt|Ti}} 不可从 {{c|{}&lt;!----&gt;}} 复制列表初始化时是 {{c/core|explicit}} 的。

@2@ 直接构造函数。以对应参数初始化元组的每个元素。
* {{cpp/enable if| {{c|1=sizeof...(Types) &gt;= 1}} 且 {{c|std::is_copy_constructible&lt;Ti&gt;::value}} 对所有 {{c|i}} 都是 {{c|true}} }}。
* 此构造函数当且仅当 {{c|std::is_convertible&lt;const Ti&amp;, Ti&gt;::value}} 对至少一个 {{c|i}} 是 {{c|false}} 时是 {{c/core|explicit}} 的。

@3@ 转换构造函数。以 {{c|std::forward&lt;UTypes&gt;(args)}} 中的对应值初始化元组的每个元素。
&lt;!----&gt;
* {{cpp/enable if|
** {{c|1=sizeof...(Types) == sizeof...(UTypes)}}，且
** {{c|1=sizeof...(Types) &gt;= 1}}，且
** {{c|std::is_constructible&lt;Ti, Ui&gt;::value}} 对所有 {{c|i}} 都是 {{c|true}}，且
** 令 {{tt|D}} 为 {{rev inl|until=c++20|{{c|std::decay&lt;U0&gt;::type}}}}{{rev inl|since=c++20|{{c|std::remove_cvref_t&lt;U0&gt;}}}}，那么
*** 如果 {{c|1=sizeof...(Types) == 1}}，那么 {{tt|D}} 不是 {{tt|std::tuple}}，否则，
*** 如果 {{c|1=sizeof...(Types) == 2}} 或 {{c|1=sizeof...(Types) == 3}}，那么要么 {{tt|D}} 不是 {{lc|std::allocator_arg_t}}，要么 {{tt|T0}} 是 {{lc|std::allocator_arg_t}}
}}。
* 此构造函数当且仅当 {{c|std::is_convertible&lt;Ui, Ti&gt;::value}} 对至少一个 {{c|i}} 是 {{c|false}} 时是 {{c/core|explicit}} 的。
{{rrev|since=c++23|
* 如果任何引用元素的初始化会[[cpp/language/reference_initialization#临时量的生存期|绑定它到临时对象]]，那么定义此构造函数为弃置的。
}}

@4-7@ 转换构造函数。以 {{c|other}} 中的对应元素初始化元组的每个元素。
&lt;!----&gt;
正式而言，令 {{c|FWD(other)}} 为 {{c|std::forward&lt;decltype(other)&gt;(other)}}，对于所有 {{c|i}}，以 {{c|std::get&lt;i&gt;(FWD(other))}} 初始化元组的第 {{c|i}} 个元素。
* {{cpp/enable if|
** {{c|1=sizeof...(Types) == sizeof...(UTypes)}}，
** {{c|std::is_constructible_v&lt;TI, decltype(std::get&lt;i&gt;(FWD(other)))&gt;}} 对所有 {{c|i}} 都是 {{c|true}}，且
** 以下之一成立：
*** {{c|sizeof...(Types)}} 不是 {{c|1}}，或者
***（当 {{tt|Types...}} 展开成 {{tt|T}} 且 {{tt|UTypes...}} 展开成 {{tt|U}} 时）{{c|std::is_convertible_v&lt;decltype(other), T&gt;}}，{{c|std::is_constructible_v&lt;T, decltype(other)&gt;}} 和 {{c|std::is_same_v&lt;T, U&gt;}} 都是 {{c|false}}
}}。
* 此构造函数当且仅当 {{c|std::is_convertible_v&lt;decltype(std::get&lt;I&gt;(FWD(other))), TI&gt;}} 对至少一个 {{c|i}} 是 {{c|false}} 时是 {{c/core|explicit}} 的。
{{rrev|since=c++23|
* 如果任何引用元素的初始化会绑定它到临时对象，那么定义此构造函数为弃置的。
}}

@8-11@ 对偶构造函数。构造 2 个元素的元组，以 {{c|p}} 中的对应元素初始化元组的每个元素。
&lt;!----&gt;
正式而言，令 {{c|FWD(p)}} 为 {{c|std::forward&lt;decltype(p)&gt;(p)}}，从 {{c|std::get&lt;0&gt;(FWD(p))}} 构造第一个元素，从 {{c|std::get&lt;1&gt;(FWD(p))}} 构造第二个元素。
* {{cpp/enable if|
** {{c|1=sizeof...(Types) == 2}}，
** {{c|std::is_constructible_v&lt;T0, decltype(std::get&lt;0&gt;(FWD(p)))&gt;}} 是 {{c|true}}，且
** {{c|std::is_constructible_v&lt;T1, decltype(std::get&lt;1&gt;(FWD(p)))&gt;}} 是 {{c|true}}
}}。
* 此构造函数当且仅当 {{c|std::is_convertible_v&lt;decltype(std::get&lt;0&gt;(FWD(p))), T0&gt;}} 或 {{c|std::is_convertible_v&lt;decltype(std::get&lt;1&gt;(FWD(p))), T1&gt;}} 是 {{c|false}} 时是 {{c/core|explicit}} 的。
{{rrev|since=c++23|
* 如果任何引用元素的初始化会绑定它到临时对象，那么定义此构造函数为弃置的。
}}

@12@ {{rlpi|tuple-like}} 构造函数。构造元组，以 {{c|u}} 中的对应元素初始化元组的每个元素。
&lt;!----&gt;
正式而言，对于所有 {{c|i}}，以 {{c|std::get&lt;i&gt;(std::forward&lt;UTuple&gt;(u))}} 初始化元组的第 {{c|i}} 个元素。
* {{cpp/enable if|
** {{c|std::same_as&lt;std::remove_cvref_t&lt;UTuple&gt;, std::tuple&gt;}} 是 {{c|false}}，
** {{c|std::remove_cvref_t&lt;UTuple&gt;}} 不是 {{ltt|cpp/ranges/subrange|std::ranges::subrange}} 的特化，
** {{c|sizeof...(Types)}} 等于 {{c|std::tuple_size_v&lt;std::remove_cvref_t&lt;UTuple&gt;&gt;}}，
** {{c|std::is_constructible_v&lt;Ti, decltype(std::get&lt;i&gt;(std::forward&lt;UTuple&gt;(u)))&gt;}} 对于所有 {{c|i}} 都是 {{c|true}}，且
** 以下之一成立：
*** {{c|sizeof...(Types)}} 不是 {{c|1}}，或者
*** （当 {{tt|Types...}} 展开成 {{tt|T}} 时）{{c|std::is_convertible_v&lt;UTuple, T&gt;}} 和 {{c|std::is_constructible_v&lt;T, UTuple&gt;}} 都是 {{c|false}}。}}
* 如果有任何引用元素可以绑定到临时对象，则此构造函数被定义为弃置的。

@13@ 隐式定义的复制构造函数。以 {{c|other}} 的对应元素初始化元组的每个元素。
* 如果此函数进行的每个操作都是 {{c/core|constexpr}}，那么它是 {{c/core|constexpr}} 的。对于空元组 {{c/core|std::tuple&lt;&gt;}}，它是 {{c|constexpr}} 的。
* {{c|std::is_copy_constructible&lt;Ti&gt;::value}} 必须对所有 {{c|i}} 都是 {{c|true}}，否则{{rev inl|until=c++20|行为未定义}}{{rev inl|since=c++20|此重载不会参与重载决议}}。

@14@ 隐式定义的移动构造函数。对于所有 {{c|i}}，以 {{c|std::forward&lt;Ui&gt;(std::get&lt;i&gt;(other))}} 构造元组的第 {{c|i}} 个元素。
* 如果此函数进行的每个操作都是 {{c/core|constexpr}} 的，那么它是 {{c/core|constexpr}} 的。对于空元组 {{c/core|std::tuple&lt;&gt;}}，它是 {{c/core|constexpr}} 的。
* {{c|std::is_move_constructible&lt;Ti&gt;::value}} 必须对所有 {{c|i}} 都是 {{c|true}}，否则{{rev inl|until=c++20|行为未定义}}{{rev inl|since=c++20|此重载不参与重载决议}}。

@15-28@ 等同于 {{v|1-14}}，但以''[[cpp/memory/uses_allocator#使用分配器构造|使用分配器构造]]''{{sep}}创建每个元素，即对每个 {{c|std::uses_allocator&lt;Ti, Alloc&gt;::value}} 为 {{c|true}} 的元素，以分配器对象 {{c|a}} 为额外实参传递给其构造函数。

===参数===
{{par begin}}
{{par|args|用于初始化元组每个元素的值}}
{{par|other|用于初始化元组每个元素的值的元组}}
{{par|p|用于初始化 2-元组的两个元素的值的对偶}}
{{par|u|用于初始化元组每个元素的值的 {{rlpi|tuple-like}} 对象}}
{{par|a|用于使用分配器构造的分配器}}
{{par end}} 

===注解===
条件性显式的构造函数使得可以在复制初始化语境中用列表初始化语法来构造元组：
{{source|1=
std::tuple&lt;int, int&gt; foo_tuple() 
{
    // return {1, -1};             // N4387 前错误
    return std::make_tuple(1, -1); // 始终可行
}
}}

注意如果列表中某元素不可隐式转换成目标元组中的对应元素，那么构造函数会变成显式的：
{{source|1=
using namespace std::chrono;
void launch_rocket_at(std::tuple&lt;hours, minutes, seconds&gt;);

launch_rocket_at({hours(1), minutes(2), seconds(3)}); // OK
launch_rocket_at({1, 2, 3}); // 错误：int 不可隐式转换到 duration
launch_rocket_at(std::tuple&lt;hours, minutes, seconds&gt;{1, 2, 3}); // OK
}}

===示例===
{{example
|code=
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;tuple&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;

// 打印 vector 到流的辅助函数
template&lt;class Os, class T&gt;
Os&amp; operator&lt;&lt;(Os&amp; os, std::vector&lt;T&gt; const&amp; v)
{
    os &lt;&lt; '{';
    for (auto i{v.size()}; const T&amp; e : v)
        os &lt;&lt; e &lt;&lt; (--i ? "," : "");
    return os &lt;&lt; '}';
}

template&lt;class T&gt;
void print_single(T const&amp; v)
{
    if constexpr (std::is_same_v&lt;T, std::decay_t&lt;std::string&gt;&gt;)
        std::cout &lt;&lt; std::quoted(v);
    else if constexpr (std::is_same_v&lt;std::decay_t&lt;T&gt;, char&gt;)
        std::cout &lt;&lt; "'" &lt;&lt; v &lt;&lt; "'";
    else
        std::cout &lt;&lt; v;
}

// 打印任意大小元组的辅助函数
template&lt;class Tuple, std::size_t N&gt;
struct TuplePrinter
{
    static void print(const Tuple&amp; t)
    {
        TuplePrinter&lt;Tuple, N - 1&gt;::print(t);
        std::cout &lt;&lt; ", ";
        print_single(std::get&lt;N - 1&gt;(t));
    }
};

template&lt;class Tuple&gt;
struct TuplePrinter&lt;Tuple, 1&gt;
{
    static void print(const Tuple&amp; t)
    {
        print_single(std::get&lt;0&gt;(t));
    }
};

template&lt;class... Args&gt;
void print(std::string_view message, const std::tuple&lt;Args...&gt;&amp; t)
{
    std::cout &lt;&lt; message &lt;&lt; " (";
    TuplePrinter&lt;decltype(t), sizeof...(Args)&gt;::print(t);
    std::cout &lt;&lt; ")\n";
}
// 辅助函数结束

int main()
{
    std::tuple&lt;int, std::string, double&gt; t1;
    print("值初始化，t1：", t1);
    
    std::tuple&lt;int, std::string, double&gt; t2{42, "Test", -3.14};
    print("通过值进行初始化，t2：", t2);
    
    std::tuple&lt;char, std::string, int&gt; t3{t2};
    print("隐式转换，t3：", t3);
    
    std::tuple&lt;int, double&gt; t4{std::make_pair(42, 3.14)};
    print("从 pair 构造，t4：", t4);
    
    // 给定拥有单实参构造函数的分配器 my_alloc my_alloc(int)
    // 用 my_alloc(1) 在 vector 中分配 5 个 int
    using my_alloc = std::allocator&lt;int&gt;;
    std::vector&lt;int, my_alloc&gt; v{5, 1, my_alloc{/* 1 */}&lt;!----&gt;};
    
    // 用 my_alloc(2) 在 tuple 中的 vector 中分配 5 个 int
    std::tuple&lt;int, std::vector&lt;int, my_alloc&gt;, double&gt; t5
        {std::allocator_arg, my_alloc{/* 2 */}, 42, v, -3.14};
    print("带分配器构造，t5：", t5);
}
|p=true
|output=
值初始化，t1：(0, "", 0)
通过值进行初始化，t2：(42, "Test", -3.14)
隐式转换，t3：('*', "Test", -3)
从 pair 构造，t4：(42, 3.14)
带分配器构造，t5：(42, {1,1,1,1,1}, -3.14)
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2510|std=C++11|before=默认构造函数是隐式的|after=使之为条件性 explicit}}
{{dr list item|wg=lwg|dr=3121|std=C++11|before=1-tuple 的默认构造函数可能递归地检查约束;&lt;br&gt;{{tt|allocator_arg_t}} 参数带来歧义|after=进一步约束构造函数}}
{{dr list item|wg=lwg|dr=3158|std=C++11|before=对应默认构造函数的使用分配器构造函数为隐式|after=使之为条件性 explicit}}
{{dr list item|wg=lwg|dr=3211|std=C++11|before=未指定 {{tt|tuple&lt;&gt;}} 的默认构造函数是否为平凡|after=要求为平凡}}
{{dr list item|wg=lwg|dr=4045|std=C++23|before={{tti|tuple-like}} 构造函数可能潜在地创建悬垂引用|after=将其定义为弃置}}
{{dr list item|paper=N4387|std=C++11|before=某些构造函数曾经是 explicit 的，阻止了有用的行为|after=使大多数构造函数为条件性 explicit}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc operator{{=}}}}
{{dsc inc|cpp/utility/tuple/dsc make_tuple}}
{{dsc inc|cpp/utility/tuple/dsc tie}}
{{dsc inc|cpp/utility/tuple/dsc forward_as_tuple}}
{{dsc inc|cpp/utility/pair/dsc constructor}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}