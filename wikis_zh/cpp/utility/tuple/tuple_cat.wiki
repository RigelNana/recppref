{{cpp/title|tuple_cat}}
{{cpp/utility/tuple/navbar}}
{{dcl begin}}
{{dcl header|tuple}}
{{dcl rev multi|since1=c++11|until1=c++14|dcl1=
template&lt; class... Tuples &gt;
std::tuple&lt;/* CTypes */...&gt; tuple_cat( Tuples&amp;&amp;... args );
|until2=c++23|dcl2=
template&lt; class... Tuples &gt;
constexpr std::tuple&lt;/* CTypes */...&gt; tuple_cat( Tuples&amp;&amp;... args );
|dcl3=
template&lt; tuple-like... Tuples &gt;
constexpr std::tuple&lt;/* CTypes */...&gt; tuple_cat( Tuples&amp;&amp;... args );
}}
{{dcl end}}

构造 {{c|args}} 中的所有元组所拼接成的元组。返回的元组的各元素类型 {{c/core|/* CTypes */}} 是通过将 {{tt|Tuples}} 中的每个 {{rev inl|until=c++23|{{lc|std::tuple}}}}{{rev inl|since=c++23|{{rlpi|tuple-like}}}} 类型的元素类型包拼接得到的。

{{rrev multi|since2=c++23
|rev1=
当 {{c/core|std::decay_t&lt;Tuples&gt;...}} 中有任何类型不是 {{lc|std::tuple}} 的特化时行为未定义。然而，实现可以选择支持遵循元组式协议的类型（例如 {{lc|std::array}} 和 {{lc|std::pair}}）。
|rev2=
{{c/core|std::decay_t&lt;Tuples&gt;...}} 中的各类型被约束为元组式类型，即其中每个类型都必须是 {{lc|std::tuple}} 的特化，或者实现了 {{rlpi|tuple-like}} 的其他任何类型（例如 {{lc|std::array}} 和 {{lc|std::pair}}）。
}}

如果 {{c/core|/* CTypes */}} 中有任何类型无法从以 {{c|args}} 拼接而成的元素序列中对应元素的类型构造，那么{{rev inl|until=c++23|行为未定义}}{{rev inl|since=c++23|程序非良构}}。

===参数===
{{par begin}}
{{par|args|要拼接的零或更多个元组}}
{{par end}}

===返回值===
{{lc|std::tuple}} 对象，由所有实参元组的所有元素组成，从对于每个独立元素的 {{c|std::get&lt;i&gt;(std::forward&lt;Ti&gt;(arg))}} 构造。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

// 打印任意大小元组的辅助函数
template&lt;class Tuple, std::size_t N&gt;
struct TuplePrinter
{
    static void print(const Tuple&amp; t)
    {
        TuplePrinter&lt;Tuple, N - 1&gt;::print(t);
        std::cout &lt;&lt; ", " &lt;&lt; std::get&lt;N-1&gt;(t);
    }
};

template&lt;class Tuple&gt;
struct TuplePrinter&lt;Tuple, 1&gt;
{
    static void print(const Tuple&amp; t)
    {
        std::cout &lt;&lt; std::get&lt;0&gt;(t);
    }
};

template&lt;typename... Args, std::enable_if_t&lt;sizeof...(Args) == 0, int&gt; = 0&gt;
void print(const std::tuple&lt;Args...&gt;&amp; t)
{
    std::cout &lt;&lt; "()\n";
}

template&lt;typename... Args, std::enable_if_t&lt;sizeof...(Args) != 0, int&gt; = 0&gt;
void print(const std::tuple&lt;Args...&gt;&amp; t)
{
    std::cout &lt;&lt; "(";
    TuplePrinter&lt;decltype(t), sizeof...(Args)&gt;::print(t);
    std::cout &lt;&lt; ")\n";
}
// 辅助函数结束

int main()
{
    std::tuple&lt;int, std::string, float&gt; t1(10, "Test", 3.14);
    int n = 7;
    auto t2 = std::tuple_cat(t1, std::make_tuple("Foo", "bar"), t1, std::tie(n));
    n = 42;
    print(t2);
}
|output=
(10, Test, 3.14, Foo, bar, 10, Test, 3.14, 42)
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc make_tuple}}
{{dsc inc|cpp/utility/tuple/dsc tie}}
{{dsc inc|cpp/utility/tuple/dsc forward_as_tuple}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}