{{cpp/title|tie}}
{{cpp/utility/tuple/navbar}}
{{dcl begin}}
{{dcl header|tuple}}
{{dcla|since=c++11|constexpr=c++14|1=
template&lt; class... Types &gt;
std::tuple&lt;Types&amp;...&gt; tie( Types&amp;... args ) noexcept;
}}
{{dcl end}}

创建到其实参或 {{lc|std::ignore}} 实例的左值引用的元组。

===参数===
{{par begin}}
{{par|args|为之构造元组的零或更多左值实参}}
{{par end}}

===返回值===
含左值引用的 {{lc|std::tuple}} 对象。

===可能的实现===
{{eq fun|1=
template &lt;typename... Args&gt;
constexpr // C++14 起
std::tuple&lt;Args&amp;...&gt; tie(Args&amp;... args) noexcept
{
    return {args...};
}
}}

===注解===
{{tt|std::tie}} 可用于解包 {{lc|std::pair}}，因为 {{lc|std::tuple}} 拥有从 pair 的[[cpp/utility/tuple/operator{{=}}|转换赋值]]：
{{source|1=
bool result;
std::tie(std::ignore, result) = set.insert(value);
}}

===示例===
{{example
|1) {{tt|std::tie}} 可以用于为结构体引入字典序比较，或解包元组；&lt;br&gt;
2) {{tt|std::tie}} 可以用于{{lt|cpp/language/structured binding|结构化绑定}}：
|code=
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

struct S
{
    int n;
    std::string s;
    float d;

    friend bool operator&lt;(const S&amp; lhs, const S&amp; rhs) noexcept
    {
        // 比较 lhs.n 与 rhs.n,
        // 然后为 lhs.s 与 rhs.s,
        // 然后为 lhs.d 与 rhs.d
        // 返回这个次序中第一个不相等的结果
        // 或者当所有元素都相等时返回 false
        return std::tie(lhs.n, lhs.s, lhs.d) &lt; std::tie(rhs.n, rhs.s, rhs.d);
    }
};

int main()
{
    // 字典序比较演示：
    std::set&lt;S&gt; set_of_s;

    S value{42, "Test", 3.14};
    std::set&lt;S&gt;::iterator iter;
    bool is_inserted;

    // 解包 pair：
    std::tie(iter, is_inserted) = set_of_s.insert(value);
    assert(is_inserted);


    // std::tie 和结构化绑定：
    auto position = [](int w) { return std::tuple(1 * w, 2 * w); };

    auto [x, y] = position(1);
    assert(x == 1 &amp;&amp; y == 2);
    std::tie(x, y) = position(2); // 用 tie 重用 x, y
    assert(x == 2 &amp;&amp; y == 4);


    // 允许隐式转换：
    std::tuple&lt;char, short&gt; coordinates(6, 9);
    std::tie(x, y) = coordinates;
    assert(x == 6 &amp;&amp; y == 9);

    // 忽略部分变量：
    std::string z;
    std::tie(x, std::ignore, z) = std::make_tuple(1, 2.0, "Test");
    assert(x == 1 &amp;&amp; z.compare("Test") == 0);

    // 跳过一个元素：
    std::string z;
    std::tie(x, std::ignore, z) = std::tuple(1, 2.0, "Test");
    assert(x == 1 &amp;&amp; z == "Test");
}
}}

=== 参阅 ===
{{dsc begin}}
{{dsc inc|cpp/language/dsc structured binding}}
{{dsc inc|cpp/utility/tuple/dsc make_tuple}}
{{dsc inc|cpp/utility/tuple/dsc forward_as_tuple}}
{{dsc inc|cpp/utility/tuple/dsc tuple_cat}}
{{dsc inc|cpp/utility/tuple/dsc ignore}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}