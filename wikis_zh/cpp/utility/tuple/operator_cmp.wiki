{{title|1=operator==,!=,&lt;,&lt;=,&gt;,&gt;=,&lt;=&gt;{{petty|(std::tuple)}}}}
{{cpp/utility/tuple/navbar}}
{{dcl begin}}
{{dcl header|tuple}}
{{dcla|num=1|since=c++11|constexpr=c++14|1=
template&lt; class... TTypes, class... UTypes &gt;
bool operator==( const std::tuple&lt;TTypes...&gt;&amp; lhs,
                 const std::tuple&lt;UTypes...&gt;&amp; rhs );
}}
{{dcla|num=2|since=c++11|constexpr=c++14|until=c++20|1=
template&lt; class... TTypes, class... UTypes &gt;
bool operator!=( const std::tuple&lt;TTypes...&gt;&amp; lhs,
                 const std::tuple&lt;UTypes...&gt;&amp; rhs );
}}
{{dcla|num=3|since=c++11|constexpr=c++14|until=c++20|1=
template&lt; class... TTypes, class... UTypes &gt;
bool operator&lt;( const std::tuple&lt;TTypes...&gt;&amp; lhs,
                const std::tuple&lt;UTypes...&gt;&amp; rhs );
}}
{{dcla|num=4|since=c++11|constexpr=c++14|until=c++20|1=
template&lt; class... TTypes, class... UTypes &gt;
bool operator&lt;=( const std::tuple&lt;TTypes...&gt;&amp; lhs,
                 const std::tuple&lt;UTypes...&gt;&amp; rhs );
}}
{{dcla|num=5|since=c++11|constexpr=c++14|until=c++20|1=
template&lt; class... TTypes, class... UTypes &gt;
bool operator&gt;( const std::tuple&lt;TTypes...&gt;&amp; lhs,
                const std::tuple&lt;UTypes...&gt;&amp; rhs );
}}
{{dcla|num=6|since=c++11|constexpr=c++14|until=c++20|1=
template&lt; class... TTypes, class... UTypes &gt;
bool operator&gt;=( const std::tuple&lt;TTypes...&gt;&amp; lhs,
                 const std::tuple&lt;UTypes...&gt;&amp; rhs );
}}
{{dcl|num=7|since=c++20|1=
template&lt; class... TTypes, class... UTypes &gt;
constexpr std::common_comparison_category_t&lt;
    synth-three-way-result&lt;TTypes, Elems&gt;...&gt;
    operator&lt;=&gt;( const std::tuple&lt;TTypes...&gt;&amp; lhs,
                 const std::tuple&lt;UTypes...&gt;&amp; rhs );
}}
{{dcl|num=8|since=c++23|1=
template&lt; class... TTypes, tuple-like UTuple &gt;
constexpr bool operator==( const tuple&lt;TTypes...&gt;&amp; lhs, const UTuple&amp; rhs );
}}
{{dcl|num=9|since=c++23|1=
template&lt; class... TTypes, tuple-like UTuple &gt;
constexpr std::common_comparison_category_t&lt;
    synth-three-way-result&lt;TTypes, /* Elems */&gt;...&gt;
    operator&lt;=&gt;( const tuple&lt;TTypes...&gt;&amp; lhs, const UTuple&amp; rhs );
}}
{{dcl end}}

@1,2@ 以 {{c/core|1=operator==}} 比较元组 {{c|lhs}} 的每个元素和元组 {{c|rhs}} 的对应元素。
:@1@ 在每对对应元素都相等时返回 {{c|true}}。
:@2@ 返回 {{c|1=!(lhs == rhs)}}。

{{rrev multi|rev1=
@@ 如果 {{c|sizeof...(TTypes)}} 不等于 {{c|sizeof...(UTypes)}}，或者 {{range|0|sizeof...(Types)}} 中存在 {{c|i}} 使得 {{c|1=std::get&lt;i&gt;(lhs) == std::get&lt;i&gt;(rhs)}} 不是合法的表达式，那么程序非良构。

@@ 如果 {{range|0|sizeof...(Types)}} 中存在 {{c|i}} 使得 {{c|1=std::get&lt;i&gt;(lhs) == std::get&lt;i&gt;(rhs)}} 不符合{{named req|BooleanTestable}}要求，则行为未定义。
|since2=c++26|rev2=
@@ {{cpp/enable_if| {{c|sizeof...(TTypes)}} 等于 {{c|sizeof...(UTypes)}}，而且对于 {{range|0|sizeof...(Types)}} 中的每个 {{c|i}}， {{c|1=std::get&lt;i&gt;(lhs) == std::get&lt;i&gt;(rhs)}} 为合法的表达式且 {{c|1=decltype(std::get&lt;i&gt;(lhs) == std::get&lt;i&gt;(rhs))}} 实现 {{lconcept|boolean-testable}} }}。
}}

@3-6@ 用 {{c/core|operator&lt;}} 以字典序比较 {{c|lhs}} 与 {{c|rhs}}，即首先比较首元素，在等价时比较第二元素，还等价时再比较第三元素，以此类推。

:@3@ 对于空元组，返回 {{c|false}}。对于非空元组，其效果等价于&lt;br&gt;{{c|
if (std::get&lt;0&gt;(lhs) &lt; std::get&lt;0&gt;(rhs)) return true;
if (std::get&lt;0&gt;(rhs) &lt; std::get&lt;0&gt;(lhs)) return false;
if (std::get&lt;1&gt;(lhs) &lt; std::get&lt;1&gt;(rhs)) return true;
if (std::get&lt;1&gt;(rhs) &lt; std::get&lt;1&gt;(lhs)) return false;
...
return std::get&lt;N - 1&gt;(lhs) &lt; std::get&lt;N - 1&gt;(rhs);
}}
:@4@ 返回 {{c|!(rhs &lt; lhs)}}。
:@5@ 返回 {{c|rhs &lt; lhs}}。
:@6@ 返回 {{c|!(lhs &lt; rhs)}}。

@@ 如果 {{c|sizeof...(TTypes)}} 不等于 {{c|sizeof...(UTypes)}}，或者等价的语句中展示的任何一个比较表达式不是合法的表达式，那么程序非良构。

@@ 如果等价的语句中展示的任何一个比较表达式的类型与值类别不符合{{named req|BooleanTestable}}要求，则行为未定义。

@7@ 用 {{lti|cpp/standard library/synth-three-way}} 以字典序比较 {{c|lhs}} 和 {{c|rhs}}，即首先比较首元素，在等价时比较第二元素，还等价时再比较第三元素，以此类推。
* 对于空元组，返回 {{ltt|cpp/utility/compare/strong_ordering|std::strong_ordering::equal}}。
* 对于非空元组，其效果等价于
:@@ {{box|
{{c/core|1=if (auto c =}}{{nbspt}}{{lti|cpp/standard library/synth-three-way}}{{c/core|1=(std::get&lt;0&gt;(lhs), std::get&lt;0&gt;(rhs)); c != 0) return c;}}&lt;br&gt;
{{c/core|1=if (auto c =}}{{nbspt}}{{lti|cpp/standard library/synth-three-way}}{{c/core|1=(std::get&lt;1&gt;(lhs), std::get&lt;1&gt;(rhs)); c != 0) return c;}}&lt;br&gt;
{{tt|...}}&lt;br&gt;
{{c/core|return}}{{nbspt}}{{lti|cpp/standard library/synth-three-way}}{{c/core|(std::get&lt;N - 1&gt;(lhs), std::get&lt;N - 1&gt;(rhs));}}
}}

@8@ 同 {{v|1}}，但 {{c|rhs}} 是 {{rlpi|tuple-like}} 对象，并且 {{c|rhs}} 的元素数量改由 {{c|std::tuple_size_v&lt;UTuple&gt;}} 确定。此重载只能通过[[cpp/language/adl|实参依赖查找]]找到。

@9@ 同 {{v|7}}，但 {{c|rhs}} 是 {{rlpi|tuple-like}} 对象。{{c/core|/* Elems */}} 表示包含 {{range|0|std::tuple_size_v&lt;UTuple&gt;}} 中按升序的每个 {{c|i}} 对应的类型 {{c/core|std::tuple_element_t&lt;i, UTuple&gt;}} 的类型包。此重载只能通过[[cpp/language/adl|实参依赖查找]]找到。

所有比较运算符都是短路的；它们在确定结果所必须的比较之外不会访问其他的元组元素。

{{rrev|since=c++20|
{{cpp/note synthesized compare}}
}}

===参数===
{{par begin}}
{{par|lhs, rhs|要比较的元组}}
{{par end}} 

===返回值===
@1,8@ 在对于所有 {{range|0|sizeof...(Types)}} 中的 {{c|i}} 都满足 {{c|1=std::get&lt;i&gt;(lhs) == std::get&lt;i&gt;(rhs)}} 时返回 {{c|true}}，否则返回 {{c|false}}。对两个空元组返回 {{c|true}}。

@2@ {{c|1=!(lhs == rhs)}}

@3@ 在 {{c|lhs}} 中的首个不等价元素小于 {{c|rhs}} 中的时候是 {{c|true}}，如果 {{c|rhs}} 中的首个不等价元素小于 {{c|lhs}} 中的或无不等价元素时返回 {{c|false}}。对两个空元组返回 {{c|false}}。

@4@ {{c|!(rhs &lt; lhs)}}

@5@ {{c|rhs &lt; lhs}}

@6@ {{c|!(lhs &lt; rhs)}}

@7,9@ 首对不等价元素（若存在）间的关系，否则返回 {{ltt|cpp/utility/compare/strong_ordering|std::strong_ordering::equal}}。对两个空元组返回 {{ltt|cpp/utility/compare/strong_ordering|std::strong_ordering::equal}}。

===注解===
{{rrev multi|rev1=
各关系运算符是基于各个元素的 {{c/core|operator&lt;}} 定义的。
|since2=c++20|rev2=
各关系运算符是基于 {{lti|cpp/standard library/synth-three-way}} 定义的，若有可能则它会使用 {{c/core|1=operator&lt;=&gt;}}，否则使用 {{c/core|operator&lt;}}。

要注意，如果元素类型自身并不提供 {{c/core|1=operator&lt;=&gt;}}，但可以隐式转换为可三路比较的类型，则就会用这项转换来替代 {{c/core|operator&lt;}}。
}}

{{feature test macro|__cpp_lib_constrained_equality|{{lc|std::tuple}} 的受约束 {{c/core|1=operator==}}|value=202403L|std=C++26}}

===示例===
{{example
|因为 {{c/core|operator&lt;}} 对于元组有定义，所以可以对元组的容器排序。
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;std::tuple&lt;int, std::string, float&gt;&gt; v
    {
        {2, "baz", -0.1},
        {2, "bar", 3.14},
        {1, "foo", 10.1},
        {2, "baz", -1.1},
    };
    std::sort(v.begin(), v.end());
    
    for (const auto&amp; p: v)
        std::cout &lt;&lt; "{ " &lt;&lt; get&lt;0&gt;(p)
                  &lt;&lt; ", " &lt;&lt; get&lt;1&gt;(p)
                  &lt;&lt; ", " &lt;&lt; get&lt;2&gt;(p)
                  &lt;&lt; " }\n";
}
|output=
{ 1, foo, 10.1 }
{ 2, bar, 3.14 }
{ 2, baz, -1.1 }
{ 2, baz, -0.1 }
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2114|paper=P2167R3|std=C++11|before=缺少布尔运算的类型前条件|after=已添加}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/pair/dsc operator cmp}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}