{{cpp/title|get{{petty|(std::tuple)}}}}
{{cpp/utility/tuple/navbar}}
{{dcl begin}}
{{dcl header|tuple}}
{{dcla|num=1|anchor=no|since=c++11|constexpr=c++14|
template&lt; std::size_t I, class... Types &gt;
typename std::tuple_element&lt;I, std::tuple&lt;Types...&gt;&gt;::type&amp;
    get( std::tuple&lt;Types...&gt;&amp; t ) noexcept;
}}
{{dcla|num=2|anchor=no|since=c++11|constexpr=c++14|
template&lt; std::size_t I, class... Types &gt;
typename std::tuple_element&lt;I, std::tuple&lt;Types...&gt;&gt;::type&amp;&amp;
    get( std::tuple&lt;Types...&gt;&amp;&amp; t ) noexcept;
}}
{{dcla|num=3|anchor=no|since=c++11|constexpr=c++14|
template&lt; std::size_t I, class... Types &gt;
const typename std::tuple_element&lt;I, std::tuple&lt;Types...&gt;&gt;::type&amp;
    get( const std::tuple&lt;Types...&gt;&amp; t ) noexcept;
}}
{{dcla|num=4|since=c++11|constexpr=c++14|
template&lt; std::size_t I, class... Types &gt;
const typename std::tuple_element&lt;I, std::tuple&lt;Types...&gt;&gt;::type&amp;&amp;
    get( const std::tuple&lt;Types...&gt;&amp;&amp; t ) noexcept;
}}
{{dcla|num=5|since=c++14|
template&lt; class T, class... Types &gt;
constexpr T&amp; get( std::tuple&lt;Types...&gt;&amp; t ) noexcept;
}}
{{dcl|num=6|since=c++14|
template&lt; class T, class... Types &gt;
constexpr T&amp;&amp; get( std::tuple&lt;Types...&gt;&amp;&amp; t ) noexcept;
}}
{{dcl|num=7|since=c++14|
template&lt; class T, class... Types &gt;
constexpr const T&amp; get( const std::tuple&lt;Types...&gt;&amp; t ) noexcept;
}}
{{dcla|num=8|since=c++14|
template&lt; class T, class... Types &gt;
constexpr const T&amp;&amp; get( const std::tuple&lt;Types...&gt;&amp;&amp; t ) noexcept;
}}
{{dcl end}}

@1-4@ 从元组提取第 {{c|I}} 个元素。{{c|I}} 必须是 {{range|0|sizeof...(Types)}} 中的整数值。
@5-8@ 提取元组 {{c|t}} 中类型是 {{tt|T}} 的元素。如果元组不恰好拥有一个该类型元素，那么编译失败。

===参数===
{{par begin}}
{{par|t|要提取内容的元组}}
{{par end}} 

===返回值===
到 {{c|t}} 的被选中元素的引用。

===注解===
{{feature test macro|__cpp_lib_tuples_by_type|按类型 {{vl|5-8}} 寻址元组|value=201304L|std=C++14}}

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

int main()
{
    auto x = std::make_tuple(1, "Foo", 3.14);
    
    // 注意：std::get 会生成到 std::get&lt;std::variant&gt; 的错误链接
    using std::get;

    // 基于索引的访问
    std::cout &lt;&lt; "( " &lt;&lt; get&lt;0&gt;(x)
              &lt;&lt; ", " &lt;&lt; get&lt;1&gt;(x)
              &lt;&lt; ", " &lt;&lt; get&lt;2&gt;(x)
              &lt;&lt; " )\n";

    // 基于类型的访问（C++14 起）
    std::cout &lt;&lt; "( " &lt;&lt; get&lt;int&gt;(x)
              &lt;&lt; ", " &lt;&lt; get&lt;const char*&gt;(x)
              &lt;&lt; ", " &lt;&lt; get&lt;double&gt;(x)
              &lt;&lt; " )\n";

    const std::tuple&lt;int, const int, double, double&gt; y(1, 2, 6.9, 9.6);
    const int&amp; i1 = std::get&lt;int&gt;(y); // OK：无歧义
    assert(i1 == 1);
    const int&amp; i2 = std::get&lt;const int&gt;(y);  // OK：无歧义
    assert(i2 == 2);
    // const double&amp; d = std::get&lt;double&gt;(y);  // 错误：非良构（歧义）

    // 注意：std::tie 和结构化绑定也可以用来分解元组为独立对象
}
|output=
( 1, Foo, 3.14 )
( 1, Foo, 3.14 )
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|dr=2485|wg=lwg|std=C++11（按索引）&lt;br&gt;C++14（按类型）|before=没有对于 {{c/core|const tuple&amp;&amp;}} 的重载|after=添加这些重载}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/language/dsc structured binding}}
{{dsc inc|cpp/container/array/dsc get}}
{{dsc inc|cpp/utility/pair/dsc get}}
{{dsc inc|cpp/utility/variant/dsc get}}
{{dsc inc|cpp/ranges/subrange/dsc get}}
{{dsc inc|cpp/numeric/complex/dsc get}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}