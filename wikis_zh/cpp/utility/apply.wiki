{{cpp/title|apply}}
{{cpp/utility/navbar}}

{{dcl begin}}
{{dcl header|tuple}}
{{dcl rev multi
|since1=c++17|dcl1=
template&lt; class F, class Tuple &gt;
constexpr decltype(auto) apply( F&amp;&amp; f, Tuple&amp;&amp; t );
|since2=c++23|dcl2=
template&lt; class F, tuple-like Tuple &gt;
constexpr decltype(auto) apply( F&amp;&amp; f, Tuple&amp;&amp; t ) noexcept(/* 见下文 */);
}}
{{dcl end}}

以元组 {{c|t}} 的各元素作为实参调用{{named req|Callable}}对象 {{c|f}}。

给定定义如下的仅用于阐述的函数 {{tti|apply-impl}}：

{{box|
{{c/core|template&lt;class F,class Tuple, std::size_t... I&gt;}}&lt;br&gt;
{{c/core|constexpr decltype(auto)}}&lt;br&gt;
{{nbspt|4}}{{tti|apply-impl}}{{c/core|(F&amp;&amp; f, Tuple&amp;&amp; t, std::index_sequence&lt;I...&gt;) // 仅用于阐述}}&lt;br&gt;
{{tt|{}}&lt;br&gt;
{{nbspt|4}}{{c/core|return}}{{nbspt}}{{lti|cpp/utility/functional|INVOKE}}{{c/core|(std::forward&lt;F&gt;(f), std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);}}&lt;br&gt;
{{tt|}&lt;!----&gt;}}
}}

效果等价于：

{{box|
{{c/core|return}}{{nbspt}}{{tti|apply-impl}}{{c/core|(std::forward&lt;F&gt;(f), std::forward&lt;Tuple&gt;(t),}}&lt;br&gt;
{{nbspt|18}}{{c/core|std::make_index_sequence&lt;}}&lt;br&gt;
{{nbspt|22}}{{c/core|std::tuple_size_v&lt;std::decay_t&lt;Tuple&gt;&gt;&gt;{});}}
}}.

===参数===
{{par begin}}
{{par|f|要调用的{{named req|Callable}}对象}}
{{par|t|其元素被用作 {{c|f}} 的实参的元组}}
{{par end}}

===返回值===
{{c|f}} 所返回的值。

===异常===
{{rrev multi|since2=c++23
|rev1=（无）
|rev2=
{{noexcept|
    noexcept(std::invoke(std::forward&lt;F&gt;(f),
                         std::get&lt;Is&gt;(std::forward&lt;Tuple&gt;(t))...))
}}

其中 {{tt|Is...}} 表示[[cpp/language/pack|包]]：
* {{c|0, 1, ..., std::tuple_size_v&lt;std::remove_reference_t&lt;Tuple&gt;&gt; - 1}}。
}}

===注解===
{{rev begin}}
{{rev|until=c++23|
{{tt|Tuple}} 不必是 {{lc|std::tuple}}，它可以是任何支持 {{ltt std|cpp/utility/tuple/get}} 和 {{ltt std|cpp/utility/tuple_size}} 的类型；特别是，可以使用 {{lc|std::array}} 和 {{lc|std::pair}}。
}}
{{rev|since=c++23|
{{tt|Tuple}} 被约束为元组式类型，即其中每个类型都必须是 {{lc|std::tuple}} 的特化，或者实现了 {{lti|cpp/utility/tuple/tuple-like}} 的其他任何类型（例如 {{lc|std::array}} 和 {{lc|std::pair}}）。
}}
{{rev end}}

{{feature test macro|__cpp_lib_apply|std=C++17|value=201603L|{{tt|std::apply}}}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;utility&gt;

int add(int first, int second) { return first + second; }

template&lt;typename T&gt;
T add_generic(T first, T second) { return first + second; }

auto add_lambda = [](auto first, auto second) { return first + second; };

template&lt;typename... Ts&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, std::tuple&lt;Ts...&gt; const&amp; theTuple)
{
    std::apply
    (
        [&amp;os](Ts const&amp;... tupleArgs)
        {
            os &lt;&lt; '[';
            std::size_t n{0};
            ((os &lt;&lt; tupleArgs &lt;&lt; (++n != sizeof...(Ts) ? ", " : "")), ...);
            os &lt;&lt; ']';
        }, theTuple
    );
    return os;
}

int main()
{
    // OK
    std::cout &lt;&lt; std::apply(add, std::pair(1, 2)) &lt;&lt; '\n';
    
    // 错误：无法推导函数类型
    // std::cout &lt;&lt; std::apply(add_generic, std::make_pair(2.0f, 3.0f)) &lt;&lt; '\n'; 
    
    // OK
    std::cout &lt;&lt; std::apply(add_lambda, std::pair(2.0f, 3.0f)) &lt;&lt; '\n'; 
    
    // 进阶示例
    std::tuple myTuple(25, "Hello", 9.31f, 'c');
    std::cout &lt;&lt; myTuple &lt;&lt; '\n';
}
|output=
3
5
[25, Hello, 9.31, c]
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc make_tuple}}
{{dsc inc|cpp/utility/tuple/dsc forward_as_tuple}}
{{dsc inc|cpp/utility/dsc make_from_tuple}}
{{dsc inc|cpp/utility/functional/dsc invoke}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}