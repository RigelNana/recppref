{{cpp/title|as_const}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|utility}}
{{dcl|since=c++17|num=1|1=
template&lt; class T &gt;
constexpr std::add_const_t&lt;T&gt;&amp; as_const( T&amp; t ) noexcept;
}}
{{dcl|since=c++17|num=2|1=
template&lt; class T &gt;
void as_const( const T&amp;&amp; ) = delete;
}}
{{dcl end}}

@1@ 形成到 {{tt|t}} 的 const 版本类型的左值引用。
@2@ const 右值引用重载被弃置，以禁止右值实参。

===可能的实现===
{{eq fun
|1=
template&lt;class T&gt;
constexpr std::add_const_t&lt;T&gt;&amp; as_const(T&amp; t) noexcept
{
    return t;
}
}}

===Notes===
{{feature test macro|__cpp_lib_as_const|value=201510L|std=C++17|[[#Top|{{tt|std::as_const}}]]}}

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;
#include &lt;utility&gt;

int main()
{
    std::string mutableString = "Hello World!";
    auto&amp;&amp; constRef = std::as_const(mutableString);

//  mutableString.clear(); // OK
//  constRef.clear(); // 错误：'constRef' 有 'const' 限定，但 'clear' 不标记为 const

    assert(&amp;constRef == &amp;mutableString);
    assert(&amp;std::as_const(mutableString) == &amp;mutableString);

    using ExprType = std::remove_reference_t&lt;decltype(std::as_const(mutableString))&gt;;

    static_assert(std::is_same_v&lt;std::remove_const_t&lt;ExprType&gt;, std::string&gt;,
                  "ExprType 应当为某种字符串。");
    static_assert(!std::is_same_v&lt;ExprType, std::string&gt;,
                  "ExprType 不能是可修改的字符串。");
}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_const}}
{{dsc inc|cpp/types/dsc add_cv}}
{{dsc inc|cpp/types/dsc remove_cv}}
{{dsc inc|cpp/ranges/dsc as_const_view}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}