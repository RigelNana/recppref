{{cpp/title|basic_stacktrace}}
{{cpp/utility/basic_stacktrace/navbar}}
{{dcl begin}}
{{dcl header|stacktrace}}
{{dcl|num=1|since=c++23|
template&lt; class Allocator &gt;
class basic_stacktrace;
}}
{{dcl|num=2|since=c++23|1=
using stacktrace =
    std::basic_stacktrace&lt;std::allocator&lt;std::stacktrace_entry&gt;&gt;;
}}
{{dcl|num=3|since=c++23|1=
namespace pmr {
using stacktrace =
    std::basic_stacktrace&lt;std::pmr::polymorphic_allocator&lt;std::stacktrace_entry&gt;&gt;;
}
}}
{{dcl end}}

@1@ {{tt|basic_stacktrace}} 类模板表示整个栈踪迹或其给定部分的快照。它满足{{named req|AllocatorAwareContainer}}、{{named req|SequenceContainer}}及{{named req|ReversibleContainer}}的要求，但仅支持移动、复制、交换和 const 限定的顺序容器上的操作，并且比较函数的语义不同于对容器所要求的语义。

@2@ 使用默认 {{lc|std::allocator}} 的 {{tt|basic_stacktrace}} 的便利类型别名。

@3@ 使用{{lt|cpp/memory/polymorphic allocator|多态分配器}}的 {{tt|basic_stacktrace}} 的便利类型别名。

当前执行线程中的当前求值 {{mathjax-or|\(\small{ {x}_{0} }\)|x&lt;sub&gt;0&lt;/sub&gt;}} 的''调用序列''，是求值的序列 {{mathjax-or|\(\small{ ({x}_{0}, \dots, {x}_{n})}\)|(x&lt;sub&gt;0&lt;/sub&gt;, ..., x&lt;sub&gt;n&lt;/sub&gt;)}}，它使得对于 {{mathjax-or|\(\small{i \ge 0}\)|i≥0}}，{{mathjax-or|\(\small{ {x}_{i} }\)|x&lt;sub&gt;i&lt;/sub&gt;}} 在函数调用 {{mathjax-or|\(\small{ {x}_{i+1} }\)|x&lt;sub&gt;i+1&lt;/sub&gt;}} 之内。

{{i|栈踪迹}}是调用序列的近似表示，由栈踪迹条目组成。

每个{{i|栈踪迹条目}}表示栈踪迹中的一项求值。它由 C++ 标准库中的 {{lc|std::stacktrace_entry}} 表示。

===模板形参===
{{par begin}}
{{par|Allocator|用于获取/释放内存及构造/销毁该内存中的元素的分配器。此类型必须符合{{named req|Allocator}}的要求。若 {{tt|Allocator::value_type}} 不是 {{lc|std::stacktrace_entry}} 则程序非良构。}}
{{par end}}

===成员类型===
{{dsc begin}}
{{dsc hitem|成员类型|定义}}
{{dsc|{{tt|value_type}}|{{lc|std::stacktrace_entry}}}}
{{dsc|{{tt|const_reference}}|{{co|const value_type&amp;}}}}
{{dsc|{{tt|reference}}|{{co|value_type&amp;}}}}
{{dsc|{{tt|const_iterator}}|实现定义的常量{{named req|RandomAccessIterator}}类型，实现 {{lconcept|random_access_iterator}}}}
{{dsc|{{tt|iterator}}|{{tt|const_iterator}}}}
{{dsc|{{tt|reverse_iterator}}|{{co|std::reverse_iterator&lt;iterator&gt;}}}}
{{dsc|{{tt|reverse_const_iterator}}|{{co|std::reverse_iterator&lt;const_iterator&gt;}}}}
{{dsc|{{tt|difference_type}}|实现定义的有符号整数类型}}
{{dsc|{{tt|size_type}}|实现定义的无符号整数类型}}
{{dsc|{{tt|allocator_type}}|{{tt|Allocator}}}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc constructor}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc destructor}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc operator{{=}}}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc current}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc get_allocator}}

{{dsc h2|迭代器}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc begin}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc end}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc rbegin}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc rend}}

{{dsc h2|容量}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc empty}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc size}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc max_size}}

{{dsc h2|元素访问}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc operator at}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc at}}

{{dsc h2|修改器}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc swap}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc tfun|cpp/utility/basic_stacktrace/operator cmp|title=operator==&lt;br&gt;operator&lt;=&gt;|notes={{mark c++23}}|比较两个 {{tt|basic_stacktrace}} 值的大小与内容}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc swap2}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc to_string}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc operator ltlt}}
{{dsc end}}

===辅助类===
{{dsc begin}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc hash}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc formatter}}
{{dsc end}}

===注解===
提供了对自定义分配器的支持，以便在热路径上或嵌入式环境中使用 {{tt|basic_stacktrace}}。用户可以在栈上或其他适合的位置分配 {{tt|stacktrace_entry}} 对象。

{{tt|std::basic_stacktrace}} 所拥有的 {{lc|std::stacktrace_entry}} 对象序列是不可变的，而且要么为空，要么表示整个栈踪迹的一个连续区间。

当 {{tt|std::basic_stacktrace}} 不可用时可以代之以使用 {{co|boost::stacktrace::basic_stacktrace}}（于 [https://www.boost.org/doc/libs/release/doc/html/stacktrace.html Boost.Stacktrace] 中可用）。

{{ftm begin|std=1|comment=1}}
{{ftm|__cpp_lib_stacktrace|std=C++23|value=202011L|[[#top|栈踪迹]]库}}
{{ftm|__cpp_lib_formatters|格式化 {{lc|std::thread::id}} 和 {{lc|std::stacktrace}}|value=202302L|std=C++23}}
{{ftm end}}

===示例===
{{example
|使用 Compiler Explorer 获得的输出结果：[https://godbolt.org/z/sjxvc97a7 msvc] 和 [https://godbolt.org/z/v117ccshs gcc]。
|code=
#include &lt;iostream&gt;
#include &lt;stacktrace&gt;

int nested_func(int c)
{
    std::cout &lt;&lt; std::stacktrace::current() &lt;&lt; '\n';
    return c + 1;
}

int func(int b)
{
    return nested_func(b + 1);
}

int main()
{
    std::cout &lt;&lt; func(777);
}
|p=true
|output=
// msvc 输出（以 '⤶' 箭头结尾的行被切分以适应宽度）：
0&gt; C:\Users\ContainerAdministrator\AppData\Local\Temp\compiler-explorer-compiler20221122-⤶
31624-2ja1sf.8ytzw\example.cpp(6): output_s!nested_func+0x1F
1&gt; C:\Users\ContainerAdministrator\AppData\Local\Temp\compiler-explorer-compiler20221122-⤶
31624-2ja1sf.8ytzw\example.cpp(12): output_s!func+0x15
2&gt; C:\Users\ContainerAdministrator\AppData\Local\Temp\compiler-explorer-compiler20221122-⤶
31624-2ja1sf.8ytzw\example.cpp(15): output_s!main+0xE
3&gt; D:\a\_work\1\s\src\vctools\crt\vcstartup\src\startup\exe_common.inl(288): output_s!⤶
__scrt_common_main_seh+0x10C
4&gt; KERNEL32!BaseThreadInitThunk+0x14
5&gt; ntdll!RtlUserThreadStart+0x21
779

gcc output:
   0# nested_func(int) at /app/example.cpp:7
   1# func(int) at /app/example.cpp:13
   2#      at /app/example.cpp:18
   3#      at :0
   4#      at :0
   5# 

779
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/dsc stacktrace_entry}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}