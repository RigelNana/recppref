{{cpp/title|tuple}}
{{cpp/utility/tuple/navbar}}
{{dcl begin}}
{{dcl header|tuple}}
{{dcl|since=c++11|
template&lt; class... Types &gt;
class tuple;
}}
{{dcl end}}

类模板 {{tt|std::tuple}} 是固定大小的异质值的汇集。它是 {{lc|std::pair}} 的泛化。

如果 {{c|std::is_trivially_destructible&lt;Ti&gt;::value}} 对 {{tt|Types}} 中的每个 {{tt|Ti}} 都是 {{c|true}}，那么 {{tt|std::tuple}} 的析构函数平凡。

如果程序声明了 {{tt|std::tuple}} 的[[cpp/language/template specialization|显式]]或[[cpp/language/partial specialization|部分]]特化，那么程序非良构，不要求诊断。

===模板形参===
{{par begin}}
{{par|Types...|{{tt|tuple}} 所存储的元素的类型。支持空列表。}}
{{par end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc constructor}}
{{dsc inc|cpp/utility/tuple/dsc operator{{=}}}}
{{dsc inc|cpp/utility/tuple/dsc swap}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc make_tuple}}
{{dsc inc|cpp/utility/tuple/dsc tie}}
{{dsc inc|cpp/utility/tuple/dsc forward_as_tuple}}
{{dsc inc|cpp/utility/tuple/dsc tuple_cat}}
{{dsc inc|cpp/utility/tuple/dsc get}}
{{dsc inc|cpp/utility/tuple/dsc operator_cmp}}
{{dsc inc|cpp/utility/tuple/dsc swap2}}
{{dsc end}}

===辅助概念===
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc tuple-like}}
{{dsc end}}

===辅助类===
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc tuple_size}}
{{dsc inc|cpp/utility/tuple/dsc tuple_element}}
{{dsc inc|cpp/utility/tuple/dsc uses_allocator}}
{{dsc inc|cpp/utility/tuple/dsc basic_common_reference}}
{{dsc inc|cpp/utility/tuple/dsc common_type}}
{{dsc inc|cpp/utility/format/dsc tuple_formatter|tuple}}
{{dsc inc|cpp/utility/tuple/dsc ignore}}
{{dsc end}}

===辅助特化===
{{dcl begin}}
{{dcl|since=c++23|1=
template&lt; class... Ts &gt;
constexpr bool enable_nonlocking_formatter_optimization&lt;std::tuple&lt;Ts...&gt;&gt; 
 = (enable_nonlocking_formatter_optimization&lt;Ts&gt; &amp;&amp; ...);
}}
{{dcl end}}

这个 {{ltt std|cpp/utility/format/enable_nonlocking_formatter_optimization}} 针对每个元素类型都已启用的 {{tt|tuple}} 对象的打印启用 {{ltt std|cpp/io/print}} 和 {{ltt std|cpp/io/println}} 的高效实现。

==={{rl|deduction guides|推导指引}}{{mark since c++17}}===

===注解===
由于元组的“形状”（其大小、各元素类型和这些类型的次序）是其类型签名的一部分，所以它们必须全部在编译时可用且仅对其他编译时信息有依赖。这意味着许多元组上的条件性运算（尤其是有条件的前附/后附和过滤）只有在其条件可以运行时求值时才可能进行。例如，给定 {{c/core|std::tuple&lt;int, double, int&gt;}}，对类型进行过滤是可能的——比如返回 {{c/core|std::tuple&lt;int, int&gt;}}——但不可能基于各个元素是否为正来过滤（这会造成其具有取决于元组的运行时值的不同类型签名），除非其所有元素自身也都是 {{c/core|constexpr}}。

作为变通可以使用 {{c/core|std::optional}} 的元组，但仍然不可能基于运行时信息调整其大小。

{{stddoc|N4387}}（作为对 C++11 的缺陷报告）前，函数不能用复制列表初始化返回 {{tt|tuple}}：
{{source|1=
std::tuple&lt;int, int&gt; foo_tuple() 
{
  return {1, -1};  // N4387 前错误
  return std::tuple&lt;int, int&gt;{1, -1};  // 始终有效
  return std::make_tuple(1, -1); // 始终有效
}
}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

std::tuple&lt;double, char, std::string&gt; get_student(int id)
{
    switch (id)
    {
        case 0: return {3.8, 'A', "Lisa Simpson"};
        case 1: return {2.9, 'C', "Milhouse Van Houten"};
        case 2: return {1.7, 'D', "Ralph Wiggum"};
        case 3: return {0.6, 'F', "Bart Simpson"};
    }
 
    throw std::invalid_argument("id");
}

int main()
{
    const auto student0 = get_student(0);
    std::cout &lt;&lt; "ID：0，"
              &lt;&lt; "GPA：" &lt;&lt; std::get&lt;0&gt;(student0) &lt;&lt; "，"
              &lt;&lt; "等级：" &lt;&lt; std::get&lt;1&gt;(student0) &lt;&lt; "，"
              &lt;&lt; "姓名：" &lt;&lt; std::get&lt;2&gt;(student0) &lt;&lt; '\n';
    
    const auto student1 = get_student(1);
    std::cout &lt;&lt; "ID：1，"
              &lt;&lt; "GPA：" &lt;&lt; std::get&lt;double&gt;(student1) &lt;&lt; "，"
              &lt;&lt; "等级：" &lt;&lt; std::get&lt;char&gt;(student1) &lt;&lt; "，"
              &lt;&lt; "姓名：" &lt;&lt; std::get&lt;std::string&gt;(student1) &lt;&lt; '\n';
    
    double gpa2;
    char grade2;
    std::string name2;
    std::tie(gpa2, grade2, name2) = get_student(2);
    std::cout &lt;&lt; "ID：2，"
              &lt;&lt; "GPA：" &lt;&lt; gpa2 &lt;&lt; "，"
              &lt;&lt; "等级：" &lt;&lt; grade2 &lt;&lt; "，"
              &lt;&lt; "姓名：" &lt;&lt; name2 &lt;&lt; '\n';
    
    // C++17 结构化绑定：
    const auto [gpa3, grade3, name3] = get_student(3);
    std::cout &lt;&lt; "ID：3，"
              &lt;&lt; "GPA：" &lt;&lt; gpa3 &lt;&lt; "，"
              &lt;&lt; "等级：" &lt;&lt; grade3 &lt;&lt; "，"
              &lt;&lt; "姓名：" &lt;&lt; name3 &lt;&lt; '\n';
}
|output=
ID：0，GPA：3.8，等级：A，姓名：Lisa Simpson
ID：1，GPA：2.9，等级：C，姓名：Milhouse Van Houten
ID：2，GPA：1.7，等级：D，姓名：Ralph Wiggum
ID：3，GPA：0.6，等级：F，姓名：Bart Simpson
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2796|std=C++11|before={{tt|std::tuple}} 的析构函数的平凡性未指明|after=已指明}}
{{dr list item|wg=lwg|dr=3990|std=C++11|before=程序可以声明 {{tt|std::tuple}} 的显式或部分特化|after=此时程序非良构（不要求诊断）}}
{{dr list end}}

===引用===
{{ref std c++23}}
{{ref std|section=22.4|title=Tuples|id=tuple}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=20.5|title=Tuples|id=tuple}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=23.5|title=Tuples|id=tuple}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=20.4|title=Tuples|id=tuple}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=20.4|title=Tuples|id=tuple}}
{{ref std end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/dsc pair}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|ko|pt|ru}}