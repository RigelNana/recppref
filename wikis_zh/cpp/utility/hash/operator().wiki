{{cpp/title|{{dsc small|hash&lt;Key&gt;::}}operator()}}
{{cpp/utility/hash/navbar}}

{{lc|std::hash}} 的特化应定义满足下列条件的 {{tt|operator()}}：

* 接收单个 {{tt|Key}} 类型的实参 {{c|key}}。
* 返回表示 {{c|key}} 的散列值的 {{c|std::size_t}} 类型的值。
* 对于两个相等的参数 {{tt|k1}} 与 {{tt|k2}}，{{c|1=std::hash&lt;Key&gt;()(k1) == std::hash&lt;Key&gt;()(k2)}}。
* 对于两个不相等的不同参数 {{tt|k1}} 与 {{tt|k2}}，{{c|1=std::hash&lt;Key&gt;()(k1) == std::hash&lt;Key&gt;()(k2)}} 的概率应该非常小，接近 {{c|1.0/std::numeric_limits&lt;size_t&gt;::max()}}。

===参数===
{{par begin}}
{{par|key|要被散列的对象}}
{{par end}}

===返回值===
表示散列值的 {{c|std::size_t}}。

===异常===
散列函数不应抛异常。

===示例===
{{example 
|下列代码演示如何为自定义类特化 {{lc|std::hash}} 模板。此散列函数使用 [[enwiki:Fowler–Noll–Vo hash function|Fowler–Noll–Vo]] 散列算法。
|code=
#include &lt;cstdint&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

struct Employee
{
    std::string name;
    std::uint64_t ID;
};

namespace std
{
    template &lt;&gt;
    class hash&lt;Employee&gt;
    {
    public:
        std::uint64_t operator()(const Employee&amp; employee) const
        {
             // 用 Fowler-Noll-Vo hash 哈散列函数的变体计算 employee 的散列值
             constexpr std::uint64_t prime{0x100000001B3};
             std::uint64_t result{0xcbf29ce484222325};

             for (std::uint64_t i{}, ie = employee.name.size(); i != ie; ++i)
                 result = (result * prime) ^ employee.name[i];

             return result ^ (employee.ID &lt;&lt; 1);
         }
    };
}

int main()
{
    Employee employee;
    employee.name = "Zaphod Beeblebrox";
    employee.ID = 42;

    std::hash&lt;Employee&gt; hash_fn;
    std::cout &lt;&lt; hash_fn(employee) &lt;&lt; '\n';
}
|output=12615575401975788567
}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}