{{cpp/title|unreachable}}
{{cpp/utility/program/navbar}}
{{ddcl|header=utility|since=c++23|
[[noreturn]] void unreachable();
}}

在指定位置引发[[cpp/language/ub|未定义行为]]。

实现可以（常在优化构建中）用它优化掉不可能的代码分支，或（常在调试构建中）使之进入陷阱以免后续执行。

===注解===
{{feature test macro|__cpp_lib_unreachable|std=C++23|value=202202L|{{tt|std::unreachable}}}}

===可能的实现===
{{eq fun
|1=
[[noreturn]] inline void unreachable()
{
    // 若可能则使用编译器特定的扩展。
    // 即使不使用扩展，空函数体与 noreturn 属性也足以引发未定义行为。
#if defined(_MSC_VER) &amp;&amp; !defined(__clang__) // MSVC
    __assume(false);
#else // GCC, Clang
    __builtin_unreachable();
#endif
}
}}

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;cstddef&gt;
#include &lt;cstdint&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

struct Color { std::uint8_t r, g, b, a; };

// 假设仅支持一组有限的材质容量。
void generate_texture(std::vector&lt;Color&gt;&amp; tex, std::size_t xy)
{
    switch (xy)
    {
    case 128: [[fallthrough]];
    case 256: [[fallthrough]];
    case 512: /* ... */
        tex.clear();
        tex.resize(xy * xy, Color{0, 0, 0, 0});
        break;
    default:
        std::unreachable();
    }
}

int main()
{
    std::vector&lt;Color&gt; tex;
    generate_texture(tex, 128); // OK
    assert(tex.size() == 128 * 128);
    generate_texture(tex, 32);  // 导致未定义行为
}
|p=true
|output=
Segmentation fault
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/language/attributes/dsc assume}}
{{dsc inc|cpp/memory/dsc assume_aligned}}
{{dsc see c|c/program/unreachable}}
{{dsc end}}

===外部链接===
{{elink begin}}
{{elink|[https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#index-_005f_005fbuiltin_005funreachable GCC 文档：{{tt|__builtin_unreachable}}]}}
{{elink|[https://clang.llvm.org/docs/LanguageExtensions.html#builtin-unreachable Clang 文档：{{tt|__builtin_unreachable}}]}}
{{elink|[https://docs.microsoft.com/en-us/cpp/intrinsics/assume MSVC 文档：{{tt|__assume}}]}}
{{elink end}}

{{langlinks|cs|de|en|es|fr|it|ja|ko|pl|pt|ru}}