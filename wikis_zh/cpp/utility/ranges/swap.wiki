{{cpp/ranges/title|swap}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|concepts}}
{{dcl|notes={{mark custpt}}|since=c++20|1=
namespace ranges {
    inline namespace /* 未指明 */ {
        inline constexpr /* 未指明 */ swap = /* 未指明 */;
    }
}
}}
{{dcl h|调用签名}}
{{dcl|since=c++20|1=
template&lt; class T, class U &gt;
constexpr void ranges::swap( T&amp;&amp; t, U&amp;&amp; u ) noexcept(/* 见下文 */);
}}
{{dcl end}}

交换 {{c|t}} 和 {{c|u}} 所引用的值。

{{c|ranges::swap(t, u)}} [[cpp/language/expressions#表达式等价|表达式等价]]于：
# {{c|(void)swap(t, u)}}，如果 {{c|t}} 或 {{c|u}} 具有类或枚举类型，并且在命名空间 {{tt|std::ranges}} 中，外加候选 {{c|1=template&lt;class T&gt; void swap(T&amp;, T&amp;) = delete;}} 进行[[cpp/language/overload resolution|重载决议]]时该表达式合法。
#* 如果重载决议所选择的函数没有交换 {{c|t}} 和 {{c|u}} 所引用的值，那么程序非良构；不要求诊断。
# 否则是 {{c|(void)ranges::swap_ranges(t, u)}}，如果 {{c|t}} 和 {{c|u}} 是长度相等（但元素类型可能不同）的数组左值，且 {{c|ranges::swap(*t, *u)}} 是合法表达式，但 {{c|noexcept(ranges::swap(t), ranges::swap(u))}} 等于 {{c|noexcept(ranges::swap(*t, *u))}}；
# 否则是一个交换 {{c|t}} 和 {{c|u}} 所引用的值的表达式，如果它们都是具有相同类型 {{tt|V}} 的左值，而 {{tt|V}} 实现 {{c|std::move_constructible&lt;V&gt;}} 和 {{c|std::assignable_from&lt;V&amp;, V&gt;}}。
#* 对该表达式应用 [[cpp/language/noexcept|{{tt|noexcept}} 运算符]]的结果等于 {{c|std::is_nothrow_move_constructible_v&lt;V&gt; &amp;&amp; std::is_nothrow_move_assignable_v&lt;V&gt;}}。
#* 该表达式在满足以下所有条件时是[[cpp/language/constant expression|常量表达式]]：
#** {{tt|V}} 是{{named req|LiteralType}}
#** {{c|1=t = std::move(u))}} 和 {{c|1=u = std::move(t)}} 都是[[cpp/language/constant expression#常量子表达式|常量子表达式]]
#** 以下声明中的初始化式的[[cpp/language/expressions#完整表达式|完整表达式]]都是常量子表达式：
#*** {{c|V v1(std::move(t));}}
#*** {{c|V v2(std::move(u));}}
# 否则，{{c|ranges::swap(t, u)}} 非良构，这能在 {{c|ranges::swap(t, u)}} 出现于模板实例化的立即语境时导致[[cpp/language/sfinae|代换失败]]。

{{cpp/ranges/cpo}}

===示例===
{{example
|code=
#include &lt;array&gt;
#include &lt;concepts&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

void print(std::string_view name, 
           std::ranges::common_range auto const&amp; p, 
           std::ranges::common_range auto const&amp; q)
{
    std::cout &lt;&lt; name &lt;&lt; "1{ ";
    for (auto const&amp; i : p)
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; "}，" &lt;&lt; name &lt;&lt; "2{ ";
    for (auto const&amp; i : q)
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; "}\n";
}

void print(std::string_view name, int p, int q)
{
    std::cout &lt;&lt; name &lt;&lt; "1 = " &lt;&lt; p &lt;&lt; "，" &lt;&lt; name &lt;&lt; "2 = " &lt;&lt; q &lt;&lt; '\n';
}

struct IntLike
{
    int v;
};

void swap(IntLike&amp; lhs, int&amp; rhs)
{
    std::swap(lhs.v, rhs);
}

void swap(int&amp; lhs, IntLike&amp; rhs)
{
    std::swap(lhs, rhs.v);
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, IntLike i)
{
    return out &lt;&lt; i.v;
}

int main()
{
    std::vector a1{10, 11, 12}, a2{13, 14};
    std::ranges::swap(a1, a2);
    print("a", a1, a2);
    
    std::array b1{15, 16, 17}, b2{18, 19, 20};
    std::ranges::swap(b1, b2);
    print("b", b1, b2);
    
    // std::array c1{1, 2, 3}; std::array c2{4, 5};
    // std::ranges::swap(c1, c2); // 错误：ADL 没有找到 swap
    
    int d1[]{21, 22, 23}, d2[]{24, 25, 26};
    std::ranges::swap(d1, d2);
    print("d", d1, d2);
 
    // int e1[]{1, 2, 3}, e2[]{4, 5};
    // std::ranges::swap(e1, e2); // 错误：长度不匹配
 
    // char f1[]{1, 2, 3};
    // int  f2[]{4, 5, 6};
    // std::ranges::swap(f1, f2); // 错误：ADL 没有找到 swap(*f1, *f2)
 
    IntLike g1[]{1, 2, 3};
    int     g2[]{4, 5, 6};
    std::ranges::swap(g1, g2); // 支持异质交换
    print("g", g1, g2);
 
    int h1{27}, h2{28};
    std::ranges::swap(h1, h2);
    print("h", h1, h2);
}
|output=
a1{ 13 14 }，a2{ 10 11 12 }
b1{ 18 19 20 }，b2{ 15 16 17 }
d1{ 24 25 26 }，d2{ 21 22 23 }
g1{ 4 5 6 }，g2{ 1 2 3 }
h1 = 28，h2 = 27
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/concepts/dsc swappable}}
{{dsc inc|cpp/algorithm/dsc swap}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}