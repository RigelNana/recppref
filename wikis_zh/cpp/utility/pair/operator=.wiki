{{cpp/utility/pair/title|operator{{=}}}}
{{cpp/utility/pair/navbar}}
{{dcl begin}}
{{dcl rev multi|num=1|dcl1=
pair&amp; operator=( const pair&amp; other );
|since2=c++20|dcl2=
constexpr pair&amp; operator=( const pair&amp; other );
}}
{{dcl|num=2
|since=c++23|1=
constexpr const pair&amp; operator=( const pair&amp; other ) const;
}}
{{dcl rev multi|num=3
|dcl1=
template&lt; class U1, class U2 &gt;
pair&amp; operator=( const pair&lt;U1, U2&gt;&amp; other );
|since2=c++20|dcl2=
template&lt; class U1, class U2 &gt;
constexpr pair&amp; operator=( const pair&lt;U1, U2&gt;&amp; other );
}}
{{dcl|num=4
|since=c++23|1=
template&lt; class U1, class U2 &gt;
constexpr const pair&amp; operator=( const pair&lt;U1, U2&gt;&amp; other ) const;
}}
{{dcl rev multi|num=5
|since1=c++11|dcl1=
pair&amp; operator=( pair&amp;&amp; other ) noexcept(/* 见下文 */);
|since2=c++20|dcl2=
constexpr pair&amp; operator=( pair&amp;&amp; other ) noexcept(/* 见下文 */);
}}
{{dcl|num=6
|since=c++23|1=
constexpr const pair&amp; operator=( pair&amp;&amp; other ) const;
}}
{{dcl rev multi|num=7|since1=c++11|dcl1=
template&lt; class U1, class U2 &gt;
pair&amp; operator=( pair&lt;U1, U2&gt;&amp;&amp; p );
|since2=c++20|dcl2=
template&lt; class U1, class U2 &gt;
constexpr pair&amp; operator=( pair&lt;U1, U2&gt;&amp;&amp; p );
}}
{{dcl|num=8
|since=c++23|1=
template&lt; class U1, class U2 &gt;
constexpr const pair&amp; operator=( pair&lt;U1, U2&gt;&amp;&amp; p ) const;
}}
{{dcl|num=9|since=c++23|1=
template&lt; pair-like P &gt;
constexpr pair&amp; operator=( P&amp;&amp; u );
}}
{{dcl|num=10|since=c++23|1=
template&lt; pair-like P &gt;
constexpr const pair&amp; operator=( P&amp;&amp; u ) const;
}}
{{dcl end}}

替换对偶的内容。

@1@ 复制赋值运算符。以 {{c|other}} 内容的副本替换内容。
{{rrev multi|until1=c++11|rev1=
此赋值运算符被隐式声明。如果 {{tt|T1}} 或 {{tt|T2}} 之一是有 const 限定的类型或引用类型，或是拥有不可访问的复制赋值运算符的类类型或这种类的数组类型，那么使用此赋值运算符会导致程序非良构。
|rev2=
如果 {{c|std::is_copy_assignable&lt;T1&gt;::value}} 或 {{c|std::is_copy_assignable&lt;T2&gt;::value}} 之一是 {{c|false}}，那么此重载被定义为弃置。
}}

@2@ 针对 const 限定操作数的复制赋值运算符。
@@ {{cpp/enable if| {{c|std::is_copy_assignable_v&lt;const T1&gt;}} 和 {{c|std::is_copy_assignable_v&lt;const T2&gt;}} 都是 {{c|true}} }}。
 
@3@ 将 {{c|other.first}} 赋给 {{tt|first}}，{{c|other.second}} 赋给 {{tt|second}}。
{{rrev|since=c++11|
{{cpp/enable if| {{c|std::is_assignable&lt;T1&amp;, const U1&amp;&gt;::value}} 和 {{c|std::is_assignable&lt;T2&amp;, const U2&amp;&gt;::value}} 都是 {{c|true}} }}。
}}

@4@ 将 {{c|other.first}} 赋给 {{tt|first}}，{{c|other.second}} 赋给 {{tt|second}}。
@@ {{cpp/enable if| {{c|std::is_assignable_v&lt;const T1&amp;, const U1&amp;&gt;}} 和 {{c|std::is_assignable_v&lt;const T2&amp;, const U2&amp;&gt;}} 都是 {{c|true}} }}。

@5@ 移动赋值运算符。用移动语义以 {{c|other}} 的内容替换内容。
@@ {{cpp/enable if| {{c|std::is_move_assignable&lt;T1&gt;::value}} 和 {{c|std::is_move_assignable&lt;T2&gt;::value}} 都是 {{c|true}} }}。

@6@ 针对 const 限定操作数的移动赋值运算符。
@@ {{cpp/enable if| {{c|std::is_assignable_v&lt;const T1&amp;, T1&gt;}} 和 {{c|std::is_assignable_v&lt;const T2&amp;, T2&gt;}} 都是 {{c|true}} }}。

@7@ 赋值 {{c|std::forward&lt;U1&gt;(p.first)}} 给 {{tt|first}}，{{c|std::forward&lt;U2&gt;(p.second)}} 给 {{tt|second}}。
@@ {{cpp/enable if| {{c|std::is_assignable&lt;T1&amp;, U1&gt;::value}} 和 {{c|std::is_assignable&lt;T2&amp;, U2&gt;::value}} 都是 {{c|true}} }}。

@8@ 赋值 {{c|std::forward&lt;U1&gt;(p.first)}} 给 {{tt|first}}，{{c|std::forward&lt;U2&gt;(p.second)}} 给 {{tt|second}}。
@@ {{cpp/enable if| {{c|std::is_assignable_v&lt;const T1&amp;, U1&gt;}} 和 {{c|std::is_assignable_v&lt;const T2&amp;, U2&gt;}} 都是 {{c|true}} }}。

@9@ 赋值 {{c|std::get&lt;0&gt;(std::forward&lt;P&gt;(u))}} 给 {{tt|first}}，{{c|std::get&lt;1&gt;(std::forward&lt;P&gt;(u))}} 给 {{tt|second}}。
@@ {{cpp/enable if|
* {{c|std::same_as&lt;std::remove_cvref_t&lt;P&gt;, std::pair&gt;}} 是 {{c|false}}，
* {{c/core|std::remove_cvref_t&lt;P&gt;}} 不是 {{l2tt std|cpp/ranges/subrange}} 的特化，
* {{c|std::is_assignable_v&lt;T1&amp;, decltype(std::get&lt;0&gt;(std::forward&lt;P&gt;(p)))&gt;}} 是 {{c|true}}，并且
* {{c|std::is_assignable_v&lt;T1&amp;, decltype(std::get&lt;1&gt;(std::forward&lt;P&gt;(p)))&gt;}} 是 {{c|true}}
}}。

@10@ 赋值 {{c|std::get&lt;0&gt;(std::forward&lt;P&gt;(u))}} 给 {{tt|first}}，{{c|std::get&lt;1&gt;(std::forward&lt;P&gt;(u))}} 给 {{tt|second}}。
@@ {{cpp/enable if|
* {{c|std::same_as&lt;std::remove_cvref_t&lt;P&gt;, std::pair&gt;}} 是 {{c|false}}，
* {{c/core|std::remove_cvref_t&lt;P&gt;}} 不是 {{l2tt std|cpp/ranges/subrange}} 的特化，
* {{c|std::is_assignable_v&lt;const T1&amp;, decltype(std::get&lt;0&gt;(std::forward&lt;P&gt;(p)))&gt;}} 是 {{c|true}}，并且
* {{c|std::is_assignable_v&lt;const T1&amp;, decltype(std::get&lt;1&gt;(std::forward&lt;P&gt;(p)))&gt;}} 是 {{c|true}}
}}。

===参数===
{{par begin}}
{{par|other|包含用来替换此对偶内容的值对偶}}
{{par|p|包含用来替换此对偶内容的（类型可能不同的）值的对偶}}
{{par|u|包含用来替换此对偶内容的值的{{lti|cpp/utility/tuple/tuple-like|对偶式}}对象}}
{{par hreq}}
{{par req|{{tt|T1}} 必须符合从 {{tt|U1}} {{named req|CopyAssignable}}的要求。{{mark until c++11}}}}
{{par req|{{tt|T2}} 必须符合从 {{tt|U2}} {{named req|CopyAssignable}}的要求。{{mark until c++11}}}}
{{par end}} 

===返回值===
{{c|*this}}

===异常===
@1-4@ {{cpp/impldef exception item}}
@5@ {{noexcept|
    std::is_nothrow_move_assignable&lt;T1&gt;::value &amp;&amp;
    std::is_nothrow_move_assignable&lt;T2&gt;::value
}}
@6-10@ {{cpp/impldef exception item}}

===示例===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template&lt;class Os, class T&gt;
Os&amp; operator&lt;&lt;(Os&amp; os, const std::vector&lt;T&gt;&amp; v)
{
    os &lt;&lt; '{';
    for (std::size_t t = 0; t != v.size(); ++t)
        os &lt;&lt; v[t] &lt;&lt; (t + 1 &lt; v.size() ? ", " : "");
    return os &lt;&lt; '}';
}

template&lt;class Os, class U1, class U2&gt;
Os&amp; operator&lt;&lt;(Os&amp; os, const std::pair&lt;U1, U2&gt;&amp; pair)
{
    return os &lt;&lt; '{' &lt;&lt; pair.first &lt;&lt; ", " &lt;&lt; pair.second &lt;&lt; '}';
}

int main()
{
    std::pair&lt;int, std::vector&lt;int&gt;&gt; p{1, {2}&lt;!----&gt;}, q{2, {5, 6}&lt;!----&gt;}
    
    p = q; // (1) operator=( const pair&amp; other );
    std::cout &lt;&lt; std::setw(23) &lt;&lt; std::left
              &lt;&lt; "(1) p = q;"
              &lt;&lt; "p: " &lt;&lt; p &lt;&lt; "     q: " &lt;&lt; q &lt;&lt; '\n';
    
    std::pair&lt;short, std::vector&lt;int&gt;&gt; r{4, {7, 8, 9}&lt;!----&gt;};
    p = r; // (3) operator=( const pair&lt;U1, U2&gt;&amp; other );
    std::cout &lt;&lt; std::setw(23)
              &lt;&lt; "(3) p = r;"
              &lt;&lt; "p: " &lt;&lt; p &lt;&lt; "  r: " &lt;&lt; r &lt;&lt; '\n';
    
    p = std::pair&lt;int, std::vector&lt;int&gt;&gt;{3, {4}&lt;!----&gt;};
    p = std::move(q); // (5) operator=( pair&amp;&amp; other );
    std::cout &lt;&lt; std::setw(23)
              &lt;&lt; "(5) p = std::move(q);"
              &lt;&lt; "p: " &lt;&lt; p &lt;&lt; "     q: " &lt;&lt; q &lt;&lt; '\n';
    
    p = std::pair&lt;int, std::vector&lt;int&gt;&gt;{5, {6}&lt;!----&gt;};
    p = std::move(r); // (7) operator=( pair&lt;U1, U2&gt;&amp;&amp; other );
    std::cout &lt;&lt; std::setw(23)
              &lt;&lt; "(7) p = std::move(r);"
              &lt;&lt; "p: " &lt;&lt; p &lt;&lt; "  r: " &lt;&lt; r &lt;&lt; '\n';
}
|output=
&lt;nowiki&gt;
(1) p = q;             p: {2, {5, 6}}     q: {2, {5, 6}}
(3) p = r;             p: {4, {7, 8, 9}}  r: {4, {7, 8, 9}}
(5) p = std::move(q);  p: {2, {5, 6}}     q: {2, {}}
(7) p = std::move(r);  p: {4, {7, 8, 9}}  r: {4, {}}
&lt;/nowiki&gt;
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=885|std=C++98|before=缺失了异质复制赋值|after=已（作为重载 {{v|3}}）添加}}
{{dr list item|wg=lwg|dr=2729|std=C++11|before={{c/core|1=operator=}} 未被约束并可能导致不必要的未定义行为|after=已约束}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc operator{{=}}}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}