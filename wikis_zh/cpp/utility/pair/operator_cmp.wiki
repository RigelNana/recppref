{{title|1=operator==,!=,&lt;,&lt;=,&gt;,&gt;=,&lt;=&gt;&lt;small&gt;(std::pair)&lt;/small&gt;}}
{{cpp/utility/pair/navbar}}
{{dcl begin}}
{{dcl header|utility}}
{{dcl rev multi|num=1
|until1=c++14|dcl1=
template&lt; class T1, class T2, class U1, class U2 &gt;
bool operator==( const std::pair&lt;T1, T2&gt;&amp; lhs, const std::pair&lt;U1, U2&gt;&amp; rhs );
|dcl2=
template&lt; class T1, class T2, class U1, class U2 &gt;
constexpr bool operator==( const std::pair&lt;T1, T2&gt;&amp; lhs,
                           const std::pair&lt;U1, U2&gt;&amp; rhs );
}}
{{dcl rev multi|num=2
|until1=c++14|dcl1=
template&lt; class T1, class T2, class U1, class U2 &gt;
bool operator!=( const std::pair&lt;T1, T2&gt;&amp; lhs, const std::pair&lt;U1, U2&gt;&amp; rhs );
|until2=c++20|dcl2=
template&lt; class T1, class T2, class U1, class U2 &gt;
constexpr bool operator!=( const std::pair&lt;T1, T2&gt;&amp; lhs,
                           const std::pair&lt;U1, U2&gt;&amp; rhs );
}}
{{dcl rev multi|num=3
|until1=c++14|dcl1=
template&lt; class T1, class T2, class U1, class U2 &gt;
bool operator&lt;( const std::pair&lt;T1, T2&gt;&amp; lhs, const std::pair&lt;U1, U2&gt;&amp; rhs );
|until2=c++20|dcl2=
template&lt; class T1, class T2, class U1, class U2 &gt;
constexpr bool operator&lt;( const std::pair&lt;T1, T2&gt;&amp; lhs,
                          const std::pair&lt;U1, U2&gt;&amp; rhs );
}}
{{dcl rev multi|num=4
|until1=c++14|dcl1=
template&lt; class T1, class T2, class U1, class U2 &gt;
bool operator&lt;=( const std::pair&lt;T1, T2&gt;&amp; lhs, const std::pair&lt;U1, U2&gt;&amp; rhs );
|until2=c++20|dcl2=
template&lt; class T1, class T2, class U1, class U2 &gt;
constexpr bool operator&lt;=( const std::pair&lt;T1, T2&gt;&amp; lhs,
                           const std::pair&lt;U1, U2&gt;&amp; rhs );
}}
{{dcl rev multi|num=5
|until1=c++14|dcl1=
template&lt; class T1, class T2, class U1, class U2 &gt;
bool operator&gt;( const std::pair&lt;T1, T2&gt;&amp; lhs, const std::pair&lt;U1, U2&gt;&amp; rhs );
|until2=c++20|dcl2=
template&lt; class T1, class T2, class U1, class U2 &gt;
constexpr bool operator&gt;( const std::pair&lt;T1, T2&gt;&amp; lhs,
                          const std::pair&lt;U1, U2&gt;&amp; rhs );
}}
{{dcl rev multi|num=6
|until1=c++14|dcl1=
template&lt; class T1, class T2, class U1, class U2 &gt;
bool operator&gt;=( const std::pair&lt;T1, T2&gt;&amp; lhs, const std::pair&lt;U1, U2&gt;&amp; rhs );
|until2=c++20|dcl2=
template&lt; class T1, class T2, class U1, class U2 &gt;
constexpr bool operator&gt;=( const std::pair&lt;T1, T2&gt;&amp; lhs,
                           const std::pair&lt;U1, U2&gt;&amp; rhs );
}}
{{dcl|num=7|since=c++20|1=
template&lt; class T1, class T2, class U1, class U2 &gt;
constexpr std::common_comparison_category_t&lt;synth-three-way-result&lt;T1, U1&gt;,
                                            synth-three-way-result&lt;T2, U2&gt;&gt;
    operator&lt;=&gt;( const std::pair&lt;T1, T2&gt;&amp; lhs, const std::pair&lt;U1, U2&gt;&amp; rhs );
}}
{{dcl end}}

@1-2@ 测试 {{c|lhs}} 和 {{c|rhs}} 的两个元素是否都各自相等，即分别比较 {{c|lhs.first}} 和 {{c|rhs.first}}，以及 {{c|lhs.second}} 和 {{c|rhs.second}}。&lt;br&gt;&lt;!--
--&gt;{{rrev multi|rev1=
如果 {{c|1=lhs.first == rhs.first}} 或 {{c|1=lhs.second == rhs.second}} 的类型与值类别不符合{{named req|BooleanTestable}}要求，则行为未定义。
|since2=c++26|rev2=
{{cpp/enable_if| {{c|1=decltype(lhs.first == rhs.first)}} 和 {{c|1=decltype(lhs.second == rhs.second)}} 均实现 {{lconcept|boolean-testable}} }}。
}}

@3-6@ 用 {{tt|operator&lt;}} 按字典序比较 {{c|lhs}} 和 {{c|rhs}}，即比较首元素，然后只有在它们等价时再比较第二元素。如果 {{c|1=lhs.first &lt; rhs.first}}、 {{c|1=rhs.first &lt; lhs.first}} 或 {{c|1=lhs.second &lt; rhs.second}} 中任何一者的类型与值类别不符合{{named req|BooleanTestable}}要求，则行为未定义。

@7@ 用 {{lti|cpp/standard library/synth-three-way}} 按字典序比较 {{c|lhs}} 和 {{c|rhs}}，即比较首元素，然后只有在它们等价时再比较第二元素。{{lti|cpp/standard library/synth-three-way|synth-three-way-result}} 是 {{tti|synth-three-way}} 的返回类型。

{{rrev|since=c++20|
{{cpp/note synthesized compare}}
}}

===参数===
{{par begin}}
{{par|lhs, rhs|要比较的对偶}}
{{par end}} 

===返回值===
@1@ 在 {{c|1=lhs.first == rhs.first}} 且 {{c|1=lhs.second == rhs.second}} 时返回 {{c|true}}，否则返回 {{c|false}}。

@2@ {{c|1=!(lhs == rhs)}}

@3@ 在 {{c|lhs.first &lt; rhs.first}} 时返回 {{c|true}}。否则在 {{c|rhs.first &lt; lhs.first}} 时返回 {{c|false}}。否则在 {{c|lhs.second &lt; rhs.second}} 时返回 {{c|true}}。否则返回 {{c|false}}。

@4@ {{c|!(rhs &lt; lhs)}}

@5@ {{c|rhs &lt; lhs}}

@6@ {{c|!(lhs &lt; rhs)}}

@7@ 在 {{box|{{lti|cpp/standard library/synth-three-way}}{{c/core|(lhs.first, rhs.first)}}}} 不等于 {{c|0}} 时返回它，否则返回 {{box|{{lti|cpp/standard library/synth-three-way}}{{c/core|(lhs.second, rhs.second)}}}}。

===注解===
{{rrev multi|rev1=
各关系运算符是基于各个元素的 {{c/core|operator&lt;}} 定义的。
|since2=c++20|rev2=
各关系运算符是基于 {{lti|cpp/standard library/synth-three-way}} 定义的，若有可能则它会使用 {{c/core|1=operator&lt;=&gt;}}，否则使用 {{c/core|operator&lt;}}。

要注意，如果元素类型自身并不提供 {{c/core|1=operator&lt;=&gt;}}，但可以隐式转换为可三路比较的类型，则就会用这项转换来替代 {{c/core|operator&lt;}}。
}}

{{feature test macro|__cpp_lib_constrained_equality|{{lc|std::pair}} 的受约束的 {{c/core|1=operator==}}|value=202403L|std=C++26}}

===示例===
{{example
|因为为对偶定义了 {{c/core|operator&lt;}}，所以存储对偶的容器可以排序。
|code=
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;std::pair&lt;int, std::string&gt;&gt; v = {&lt;!----&gt;{2, "baz"}, {2, "bar"}, {1, "foo"}&lt;!----&gt;};
    std::sort(v.begin(), v.end());
    
    for (auto p : v)
        std::cout &lt;&lt; '{' &lt;&lt; p.first &lt;&lt; ", " &lt;&lt; std::quoted(p.second) &lt;&lt; "}\n";
}
|output=
{1, "foo"}
{2, "bar"}
{2, "baz"}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=296|std=C++98|before=缺失了除了 {{tt|1===}} 和 {{tt|&lt;}} 以外的运算符的描述|after=已补充}}
{{dr list item|wg=lwg|dr=2114|paper=P2167R3|std=C++98|before=缺少布尔运算的类型前条件|after=已添加}}
{{dr list item|wg=lwg|dr=3865|std=C++98|before=比较运算符仅接受同类型的 {{tt|pair}}|after=接受不同类型的 {{tt|pair}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc operator cmp}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}