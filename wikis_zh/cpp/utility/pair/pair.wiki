{{cpp/utility/pair/title|pair}}
{{cpp/utility/pair/navbar}}
{{dcl begin}}
{{dcla|num=1|constexpr=c++11|notes={{mark|C++11 起条件性 explicit}}|1=
pair();
}}
{{dcl|num=2|notes={{mark|C++11 起条件性 explicit}}&lt;br&gt;{{mark constexpr since c++14}}|1=
pair( const T1&amp; x, const T2&amp; y );
}}
{{dcl rev multi|num=3 
|since1=c++11|notes1={{mark constexpr since c++14}}&lt;br&gt;{{mark|条件性 explicit}}|dcl1=
template&lt; class U1, class U2 &gt;
pair( U1&amp;&amp; x, U2&amp;&amp; y );
|since2=c++23|notes2={{mark|条件性 explicit}}|dcl2=
template&lt; class U1 = T1, class U2 = T2 &gt;
constexpr pair( U1&amp;&amp; x, U2&amp;&amp; y );
}}
{{dcl|num=4|since=c++23|notes={{mark|条件性 explicit}}|
template&lt; class U1, class U2 &gt;
constexpr pair( pair&lt;U1, U2&gt;&amp; p );
}}
{{dcl|num=5|notes={{mark|C++11 起条件性 explicit}}&lt;br&gt;{{mark constexpr since c++14}}|
template&lt; class U1, class U2 &gt;
pair( const pair&lt;U1, U2&gt;&amp; p );
}}
{{dcla|num=6|constexpr=c++14|notes={{mark|C++11 起条件性 explicit}}|
template&lt; class U1, class U2 &gt;
pair( pair&lt;U1, U2&gt;&amp;&amp; p );
}}
{{dcl|num=7|since=c++23|notes={{mark|条件性 explicit}}|
template&lt; class U1, class U2 &gt;
constexpr pair( const pair&lt;U1, U2&gt;&amp;&amp; p );
}}
{{dcl|num=8|since=c++23|notes={{mark|条件性 explicit}}|
template&lt; pair-like P &gt;
constexpr pair ( P&amp;&amp; u );
}}
{{dcla|num=9|since=c++11|constexpr=c++20|
template&lt; class... Args1, class... Args2 &gt;
pair( std::piecewise_construct_t,
      std::tuple&lt;Args1...&gt; first_args,
      std::tuple&lt;Args2...&gt; second_args );
}}
{{dcl|num=10|1=
pair( const pair&amp; p ) = default;
}}
{{dcl|num=11|since=c++11|1=
pair( pair&amp;&amp; p ) = default;
}}
{{dcl end}}

构造新的对偶。

@1@ 默认构造函数。值初始化对偶的两个元素 {{tt|first}} 和 {{tt|second}}。
{{rrev|since=c++11|
此构造函数当且仅当 {{c|std::is_default_constructible_v&lt;T1&gt;}} 与 {{c|std::is_default_constructible_v&lt;T2&gt;}} 都是 {{c|true}} 时参与重载决议。

此构造函数当且仅当 {{tt|T1}} 或 {{tt|T2}} 不可隐式默认构造时是 {{c/core|explicit}} 的。
}}

@2@ 以 {{c|x}} 初始化 {{tt|first}} 并以 {{c|y}} 初始化 {{tt|second}}。
{{rrev|since=c++11|
此构造函数当且仅当 {{c|std::is_copy_constructible_v&lt;T1&gt;}} 与 {{c|std::is_copy_constructible_v&lt;T2&gt;}} 都是 {{c|true}} 时参与重载决议。

此构造函数当且仅当 {{c|std::is_convertible_v&lt;const T1&amp;, T1&gt;}} 是 {{c|false}} 或 {{c|std::is_convertible_v&lt;const T2&amp;, T2&gt;}} 是 {{c|false}} 时是 {{c/core|explicit}} 的。
}}

@3@ 以 {{c|std::forward&lt;U1&gt;(x)}} 初始化 {{tt|first}} 并以 {{c|std::forward&lt;U2&gt;(y)}} 初始化 {{tt|second}}。
@@ 此构造函数当且仅当 {{c|std::is_constructible_v&lt;T1, U1&gt;}} 和 {{c|std::is_constructible_v&lt;T2, U2&gt;}} 都是 {{c|true}} 时参与重载决议。
@@ 此构造函数当且仅当 {{c|std::is_convertible_v&lt;U1, T1&gt;}} 是 {{c|false}} 或 {{c|std::is_convertible_v&lt;U2, T2&gt;}} 是 {{c|false}} 时是 {{c/core|explicit}} 的。
{{rrev|since=c++23|
如果 {{tt|first}} 或 {{tt|second}} 的初始化会[[cpp/language/reference initialization#临时量的生存期|绑定引用到临时对象]]，那么此构造函数会定义为被弃置。
}}

@4@ 以 {{c|p.first}} 初始化 {{tt|first}} 并以 {{c|p.second}} 初始化 {{tt|second}}。
@@ 此构造函数当且仅当 {{c|std::is_constructible_v&lt;T1, U1&amp;&gt;}} 和 {{c|std::is_constructible_v&lt;T2, U2&amp;&gt;}} 都是 {{c|true}} 时参与重载决议。
@@ 此构造函数当且仅当 {{c|std::is_convertible_v&lt;U1&amp;, T1&gt;}} 是 {{c|false}} 或 {{c|std::is_convertible_v&lt;U2&amp;, T2&gt;}} 是 {{c|false}} 时是 {{c/core|explicit}} 的。
@@ 如果 {{tt|first}} 或 {{tt|second}} 的初始化会绑定引用到临时对象，那么此构造函数会定义为被弃置。

@5@ 以 {{c|p.first}} 初始化 {{tt|first}} 并以 {{c|p.second}} 初始化 {{tt|second}}。
{{rrev|since=c++11|
此构造函数当且仅当 {{c|std::is_constructible_v&lt;T1, const U1&amp;&gt;}} 和 {{c|std::is_constructible_v&lt;T2, const U2&amp;&gt;}} 都是 {{c|true}} 时参与重载决议。

此构造函数当且仅当 {{c|std::is_convertible_v&lt;const U1&amp;, T1&gt;}} 是 {{c|false}} 或 {{c|std::is_convertible_v&lt;const U2&amp;, T2&gt;}} 是 {{c|false}} 时是 {{c/core|explicit}} 的。
}}
{{rrev|since=c++23|
如果 {{tt|first}} 或 {{tt|second}} 的初始化会绑定引用到临时对象，那么此构造函数会定义为被弃置。
}}

@6@ 以 {{c|std::forward&lt;U1&gt;(p.first)}} 初始化 {{tt|first}} 并以 {{c|std::forward&lt;U2&gt;(p.second)}} 初始化 {{tt|second}}。
@@ 此构造函数当且仅当 {{c|std::is_constructible_v&lt;T1, U1&gt;}} 和 {{c|std::is_constructible_v&lt;T2, U2&gt;}} 都是 {{c|true}} 时参与重载决议。
@@ 此构造函数当且仅当 {{c|std::is_convertible_v&lt;U1, T1&gt;}} 是 {{c|false}} 或 {{c|std::is_convertible_v&lt;U2, T2&gt;}} 是 {{c|false}} 时是 {{c/core|explicit}} 的。
{{rrev|since=c++23|
如果 {{tt|first}} 或 {{tt|second}} 的初始化会绑定引用到临时对象，那么此构造函数会定义为被弃置。
}}

@7@ 以 {{c|std::forward&lt;const U1&gt;(p.first)}} 初始化 {{tt|first}} 并以 {{c|std::forward&lt;const U2&gt;(p.second)}} 初始化 {{tt|second}}。
@@ 此构造函数当且仅当 {{c|std::is_constructible_v&lt;T1, const U1&gt;}} 和 {{c|std::is_constructible_v&lt;T2, const U2&gt;}} 都是 {{c|true}} 时参与重载决议。
@@ 此构造函数当且仅当 {{c|std::is_convertible_v&lt;const U1, T1&gt;}} 是 {{c|false}} 或 {{c|std::is_convertible_v&lt;const U2, T2&gt;}} 是 {{c|false}} 时是 {{c/core|explicit}} 的。
@@ 如果 {{tt|first}} 或 {{tt|second}} 的初始化会绑定引用到临时对象，那么此构造函数会定义为被弃置。

@8@ 给定 {{c|u1}} 为 {{c|std::get&lt;0&gt;(std::forward(u))}}，{{c|u2}} 为 {{c|std::get&lt;1&gt;(std::forward(u))}}，并分别以 {{tt|U1}} 和 {{tt|U2}} 表示它们的类型。以 {{c|u1}} 初始化 {{tt|first}} 并以 {{c|u2}} 初始化 {{tt|second}}。
@@ 此构造函数当且仅当满足以下所有条件时参与重载决议：
* {{c/core|std::remove_cvref(P)}} 不是 {{l2tt std|cpp/ranges/subrange}} 的特化，
* {{c|std::is_constructible_v&lt;T1, U1&gt;}} 是 {{c|true}}，并且
* {{c|std::is_constructible_v&lt;T2, U2&gt;}} 是 {{c|true}}。
@@ 此构造函数当且仅当 {{c|std::is_convertible_v&lt;U1, T1&gt;}} 是 {{c|false}} 或 {{c|std::is_convertible_v&lt;U2, T2&gt;}} 是 {{c|false}} 时是 {{c/core|explicit}} 的。
@@ 如果 {{tt|first}} 或 {{tt|second}} 的初始化会绑定引用到临时对象，那么此构造函数会定义为被弃置。

@9@ 转发 {{c|first_args}} 的元素到 {{tt|first}} 的构造函数并转发 {{c|second_args}} 的元素到 {{tt|second}} 的构造函数。除了默认构造函数外，只有该构造函数能用于构造不可复制不可移动类型的 pair。如果 {{tt|first}} 或 {{tt|second}} 是引用且被绑定到临时对象，那么程序非良构。

@10@ 复制构造函数是{{rev inl|until=c++11|隐式声明的}}{{rev inl|since=c++11|预置的，且当两个元素的复制都满足 constexpr 函数的要求时是 {{c/core|constexpr}} 的}}。

@10@ 移动构造函数是预置的，且当两个元素的移动都满足 constexpr 函数的要求时是 {{c/core|constexpr}} 的。

===参数===
{{par begin}}
{{par|x|初始化此对偶首元素的值}}
{{par|y|初始化此对偶第二元素的值}}
{{par|p|用于初始化此对偶两个元素的值的对偶}}
{{par|u|用于初始化此对偶两个元素的值的{{lti|cpp/utility/tuple/tuple-like|对偶式}}对象}}
{{par|first_args|用于初始化此对偶首元素的构造函数实参元组}}
{{par|second_args|用于初始化此对偶第二元素的构造函数实参元组}}
{{par end}}

===异常===
不抛异常，除非指定操作之一（如元素的构造函数）抛出。

===示例===
{{example
|code=
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;utility&gt;

int main()
{
    auto print = [](auto rem, auto const&amp; pair)
    {
        std::cout &lt;&lt; rem &lt;&lt; "(" &lt;&lt; pair.first &lt;&lt; ", " &lt;&lt; pair.second &lt;&lt; ")\n";
    };
    
    std::pair&lt;int, float&gt; p1;
    print("(1) 值初始化：", p1);

    std::pair&lt;int, double&gt; p2{42, 3.1415};
    print("(2) 以两个值进行初始化：", p2);

    std::pair&lt;char, int&gt; p4{p2};
    print("(4) 隐式转换：", p4);

    std::pair&lt;std::complex&lt;double&gt;, std::string&gt; p6
        {std::piecewise_construct, std::forward_as_tuple(0.123, 7.7),
            std::forward_as_tuple(10, 'a')};
    print("(8) 逐段构造：", p6);
}
|p=true
|output=
(1) 值初始化：(0, 0)
(2) 以两个值进行初始化：(42, 3.1415)
(4) 隐式转换：(*, 3)
(8) 逐段构造：((0.123,7.7), aaaaaaaaaa)
}}

=== 缺陷报告 ===
{{dr list begin}}
{{dr list item|wg=lwg|dr=265|std=C++98|before=默认构造函数分别以 {{c|T1()}} 和 {{c|T2()}} 复制初始化 {{tt|first}} 和&lt;br&gt;{{tt|second}}（因此 {{tt|T1}} 和 {{tt|T2}} 需要{{named req|CopyConstructible}}）|after={{tt|first}} 和 {{tt|second}}&lt;br&gt;会被值初始化}}
{{dr list item|wg=lwg|dr=2510|std=C++11|before=默认构造函数不是 explicit 的|after=改成是条件性 explicit 的}}
{{dr list item|paper=N4387|std=C++11|before=某些构造函数是 explicit 的，这会阻止有用的行为|after=将大多数构造函数改成是条件性 explicit 的}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/pair/dsc make_pair}}
{{dsc inc|cpp/utility/tuple/dsc constructor}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}