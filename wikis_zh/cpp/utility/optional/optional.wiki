{{cpp/utility/optional/title|optional}}
{{cpp/utility/optional/navbar}}
{{dcl begin}}
{{dcla|num=1|since=c++17|
constexpr optional() noexcept;
}}
{{dcla|num=2|since=c++17|
constexpr optional( std::nullopt_t ) noexcept;
}}
{{dcla|num=3|since=c++17|
constexpr optional( const optional&amp; other );
}}
{{dcla|num=4|since=c++17|
constexpr optional( optional&amp;&amp; other ) noexcept(/* 见下文 */);
}}
{{dcla|num=5|since=c++17|constexpr=c++20|notes={{mark|条件性 explicit}}|
template&lt; class U &gt;
optional( const optional&lt;U&gt;&amp; other );
}}
{{dcla|num=6|since=c++17|constexpr=c++20|notes={{mark|条件性 explicit}}|
template&lt; class U &gt;
optional( optional&lt;U&gt;&amp;&amp; other );
}}
{{dcla|num=7|since=c++17|
template&lt; class... Args &gt;
constexpr explicit optional( std::in_place_t, Args&amp;&amp;... args );
}}
{{dcla|num=8|since=c++17|
template&lt; class U, class... Args &gt;
constexpr explicit optional( std::in_place_t,
                             std::initializer_list&lt;U&gt; ilist,
                             Args&amp;&amp;... args );
}}
{{dcla|num=9|since=c++17|notes={{mark|条件性 {{tt|explicit}}}}|1=
template&lt; class U = std::remove_cv_t&lt;T&gt; &gt;
constexpr optional( U&amp;&amp; value );
}}
{{dcl end}}

构造新的 {{tt|optional}} 对象。

===参数===
{{par begin}}
{{par|other|要复制其所含值的另一 {{tt|optional}} 对象}}
{{par|value|初始化所含值所用的值}}
{{par|args...|初始化所含值所用的实参}}
{{par|ilist|初始化所含值所用的初始化式列表}}
{{par end}}

===效果===
{|class="wikitable" style="word-break: keep-all;"
!{{nbsp}}重载{{nbsp}}
!初始化方式
!包含的值的初始化器
!构造后的 {{rlpt|operator bool|has_value()}}
|-
|style="text-align: center;"|{{vl|1}}
|rowspan=2 {{n/a}}
|rowspan=2 {{n/a|-}}
|rowspan=2|{{c|false}}
|-
|style="text-align: center;"|{{vl|2}}
|-
|style="text-align: center;"|{{vl|3}}
|rowspan=7|（非列表）[[cpp/language/direct initialization|直接初始化]]{{nbsp}}
|{{c|*other}}
|rowspan=4|{{c|other.has_value()}}
* 是 {{c|false}} 时不会初始化包含的值。
|-
|style="text-align: center;"|{{vl|4}}
|{{c|std::move(*other)}}
|-
|style="text-align: center;"|{{vl|5}}
|{{c|*other}}
|-
|style="text-align: center;"|{{vl|6}}
|{{c|std::move(*other)}}
|-
|style="text-align: center;"|{{vl|7}}
|{{c|std::forward&lt;Args&gt;(args)...}}
|rowspan=3|{{c|true}}
|-
|style="text-align: center;"|{{vl|8}}
|{{c|ilist, std::forward&lt;Args&gt;(args)...}}
|-
|style="text-align: center;"|{{vl|9}}
|{{c|std::forward&lt;U&gt;(value)}}
|}

===约束和补充信息===
@3@ 如果 {{c|std::is_copy_constructible_v&lt;T&gt;}} 是 {{c|false}}，那么此构造函数被定义为弃置。
@@ 如果 {{c|std::is_trivially_copy_constructible_v&lt;T&gt;}} 是 {{c|true}}，那么此构造函数是平凡的。

@4@ {{cpp/enable if| {{c|std::is_move_constructible_v&lt;T&gt;}} 是 {{c|true}} }}。
@@ 如果 {{c|std::is_trivially_move_constructible_v&lt;T&gt;}} 是 {{c|true}}，那么此构造函数是平凡的。

@5@ {{cpp/enable if|满足以下所有条件}}：
* {{c|std::is_constructible_v&lt;T, const U&amp;&gt;}} 是 {{c|true}}。
* 如果 {{tt|T}} 不是（可有 cv 限定的）{{c/core|bool}}，那么以下 8 个值都是 {{c|false}}&lt;ref name="no-convert"&gt;也就是说，从任何（可有 const 限定的）{{c/core|std::optional&lt;U&gt;}} 类型的表达式都不能构造或转换到 {{tt|T}}。&lt;/ref&gt;：
** {{c|std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&gt;}}
** {{c|std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&gt;}}
** {{c|std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;}}
** {{c|std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;}}
** {{c|std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;, T&gt;}}
** {{c|std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;, T&gt;}}
** {{c|std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;}}
** {{c|std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;}}

@@ 此重载如同声明有 {{c/core|explicit(!std::is_convertible_v&lt;const U&amp;, T&gt;)}}。

@6@ {{cpp/enable if|满足以下所有条件}}：
* {{c|std::is_constructible_v&lt;T, U&gt;}} 是 {{c|true}}。
* 如果 {{tt|T}} 不是（可有 cv 限定的）{{c/core|bool}}，那么以下 8 个值都是 {{c|false}}&lt;ref name="no-convert" /&gt;：
** {{c|std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&gt;}}
** {{c|std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&gt;}}
** {{c|std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;}}
** {{c|std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;}}
** {{c|std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;, T&gt;}}
** {{c|std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;, T&gt;}}
** {{c|std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;}}
** {{c|std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;}}

@@ 此重载如同声明有 {{c/core|explicit(!std::is_convertible_v&lt;U, T&gt;)}}。

@7@ {{cpp/enable if| {{c|std::is_constructible_v&lt;T, Args...&gt;}} 是 {{c|true}} }}。
@@ 如果为初始化选择的 {{tt|T}} 的构造函数是 {{c/core|constexpr}} 构造函数，那么此构造函数也是 {{c/core|constexpr}} 构造函数。

@8@ {{cpp/enable if| {{c|std::is_constructible_v&lt;T, std::initializer_list&lt;U&gt;&amp;, Args...&gt;}} 是 {{c|true}} }}。
@@ 如果为初始化选择的 {{tt|T}} 的构造函数是 {{c/core|constexpr}} 构造函数，那么此构造函数也是 {{c/core|constexpr}} 构造函数。

@9@ {{cpp/enable if|满足以下所有条件}}：
* {{c|std::is_constructible_v&lt;T, U&gt;}} 是 {{c|true}}。
* {{rev inl|until=c++20|{{c/core|std::decay_t&lt;U&gt;}}}}{{rev inl|since=c++20|{{c/core|std::remove_cvref_t&lt;U&gt;}}}} 既不是 {{lc|std::in_place_t}} 也不是 {{c/core|std::optional&lt;T&gt;}}。
* 当 {{tt|T}} 是（可有 cv 限定的）{{c/core|bool}} 时，{{rev inl|until=c++20|{{c/core|std::decay_t&lt;U&gt;}}}}{{rev inl|since=c++20|{{c/core|std::remove_cvref_t&lt;U&gt;}}}} 不是 {{tt|std::optional}} 的特化。

@@ 此重载如同声明有 {{c/core|explicit(!std::is_convertible_v&lt;U, T&gt;)}}。
@@ 如果为初始化选择的 {{tt|T}} 的构造函数是 {{c/core|constexpr}} 构造函数，那么此构造函数也是 {{c/core|constexpr}} 构造函数。

&lt;references/&gt;

===异常===
@3@ 抛出 {{tt|T}} 的构造函数所抛的任何异常。

@4@ 抛出 {{tt|T}} 的构造函数所抛的任何异常。拥有随后的 {{noexcept|std::is_nothrow_move_constructible&lt;T&gt;::value}}

@5-9@ 抛出 {{tt|T}} 的构造函数所抛的任何异常。

===[[cpp/utility/optional/deduction guides|推导指引]]===

===注解===
在解决 {{lwg|3836}} 前，从 {{c/core|std::optional&lt;U&gt;}} 构造 {{c/core|std::optional&lt;bool&gt;}} 时，在 {{tt|U}} 不是 {{c/core|bool}} 的情况下会选择重载 {{vl|9}} 而不是重载 {{vl|5,6}}。这是因为在 {{tt|T}}（这里是 {{c/core|bool}}）可以从 {{c/core|std::optional&lt;U&gt;}} 构造或转换时重载决议不会选择重载 {{vl|5,6}}，但是 {{rlpt|operator bool|std::optional::operator bool}} 使得该转换适用于所有 {{tt|U}}。

这会导致构造的 {{c/core|std::optional&lt;bool&gt;}} 始终会包含值。该值由提供的 {{c/core|std::optional&lt;U&gt;}} 对象是否包含值决定，而不是从所含值直接初始化的 {{c/core|bool}} 值：
{{source|
std::optional&lt;bool&gt; op_false(false);
std::optional&lt;int&gt; op_zero(0);
 
std::optional&lt;int&gt; from_bool(op_false); // OK：包含 0（从 false 初始化）
std::optional&lt;bool&gt; from_int(op_zero);  // 缺陷（LWG 3836）：包含 true
                                        // 这是因为 op_zero 包含值，即使
                                        // 从该值初始化 bool 会得出 false
}}

{{ftm begin}}
{{ftm|std=C++20|dr=20|value=202106L|__cpp_lib_optional|完全 {{c/core|constexpr}} {{vl|5,6}}}}
{{ftm end}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;optional&gt;
#include &lt;string&gt;

int main()
{
    std::optional&lt;int&gt; o1, // 空
                       o2 = 1, // 从右值初始化
                       o3 = o2; // 复制构造函数
    
    // 调用 std::string( initializer_list&lt;CharT&gt; ) 构造函数
    std::optional&lt;std::string&gt; o4(std::in_place, {'a', 'b', 'c'});
    
    // 调用 std::string( size_type count, CharT ch ) 构造函数
    std::optional&lt;std::string&gt; o5(std::in_place, 3, 'A');
    
    // 从 std::string 移动构造，用推导指引拾取类型
    
    std::optional o6(std::string{"deduction"});
    
    std::cout &lt;&lt; *o2 &lt;&lt; ' ' &lt;&lt; *o3 &lt;&lt; ' ' &lt;&lt; *o4 &lt;&lt; ' ' &lt;&lt; *o5  &lt;&lt; ' ' &lt;&lt; *o6 &lt;&lt; '\n';
}
|output=
1 1 abc AAA deduction
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3836|std=C++17|before=从 {{c/core|std::optional&lt;U&gt;}} 构造 {{c/core|std::optional&lt;bool&gt;}} 时，&lt;br&gt;在 {{tt|U}} 不是 {{c/core|bool}} 的情况下会选择重载 {{vl|9}}|after=此时会选择转换复制/移动构造函数}}
{{dr list item|wg=lwg|dr=3886|std=C++17|before=重载 {{vl|9}} 的默认模板实参是 {{tt|T}}|after=改成 {{c/core|std::remove_cv_t&lt;T&gt;}}}}
{{dr list item|paper=P0602R4|std=C++17|before=即使底层构造函数平凡，复制/移动构造函数也不一定平凡|after=要求传播平凡性}}
{{dr list item|paper=P2231R1|std=C++20|before=重载 {{vl|5,6}} 不是 {{c/core|constexpr}} 的|after=使之为 {{c/core|constexpr}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/optional/dsc make_optional}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}