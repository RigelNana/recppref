{{title|函数对象}}
{{cpp/utility/functional/navbar}}

任何定义了函数调用运算符的对象都是''函数对象''。C++ 支持创建、操作新的函数对象，同时也提供了许多内置的函数对象。

===函数调用===
{{rrev|since=c++11|
仅用于阐述的 {{box|{{tti|INVOKE}}{{c/core|(f, arg_0, arg_1, arg_2, ..., arg_N)}}}} 操作定义如下：

令类型 {{tt|Obj}} 为 {{c/core|std::remove_cv&lt;std::remove_reference&lt;decltype(arg_0)&gt;::type&gt;::type}}：
* 如果 {{c|f}} 是类 {{tt|C}} 的[[cpp/language/pointer#成员函数指针|成员函数指针]]，那么 {{box|{{tti|INVOKE}}{{c/core|(f, obj, arg_1, arg_2, ..., arg_N)}}}} 等价于：
:* 如果 {{c|std::is_same&lt;C, Obj&gt;::value {{!!}} std::is_base_of&lt;C, Obj&gt;::value}} 为 {{c|true}}
::* {{c|(obj.*f)(arg_1, arg_2, ..., arg_N)}}（在对象上调用成员函数）。
:* 如果 {{tt|Obj}} 是 {{lc|std::reference_wrapper}} 的特化
::* {{c|(obj.get().*f)(arg_1, arg_2, ..., arg_N)}}（在被特殊引用的对象上调用成员函数）。
:* 否则
::* {{c|((*obj).*f)(arg_1, arg_2, ..., arg_N)}}（在解引用的对象上调用成员函数）。
* 否则，如果 {{c|1=N == 1}} 并且 {{c|f}} 是类 {{tt|C}} 的[[cpp/language/pointer#数据成员指针|数据成员指针]]，那么 {{box|{{tti|INVOKE}}{{c/core|(mptr, obj)}}}} 等价于：
:* 如果 {{c|std::is_same&lt;C, Obj&gt;::value {{!!}} std::is_base_of&lt;C, Obj&gt;::value}} 是 {{c|true}}
::* {{c|obj.*mptr}}（访问对象的数据成员）。
:* 如果 {{tt|T1}} 是 {{lc|std::reference_wrapper}} 的特化
::* {{c|obj.get().*mptr}}（访问被特殊引用的对象的数据成员）。
:* 否则
::* {{c|(*obj).*mptr}}（解引用的对象的数据成员）。
* 否则
:* {{box|{{tti|INVOKE}}{{c/core|(f, arg_0, arg_1, arg_2, ..., arg_N)}}}} 等价于 {{c|f(arg_0, arg_1, arg_2, ..., arg_N)}}（调用可调用物）。


仅用于阐述的 {{box|{{tti|INVOKE&lt;R&gt;}}{{c/core|(f, arg_0, arg_1, arg_2, ..., arg_N)}}}} 操作的定义如下：
* 如果 {{tt|R}} 是（可能有 cv 限定的）{{c/core|void}}
:* {{box|{{c/core|static_cast&lt;void&gt;(}}{{tti|INVOKE}}{{c/core|(f, arg_0, arg_1, arg_2, ..., arg_N))}}}}。
* 否则
:* 隐式转换到 {{tt|R}} 的 {{box|{{tti|INVOKE}}{{c/core|(f, arg_0, arg_1, arg_2, ..., arg_N)}}}}。
{{rrev|since=c++23|
令类型 {{tt|Actual}} 为 {{c/core|decltype(}}{{tti|INVOKE}}{{c/core|(f, arg_0, arg_1, arg_2, ..., arg_N))}}
* 如果 {{box|{{ltt|cpp/types/reference_converts_from_temporary|std::reference_converts_from_temporary_v}} {{c/core|&lt;R, Actual&gt;}}}} 是 {{c|true}}
:* {{box|{{tti|INVOKE&lt;R&gt;}}{{c/core|(f, arg_0, arg_1, arg_2, ..., arg_N)}}}} 非良构。
}}
}}


{{lc|std::invoke}}{{rev inl|since=c++23| / {{rlt|invoke|std::invoke_r}}}} 可以按 {{tti|INVOKE}}{{rev inl|since=c++23| / {{tti|INVOKE&lt;R&gt;}}}} 的规则以给定实参调用任何{{named req|Callable}}对象。

{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc invoke}}
{{dsc end}}

===函数包装器===
这些包装器类提供存储任意函数对象的支持。

{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc function}}
{{dsc inc|cpp/utility/functional/dsc move_only_function}}
{{dsc inc|cpp/utility/functional/dsc copyable_function}}
{{dsc inc|cpp/utility/functional/dsc function_ref}}
{{dsc inc|cpp/utility/functional/dsc bad_function_call}}
{{dsc inc|cpp/utility/functional/dsc mem_fn}}
{{dsc end}}

===恒等===
{{lc|std::identity}} 是恒等函数对象：它不修改地返回实参。

{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc identity}}
{{dsc end}}

===部分函数应用===
{{lc|std::bind_front}} 与 {{lc|std::bind}} 提供[[enwiki:Partial application|部分函数应用]]的支持，即绑定实参到函数以创建新函数。

{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc bind_front}}
{{dsc inc|cpp/utility/functional/dsc bind}}
{{dsc inc|cpp/utility/functional/dsc is_bind_expression}}
{{dsc inc|cpp/utility/functional/dsc is_placeholder}}
{{dsc namespace|std::placeholders}}
{{dsc inc|cpp/utility/functional/dsc placeholders}}
{{dsc end}}

===取反器===
{{lc|std::not_fn}} 创建对传递给它的可调用对象的结果取反的函数对象。

{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc not_fn}}
{{dsc end }}

===搜索器===
提供实现数种字符串搜索算法的搜索器。它们能直接使用或用于 {{lc|std::search}}。

{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc default_searcher}}
{{dsc inc|cpp/utility/functional/dsc boyer_moore_searcher}}
{{dsc inc|cpp/utility/functional/dsc boyer_moore_horspool_searcher}}
{{dsc end}}

===引用包装器===
引用包装器允许在可复制的函数对象中存储引用实参：

{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc reference_wrapper}}
{{dsc inc|cpp/utility/functional/dsc ref}}
{{dsc inc|cpp/utility/functional/dsc unwrap_reference}}
{{dsc end}}

{{rrev|since=c++14|
===透明函数对象===
{{ls|cpp/container#关联容器}}{{rev inl|since=c++20|和{{lsd|cpp/container#无序关联容器}}}}提供了异质查找{{rev inl|since=c++23|和擦除}}操作，但是它们只有在提供的函数对象类型 {{tt|T}} ''透明''{{sep}}时才会启用：有限定标识符 {{tt|T::is_transparent}} 合法，并且指代一个类型。

标准库中的所有透明函数对象类型都会定义一个嵌套类型 {{tt|is_transparent}}。不过用户定义的透明函数对象类型并不需要直接提供 {{tt|is_transparent}} 为其嵌套类型：只要 {{tt|T::is_transparent}} 满足上述透明要求，它也可以在基类中定义。
}}

===运算符函数对象===
C++ 针对常用的算术和逻辑运算定义了以下函数对象。

{{rrev|since=c++14|
各个 {{c/core|void}} 特化会根据它们的实参来推导形参类型和返回类型，它们都是[[#透明函数对象|透明]]的。
}}

{{dsc begin}}
{{dsc h2|算术运算}}
{{dsc inc|cpp/utility/functional/dsc plus}}
{{dsc inc|cpp/utility/functional/dsc plus void}}
{{dsc inc|cpp/utility/functional/dsc minus}}
{{dsc inc|cpp/utility/functional/dsc minus void}}
{{dsc inc|cpp/utility/functional/dsc multiplies}}
{{dsc inc|cpp/utility/functional/dsc multiplies void}}
{{dsc inc|cpp/utility/functional/dsc divides}}
{{dsc inc|cpp/utility/functional/dsc divides void}}
{{dsc inc|cpp/utility/functional/dsc modulus}}
{{dsc inc|cpp/utility/functional/dsc modulus void}}
{{dsc inc|cpp/utility/functional/dsc negate}}
{{dsc inc|cpp/utility/functional/dsc negate void}}

{{dsc h2|比较}}
{{dsc inc|cpp/utility/functional/dsc equal_to}}
{{dsc inc|cpp/utility/functional/dsc equal_to void}}
{{dsc inc|cpp/utility/functional/dsc not_equal_to}}
{{dsc inc|cpp/utility/functional/dsc not_equal_to void}}
{{dsc inc|cpp/utility/functional/dsc greater}}
{{dsc inc|cpp/utility/functional/dsc greater void}}
{{dsc inc|cpp/utility/functional/dsc less}}
{{dsc inc|cpp/utility/functional/dsc less void}}
{{dsc inc|cpp/utility/functional/dsc greater_equal}}
{{dsc inc|cpp/utility/functional/dsc greater_equal void}}
{{dsc inc|cpp/utility/functional/dsc less_equal}}
{{dsc inc|cpp/utility/functional/dsc less_equal void}}

{{dsc h2|逻辑运算}}
{{dsc inc|cpp/utility/functional/dsc logical_and}}
{{dsc inc|cpp/utility/functional/dsc logical_and void}}
{{dsc inc|cpp/utility/functional/dsc logical_or}}
{{dsc inc|cpp/utility/functional/dsc logical_or void}}
{{dsc inc|cpp/utility/functional/dsc logical_not}}
{{dsc inc|cpp/utility/functional/dsc logical_not void}}

{{dsc h2|位运算}}
{{dsc inc|cpp/utility/functional/dsc bit_and}}
{{dsc inc|cpp/utility/functional/dsc bit_and void}}
{{dsc inc|cpp/utility/functional/dsc bit_or}}
{{dsc inc|cpp/utility/functional/dsc bit_or void}}
{{dsc inc|cpp/utility/functional/dsc bit_xor}}
{{dsc inc|cpp/utility/functional/dsc bit_xor void}}
{{dsc inc|cpp/utility/functional/dsc bit_not}}
{{dsc inc|cpp/utility/functional/dsc bit_not void}}
{{dsc end}}


{{rrev|since=c++20|
===受约束的比较函数对象===
以下比较函数对象[[cpp/language/constraints|受约束]]。
* 相等性运算符（{{tt|ranges::equal_to}} 和 {{tt|ranges::not_equal_to}}）要求实参类型满足 {{lconcept|equality_comparable_with}}。
* 关系运算符（{{tt|ranges::less}}、{{tt|ranges::greater}}、{{tt|ranges::less_equal}} 和 {{tt|ranges::greater_equal}}）要求实参类型满足 {{lconcept|totally_ordered_with}}。
* 三路比较运算符（{{tt|compare_three_way}}）要求实参类型满足 {{lconcept|three_way_comparable_with}}。

这些函数对象都是[[#透明函数对象|透明]]的。

{{dsc begin}}
{{dsc inc|cpp/utility/functional/ranges/dsc equal_to}}
{{dsc inc|cpp/utility/functional/ranges/dsc not_equal_to}}
{{dsc inc|cpp/utility/functional/ranges/dsc less}}
{{dsc inc|cpp/utility/functional/ranges/dsc greater}}
{{dsc inc|cpp/utility/functional/ranges/dsc less_equal}}
{{dsc inc|cpp/utility/functional/ranges/dsc greater_equal}}
{{dsc inc|cpp/utility/compare/dsc compare_three_way}}
{{dsc end}}
}}


{{rrev|since=c++26|
===辅助项===
以下仅用于阐释的各项由标准库中的一些组件所用，但它们并不属于标准库接口。

{{dcl begin}}
{{dcla|num=1|anchor=callable|expos=yes|1=
template&lt; class Fn, class... Args &gt;
concept /*callable*/ =
    requires (Fn&amp;&amp; fn, Args&amp;&amp;... args) {
        std::forward&lt;Fn&gt;(fn)(std::forward&lt;Args&gt;(args)...);
    };
}}
{{dcla|num=2|anchor=nothrow-callable|expos=yes|1=
template&lt; class Fn, class... Args &gt;
concept /*nothrow-callable*/ =
    /*callable*/&lt;Fn, Args...&gt; &amp;&amp;
    requires (Fn&amp;&amp; fn, Args&amp;&amp;... args) {
        { std::forward&lt;Fn&gt;(fn)(std::forward&lt;Args&gt;(args)...) } noexcept;
    };
}}
{{dcla|num=3|anchor=call-result-t|expos=yes|1=
template&lt; class Fn, class... Args &gt;
using /*call-result-t*/ = decltype(std::declval&lt;Fn&gt;()(std::declval&lt;Args&gt;()...));
}}
{{dcla|num=4|anchor=decayed-typeof|expos=yes|1=
template&lt; const auto&amp; T &gt;
using /*decayed-typeof*/ = decltype(auto(T));
}}
{{dcl end}}
}}


{{rrev|until=c++20|
===旧式绑定器与适配器===
早期提供功能支持的一些工具都已经被弃用和移除：

{{dsc begin}}
{{dsc h2|基类}}
{{dsc inc|cpp/utility/functional/dsc unary_function}}
{{dsc inc|cpp/utility/functional/dsc binary_function}}

{{dsc h2|绑定器}}
{{dsc inc|cpp/utility/functional/dsc binder12}}
{{dsc inc|cpp/utility/functional/dsc bind12}}

{{dsc h2|函数适配器}}
{{dsc inc|cpp/utility/functional/dsc pointer_to_unary_function}}
{{dsc inc|cpp/utility/functional/dsc pointer_to_binary_function}}
{{dsc inc|cpp/utility/functional/dsc ptr_fun}}
{{dsc inc|cpp/utility/functional/dsc mem_fun_t}}
{{dsc inc|cpp/utility/functional/dsc mem_fun}}
{{dsc inc|cpp/utility/functional/dsc mem_fun_ref_t}}
{{dsc inc|cpp/utility/functional/dsc mem_fun_ref}}
{{dsc inc|cpp/utility/functional/dsc unary_negate}}
{{dsc inc|cpp/utility/functional/dsc binary_negate}}
{{dsc inc|cpp/utility/functional/dsc not1}}
{{dsc inc|cpp/utility/functional/dsc not2}}
{{dsc end}}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=185|std=C++98|before=使用函数对象就会增加程序效率|after=移除该断言}}
{{dr list item|wg=lwg|dr=660|std=C++98|before=缺失了执行逐位操作的函数对象|after=已补充}}
{{dr list item|wg=lwg|dr=2149|std=C++98|before=接受一个或两个实参的函数对象需要提供嵌套类型以表示实参和结果类型|after=不需要}}
{{dr list item|wg=lwg|dr=2219|std=C++11|before={{tti|INVOKE}} 没有正确处理 {{lc|std::reference_wrapper}}|after=能正确处理}}
{{dr list item|wg=lwg|dr=2420|std=C++11|before={{tti|INVOKE&lt;R&gt;}} 在 {{tt|R}} 是 {{c/core|void}} 时不会丢弃返回值|after=此时会丢弃返回值}}
{{dr list item|wg=lwg|dr=2926|paper=P0604R0|std=C++11|before=带有返回类型 {{tt|R}} 的 {{tti|INVOKE}} 操作的形式&lt;!-- INVOKE 是仅用于阐述的操作，不适合用【语法】一词 --&gt;是&lt;br&gt;{{box|{{tti|INVOKE}}{{c/core|(f, t1, t2, ..., tN, R)}}}}|after=改成&lt;br&gt;{{box|{{tti|INVOKE&lt;R&gt;}}{{c/core|(f, t1, t2, ..., tN)}}}}}}
{{dr list item|wg=lwg|dr=3655|std=C++11|before=由于 {{lwg|2219}} 的解决方案，{{tti|INVOKE}} 没有正确处理联合体|after=能正确处理}}
{{dr list end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}