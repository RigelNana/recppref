{{cpp/title|unary_function}}
{{cpp/utility/functional/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl|until=c++17|deprecated=c++11|1=
template&lt; typename ArgumentType, typename ResultType &gt;
struct unary_function;
}}
{{dcl end}}

{{tt|unary_function}} 是用于创建拥有一个实参的函数对象的基类。

{{tt|unary_function}} 不定义 {{c|operator()}}；它期待派生类定义此运算符。{{tt|unary_function}} 只提供由模板形参定义的两个类型：{{tt|argument_type}} 和 {{tt|result_type}}。

一些标准库函数对象适配器，如 {{lc|std::not1}}，要求它们适配的函数对象已定义某些类型；{{lc|std::not1}} 要求要适配的函数对象拥有名为 {{tt|argument_type}} 的类型。从 {{tt|unary_function}} 派生的函数对象是令它们与那些适配器兼容的简易方式。

{{tt|unary_function}} 在 C++11 中被弃用。

===成员类型===
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc|{{tt|argument_type}}|{{tt|ArgumentType}}}}
{{dsc|{{tt|result_type}}|{{tt|ResultType}}}}
{{dsc end}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct less_than_7 : std::unary_function&lt;int, bool&gt;
{
    bool operator()(int i) const { return i &lt; 7; }
};

int main()
{
    std::vector&lt;int&gt; v(10, 7);
    v[0] = v[1] = v[2] = 6;
 
    std::cout &lt;&lt; std::count_if(v.begin(), v.end(), std::not1(less_than_7()));
 
    // C++11 解法：
    // 用某方法转型到 std::function&lt;bool (int)&gt; ——即使 lambda 也行
    // std::cout &lt;&lt; std::count_if(v.begin(), v.end(),
    //     std::not1(std::function&lt;bool (int)&gt;([](int i) { return i &lt; 7; })));
}
|output=
7
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc function}}
{{dsc inc|cpp/utility/functional/dsc move_only_function}}
{{dsc inc|cpp/utility/functional/dsc ptr_fun}}
{{dsc inc|cpp/utility/functional/dsc pointer_to_unary_function}}
{{dsc inc|cpp/utility/functional/dsc binary_function}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}