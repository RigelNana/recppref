{{cpp/title|binary_negate}}
{{cpp/utility/functional/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl rev begin}}
{{dcl|until=c++11|
template&lt; class Predicate &gt;
struct binary_negate
    : public std::binary_function&lt;
        Predicate::first_argument_type,
        Predicate::second_argument_type,
        bool
    &gt;;
}}
{{dcl|since=c++11|deprecated=c++17|removed=c++20|
template&lt; class Predicate &gt;
struct binary_negate;
}}
{{dcl rev end}}
{{dcl end}}

{{tt|binary_negate}} 是返回其所保有的二元谓词的补的包装器函数对象。

二元谓词必须定义两个成员类型，{{tt|first_argument_type}} 和 {{tt|second_argument_type}}，它们可转换为谓词的形参类型。从 {{lc|std::owner_less}}、{{lc|std::ref}}、{{lc|std::cref}}、{{lc|std::plus}}、{{lc|std::minus}}、{{lc|std::multiplies}}、{{lc|std::divides}}、{{lc|std::modulus}}、{{lc|std::equal_to}}、{{lc|std::not_equal_to}}、{{lc|std::greater}}、{{lc|std::less}}、{{lc|std::greater_equal}}、{{lc|std::less_equal}}、{{lc|std::logical_not}}、{{lc|std::logical_or}}、{{lc|std::bit_and}}、{{lc|std::bit_or}}、{{lc|std::bit_xor}}、{{lc|std::mem_fn}}、{{lc|std::map::value_comp}}、{{lc|std::multimap::value_comp}}、{{lc|std::function}} 或对 {{lc|std::not2}} 的调用获得的函数对象，都定义了这些类型，和派生自已弃用的 {{lc|std::binary_function}} 的函数对象一样。

{{tt|binary_negate}} 对象简单地以辅助函数 {{lc|std::not2}} 创建。

===成员类型===
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc|{{tt|first_argument_type}}|{{c|Predicate::first_argument_type}}}}
{{dsc|{{tt|second_argument_type}}|{{c|Predicate::second_argument_type}}}}
{{dsc|{{tt|result_type}}|{{c|bool}}}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc mem ctor|nolink=true|以提供的谓词构造新的 {{tt|binary_negate}} 对象}}
{{dsc mem fun|operator()|nolink=true|返回调用存储的谓词结果的逻辑补}}
{{dsc end}}

{{member|{{small|std::binary_negate::}}binary_negate|2=
{{dcl begin}}
{{dcl rev begin}}
{{dcl|until=c++14|
explicit binary_negate( Predicate const&amp; pred );
}}
{{dcl|since=c++14|
constexpr explicit binary_negate( Predicate const&amp; pred );
}}
{{dcl rev end}}
{{dcl end}}

构造带有存储的谓词 {{c|pred}} 的 {{tt|binary_negate}} 函数对象。

===参数===
{{par begin}}
{{par|pred|谓词函数对象}}
{{par end}}
}}

{{member|{{small|std::binary_negate::}}operator()|2=
{{dcl begin}}
{{dcl rev begin}}
{{dcl|until=c++14|
bool operator()( first_argument_type const&amp; x,
                 second_argument_type const&amp; y ) const;
}}
{{dcl|since=c++14|
constexpr bool operator()( first_argument_type const&amp; x,
                           second_argument_type const&amp; y ) const;
}}
{{dcl rev end}}
{{dcl end}}

返回调用 {{c|pred(x, y)}} 结果的逻辑补。

===参数===
{{par begin}}
{{par|x|通过谓词传递的第一实参}}
{{par|y|通过谓词传递的第二实参}}
{{par end}}

===返回值===
调用 {{c|pred(x, y)}} 结果的逻辑补。
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cstddef&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct same : std::binary_function&lt;int, int, bool&gt;
{
    bool operator()(int a, int b) const { return a == b; }
};

int main()
{
    std::vector&lt;int&gt; v1;
    for (int i = 0; i &lt; 7; ++i)
        v1.push_back(i);
    
    std::vector&lt;int&gt; v2(v1.size());
    std::reverse_copy(v1.begin(), v1.end(), v2.begin());

    std::vector&lt;bool&gt; v3(v1.size());

    std::binary_negate&lt;same&gt; not_same((same()));
    
    // C++11 的解决方案：
    // std::function&lt;bool (int, int)&gt; not_same =
    //     [](int x, int y) -&gt; bool { return !same()(x, y); };

    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), not_same);

    std::cout.setf(std::ios_base::boolalpha);
    for (std::size_t i = 0; i != v1.size(); ++i)
        std::cout &lt;&lt; v1[i] &lt;&lt; " != " &lt;&lt; v2[i] &lt;&lt; " : " &lt;&lt; v3[i] &lt;&lt; '\n';
}
|output=
0 != 6 : true
1 != 5 : true
2 != 4 : true
3 != 3 : false
4 != 2 : true
5 != 1 : true
6 != 0 : true
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc binary_function}}
{{dsc inc|cpp/utility/functional/dsc function}}
{{dsc inc|cpp/utility/functional/dsc move_only_function}}
{{dsc inc|cpp/utility/functional/dsc not2}}
{{dsc inc|cpp/utility/functional/dsc ptr_fun}}
{{dsc inc|cpp/utility/functional/dsc unary_negate}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}