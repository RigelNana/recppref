{{cpp/utility/functional/copyable_function/title|copyable_function}}
{{cpp/utility/functional/copyable_function/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++26|
copyable_function() noexcept;
}}
{{dcl|num=2|since=c++26|
copyable_function( std::nullptr_t ) noexcept;
}}
{{dcl|num=3|since=c++26|
copyable_function( const copyable_function&amp; other );
}}
{{dcl|num=4|since=c++26|
copyable_function( copyable_function&amp;&amp; other ) noexcept;

}}
{{dcl|num=5|since=c++26|
template&lt; class F &gt; 
copyable_function( F&amp;&amp; f );
}}
{{dcl|num=6|since=c++26|
template&lt; class T, class... CArgs &gt; 
explicit copyable_function( std::in_place_type_t&lt;T&gt;, CArgs&amp;&amp;... args );
}}
{{dcl|num=7|since=c++26|
template&lt; class T, class U, class... CArgs &gt; 
explicit copyable_function( std::in_place_type_t&lt;T&gt;,
                            std::initializer_list&lt;U&gt; il, CArgs&amp;&amp;... args );
}}
{{dcl end}}

创建新的 {{tt|std::copyable_function}}。

@1,2@ 默认构造函数和接受 {{c|nullptr}} 的构造函数构造空的 {{tt|std::copyable_function}}。

@3@ 复制构造函数构造 {{tt|std::copyable_function}}，其目标为 {{c|other}} 目标的副本。否则，若 {{c|other}} 为空则构造空的 {{tt|std::copyable_function}}。

@4@ 移动构造函数构造 {{tt|std::copyable_function}}，其目标为 {{c|other}} 的目标。移动构造之后 {{c|other}} 处于有效但未指明的状态。

@5@ 令 {{tt|VT}} 为 {{c|std::decay_t&lt;F&gt;}}。如果 {{c|f}} 是空函数指针，空成员指针值，或者空的 {{tt|std::copyable_function}}（可为其他任意特化），那么构造空的 {{tt|std::copyable_function}}。否则，构造 {{tt|std::copyable_function}}，其目标类型为 {{tt|VT}} 并以 {{c|std::forward&lt;F&gt;(f)}} 进行直接非列表初始化。
* {{cpp/enable_if| {{tt|VT}} 既和 {{tt|copyable_function}} 不同又不是 {{lc|std::in_place_type_t}} 的特化，且 {{c|/*is-callable-from*/&lt;VT&gt;}}（见下文）为 {{c|true}}}}。
* 如果 {{c|std::is_constructible_v&lt;VT, F&gt;}} 或 {{c|std::is_copy_constructible_v&lt;VT&gt;}} 不为 {{c|true}}，那么程序非良构。

@6@ 令 {{tt|VT}} 为 {{c|std::decay_t&lt;T&gt;}}。构造 {{tt|std::copyable_function}}，其目标类型为 {{tt|VT}} 并以 {{c|std::forward&lt;CArgs&gt;(args)...}} 进行直接非列表初始化。
* {{cpp/enable_if| {{c|std::is_constructible_v&lt;VT, CArgs...&gt;}} 和 {{c|/*is-callable-from*/&lt;VT&gt;}}（见下文）均为 {{c|true}}}}。
* 如果 {{tt|VT}} 与 {{tt|T}} 不是同一类型或者 {{c|std::is_copy_constructible_v&lt;VT&gt;}} 不为 {{c|true}}，那么程序非良构。

@7@ 令 {{tt|VT}} 为 {{c|std::decay_t&lt;T&gt;}}。构造 {{tt|std::copyable_function}}，其目标类型为 {{tt|VT}} 并以 {{c|il, std::forward&lt;CArgs&gt;(args)...}} 进行直接非列表初始化。
* {{cpp/enable_if| {{c|std::is_constructible_v&lt;VT, std::initializer_list&lt;U&gt;&amp;, CArgs...&gt;}} 和 {{c|/*is-callable-from*/&lt;VT&gt;}}（见下文）均为 {{c|true}}}}。
* 如果 {{tt|VT}} 与 {{tt|T}} 不是同一类型或者 {{c|std::is_copy_constructible_v&lt;VT&gt;}} 不为 {{c|true}}，那么程序非良构。

对于构造函数 {{v|5-7}}，除非 {{tt|VT}} 同时满足{{named req|Destructible}}和{{named req|CopyConstructible}}，否则其行为未定义。

{{cpp/utility/functional/is_callable_from_table|copyable_function}}

===参数===
{{par begin}}
{{par|other|要复制或移动的另一 {{tt|std::copyable_function}}}}
{{par|f|要包装的函数或{{named req|Callable}}对象}}
{{par|args|用以构造目标对象的实参}}
{{par|il|用以构造目标对象的 {{lc|std::initializer_list}}}}
{{par end}}

===异常===
@3@ 分配失败时可抛出 {{lc|std::bad_alloc}}，或传播目标的初始化所抛出的异常。
@5-7@ 分配失败时可抛出 {{lc|std::bad_alloc}}，或传播目标的初始化所抛出的异常。如果 {{tt|VT}} 是函数指针类型或 {{lc|std::reference_wrapper}} 的特化，则不抛出任何异常。

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/function/dsc constructor}}
{{dsc inc|cpp/utility/functional/move_only_function/dsc constructor}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}