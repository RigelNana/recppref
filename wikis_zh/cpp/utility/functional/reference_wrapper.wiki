{{cpp/title|reference_wrapper}}
{{cpp/utility/functional/reference_wrapper/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl|since=c++11|
template&lt; class T &gt;
class reference_wrapper;
}}
{{dcl end}}

{{tt|std::reference_wrapper}} 是一种把引用包装到可复制、可赋值对象的类模板。

明确地说，{{tt|std::reference_wrapper}} 是围绕到 {{tt|T}} 类型的对象引用或函数引用的{{named req|CopyConstructible}}且{{named req|CopyAssignable}}的包装器。{{tt|std::reference_wrapper}} 的实例是对象（它们可被复制或存储于容器），但它们能隐式转换成 {{c|T&amp;}}，故能将它用作按引用接收底层类型的函数的实参。

若存储的引用{{named req|Callable}}，则可以相同实参调用 {{tt|std::reference_wrapper}}。

辅助函数 {{lc|std::ref}} 与 {{lc|std::cref}} 常用于生成 {{tt|std::reference_wrapper}} 对象。

{{tt|std::reference_wrapper}} 亦用于按引用传递对象给 {{lc|std::bind}}，{{lc|std::thread}} 的构造函数，或辅助函数 {{lc|std::make_pair}} 与 {{lc|std::make_tuple}}。它还可以作为在通常无法持有引用的标准容器（如 {{lc|std::vector}}）中存储引用的机制。

{{rrev|since=c++17|
保证 {{tt|std::reference_wrapper}} 为{{named req|TriviallyCopyable}}。
}}

{{rrev|since=c++20|
{{tt|T}} 可为不完整类型。
}}

===成员类型===
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc|{{tt|type}}|{{tt|T}}}}
{{dsc|{{tt|result_type}}{{mark life|deprecated=c++17|removed=c++20}}|br=yes|若 {{tt|T}} 为函数则为 {{tt|T}} 的返回类型。否则不定义。}}
{{dsc|{{tt|argument_type}}{{mark life|deprecated=c++17|removed=c++20}}|br=yes|
* 若 {{tt|T}} 为接受一个 {{tt|A1}} 类型实参的函数或函数指针，则 {{tt|argument_type}} 为 {{tt|A1}}&lt;br&gt;
* 若 {{tt|T}} 是不接收实参的指向类 {{tt|T0}} 成员函数的指针，则 {{tt|argument_type}} 为 {{c/core|T0*}}，可能有 cv 限定&lt;br&gt;
* 若 {{tt|T}} 是拥有成员类型 {{c/core|T::argument_type}} 的类类型，则 {{tt|argument_type}} 为其别名}}
{{dsc|{{tt|first_argument_type}}&lt;br&gt;{{mark life|deprecated=c++17|removed=c++20}}|br=yes|
* 若 {{tt|T}} 是接收两个 {{tt|A1}} 与 {{tt|A2}} 类型实参的函数或函数指针，则 {{tt|first_argument_type}} 为 {{tt|A1}}&lt;br&gt;
* 若 {{tt|T}} 是接收一个实参的指向类 {{tt|T0}} 的成员函数的指针，则 {{tt|first_argument_type}} 为 {{c/core|T0*}}，可能有 cv 限定&lt;br&gt;
* 若 {{tt|T}} 是拥有成员类型 {{c/core|T::first_argument_type}} 的类类型，则 {{tt|first_argument_type}} 为其别名
}}
{{dsc|{{tt|second_argument_type}}&lt;br&gt;{{mark life|deprecated=c++17|removed=c++20}}|br=yes|
* 若 {{tt|T}} 是接收两个 {{tt|A1}} 与 {{tt|A2}} 类型实参的函数或函数指针，则 {{tt|second_argument_type}} 为 {{tt|A2}}&lt;br&gt;
* 若 {{tt|T}} 是接收一个 {{tt|A1}} 类型实参的指向类 {{tt|T0}} 成员函数的指针，则 {{tt|second_argument_type}} 为 {{tt|A1}}，可有 cv 限定&lt;br&gt;
* 若 {{tt|T}} 是拥有成员类型 {{c/core|T::second_argument_type}} 的类类型，则 {{tt|second_argument_type}} 为其别名}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/reference_wrapper/dsc constructor}}
{{dsc inc|cpp/utility/functional/reference_wrapper/dsc operator{{=}}}}
{{dsc inc|cpp/utility/functional/reference_wrapper/dsc get}}
{{dsc inc|cpp/utility/functional/reference_wrapper/dsc operator()}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/reference_wrapper/dsc operator_cmp}}
{{dsc end}}

==={{rl|deduction guides|推导指引}}{{mark since c++17}}===

===辅助类===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/reference_wrapper/dsc basic_common_reference}}
{{dsc end}}

===可能的实现===
{{eq fun
|1=
namespace detail
{
    template&lt;class T&gt; constexpr T&amp; FUN(T&amp; t) noexcept { return t; }
    template&lt;class T&gt; void FUN(T&amp;&amp;) = delete;
}

template&lt;class T&gt;
class reference_wrapper
{
public:
    // 类型
    using type = T;

    // construct/copy/destroy
    template&lt;class U, class = decltype(
        detail::FUN&lt;T&gt;(std::declval&lt;U&gt;()),
        std::enable_if_t&lt;!std::is_same_v&lt;reference_wrapper, std::remove_cvref_t&lt;U&gt;&gt;&gt;()
    )&gt;
    constexpr reference_wrapper(U&amp;&amp; u)
        noexcept(noexcept(detail::FUN&lt;T&gt;(std::forward&lt;U&gt;(u))))
        : _ptr(std::addressof(detail::FUN&lt;T&gt;(std::forward&lt;U&gt;(u)))) {}

    reference_wrapper(const reference_wrapper&amp;) noexcept = default;
 
    // 赋值
    reference_wrapper&amp; operator=(const reference_wrapper&amp; x) noexcept = default;
 
    // 访问
    constexpr operator T&amp; () const noexcept { return *_ptr; }
    constexpr T&amp; get() const noexcept { return *_ptr; }

    template&lt;class... ArgTypes&gt;
    constexpr std::invoke_result_t&lt;T&amp;, ArgTypes...&gt;
        operator() (ArgTypes&amp;&amp;... args ) const
            noexcept(std::is_nothrow_invocable_v&lt;T&amp;, ArgTypes...&gt;)
    {
        return std::invoke(get(), std::forward&lt;ArgTypes&gt;(args)...);
    }
 
private:
    T* _ptr;
};

// 推导指引
template&lt;class T&gt;
reference_wrapper(T&amp;) -&gt; reference_wrapper&lt;T&gt;;
}}

===示例===
{{example
|演示将 {{tt|std::reference_wrapper}} 作为引用的容器使用，这令使用多重索引访问同一容器称为可能。
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;numeric&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

void println(auto const rem, std::ranges::range auto const&amp; v)
{
    for (std::cout &lt;&lt; rem; auto const&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    std::list&lt;int&gt; l(10);
    std::iota(l.begin(), l.end(), -4);

    // 不能在 list 上用 shuffle（要求随机访问），但能在 vector 上使用它
    std::vector&lt;std::reference_wrapper&lt;int&gt;&gt; v(l.begin(), l.end());

    std::ranges::shuffle(v, std::mt19937{std::random_device{}()});

    println("list 的内容: ", l);
    println("list 的内容，通过经混洗的 vector 所见: ", v);

    std::cout &lt;&lt; "倍增初始化式列表中的值...\n";
    std::ranges::for_each(l, [](int&amp; i) { i *= 2; });

    println("list 的内容，通过经混洗的 vector 所见: ", v);
}
|p=true
|output=
list 的内容: -4 -3 -2 -1 0 1 2 3 4 5
list 的内容，通过经混洗的 vector 所见: -1 2 -2 1 5 0 3 -3 -4 4
倍增初始化式列表中的值...
list 的内容，通过经混洗的 vector 所见: -2 4 -4 2 10 0 6 -6 -8 8
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc ref}}
{{dsc inc|cpp/utility/functional/dsc bind}}
{{dsc inc|cpp/utility/functional/dsc unwrap_reference}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}