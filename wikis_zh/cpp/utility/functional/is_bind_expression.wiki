{{cpp/title|is_bind_expression}}
{{cpp/utility/functional/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl|since=c++11|1=
template&lt; class T &gt;
struct is_bind_expression;
}}
{{dcl end}}

如果 {{tt|T}} 是调用 {{lc|std::bind}}（但不是 {{rlpt|bind_front|std::bind_front}} 和 {{rlpt|bind_front|std::bind_back}}）产生的类型，那么此模板会从 {{lc|std::true_type}} 派生。对于任何其他类型，此模板（在没有用户特化时）会从 {{lc|std::false_type}} 派生。

程序可以对{{ls|cpp/language/type#由程序定义的类型}} {{tt|T}} 特化此模板，以基特征 {{lc|std::true_type}} 实现{{named req|UnaryTypeTrait}}，指示 {{tt|T}} 应被处理成如同它是绑定子表达式的类型：调用绑定生成的函数对象时，此类型的被绑定参数将作为函数对象调用，并且传递给绑定生成对象的所有未绑定实参都将传给它。

===辅助变量模板===
{{ddcl|since=c++17|1=
template&lt; class T &gt;
constexpr bool is_bind_expression_v = is_bind_expression&lt;T&gt;::value;
}}

{{cpp/types/integral_constant/inherit|{{tt|T}} 是 {{lc|std::bind}} 生成的函数对象}}

===示例===
{{example
|code=
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;

struct MyBind
{
    typedef int result_type;
    int operator()(int a, int b) const { return a + b; }
};

namespace std
{
    template&lt;&gt;
    struct is_bind_expression&lt;MyBind&gt; : public true_type {};
}

int f(int n1, int n2)
{
    return n1 + n2;
}

int main()
{
    // 如同 bind(f, bind(MyBind(), _1, _2), 2)
    auto b = std::bind(f, MyBind(), 2); 
    
    std::cout &lt;&lt; "10 与 11 的和加上 2 得到 " &lt;&lt; b(10, 11) &lt;&lt; '\n';
}
|output=
10 与 11 的和加上 2 得到 23
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2010|std=C++11|before=由程序定义的特化只能从 {{lc|std::false_type}} 派生|after=可以从 {{lc|std::true_type}} 派生}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc bind}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}