{{cpp/title|mem_fun_ref}}
{{cpp/utility/functional/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl|deprecated=c++11|until=c++17|num=1|
template&lt; class Res, class T &gt;
std::mem_fun_ref_t&lt;Res,T&gt; mem_fun_ref( Res (T::*f)() );
}}
{{dcl|deprecated=c++11|until=c++17|num=1|
template&lt; class Res, class T &gt;
std::const_mem_fun_ref_t&lt;Res,T&gt; mem_fun_ref( Res (T::*f)() const );
}}
{{dcl|deprecated=c++11|until=c++17|num=2|
template&lt; class Res, class T, class Arg &gt;
std::mem_fun1_ref_t&lt;Res,T,Arg&gt; mem_fun_ref( Res (T::*f)(Arg) );
}}
{{dcl|deprecated=c++11|until=c++17|num=2|
template&lt; class Res, class T, class Arg &gt;
std::const_mem_fun1_ref_t&lt;Res,T,Arg&gt; mem_fun_ref( Res (T::*f)(Arg) const );
}}
{{dcl end}}

创建成员函数包装器对象，从模板实参推导类型。包装器对象期待到 {{tt|T}} 类型的引用作为其 {{c|operator()}} 的首个参数。

@1@ 相当于调用 {{c|std::mem_fun_ref_t&lt;S,T&gt;(f)}} 或 {{c|std::const_mem_fun_ref_t&lt;S,T&gt;(f)}}。

@2@ 相当于调用 {{c|std::mem_fun1_ref_t&lt;S,T&gt;(f)}} 或 {{c|std::const_mem_fun1_ref_t&lt;S,T&gt;(f)}}。

此函数与相关类型于 C++11 弃用并于 C++17 移除，为了让位给更通用的 {{lc|std::mem_fn}} 与 {{lc|std::bind}}，它们都从成员函数创建可调用的兼容适配器的函数对象。

===参数===
{{par begin}}
{{par|f|指向要创建包装器的成员函数的指针}}
{{par end}}

===返回值===
包装 {{c|f}} 的函数对象。

{{cpp/impldef exception}}

===注解===
{{c|std::mem_fun}} 与 {{c|std::mem_fun_ref}} 的区别是前者产生的函数包装器期待对象指针，而后者期待引用。

===示例===
{{example
|用 {{tt|std::mem_fun_ref}} 绑定 {{lc|std::string}} 的成员函数 {{lc|std::basic_string::size|size()}}。
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;std::string&gt; v = {"once", "upon", "a", "time"};
    std::transform(v.begin(), v.end(),
                   std::ostream_iterator&lt;std::size_t&gt;(std::cout, " "),
                   std::mem_fun_ref(&amp;std::string::size));
}
|output=
4 4 1 4
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc mem_fun}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}