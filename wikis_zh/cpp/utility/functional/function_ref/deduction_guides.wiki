{{title|{{tt|std::function_ref}} 的推导指引}}
{{cpp/utility/functional/function_ref/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl|num=1|since=c++26|
template&lt; class F &gt;
function_ref( F* ) -&gt; function_ref&lt;F&gt;;
}}
{{dcl|num=2|since=c++26|
template&lt; auto f &gt;
function_ref( std::nontype_t&lt;f&gt; ) -&gt; function_ref&lt;/* 见下文 */&gt;;
}}
{{dcl|num=3|since=c++26|
template&lt; auto f, class T &gt;
function_ref( std::nontype_t&lt;f&gt;, T&amp;&amp; ) -&gt; function_ref&lt;/* 见下文 */&gt;;
}}
{{dcl end}}
@1@ {{cpp/enable_if| {{c|std::is_function_v&lt;F&gt;}} 为 {{c|true}} }}。
@2@ 令类型 {{c|F}} 为 {{c|std::remove_pointer_t&lt;decltype(f)&gt;}}。{{cpp/enable_if| {{c|std::is_function_v&lt;F&gt;}} 为 {{c|true}} }}。推导的类型是 {{c|std::function_ref&lt;F&gt;}}。
@3@ 令类型 {{c|F}} 为 {{c|decltype(f)}}。{{cpp/enable_if|：
* {{c|F}} 对于类型 {{c|G}} 的形式为 {{c|R(G::*)(A...) noexcept(E)}}（可选有 cv 限定，可选为 noexcept，可选有左值引用限定），或者
* {{c|F}} 对于类型 {{c|G}} 和对象类型 {{c|M}} 的形式为 {{c|M G::*}}，这种情况下令 {{c|R}} 为 {{c|std::invoke_result_t&lt;F, T&amp;&gt;}}，{{c|A...}} 为空包，并令 {{c|E}} 为 {{c|false}}，或者
* {{c|F}} 对于类型 {{c|G}} 的形式为 {{c|R(*)(G, A...) noexcept(E)}}。
}}。
::推导的类型是 {{c|std::function_ref&lt;R(A...) noexcept(E)&gt;}}。

===示例===
{{example}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}