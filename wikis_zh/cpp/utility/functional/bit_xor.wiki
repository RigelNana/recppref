{{cpp/title|bit_xor}}
{{cpp/utility/functional/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl rev begin}}
{{dcl|until=c++14|
template&lt; class T &gt;
struct bit_xor;
}}
{{dcl|since=c++14|1=
template&lt; class T = void &gt;
struct bit_xor;
}}
{{dcl rev end}}
{{dcl end}}

进行逐位异或的函数对象。相当于调用类型 {{tt|T}} 上的 {{c|operator^}}。

===特化===
{{rev begin}}
{{rev|since=c++14|
标准库提供 {{tt|std::bit_xor}} 在不指定 {{tt|T}} 时的特化，它使得形参类型和返回类型留待推导。
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc bit_xor_void}}
{{dsc end}}
}}
{{rev end}}

{{cpp/utility/functional/member types|result=T|arg1=T|arg2=T}}

===成员函数===
{{dsc begin}}
{{dsc mem fun|operator()|nolink=true|返回两个实参逐位异或的结果}}
{{dsc end}}

{{member|{{small|std::bit_xor::}}operator()|2=
{{dcl begin}}
{{dcla|constexpr=c++14|1=
T operator()( const T&amp; lhs, const T&amp; rhs ) const;
}}
{{dcl end}}

返回 {{c|lhs}} 与 {{c|rhs}} 逐位异或的结果。

===参数===
{{par begin}}
{{par|lhs, rhs|要计算逐位异或的值}}
{{par end}}

===返回值===
{{c|lhs ^ rhs}} 的结果。

{{cpp/impldef exception}}

===可能的实现===
{{eq fun|1=
constexpr T operator()(const T&amp; lhs, const T&amp; rhs) const
{
    return lhs ^ rhs;
}
}}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=660|std=C++98|before=缺少逐位运算的函数对象|after=已添加}}
{{dr list end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}