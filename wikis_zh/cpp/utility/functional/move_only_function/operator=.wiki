{{cpp/utility/functional/move_only_function/title|operator{{=}}}}
{{cpp/utility/functional/move_only_function/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++23|1=
move_only_function&amp; operator=( move_only_function&amp;&amp; other );
}}
{{dcl|num=2|since=c++23|1=
move_only_function&amp; operator=( const move_only_function&amp; ) = delete;
}}
{{dcl|num=3|since=c++23|1=
move_only_function&amp; operator=( std::nullptr_t ) noexcept;
}}
{{dcl|num=4|since=c++23|1=
template&lt; class F &gt;
move_only_function&amp; operator=( F&amp;&amp; f );
}}
{{dcl end}}

指派新目标给 {{tt|std::move_only_function}} 或销毁其目标。

@1@ 通过 {{c|auto(std::move(other)).swap(*this)}} 移动 {{c|other}} 的目标给 {{c|*this}} 或若 {{c|other}} 为空则销毁 {{c|*this}} 的目标（若存在）。移动赋值后 {{c|other}} 在有未指定值的合法状态。

@2@ 复制赋值运算符被弃置。{{tt|std::move_only_function}} 不满足{{named req|CopyAssignable}}。

@3@ 若当前目标存在则销毁它。调用后 {{c|*this}} 为空。

@4@ 如同通过执行 {{c|move_only_function(std::forward&lt;F&gt;(f)).swap(*this);}} 设置 {{c|*this}} 的目标为可调用对象 {{c|f}}，或若 {{c|f}} 为空函数指针、空成员函数指针或空 {{tt|std::move_only_function}} 则销毁当前目标。{{cpp/enable_if| {{tt|move_only_function}} 源自 {{tt|F}} 的构造函数参与重载决议}}。若选择的构造函数调用非良构或有未定义行为，则程序非良构或有未定义行为。

===参数===
{{par begin}}
{{par|other|要移动目标的 {{tt|std::move_only_function}} 对象}}
{{par|f|用以初始化新目标的可调用对象}}
{{par end}}

===返回值===
{{c|*this}}

===注解===
有意不要求移动赋值运算符为 {{c/core|noexcept}}，以为将来的知分配器的 {{tt|move_only_function}} 留出余地。

只要能从 {{c|std::in_place_type&lt;Fn&gt;}} 构造 {{tt|move_only_function}}，就能用该实参对其赋值。

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/function/dsc operator{{=}}}}
{{dsc begin}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}