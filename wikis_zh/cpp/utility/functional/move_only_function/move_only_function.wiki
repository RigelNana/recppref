{{cpp/utility/functional/move_only_function/title|move_only_function}}
{{cpp/utility/functional/move_only_function/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++23|
move_only_function() noexcept;
}}
{{dcl|num=2|since=c++23|
move_only_function( std::nullptr_t ) noexcept;
}}
{{dcl|num=3|since=c++23|
move_only_function( move_only_function&amp;&amp; other ) noexcept;
}}
{{dcl|num=4|since=c++23|1=
move_only_function( const move_only_function&amp; ) = delete;
}}
{{dcl|num=5|since=c++23|
template&lt; class F &gt; 
move_only_function( F&amp;&amp; f );
}}
{{dcl|num=6|since=c++23|
template&lt; class T, class... CArgs &gt; 
explicit move_only_function( std::in_place_type_t&lt;T&gt;, CArgs&amp;&amp;... args );
}}
{{dcl|num=7|since=c++23|
template&lt; class T, class U, class... CArgs &gt; 
explicit move_only_function( std::in_place_type_t&lt;T&gt;,
                             std::initializer_list&lt;U&gt; il, CArgs&amp;&amp;... args );
}}
{{dcl end}}

创建新的 {{tt|std::move_only_function}}。

@1,2@ 默认构造函数与接收 {{c|nullptr}} 的构造函数构造空的 {{tt|std::move_only_function}}。

@3@ 移动构造函数构造目标为 {{c|other}} 的目标的 {{tt|std::move_only_function}}。移动构造后 {{c|other}} 处于合法但未指明的状态。

@4@ 复制构造函数被弃置。{{tt|std::move_only_function}} 不满足{{named req|CopyConstructible}}。

@5@ 令 {{tt|VT}} 为 {{c|std::decay_t&lt;F&gt;}}。若 {{c|f}} 为空函数指针、空成员指针值或空 {{tt|std::move_only_function}}（可为其他任何特化），则构造空的 {{tt|std::move_only_function}}。否则，构造目标具有 {{tt|VT}} 类型并以 {{c|std::forward&lt;F&gt;(f)}} 直接非列表初始化的 {{tt|std::move_only_function}}。
* {{cpp/enable_if| {{tt|VT}} 既非 {{tt|move_only_function}} 亦非 {{lc|std::in_place_type_t}} 的特化，且 {{c|/*is-callable-from*/&lt;VT&gt;}} 为 {{c|true}} }}。
* 若 {{c|std::is_constructible_v&lt;VT, F&gt;}} 非 {{c|true}} 则程序非良构。

@6@ 令 {{tt|VT}} 为 {{c|std::decay_t&lt;T&gt;}}。构造目标具有 {{tt|VT}} 类型并以 {{c|std::forward&lt;CArgs&gt;(args)...}} 直接非列表初始化的 {{tt|std::move_only_function}}。
* {{cpp/enable_if| {{c|std::is_constructible_v&lt;VT, CArgs...&gt;}} 与 {{c|/*is-callable-from*/&lt;VT&gt;}} （见后述）均为 {{c|true}} }}。
* 若 {{tt|VT}} 与 {{tt|T}} 不是同一类型则程序非良构。

@7@ 令 {{tt|VT}} 为 {{c|std::decay_t&lt;T&gt;}}。构造目标具有 {{tt|VT}} 类型并以 {{c|il, std::forward&lt;CArgs&gt;(args)...}} 直接非列表初始化的 {{tt|std::move_only_function}}。
* {{cpp/enable_if| {{c|std::is_constructible_v&lt;VT, std::initializer_list&lt;U&gt;&amp;, CArgs...&gt;}} 与 {{c|/*is-callable-from*/&lt;VT&gt;}}（见后述）均为 {{c|true}} }}。
* 若 {{tt|VT}} 与 {{tt|T}} 不是同一类型则程序非良构。

对于构造函数 {{v|5-7}}，若 {{tt|VT}} 不满足{{named req|Destructible}}要求或若 {{c|std::is_move_constructible_v&lt;VT&gt;}} 为 {{c|true}} 但不满足{{named req|MoveConstructible}}要求则行为未定义。

{{cpp/utility/functional/is_callable_from_table|move_only_function}}

===参数===
{{par begin}}
{{par|other|要移动的另一 {{tt|std::move_only_function}}}}
{{par|f|要包装的函数或{{named req|Callable}}对象}}
{{par|args|构造目标对象的实参}}
{{par|il|构造目标对象的 {{lc|std::initializer_list}}}}
{{par end}}

===异常===
@5-7@ 可能在分配失败时抛出 {{lc|std::bad_alloc}} 或传播初始化目标时抛出的异常。若 {{tt|VT}} 为函数指针类型或 {{lc|std::reference_wrapper}} 的特化则不抛异常。

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/function/dsc constructor}}
{{dsc inc|cpp/utility/functional/copyable_function/dsc constructor}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}