{{cpp/title|ptr_fun}}
{{cpp/utility/functional/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl|deprecated=c++11|until=c++17|num=1|
template&lt; class Arg, class Result &gt;
std::pointer_to_unary_function&lt;Arg,Result&gt;
    ptr_fun( Result (*f)(Arg) );
}}
{{dcl|deprecated=c++11|until=c++17|num=2|
template&lt; class Arg1, class Arg2, class Result &gt;
std::pointer_to_binary_function&lt;Arg1,Arg2,Result&gt;
    ptr_fun( Result (*f)(Arg1, Arg2) );
}}
{{dcl end}}

创建函数包装器对象（{{c|std::pointer_to_unary_function}} 或 {{c|std::pointer_to_binary_function}}），从模板实参推导目标类型。

@1@ 相当于调用 {{c|std::pointer_to_unary_function&lt;Arg,Result&gt;(f)}}。

@2@ 相当于调用 {{c|std::pointer_to_binary_function&lt;Arg1,Arg2,Result&gt;(f)}}。

此函数与关联类型从 C++11 起被弃用，以让位于更通用的 {{lc|std::function}} 和 {{lc|std::ref}}，它们都可以从普通函数创建与适配器兼容的函数对象。

===参数===
{{par begin}}
{{par|f|为之创建包装的函数指针}}
{{par end}}

===返回值===
包装 {{c|f}} 的函数对象。

{{cpp/impldef exception}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;

constexpr bool is_vowel(char c)
{
    return std::string_view{"aeoiuAEIOU"}.find(c) != std::string_view::npos;
}

int main()
{
    std::string_view s = "Hello, world!";
    std::ranges::copy_if(s, std::ostreambuf_iterator&lt;char&gt;(std::cout),
        std::not1(std::ptr_fun(is_vowel)));
// C++11 替用方案：
        std::not1(std::cref(is_vowel)));
        std::not1(std::function&lt;bool(char)&gt;(is_vowel)));
        [](char c) { return !is_vowel(c); });
// C++17 替用方案：
        std::not_fn(is_vowel));
#endif
}
|output=
Hll, wrld!
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc function}}
{{dsc inc|cpp/utility/functional/dsc move_only_function}}
{{dsc inc|cpp/utility/functional/dsc invoke}}
{{dsc inc|cpp/utility/functional/dsc not_fn}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}