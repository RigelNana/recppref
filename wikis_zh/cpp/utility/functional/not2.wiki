{{cpp/title|not2}}
{{cpp/utility/functional/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl rev begin}}
{{dcl|until=c++14| 
template&lt; class Predicate &gt;
std::binary_negate&lt;Predicate&gt; not2( const Predicate&amp; pred );
}}
{{dcl|since=c++14|deprecated=c++17|removed=c++20|
template&lt; class Predicate &gt;
constexpr std::binary_negate&lt;Predicate&gt; not2( const Predicate&amp; pred );
}}
{{dcl rev end}}
{{dcl end}}

{{tt|not2}} 是创建函数对象的辅助函数，它返回传递的二元谓词函数的补。创建的函数对象拥有 {{c|std::binary_negate&lt;Predicate&gt;}} 类型。

二元谓词类型必须定义两个成员类型，{{tt|first_argument_type}} 和 {{tt|second_argument_type}}，它们可转换为谓词的形参类型。从 {{lc|std::owner_less}}、{{lc|std::ref}}、{{lc|std::cref}}、{{lc|std::plus}}、{{lc|std::minus}}、{{lc|std::multiplies}}、{{lc|std::divides}}、{{lc|std::modulus}}、{{lc|std::equal_to}}、{{lc|std::not_equal_to}}、{{lc|std::greater}}、{{lc|std::less}}、{{lc|std::greater_equal}}、{{lc|std::less_equal}}、{{lc|std::logical_not}}、{{lc|std::logical_or}}、{{lc|std::bit_and}}、{{lc|std::bit_or}}、{{lc|std::bit_xor}}、{{lc|std::mem_fn}}、{{lc|std::map::value_comp}}、{{lc|std::multimap::value_comp}}、{{lc|std::function}} 或对 {{lc|std::not2}} 调用获得的函数对象定义这些类型，和派生自已弃用的 {{lc|std::binary_function}} 的函数对象一样。

===参数===
{{par begin}}
{{par|pred|二元谓词}}
{{par end}}

===返回值===
{{tt|std::not2}} 返回以 {{c|pred}} 构造的 {{c|std::binary_negate&lt;Predicate&gt;}} 类型的对象。

===异常===
（无）

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cstddef&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
 
struct old_same : std::binary_function&lt;int, int, bool&gt;
{
    bool operator()(int a, int b) const { return a == b; }
};
 
struct new_same
{
    bool operator()(int a, int b) const { return a == b; }
};

bool same_fn(int a, int b)
{
    return a == b;
}
 
int main()
{
    std::vector&lt;int&gt; v1{0, 1, 2};
    std::vector&lt;int&gt; v2{2, 1, 0};
    std::vector&lt;bool&gt; v3(v1.size());
 
    std::cout &lt;&lt; "取反 binary_function:\n";
    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),
                   std::not2(old_same()));
 
    std::cout &lt;&lt; std::boolalpha;
    for (std::size_t i = 0; i &lt; v1.size(); ++i)
        std::cout &lt;&lt; v1[i] &lt;&lt; ' ' &lt;&lt; v2[i] &lt;&lt; ' ' &lt;&lt; v3[i] &lt;&lt; '\n';
 
    std::cout &lt;&lt; "取反标准函数对象:\n";
    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),
                   std::not2(std::equal_to&lt;int&gt;()));
 
    for (std::size_t i = 0; i &lt; v1.size(); ++i)
        std::cout &lt;&lt; v1[i] &lt;&lt; ' ' &lt;&lt; v2[i] &lt;&lt; ' ' &lt;&lt; v3[i] &lt;&lt; '\n';
 
    std::cout &lt;&lt; "取反 std::function:\n";
    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),
                   std::not2(std::function&lt;bool(int, int)&gt;(new_same())));
 
    for (std::size_t i = 0; i &lt; v1.size(); ++i)
        std::cout &lt;&lt; v1[i] &lt;&lt; ' ' &lt;&lt; v2[i] &lt;&lt; ' ' &lt;&lt; v3[i] &lt;&lt; '\n';

    std::cout &lt;&lt; "取反 std::reference_wrapper:\n";
    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),
                   std::not2(std::ref(same_fn)));
 
    for (std::size_t i = 0; i &lt; v1.size(); ++i)
        std::cout &lt;&lt; v1[i] &lt;&lt; ' ' &lt;&lt; v2[i] &lt;&lt; ' ' &lt;&lt; v3[i] &lt;&lt; '\n';

}
|output=
取反 binary_function:
0 2 true
1 1 false
2 0 true
取反标准函数对象:
0 2 true
1 1 false
2 0 true
取反 std::function:
0 2 true
1 1 false
2 0 true
取反 std::reference_wrapper:
0 2 true
1 1 false
2 0 true
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc not_fn}}
{{dsc inc|cpp/utility/functional/dsc binary_negate}}
{{dsc inc|cpp/utility/functional/dsc function}}
{{dsc inc|cpp/utility/functional/dsc move_only_function}}
{{dsc inc|cpp/utility/functional/dsc not1}}
{{dsc inc|cpp/utility/functional/dsc ptr_fun}}
{{dsc inc|cpp/utility/functional/dsc binary_function}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}