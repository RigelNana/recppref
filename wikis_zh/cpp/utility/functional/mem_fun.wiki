{{cpp/title|mem_fun}}
{{cpp/utility/functional/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl|deprecated=c++11|until=c++17|num=1|
template&lt; class Res, class T &gt;
std::mem_fun_t&lt;Res,T&gt; mem_fun( Res (T::*f)() );
}}
{{dcl|deprecated=c++11|until=c++17|num=1|
template&lt; class Res, class T &gt;
std::const_mem_fun_t&lt;Res,T&gt; mem_fun( Res (T::*f)() const );
}}
{{dcl|deprecated=c++11|until=c++17|num=2|
template&lt; class Res, class T, class Arg &gt;
std::mem_fun1_t&lt;Res,T,Arg&gt; mem_fun( Res (T::*f)(Arg) );
}}
{{dcl|deprecated=c++11|until=c++17|num=2|
template&lt; class Res, class T, class Arg &gt;
std::const_mem_fun1_t&lt;Res,T,Arg&gt; mem_fun( Res (T::*f)(Arg) const );
}}
{{dcl end}}

创建成员函数包装器对象，从模板实参推导目标类型。包装器对象期待以指向 {{tt|T}} 类型对象的指针作为其 {{c|operator()}} 的首个参数。

@1@ 相当于调用 {{c|std::mem_fun_t&lt;Res,T&gt;(f)}} 或 {{c|std::const_mem_fun_t&lt;Res,T&gt;(f)}}。

@2@ 相当于调用 {{c|std::mem_fun1_t&lt;Res,T,Arg&gt;(f)}} 或 {{c|std::const_mem_fun1_t&lt;Res,T,Arg&gt;(f)}}。

此函数与相关类型于 C++11 弃用并于 C++17 移除，为了让位给更通用的 {{lc|std::mem_fn}} 与 {{lc|std::bind}}，它们都能从成员函数创建可调用的兼容适配器的函数对象。

===参数===
{{par begin}}
{{par|f|要创建包装器的成员函数指针}}
{{par end}}

===返回值===
包装 {{tt|f}} 的函数对象。

{{cpp/impldef exception}}

===注解===
{{c|std::mem_fun}} 与 {{c|std::mem_fun_ref}} 的区别是前者产生的函数包装器期待对象指针，而后者期待引用。

===示例===
{{example
|1=演示 {{tt|std::mem_fun}} 的用法，并将其与 {{lc|std::mem_fn}} 进行比较。可能必须使用 C++11/14 兼容编译模式：g++/clang++ 带 -std=c++11，cl 带 /std:c++11 等。在近期的编译器（如 gcc-12）上，如果不在 C++98 模式中编译，则可能给出 "已弃用声明" 的警告。
|code=
#include &lt;functional&gt;
#include &lt;iostream&gt;

struct S
{
    int get_data() const { return data; }
    void no_args() const { std::cout &lt;&lt; "void S::no_args() const\n"; }
    void one_arg(int) { std::cout &lt;&lt; "void S::one_arg()\n"; }
    void two_args(int, int) { std::cout &lt;&lt; "void S::two_args(int, int)\n"; }
#if __cplusplus &gt; 201100
    int data{42};
#else
    int data;
    S() : data(42) {}
#endif
};

int main()
{
    S s;
 
    std::const_mem_fun_t&lt;int, S&gt; p = std::mem_fun(&amp;S::get_data);
    std::cout &lt;&lt; "s.get_data(): " &lt;&lt; p(&amp;s) &lt;&lt; '\n';
 
    std::const_mem_fun_t&lt;void, S&gt; p0 = std::mem_fun(&amp;S::no_args);
    p0(&amp;s);

    std::mem_fun1_t&lt;void, S, int&gt; p1 = std::mem_fun(&amp;S::one_arg);
    p1(&amp;s, 1);

#if __cplusplus &gt; 201100
//  auto p2 = std::mem_fun(&amp;S::two_args); // 错误: mem_fun 只支持没有形参或只有一个形参的成员函数。
                                          // 因此，std::mem_fn 是更好的替代品：
    auto p2 = std::mem_fn(&amp;S::two_args);
    p2(s, 1, 2);

//  auto pd = std::mem_fun(&amp;S::data); // 错误: 不支持数据成员指针。
                                      // 换用 std::mem_fn：
    auto pd = std::mem_fn(&amp;S::data);
    std::cout &lt;&lt; "s.data = " &lt;&lt; pd(s) &lt;&lt; '\n';
#endif
}
|p=true
|output=
s.get_data(): 42
void S::no_args() const
void S::one_arg(int)
void S::two_args(int, int)
s.data = 42
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc mem_fn}}
{{dsc inc|cpp/utility/functional/dsc mem_fun_ref}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}