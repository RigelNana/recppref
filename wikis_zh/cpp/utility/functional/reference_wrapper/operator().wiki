{{cpp/utility/functional/reference_wrapper/title|operator()}}
{{cpp/utility/functional/reference_wrapper/navbar}}
{{dcl begin}}
{{dcl rev multi
|since1=c++11|dcl1=
template&lt; class... ArgTypes &gt;
typename std::result_of&lt;T&amp;(ArgTypes&amp;&amp;...)&gt;::type
    operator() ( ArgTypes&amp;&amp;... args ) const;
|since2=c++17|notes2={{mark constexpr since c++20}}|dcl2=
template&lt; class... ArgTypes &gt;
std::invoke_result_t&lt;T&amp;, ArgTypes...&gt;
    operator() ( ArgTypes&amp;&amp;... args ) const noexcept(/* 见下文 */);
}}
{{dcl end}}

如同以 {{box|{{lti|cpp/utility/functional|INVOKE}}{{c/core|(}}{{rlpf|get}}{{c/core|, std::forward&lt;ArgTypes&gt;(args)...)}}}} 调用存储自身引用的{{named req|Callable}}对象。此函数只有在存储的引用指向{{named req|Callable}}对象时才可用。

{{tt|T}} 必须是完整类型。

===参数===
{{par begin}}
{{par|args|传递给被调用函数的实参}}
{{par end}}

===返回值===
被调用函数的返回值。

===异常===
{{rrev multi|since1=c++11|until1=c++17
|rev1=可能会抛出由实现定义的异常。
|rev2={{noexcept|std::is_nothrow_invocable_v&lt;T&amp;, ArgTypes...&gt;}}
}}

===示例===
{{example|
|code=
#include &lt;functional&gt;
#include &lt;iostream&gt;

void f1()
{
    std::cout &lt;&lt; "调用了到函数的引用\n";
}

void f2(int n)
{
    std::cout &lt;&lt; "以 " &lt;&lt; n &lt;&lt; " 作为实参调用了绑定表达式\n";
}

int main()
{
    std::reference_wrapper&lt;void()&gt; ref1 = std::ref(f1);
    ref1();
    
    auto b = std::bind(f2, std::placeholders::_1);
    auto ref2 = std::ref(b);
    ref2(7);
    
    auto c = []{std::cout &lt;&lt; "调用了 lambda 函数\n"; };
    auto ref3 = std::ref(c);
    ref3();
}
|output=
调用了到函数的引用
以 7 作为实参调用了绑定表达式
调用了 lambda 函数
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3764|std=C++17|before={{c/core|operator()}} 不是 {{c/core|noexcept}}|after=传播 {{c/core|noexcept}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/reference_wrapper/dsc get}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}