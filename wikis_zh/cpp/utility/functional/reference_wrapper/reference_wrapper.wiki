{{cpp/utility/functional/reference_wrapper/title|reference_wrapper}}
{{cpp/utility/functional/reference_wrapper/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++11|notes={{mark constexpr since c++20}}|
template&lt; class U &gt;
reference_wrapper( U&amp;&amp; x ) noexcept(/* 见下文 */) ;
}}
{{dcl|num=2|since=c++11|notes={{mark constexpr since c++20}}|
reference_wrapper( const reference_wrapper&amp; other ) noexcept;
}}
{{dcl end}}

构造新的引用包装器。

@1@ 如同用 {{c|1=T&amp; t = std::forward&lt;U&gt;(x);}} 转换 {{tt|x}} 为 {{tt|T&amp;}}，然后存储到 {{tt|t}} 的引用。{{cpp/enable if| {{c|typename std::decay&lt;U&gt;::type}} 与 {{tt|reference_wrapper}} 不是同一类型且表达式 {{c|FUN(std::declval&lt;U&gt;())}} 为良构}}，其中 {{tt|FUN}} 指名虚构的函数集。
{{source|1=
void FUN(T&amp;) noexcept;
void FUN(T&amp;&amp;) = delete;
}}

@2@ 复制构造函数。存储到 {{tt|other.get()}} 的引用。

===参数===
{{par begin}}
{{par|x|要包装的对象}}
{{par|other|另一引用包装器}}
{{par end}}

===异常===
@1@ {{noexcept|noexcept(FUN(std::declval&lt;U&gt;()))}}，其中 {{tt|FUN}} 是以上描述中的虚构函数集。

===示例===
{{example}}

===缺陷报告===
{{dr list begin}}
{{dr list item|std=C++11|dr=2993|wg=lwg|before=被弃置的 {{tt|reference_wrapper(T&amp;&amp;)}} 构造函数在某些情况下干涉重载决议| after=替换成构造函数模板}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}