{{title|C++ 标准库}}
{{cpp/standard library/navbar}}

C++ 标准库提供了可以在标准 C++ 中使用的各类设施。

===分类===
[[cpp/utility#语言支持|语言支持库]]提供了 C++ 语言中特定部分需要的组件，例如内存分配（[[cpp/language/new|new]]/[[cpp/language/delete|delete]]）和[[cpp/language/exceptions|异常处理]]。

{{rrev|since=c++20|
[[cpp/concepts|概念库]]描述了 C++ 程序为进行编译期[[cpp/language/template parameters|模板实参]]验证和根据类型的属性分派函数而可能要用到的库组件。
}}

[[cpp/error|诊断库]]提供了在 C++ 程序中报告错误的统一框架，包括[[cpp/error#异常类别|预定义的异常类]]。

[[cpp/memory|内存管理库]]提供了内存管理所需的组件，包括{{ls|cpp/memory#智能指针}}{{rev inl|since=c++11|和[[cpp/memory/scoped_allocator_adaptor|有作用域分配器]]}}。

{{rrev|since=c++11|
[[cpp/meta|元编程库]]描述了用于[[cpp/language/templates|模板]]和常量求值的设施，包括[[cpp/meta#类型特征|类型特征]]{{rev inl|since=c++14|，{{lt|cpp/utility/integer_sequence|整数序列}}}}和[[cpp/numeric/ratio|有理数算术]]。
}}

[[cpp/utility#通用工具|通用工具库]]包含了其他库元素需要用到的组件，例如动态存储管理所需的[[cpp/memory#分配器|预定义的存储分配器]]，以及 C++ 程序中用作基础设施的组件，例如{{rev inl|since=c++11|{{lt|cpp/utility/tuple|元组}}和}}[[cpp/utility/functional|函数包装器]]。

{{lt|cpp/container|容器}}，{{lt|cpp/iterator|迭代器}}{{rev inl|since=c++20|，{{lt|cpp/ranges|范围}}}}和{{lt|cpp/algorithm|算法}}库向 C++ 程序提供了最广泛使用的算法和数据结构的一个子集。

[[cpp/string|字符串库]]针对表示为以下类型的同质序列的字符序列的文本进行操纵提供支持：{{c/core|char}}，{{rev inl|since=c++20|{{c/core|char8_t}}，}}{{rev inl|since=c++11|{{c/core|char16_t}}，{{c/core|char32_t}}，}}{{c/core|wchar_t}} 或其他字符式类型。

[[cpp/text|文本处理库]]提供{{rev inl|since=c++11|[[cpp/regex|正则表达式]]匹配与搜索}}{{rev inl|since=c++20|，[[cpp/utility/format|文本格式化]]工具}}{{rev inl|since=c++26|和[[cpp/text/text_encoding|文本编码识别]]}}，以及[[cpp/locale|本地化设施]]。

[[cpp/numeric|数值库]]提供了{{ls|cpp/numeric#数值算法}}和[[cpp/numeric/complex|复数]]组件以扩展对数值处理的支持。{{lt|cpp/numeric/valarray}} 组件提供了对同时处理多个数值的支持，它可以在支持的平台上被实现为采用并行操作。{{rev inl|since=c++11|[[cpp/numeric/random|随机数组件]]提供了生成伪随机数的设施。}}

[[cpp/chrono|时间库]]提供了通用的时间工具。

[[cpp/io|输入/输出库]]提供了用于 C++ 程序的主要输入和输出机制的 [[cpp/io#基于流的 I/O|I/O 流组件]]。它们可以和库的其他元素一起使用，尤其是字符串、本地化和迭代器。

{{rrev|since=c++11|
[[cpp/thread|线程支持库]]提供了用于创建和管理线程的组件，包括[[cpp/atomic/atomic|原子操作]]，[[cpp/thread/mutex|互斥锁]]和线程间通信。
}}
&lt;p&gt;
{{rrev|since=c++26|
[[cpp/execution|执行支持库]]提供了用于在通用执行资源上管理异步执行的框架。
}}

===库的内容===
除非另外说明，C++ 标准库会按 [[cpp/headers|C++ 标准库]]中的大纲的描述来提供[[cpp/language/basic concepts|实体]]和[[cpp/preprocessor/replace|宏]]的定义。

除了 {{lc|operator new}} 和 {{lc|operator delete}} 以外的所有库实体都在命名空间 {{c|std}} 或命名空间 {{c|std}} 中嵌套的{{lt|cpp/language/namespace|命名空间}}中定义（C 标准库设施的实体除外，见下文）。{{rev inl|since=c++11|未指明在指定命名空间中定义的名字是直接在该命名空间中定义还是在该命名空间中的[[cpp/language/namespace#内联命名空间|内联命名空间]]定义。}}

====标头====
C++ 标准库中的每个元素都在{{i|标头}}内声明或（合适地）定义。标头不一定是源文件，标头名中 {{ttb|&amp;lt;}} 和 {{ttb|&amp;gt;}} 之间的序列也不一定是合法的源文件名。

C++ 标准库提供了 {{i|C++ 库标头}}和''提供了 C 库设施的额外 C++ 标头''（具体描述见“{{lt|cpp/headers|标头}}”页面）：
{|class="wikitable"
|-style="text-align:center; font-size:16px; line-height:16px;"
!colspan="5"|C++ 库标头
|-
|{{header|algorithm}}
|{{header|iomanip}}
|{{header|list}}
|{{header|ostream}}
|{{header|streambuf}}
|-
|{{header|bitset}}
|{{header|ios}}
|{{header|locale}}
|{{header|queue}}
|{{header|string}}
|-
|{{header|complex}}
|{{header|iosfwd}}
|{{header|map}}
|{{header|set}}
|{{header|typeinfo}}
|-
|{{header|deque}}
|{{header|iostream}}
|{{header|memory}}
|{{header|sstream}}
|{{header|utility}}
|-
|{{header|exception}}
|{{header|istream}}
|{{header|new}}
|{{header|stack}}
|{{header|valarray}}
|-
|{{header|fstream}}
|{{header|iterator}}
|{{header|numeric}}
|{{header|stdexcept}}
|{{header|vector}}
|-
|{{header|functional}}
|{{header|limits}}
|
|
|
|-style="text-align:center"
!colspan="5"|C++11 中添加的标头
|-
|{{header|array}}
|{{header|condition_variable}}
|{{header|mutex}}
|{{header|scoped_allocator}}
|{{header|type_traits}}
|-
|{{header|atomic}}
|{{header|forward_list}}
|{{header|random}}
|{{header|system_error}}
|{{header|typeindex}}
|-
|{{header|chrono}}
|{{header|future}}
|{{header|ratio}}
|{{header|thread}}
|{{header|unordered_map}}
|-
|{{header|codecvt}}
|{{header|initializer_list}}
|{{header|regex}}
|{{header|tuple}}
|{{header|unordered_set}}
|-style="text-align:center"
!colspan="5"|C++14 中添加的标头
|-
|{{header|shared_mutex}}
|
|
|
|
|-style="text-align:center"
!colspan="5"|C++17 中添加的标头
|-
|{{header|any}}
|{{header|execution}}
|{{header|memory_resource}}
|{{header|string_view}}
|{{header|variant}}
|-
|{{header|charconv}}
|{{header|filesystem}}
|{{header|optional}}
|
|
|-style="text-align:center"
!colspan="5"|C++20 中添加的标头
|-
|{{header|barrier}}
|{{header|concepts}}
|{{header|latch}}
|{{header|semaphore}}
|{{header|stop_token}}
|-
|{{header|bit}}
|{{header|coroutine}}
|{{header|numbers}}
|{{header|source_location}}
|{{header|syncstream}}
|-
|{{header|compare}}
|{{header|format}}
|{{header|ranges}}
|{{header|span}}
|{{header|version}}
|-style="text-align:center"
!colspan="5"|C++23 中添加的标头
|-
|{{header|expected}}
|{{header|flat_set}}
|{{header|mdspan}}
|{{header|spanstream}}
|{{header|stdfloat}}
|-
|{{header|flat_map}}
|{{header|generator}}
|{{header|print}}
|{{header|stacktrace}}
|
|-style="text-align:center"
!colspan="5"|C++26 中添加的标头
|-
|{{header|contracts}}
|{{header|hazard_pointer}}
|{{header|inplace_vector}}
|{{header|rcu}}
|{{header|text_encoding}}
|-
|{{header|debugging}}
|{{header|hive}}
|{{header|linalg}}
|{{header|simd}}
|
|-style="text-align:center; font-size:16px; line-height:16px;"
!colspan="5"|被移除的标头
|-
|{{header|codecvt}}
|colspan="4"|{{mark life|since=c++11|deprecated=c++17|removed=c++26}}
|-
|{{header|strstream}}
|colspan="4"|{{mark life|deprecated=c++98|removed=c++26}}
|}

{|class="wikitable"
|-style="text-align:center; font-size:16px; line-height:16px;"
! colspan="4"|提供了 C 库设施的 C++ 标头
|-
|{{header|cassert}}
|{{header|clocale}}
|{{header|cstdarg}}
|{{header|cstring}}
|-
|{{header|cctype}}
|{{header|cmath}}
|{{header|cstddef}}
|{{header|ctime}}
|-
|{{header|cerrno}}
|{{header|csetjmp}}
|{{header|cstdio}}
|{{header|cwchar}}
|-
|{{header|cfloat}}
|{{header|csignal}}
|{{header|cstdlib}}
|{{header|cwctype}}
|-
|{{header|climits}}
|
|
|
|-style="text-align:center"
!colspan="4"|C++11 中添加的标头
|-
|{{header|cfenv}}
|{{header|cinttypes}}
|{{header|cstdint}}
|{{header|cuchar}}
|-style="text-align:center; font-size:16px; line-height:16px;"
!colspan="5"|被移除的标头
|-
|{{header|ccomplex}}
|colspan="4"|{{mark life|since=c++11|deprecated=c++17|removed=c++20}}
|-
|{{header|ciso646}}
|colspan="4"|{{mark until c++20|removed=yes}}
|-
|{{header|cstdalign}}
|colspan="4"|{{mark life|since=c++11|deprecated=c++17|removed=c++20}}
|-
|{{header|cstdbool}}
|colspan="4"|{{mark life|since=c++11|deprecated=c++17|removed=c++20}}
|-
|{{header|ctgmath}}
|colspan="4"|{{mark life|since=c++11|deprecated=c++17|removed=c++20}}
|}

[[cpp/freestanding|独立实现]]带有由实现定义的一套标头，对这套标头的最低限度要求参考[[cpp/freestanding#标头规定|此处]]。

===C 标准库===
使用 C++ 标准库也可以使用 C 标准库的设施，它们经适当调整以确保静态类型安全。对于这些库函数的描述大多依赖于它们在 C 标准库中的语义。

在某些情况下，标准 C++ 中指定的签名可能会与在 C 标准库中的签名不同，并且可能会声明额外的重载，但是没有另外说明的情况下它们的行为和前提条件{{rev inl|since=c++17|（包括 C 的 [[c/language/restrict|{{c/core|restrict}}]] 所蕴含的语义）}}不变。

为了与 C 标准库的兼容性，C++ 标准库提供了以下列出的 C 标头。这些标头应该只在需要考虑互操作性的时候使用。C++ 源文件可能需要包含这些标头其中之一以成为合法的 ISO C 源文件。没有考虑成为合法的 ISO C 源文件的源文件不应使用这些 C 标头。具体描述参考[[cpp/headers#C 兼容头文件|此处]]。
{|class="wikitable"
|-style="text-align:center; font-size:16px; line-height:16px;"
!colspan="4"|C 标头
|-
|{{ltt|cpp/header/cassert|&lt;assert.h&gt;}}
|{{ltt|cpp/header/climits|&lt;limits.h&gt;}}
|{{ltt|cpp/header/cstdarg|&lt;stdarg.h&gt;}}
|{{ltt|cpp/header/cstring|&lt;string.h&gt;}}
|-
|{{ltt|cpp/header/cctype|&lt;ctype.h&gt;}}
|{{ltt|cpp/header/clocale|&lt;locale.h&gt;}}
|{{ltt|cpp/header/cstddef|&lt;stddef.h&gt;}}
|{{ltt|cpp/header/ctime|&amp;lt;time.h&gt;}}
|-
|{{ltt|cpp/header/cerrno|&lt;errno.h&gt;}}
|{{ltt|cpp/header/cmath|&lt;math.h&gt;}}
|{{ltt|cpp/header/cstdio|&lt;stdio.h&gt;}}
|{{ltt|cpp/header/cwchar|&lt;wchar.h&gt;}}
|-
|{{ltt|cpp/header/cfloat|&lt;float.h&gt;}}
|{{ltt|cpp/header/csetjmp|&lt;setjmp.h&gt;}}
|{{ltt|cpp/header/cstdlib|&lt;stdlib.h&gt;}}
|{{ltt|cpp/header/cwctype|&lt;wctype.h&gt;}}
|-
|{{ltt|cpp/header/ciso646|&lt;iso646.h&gt;}}
|{{ltt|cpp/header/csignal|&lt;signal.h&gt;}}
|
|
|-style="text-align:center"
!colspan="4"|C++11 中添加的标头
|-
|{{ltt|cpp/header/ccomplex|&lt;complex.h&gt;}}
|{{ltt|cpp/header/cinttypes|&lt;inttypes.h&gt;}}
|{{ltt|cpp/header/cstdbool|&lt;stdbool.h&gt;}}
|{{ltt|cpp/header/ctgmath|&lt;tgmath.h&gt;}}
|-
|{{ltt|cpp/header/cfenv|&lt;fenv.h&gt;}}
|{{ltt|cpp/header/cstdalign|&lt;stdalign.h&gt;}}
|{{ltt|cpp/header/cstdint|&lt;stdint.h&gt;}}
|{{ltt|cpp/header/cuchar|&lt;uchar.h&gt;}}
|-style="text-align:center"
!colspan="4"|C++23 中添加的标头
|-
|{{ltt|cpp/header/stdatomic.h|&lt;stdatomic.h&gt;}}
|
|
|
|-style="text-align:center"
!colspan="4"|C++26 中添加的标头
|-
|{{ltt|cpp/header/stdbit.h|&lt;stdbit.h&gt;}}
|{{ltt|cpp/header/stdchkint.h|&lt;stdchkint.h&gt;}}
|}

除非另外说明，标头 {{tt|c''xxx''}} 中的内容与 [[c/header|C 标准库]]中规定的对应的标头 {{tt|''xxx''.h}} 一致。但是在 C++ 标准库中，这些声明（除了在 C 中被定义为宏的名字）处于命名空间 {{c|std}} 的命名空间作用域中。未指明这些名字（包括添加的重载）是否在全局命名空间作用域首次声明然后通过显式 {{ls|cpp/language/namespace#using 声明}}注入命名空间 {{c|std}}。

在 C 中定义为宏的名字（{{ltt|cpp/error/assert}}，{{ltt|cpp/types/offsetof}}，{{ltt|cpp/utility/program/setjmp}}，{{ltt|cpp/utility/variadic/va_arg}}，{{ltt|cpp/utility/variadic/va_end}} 和 {{ltt|cpp/utility/variadic/va_start}}）在 C++ 标准库中也必须定义为宏，即使 C 授予了实现将它们定义为函数的许可也是如此。

在 C 中定义为函数的名字在 C++ 标准库中也必须定义为函数。这禁止了 C 中所允许的一种实践，即在函数原型之外提供一个遮蔽宏。在 C++ 中唯一可以达成等价的内联行为的方法是将它们定义成 extern [[cpp/language/inline|内联函数]]。

在 C++ 是关键词或运算符的标识符不能在 C++ 标准库标头中定义为宏。特别地，包含标头 {{ltt|cpp/header/ciso646|&lt;iso646.h&gt;}} 没有任何效果。

====与标准 C 中的安全函数关联的名字 {{mark since c++17}}====
只要包含了任何 C++ 标头，由实现定义是否在全局命名空间声明以下在 C 标准附录 K 中的名字（它们不会在命名空间 {{c|std}} 中声明）：

{|class="wikitable"
|-style="text-align:center"
!colspan="4"|C 标准附录 K 中的名字
|-
|{{ltt|c/error/abort_handler_s}}
|{{ltt|c/string/multibyte/mbstowcs|mbstowcs_s}}
|{{ltt|c/string/byte/strncat|strncat_s}}
|{{ltt|c/io/vfwscanf|vswscanf_s}}
|-
|{{ltt|c/chrono/asctime|asctime_s}}
|{{ltt|c/string/byte/memcpy|memcpy_s}}
|{{ltt|c/string/byte/strncpy|strncpy_s}}
|{{ltt|c/io/vfwprintf|vwprintf_s}}
|-
|{{ltt|c/algorithm/bsearch|bsearch_s}}
|{{ltt|c/string/byte/memmove|memmove_s}}
|{{ltt|c/string/byte/strtok|strtok_s}}
|{{ltt|c/io/vfwscanf|vwscanf_s}}
|-
|{{ltt|c/error/set_constraint_handler_s|constraint_handler_t}}
|{{ltt|c/string/byte/memset|memset_s}}
|{{ltt|c/io/fwprintf|swprintf_s}}
|{{ltt|c/string/multibyte/wcrtomb|wcrtomb_s}}
|-
|{{ltt|c/chrono/ctime|ctime_s}}
|{{ltt|c/io/fprintf|printf_s}}
|{{ltt|c/io/fwscanf|swscanf_s}}
|{{ltt|c/string/wide/wcscat|wcscat_s}}
|-
|{{ltt|c/error|errno_t}}
|{{ltt|c/algorithm/qsort|qsort_s}}
|{{ltt|c/io/tmpfile|tmpfile_s}}
|{{ltt|c/string/wide/wcscpy|wcscpy_s}}
|-
|{{ltt|c/io/fopen|fopen_s}}
|{{ltt|c/error|RSIZE_MAX}}
|{{ltt|c/io/tmpnam|TMP_MAX_S}}
|{{ltt|c/string/wide/wcsncat|wcsncat_s}}
|-
|{{ltt|c/io/fprintf|fprintf_s}}
|{{ltt|c/error|rsize_t}}
|{{ltt|c/io/tmpnam|tmpnam_s}}
|{{ltt|c/string/wide/wcsncpy|wcsncpy_s}}
|-
|{{ltt|c/io/freopen|freopen_s}}
|{{ltt|c/io/fscanf|scanf_s}}
|{{ltt|c/io/vfprintf|vfprintf_s}}
|{{ltt|c/string/wide/wcslen|wcsnlen_s}}
|-
|{{ltt|c/io/fscanf|fscanf_s}}
|{{ltt|c/error/set_constraint_handler_s}}
|{{ltt|c/io/vfscanf|vfscanf_s}}
|{{ltt|c/string/multibyte/wcsrtombs|wcsrtombs_s}}
|-
|{{ltt|c/io/fwprintf|fwprintf_s}}
|{{ltt|c/io/fprintf|snprintf_s}}
|{{ltt|c/io/vfwprintf|vfwprintf_s}}
|{{ltt|c/string/wide/wcstok|wcstok_s}}
|-
|{{ltt|c/io/fwscanf|fwscanf_s}}
|{{ltt|c/io/fwprintf|snwprintf_s}}
|{{ltt|c/io/vfwscanf|vfwscanf_s}}
|{{ltt|c/string/multibyte/wcstombs|wcstombs_s}}
|-
|{{ltt|c/io/gets|gets_s}}
|{{ltt|c/io/fscanf|sscanf_s}}
|{{ltt|c/io/vfprintf|vprintf_s}}
|{{ltt|c/string/wide/wmemcpy|wmemcpy_s}}
|-
|{{ltt|c/chrono/gmtime|gmtime_s}}
|{{ltt|c/string/multibyte/mbstowcs|mbstowcs_s}}
|{{ltt|c/io/vfscanf|vscanf_s}}
|{{ltt|c/io/vfwscanf|vswscanf_s}}
|-
|{{ltt|c/error/abort_handler_s}}
|{{ltt|c/string/byte/strcat|strcat_s}}
|{{ltt|c/io/vfprintf|vsnprintf_s}}
|{{ltt|c/string/wide|wmemmove|wmemmove_s}}
|-
|{{ltt|c/error/ignore_handler_s}}
|{{ltt|c/string/byte/strcpy|strcpy_s}}
|{{ltt|c/io/vfwprintf|vsnwprintf_s}}
|{{ltt|c/io/fwprintf|wprintf_s}}
|-
|{{ltt|c/chrono/localtime|localtime_s}}
|{{ltt|c/string/byte/strerror|strerrorlen_s}}
|{{ltt|c/io/vfprintf|vsprintf_s}}
|{{ltt|c/io/fwscanf|wscanf_s}}
|-
|{{ltt|c/io/tmpnam|L_tmpnam_s}}
|{{ltt|c/string/byte/strerror|strerror_s}}
|{{ltt|c/io/vfscanf|vsscanf_s}}
|
|-
|{{ltt|c/string/multibyte/mbsrtowcs|mbsrtowcs_s}}
|{{ltt|c/string/byte/strlen|strlen_s}}
|{{ltt|c/io/vfwprintf|vswprintf_s}}
|
|}

===库的使用===
====包含标头====
C++ 标准库中的实体在标头中定义，翻译单元中有合适的 {{ltt|cpp/preprocessor/include|#include}} 预处理指令时将使标头中的内容可以用于该翻译单元。

翻译单元可以以任何顺序包含库标头。每个标头都可以被多次包含，效果和只包含一次相同，但每次包含 {{header|cassert}} 或 {{ltt|cpp/header/cassert|&lt;assert.h&gt;}} 的效果都依赖于 {{c|NDEBUG}} 的当前词法定义。

翻译单元只能在定义或声明之外包含标头，并且该标头内声明的实体只能在词法中这次包含之后引用。不需要诊断。

{{rrev|since=c++20|
在[[cpp/language/modules|模块单元]]中，只能在{{ls|cpp/language/modules#全局模块片段}}包含标头。
}}

{{rev begin}}
{{rev|since=c++20|
====导入标头====
[[#标头|C++ 库标头]]，或者对于自立实现，由实现提供的这些标头的子集，被统称为''可导入的 C++ 库标头''。

翻译单元中有合适的[[cpp/language/modules#导入模块和头|导入声明]]时可以使可导入的 C++ 库标头中的内容可以用于该翻译单元（即导入该标头）。
}}
{{rev|since=c++23|
====导入模块====
C++ 标准库提供以下 ''C++ 库模块''：
* [[cpp/language/modules#模块声明|具名模块]] {{c|std}} 会导出由可导入的 C++ 库标头或[[#标头|提供了 C 库设施的额外 C++ 标头]]提供的在命名空间 {{tt|std}} 中的声明（例如 {{header|bit}} 的 {{lc|std::rotr}} 以及 {{header|cstdio}} 的 {{lc|std::puts}}）。它还会导出由 {{header|new}} 提供的存储[[cpp/memory/new/operator new|分配]]和[[cpp/memory/new/operator delete|解分配]]函数在全局命名空间的声明（例如 {{lc|operator new|::operator new}}）。
* 具名模块 {{c|std.compat}} 会导出与具名模块 {{c|std}} 相同的声明，外加与由提供了 C 库设施的额外 C++ 标头提供的在命名空间 {{tt|std}} 中的声明相对应的在全局命名空间中的声明（例如 {{lc|std::fclose|::fclose}}）。

对于标准库中的每个声明：
* 未指明它[[cpp/language/modules#模块所有权|隶属于]]哪个模块。
* 无论它是因为包含标头，导入标头单元还是导入 C++ 库模块而变得可及，它都会表示相同的[[cpp/language/basic concepts|实体]]。
}}
{{rev end}}

====链接====
C++ 标准库中的实体具有{{ls|cpp/language/storage duration#外部链接}}。除非另外说明，对象和函数默认具有 {{c/core|extern "C++"}} [[cpp/language/language linkage|链接]]。

来自 C 标准库并且声明为具有外部链接的名字具有 {{c/core|extern "C"}} 还是 {{c/core|extern "C++"}} 链接由实现定义。C++ 标准推荐在这种情况下使用 {{c/core|extern "C++"}}。

在库中定义且由 C++ 程序所需的对象和函数会在程序启动前包含到程序中。

===对标准库实现的要求===
====保证====
每个 C++ 标头必须提供在以下地方出现的{{lt|cpp/language/declarations|声明}}和{{lt|cpp/language/definition|定义}}：
* 该标头的概要中
* 在该标头的概要中所包含的所有其他标头的概要中

对于在多个标头中定义的类型或宏（例如 {{ltt|cpp/types/NULL}}），以任意顺序任意次数包含这些标头都不会违反[[cpp/language/definition#单一定义规则（ODR）|单一定义规则]]。

除非另外说明，所有由 C 标准库定义且展开为整型{{lt|cpp/language/constant expression|常量表达式}}的{{ls|cpp/preprocessor/replace#对象式宏}}，都可以用于[[cpp/preprocessor/conditional|{{tt|#if}}]] 预处理指令。

调用标准库的任意一个非成员函数签名总是导致对这个函数的实际调用。因此符合标准的标准库实现都不能另外定义可能会被合法 C++ 程序调用的非成员函数。

不能将非成员函数签名声明为具有额外的{{lt|cpp/language/default arguments|默认实参}}。

除非另外说明，标准库中的函数在调用非运算符非成员函数时不会通过[[cpp/language/adl|实参依赖查找]]使用来自其他{{lt|cpp/language/namespace|命名空间}}的函数。

对于类（模板）定义中的每个函数（模板）[[cpp/language/friend|友元声明]]，不会提供该函数（模板）的其他声明。

{{rrev|since=c++11|1=
标准库函数签名只有在需要是 {{lt|cpp/language/constexpr}} 的情况下才能声明为 {{c/core|constexpr}}（libstdc++ 的 cmath [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=102916 并不符合]这点）。如果有标头提供了 constexpr 函数（包括构造函数）的非定义的声明，那么它也需要提供对应的定义。

除非另外说明，每个标准库函数都应该满足下列各项要求以避免[[cpp/language/memory model#线程与数据竞争|数据竞争]]：
* 除了通过函数实参（包括 {{c|this}}），C++ 标准库函数不能（直接或间接地）访问能被当前线程以外的线程访问到的对象。
* 除了通过非 const 函数实参（包括 {{c|this}}），C++ 标准库函数不能（直接或间接地）修改能被当前线程以外的线程访问到的对象。
** 例如在没有进行同步处理的情况下，不能在内部使用具有静态存储期的对象，因为没有显式在线程间共享对象的程序也可能会因此产生数据竞争。
* C++ 标准库函数不能访问能通过它的实参或它的{{lt|cpp/container|容器}}实参的元素间接访问到的对象，除非通过对容器元素调用该标准库函数的文档描述中要求调用的函数。
* 对通过调用标准库容器或字符串的成员函数获得的{{lt|cpp/iterator|迭代器}}的操作可以访问底层容器，但不能修改它。
** 尤其是，会使迭代器失效的容器操作会与该容器关联的迭代器操作冲突。
* C++ 标准库执行的所有对用户[[cpp/language/memory model#内存顺序|可见]]的操作都只能在当前线程进行。
** 没有可见副作用的操作可以并行处理。
}}

对于每个 C++ 标准库所定义且要求从另一个 C++ 标准库定义的类[[cpp/language/derived class|派生]]的类：
* 该基类在指定为 {{c/core|virtual}} 时必须是[[cpp/language/derived class#虚基类|虚]]基类，
* 该基类在没有指定为 {{c/core|virtual}} 时不能是虚基类，
* 除非另外说明，名字不同的类型只能是不同的类型。

{{rrev|since=c++11|
除非另外说明，在 C++ 标准库中指定的类型都不能是指定为 {{lt|cpp/language/final}} 的类类型。
}}

如果在 C++ 标准库中定义的函数指定为需要（在特定情况下）抛出某个指定类型的[[cpp/language/exceptions|异常]]，那么抛出的异常只能具有那个类型或者从那个类型派生的类型，这样对应那个基类类型的异常处理块才能捕获该异常。

C 标准库中的函数不能抛出异常，除非该函数调用了由程序提供的函数（{{ltf|cpp/algorithm/qsort}} 和 {{ltf|cpp/algorithm/bsearch}} 满足这种情况），并且那个函数抛出了异常。

C++ 标准库中定义的析构操作绝不会抛出异常。C++ 标准库的所有析构函数都表现为如同具有[[cpp/language/noexcept spec|不抛出的异常说明]]。

{{rrev|since=c++11|
如果 C++ 标准库中的函数通过 {{lc|std::error_code}} 对象报告错误，那么该对象的 {{ltf|cpp/error/error_code/category}} 成员在错误来自操作系统时必须返回 {{lc|std::system_category()}}，或者在错误来自其他地方时必须返回到由实现定义的 {{lc|std::error_category}} 对象的引用。对于这些错误类别，需要定义每个类别中 {{ltf|cpp/error/error_code/value}} 的所有可能的值。

具有在 C++ 标准库中定义的类型的对象可以[[cpp/language/move constructor|被移动]]。移动操作可以显式指明或隐式生成。除非另外说明，这类被移动后的对象会处于合法但未指明的状态。

具有在 C++ 标准库中定义的类型的对象可以[[cpp/language/move assignment|移动赋值]]到自身。除非另外说明，这类移动赋值后的对象会处于合法但未指明的状态。
}}

====实现自由处理====
未指明 C++ 标准库中定义的成员和非成员函数是否会被定义成{{lt|cpp/language/inline|内联}}函数。

对于非{{lt|cpp/language/virtual|虚}}的 C++ 标准库成员函数，可以声明一组不同的成员函数签名，只要对该成员函数的任何调用在应当选中原函数签名组中的某个重载的情况下的行为与选中该重载本身的行为一致即可。这样就可以进行以下调整：
* 添加带有默认实参的形参，
* 将有默认实参的成员函数替换成多个行为等价的成员函数，
* 为成员函数名添加额外的签名。

除非另外说明，由实现定义 C++ 标准库的哪些函数可以递归地重新进入。

{{rrev|since=c++11|
C++ 标准库实现可以在线程间共享自己内部使用的对象，前提是这些对象对用户不可见且会受保护以避免数据竞争。
}}

未指明 C++ 标准库的哪些函数签名和类是 C++ 标准库的另一个类的友元。

[[#库的内容|这里]]描述的名字和全局函数签名为实现保留。

C++ 标准库的任何类都可以从一个具有为实现保留的名字的类派生。如果一个在 C++ 标准库定义的类要求从另一个在 C++ 标准库定义的类派生，那么该派生类既可以直接从要求的基类派生，也可以间接通过一系列具有为实现保留的名字的基类派生。

如果在 C++ 标准库中定义的函数没有指定为需要（在特定情况下）抛出异常但该函数不具有不抛出的异常说明，那么抛出的异常由实现定义，但异常类型必须是 {{lc|std::exception}} 或者从 {{lc|std::exception}} 派生的任意类型。

非虚函数的异常说明可以通过添加不抛出的异常说明来强化。

{{rrev|since=c++26|1=
===标准库硬化===
实现可以是''硬化实现''，由实现定义实现本身是否硬化。

某些标准库成员函数（和成员函数模板）带有''硬化前条件''。在调用此类函数时：
* 如果实现是硬化实现，那么在该函数的其他所有可观察副作用前以检查语义对一个或多个[[cpp/language/contracts|契约断言]]进行求值，这些契约断言的谓词会在硬化前条件中描述。如果这些断言以非终止语义求值且{{ls|cpp/language/contracts#契约违背处理函数}}返回，那么行为未定义。
* 如果实现不是硬化实现，那么违背任何硬化前条件时行为未定义。

====带有硬化前条件的成员函数====
&lt;div style="max-width: 668px; max-height: 80vh; overflow: auto;"&gt;
{{cpp/standard library/hardened functions}}
&lt;/div&gt;
}}

===注解===
{{ftm begin}}
{{ftm|__cpp_lib_modules|标准库模块 {{c|std}} 和 {{c|std.compat}}|value=202207L|std=C++23}}
|-style="text-align: center;"
!colspan=4|仅限硬化实现
{{ftm|__cpp_lib_hardened_array|硬化的 {{lc|std::array}}|value=202502L|std=C++26}}
{{ftm|__cpp_lib_hardened_basic_string|硬化的 {{lc|std::basic_string}}|value=202502L|std=C++26}}
{{ftm|__cpp_lib_hardened_basic_string_view|硬化的 {{lc|std::basic_string_view}}|value=202502L|std=C++26}}
{{ftm|__cpp_lib_hardened_bitset|硬化的 {{lc|std::bitset}}|value=202502L|std=C++26}}
{{ftm|__cpp_lib_hardened_deque|硬化的 {{lc|std::deque}}|value=202502L|std=C++26}}
{{ftm|__cpp_lib_hardened_expected|硬化的 {{ltt std|cpp/utility/expected}}|value=202502L|std=C++26}}
{{ftm|__cpp_lib_hardened_forward_list|硬化的 {{lc|std::forward_list}}|value=202502L|std=C++26}}
{{ftm|__cpp_lib_hardened_inplace_vector|硬化的 {{ltt std|cpp/container/inplace_vector}}|value=202502L|std=C++26}}
{{ftm|__cpp_lib_hardened_list|硬化的 {{lc|std::list}}|value=202502L|std=C++26}}
{{ftm|__cpp_lib_hardened_mdspan|硬化的 {{ltt std|cpp/container/mdspan}}|value=202502L|std=C++26}}
{{ftm|__cpp_lib_hardened_optional|硬化的 {{lc|std::optional}}|value=202502L|std=C++26}}
{{ftm|__cpp_lib_hardened_span|硬化的 {{ltt std|cpp/container/span}}|value=202502L|std=C++26}}
{{ftm|__cpp_lib_hardened_valarray|硬化的 {{lc|std::valarray}}|value=202502L|std=C++26}}
{{ftm|__cpp_lib_hardened_vector|硬化的 {{lc|std::vector}}|value=202502L|std=C++26}}
{{ftm end}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=1|std=C++98|before=未指明来自 C 标准库并且声明为具有外部链接的名字的语言链接|after=由实现定义}}
{{dr list item|wg=lwg|dr=119|std=C++98|before=可以强化虚函数的异常说明|after=仅限非虚函数}}
{{dr list item|wg=lwg|dr=147|std=C++98|before=关于非成员函数的说明只考虑了全局函数|after=也会考虑非全局函数}}
{{dr list item|wg=lwg|dr=225|std=C++98|before=标准库函数可能会因为实参依赖查找而调用其他命名空间的非成员函数|after=已禁止（除非另外说明）}}
{{dr list item|wg=lwg|dr=336|std=C++98|before={{header|strstream}} 不是 C++ 库标头|after=它是 C++ 库标头}}
{{dr list item|wg=lwg|dr=343|std=C++98|before=未指定库标头的依赖|after=已（在概要中）指定}}
{{dr list item|wg=lwg|dr=456|std=C++98|before=提供了 C 库设施的 C++ 标头只能在命名空间 {{c|std}} 中提供定义|after=可以在全局命名空间提供，&lt;br&gt;然后注入命名空间 {{c|std}}}}
{{dr list item|wg=lwg|dr=465|std=C++98|before=在 C++ 中是关键词或运算符的标识符可以在 C++&lt;br&gt;标准库标头中定义为宏（只有 {{header|ciso646}} 不允许）|after=所有 C++ 标准库标头中&lt;br&gt;都不能将它们定义为宏}}
{{dr list item|wg=lwg|dr=1178|std=C++98|before=C++ 标头需要包含其他提供了所需定义的标头|after=C++ 标头需要提供直接或间接地&lt;br&gt;包含在它的概要中的声明和定义}}
{{dr list item|wg=lwg|dr=2013|std=C++11|before=未指定标准库是否可以将在标准中未要求&lt;br&gt;是 constexpr 的函数声明为 {{c/core|constexpr}}|after=已禁止}}
{{dr list item|wg=lwg|dr=2225|std=C++98|before=在错误的位置包含标头时需要诊断|after=此时不需要诊断}}
{{dr list end}}

{{langlinks|ar|de|en|es|fr|it|ja|pt|ru}}