{{cpp/filesystem/title|begin{{small|(recursive_directory_iterator)}}|end{{small|(recursive_directory_iterator)}}}}
{{cpp/filesystem/recursive_directory_iterator/navbar}}
{{dcl begin}}
{{dcl header|filesystem}}
{{dcl|num=1|since=c++17|
recursive_directory_iterator begin( recursive_directory_iterator iter ) noexcept;
}}
{{dcl|num=2|since=c++17|
recursive_directory_iterator end( recursive_directory_iterator ) noexcept;
}}
{{dcl end}}
@1@ 返回未更改的 {{c|iter}}。
@2@ 返回默认构造的 {{ltt|cpp/filesystem/recursive_directory_iterator}}，其作用为尾迭代器。忽略实参。

非成员函数使得以基于范围的 for 循环使用 {{tt|recursive_directory_iterator}} 可行{{rev inl|since=c++20|并使 {{tt|recursive_directory_iterator}} 为 {{lconcept|range}} 类型}}。

===参数===
{{par begin}}
{{par | iter | {{tt|recursive_directory_iterator}}}}
{{par end}}

===返回值===
@1@ 未更改的 {{c|iter}}。
@2@ 尾迭代器（默认构造的 {{tt|recursive_directory_iterator}}）。

===示例===
{{example
|code=
#include &lt;cstdlib&gt;
#include &lt;filesystem&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
namespace fs = std::filesystem;

int main()
{
    fs::current_path(fs::temp_directory_path());
    fs::create_directories("sandbox/a/b");
    std::ofstream("sandbox/file1.txt");
    fs::create_symlink("a", "sandbox/syma");

    std::cout &lt;&lt; "使用 OS 特定的命令 'tree' 打印目录结构:\n";
    std::system("tree --noreport sandbox");

    std::cout &lt;&lt; "\n使用目录迭代器打印目录结构:\n";
    for (auto&amp; p : fs::recursive_directory_iterator("sandbox"))
        std::cout &lt;&lt; p &lt;&lt; '\n';

    fs::remove_all("sandbox");
}
|p=true
|output=
使用 OS 特定的命令 'tree' 打印目录结构:
sandbox
├── a
│   └── b
├── file1.txt
└── syma -&gt; a

使用目录迭代器打印目录结构:
"sandbox/syma"
"sandbox/file1.txt"
"sandbox/a"
"sandbox/a/b"
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3480|std=C++17|before={{tt|end}} 按引用接收参数|after=按值接收参数}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/filesystem/directory_iterator/dsc begin}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}