{{cpp/filesystem/recursive_directory_iterator/title|disable_recursion_pending}}
{{cpp/filesystem/recursive_directory_iterator/navbar}}
{{dcl begin}}
{{dcl|since=c++17|1=
void disable_recursion_pending();
}}
{{dcl end}}

禁用对当前所指代的子目录的递归，若子目录存在。

该调用修改迭代器上的递归挂起标志，使得下次调用 {{ltt|cpp/filesystem/recursive_directory_iterator/increment}} 时，迭代器将在当前目录前进，即使未造访当前指代的子目录。

可以用 {{ltt|cpp/filesystem/recursive_directory_iterator/recursion_pending|recursion_pending()}} 查询递归挂起标志的状态，此调用后它为 {{c|false}}。{{ltt|cpp/filesystem/recursive_directory_iterator/increment|自增}}后它被重置为 {{c|true}}，其初值亦为 {{c|true}}。

若 {{c|*this}} 是尾迭代器则行为未定义。

===参数===
（无）

===返回值===
（无）

{{cpp/impldef exception}}

===示例===
{{example
|code=
#include &lt;cstdlib&gt;
#include &lt;filesystem&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
namespace fs = std::filesystem;

int main()
{
    fs::current_path(fs::temp_directory_path());
    fs::create_directories("sandbox/a/b/c");
    fs::create_directories("sandbox/a/b/d/e");
    std::ofstream("sandbox/a/b/file1.txt");
    fs::create_symlink("a", "sandbox/syma");
    std::system("tree sandbox");
    for (auto i = fs::recursive_directory_iterator("sandbox");
         i != fs::recursive_directory_iterator();
         ++i)
    {
        std::cout &lt;&lt; std::string(i.depth() * 2, ' ') &lt;&lt; *i;
        if (fs::is_symlink(i-&gt;symlink_status()))
            std::cout &lt;&lt; " -&gt; " &lt;&lt; fs::read_symlink(*i);
        std::cout &lt;&lt; '\n';

        // 不下降到 "b"
        if (i-&gt;path().filename() == "b")
            i.disable_recursion_pending();
    }
    fs::remove_all("sandbox");
}
|p=true
|output=
sandbox
├── a
│   └── b
│       ├── c
│       ├── d
│       │   └── e
│       └── file1.txt
└── syma -&gt; a

"sandbox/a"
  "sandbox/a/b"
"sandbox/syma" -&gt; "a"
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/filesystem/recursive_directory_iterator/dsc recursion_pending}}
{{dsc inc|cpp/filesystem/recursive_directory_iterator/dsc increment}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}