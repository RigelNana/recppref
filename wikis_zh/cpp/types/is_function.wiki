{{cpp/types/traits/is|1=is_function
|description=
检查 {{tt|T}} 是否为函数类型。如 {{c|std::function}}、lambda、重载了 {{tt|operator()}} 的类和函数指针类型不是函数类型。如果 {{tt|T}} 为函数类型，那么提供的成员常量 {{tt|value}} 等于 {{c|true}}。否则，{{tt|value}} 等于 {{c|false}}。
|inherit_desc={{tt|T}} 为函数类型
}}

===注解===
{{tt|std::is_function}} 能以更简单的方式实现。[https://github.com/llvm-mirror/libcxx/blob/master/include/type_traits#L889 libc++]、[https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/type_traits#L489 libstdc++] 及 [https://github.com/microsoft/STL/pull/460 MS STL] 的新版本使用类似以下的实现：
{{source|
template&lt;class T&gt;
struct is_function : std::integral_constant&lt;
    bool,
    !std::is_const&lt;const T&gt;::value &amp;&amp; !std::is_reference&lt;T&gt;::value
&gt; {};
}}

下面展示的实现是为教学目的的，因为它会展现大量的函数类型种类。

===可能的实现===
{{eq fun
|1=
// 主模板
template&lt;class&gt;
struct is_function : std::false_type {};

// 对常规函数的特化
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...)&gt; : std::true_type {};

// 对变参数函数，如 std::printf 的特化
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......)&gt; : std::true_type {};

// 对拥有 cv 限定符的函数类型的特化
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) volatile&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const volatile&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) volatile&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const volatile&gt; : std::true_type {};

// 对拥有引用限定符的函数类型的特化
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) volatile &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const volatile &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) volatile &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const volatile &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) &amp;&amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const &amp;&amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) volatile &amp;&amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const volatile &amp;&amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) &amp;&amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const &amp;&amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) volatile &amp;&amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const volatile &amp;&amp;&gt; : std::true_type {};

// 对所有以上的 noexcept 版本的特化（C++17 及之后）
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) volatile noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const volatile noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) volatile noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const volatile noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) volatile &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const volatile &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) volatile &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const volatile &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) &amp;&amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const &amp;&amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) volatile &amp;&amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const volatile &amp;&amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) &amp;&amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const &amp;&amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) volatile &amp;&amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const volatile &amp;&amp; noexcept&gt; : std::true_type {};
}}

===示例===
{{example
|code=
#include &lt;functional&gt;
#include &lt;type_traits&gt;

int f();
static_assert(std::is_function_v&lt;decltype(f)&gt;);

static_assert(std::is_function_v&lt;int(int)&gt;);
static_assert(!std::is_function_v&lt;int&gt;);
static_assert(!std::is_function_v&lt;decltype([]{})&gt;);
static_assert(!std::is_function_v&lt;std::function&lt;void()&gt;&gt;);

struct O { void operator()() {} };
static_assert(std::is_function_v&lt;O()&gt;);

struct A
{
    static int foo();
    int fun() const&amp;;
};
static_assert(!std::is_function_v&lt;A&gt;);
static_assert(std::is_function_v&lt;decltype(A::foo)&gt;);
static_assert(!std::is_function_v&lt;decltype(&amp;A::fun)&gt;);

template&lt;typename&gt;
struct PM_traits {};
template&lt;class T, class U&gt;
struct PM_traits&lt;U T::*&gt; { using member_type = U; };

int main() 
{
    using T = PM_traits&lt;decltype(&amp;A::fun)&gt;::member_type; // T 为 int() const&amp;
    static_assert(std::is_function_v&lt;T&gt;);
}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_invocable}}
{{dsc inc|cpp/types/dsc is_object}}
{{dsc inc|cpp/types/dsc is_class}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}