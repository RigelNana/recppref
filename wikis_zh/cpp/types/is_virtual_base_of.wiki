{{cpp/title|is_virtual_base_of}}
{{cpp/meta/navbar}}
{{ddcl|header=type_traits|since=c++26|1=
template&lt; class Base, class Derived &gt;
struct is_virtual_base_of;
}}

{{tt|std::is_virtual_base_of}} 是一个{{named req|BinaryTypeTrait}}。

如果 {{tt|Base}} 是 {{tt|Derived}} 的[[cpp/language/derived_class#虚基类|虚基类]]（忽略 cv 限定），则所提供的成员常量 {{c|value}} 等于 {{c|true}}。否则 {{c|value}} 为 {{c|false}}。

当 {{tt|Base}} 和 {{tt|Derived}} 都是非联合体类类型（忽略 cv 限定）时，{{tt|Derived}} 应当是[[cpp/language/incomplete type|完整类型]]；否则其行为未定义。

{{cpp/types/nospec|pv}}

===辅助变量模板===
{{ddcl|since=c++26|1=
template&lt; class Base, class Derived &gt;
constexpr bool is_virtual_base_of_v = is_virtual_base_of&lt;Base, Derived&gt;::value;
}}
{{cpp/types/integral_constant/inherit|{{tt|Derived}} 派生于虚基类 {{tt|Base}}（忽略 cv 限定）}}

===注解===
即使 {{tt|A}} 是 {{tt|B}} 的私有、受保护或有歧义的基类，{{c|std::is_virtual_base_of_v&lt;A, B&gt;}} 也 {{c|true}}。

如果 {{c|std::is_virtual_base_of_v&lt;A, B&gt;}} 为 {{c|true}}，那么 {{c|std::is_base_of_v&lt;A, B&gt;}} 也为 {{c|true}}。但是反之则不总是如此，因为对虚继承的检查更加特殊。这种情况下，即便 {{tt|T}} 是非联合体类类型 {{c|std::is_virtual_base_of_v&lt;T, T&gt;}} 也为 {{c|false}}。

===示例===
{{example|code=
#include &lt;type_traits&gt;

class A {};
class B : A {};
class C : B {};
class D : virtual A {};
class E : D {};

union F {};
using I = int;

static_assert
(
    std::is_virtual_base_of_v&lt;A, A&gt; != true &amp;&amp;
    std::is_virtual_base_of_v&lt;A, B&gt; != true &amp;&amp;
    std::is_virtual_base_of_v&lt;A, D&gt; == true &amp;&amp;
    std::is_virtual_base_of_v&lt;D, E&gt; != true &amp;&amp;
    std::is_virtual_base_of_v&lt;F, F&gt; != true &amp;&amp;
    std::is_virtual_base_of_v&lt;I, I&gt; != true
);

int main() {}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_base_of}}
{{dsc inc|cpp/types/dsc is_convertible}}
{{dsc inc|cpp/concepts/dsc derived_from}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}