{{cpp/title|is_assignable|is_trivially_assignable|is_nothrow_assignable}}
{{cpp/meta/navbar}}
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++11|num=1|1=
template&lt; class T, class U &gt;
struct is_assignable;
}}
{{dcl|since=c++11|num=2|1=
template&lt; class T, class U &gt;
struct is_trivially_assignable;
}}
{{dcl|since=c++11|num=3|1=
template&lt; class T, class U &gt;
struct is_nothrow_assignable;
}}
{{dcl end}}

@1@ 如果表达式 {{c|1=std::declval&lt;T&gt;() = std::declval&lt;U&gt;()}} 在不求值语境中良构，则提供的成员常量 {{c|value}} 等于 {{c|true}}。否则，{{c|value}} 等于 {{c|false}}。如同从不关联到任一方的语境进行[[cpp/language/access|访问检查]]。 
@2@ 同 {{v|1}}，但赋值表达式的求值将不调用任何非平凡的操作。为此检查的目的，对 {{lc|std::declval}} 的调用被认为是平凡，且不是 {{lc|std::declval}} 的 [[cpp/language/definition#ODR 式使用|ODR 式使用]]。
@3@ 同 {{v|1}}，但赋值表达式的求值将不调用任何不是 noexcept 的操作。

{{cpp/types/cvaub|type2=U}}

{{cpp/types/nospec|any}}

=== 辅助变量模板 ===
{{dcl begin}}

{{dcl|since=c++17|1=
template&lt; class T, class U &gt;
constexpr bool is_assignable_v = is_assignable&lt;T, U&gt;::value;
}}

{{dcl|since=c++17|1=
template&lt; class T, class U &gt;
constexpr bool is_trivially_assignable_v = is_trivially_assignable&lt;T, U&gt;::value;
}}

{{dcl|since=c++17|1=
template&lt; class T, class U &gt;
constexpr bool is_nothrow_assignable_v = is_nothrow_assignable&lt;T, U&gt;::value;
}}
{{dcl end}}
{{cpp/types/integral_constant/inherit|{{tt|T}} 可从 {{tt|U}} 赋值}}

===注解===
此特征不检查赋值表达式的立即语境之外的任何事物：如果 {{tt|T}} 或 {{tt|U}} 的使用会触发模板特化，以及生成隐式定义的成员函数等等，而它们带有错误，则实际赋值可能无法编译，即使 {{c/core|std::is_assignable&lt;T,U&gt;::value}} 通过编译并求值为 {{c|true}} 也是如此。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;

struct Ex1 { int n; };

int main()
{
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; "int 可以从 int 赋值? "
              &lt;&lt; std::is_assignable&lt;int, int&gt;::value &lt;&lt; '\n' // 1 = 1; 无法编译
              &lt;&lt; "int&amp; 可以从 int 赋值? "
              &lt;&lt; std::is_assignable&lt;int&amp;, int&gt;::value &lt;&lt; '\n' // int a; a = 1; 有效
              &lt;&lt; "int 可以从 double 赋值? "
              &lt;&lt; std::is_assignable&lt;int, double&gt;::value &lt;&lt; '\n'
              &lt;&lt; "int&amp; 可以从 double 无抛出赋值? "
              &lt;&lt; std::is_nothrow_assignable&lt;int&amp;, double&gt;::value &lt;&lt; '\n'
              &lt;&lt; "string 可以从 double 赋值? "
              &lt;&lt; std::is_assignable&lt;std::string, double&gt;::value &lt;&lt; '\n'
              &lt;&lt; "Ex1&amp; 可以从 const Ex1&amp; 平凡赋值? "
              &lt;&lt; std::is_trivially_assignable&lt;Ex1&amp;, const Ex1&amp;&gt;::value &lt;&lt; '\n';
}
|output=
int 可以从 int 赋值? false
int&amp; 可以从 int 赋值? true
int 可以从 double 赋值? false
int&amp; 可以从 double 无抛出赋值? true
string 可以从 double 赋值? true
Ex1&amp; 可以从 const Ex1&amp; 平凡赋值? true
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_copy_assignable}}
{{dsc inc|cpp/types/dsc is_move_assignable}}
{{dsc inc|cpp/concepts/dsc assignable_from}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}