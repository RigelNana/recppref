{{cpp/title|is_pointer_interconvertible_with_class}}
{{cpp/meta/navbar}}
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++20|
template&lt; class S, class M &gt;
constexpr bool is_pointer_interconvertible_with_class( M S::* mp ) noexcept;
}}
{{dcl end}}

给定 {{tt|S}} 类型的对象 {{tt|s}}，确定 {{c|s.*mp}} 是否指代 {{tt|s}} 的子对象且 {{tt|s}} 与其子对象 {{c|s.*mp}} [[cpp/language/static_cast#指针可互转换|指针可互转换]]。若 {{tt|S}} 不是[[cpp/language/type#不完整类型|完整类型]]则程序非良构。

若 {{tt|S}} 不是{{named req|StandardLayoutType}}，或 {{tt|M}} 不是对象类型，或 {{tt|mp}} 等于 {{c|nullptr}}，则结果始终为 {{c|false}}。

===参数===
{{par begin}}
{{par|mp|要检测的成员指针}}
{{par end}}

===返回值===
若 {{c|s.*mp}} 指代 {{tt|s}} 的子对象且 {{tt|s}} 与其子对象 {{c|s.*mp}} 指针可互转换则为 {{c|true}}，否则为 {{c|false}}，其中 {{tt|s}} 是 {{tt|S}} 类型的对象。

===注解===
成员指针表达式 {{c|&amp;S::m}} 的类型并非始终是 {{c|M S::*}}，其中 {{tt|m}} 的类型为 {{tt|M}}，因为 {{tt|m}} 可能是从 {{tt|S}} 的基类继承的成员。可以指定第一模板实参以避免潜在地令人诧异的结果。

若存在 {{c|M S::*}} 类型的值 {{tt|mp}} 使得 {{c|1=std::is_pointer_interconvertible_with_class(mp) == true}}，则 {{c|reinterpret_cast&lt;M&amp;&gt;(s)}} 拥有良定义结果且与 {{c|s.*mp}} 指代同一子对象，其中 {{tt|s}} 是合法的 {{tt|S}} 类型的左值。

在常用平台上，若 {{c|1=std::is_pointer_interconvertible_with_class(mp) == true}}，则 {{tt|mp}} 的位模式为全零。

{{feature test macro|__cpp_lib_is_pointer_interconvertible|value=201907L|std=C++20|指针可互换性特征：
* {{lc|std::is_pointer_interconvertible_base_of}}
* {{tt|std::is_pointer_interconvertible_with_class}}}}

===示例===
{{example
|code=
#include &lt;type_traits&gt;

struct Foo { int x; };
struct Bar { int y; };

struct Baz : Foo, Bar {}; // 非标准布局

static_assert( not std::is_same_v&lt;decltype(&amp;Baz::x), int Baz::*&gt; );
static_assert( std::is_pointer_interconvertible_with_class(&amp;Baz::x) );
static_assert( not std::is_pointer_interconvertible_with_class&lt;Baz, int&gt;(&amp;Baz::x) );

int main() { }
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_standard_layout}}
{{dsc inc|cpp/types/dsc is_member_object_pointer}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}