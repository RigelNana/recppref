{{cpp/title|is_swappable_with|is_swappable|is_nothrow_swappable_with|is_nothrow_swappable}}
{{cpp/meta/navbar}}
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++17|num=1|1=
template&lt; class T, class U &gt;
struct is_swappable_with;
}}
{{dcl|since=c++17|num=2|1=
template&lt; class T &gt;
struct is_swappable;
}}
{{dcl|since=c++17|num=3|1=
template&lt; class T, class U &gt;
struct is_nothrow_swappable_with;
}}
{{dcl|since=c++17|num=4|1=
template&lt; class T &gt;
struct is_nothrow_swappable;
}}
{{dcl end}}

@1@ 如果表达式 {{c|swap(std::declval&lt;T&gt;(), std::declval&lt;U&gt;())}} 及
{{c|swap(std::declval&lt;U&gt;(), std::declval&lt;T&gt;())}} 在使用 {{c|using std::swap;}}（见 {{named req|Swappable}}）后的不求值语境中均为良构，那么提供的成员常量 {{tt|value}} 等于 {{c|true}}。否则，{{tt|value}} 等于 {{c|false}}。
@@ 如同从与 {{tt|T}} 和 {{tt|U}} 都无关的语境进行[[cpp/language/access|访问检查]]。 

@3@ 同 {{v|1}}，但已知来自 {{v|1}} 的两个表达式求值都不抛异常。

{|class="wikitable" style="text-align: center;"
!rowspan=2|{{nbsp}}类型特征{{nbsp}}
!colspan=2|成员常量 {{tt|value}} 的值
|-
!{{tt|T}} 是[[cpp/meta#定义|可引用类型]]
!{{nbsp}}{{tt|T}} 不是可引用类型{{nbsp}}
|-
|{{v|2}}
|style="text-align: left;"|{{c|std::is_swappable_with&lt;T&amp;, T&amp;&gt;::value}}
|rowspan=2|{{c|false}}
|-
|{{v|4}}
|{{c|std::is_nothrow_swappable_with&lt;T&amp;, T&amp;&gt;::value}}
|}

{{cpp/types/cvaub|type2=U}}

{{cpp/types/nospec|any}}

===辅助变量模板===
{{dcl begin}}
{{dcl|since=c++17|1=
template&lt; class T, class U &gt; 
inline constexpr bool is_swappable_with_v = is_swappable_with&lt;T, U&gt;::value;
}}
{{dcl|since=c++17|1=
template&lt; class T &gt; 
inline constexpr bool is_swappable_v = is_swappable&lt;T&gt;::value;
}}
{{dcl|since=c++17|1=
template&lt; class T, class U &gt;
inline constexpr bool is_nothrow_swappable_with_v =
    is_nothrow_swappable_with&lt;T, U&gt;::value;
}}
{{dcl|since=c++17|1=
template&lt; class T &gt;
inline constexpr bool is_nothrow_swappable_v =
    is_nothrow_swappable&lt;T&gt;::value;
}}
{{dcl end}}

{{cpp/types/integral_constant/inherit|{{tt|T}} 可与 {{tt|U}} 交换}}

===注解===
此特征不检查 {{tt|swap}} 表达式的立即语境外的内容：如果 {{tt|T}} 或 {{tt|U}} 的使用会触发模板特化，生成隐式定义的特定成员函数等，而它们有错误，那么即使 {{c|std::is_swappable_with&lt;T, U&gt;::value}} 通过编译且求值为 {{c|true}}，实际的 {{tt|swap}} 也可能无法编译。

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc swap}}
{{dsc inc|cpp/types/dsc is_move_assignable}}
{{dsc inc|cpp/concepts/dsc swappable}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}