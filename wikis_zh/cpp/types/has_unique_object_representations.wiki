{{cpp/types/traits/is|1=has_unique_object_representations
|std=c++17
|description=如果 {{tt|T}} [[cpp/language/type#可平凡复制类型|可平凡复制]]，并且如果任意两个拥有相同值的 {{tt|T}} 类型对象都拥有相同的[[cpp/language/object|对象表示]]，那么提供的成员常量 {{tt|value}} 等于 {{c|true}}。对于其它类型，{{tt|value}} 等于 {{c|false}}。

使用此特征时，如果两个数组的各元素都拥有相同值，那么它们就拥有相同值，如果两个非联合体类的各直接子对象都拥有相同值，那么它们就拥有相同值，而如果两个联合体拥有相同的活跃成员，且该成员值相同，那么它们拥有相同值。

标量类型是否满足此特性是实现定义的，但保证不使用填充位的{{rev inl|until=c++20|无符号}}整数类型拥有唯一对象表示。

如果 {{c/core|std::remove_all_extents_t&lt;T&gt;}} 是除了（可有 cv 限定的）{{c/core|void}} 以外的不完整类型，那么行为未定义。
|inherit_desc={{tt|T}} 拥有唯一对象表示
}}

===注解===
引入此特征是为了能够确定是否能通过把一个类型的对象表示作为字节数组进行散列，正确地散列该类型。

{{feature test macro|__cpp_lib_has_unique_object_representations|value=201606L|std=C++17|{{tt|std::has_unique_object_representations}}}}

===示例===
{{example
|
|code=
#include &lt;cstdint&gt;
#include &lt;type_traits&gt;

struct unpadded
{
    std::uint32_t a, b;
};

struct likely_padded
{
    std::uint8_t c;
    std::uint16_t st;
    std::uint32_t i;
};

int main()
{
    // char 的每个值都严格对应于一个对象表示。
    static_assert(std::has_unique_object_representations_v&lt;char&gt;);
    // 此断言对于 IEC 559 float 成立，因为值 NaN 由多个对象表示。
    static_assert(!std::has_unique_object_representations_v&lt;float&gt;);
    
    // 任何正常实现中都应当成立，因为 unpadded 通常不会被填充，且 std::uint32_t 不包含填充位。
    static_assert(std::has_unique_object_representations_v&lt;unpadded&gt;);
    // 大多数实现中都会失败，因为为了把 st 对齐到 16 位，会在数据成员 c 和 st 之间插入填充位。
    static_assert(!std::has_unique_object_representations_v&lt;likely_padded&gt;);
    
    // 注意架构分歧：
    static_assert(std::has_unique_object_representations_v&lt;bool&gt;);  // x86
 // static_assert(!std::has_unique_object_representations_v&lt;bool&gt;); // ARM
}
|p=true
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=4113|std=C++17|before={{tt|T}} 可以是元素类型不完整的未知边界数组类型|after=要求元素类型完整}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_standard_layout}}
{{dsc inc|cpp/utility/dsc hash}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}