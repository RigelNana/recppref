{{cpp/title|is_move_assignable|is_trivially_move_assignable|is_nothrow_move_assignable}}
{{cpp/meta/navbar}}
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++11|num=1|
template&lt; class T &gt;
struct is_move_assignable;
}}
{{dcl|since=c++11|num=2|
template&lt; class T &gt;
struct is_trivially_move_assignable;
}}
{{dcl|since=c++11|num=3|
template&lt; class T &gt;
struct is_nothrow_move_assignable;
}}
{{dcl end}}

{|class="wikitable" style="text-align: center;"
!rowspan=2|{{nbsp}}类型特征{{nbsp}}
!colspan=2|成员常量 {{ttn|value}} 的值
|-
!{{ttn|T}} 是[[cpp/meta#定义|可引用类型]]
!{{nbsp}}{{ttn|T}} 不是可引用类型{{nbsp}}
|-
|{{v|1}}
|{{c|std::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value}}
|rowspan=3|{{c|false}}
|-
|{{v|2}}
|{{c|std::is_trivially_assignable&lt;T&amp;, T&amp;&amp;&gt;::value}}
|-
|{{v|3}}
|{{c|std::is_nothrow_assignable&lt;T&amp;, T&amp;&amp;&gt;::value}}
|}

{{cpp/types/cvaub}}

{{cpp/types/nospec|any}}

===辅助变量模板===
{{dcl begin}}
{{dcl|since=c++17|1=
template&lt; class T &gt;
inline constexpr bool is_move_assignable_v =
    is_move_assignable&lt;T&gt;::value;
}}
{{dcl|since=c++17|1=
template&lt; class T &gt;
inline constexpr bool is_trivially_move_assignable_v =
    is_trivially_move_assignable&lt;T&gt;::value;
}}
{{dcl|since=c++17|1=
template&lt; class T &gt;
inline constexpr bool is_nothrow_move_assignable_v =
    is_nothrow_move_assignable&lt;T&gt;::value;
}}
{{dcl end}}

{{cpp/types/integral_constant/inherit| {{tt|T}} 可移动赋值}}

===可能的实现===
{{eq fun
|1=
template&lt;class T&gt;
struct is_move_assignable
    : std::is_assignable&lt;typename std::add_lvalue_reference&lt;T&gt;::type,
                         typename std::add_rvalue_reference&lt;T&gt;::type&gt; {};

template&lt;class T&gt;
struct is_trivially_move_assignable
    : std::is_trivially_assignable&lt;typename std::add_lvalue_reference&lt;T&gt;::type,
                                   typename std::add_rvalue_reference&lt;T&gt;::type&gt; {};

template&lt;class T&gt;
struct is_nothrow_move_assignable
    : std::is_nothrow_assignable&lt;typename std::add_lvalue_reference&lt;T&gt;::type,
                                 typename std::add_rvalue_reference&lt;T&gt;::type&gt; {};
}}

===注解===
特征 {{tt|std::is_move_assignable}} 不如{{named req|MoveAssignable}}严格，因为它既不检查赋值的结果类型（对于{{named req|MoveAssignable}}类型必须是 {{tt|T&amp;}}），也不检查赋值后目标的值等于赋值前源的值的语义要求。

为满足此特征，类型不必实现[[cpp/language/move assignment|移动赋值运算符]]，细节见{{named req|MoveAssignable}}。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;

struct Foo { int n; };

struct NoMove
{
    // 避免默认的移动赋值运算符的隐式定义
    // 然而，该类仍然可移动赋值，因为
    // 其复制赋值运算符能绑定到右值实参
    NoMove&amp; operator=(const NoMove&amp;) { return *this; }
};

int main()
{
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; "std::string 是否可不抛出移动赋值？"
              &lt;&lt; std::is_nothrow_move_assignable&lt;std::string&gt;::value &lt;&lt; '\n'
              &lt;&lt; "int[2] 是否可移动赋值？"
              &lt;&lt; std::is_move_assignable&lt;int[2]&gt;::value &lt;&lt; '\n'
              &lt;&lt; "Foo 是否可平凡移动赋值？"
              &lt;&lt; std::is_trivially_move_assignable&lt;Foo&gt;::value &lt;&lt; '\n'
              &lt;&lt; "NoMove 是否可移动赋值？"
              &lt;&lt; std::is_move_assignable&lt;NoMove&gt;::value &lt;&lt; '\n'
              &lt;&lt; "NoMove 是否可不抛出移动赋值？"
              &lt;&lt; std::is_nothrow_move_assignable&lt;NoMove&gt;::value &lt;&lt; '\n';
}
|output=
std::string 是否可不抛出移动赋值？true
int[2] 是否可移动赋值？false
Foo 是否可平凡移动赋值？true
NoMove 是否可移动赋值？true
NoMove 是否可不抛出移动赋值？false
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2196|std=C++11|before=无法组成 {{c/core|T&amp;&amp;}} 时的行为不明确|after=此时产生的值是 {{c|false}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_assignable}}
{{dsc inc|cpp/types/dsc is_copy_assignable}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}