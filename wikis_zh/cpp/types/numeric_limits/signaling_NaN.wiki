{{cpp/types/numeric_limits/title|signaling_NaN}}
{{cpp/types/numeric_limits/navbar}}
{{dcl begin}}
{{dcl rev multi|until1=c++11
|dcl1=
static T signaling_NaN() throw();
|dcl2=
static constexpr T signaling_NaN() noexcept;
}}
{{dcl end}}

返回特殊值“发信的[[enwiki:NaN|非数]]”，以浮点类型 {{tt|T}} 表示。只有在 {{c|1=std::numeric_limits&lt;T&gt;::has_signaling_NaN == true}} 时才有意义。在最常见的浮点数二进制表示 IEEE 754 中，任何所有指数位都是 1 且至少有一位尾数位是 1 的值都表示 NaN。哪些尾数值表示安静或发信的 NaN，及符号位是否有意义都由实现定义。

===返回值===
{{dsc begin}}
{{dsc hitem | {{tt|T}} | {{c|std::numeric_limits&lt;T&gt;::signaling_NaN()}} }}
{{dsc | {{c/core|/* 未特化 */}}   | {{c|T()}} }}
{{dsc | {{c/core|bool}}              | {{c|false}} }}
{{dsc | {{c/core|char}}              | {{c|0}} }}
{{dsc | {{c/core|signed char}}       | {{c|0}} }}
{{dsc | {{c/core|unsigned char}}     | {{c|0}} }}
{{dsc | {{c/core|wchar_t}}           | {{c|0}} }}
{{dsc | {{c/core|char8_t}} {{mark since c++20}}  | {{c|0}} }}
{{dsc | {{c/core|char16_t}} {{mark since c++11}} | {{c|0}} }}
{{dsc | {{c/core|char32_t}} {{mark since c++11}} | {{c|0}} }}
{{dsc | {{c/core|short}}             | {{c|0}} }}
{{dsc | {{c/core|unsigned short}}    | {{c|0}} }}
{{dsc | {{c/core|int}}               | {{c|0}} }}
{{dsc | {{c/core|unsigned int}}      | {{c|0}} }}
{{dsc | {{c/core|long}}              | {{c|0}} }}
{{dsc | {{c/core|unsigned long}}     | {{c|0}} }}
{{dsc | {{c/core|long long}} {{mark since c++11}}          | {{c|0}} }}
{{dsc | {{c/core|unsigned long long}} {{mark since c++11}} | {{c|0}} }}
{{dsc | {{c/core|float}}             | 由实现定义（可以是 {{lc|FLT_SNAN}}&lt;!-- C23 特性 --&gt;）}}
{{dsc | {{c/core|double}}            | 由实现定义（可以是 {{lc|DBL_SNAN}}&lt;!-- C23 特性 --&gt;）}}
{{dsc | {{c/core|long double}}       | 由实现定义（可以是 {{lc|LDBL_SNAN}}&lt;!-- C23 特性 --&gt;）}}
{{dsc end}}

===注解===
NaN 与自身永远不会比较相等。IEEE-754 不要求复制 NaN 保留它的位表示（正负号与[[cpp/numeric/math/nan|载荷]]），尽管大多数实现都会保留。

当发信 NaN 被用于算术表达式的实参时，可能引发适当的浮点异常，而且 NaN 被“安静化”，即表达式返回安静的 NaN。

===示例===
{{example
|演示用发信 NaN 引发浮点异常：
|code=
#include &lt;cfenv&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;

#pragma STDC_FENV_ACCESS on

void show_fe_exceptions()
{
    int n = std::fetestexcept(FE_ALL_EXCEPT);
    
    if (n &amp; FE_INVALID)
        std::cout &lt;&lt; "引发了 FE_INVALID\n";
    else if (n == 0)
        std::cout &lt;&lt; "没有引发异常\n";
    
    std::feclearexcept(FE_ALL_EXCEPT);
}

int main()
{
    double snan = std::numeric_limits&lt;double&gt;::signaling_NaN();
    std::cout &lt;&lt; "在获取 sNaN 后，";
    show_fe_exceptions();
    
    double qnan = snan * 2.0;
    std::cout &lt;&lt; "在将 sNaN 乘以 2 后，";
    show_fe_exceptions();
    
    double qnan2 = qnan * 2.0;
    std::cout &lt;&lt; "在将安静 NaN 乘以 2 后，";
    show_fe_exceptions();
    
    std::cout &lt;&lt; "结果是 " &lt;&lt; qnan2 &lt;&lt; '\n';
}
|output=
在获取 sNaN 后，没有引发异常
在将 sNaN 乘以 2 后，引发了 FE_INVALID
在将安静 NaN 乘以 2 后，没有引发异常
结果是 nan
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/numeric_limits/dsc has_signaling_NaN}}
{{dsc inc|cpp/types/numeric_limits/dsc quiet_NaN}}
{{dsc inc|cpp/numeric/math/dsc isnan}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}