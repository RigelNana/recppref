{{cpp/types/numeric_limits/title|epsilon}}
{{cpp/types/numeric_limits/navbar}}
{{dcl begin}}
{{dcl rev multi|until1=c++11
|dcl1=
static T epsilon() throw();
|dcl2=
static constexpr T epsilon() noexcept;
}}
{{dcl end}}

返回机器 ε (epsilon)，即 {{c|1.0}} 与浮点数类型 {{tt|T}} 的下个可表示值的差。它只有在 {{c|1=std::numeric_limits&lt;T&gt;::is_integer == false}} 时才有意义。

===返回值===
{{dsc begin}}
{{dsc hitem | {{tt|T}} | {{c|std::numeric_limits&lt;T&gt;::epsilon()}} }}
{{dsc | {{c/core|/* 未特化 */}}   | {{c|T()}} }}
{{dsc | {{c/core|bool}}              | {{c|false}} }}
{{dsc | {{c/core|char}}              | {{c|0}} }}
{{dsc | {{c/core|signed char}}       | {{c|0}} }}
{{dsc | {{c/core|unsigned char}}     | {{c|0}} }}
{{dsc | {{c/core|wchar_t}}           | {{c|0}} }}
{{dsc | {{c/core|char8_t}} {{mark since c++20}}  | {{c|0}} }}
{{dsc | {{c/core|char16_t}} {{mark since c++11}} | {{c|0}} }}
{{dsc | {{c/core|char32_t}} {{mark since c++11}} | {{c|0}} }}
{{dsc | {{c/core|short}}             | {{c|0}} }}
{{dsc | {{c/core|unsigned short}}    | {{c|0}} }}
{{dsc | {{c/core|int}}               | {{c|0}} }}
{{dsc | {{c/core|unsigned int}}      | {{c|0}} }}
{{dsc | {{c/core|long}}              | {{c|0}} }}
{{dsc | {{c/core|unsigned long}}     | {{c|0}} }}
{{dsc | {{c/core|long long}} {{mark since c++11}}         | {{c|0}} }}
{{dsc | {{c/core|unsigned long long}}{{mark since c++11}} | {{c|0}} }}
{{dsc | {{c/core|float}}             | {{lc|FLT_EPSILON}} }}
{{dsc | {{c/core|double}}            | {{lc|DBL_EPSILON}} }}
{{dsc | {{c/core|long double}}       | {{lc|LDBL_EPSILON}} }}
{{dsc end}}

===示例===
{{example
|演示用机器 epsilon 比较浮点数是否相等：
|code=
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstddef&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;type_traits&gt;

template &lt;class T&gt;
std::enable_if_t&lt;not std::numeric_limits&lt;T&gt;::is_integer, bool&gt;
equal_within_ulps(T x, T y, std::size_t n)
{
    // 因为 `epsilon()` 是浮点数在区间 [1, 2) 中的间隙大小（ULP，末位单位），
    // 所以我们可以将其放大到区间 [2^e, 2^{e+1}) 中的间隙大小，
    // 其中 `e` 为 `x` 和 `y` 的幂指数。

    // 如果 `x` 和 `y` 的间隙大小不同（即它们有不同指数），就取较小值。
    // 我估计取较大值也可以。
    const T m = std::min(std::fabs(x), std::fabs(y));

    // 非正规数值有固定的指数，即 `min_exponent - 1`。
    const int exp = m &lt; std::numeric_limits&lt;T&gt;::min()
                  ? std::numeric_limits&lt;T&gt;::min_exponent - 1
                  : std::ilogb(m);

    // 如果 `x` 和 `y` 之间的差处于 `n` 个 ULP 之内，则认为它们相等。
    return std::fabs(x - y) &lt;= n * std::ldexp(std::numeric_limits&lt;T&gt;::epsilon(), exp);
}

int main()
{
    double x = 0.3;
    double y = 0.1 + 0.2;
    std::cout &lt;&lt; std::hexfloat;
    std::cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; '\n';
    std::cout &lt;&lt; "y = " &lt;&lt; y &lt;&lt; '\n';
    std::cout &lt;&lt; (x == y ? "x == y" : "x != y") &lt;&lt; '\n';
    for (std::size_t n = 0; n &lt;= 10; ++n)
        if (equal_within_ulps(x, y, n))
        {
            std::cout &lt;&lt; "x 等于 y (" &lt;&lt; n &lt;&lt; " 个 ulp 以内)" &lt;&lt; '\n';
            break;
        }
}
|output=
x = 0x1.3333333333333p-2
y = 0x1.3333333333334p-2
x != y
x 等于 y (1 个 ulp 以内)
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc nextafter}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}