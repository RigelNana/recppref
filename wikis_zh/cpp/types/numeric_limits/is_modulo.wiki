{{cpp/types/numeric_limits/title|is_modulo}}
{{cpp/types/numeric_limits/navbar}}
{{dcl begin}}
{{dcl rev multi|until1=c++11
|dcl1=
static const bool is_modulo;
|dcl2=
static constexpr bool is_modulo;
}}
{{dcl end}}

{{c|std::numeric_limits&lt;T&gt;::is_modulo}} 对所有以模算术处理溢出的算术类型 {{tt|T}} 都是 {{c|true}}。模算术即在此类型的加法、减法、乘法或除法结果会落在范围 {{tt|[}}{{lc|min()}}{{tt|,&amp;nbsp;}}{{lc|max()}}{{tt|]}} 外时，这种运算返回的结果会与期望值相差 {{c|max() - min() + 1}} 的整数倍。

{{tt|is_modulo}} 对有符号整数类型是 {{c|false}}，除非实现定义有符号整数溢出进行回绕。

===标准特化===
{{dsc begin}}
{{dsc hitem | {{tt|T}} | {{c|std::numeric_limits&lt;T&gt;::is_modulo}} 的值}}
{{dsc | {{c/core|/* 未特化 */}} | {{c|false}} }}
{{dsc | {{c/core|bool}}              | {{c|false}} }}
{{dsc | {{c/core|char}}              | 由实现定义 }}
{{dsc | {{c/core|signed char}}       | 由实现定义 }}
{{dsc | {{c/core|unsigned char}}     | {{c|true}} }}
{{dsc | {{c/core|wchar_t}}           | 由实现定义 }}
{{dsc | {{c/core|char8_t}} {{mark since c++20}}  | {{c|true}} }}
{{dsc | {{c/core|char16_t}} {{mark since c++11}} | {{c|true}} }}
{{dsc | {{c/core|char32_t}} {{mark since c++11}} | {{c|true}} }}
{{dsc | {{c/core|short}}             | 由实现定义 }}
{{dsc | {{c/core|unsigned short}}    | {{c|true}} }}
{{dsc | {{c/core|int}}               | 由实现定义 }}
{{dsc | {{c/core|unsigned int}}      | {{c|true}} }}
{{dsc | {{c/core|long}}              | 由实现定义 }}
{{dsc | {{c/core|unsigned long}}     | {{c|true}} }}
{{dsc | {{c/core|long long}} {{mark since c++11}}          | 由实现定义 }}
{{dsc | {{c/core|unsigned long long}} {{mark since c++11}} | {{c|true}} }}
{{dsc | {{c/core|float}}             | {{c|false}} }}
{{dsc | {{c/core|double}}            | {{c|false}} }}
{{dsc | {{c/core|long double}}       | {{c|false}} }}
{{dsc end}}

===注解===
C++ 标准在修复 {{lwg|2422}} 前记述“在大多数机器上，这对于有符号整数是 {{tt|true}}”。相关讨论参考 [http://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200 GCC PR 22200]。

===示例===
{{example
|演示模运算类型的行为
|code=
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;limits&gt;

template&lt;class T&gt;
typename std::enable_if&lt;std::numeric_limits&lt;T&gt;::is_modulo&gt;::type
    check_overflow()
{
    std::cout &lt;&lt; "最大值是 " &lt;&lt; std::numeric_limits&lt;T&gt;::max() &lt;&lt; '\n'
              &lt;&lt; "最小值是 " &lt;&lt; std::numeric_limits&lt;T&gt;::min() &lt;&lt; '\n'
              &lt;&lt; "最大值 + 1 是 " &lt;&lt; std::numeric_limits&lt;T&gt;::max()+1 &lt;&lt; '\n';
}

int main()
{
    check_overflow&lt;int&gt;();
    std::cout &lt;&lt; '\n';
    check_overflow&lt;unsigned long&gt;();
//  check_overflow&lt;float&gt;(); // 编译时错误，非模类型
}
|p=true
|output=
最大值是 2147483647
最小值是 -2147483648
最大值 + 1 是 -2147483648

最大值是 18446744073709551615
最小值是 0
最大值 + 1 是 0
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=612|std=C++98|before=“以模算术处理溢出”的定义很糟糕&lt;ref&gt;定义是“将两个正数相加的结果可以是回绕到的第三个更小的数”。这个定义有以下几个问题：
* 它没有定义回绕后的值。
* 它没有给出回绕是否会复现。
* 它没有定义对所有值的加、减和其他操作的行为
&lt;/ref&gt;|after=提供更好的定义}}
{{dr list item|wg=lwg|dr=2422|std=c++11|before=曾在大多数机器上要求 {{tt|is_modulo}}&lt;br&gt;对有符号整数类型是 {{c|true}}|after=对有符号整数类型要求是 {{c|false}}，&lt;br&gt;除非定义有符号整数溢出为回绕}}
{{dr list end}}
&lt;references/&gt;

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/numeric_limits/dsc is_integer}}
{{dsc inc|cpp/types/numeric_limits/dsc is_iec559}}
{{dsc inc|cpp/types/numeric_limits/dsc is_exact}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}