{{cpp/types/numeric_limits/title|tinyness_before}}
{{cpp/types/numeric_limits/navbar}}
{{dcl begin}}
{{dcl rev multi|until1=c++11
|dcl1=
static const bool tinyness_before;
|dcl2=
static constexpr bool tinyness_before;
}}
{{dcl end}}

{{c|std::numeric_limits&lt;T&gt;::tinyness_before}} 的值对所有在舍入前检测浮点数表达式是否下溢的浮点数类型 {{tt|T}} 都是 {{c|true}}。

===标准特化===
{{dsc begin}}
{{dsc hitem | {{tt|T}} |{{c|std::numeric_limits&lt;T&gt;::tinyness_before}} 的值}}
{{dsc | {{c/core|/* 未特化 */}}   | {{c|false}} }}
{{dsc | {{c/core|bool}}              | {{c|false}} }}
{{dsc | {{c/core|char}}              | {{c|false}} }}
{{dsc | {{c/core|signed char}}       | {{c|false}} }}
{{dsc | {{c/core|unsigned char}}     | {{c|false}} }}
{{dsc | {{c/core|wchar_t}}           | {{c|false}} }}
{{dsc | {{c/core|char8_t}} {{mark since c++20}}  | {{c|false}} }}
{{dsc | {{c/core|char16_t}} {{mark since c++11}} | {{c|false}} }}
{{dsc | {{c/core|char32_t}} {{mark since c++11}} | {{c|false}} }}
{{dsc | {{c/core|short}}             | {{c|false}} }}
{{dsc | {{c/core|unsigned short}}    | {{c|false}} }}
{{dsc | {{c/core|int}}               | {{c|false}} }}
{{dsc | {{c/core|unsigned int}}      | {{c|false}} }}
{{dsc | {{c/core|long}}              | {{c|false}} }}
{{dsc | {{c/core|unsigned long}}     | {{c|false}} }}
{{dsc | {{c/core|long long}} {{mark since c++11}}          | {{c|false}} }}
{{dsc | {{c/core|unsigned long long}} {{mark since c++11}} | {{c|false}} }}
{{dsc | {{c/core|float}}             | 由实现定义 }}
{{dsc | {{c/core|double}}            | 由实现定义 }}
{{dsc | {{c/core|long double}}       | 由实现定义 }}
{{dsc end}}

===注解===
符合标准的 IEEE 754 浮点数实现要求检测浮点数下溢，并在执行处有两种可选的情形：
# 如果在假定以指数范围和精度均为无界的计算的情况下产生绝对值小于 {{c|std::numeric_limits&lt;T&gt;::min()}} 的结果，那么发生下溢（并且可能引发 {{lc|FE_UNDERFLOW}}）。这种实现在舍入前检测是否较小（如 UltraSparc、POWER）。
# 如果舍入到目标浮点数类型（即舍入到 {{c|std::numeric_limits&lt;T&gt;::digits}} 位）后，结果的绝对值小于 {{c|std::numeric_limits&lt;T&gt;::min()}}，那么发生下溢（并且可能引发 {{lc|FE_UNDERFLOW}}）。正式地说，假定以指数范围和精度均为无界的计算的非零结果的绝对值小于 {{c|std::numeric_limits&lt;T&gt;::min()}}。这种实现在舍入后检测是否较小（如 SuperSparc）。

===示例===
{{example
|最大非正规数乘 1.0 加上一个机器 epsilon 在舍入前给出小值 0x0.fffffffffffff8p-1022，而非舍入后的正规值 1p-1022。用于执行此测试的实现（{{enwiki|IBM Power microprocessors#POWER7|IBM Power7}}）检测舍入前是否较小。
|code=
#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;cmath&gt;
#include &lt;cfenv&gt;

int main()
{
    std::cout &lt;&lt; "舍入前是否检测下溢：" &lt;&lt; std::boolalpha
              &lt;&lt; std::numeric_limits&lt;double&gt;::tinyness_before &lt;&lt; '\n';

    double denorm_max = std::nextafter(std::numeric_limits&lt;double&gt;::min(), 0);
    double multiplier = 1 + std::numeric_limits&lt;double&gt;::epsilon();

    std::feclearexcept(FE_ALL_EXCEPT);

    double result = denorm_max * multiplier; // 只有在 tinyness_before 时才下溢

    if (std::fetestexcept(FE_UNDERFLOW))
        std::cout &lt;&lt; "检测到下溢\n";

    std::cout &lt;&lt; std::hexfloat &lt;&lt; denorm_max &lt;&lt; " x " &lt;&lt; multiplier &lt;&lt;  " = "
              &lt;&lt; result &lt;&lt; '\n';
}
|p=true
|output=
舍入前是否检测下溢：true
检测到下溢
0xf.ffffffffffffp-1030 x 0x1.0000000000001p+0 = 0x1p-1022
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/numeric_limits/dsc has_denorm_loss}}
{{dsc inc|cpp/types/numeric_limits/dsc has_denorm}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}