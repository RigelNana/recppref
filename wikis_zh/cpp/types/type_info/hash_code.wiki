{{cpp/types/type_info/title|hash_code}}
{{cpp/types/type_info/navbar}}
{{ddcl|since=c++11|1=
std::size_t hash_code() const noexcept;
}}

返回未指定值（此处成为''散列码''），使得所有指代同一类型的 {{lc|std::type_info}} 对象的''散列码''都相同。

不给出其他保证：指代不同类型的 {{lc|std::type_info}} 对象可以拥有相同的''散列码''（尽管标准推荐实现尽可能避免这点），而同一类型的''散列码''可在相同程序的各次不同调用间改变。

===参数===
（无）

===返回值===
对所有指代同一类型的 {{lc|std::type_info}} 对象都相同的值。

===示例===
{{example
|下列程序是一个有效的不使用 {{lc|std::type_index}} 的类型-值映射示例。
|code=
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;typeinfo&gt;
#include &lt;unordered_map&gt;

struct A
{
    virtual ~A() {}
};

struct B : A {};
struct C : A {};

using TypeInfoRef = std::reference_wrapper&lt;const std::type_info&gt;;

struct Hasher
{
    std::size_t operator()(TypeInfoRef code) const
    {
        return code.get().hash_code();
    }
};

struct EqualTo
{
    bool operator()(TypeInfoRef lhs, TypeInfoRef rhs) const
    {
        return lhs.get() == rhs.get();
    }
};

int main()
{
    std::unordered_map&lt;TypeInfoRef, std::string, Hasher, EqualTo&gt; type_names;

    type_names[typeid(int)] = "int";
    type_names[typeid(double)] = "double";
    type_names[typeid(A)] = "A";
    type_names[typeid(B)] = "B";
    type_names[typeid(C)] = "C";

    int i;
    double d;
    A a;

    // 注意我们存储指向 A 的指针
    std::unique_ptr&lt;A&gt; b(new B);
    std::unique_ptr&lt;A&gt; c(new C);

    std::cout &lt;&lt; "i 是 " &lt;&lt; type_names[typeid(i)] &lt;&lt; '\n';
    std::cout &lt;&lt; "d 是 " &lt;&lt; type_names[typeid(d)] &lt;&lt; '\n';
    std::cout &lt;&lt; "a 是 " &lt;&lt; type_names[typeid(a)] &lt;&lt; '\n';
    std::cout &lt;&lt; "*b 是 " &lt;&lt; type_names[typeid(*b)] &lt;&lt; '\n';
    std::cout &lt;&lt; "*c 是 " &lt;&lt; type_names[typeid(*c)] &lt;&lt; '\n';
}
|output=
i 是 int
d 是 double
a 是 A
*b 是 B
*c 是 C
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/type_info/dsc operator_cmp}}
{{dsc inc|cpp/types/type_info/dsc name}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}