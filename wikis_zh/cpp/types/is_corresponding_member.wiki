{{cpp/title|is_corresponding_member}}
{{cpp/meta/navbar}}
{{ddcl|header=type_traits|since=c++20|
template&lt; class S1, class S2, class M1, class M2 &gt;
constexpr bool is_corresponding_member( M1 S1::* mp, M2 S2::* mq ) noexcept;
}}

确定 {{c|mp}} 与 {{c|mq}} 是否指代 {{tt|S1}} 与 {{tt|S2}} 的[[cpp/language/data members#标准布局|公共起始序列]]中的对应成员。若 {{tt|S1}} 或 {{tt|S2}} 为[[cpp/language/type#不完整类型|不完整类型]]则程序非良构。

若 {{tt|S1}} 或 {{tt|S2}} 不是{{named req|StandardLayoutType}}，或若 {{tt|M1}} 或 {{tt|M2}} 不是对象类型，或若 {{c|mp}} 或 {{c|mq}} 等于 {{c|nullptr}}，则结果始终为 {{c|false}}。

===参数===
{{par begin}}
{{par|mp, mq|要检测的成员指针}}
{{par end}}

===返回值===
若 {{c|mp}} 与 {{c|mq}} 指代 {{tt|S1}} 与 {{tt|S2}} 的公共起始序列中的对应成员则为 {{c|true}}，否则为 {{c|false}}。

===注解===
成员指针表达式 {{c|&amp;S::m}} 的类型并非始终是 {{c|M S::*}}，其中 {{tt|m}} 的类型为 {{tt|M}}，因为 {{tt|m}} 可能是从 {{tt|S}} 的基类继承的成员。可以指定前两个模板实参以避免潜在地令人诧异的结果。

===示例===
{{example
|code=
#include &lt;type_traits&gt;

struct Foo
{
    int x;
    double d;
};

struct Bar
{
    int y;
    double z;
};

struct Baz : Foo, Bar {}; // 非标准布局

static_assert(
    std::is_same_v&lt;decltype(&amp;Baz::x), int Foo::*&gt; == true &amp;&amp;
    std::is_same_v&lt;decltype(&amp;Baz::y), int Bar::*&gt; == true &amp;&amp;
    std::is_corresponding_member(&amp;Foo::x, &amp;Bar::y) == true &amp;&amp;
    std::is_corresponding_member(&amp;Foo::d, &amp;Bar::z) == true &amp;&amp;
    std::is_corresponding_member(&amp;Baz::x, &amp;Baz::y) == true &amp;&amp;
    std::is_corresponding_member&lt;Baz, Baz, int, int&gt;(&amp;Baz::x, &amp;Baz::y) == false
);

int main() {}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_standard_layout}}
{{dsc inc|cpp/types/dsc is_layout_compatible}}
{{dsc inc|cpp/types/dsc is_member_object_pointer}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}