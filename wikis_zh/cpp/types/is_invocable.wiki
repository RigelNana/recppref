{{cpp/title|is_invocable|is_invocable_r|is_nothrow_invocable|is_nothrow_invocable_r}}
{{cpp/meta/navbar}}
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++17|num=1|
template&lt; class Fn, class... ArgTypes &gt;
struct is_invocable;
}}
{{dcl|since=c++17|num=2|
template&lt; class R, class Fn, class... ArgTypes &gt;
struct is_invocable_r;
}}
{{dcl|since=c++17|num=3|
template&lt; class Fn, class... ArgTypes &gt;
struct is_nothrow_invocable;
}}
{{dcl|since=c++17|num=4|
template&lt; class R, class Fn, class... ArgTypes &gt;
struct is_nothrow_invocable_r;
}}
{{dcl end}}

@1@ 确定 {{box|{{lti|cpp/utility/functional|INVOKE}}{{c/core|(std::declval&lt;Fn&gt;(), std::declval&lt;ArgTypes&gt;()...)}}}} 在作为不求值操作数时是否良构。
@2@ 确定 {{box|{{lti|cpp/utility/functional|INVOKE&lt;R&gt;}}{{c/core|(std::declval&lt;Fn&gt;(), std::declval&lt;ArgTypes&gt;()...)}}}} 在作为不求值操作数时是否良构。
@3@ 确定 {{box|{{lti|cpp/utility/functional|INVOKE}}{{c/core|(std::declval&lt;Fn&gt;(), std::declval&lt;ArgTypes&gt;()...)}}}} 在作为不求值操作数时是否良构，以及是否已知这种调用不抛任何异常。
@4@ 确定 {{box|{{lti|cpp/utility/functional|INVOKE&lt;R&gt;}}{{c/core|(std::declval&lt;Fn&gt;(), std::declval&lt;ArgTypes&gt;()...)}}}} 在作为不求值操作数时是否良构，以及是否已知这种调用不抛任何异常。

{{cpp/types/cvaub|type1=Fn, R|pack=ArgTypes}}

{{cpp/types/nospec|any}}

===辅助变量模板===
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++17|num=1|1=
template&lt; class Fn, class... ArgTypes &gt;
inline constexpr bool is_invocable_v =
    std::is_invocable&lt;Fn, ArgTypes...&gt;::value;
}}
{{dcl|since=c++17|num=2|1=
template&lt; class R, class Fn, class... ArgTypes &gt;
inline constexpr bool is_invocable_r_v =
    std::is_invocable_r&lt;R, Fn, ArgTypes...&gt;::value;
}}
{{dcl|since=c++17|num=3|1=
template&lt; class Fn, class... ArgTypes &gt;
inline constexpr bool is_nothrow_invocable_v =
    std::is_nothrow_invocable&lt;Fn, ArgTypes...&gt;::value;
}}
{{dcl|since=c++17|num=4|1=
template&lt; class R, class Fn, class... ArgTypes &gt;
inline constexpr bool is_nothrow_invocable_r_v =
    std::is_nothrow_invocable_r&lt;R, Fn, ArgTypes...&gt;::value;
}}
{{dcl end}}

{{cpp/types/integral_constant/inherit|（对于重载 {{v|1}}）{{box|{{lti|cpp/utility/functional|INVOKE}}{{c/core|(std::declval&lt;Fn&gt;(), std::declval&lt;ArgTypes&gt;()...)}}}} 在被当做不求值操作数时为良构}}

===注解===
{{ftm begin|std=1|comment=1}}
{{ftm|std=C++17|value=201703L|__cpp_lib_is_invocable|{{tt|std::is_invocable}}, {{lc|std::invoke_result}}}}
{{ftm end}}

===示例===
{{example
|code=
#include &lt;type_traits&gt;

auto func2(char) -&gt; int (*)()
{
    return nullptr;
}

int main()
{
    static_assert(std::is_invocable_v&lt;int()&gt;);
    static_assert(not std::is_invocable_v&lt;int(), int&gt;);
    static_assert(std::is_invocable_r_v&lt;int, int()&gt;);
    static_assert(not std::is_invocable_r_v&lt;int*, int()&gt;);
    static_assert(std::is_invocable_r_v&lt;void, void(int), int&gt;);
    static_assert(not std::is_invocable_r_v&lt;void, void(int), void&gt;);
    static_assert(std::is_invocable_r_v&lt;int(*)(), decltype(func2), char&gt;);
    static_assert(not std::is_invocable_r_v&lt;int(*)(), decltype(func2), void&gt;);
}
|output=
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc invoke}}
{{dsc inc|cpp/types/dsc result_of}}
{{dsc inc|cpp/utility/dsc declval}}
{{dsc inc|cpp/concepts/dsc invocable}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}