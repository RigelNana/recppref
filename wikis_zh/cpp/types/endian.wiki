{{cpp/title|endian}}
{{cpp/utility/bit/navbar}}
{{ddcl|header=bit|since=c++20|1=
enum class endian
{
    little = /* 实现定义 */,
    big    = /* 实现定义 */,
    native = /* 实现定义 */
};
}}

指示所有[[cpp/language/type|标量类型]]的{{enwiki|Endianness#Overview|端序}}：

* 若所有标量类型均为小端，则 {{tt|std::endian::native}} 等于 {{tt|std::endian::little}}。
* 若所有标量类型均为大端，则 {{tt|std::endian::native}} 等于 {{tt|std::endian::big}}。

符合边界情况的平台也受支持：
* 若所有标量类型的 {{tt|sizeof}} 都等于 1，则端序没有意义，且 {{tt|std::endian::little}}、{{tt|std::endian::big}} 及 {{tt|std::endian::native}} 三个值相同。
* 若平台使用混合端序，则 {{tt|std::endian::native}} 既不等于 {{tt|std::endian::big}} 亦不等于 {{tt|std::endian::little}}。

===可能的实现===
{{source|1=
enum class endian
{
#if defined(_MSC_VER) &amp;&amp; !defined(__clang__)
    little = 0,
    big    = 1,
    native = little
#else
    little = __ORDER_LITTLE_ENDIAN__,
    big    = __ORDER_BIG_ENDIAN__,
    native = __BYTE_ORDER__
#endif
};
}}

===注解===
{{feature test macro|__cpp_lib_endian|std=C++20|value=201907L|{{c|std::endian}}}}

===示例===
{{example
|code=
#include &lt;bit&gt;
#include &lt;iostream&gt;

int main()
{
    if constexpr (std::endian::native == std::endian::big)
        std::cout &lt;&lt; "大端\n";
    else if constexpr (std::endian::native == std::endian::little)
        std::cout &lt;&lt; "小端\n";
    else
        std::cout &lt;&lt; "混合端序\n";
}
|p=true
|output=
混合端序
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/dsc byteswap}}
{{dsc see c|c/numeric/endian}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}