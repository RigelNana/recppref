{{cpp/title|add_lvalue_reference|add_rvalue_reference}}
{{cpp/meta/navbar}}
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++11|num=1|1=
template&lt; class T &gt;
struct add_lvalue_reference;
}}
{{dcl|since=c++11|num=2|1=
template&lt; class T &gt;
struct add_rvalue_reference;
}}
{{dcl end}}

创建 {{tt|T}} 的左值或右值引用类型。

{|class="wikitable" style="text-align: center;"
!rowspan=2|{{nbsp}}类型特征{{nbsp}}
!colspan=2|嵌套类型 {{ttn|type}} 表示的类型
|-
!{{nbsp}}{{ttn|T}} 是[[cpp/meta#定义|可引用类型]]{{nbsp}}
!{{nbsp}}{{ttn|T}} 不是可引用类型{{nbsp}}
|-
|{{v|1}}
|{{tt|T&amp;}}&lt;ref&gt;此规则反映了{{lsd|cpp/language/reference#引用折叠}}的语义。&lt;/ref&gt;
|rowspan=2|{{tt|T}}
|-
|{{v|2}}
|{{tt|T&amp;&amp;}}&lt;ref&gt;此规则反映了{{lsd|cpp/language/reference#引用折叠}}的语义。注意：{{c/core|std::add_rvalue_reference&lt;T&amp;&gt;::type}} 是 {{tt|T&amp;}}，而它不是右值引用类型。&lt;/ref&gt;
|}
&lt;references/&gt;

{{cpp/types/nospec|any}}

===嵌套类型===
{{dsc begin}}
{{dsc hitem|名字|定义}}
{{dsc|{{tt|type}}|按以上方式确定}}
{{dsc end}}

===辅助类型===
{{dcl begin}}
{{dcl|since=c++14|1=
template&lt; class T &gt;
using add_lvalue_reference_t = typename add_lvalue_reference&lt;T&gt;::type;
}}
{{dcl|since=c++14|1=
template&lt; class T &gt;
using add_rvalue_reference_t = typename add_rvalue_reference&lt;T&gt;::type;
}}
{{dcl end}}

===注解===
使用这些类型特征与直接使用 {{tt|T&amp;}} 或 {{tt|T&amp;&amp;}} 的主要区别是 {{tt|T}} 可以是不[[cpp/meta#定义|可引用]]的类型。例如 {{c/core|std::add_lvalue_reference&lt;void&gt;::type}} 是 {{c/core|void}}，而 {{c/core|void&amp;}} 会导致编译错误。

===可能的实现===
{{eq fun
|1=
namespace detail
{
    template&lt;class T&gt;
    struct type_identity { using type = T; }; // 或者使用 std::type_identity（C++20 起）
    
    template&lt;class T&gt; // 注意 “cv void&amp;” 是替换失败
    auto try_add_lvalue_reference(int) -&gt; type_identity&lt;T&amp;&gt;;
    template&lt;class T&gt; // 处理 T = cv void 的情况
    auto try_add_lvalue_reference(...) -&gt; type_identity&lt;T&gt;;
    
    template&lt;class T&gt;
    auto try_add_rvalue_reference(int) -&gt; type_identity&lt;T&amp;&amp;&gt;;
    template&lt;class T&gt;
    auto try_add_rvalue_reference(...) -&gt; type_identity&lt;T&gt;;
} // namespace detail

template&lt;class T&gt;
struct add_lvalue_reference
    : decltype(detail::try_add_lvalue_reference&lt;T&gt;(0)) {};

template&lt;class T&gt;
struct add_rvalue_reference
    : decltype(detail::try_add_rvalue_reference&lt;T&gt;(0)) {};
}}

===示例===
{{example
|code=
#include &lt;type_traits&gt;

using non_ref = int;
static_assert(std::is_lvalue_reference_v&lt;non_ref&gt; == false);

using l_ref = std::add_lvalue_reference_t&lt;non_ref&gt;;
static_assert(std::is_lvalue_reference_v&lt;l_ref&gt; == true);

using r_ref = std::add_rvalue_reference_t&lt;non_ref&gt;;
static_assert(std::is_rvalue_reference_v&lt;r_ref&gt; == true);

using void_ref = std::add_lvalue_reference_t&lt;void&gt;;
static_assert(std::is_reference_v&lt;void_ref&gt; == false);

int main() {}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2101|std=c++11|before=在 {{tt|T}} 是有 {{spar sep|cv限定符}}或{{spar sep|引用限定符}}的{{ls|cpp/language/function#函数类型}}时程序非良构|after=此时产生的类型是 {{tt|T}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_reference}}
{{dsc inc|cpp/types/dsc remove_reference}}
{{dsc inc|cpp/types/dsc remove_cvref}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}