{{cpp/title|bad_typeid}}
{{cpp/types/navbar}}
{{ddcl|header=typeinfo|
class bad_typeid : public std::exception;
}}

此类型的异常在应用 {{ltt|cpp/language/typeid}} 运算符到多态类型的空指针值时抛出。

{{inheritance diagram/std-bad_typeid}}

===成员函数===
{{cpp/error/exception/member of derived|bad_typeid}}

{{cpp/error/exception/inherit}}

===注解===
{{feature test macro|__cpp_lib_constexpr_exceptions|value=202411L|std=C++26|{{c/core|constexpr}} 的异常类型}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

struct S // 类型必须是多态
{
    virtual void f();
}; 

int main()
{
    S* p = nullptr;
    try
    {
        std::cout &lt;&lt; typeid(*p).name() &lt;&lt; '\n';
    }
    catch (const std::bad_typeid&amp; e)
    {
        std::cout &lt;&lt; e.what() &lt;&lt; '\n';
    }
}
|p=true
|output=
Attempted a typeid of NULL pointer!
}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}