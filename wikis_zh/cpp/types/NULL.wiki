{{title|NULL}}
{{cpp/types/navbar}}
{{dcl begin}}
{{dcl header|clocale}}&lt;!-- C++03 的表格 62 中缺失，但“内容同标准 C 库同文件 locale.h ”而 C89 定义 NULL 于 locale.h ($4.4)--&gt;
{{dcl header|cstddef}}
{{dcl header|cstdio}}
{{dcl header|cstdlib}}&lt;!-- 表格 33 的所有订版中缺失（只是“部分”（ C++03 ）/“描述某些内容”（ C++11 ）），但“内容同标准 C 库头文件 stdlib.h ”，而且亦列于 C++11 的表格 149 和 C.5.2.4[diff.null]/1 --&gt;
{{dcl header|cstring}}
{{dcl header|ctime}}
{{dcl header|cwchar}}
{{dcl|
#define NULL /* 由实现定义 */
}}
{{dcl end}}

宏 {{tt|NULL}} 是由实现定义的[[cpp/language/pointer#空指针|空指针常量]]。

===可能的实现===
{{eq fun|
#define NULL 0
// C++11 起
#define NULL nullptr
}}

===注解===
C 中，宏 {{tt|NULL}} 可以拥有类型 {{c/core|void*}}，但这在 C++ 中不允许，因为空指针常量不能具有该类型。

===示例===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;typeinfo&gt;

class S;

int main()
{
    int* p = NULL;
    int* p2 = static_cast&lt;std::nullptr_t&gt;(NULL);
    void(*f)(int) = NULL;
    int S::*mp = NULL;
    void(S::*mfp)(int) = NULL;
    auto nullvar = NULL; // 以 gcc/clang 编译时可能会触发警告
    
    std::cout &lt;&lt; "nullvar 的类型是 " &lt;&lt; typeid(nullvar).name() &lt;&lt; '\n';
    
    if constexpr(std::is_same_v&lt;decltype(NULL), std::nullptr_t&gt;)
        std::cout &lt;&lt; "NULL 以 std::nullptr_t 类型实现\n";
    else
        std::cout &lt;&lt; "NULL 以整数类型实现\n";

    [](...){}(p, p2, f, mp, mfp); // &lt; 抑制“未使用变量”警告
}
|p=true
|output=
nullvar 的类型是 long
NULL 以整数类型实现
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/language/dsc nullptr}}
{{dsc inc|cpp/types/dsc nullptr_t}}
{{dsc see c|c/types/NULL}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}