{{cpp/types/traits/is|1=is_literal_type
|deprecated=c++17
|removed=c++20
|description=
（由于对泛型编程而言十分鸡肋，这项类型特性已经弃用&lt;ref&gt;{{User:Radix/cite_p_paper|authors=Alisdair Meredith|no=0174|revision=2|title=Deprecating Vestigial Library Parts in C++17|mailing-year=2016|extension=html|section=Deprecate the &lt;tt&gt;is_literal&lt;/tt&gt; Trait|section-id=2.3|quote=The &lt;tt&gt;is_literal&lt;/tt&gt; type trait offers negligible value to generic code, as what is really needed is the ability to know that a specific construction would produce constant initialization.}}&lt;/ref&gt;并移除&lt;ref&gt;{{User:Radix/cite_p_paper|authors=Alisdair Meredith, Stephan T. Lavavej, Tomasz Kamiński|no=0619|revision=4|title=Reviewing Deprecated Facilities of C++17 for C++20|mailing-year=2018|extension=html|section=Deprecated type traits|section-id=3.12|quote='''Strong recommendation:''' Remove the traits that can live on as zombies. [...] '''Toronto Review:''' Accept strong recommendation, strike from C++20.}}&lt;/ref&gt;。）

如果 {{tt|T}} 满足{{named req|LiteralType}}的所有要求，那么提供的成员常量 {{tt|value}} 等于 {{c|true}}。对于其它任何类型，{{tt|value}} 等于 {{c|false}}。

如果 {{c/core|std::remove_all_extents_t&lt;T&gt;}} 是除了（可有 cv 限定的）{{c/core|void}} 以外的不完整类型，那么行为未定义。
|inherit_desc={{tt|T}} 是字面类型
}}

===注解===
只有字面类型能作为 {{ls|cpp/language/constexpr#constexpr 函数}}的形参或返回类型。只有字面类能拥有 constexpr 成员函数。

===示例===
{{example
|code=
#include &lt;type_traits&gt;

struct A { int m; };
static_assert(std::is_literal_type_v&lt;A&gt; == true);

struct B { virtual ~B(); };
static_assert(std::is_literal_type_v&lt;B&gt; == false);

int main() {}
|output=
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2015|std=C++11|before={{tt|T}} 可以是不完整类类型的未知边界数组|after=此时行为未定义}}
{{dr list end}}

===外部链接===
{{eli|&lt;references/&gt;}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}