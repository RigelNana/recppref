{{cpp/types/traits/is|1=is_scoped_enum
|std=c++23
|description= 
检查 {{tt|T}} 是否为[[cpp/language/enum#有作用域枚举|有作用域枚举类型]]。如果 {{tt|T}} 是有作用域枚举类型，那么提供的成员常量 {{tt|value}} 等于 {{c|true}}。否则，{{tt|value}} 等于 {{c|false}}。
|inherit_desc={{tt|T}} 是有作用域枚举类型
}}

===注解===
{{feature test macro|__cpp_lib_is_scoped_enum|value=202011L|std=C++23|{{tt|std::is_scoped_enum}}}}

===可能的实现===
{{eq fun|1=
namespace detail
{
void test_conversion(...);          // 在 E 完整且为有作用域时得到选择
void test_conversion(int) = delete; // 在 E 完整且为无作用域时得到选择
 
template&lt;class E&gt;
concept is_scoped_enum_impl =
    std::is_enum_v&lt;E&gt; &amp;&amp;                        // 首先检查
    requires { detail::test_conversion(E{}); }; // 当 E 不完整时在重载决议前非良构
} // namespace detail
 
template&lt;class T&gt;
struct is_scoped_enum : std::bool_constant&lt;detail::is_scoped_enum_impl&lt;T&gt;&gt; {};
}}

===示例===
{{example
|code=
#include &lt;type_traits&gt;
 
static_assert(std::is_scoped_enum_v&lt;int&gt; == false);
 
class A {};
static_assert(std::is_scoped_enum_v&lt;A&gt; == false);
 
enum B { self_test = std::is_scoped_enum_v&lt;B&gt; };
static_assert(std::is_scoped_enum_v&lt;B&gt; == false);
static_assert(!self_test);
 
enum struct C { final, import, module };
static_assert(std::is_scoped_enum_v&lt;C&gt; == true);
 
enum class D : int { pre, post, override };
static_assert(std::is_scoped_enum_v&lt;D&gt; == true);
 
enum class E;
static_assert(std::is_scoped_enum_v&lt;E&gt; == true);
 
int main() {}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_integral}}
{{dsc inc|cpp/types/dsc is_arithmetic}}
{{dsc inc|cpp/types/dsc is_scalar}}
{{dsc inc|cpp/types/dsc is_enum}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}