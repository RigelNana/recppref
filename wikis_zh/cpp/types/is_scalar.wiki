{{cpp/types/traits/is|1=is_scalar
|description=
如果 {{tt|T}} 是[[cpp/named req/ScalarType|标量类型]]，那么提供的成员常量 {{tt|value}} 等于 {{c|true}}。对于其它任何类型，{{tt|value}} 等于 {{c|false}}。
|inherit_desc={{tt|T}} 是标量类型
}}

===注解===
C++ 内存模型中的每个独立内存位置，包括语言特性所用的隐藏内存位置（如虚表指针），都拥有标量类型（或为相邻的非零长位域序列）。表达式求值中的副作用顺序、线程间同步和依赖顺序全部都基于标量对象定义。

===可能的实现===
{{eq fun
|1=
template&lt;class T&gt;
struct is_scalar : std::integral_constant&lt;bool, std::is_arithmetic&lt;T&gt;::value
                                             {{!!}} std::is_enum&lt;T&gt;::value
                                             {{!!}} std::is_pointer&lt;T&gt;::value
                                             {{!!}} std::is_member_pointer&lt;T&gt;::value
                                             {{!!}} std::is_null_pointer&lt;T&gt;::value&gt;
{};
}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;typeinfo&gt;
#include &lt;utility&gt;

template&lt;typename Head, typename... Tail&gt;
void are_scalars(Head&amp;&amp; head, Tail&amp;&amp;... tail)
{
    using T = std::decay_t&lt;decltype(head)&gt;;
    
    std::cout &lt;&lt; typeid(T).name() &lt;&lt; " "
              &lt;&lt; (std::is_scalar_v&lt;T&gt; ? "" : "不")
              &lt;&lt; "是标量类型\n";
    
    if constexpr (sizeof... (Tail))
    {
        are_scalars(std::forward&lt;decltype(tail)&gt;(tail)...);
    }
}

int main()
{
    struct S { int m; } s;
    int S::* mp = &amp;S::m;
    enum class E { e };
    
    are_scalars(42, 3.14, E::e, "str", mp, nullptr, s);
}
|p=true
|output=
int 是标量类型
double 是标量类型
main::E 是标量类型
char const* 是标量类型
int main::S::* 是标量类型
nullptr 是标量类型
main::S 不是标量类型
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_arithmetic}}
{{dsc inc|cpp/types/dsc is_enum}}
{{dsc inc|cpp/types/dsc is_pointer}}
{{dsc inc|cpp/types/dsc is_member_pointer}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}