{{cpp/title|byte}}
{{cpp/types/navbar}}
{{ddcl|header=cstddef|since=c++17|
enum class byte : unsigned char {};
}}

{{tt|std::byte}} 是一种独立类型，它实现了 C++ 语言定义中所规定的字节的概念。

类似 {{c/core|unsigned char}}，它能用于访问其他对象所占据的原始内存（[[cpp/language/object|对象表示]]），但不同于 {{c/core|unsigned char}}，它不是字符类型也不是算术类型。{{tt|std::byte}} 只实现位的汇集，而且仅支持进行整数位移运算、与另一 {{tt|std::byte}} 进行逐位和比较运算。

===非成员函数===
{{member|{{small|std::}}to_integer|2=
{{dcl begin}}
{{dcl|since=c++17|
template&lt; class IntegerType &gt;
constexpr IntegerType to_integer( std::byte b ) noexcept;
}}
{{dcl end}}
等价于：{{c|return IntegerType(b);}}
{{cpp/enable_if| {{c|std::is_integral_v&lt;IntegerType&gt;}} 为 {{c|true}} }}。
}}

{{member|1={{small|std::}}operator&lt;&lt;=,operator&gt;&gt;=|2=
{{dcl begin}}
{{dcl | since=c++17|num=1|1=
template&lt; class IntegerType &gt;
constexpr std::byte&amp; operator&lt;&lt;=( std::byte&amp; b, IntegerType shift ) noexcept;
}}
{{dcl|since=c++17|num=2|1=
template&lt; class IntegerType &gt;
constexpr std::byte&amp; operator&gt;&gt;=( std::byte&amp; b, IntegerType shift ) noexcept;
}}
{{dcl end}}
@1@等价于：{{c|1=return b = b &lt;&lt; shift;}}
{{cpp/enable_if| {{c|std::is_integral_v&lt;IntegerType&gt;}} 为 {{c|true}} }}。
@2@等价于：{{c|1=return b = b &gt;&gt; shift;}}
{{cpp/enable_if| {{c|std::is_integral_v&lt;IntegerType&gt;}} 为 {{c|true}} }}。
}}

{{member|{{small|std::}}operator&lt;&lt;,operator&gt;&gt;|2=
{{dcl begin}}
{{dcl|since=c++17|num=1|
template&lt; class IntegerType &gt;
constexpr std::byte operator&lt;&lt;( std::byte b, IntegerType shift ) noexcept;
}}
{{dcl|since=c++17|num=2|
template&lt; class IntegerType &gt;
constexpr std::byte operator&gt;&gt;( std::byte b, IntegerType shift ) noexcept;
}}
{{dcl end}}
@1@等价于：{{c|return std::byte(static_cast&lt;unsigned int&gt;(b) &lt;&lt; shift);}}
{{cpp/enable_if| {{c|std::is_integral_v&lt;IntegerType&gt;}} 为 {{c|true}} }}。
@2@等价于：{{c|return std::byte(static_cast&lt;unsigned int&gt;(b) &gt;&gt; shift);}}
{{cpp/enable_if| {{c|std::is_integral_v&lt;IntegerType&gt;}} 为 {{c|true}} }}。
}}

{{member|1={{small|std::}}operator{{!}}=,operator&amp;=,operator^=|2=
{{dcl begin}}
{{dcl|since=c++17|num=1|1=
constexpr std::byte&amp; operator{{!}}=(std::byte&amp; l, std::byte r) noexcept;  
}}
{{dcl|since=c++17|num=2|1=
constexpr std::byte&amp; operator&amp;=(std::byte&amp; l, std::byte r) noexcept;
}}
{{dcl|since=c++17|num=3|1=
constexpr std::byte&amp; operator^=(std::byte&amp; l, std::byte r) noexcept;
}}
{{dcl end}}
@1@ 等价于：{{c|1=return l = l {{!}} r;}}。
@2@ 等价于：{{c|1=return l = l &amp; r;}}。
@3@ 等价于：{{c|1=return l = l ^ r;}}。
}}

{{member|{{small|std::}}operator{{!}},operator&amp;,operator^,operator~|2=
{{dcl begin}}
{{dcl|since=c++17|num=1|1=
constexpr std::byte operator{{!}}( std::byte l, std::byte r ) noexcept;
}}
{{dcl|since=c++17|num=2|
constexpr std::byte operator&amp;( std::byte l, std::byte r ) noexcept;
}}
{{dcl|since=c++17|num=3|
constexpr std::byte operator^( std::byte l, std::byte r ) noexcept;
}}
{{dcl|since=c++17|num=4|
constexpr std::byte operator~( std::byte b ) noexcept;
}}
{{dcl end}}
@1@ 等价于：{{c|1=return std::byte(static_cast&lt;unsigned int&gt;(l) {{!}} static_cast&lt;unsigned int&gt;(r));}}。
@2@ 等价于：{{c|1=return std::byte(static_cast&lt;unsigned int&gt;(l) &amp; static_cast&lt;unsigned int&gt;(r));}}。
@3@ 等价于：{{c|1=return std::byte(static_cast&lt;unsigned int&gt;(l) ^ static_cast&lt;unsigned int&gt;(r));}}。
@4@ 等价于：{{c|1=return std::byte(~static_cast&lt;unsigned int&gt;(b));}}。
}}

===注解===
由于 C++17 [[cpp/language/enum#enum relaxed init cpp17|放松的 enum class 初始化规则]]，可以用 {{c|1=std::byte{n}&lt;!----&gt;}} 转换数值 {{c|n}} 为 {{tt|byte}} 值。

可以使用常规方式用[[cpp/language/explicit_cast|显式转换]]把 {{tt|byte}} 转换为数值（例如用于生成对象的整数散列），使用 {{lc|std::to_integer}} 也可以。

{{feature test macro|__cpp_lib_byte|{{tt|std::byte}}|std=C++17|value=201603L}}

===示例===
{{example
|code=
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, std::byte b)
{
    return os &lt;&lt; std::bitset&lt;8&gt;(std::to_integer&lt;int&gt;(b));
}

int main()
{
    // std::byte y = 1; // 错误：无法把 int 转换为 byte。
    std::byte y{1}; // OK

    // if (y == 13) {} // 错误：无法比较。
    if (y == std::byte{13}) {} // OK，byte 是可比较的

    int arr[]{1, 2, 3};
    // int c = a[y]; // 错误：数组下标不是整数
    [[maybe_unused]] int i = arr[std::to_integer&lt;int&gt;(y)]; // OK
    [[maybe_unused]] int j = arr[std::to_underlying(y)];   // OK

    auto to_int = [](std::byte b) { return std::to_integer&lt;int&gt;(b); };

    std::byte b{42};
    assert(to_int(b) == 0b00101010);
    std::cout &lt;&lt; b &lt;&lt; '\n';

    // b *= 2; // 错误：b 不是算术类型
    b &lt;&lt;= 1;
    assert(to_int(b) == 0b01010100);

    b &gt;&gt;= 1;
    assert(to_int(b) == 0b00101010);

    assert(to_int(b &lt;&lt; 1) == 0b01010100);
    assert(to_int(b &gt;&gt; 1) == 0b00010101);

    b {{!}}= std::byte{0b11110000};
    assert(to_int(b) == 0b11111010);

    b &amp;= std::byte{0b11110000};
    assert(to_int(b) == 0b11110000);

    b ^= std::byte{0b11111111};
    assert(to_int(b) == 0b00001111);
}
|output=
00101010
}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}