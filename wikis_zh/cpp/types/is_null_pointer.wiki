{{cpp/types/traits/is|1=is_null_pointer 
|std=c++11
|description=
检查 {{tt|T}} 是否是 {{lc|std::nullptr_t}} 类型。

如果 {{tt|T}} 是类型 {{lc|std::nullptr_t}}、{{c/core|const std::nullptr_t}}、{{c/core|volatile std::nullptr_t}} 或 {{c/core|const volatile std::nullptr_t}}，那么提供的成员常量 {{tt|value}} 等于 {{c|true}}。

否则，{{c|value}} 等于 {{c|false}}。
|inherit_desc={{tt|T}} 是（可有 cv 限定的）{{lc|std::nullptr_t}} 类型
}}

===可能的实现===
{{eq fun
|1=
template&lt;class T&gt;
struct is_null_pointer : std::is_same&lt;std::nullptr_t, std::remove_cv_t&lt;T&gt;&gt; {};
}}

===注解===
对于 {{lc|std::nullptr_t}}，{{lc|std::is_pointer}} 是 {{c|false}}，因为它不是内建指针类型。

在 libc++ 中，{{tt|std::is_null_pointer}} 不能在 C++11 模式中使用。

{{feature test macro|__cpp_lib_is_null_pointer|{{tt|std::is_null_pointer}}|value=201309L|std=C++14|dr=11}}

===示例===
{{example
|code=
#include &lt;type_traits&gt;

static_assert(std::is_null_pointer_v&lt;decltype(nullptr)&gt;);
static_assert(!std::is_null_pointer_v&lt;int*&gt;);
static_assert(!std::is_pointer_v&lt;decltype(nullptr)&gt;);
static_assert(std::is_pointer_v&lt;int*&gt;);

int main()
{
}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2247|std=C++11|before=缺失了检测 {{lc|std::nullptr_t}} 的类型特征|after=添加该特征}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_void}}
{{dsc inc|cpp/types/dsc is_array}}
{{dsc inc|cpp/types/dsc is_pointer}}
{{dsc inc|cpp/types/dsc is_enum}}
{{dsc inc|cpp/types/dsc is_union}}
{{dsc inc|cpp/types/dsc is_class}}
{{dsc inc|cpp/types/dsc is_function}}
{{dsc inc|cpp/types/dsc is_object}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}