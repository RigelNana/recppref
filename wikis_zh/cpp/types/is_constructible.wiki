{{cpp/title|is_constructible|is_trivially_constructible|is_nothrow_constructible}}
{{cpp/meta/navbar}}
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++11|num=1|1=
template&lt; class T, class... Args &gt;
struct is_constructible;
}}
{{dcl|since=c++11|num=2|1=
template&lt; class T, class... Args &gt;
struct is_trivially_constructible;
}}
{{dcl|since=c++11|num=3|1=
template&lt; class T, class... Args &gt;
struct is_nothrow_constructible;
}}
{{dcl end}}

@1@ 如果 {{tt|T}} 是对象或引用类型，且变量定义 {{c|T obj(std::declval&lt;Args&gt;()...);}} 良构，那么提供的成员常量 {{tt|value}} 等于 {{c|true}}。对于其它所有类型，{{tt|value}} 等于 {{c|false}}。&lt;br&gt;
对于这项检查而言，决不会把变量定义判读为函数声明，且不认为 {{lc|std::declval}} 是 [[cpp/language/definition#ODR 式使用|ODR 式使用]]。如同从与 {{tt|T}} 和 {{tt|Args}} 中的任何类型无关的语境进行[[cpp/language/access|访问检查]]。仅考虑变量定义的立即语境的合法性。

@2@ 同 {{v|1}}，但变量定义不进行任何非平凡操作。对于这项检查而言，对 {{lc|std::declval}} 的调用被认为是平凡的。

@3@ 同 {{v|1}}，但变量定义为 {{tt|noexcept}}。

{{cpp/types/cvaub|pack=Args}}

{{cpp/types/nospec|any}}

=== 辅助变量模板 ===
{{dcl begin}}

{{dcl|since=c++17|1=
template&lt; class T, class... Args &gt;
inline constexpr bool is_constructible_v =
    is_constructible&lt;T, Args...&gt;::value;
}}

{{dcl|since=c++17|1=
template&lt; class T, class... Args &gt;
inline constexpr bool is_trivially_constructible_v =
    is_trivially_constructible&lt;T, Args...&gt;::value;
}}

{{dcl|since=c++17|1=
template&lt; class T, class... Args &gt;
inline constexpr bool is_nothrow_constructible_v =
    is_nothrow_constructible&lt;T, Args...&gt;::value;
}}
{{dcl end}}

{{cpp/types/integral_constant/inherit|{{tt|T}} 可从 {{tt|Args...}} 构造}}

===注解===
多数实现中，{{tt|is_nothrow_constructible}} 亦检查析构函数是否抛出，因为它相当于 {{c|noexcept(T(arg))}}。同样的情况适用于 {{tt|is_trivially_constructible}}，在这些实现中亦要求析构函数为平凡的：[https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452 GCC 漏洞 51452] {{lwg|2116}}。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;type_traits&gt;

class Foo
{
    int v1;
    double v2;
public:
    Foo(int n) : v1(n), v2() {}
    Foo(int n, double f) noexcept : v1(n), v2(f) {}
};

int main()
{
    auto is = [](bool o) { return (o ? "\t" "" : "\t" "不"); };
    std::cout &lt;&lt; "Foo ...\n"
              &lt;&lt; is(std::is_trivially_constructible_v&lt;Foo, const Foo&amp;&gt;)
              &lt;&lt; "可从 const Foo&amp; 平凡构造\n"
              &lt;&lt; is(std::is_trivially_constructible_v&lt;Foo, int&gt;)
              &lt;&lt; "可从 int 平凡构造\n"
              &lt;&lt; is(std::is_constructible_v&lt;Foo, int&gt;)
              &lt;&lt; "可从 int 构造\n"
              &lt;&lt; is(std::is_nothrow_constructible_v&lt;Foo, int&gt;)
              &lt;&lt; "可从 int 无抛出构造\n"
              &lt;&lt; is(std::is_nothrow_constructible_v&lt;Foo, int, double&gt;)
              &lt;&lt; "可从 int 和 double 无抛出构造\n";
}
|output=
Foo ...
        可从 const Foo&amp; 平凡构造
        不可从 int 平凡构造
        可从 int 构造
        不可从 int 无抛出构造
        可从 int 和 double 无抛出构造
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_default_constructible}}
{{dsc inc|cpp/types/dsc is_copy_constructible}}
{{dsc inc|cpp/types/dsc is_move_constructible}}
{{dsc inc|cpp/concepts/dsc constructible_from}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}