{{cpp/types/traits/is|1=is_implicit_lifetime
|std=c++23
|description=
如果 {{tt|T}} 是[[cpp/named req/ImplicitLifetimeType|隐式生存期类型]]，那么提供的成员常量 {{c|value}} 等于 {{c|true}}。对于其它任何类型，{{c|value}} 等于 {{c|false}}。

如果 {{tt|T}} 是除了数组类型和（可能有 cv 限定的）{{c|void}} 以外的不完整类型，那么行为未定义。
|inherit_desc={{tt|T}} 是隐式生存期类型
}}

===注解===
{{feature test macro|__cpp_lib_is_implicit_lifetime|std=C++23|value=202302L|{{tt|std::is_implicit_lifetime}}}}

===示例===
{{example
|code=
// 以下类型统称为隐式生存期类型：
// * 标量类型：
//     * 算术类型
//     * 枚举类型
//     * 指针类型
//     * 成员指针类型
//     * std::nullptr_t
// * 隐式生存期类类型
//     * 其为聚合体且其析构函数并非由用户提供
//     * 其具有至少一个平凡的合格构造函数和一个平凡的未弃置析构函数
// * 数组类型
// * 这些类型的 cv 限定版本
#include &lt;type_traits&gt;

static_assert(std::is_implicit_lifetime_v&lt;int&gt;); // 算术类型是标量类型
static_assert(std::is_implicit_lifetime_v&lt;const int&gt;); // cv 限定的标量类型

enum E { e };
static_assert(std::is_implicit_lifetime_v&lt;E&gt;); // 枚举类型是标量类型
static_assert(std::is_implicit_lifetime_v&lt;int*&gt;); // 指针类型是标量类型
static_assert(std::is_implicit_lifetime_v&lt;std::nullptr_t&gt;); // 标量类型

struct S { int x, y; };
// S 是隐式生存期类：没有用户提供析构函数的聚合体
static_assert(std::is_implicit_lifetime_v&lt;S&gt;);

static_assert(std::is_implicit_lifetime_v&lt;int S::*&gt;); // 成员指针

struct X { ~X() = delete; };
// 由于弃置的析构函数，X 不是隐式生存期类
static_assert(!std::is_implicit_lifetime_v&lt;X&gt;);

static_assert(std::is_implicit_lifetime_v&lt;int[8]&gt;); // 数组类型
static_assert(std::is_implicit_lifetime_v&lt;volatile int[8]&gt;); // cv 限定的数组类型

int main() {}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_scalar}}
{{dsc inc|cpp/types/dsc is_array}}
{{dsc inc|cpp/types/dsc is_aggregate}}
{{dsc inc|cpp/memory/dsc start_lifetime_as}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}