{{title|扩充命名空间 {{tt|std}}}}
{{cpp/language/navbar}}

===向 {{tt|std}} 添加声明===
向命名空间 {{tt|std}} 或 {{tt|std}} 中嵌套的任何命名空间添加声明或定义，除了下面提到的少数例外的情况下都是未定义行为。

{{source|
#include &lt;utility&gt;

namespace std
{
    // 向命名空间 std 添加函数：未定义行为
    pair&lt;int, int&gt; operator+(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b)
    {
        return {a.first + b.first, a.second + b.second};
    }
}
}}

===添加模板特化===
====类模板====
对于任何标准库类模板的模板特化，只有在它的声明依赖至少一个{{rlps|type#由程序定义的类型}}，且该特化满足原模板的所有要求时，才能向命名空间 {{tt|std}} 中添加，除非这种特化被禁止。

{{source|
// 获取主 std::hash 模板的声明。不能自己声明它。
// 保证 &lt;typeindex&gt; 提供这种声明，包含它比 &lt;functional&gt; 低廉很多。

#include &lt;typeindex&gt; 

// 特化 std::hash 使得 MyType 可以成为
// std::unordered_set 和 std::unordered_map 中的键。
// 直接展开命名空间 std 可能会引发未定义行为，而且特化类模板也不需要这样做。
template &lt;&gt;
struct std::hash&lt;MyType&gt;
{
    std::size_t operator()(const MyType&amp; t) const { return t.hash(); }
}; 
}}

* 未指明 {{c/core|float}}、{{c/core|double}}、{{c/core|long double}} 以外的类型特化 {{lc|std::complex}} 的效果。

* {{lc|std::numeric_limits}} 的特化必须对主模板中所有声明为 {{rev inl|until=c++11|{{c/core|static const}}}}{{rev inl|since=c++11|{{c/core|static constexpr}}}} 的成员进行定义，而且要使得它们能用作{{rlp|constant expression|整数常量表达式}}。
{{rrev|since=c++11|
* 除了 {{lc|std::common_type}} {{rev inl|since=c++20|和 {{ltt|cpp/types/common_reference#辅助类型|std::basic_common_reference}} }}以外，{{header|type_traits}} 中定义的模板均不可对由程序定义的类型特化。这包含各种[[cpp/types|类型特征]]和 {{lc|std::integral_constant}} 类模板。

* {{lc|std::hash}} 对由程序定义的类型的特化的必须满足{{named req|Hash}}要求。

* {{lc|std::atomic}} 的特化必须拥有弃置的复制构造函数，弃置的复制赋值运算符，和一个 constexpr 值构造函数。

* {{lc|std::shared_ptr}} 和 {{lc|std::weak_ptr}} 的特化必须满足{{named req|CopyConstructible}}和{{named req|CopyAssignable}}。另外，{{lc|std::shared_ptr}} 的特化必须满足{{named req|LessThanComparable}}，而且可以转换到 {{c|bool}}。

* {{lc|std::istreambuf_iterator}} 的特化必须有平凡的复制构造函数，constexpr 默认构造函数，和平凡的析构函数。
}}
{{rrev|until=c++17|
* 不能特化 {{lc|std::unary_function}} 和 {{lc|std::binary_function}}。
}}

声明标准库类或类模板的任何成员类模板的完全或部分特化都是未定义行为。
{{todo|小示例}}

====函数模板与模板的成员函数====
{{rrev multi|until1=c++20
|rev1=
对于任何标准库函数模板的模板特化，只有在它的声明依赖至少一个由程序定义的类型，且该特化满足原模板的所有要求时，才能向命名空间 {{tt|std}} 中添加，除非这种特化被禁止。
|rev2=
声明任何标准库函数模板的完全特化都是未定义行为。
}}
{{todo|小示例}}

声明标准库类模板的任何成员函数的完全特化都是未定义行为：
{{todo|小示例}}

声明标准库类或类模板的任何成员函数模板的完全特化都是未定义行为：
{{todo|小示例}}

====变量模板====
{{rrev|since=c++14|
声明任何标准库变量模板的完全特化或部分特化，除非明确允许，否则都是未定义行为。{{mark unreviewed dr|LWG|2954}}
{{todo|小示例}}
{{rrev|since=c++20|
* {{ltt|cpp/iterator/sized_sentinel_for|std::disable_sized_sentinel_for}}、{{ltt|cpp/ranges/sized_range|std::ranges::disable_sized_range}}、{{ltt|cpp/ranges/view|std::ranges::enable_view}} 和 {{ltt|cpp/ranges/borrowed_range|std::ranges::enable_borrowed_range}} 的特化必须能用于常量表达式并拥有 {{c/core|const bool}} 类型。而且
** {{tt|std::disable_sized_sentinel_for}} 可以对无 cv 限定的非数组对象类型 {{tt|S}} 与 {{tt|I}} 特化，需要其中至少有一个是由程序定义的类型。
** {{tt|std::ranges::disable_sized_range}}、{{tt|std::ranges::enable_view}} 和 {{tt|std::ranges::enable_borrowed_range}} 可以对无 cv 限定的由程序定义的类型的特化。
* 每个[[cpp/numeric/constants|数学常数变量模板]]都可以被部分或显式特化，只要该特化依赖由程序定义的类型。
}}
}}

===模板的显式实例化===
对于标准库中定义的{{rev inl|since=c++20|类}}模板的显式实例化，只有在它的声明依赖至少一个由程序定义的类型的名称，且实例化满足标准库对原始模板的要求时，才能进行显示实例化。
{{todo|小示例}}

===其他限制===
不能将命名空间 {{tt|std}} 声明为{{rlp|namespace#内联命名空间|内联命名空间}}。

{{rrev|since=c++20|
====取址限制====
如果 C++ 程序显式或隐式地尝试形成到标准库函数或标准库函数模板实例化的指针、引用（对于自由函数和静态成员函数）或成员指针（对于非静态成员函数），那么程序行为未指明（可能非良构），除非该函数被指定为''可取址函数''（见下文）。

下列代码在 C++17 中良定义，但从 C++20 起将导致未指定的行为，并且可能无法编译：
{{source|1=
#include &lt;cmath&gt;
#include &lt;memory&gt;

int main()
{
    // 通过一元 operator&amp;
    auto fptr0 = &amp;static_cast&lt;float(&amp;)(float, float)&gt;(std::betaf);

    // 通过 std::addressof
    auto fptr1 = std::addressof(static_cast&lt;float(&amp;)(float, float)&gt;(std::betaf));

    // 通过函数到指针隐式转换
    auto fptr2 = static_cast&lt;float(&amp;)(float)&gt;(std::riemann_zetaf);

    // 形成引用
    auto&amp; fref = static_cast&lt;float(&amp;)(float)&gt;(std::riemann_zetaf);
}
}}

====指定的可取址函数====
* [[cpp/io/manip|输入/输出操纵符]]：
** {{tt|fmtflags}} 操纵符：
*** {{lc|std::boolalpha}}
*** {{lc|std::boolalpha|std::noboolalpha}}
*** {{lc|std::showbase}}
*** {{lc|std::showbase|std::noshowbase}}
*** {{lc|std::showpoint}}
*** {{lc|std::showpoint|std::noshowpoint}}
*** {{lc|std::showpos}}
*** {{lc|std::showpos|std::noshowpos}}
*** {{lc|std::skipws}}
*** {{lc|std::skipws|std::noskipws}}
*** {{lc|std::uppercase}}
*** {{lc|std::uppercase|std::nouppercase}}
*** {{lc|std::unitbuf}}
*** {{lc|std::unitbuf|std::nounitbuf}}
** {{tt|adjustfield}} 操纵符：
*** {{lc|std::left|std::internal}}
*** {{lc|std::left}}
*** {{lc|std::left|std::right}}
** {{tt|basefield}} 操纵符：
*** {{lc|std::hex|std::dec}}
*** {{lc|std::hex}}
*** {{lc|std::hex|std::oct}}
** {{tt|floatfield}} 操纵符：
*** {{lc|std::fixed}}
*** {{lc|std::fixed|std::scientific}}
*** {{lc|std::fixed|std::hexfloat}}
*** {{lc|std::fixed|std::defaultfloat}}
** {{tt|basic_istream}} 操纵符：
*** {{lc|std::ws}}
** {{tt|basic_ostream}} 操纵符：
*** {{lc|std::endl}}
*** {{lc|std::ends}}
*** {{lc|std::flush}}
&lt;!-- 尚未建立映射
*** {{lc|std::emit_on_flush}}
*** {{lc|std::emit_on_flush|std::noemit_on_flush}}
*** {{lc|std::flush_emit}}
--&gt;
*** {{ltt|cpp/io/manip/emit_on_flush|std::emit_on_flush}}
*** {{ltt|cpp/io/manip/emit_on_flush|std::noemit_on_flush}}
*** {{ltt|cpp/io/manip/flush_emit|std::flush_emit}}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=120|std=C++98|before=用户可以以非用户定义类型显式实例化标准库模板|after=已禁止}}
{{dr list item|wg=lwg|dr=232|std=C++98|before=用户可以在声明依赖了具有外部链接的名字的情况下显式&lt;br&gt;特化标准库模板（即使该名字表示的不是用户定义类型）|after=仅限用户定义类型}}
{{dr list item|wg=lwg|dr=422|std=C++98|before=用户可以在不特化整个标准库类或类模板的情况下单独特化它的成员或成员模板|after=行为未定义}}
{{dr list end}}

{{langlinks|en|es|ja|ru}}