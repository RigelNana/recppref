{{title|默认构造函数}}
{{cpp/language/classes/navbar}}

默认构造函数是不需要提供实参就能调用的{{rlp|constructor|构造函数}}。

===语法===
{{sdsc begin}}
{{sdsc|num=1|{{spar sep|类名}}{{ttb|(}}{{spar optional|形参列表}}{{ttb|);}}}}
{{sdsc|num=2|{{spar sep|类名}}{{ttb|(}}{{spar optional|形参列表}}{{ttb|)}} {{spar|函数体}}}}
{{sdsc|num=3|{{spar sep|类名}}{{ttb|1=() = default;}}|notes={{mark since c++11}}}}
{{sdsc|num=4|{{spar sep|类名}}{{ttb|(}}{{spar optional|形参列表}}{{ttb|1=) = delete;}}|notes={{mark since c++11}}}}
{{sdsc|num=5|{{spar sep|类名}}{{ttb|::}}{{spar sep|类名}}{{ttb|(}}{{spar optional|形参列表}}{{ttb|)}} {{spar|函数体}}}}
{{sdsc|num=6|{{spar sep|类名}}{{ttb|::}}{{spar sep|类名}}{{ttb|1=() = default;}}|notes={{mark since c++11}}}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|类名}}|要声明默认构造函数的类}}
{{par|{{spar|形参列表}}|{{rlps|function#形参列表}}，其中{{rev inl|since=c++11|（{{rlp|parameter pack|形参包}}以外的）}}所有形参都有{{rlp|default arguments|默认实参}}}}
{{par|{{spar|函数体}}|默认构造函数的{{rlp|constructor|函数体}}}}
{{par end}}

===解释===
@1@ 类定义中的默认构造函数的声明。
@2-4@ 类定义中的默认构造函数的定义。
:@3@ 默认构造函数会被显式预置。
:@4@ 默认构造函数会被弃置。
@5,6@ 类定义之外的默认构造函数的定义（该类必须包含一条声明 {{v|1}}）。
:@6@ 默认构造函数会被显式预置。

默认构造函数会在{{rlp|default initialization|默认初始化}}和{{rlp|value initialization|值初始化}}中被调用。

===隐式声明的默认构造函数===
如果某个类类型没有用户声明的构造函数或构造函数模板，那么编译器会隐式声明一个作为它的类的 {{c/core|inline public}} 成员的默认构造函数。

隐式声明（或在它的首个声明被预置）的默认构造函数具有{{rev inl|until=c++17|{{rlp|except spec|动态异常说明}}}}{{rev inl|since=c++17|{{rlp|noexcept spec|异常说明}}}}中所描述的异常说明。

===隐式定义的默认构造函数===
如果{{rev inl|until=c++11|默认构造函数是隐式声明的}}{{rev inl|since=c++11|隐式声明的或显式预置的默认构造函数没有被定义为弃置的}}，那么当它被 {{rlp|definition#ODR 使用|ODR 使用}}{{rev inl|since=c++11|&lt;!-- P0859R0 --&gt;或者被{{rlp|constant expression#常量求值所需要的函数与变量|常量求值所需要}}}}时，编译器会隐式定义它。

{{rrev|since=c++26|
如果{{rlps|union#联合体式的类}} {{tt|T}} 的默认构造函数是平凡的，那么对于 {{tt|T}} 或 {{tt|T}} 的所有匿名联合体成员中的每个联合体 {{tt|U}}，如果 {{tt|U}} 的首个变体成员（如果存在）具有{{rlps|type#隐式生存期类型}}，那么 {{tt|T}} 的默认构造函数会在该成员不是它所在的联合体的活跃成员时开始该成员的生存期。
}}

{{rev inl|since=c++26|否则，}}隐式定义的默认构造函数与拥有空函数体和空初始化器列表的用户定义的构造函数有严格相同的效果。即它调用这个类的各基类和各非静态成员的默认构造函数。{{rlp|value initialization|值初始化}}过程中由用户提供的空构造函数和隐式定义的构造函数可能会以不同的方式处理。

{{rrev|since=c++11|
如果它满足对于 {{rev inl|until=c++23|{{rlp|constexpr#constexpr 构造函数|{{c/core|constexpr}} 构造函数}}}}{{rev inl|since=c++23|{{rlp|constexpr#constexpr 函数|{{c/core|constexpr}} 函数}}}}的要求，那么生成的构造函数是 {{c/core|constexpr}} 的。

当存在用户定义的构造函数时，用户仍可以通过关键词 {{c/core|default}} 强制编译器自动生成原本隐式声明的默认构造函数。
}}


{{rrev|since=c++11|
===弃置的默认构造函数===
如果满足以下任意条件，那么类 {{tt|T}} 中隐式声明的或显式预置的默认构造函数会被定义为弃置的：
* {{tt|T}} 有一个具有引用类型并且不带默认初始化器的非静态数据成员。
* {{tt|T}} {{rev inl|since=c++26|不是{{rlp|union|联合体}}，并且}}有一个具有有 const 限定但不{{rlp|default initialization#const 对象的默认初始化|可 const 默认构造}}的类型（或它的可以有多维的数组类型）并且不带默认初始化器的非变体非静态数据成员。
{{rrev|until=c++26|
* {{tt|T}} 是{{rlp|union|联合体}}，并且它所有的变体成员的类型都是有 const 限定的类型（或它的可以有多维的数组类型）。
* {{tt|T}} 不是联合体，并且它所有的{{rlps|union#匿名联合体}}成员的类型都是有 const 限定的类型（或它的可以有多维的数组类型）。
}}
* 给定类类型 {{tt|M}}，{{tt|T}} 有一个具有 {{tt|M}} 类型（或它的可以有多维的数组类型）的{{rlps|object#潜在构造的子对象}} {{c|obj}}，并且满足以下任意条件：
:* {{tt|M}} 有一个被弃置或无法从该默认构造函数访问的析构函数{{rev inl|since=c++26|，并且 {{c|obj}} 要么不是变体成员，要么带有默认初始化器}}。
:* 满足以下所有条件：
::* {{c|obj}} 不是带有默认初始化器的非静态数据成员。
::* {{c|obj}} 不是{{rev inl|until=c++26|其他所有非静态数据成员都不带默认初始化器的联合体}}的变体成员。
::* 为寻找 {{tt|M}} 的默认构造函数而进行的重载决议没有产生可用候选{{rev inl|until=c++26|，或者在 {{c|obj}} 是变体成员时，选择了非平凡的函数}}。

当不存在用户定义的构造函数，且隐式声明的默认构造函数非平凡时，用户仍可以通过关键词 {{c/core|delete}} 禁止编译器自动生成隐式定义的默认构造函数。
}}

===平凡默认构造函数===
如果满足以下所有条件，那么类 {{tt|T}} 的默认构造函数是平凡的：
* 构造函数{{rev inl|until=c++11|是隐式声明的}}{{rev inl|since=c++11|不是{{rlp|function#由用户提供的函数|由用户提供的}}}}。
* {{tt|T}} 没有虚成员函数。
* {{tt|T}} 没有虚基类。
{{rrev|since=c++11|
* {{tt|T}} 没有带有默认初始化器的非静态数据成员。
}}
* 每个 {{tt|T}} 的直接基类都拥有平凡默认构造函数
{{rev begin}}
{{rev|until=c++26|
* 每个类类型（或它的数组类型）的非静态成员都拥有平凡默认构造函数。
}}
{{rev|since=c++26|
* 要么 {{tt|T}} 是联合体，要么每个类类型（或它的数组类型）的非静态成员都拥有平凡默认构造函数。
}}
{{rev end}}

平凡默认构造函数是没有任何动作的构造函数。所有与 C 语言兼容的数据类型（POD 类型）都是可以平凡默认构造的。

===合格的默认构造函数===
{{cpp/language/eligible special member function|默认构造函数}}

合格的默认构造函数的平凡性确定该类是否为{{rlps|type#隐式生存期类型}}，以及该类是否为{{rlps|type#可平凡复制类型}}。

===注解===
{{feature test macro|__cpp_trivial_union|放松对联合体的特殊成员函数的平凡性要求|value=202502L|std=C++26}}

===示例===
{{example|code=
struct A
{
    int x;
    A(int x = 1): x(x) {} // 用户定义默认构造函数
};

struct B: A
{
    // 隐式定义 B::B()，调用 A::A()
};

struct C
{
    A a;
    // 隐式定义 C::C()，调用 A::A()
};

struct D: A
{
    D(int y): A(y) {}
    // 不会声明 D::D()，因为已经有其他构造函数
};

struct E: A
{
    E(int y): A(y) {}
    E() = default; // 显式预置，调用 A::A()
};

struct F
{
    int&amp; ref; // 引用成员
    const int c; // const 成员
    // F::F() 被隐式定义为弃置的
};

// 用户声明的复制构造函数（由用户提供，被弃置或被预置）
// 防止隐式生成默认构造函数

struct G
{
    G(const G&amp;) {}
    // G::G() 被隐式定义为弃置的
};

struct H
{
    H(const H&amp;) = delete;
    // H::H() 被隐式定义为弃置的
};

struct I
{
    I(const I&amp;) = default;
    // I::I() 被隐式定义为弃置的
};

int main()
{
    A a;
    B b;
    C c;
//  D d; // 编译错误
    E e;
//  F f; // 编译错误
//  G g; // 编译错误
//  H h; // 编译错误
//  I i; // 编译错误
}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1353|std=C++98|before=不定义隐式声明的默认构造函数的条件没有考虑多维数组类型|after=考虑这些类型}}
{{dr list item|wg=cwg|dr=2084|std=C++11|before=默认成员初始化器对预置的联合体默认构造函数是否被弃置没有影响|after=它们阻止预置默认构造函数被定义为弃置的}}
{{dr list item|wg=cwg|dr=2595|std=C++20|before=对于一个默认构造函数，如果存在其他更受约束但&lt;br&gt;无法满足关联约束的默认构造函数，那么它无法合格|after=此时它可以合格}}
{{dr list item|wg=cwg|dr=2871|std=C++98|before=即使在有用户声明的构造函数模板的情况下也会隐式声明默认构造函数|after=此时不会隐式声明}}
{{dr list end}}

===参阅===
* {{rlp|constructor|构造函数}}
* {{rlp|initialization|初始化}}
** {{rlp|aggregate initialization|聚合初始化}}
** {{rlp|constant initialization|常量初始化}}
** {{rlp|copy initialization|复制初始化}}
** {{rlp|default initialization|默认初始化}}
** {{rlp|direct initialization|直接初始化}}
** {{rlp|list initialization|列表初始化}}
** {{rlp|reference initialization|引用初始化}}
** {{rlp|value initialization|值初始化}}
** {{rlp|zero initialization|零初始化}}
* {{rlpt|new}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}