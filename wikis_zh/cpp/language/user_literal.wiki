{{title|用户定义字面量 {{mark since c++11}}}}
{{cpp/language/expressions/navbar}}

通过定义用户定义的后缀，允许整数、浮点数、字符及字符串字面量产生用户定义类型的对象。

===语法===
用户定义字面量是下列形式的表达式之一：
{{sdsc begin}}
{{sdsc|since=c++11|num=1|{{spar|十进制字面量}} {{spar|用户定义后缀}}}}
{{sdsc|since=c++11|num=2|{{spar|八进制字面量}} {{spar|用户定义后缀}}}}
{{sdsc|since=c++11|num=3|{{spar|十六进制字面量}} {{spar|用户定义后缀}}}}
{{sdsc|since=c++14|num=4|{{spar|二进制字面量}} {{spar|用户定义后缀}}}}
{{sdsc|since=c++11|num=5|{{spar|分数常量}} {{spar optional|指数部分}} {{spar|用户定义后缀}}}}
{{sdsc|since=c++11|num=6|{{spar|数字序列}} {{spar|指数部分}} {{spar|用户定义后缀}}}}
{{sdsc|since=c++11|num=7|{{spar|字符字面量}} {{spar|用户定义后缀}}}}
{{sdsc|since=c++11|num=8|{{spar|字符串字面量}} {{spar|用户定义后缀}}}}
{{sdsc end}}
@1-4@ 用户定义整数字面量，例如 {{c|12_km}}
@5-6@ 用户定义浮点数字面量，例如 {{c|0.5_Pa}}
@7@ 用户定义字符字面量，例如 {{c|'c'_X}}
@8@ 用户定义字符串字面量，例如 {{c|"abd"_L}} 或 {{c|u"xyz"_M}}

{{par begin}}
{{par|{{spar|十进制字面量}}|与{{rlp|integer literal|整数字面量}}中相同，非零的十进制数位后随零或多个十进制数位}}
{{par|{{spar|八进制字面量}}|与{{rlp|integer literal|整数字面量}}中相同，零后随零或多个八进制数位}}
{{par|{{spar|十六进制字面量}}|与{{rlp|integer literal|整数字面量}}中相同，{{tt|0x}} 或 {{tt|0X}} 后随一个或多个十六进制数位}}
{{par|{{spar|二进制字面量}}|与{{rlp|integer literal|整数字面量}}中相同，{{tt|0b}} 或 {{tt|0B}} 后随一或多个二进制数位}}
{{par|{{spar|数字序列}}|与{{rlp|floating literal|浮点数字面量}}中相同，一个十进制数字序列}}
{{par|{{spar|分数常量}}|与{{rlp|floating literal|浮点数字面量}}中相同，要么是一个后随小数点的 {{spar|数字序列}}（{{c|123.}}），要么是一个可选的 {{spar|数字序列}} 后随小数点和另一个 {{spar|数字序列}}（{{c|1.0}} 或 {{c|.12}}）}}
{{par|{{spar|指数部分}}|与{{rlp|floating literal|浮点数字面量}}中相同，字母 {{tt|e}} 或字母 {{tt|E}} 后随可选的正负号，后随 {{spar|数字序列}}}}
{{par|{{spar|字符字面量}}|与{{rlp|character literal|字符字面量}}中相同 }}
{{par|{{spar|字符串字面量}}|与{{rlp|string literal|字符串字面量}}中相同，包括原始字符串字面量}}
{{par|{{spar|用户定义后缀}}|标识符，由''字面量运算符''或''字面量运算符模板''声明引入（见[[#字面量运算符|下文]]）}}
{{par end}}

{{rrev|since=c++14|
在{{rlp|integer literal#单引号|整数}}和{{rlp|floating literal#单引号|浮点数}}数字序列中，可以在任何两个数位间插入分隔符 {{ttb|'}}，并忽略它们。
}}

如果一个记号同时匹配用户定义字面量的语法和普通字面量的语法，那么它被假定为普通字面量（即不可能重载 {{c|123LL}} 中的 {{c|LL}}）。

当编译器遇到一个带有 {{spar|用户定义后缀}} {{tt|X}} 的用户定义字面量时，它进行{{rlp|lookup#无限定名字查找|无限定名字查找}}，寻找名为 {{tt|operator ""X}} 的函数。如果找不到任何声明，那么程序非良构。否则，
@1@ 对于用户定义整数字面量：
:@a@ 如果重载集包含带有形参类型 {{c/core|unsigned long long}} 的字面量运算符，那么用户定义字面量表达式会被当做函数调用 {{box|{{c/core|operator ""X(}}{{spar sep|n}}{{c/core|ULL)}}}}，其中 {{spar|n}} 是无 {{spar|用户定义后缀}} 的该字面量；
:@b@ 否则，重载集要么包含原始字面量运算符，要么数值字面量运算符模板。如果重载集包含原始字面量运算符，那么用户定义字面量表达式会被当做函数调用 {{box|{{c/core|operator""X("}}{{spar sep|n}}{{c/core|")}}}}；
:@c@ 否则，如果重载集包含数值字面量运算符模板，则用户定义字面量表达式被当做函数调用 {{box|{{c/core|operator""X&lt;'}}{{spar sep|c1}}{{c/core|'}}{{c/core|, '}}{{spar sep|c2}}{{c/core|'}}{{c/core|, '}}{{spar sep|c3}}{{c/core|'}}{{c/core|..., '}}{{spar sep|ck}}{{c/core|'}}{{c/core|&gt;()}}}}，其中 {{spar|c1}}..{{spar|ck}} 是 {{spar|n}} 中的各个字符且它们都来自{{rlp|charset#基本字符集|基本字符集}}。
@2@ 对于用户定义浮点数字面量：
:@a@ 如果重载集包含带有形参类型 {{c/core|long double}} 的字面量运算符，那么用户定义字面量表达式会被当做函数调用 {{box|{{c/core|operator ""X(}}{{spar sep|f}}{{c/core|L)}}}}，其中 {{spar|f}} 是无 {{spar|用户定义后缀}} 的该字面量；
:@b@ 否则，重载集包含原始字面量运算符和数值字面量运算符模板其中的一种。如果重载集包含原始字面量运算符，那么用户定义字面量表达式会被当做函数调用 {{box|{{c/core|operator ""X("}}{{spar sep|f}}{{c/core|")}}}}；
:@c@ 否则，如果重载集包含数值字面量运算符模板，那么用户定义字面量表达式会被当做函数调用 {{box|{{c/core|operator""X&lt;'}}{{spar sep|c1}}{{c/core|'}}{{c/core|, '}}{{spar sep|c2}}{{c/core|'}}{{c/core|, '}}{{spar sep|c3}}{{c/core|'}}{{c/core|..., '}}{{spar sep|ck}}{{c/core|'}}{{c/core|&gt;()}}}}，其中 {{spar|c1}}..{{spar|ck}} 是 {{spar|f}} 中的各个字符且它们都来自{{rlp|charset#基本字符集|基本字符集}}。
@3@ 对于用户定义字符串字面量，令 {{c|str}} 为无 {{spar|用户定义后缀}} 的字面量：

{{rrev|since=c++20|1=
:@a@ 如果重载集包含带非类型模板形参的字符串字面量运算符模板，且 {{c|str}} 对它是良构的模板实参，则用户定义字面量表达式被当作函数调用 {{c|operator ""X&lt;str&gt;()}}；
}}
:@b@ 否则，用户定义字面量表达式被当做函数调用 {{c|operator ""X(str, len)}}，其中 {{c|len}} 是字符串字面量的长度，不包含终止空字符。
@4@ 对于用户定义字符字面量，用户定义字面量表达式被当做函数调用 {{c|operator ""X(ch)}}，其中 {{c|ch}} 是无 {{spar|用户定义后缀}} 的该字面量。

{{source|1=
long double operator ""_w(long double);
std::string operator ""_w(const char16_t*, size_t);
unsigned    operator ""_w(const char*);

int main()
{
    1.2_w;    // 调用 operator ""_w(1.2L)
    u"one"_w; // 调用 operator ""_w(u"one", 3)
    12_w;     // 调用 operator ""_w("12")
    "two"_w;  // 错误：没有适用的字面量运算符
}
}}

当在{{rlp|translation phases#阶段 6|翻译阶段 6}} 中发生字符串字面量的拼接时，用户定义字符串字面量也会被拼接，且其 {{spar|用户定义后缀}} 在拼接时被忽略，但所有被拼接的字面量中只可以出现一个后缀：
{{source|1=
int main()
{
    L"A" "B" "C"_x;  // OK：同 L"ABC"_x
    "P"_x "Q" "R"_y; // 错误：两个不同的用户定义后缀（_x 与 _y）
}
}}

===字面量运算符===
用户定义字面量所调用的函数被称为''字面量运算符''（如果它是模板，那么它被称为''字面量运算符模板''）。它的声明恰如任何其他命名空间作用域的{{rlp|function|函数}}或{{rlp|function template|函数模板}}一样（它可以是友元函数、函数模板的显式实例化或特化，或通过 using 声明引入），但有下列限制：

此函数的名称可拥有两种形式之一：
{{sdsc begin}}
{{sdsc|{{ttb|operator}} {{ttb|""}} {{spar|标识符}}|num=1|notes={{mark deprecated}}}}
{{sdsc|{{ttb|operator}} {{spar|用户定义字符串字面量}}|num=2}} 
{{sdsc end}}
{{par begin}}
{{par|{{spar|标识符}}|作为用户定义字面量所用且会调用此函数的 {{spar|用户定义后缀}} 的{{rlp|identifiers|标识符}}}}
{{par|{{spar|用户定义字符串字面量}}|字符序列 {{ttb|""}} 后不带空格，后随将作为 {{spar|用户定义后缀}} 的字符序列}}
{{par end}}

@1@ 声明字面量运算符。
@2@ 声明字面量运算符。这种语法允许将语言关键词和[[cpp/keywords|保留标识符]]用作 {{spar|用户定义后缀}}，例如来自标头 {{header|complex}} 的 {{c/core|operator ""if}}。

{{spar|用户定义后缀}} 必须以下划线 {{ttb|_}} 开始：不以下划线开始的后缀为标准库提供的字面量运算符所保留。
{{spar|用户定义后缀}} 也不能包含双下划线 {{ttb|__}}：此类后缀也被保留。

如果字面量运算符是模板，那么它必须有空形参列表，并且只能有一个模板形参，模板形参必须是元素类型是 {{c/core|char}} 的非类型模板形参包（此时称之为''数值字面量运算符模板''）：
{{source|1=
template&lt;char...&gt;
double operator ""_x();
}}
{{rrev|since=c++20|1=
或类类型的非类型模板形参（此时称之为''字符串字面量运算符模板''）：
{{source|1=
struct A { constexpr A(const char*); };

template&lt;A a&gt;
A operator ""_a();
}}
}}

字面量运算符仅允许下列形参列表：
{{sdsc begin}}
{{sdsc|num=1|{{ttb|(}} {{c/core|const char*}} {{ttb|)}}}}
{{sdsc|num=2|{{ttb|(}} {{c/core|unsigned long long int}} {{ttb|)}}}}
{{sdsc|num=3|{{ttb|(}} {{c/core|long double}} {{ttb|)}}}}
{{sdsc|num=4|{{ttb|(}} {{c/core|char}} {{ttb|)}}}}
{{sdsc|num=5|{{ttb|(}} {{c/core|wchar_t}} {{ttb|)}}}}
{{sdsc|num=6|{{ttb|(}} {{c/core|char8_t}} {{ttb|)}}|notes={{mark since c++20}}}}
{{sdsc|num=7|{{ttb|(}} {{c/core|char16_t}} {{ttb|)}}}}
{{sdsc|num=8|{{ttb|(}} {{c/core|char32_t}} {{ttb|)}}}}
{{sdsc|num=9|{{ttb|(}} {{c/core|const char*}}{{ttb|,}} {{lc|std::size_t}} {{ttb|)}}}}
{{sdsc|num=10|{{ttb|(}} {{c/core|const wchar_t*}}{{ttb|,}} {{lc|std::size_t}} {{ttb|)}}}}
{{sdsc|num=11|{{ttb|(}} {{c/core|const char8_t*}}{{ttb|,}} {{lc|std::size_t}} {{ttb|)}}|notes={{mark since c++20}}}}
{{sdsc|num=12|{{ttb|(}} {{c/core|const char16_t*}}{{ttb|,}} {{lc|std::size_t}} {{ttb|)}}}}
{{sdsc|num=13|{{ttb|(}} {{c/core|const char32_t*}}{{ttb|,}} {{lc|std::size_t}} {{ttb|)}}}}
{{sdsc end}}
@1@ 拥有此形参列表的字面量运算符是''原始字面量运算符''，用于整数和浮点数用户定义字面量的后备方式（见上文）
@2@ 拥有这些形参列表的字面量运算符是用户定义整数字面量的首选字面量运算符
@3@ 拥有这些形参列表的字面量运算符是用于定义浮点数字面量的首选字面量运算符
@4-8@ 拥有这些形参列表的字面量运算符由用户定义的字符字面量所调用
@9-13@ 拥有这些形参列表的字面量运算符由用户定义的字符串字面量所调用

不能有{{rlp|default arguments|默认实参}}。

不允许 C {{rlp|language linkage|语言链接}}。

除了上述限制外，字面量运算符和字面量运算符模板都是普通的函数（和函数模板），它们可声明为 inline 或 constexpr，它们可拥有内部或外部链接，它们可显式调用，可被取地址，等等。

{{example
|code=
#include &lt;string&gt;

void        operator ""_km(long double); // OK ，将为 1.0_km 所调用
void        operator "" _km(long double); // 同上，弃用
std::string operator ""_i18n(const char*, std::size_t); // OK

template &lt;char...&gt;
double operator ""_π(); // OK
float  operator ""_e(const char*); // OK
 
// 错误：后缀必须以下划线开始
float operator ""Z(const char*);

// 错误：所有以下划线后随大写字母开始的名称受到保留（注意 "" 和 _ 之间的空格）
double operator"" _Z(long double);

// OK：注意 "" 和 _ 之间没有空格
double operator""_Z(long double);

// OK：可以重载字面量运算符
double operator ""_Z(const char* args);

int main() {}
}}

===注解===
自从引入用户定义字面量之后，使用[[cpp/types/integer|定宽整数类型格式化宏常量]]且未在前导字符串字面量后加空格的情况变为非法：{{c|std::printf("%"PRId64"\n",INT64_MIN);}} 必须替换成 {{c|std::printf("%" PRId64"\n",INT64_MIN);}}

由于{{rlp|translation phases#最大吞噬|最大吞噬规则}}，以 {{rev inl|since=c++17|{{tt|p}}、{{tt|P}}、}}{{tt|e}} 和 {{tt|E}} 结束的用户定义整数和浮点数字面量，在后随运算符 {{tt|+}} 或 {{tt|-}} 时，必须在源码中以空白符或括号与运算符分隔：
{{source|1=
long double operator""_E(long double);
long double operator""_a(long double);
int operator""_p(unsigned long long);

auto x = 1.0_E+2.0;   // 错误
auto y = 1.0_a+2.0;   // OK
auto z = 1.0_E +2.0;  // OK
auto q = (1.0_E)+2.0; // OK
auto w = 1_p+2;       // 错误
auto u = 1_p +2;      // OK
}}

同样的规则适用于整数或浮点数用户定义字面量后的点运算符：
{{source|1=
#include &lt;chrono&gt;

using namespace std::literals;

auto a = 4s.count();   // 错误
auto b = 4s .count();  // OK
auto c = (4s).count(); // OK
}}

否则会组成单个非法预处理数字记号（例如 {{c|1.0_E+2.0}} 或 {{c|4s.count}}），这会导致编译失败。
{{feature test macro|__cpp_user_defined_literals|用户定义字面量|value=200809L|std=C++11}}

===关键词===
{{ltt|cpp/keyword/operator}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;numbers&gt;
#include &lt;string&gt;

// 用作从度（输入参数）转换为弧度（返回输出）
constexpr long double operator""_deg_to_rad(long double deg)
{
    long double radians = deg * std::numbers::pi_v&lt;long double&gt; / 180;
    return radians;
}

// 用作自定义类型
struct mytype
{
    unsigned long long m;
};

constexpr mytype operator""_mytype(unsigned long long n)
{
    return mytype{n};
}

// 用作副作用
void operator""_print(const char* str)
{
    std::cout &lt;&lt; str &lt;&lt; '\n';
}

#if __cpp_nontype_template_args &lt; 201911

std::string operator""_x2(const char* str, std::size_t)
{
    return std::string{str} + str;
}

#else // C++20 字符串字面量运算符模板

template&lt;std::size_t N&gt;
struct DoubleString
{
    char p[N * 2 - 1]{};
    
    constexpr DoubleString(char const(&amp;pp)[N])
    {
        std::ranges::copy(pp, p);
        std::ranges::copy(pp, p + N - 1);
    };
};

template&lt;DoubleString A&gt;
constexpr auto operator""_x2()
{
    return A.p;
}

#endif // C++20

int main()
{
    double x_rad = 90.0_deg_to_rad;
    std::cout &lt;&lt; std::fixed &lt;&lt; x_rad &lt;&lt; '\n';
    
    mytype y = 123_mytype;
    std::cout &lt;&lt; y.m &lt;&lt; '\n';
    
    0x123ABC_print;
    std::cout &lt;&lt; "abc"_x2 &lt;&lt; '\n';
}
|output=
1.570796
123
0x123ABC
abcabc
}}

===标准库===
标准库中定义了下列字面量运算符：
{{dsc begin}}
{{dsc namespace|std::literals::complex_literals|inline=true}}
{{dsc inc|cpp/numeric/dsc operator""i}}
{{dsc namespace|std::literals::chrono_literals|inline=true}}
{{dsc inc|cpp/chrono/dsc operator""h}}
{{dsc inc|cpp/chrono/dsc operator""min}}
{{dsc inc|cpp/chrono/dsc operator""s}}
{{dsc inc|cpp/chrono/dsc operator""ms}}
{{dsc inc|cpp/chrono/dsc operator""us}}
{{dsc inc|cpp/chrono/dsc operator""ns}}
{{dsc inc|cpp/chrono/dsc operator""y}}
{{dsc inc|cpp/chrono/dsc operator""d}}
{{dsc namespace|std::literals::string_literals|inline=true}}
{{dsc inc|cpp/string/basic_string/dsc operator""s}}
{{dsc namespace|std::literals::string_view_literals|inline=true}}
{{dsc inc|cpp/string/basic_string_view/dsc operator""sv}}
{{dsc end}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1473|std=C++11|before=字面量运算符声明中曾要求 {{c/core|""}} 与 {{spar|用户定义后缀}} 间的空格|after=不再强制要求}}
{{dr list item|wg=cwg|dr=1479|std=C++11|before=字面量运算符可以有默认实参|after=不能有默认实参}}
{{dr list item|wg=cwg|dr=2521|std=C++11|before={{c/core|operator"" _Bq}} 使用了保留的标识&lt;br&gt;符 {{tt|_Bq}}，因此它非良构（不要求诊断）|after=弃用 {{c/core|""}} 和 {{spar|用户定义后缀}} 之间&lt;br&gt;有空格的字面量运算符语法}}
{{dr list end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}