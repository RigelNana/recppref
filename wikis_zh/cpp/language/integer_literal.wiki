{{title|整数字面量}}
{{cpp/language/expressions/navbar}}
允许在表达式中直接使用整数类型的值。

===语法===
整数字面量拥有以下形式
{{sdsc begin}}
{{sdsc|num=1|{{spar|十进制字面量}} {{spar optional|整数后缀}}}}
{{sdsc|num=2|{{spar|八进制字面量}} {{spar optional|整数后缀}}}}
{{sdsc|num=3|{{spar|十六进制字面量}} {{spar optional|整数后缀}}}}
{{sdsc|num=4|notes={{mark since c++14}}|{{spar|二进制字面量}} {{spar optional|整数后缀}}}}
{{sdsc end}}
其中
* {{spar|十进制字面量}} 是一个非零十进制数字（{{tt|1}}、{{tt|2}}、{{tt|3}}、{{tt|4}}、{{tt|5}}、{{tt|6}}、{{tt|7}}、{{tt|8}}、{{tt|9}}）后随零或多个十进制数字（{{tt|0}}、{{tt|1}}、{{tt|2}}、{{tt|3}}、{{tt|4}}、{{tt|5}}、{{tt|6}}、{{tt|7}}、{{tt|8}}、{{tt|9}}）
* {{spar|八进制字面量}} 是数字零（{{tt|0}}）后随零或多个八进制数字（{{tt|0}}、{{tt|1}}、{{tt|2}}、{{tt|3}}、{{tt|4}}、{{tt|5}}、{{tt|6}}、{{tt|7}}）
* {{spar|十六进制字面量}} 是字符序列 {{tt|0x}} 或字符序列 {{tt|0X}} 后随一或多个十六进制数字（{{tt|0}}、{{tt|1}}、{{tt|2}}、{{tt|3}}、{{tt|4}}、{{tt|5}}、{{tt|6}}、{{tt|7}}、{{tt|8}}、{{tt|9}}、{{tt|a}}、{{tt|A}}、{{tt|b}}、{{tt|B}}、{{tt|c}}、{{tt|C}}、{{tt|d}}、{{tt|D}}、{{tt|e}}、{{tt|E}}、{{tt|f}}、{{tt|F}}）
* {{spar|二进制字面量}} 是字符序列 {{tt|0b}} 或字符序列 {{tt|0B}} 后随一或多个二进制数字（{{tt|0}}、{{tt|1}}）
* 若提供 {{spar|整数后缀}}，则可含有下列一或两者（若均提供，则可以任意顺序出现）：
:* {{spar|无符号后缀}}（字符 {{tt|u}} 或字符 {{tt|U}}）
:* 以下之一
::* {{spar|长后缀}}（字符 {{tt|l}} 或字符 {{tt|L}}）
{{rrev|since=c++11|
::* {{spar|长长后缀}}（字符序列 {{tt|ll}} 或字符序列 {{tt|LL}}）
}}
{{rrev|since=c++23|
::* {{spar|大小后缀}}（字符 {{tt|z}} 或字符 {{tt|Z}}）
}}
{{anchor|单引号}}
{{rrev|since=c++14|
数字之间可插入作为分隔符的可选的单引号（{{tt|'}}）。编译器会忽略它们。
}}
整数字面量（与任何字面量相同）是{{rlp|expressions#初等表达式|初等表达式}}。

===解释===
@1@ 十进制整数字面量（以 10 为底）
@2@ 八进制整数字面量（以 8 为底）
@3@ 十六进制整数字面量（以 16 为底，字母 'a' 到 'f' 表示（十进制）值 10 到 15）
@4@ 二进制整数字面量（以 2 为底）

整数字面量的首位为最高位。

例如，下列变量被初始化为相同值：
{{source|1=
int d = 42;
int o = 052;
int x = 0x2a;
int X = 0X2A;
int b = 0b101010; // C++14
}}

例如，下列变量也被初始化为相同值：
{{source|1=
unsigned long long l1 = 18446744073709550592ull;       // C++11
unsigned long long l2 = 18'446'744'073'709'550'592llu; // C++14
unsigned long long l3 = 1844'6744'0737'0955'0592uLL;   // C++14
unsigned long long l4 = 184467'440737'0'95505'92LLU;   // C++14
}}

===字面量的类型===
整数字面量的类型，是依赖于所用数字基底和 {{spar|整数后缀}} 确定的列表中，首个能适合其值的类型。

{| class="wikitable"
|- style="text-align:center"
! 后缀
! 十进制底
! 二进制，八进制或十六进制底
|- style="text-align:left"
| （无后缀）
|
* {{c/core|int}}
* {{c/core|long int}}
* {{c/core|long long int}} {{mark since c++11}}
|
* {{c/core|int}}
* {{c/core|unsigned int}}
* {{c/core|long int}}
* {{c/core|unsigned long int}}
* {{c/core|long long int}} {{mark since c++11}}
* {{c/core|unsigned long long int}} {{mark since c++11}}
|-
| {{tt|u}} 或 {{tt|U}}
|
* {{c/core|unsigned int}}
* {{c/core|unsigned long int}}
* {{c/core|unsigned long long int}} {{mark since c++11}}
|
* {{c/core|unsigned int}}
* {{c/core|unsigned long int}}
* {{c/core|unsigned long long int}} {{mark since c++11}}
|-
| {{tt|l}} 或 {{tt|L}}
|
* {{c/core|long int}}
* {{c/core|unsigned long int}} {{mark until c++11}}
* {{c/core|long long int}} {{mark since c++11}}
|
* {{c/core|long int}}
* {{c/core|unsigned long int}}
* {{c/core|long long int}} {{mark since c++11}}
* {{c/core|unsigned long long int}} {{mark since c++11}}
|-
| 同时有 {{tt|l}}/{{tt|L}} 和 {{tt|u}}/{{tt|U}}
|
*{{c/core|unsigned long int}}
*{{c/core|unsigned long long int}} {{mark since c++11}}
|
* {{c/core|unsigned long int}}
* {{c/core|unsigned long long int}} {{mark since c++11}}
|-
| {{tt|ll}} 或 {{tt|LL}}
|
* {{c/core|long long int}} {{mark since c++11}}
|
* {{c/core|long long int}} {{mark since c++11}}
* {{c/core|unsigned long long int}} {{mark since c++11}}
|-
| 同时有 {{tt|ll}}/{{tt|LL}} 和 {{tt|u}}/{{tt|U}}
|
* {{c/core|unsigned long long int}} {{mark since c++11}}
|
* {{c/core|unsigned long long int}} {{mark since c++11}}
|-
| {{tt|z}} 或 {{tt|Z}}
|
* {{lc|std::size_t}} 的有符号版本 {{mark since c++23}}
|
* {{lc|std::size_t}} 的有符号版本 {{mark since c++23}}
* {{lc|std::size_t}} {{mark since c++23}}
|-
| 同时有 {{tt|z}}/{{tt|Z}} 和 {{tt|u}}/{{tt|U}}
|
* {{lc|std::size_t}} {{mark since c++23}}
|
* {{lc|std::size_t}} {{mark since c++23}}
|}

若{{rev inl|since=c++23|不具有 {{spar|大小后缀}} 的}}整数字面量的值过大从而无法符合任何后缀/底组合所允许的类型，且编译器支持能表示该字面量的值的扩展整数类型（如 {{c|__int128}}），则字面量可以被授予该扩展整数类型——否则程序非良构。

===注解===
整数字面量中的字母是无关大小写的：{{tt|0xDeAdBaBeU}} 与 {{tt|0XdeadBABEu}} 表示同一数值{{rev inl|since=c++11|（一个例外是 {{spar|长长后缀}}，它是 {{tt|ll}} 或 {{tt|LL}}，而决不能是 {{tt|lL}} 或 {{tt|Ll}}）}}

没有负整数字面量。如 {{c|-1}} 这样的表达式对字面量所表示的值运用{{rlp|operator_arithmetic|一元减运算符}}，这可能涉及隐式转换。

在 C99 之前的 C 中（但不是 C++ 中），不符合 {{c/core|long int}} 的无后缀十进制值允许拥有类型 {{c/core|unsigned long int}}。

{{rrev|since=c++11|
当用于 {{ltt|cpp/preprocessor/conditional|#if}} 或 {{ltt|c/preprocessor/conditional|#elif}} 的控制表达式时，全部有符号整数常量表现如同它们具有 {{lc|std::intmax_t}} 类型，而全部无符号整数常量表现如同它们具有 {{lc|std::uintmax_t}} 类型。
}}

由于{{rlp|translation_phases#最大吞噬|最大吞噬}}规则，以 {{ttb|e}} 和 {{ttb|E}} 结束的十六进制整数字面量在后随运算符 {{ttb|+}} 或 {{ttb|-}} 时，源码中必须以空白符或括号将它们与运算符分隔：

{{source|1=
auto x = 0xE+2.0;   // 错误
auto y = 0xa+2.0;   // OK
auto z = 0xE +2.0;  // OK
auto q = (0xE)+2.0; // OK
}}

否则，将构成一个非法的预处理数字记号，并导致进一步的分析失败。

{{ftm begin|std=1|comment=1}}
{{ftm|value=201304L|std=C++14|__cpp_binary_literals|[[#语法|二进制字面量]]}}
{{ftm|value=202011L|std=C++23|__cpp_size_t_suffix|{{lc|std::size_t}} 及其有符号版本的字面量后缀}}
{{ftm end}}

===示例===
{{example|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;

int main()
{
std::cout &lt;&lt; 123    &lt;&lt; '\n'
          &lt;&lt; 0123   &lt;&lt; '\n'
          &lt;&lt; 0x123  &lt;&lt; '\n'
          &lt;&lt; 0b10   &lt;&lt; '\n'
          &lt;&lt; 12345678901234567890ull &lt;&lt; '\n'
          &lt;&lt; 12345678901234567890u   &lt;&lt; '\n'; // 类型是 unsigned long long
                                              // 即使无 long long 后缀

//   std::cout &lt;&lt; -9223372036854775808 &lt;&lt; '\n'; // 错误：值 9223372036854775808
                // 不吻合 signed long long，这是无后缀整数字面量允许的最大类型
     std::cout &lt;&lt; -9223372036854775808u &lt;&lt; '\n'; // 应用于无符号值的一元减
                // 从 2^64 减去该值，给出 9223372036854775808
     std::cout &lt;&lt; -9223372036854775807 - 1 &lt;&lt; '\n'; // 计算值 -9223372036854775808
                                                    // 的正确方式

#if __cpp_size_t_suffix &gt;= 202011L // C++23
     static_assert(std::is_same_v&lt;decltype(0UZ), std::size_t&gt;);
     static_assert(std::is_same_v&lt;decltype(0Z), std::make_signed_t&lt;std::size_t&gt;&gt;);
#endif
}
|output=
123
83
291
2
12345678901234567890
12345678901234567890
9223372036854775808
-9223372036854775808
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=2698|std=C++23|before=拥有 {{spar|大小后缀}} 的整数字面量能拥有扩展整数类型|after=若过大则为非良构}}
{{dr list end}}

===引用===
{{ref std c++23}}
{{ref std|section=5.13.2|title=Integer literals|id=lex.icon}}
&lt;!--{{ref std| section = 7.5.1 | title= Literals|id =expr.prim.literal}}
This is the source for the claim "An integer literal (as any literal) is a primary expression. "
It could be added here, but it should probably be added to the expressions page instead--&gt;
{{ref std end}}
{{ref std c++20}}
{{ref std|section=5.13.2|title=Integer literals|id=lex.icon}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=5.13.2|title=Integer literals|id=lex.icon}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=2.14.2|title=Integer literals|id=lex.icon}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=2.14.2|title=Integer literals|id=lex.icon}}
{{ref std end}}
&lt;!--{{ref std c++03}}
{{ref std|section=2.13.1|title=Integer literals|id=lex.icon}}
{{ref std end}}--&gt;
{{ref std c++98}}
{{ref std|section=2.13.1|title=Integer literals|id=lex.icon}}
{{ref std end}}

===参阅===
{{dsc begin}}
{{dsc inc | cpp/language/dsc user_literal}}
{{dsc see c | c/language/integer_constant |整数常量|nomono=true}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}