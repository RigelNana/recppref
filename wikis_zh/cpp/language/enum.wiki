{{title|枚举声明}}
{{cpp/language/declarations/navbar}}

''枚举''{{sep}}是一种独立的类型，它的值被限制在一个取值范围内（细节见下文），它可以包含数个明确命名的常量（“''枚举项''”）。

各常量的值是某个整数类型（称为该枚举的''底层类型''）的值。枚举的{{rlp|sizeof|大小}}、{{rlp|object#对象表示与值表示|值表示}}和{{rlp|object#对齐|对齐要求}}与它的底层类型相同。而且枚举的每个值都与该枚举的底层类型的对应值有着相同的表示。

以下列语法（重复）声明枚举：
{{sdsc begin}}
{{sdsc|num=1|1=
{{spar|枚举关键词}} {{spar optional|属性}} {{spar optional|枚举头名}} {{spar optional|枚举基}} {{ttb|{}} {{spar optional|枚举项列表}} {{ttb|}&lt;!-- --&gt;}}
}}
{{sdsc|num=2|1=
{{spar|枚举关键词}} {{spar optional|属性}} {{spar optional|枚举头名}} {{spar optional|枚举基}} {{ttb|{}} {{spar|枚举项列表}} {{ttb|, }&lt;!-- --&gt;}}
}}
{{sdsc|num=3|notes={{mark since c++11}}|1=
{{spar|枚举关键词}} {{spar optional|属性}} {{spar|枚举头名}} {{spar optional|枚举基}} {{ttb|;}}
}}
{{sdsc end}}
@1@ {{spar|枚举说明符}}，在{{rlp|declarations|声明}}语法的{{spar sep|声明说明符序列}}中出现：定义枚举类型和它的枚举项。
@2@ 可以在{{spar sep|枚举项列表}}后跟随一个逗号。
@3@ 笼统枚举声明：定义枚举类型，但不定义它的枚举项：在此声明后，该类型是完整类型，且它的大小已知。

{{par begin}}
{{par|{{spar|枚举关键字}}|
{{rrev multi|rev1={{ttb|enum}}
|since2=c++11|rev2={{ttb|enum}}、{{ttb|enum class}} 或 {{ttb|enum struct}} 之一}}}}
{{par|{{spar|属性}}|{{mark since c++11}} 任意数量的{{rlp|attributes|属性}}的可选序列}}
{{par|{{spar|枚举头名}}|
{{rrev multi|rev1=所声明的枚举的名字，可以省略。
|since2=c++11|rev2=所声明的枚举的名字，并且前面可以有一个{{spar|嵌套名说明符}}：即名字和作用域解析运算符 {{tt|::}} 的序列并以作用域解析运算符结尾。只能在非笼统声明的无作用域枚举声明中省略枚举名。&lt;br&gt;
{{spar sep|嵌套名说明符}}只有在枚举名存在且此声明是重声明时才能使用。对于笼统枚举声明，只有在{{rlp|template specialization|显式特化声明}}中{{spar sep|嵌套名说明符}}才能在枚举的名字前出现。&lt;br&gt;
如果存在{{spar|嵌套名说明符}}，那么''枚举说明符''{{sep}}不能指代只是从 {{rlp|using declaration|{{c/core|using}} 声明}}继承或引入的枚举，并且该''枚举说明符''{{sep}}只能在先前声明的外围命名空间出现。此时{{spar sep|嵌套名说明符}}不能以 {{rlp|decltype}} 说明符起始。}}}}
{{par|{{spar|枚举基}}|{{mark since c++11}} 冒号 ({{ttb|:}})，后随指名某个整数类型的{{spar|类型说明符序列}}（忽略它的限定性），该类型将作为此枚举类型的固定底层类型}}
{{par|{{spar|枚举项列表}}|枚举项定义的逗号分隔列表，每项要么是简单的独一无二的{{spar|标识符}}，它成为枚举项的名字，要么是带常量表达式的独一无二的标识符：{{spar|标识符}} {{ttb|1==}} {{spar|常量表达式}}。{{rev inl|since=c++17|在任一情况下，{{spar sep|标识符}}都可以直接后随一个{{rlp|attributes|属性说明符序列}}。}}}}
{{par end}}

有两种截然不同的枚举：''无作用域枚举''（以 {{spar|枚举关键词}} {{ttb|enum}} 声明）和''有作用域枚举''（以 {{spar|枚举关键词}} {{ttb|enum class}} 或 {{ttb|enum struct}} 声明）。

===无作用域枚举===
{{sdsc begin}}
{{sdsc|num=1|1=
{{ttb|enum}} {{spar optional|名字}} {{ttb|{}} {{spar|枚举项}} {{ttb|1==}} {{spar|常量表达式}} {{ttb|,}} {{spar|枚举项}} {{ttb|1==}} {{spar|常量表达式}} {{ttb|,}} ... {{ttb|}&lt;!-- --&gt;}}
}}
{{sdsc|num=2|notes={{mark since c++11}}|1=
{{ttb|enum}} {{spar optional|名字}} {{ttb|:}} {{spar|类型}} {{ttb|{}} {{spar|枚举项}} {{ttb|1==}} {{spar|常量表达式}} {{ttb|,}} {{spar|枚举项}} {{ttb|1==}} {{spar|常量表达式}} {{ttb|,}} ... {{ttb|}&lt;!-- --&gt;}}
}}
{{sdsc|num=3|notes={{mark since c++11}}|1=
{{ttb|enum}} {{spar|名字}} {{ttb|:}} {{spar|类型}} {{ttb|;}}
}}
{{sdsc end}}
@1@ 声明一个无作用域枚举类型，它的底层类型不固定（此时底层类型是由实现定义的某个能表示所有枚举项值的整数类型；此类型不大于 {{c/core|int}}，除非枚举项的值不能放入 {{c/core|int}} 或 {{c/core|unsigned int}}。如果{{spar sep|枚举项列表}} 为空，那么底层类型是如同枚举拥有单个值为 {{c|0}} 的枚举项。如果不存在能够表示所有枚举项的值的整数类型，那么该枚举非良构）。
@2@ 声明一个底层类型固定的无作用域枚举类型。
@3@ 无作用域枚举的笼统枚举声明必须指定名字与底层类型。

每个{{spar sep|枚举项}}都成为该枚举类型（即{{spar|名字}}）的一个具名常量，在它的外围作用域可见，且可以用于要求常量的任何位置。
{{source|1=
enum Color { red, green, blue };
Color r = red;

switch(r)
{
    case red  : std::cout &lt;&lt; "红\n"; break;
    case green: std::cout &lt;&lt; "绿\n"; break;
    case blue : std::cout &lt;&lt; "蓝\n"; break;
}
}}

每个枚举项都与一个底层类型的值相关联。当{{spar sep|枚举项列表}}中提供了 {{ttb|1==}} 时，各枚举项的值由它们所关联的{{spar sep|常量表达式}}所定义。如果首个枚举项无 {{ttb|1==}}，那么它的关联值为零。对于其他任何定义中无 {{ttb|1==}} 的枚举项，它的关联值是前一枚举项加一。
{{source|1=enum Foo { a, b, c = 10, d, e = 1, f, g = f + c };
//a = 0, b = 1, c = 10, d = 11, e = 1, f = 2, g = 12}}

无作用域枚举的{{spar sep|名字}}可以忽略：这种声明只是将各枚举项引入到它的外围作用域中：
{{source|1=enum { a, b, c = 0, d = a + 2 }; // 定义 a = 0, b = 1, c = 0, d = 2}}

当无作用域枚举是类成员时，它的枚举项可以通过类成员访问运算符 {{ttb|.}} 和 {{ttb|-&gt;}} 访问：
{{source|1=
struct X
{
    enum direction { left = 'l', right = 'r' };
};
X x;
X* p = &amp;x;

int a = X::direction::left; // C++11 开始才能用
int b = X::left;
int c = x.left;
int d = p-&gt;left;
}}

{{rrev|since=c++11|
在{{rlp|class#成员说明|成员声明}}的{{rlp|declarations#说明符|声明说明符}}中，以下序列

:{{ttb|enum}} {{spar|枚举头名}} {{ttb|:}}

只能被解析成枚举声明的一部分：
{{source|
struct S
{
    enum E1 : int {};
    enum E1 : int {}; // 错误：重声明了枚举，不会被解析成宽度为零且具有类型 enum E1 的位域
};
 
enum E2 { e1 };
 
void f()
{
    false ? new enum E2 : int(); // OK：int 不会被解析成底层类型
}
}}
}}

====以链接为目的的枚举名====
没有{{rlps|typedef#以链接为目的的 typedef 名}}且有枚举项的无名枚举会{{rlp|storage duration|以链接为目的}}，通过它的底层类型和它的首个枚举项指名；这种枚举被视为以它的枚举项''以链接为目的具有枚举名''。

===有作用域枚举===
{{rrev|since=c++11|
{{sdsc begin}}
{{sdsc|num=1|1=
{{ttb|enum struct{{!}}class}} {{spar|名字}} {{ttb|{}} {{spar|枚举项}} {{ttb|1==}} {{spar|常量表达式}} {{ttb|,}} {{spar|枚举项}} {{ttb|{{=}}}} {{spar|常量表达式}} {{ttb|,}} ... {{ttb|}&lt;!-- --&gt;}}
}}
{{sdsc|num=2|1=
{{ttb|enum struct{{!}}class}} {{spar|名字}} {{ttb|:}} {{spar|类型}} {{ttb|{}} {{spar|枚举项}} {{ttb|1==}} {{spar|常量表达式}} {{ttb|,}} {{spar|枚举项}} {{ttb|1==}} {{spar|常量表达式}} {{ttb|,}} ... {{ttb|}&lt;!-- --&gt;}}
}}
{{sdsc|num=3|1=
{{ttb|enum struct{{!}}class}} {{spar|名字}} {{ttb|;}}
}}
{{sdsc|num=4|1=
{{ttb|enum struct{{!}}class}} {{spar|名字}} {{ttb|:}} {{spar|类型}} {{ttb|;}}
}}
{{sdsc end}}

@1@ 声明底层类型为 {{c/core|int}} 的有作用域枚举类型（关键词 {{c/core|class}} 与 {{c/core|struct}} 完全等价）
@2@ 声明底层类型为{{spar sep|类型}}的有作用域枚举类型
@3@ 底层类型为 {{c/core|int}} 的有作用域枚举类型的笼统枚举声明
@4@ 底层类型为{{spar sep|类型}}的有作用域枚举类型的笼统枚举声明

每个{{spar sep|枚举项}}都成为该枚举的类型（即{{spar|名字}}）的具名常量，它被该枚举的作用域所包含，且可用作用域解析运算符访问。没有从有作用域枚举项到整数类型的隐式转换，尽管 {{rlpt|static_cast}} 可以用来获得枚举项的数值。
{{example
|code=
#include &lt;iostream&gt;

int main()
{
    enum class Color { red, green = 20, blue };
    Color r = Color::blue;

    switch(r)
    {
        case Color::red  : std::cout &lt;&lt; "红\n"; break;
        case Color::green: std::cout &lt;&lt; "绿\n"; break;
        case Color::blue : std::cout &lt;&lt; "蓝\n"; break;
    }

    // int n = r; // 错误：不存在从有作用域枚举到 int 的隐式转换
    int n = static_cast&lt;int&gt;(r); // OK, n = 21
    std::cout &lt;&lt; n &lt;&lt; '\n'; // prints 21
}
}}
}}
{{anchor|enum_relaxed_init_cpp17}}
{{rrev|since=c++17|
枚举在满足下列条件时都能用{{rlp|list initialization|列表初始化}}从一个整数初始化而无需转型：
* 初始化是直接列表初始化
* 初始化器列表仅有单个元素
* 枚举是底层类型固定的有作用域枚举或无作用域枚举
* 转换是非窄化转换

这使得我们能引入新的整数类型（例如 {{tt|SafeInt}}）并享受与它的底层整数类型相同的既存调用约定，即使 ABI 不利于以值传递/返回结构体。

{{source|1=
enum byte : unsigned char {}; // byte 是新的整数类型；参见 std::byte（C++17）
byte b{42};        // C++17 起 OK（直接列表初始化）
byte c = {42};     // 错误
byte d = byte{42}; // C++17 起 OK；与 b 的值相同
byte e{-1};        // 错误

struct A { byte b; };
A a1 = {&lt;!----&gt;{42}&lt;!----&gt;};     // 错误（构造函数形参的复制列表初始化）
A a2 = {byte{42}&lt;!----&gt;}; // C++17 起 OK

void f(byte);
f({42}); // 错误（函数形参的复制列表初始化）

enum class Handle : std::uint32_t { Invalid = 0 };
Handle h{42}; // C++17 起 OK
}}
}}


{{rrev|since=c++20|
==={{c/core|using enum}} 声明===
{{sdsc begin}}
{{sdsc|notes={{mark since c++20}}|
{{ttb|using enum}} {{spar|声明符}} {{ttb|;}}
}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|声明符}}|（可有限定的）{{rlp|identifiers|标识符}}或{{rlp|templates#模板标识|简单模板标识}}}}
{{par end}}


其中{{spar sep|声明符}}必须指名一个{{rlp|dependent name#待决类型|非待决}}枚举类型。枚举类型的查找会根据{{spar sep|声明符}}是否有限定而进行只查找类型的常规{{rlp|qualified lookup|有限定}}或{{rlp|unqualified lookup|无限定}}查找。

{{source|1=
enum E { x };

void f()
{
    int E;
    using enum E; // OK
}

using F = E;
using enum F; // OK

template&lt;class T&gt;
using EE = T;

void g()
{
    using enum EE&lt;E&gt;; // OK
}
}}

{{c/core|using enum}} 声明引入它所指名的枚举的枚举项名字，如同用对每个枚举项的 {{rlp|using declaration|{{c/core|using}} 声明}}。在类作用域中时，{{c/core|using enum}} 声明将它指名的枚举的枚举项名字作为成员添加到作用域，使成员查找能访问它们。

{{source|1=
enum class fruit { orange, apple };

struct S
{
    using enum fruit; // OK：引入 orange 与 apple 到 S 中
};

void f()
{
    S s;
    s.orange;  // OK：指名 fruit::orange
    S::orange; // OK：指名 fruit::orange
}
}}

引入两个同名的枚举项的两个 {{c/core|using enum}} 声明会冲突。
{{source|1=
enum class fruit { orange, apple };
enum class color { red, orange };

void f()
{
    using enum fruit;    // OK
    // using enum color; // 错误：color::orange 与 fruit::orange 冲突
}
}}
}}

===注解===
无作用域枚举类型的值可以被{{rlp|implicit conversion#从枚举类型提升|提升}}或{{rlp|implicit conversion#整数转换|转换}}为整数类型：
{{source|1=
enum color { red, yellow, green = 20, blue };
color col = red;
int n = blue; // n == 21
}}

整数、浮点或枚举类型的值，可以使用 {{rlpt|static_cast}} 转换为任何枚举类型。注意，这样转换后的值不一定与该枚举所定义的任何具名枚举项相等：
{{source|1=
enum access_t { read = 1, write = 2, exec = 4 }; // 枚举项: 1, 2, 4 范围: 0..7
access_t rwe = static_cast&lt;access_t&gt;(7);
assert((rwe &amp; read) &amp;&amp; (rwe &amp; write) &amp;&amp; (rwe &amp; exec));

access_t x = static_cast&lt;access_t&gt;(8.0); // CWG 1766 起为未定义行为
access_t y = static_cast&lt;access_t&gt;(8);   // CWG 1766 起为未定义行为

enum foo { a = 0, b = UINT_MAX }; // 范围: [0, UINT_MAX]
foo x = foo(-1); // CWG 1766 起为未定义行为，即使 foo 的底层类型为 unsigned int
}}

{{ftm begin|core=1|std=1|comment=1}}
{{ftm|std=C++17|value=201411L|__cpp_enumerator_attributes|应用到枚举项的{{rlp|attributes|属性}}}}
{{ftm|std=C++20|value=201907L|__cpp_using_enum|[[#using enum 声明|{{c/core|using enum}}]]}}
{{ftm end}}

===关键词===
{{ltt|cpp/keyword/enum}},
{{ltt|cpp/keyword/struct}},
{{ltt|cpp/keyword/class}},
{{ltt|cpp/keyword/using}}

===示例===
{{example
|code=
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

// 采用 16 位的枚举
enum smallenum: std::int16_t
{
    a,
    b,
    c
};

// color 可以是 red（值为 0）、yellow（值为 1）、green（值为 20）或 blue（值为 21）
enum color
{
    red,
    yellow,
    green = 20,
    blue
};

// altitude 可为 altitude::high 或 altitude::low
enum class altitude: char
{ 
    high = 'h',
    low = 'l', // CWG 518 之后才允许尾部的逗号
}; 

// 常量 d 为 0，常量 e 为 1，常量 f 为 3
enum
{
    d,
    e,
    f = e + 2
};

// 枚举类型（有作用域和无作用域）能有重载的运算符
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, color c)
{
    switch(c)
    {
        case red   : os &lt;&lt; "红"; break;
        case yellow: os &lt;&lt; "黄"; break;
        case green : os &lt;&lt; "绿"; break;
        case blue  : os &lt;&lt; "蓝"; break;
        default    : os.setstate(std::ios_base::failbit);
    }
    return os;
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, altitude al)
{
    return os &lt;&lt; static_cast&lt;char&gt;(al);
}

// 有作用域枚举（C++11）能部分地在早期 C++ 版本模拟：

enum struct E11 { x, y }; // C++11 起

struct E98 { enum { x, y }; }; // C++11 前也 OK

namespace N98 { enum { x, y }; } // C++11 前也 OK

struct S98 { static const int x = 0, y = 1; }; // C++11 前也 OK

void emu()
{
    std::cout &lt;&lt; (static_cast&lt;int&gt;(E11::y) + E98::y + N98::y + S98::y) &lt;&lt; '\n'; // 4
}

namespace cxx20
{
    enum class long_long_long_name { x, y };

    void using_enum_demo()
    {
        std::cout &lt;&lt; "C++20 `using enum`：__cpp_using_enum == ";
        switch (auto rnd = []{return long_long_long_name::x;}; rnd())
        {
#if defined(__cpp_using_enum)
            using enum long_long_long_name;
            case x: std::cout &lt;&lt; __cpp_using_enum &lt;&lt; "；x\n"; break;
            case y: std::cout &lt;&lt; __cpp_using_enum &lt;&lt; "；y\n"; break;
#else
            case long_long_long_name::x: std::cout &lt;&lt; "？；x\n"; break;
            case long_long_long_name::y: std::cout &lt;&lt; "？；y\n"; break;
#endif
        }
    }
}

int main()
{
    color col = red;
    altitude a;
    a = altitude::low;

    std::cout &lt;&lt; "col = " &lt;&lt; col &lt;&lt; '\n'
              &lt;&lt; "a = "   &lt;&lt; a   &lt;&lt; '\n'
              &lt;&lt; "f = "   &lt;&lt; f   &lt;&lt; '\n';

    cxx20::using_enum_demo();
}
|p=true
|output=
col = 红
a = l
f = 3
C++20 `using enum`：__cpp_using_enum == 201907；x
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=377|std=C++98|before=未指定当不存在能够表示所有枚举项的值的整数类型时的行为|after=此时枚举非良构}}
{{dr list item|wg=cwg|dr=518|std=C++98|before=枚举项列表不能后随逗号|after=可以后随一个逗号}}
{{dr list item|wg=cwg|dr=1514|std=C++11|before=底层类型固定的枚举的重声明可能会在类成员声明中被解析成位域|after=只能被解析成重声明}}
{{dr list item|wg=cwg|dr=1638|std=C++11|before=不可见枚举声明的文法禁止用于模板特化|after=容许嵌套类型说明符}}
{{dr list item|wg=cwg|dr=1766|std=C++98|before=从范围外的值转型到无固定底层类型的枚举拥有未指明的结果|after=行为未定义}}
{{dr list item|wg=cwg|dr=1966|std=C++11|before={{cwg|1514}} 的解决方案导致条件表达式中的 {{tt|:}} 也会成为{{spar sep|枚举基}}的一部分|after=只将该解决方案应用到&lt;br&gt;成员声明说明符中}}
{{dr list item|wg=cwg|dr=2156|std=C++11|before=枚举定义可以通过 using 声明来定义枚举类型|after=已禁止}}
{{dr list item|wg=cwg|dr=2157|std=C++11|before={{cwg|1966}} 的解决方案没有覆盖到有限定的枚举名|after=已覆盖}}
{{dr list item|wg=cwg|dr=2530|std=C++98|before=枚举项列表可以包含多个标识符相同的枚举项|after=已禁止}}
{{dr list item|wg=cwg|dr=2590|std=C++98|before=枚举的大小，值表示和对齐要求与它的底层类型无关|after=与底层类型的对应属性相同}}
{{dr list item|wg=cwg|dr=2621|std=C++20|before=不明确 {{c/core|using enum}} 声明如何查找枚举声明|after=使之明确}}
{{dr list item|wg=cwg|dr=2877|std=C++20|before=在 {{c/core|using enum}} 声明中会查找非类型声明|after=不会查找非类型声明}}
{{dr list end}}

===参阅===
{{ref std c++23}}
{{ref std|section=9.7.1|title=Enumeration declarations|id=dcl.enum}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=9.7.1|title=Enumeration declarations|id=dcl.enum}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=10.2|title=Enumeration declarations|id=dcl.enum}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=7.2|title=Enumeration declarations|id=dcl.enum}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=7.2|title=Enumeration declarations|id=dcl.enum}}
{{ref std end}}
{{ref std c++03}}
{{ref std|section=7.2|title=Enumeration declarations|id=dcl.enum}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=7.2|title=Enumeration declarations|id=dcl.enum}}
{{ref std end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_enum}}
{{dsc inc|cpp/types/dsc is_scoped_enum}}
{{dsc inc|cpp/types/dsc underlying_type}}
{{dsc inc|cpp/utility/dsc to_underlying}}
{{dsc see c|c/language/enum|枚举|nomono=true}}
{{dsc end}}

{{langlinks|ar|de|en|es|fr|it|ja|pt|ru}}