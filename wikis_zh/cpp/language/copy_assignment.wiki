{{title|复制赋值运算符}}
{{cpp/language/classes/navbar}}

复制赋值运算符是名字为 {{c/core|1=operator=}} 的非模板{{rlp|member functions|非静态成员函数}}，它提供一个相同类类型实参就能调用，并且在不修改实参的情况下复制该实参的内容。

===语法===
关于复制赋值运算符的正式语法，可以参考{{rlp|function|函数声明}}。以下列出的语法只是合法复制赋值运算符语法的一部分。
{{sdsc begin}}
{{sdsc|num=1|{{spar|返回类型}} {{ttb|1=operator=(}}{{spar sep|形参列表}}{{ttb|);}}}}
{{sdsc|num=2|{{spar|返回类型}} {{ttb|1=operator=(}}{{spar sep|形参列表}}{{ttb|)}} {{spar|函数体}}}}
{{sdsc|num=3|{{spar|返回类型}} {{ttb|1=operator=(}}{{spar sep|无默认形参列表}}{{ttb|1=) = default;}}|notes={{mark since c++11}}}}
{{sdsc|num=4|{{spar|返回类型}} {{ttb|1=operator=(}}{{spar sep|形参列表}}{{ttb|1=) = delete;}}|notes={{mark since c++11}}}}
{{sdsc|num=5|{{spar|返回类型}} {{spar sep|类名}}{{ttb|::}}{{ttb|1=operator=(}}{{spar sep|形参列表}}{{ttb|)}} {{spar|函数体}}}}
{{sdsc|num=6|{{spar|返回类型}} {{spar sep|类名}}{{ttb|::}}{{ttb|1=operator=(}}{{spar sep|无默认形参列表}}{{ttb|1=) = default;}}|notes={{mark since c++11}}}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|类名}}|要声明复制赋值运算符的类，它的类型在以下描述中给定为 {{tt|T}}}}
{{par|{{spar|形参列表}}|只有一个形参的{{rlp|function#形参列表|形参列表}}，该形参的类型是 {{tt|T}}，{{tt|T&amp;}}，{{c/core|const T&amp;}}，{{c/core|volatile T&amp;}} 或 {{c/core|const volatile T&amp;}}}}
{{par|{{spar|无默认形参列表}}|只有一个形参的{{rlp|function#形参列表|形参列表}}，该形参的类型是 {{tt|T}}，{{tt|T&amp;}}，{{c/core|const T&amp;}}，{{c/core|volatile T&amp;}} 或 {{c/core|const volatile T&amp;}}，并且没有默认实参}}
{{par|{{spar|函数体}}|复制赋值运算符的{{rlp|constructor|函数体}}}}
{{par|{{spar|返回类型}}|任意类型，但为了允许链式赋值一般倾向于 {{tt|T&amp;}}}}
{{par end}}

===解释===
@1@ 类定义中的复制赋值运算符的声明。
@2-4@ 类定义中的复制赋值运算符的定义。
:@3@ 复制赋值运算符会被显式预置。
:@4@ 复制赋值运算符会被弃置。
@5,6@ 类定义之外的复制赋值运算符的定义（该类必须包含一条声明 {{v|1}}）。
:@6@ 复制赋值运算符会被显式预置。

{{source|1=
struct X
{
    X&amp; operator=(X&amp; other);     // 复制赋值运算符
    X operator=(X other);       // 允许按值传递
//  X operator=(const X other); // 错误：形参类型不正确
};

union Y
{
    // 复制赋值运算符并不一定要完全遵循上述列出的语法，
    // 它们只需要在不违反上述限制的情况下遵循通常函数声明的语法
    auto operator=(Y&amp; other) -&gt; Y&amp;;       // OK：尾随返回类型
    Y&amp; operator=(this Y&amp; self, Y&amp; other); // OK：显式对象形参
//  Y&amp; operator=(Y&amp;, int num = 1);        // 错误：有其他非对象形参
};
}}

每当{{rlp|overload resolution|重载决议}}选择复制赋值运算符时，它都会被调用，例如对象出现在赋值表达式左侧时。

===隐式声明的复制赋值运算符===
如果没有对类类型提供任何用户定义的复制赋值运算符，那么编译器将始终声明一个复制赋值运算符作为类的 {{c/core|inline public}} 成员。如果满足下列所有条件，那么这个隐式声明的复制赋值运算符拥有形式 {{c|1=T&amp; T::operator=(const T&amp;)}}：
* {{tt|T}} 的每个直接基类 {{tt|B}} 均拥有形参是 {{tt|B}}、{{c/core|const B&amp;}} 或 {{c/core|const volatile B&amp;}} 的复制赋值运算符；
* {{tt|T}} 的每个类类型或类的数组类型的非静态数据成员 {{tt|M}} 均拥有形参是 {{tt|M}}、{{c/core|const M&amp;}} 或 {{c/core|const volatile M&amp;}} 的复制赋值运算符。
否则，隐式声明的复制赋值运算符会被声明为 {{c|1=T&amp; T::operator=(T&amp;)}}。

因为这些规则，隐式声明的复制赋值运算符不能绑定到 {{c/core|volatile}} 左值实参。

类可以拥有多个复制赋值运算符，如 {{c|1=T&amp; T::operator=(T&amp;)}} 和 {{c|1=T&amp; T::operator=(T)}}。{{rev inl|since=c++11|当存在用户定义的复制赋值运算符时，用户仍然可以通过关键词 {{c/core|default}} 强迫编译器生成隐式声明的复制赋值运算符。}}

隐式声明（或在它的首个声明被预置）的复制赋值运算符具有{{rev inl|until=c++17|{{rlp|except spec|动态异常说明}}}}{{rev inl|since=c++17| {{rlp|noexcept spec|noexcept 说明}}}}中所描述的异常说明。

因为每个类总是会声明复制赋值运算符，所以基类的赋值运算符始终会被隐藏。当使用 {{rlp|using declaration#在类定义中|using 声明}}从基类带入复制赋值运算符，且它的实参类型与派生类的隐式复制赋值运算符的实参类型相同时，该 using 声明也会被隐式声明所隐藏。

===隐式定义的复制赋值运算符===
如果隐式声明的复制赋值运算符既没有被弃置也不平凡，那么当它被 {{rlp|definition#ODR 使用|ODR 使用}}{{rev inl|since=c++14|&lt;!-- P0859R0 --&gt;或用于{{rlp|constant expression#常量求值所需要的函数与变量|常量求值}}}}时，它会被编译器定义（即生成并编译函数体）。对于联合体类型，隐式定义的复制赋值运算符（如同以 {{lc|std::memmove}}）复制它的对象表示。对于非联合类类型，编译器按照声明顺序对对象的各直接基类和非静态数据成员进行逐成员复制赋值，其中对标量进行内建赋值，对数组使用逐元素复制赋值，而对类类型使用复制赋值运算符。

{{rrev multi|since1=c++14|since2=c++23
|rev1=如果满足下列所有条件，那么类 {{tt|T}} 的隐式定义的复制赋值运算符是 {{rlpt|constexpr}} 的：
* {{tt|T}} 是[[cpp/named req/LiteralType|字面类型]]，且
* 复制每个直接基类子对象时选中的赋值运算符都是 constexpr 函数，且
* 复制 {{tt|T}} 的每个类（或其数组）类型的数据成员时选中的赋值运算符都是 constexpr 函数。
|rev2=类 {{tt|T}} 的隐式定义的复制赋值运算符是 {{rlpt|constexpr}} 的。
}}

{{rrev|since=c++11|
当 {{tt|T}} 拥有用户定义的析构函数或用户定义的复制构造函数时，隐式定义的复制赋值运算符的生成被弃用。
}}

===弃置的复制赋值运算符===
如果满足以下任意条件，那么类 {{tt|T}} 中隐式声明的{{rev inl|since=c++11|或显式预置的}}复制赋值运算符{{rev inl|until=c++11|不被定义}}{{rev inl|since=c++11|被定义为弃置的}}：
* {{tt|T}} 有一个具有 const 限定的非类类型（或它的可以有多维的数组）的非静态数据成员。
* {{tt|T}} 有一个具有引用类型的非静态数据成员。
* {{tt|T}} 有一个具有类类型 {{tt|M}}（或它的可以有多维的数组类型）的{{rlp|object#潜在构造的子对象|潜在构造的子对象}}，并且为寻找 {{tt|M}} 的复制赋值运算符而进行的重载决议
:* 没有得到可用候选，或者
:* 在该子对象是{{rlp|union#联合体式的类|变体成员}}时，选择了非平凡的函数。

{{rrev|since=c++11|
类 {{tt|T}} 中隐式声明的复制赋值运算符在 {{tt|T}} 声明了{{rlp|move constructor|移动构造函数}}或{{rlp|move assignment|移动赋值运算符}}的情况下会被弃置。
}}

===平凡的复制赋值运算符===
如果满足下列所有条件，那么类 {{tt|T}} 的复制赋值运算符是平凡的：
* 它不是用户提供的（即它是隐式定义或预置的）；
* {{tt|T}} 没有虚成员函数；
* {{tt|T}} 没有虚基类；
* 为 {{tt|T}} 的每个直接基类选择的复制赋值运算符都是平凡的；
* 为 {{tt|T}} 的每个类类型（或类类型的数组）的非静态数据成员选择的复制赋值运算符都是平凡的。

平凡复制赋值运算符如同用 {{lc|std::memmove}} 进行对象表示的复制。所有与 C 语言兼容的数据类型（POD 类型）都可以平凡复制。

===合格的复制赋值运算符===
{{cpp/language/eligible special member function|复制赋值运算符}}

合格复制赋值运算符的平凡性确定该类是否为[[cpp/named req/TriviallyCopyable|可平凡复制类型]]。

===注解===
如果复制和移动赋值运算符都有提供，那么重载决议会在实参是{{rlp|value category|右值}}（例如无名临时量的{{rlp|value category|纯右值}} 或 {{ltt std|cpp/utility/move}} 的结果的{{rlp|value category|亡值}}）时选择移动赋值，而在实参是{{rlp|value category|左值}}（具名对象或返回左值引用的函数或运算符）时选择复制赋值。如果只提供了复制赋值，那么重载决议对于所有值类别都会选择它（只要它按值或按到 const 的引用接收它的实参），从而当移动赋值不可用时，复制赋值将会成为它的后备。

隐式定义的复制赋值运算符是否会多次对在继承网格中可通过多于一条路径访问的虚基类子对象赋值是未指明的（同样适用于{{rlp|move assignment|移动赋值}}）。

有关用户定义的复制赋值运算符应当有哪些行为，见{{rlp|operators#赋值运算符|赋值运算符重载}}。

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

struct A
{
    int n;
    std::string s1;
 
    A() = default;
    A(A const&amp;) = default;
    
    // 用户定义的复制赋值（复制交换法）
    A&amp; operator=(A other)
    {
        std::cout &lt;&lt; "A 的复制赋值\n";
        std::swap(n, other.n);
        std::swap(s1, other.s1);
        return *this;
    }
};

struct B : A
{
    std::string s2;
    // 隐式定义的复制赋值
};

struct C
{
    std::unique_ptr&lt;int[]&gt; data;
    std::size_t size;
    
    // 用户定义的复制赋值（非复制交换法）
    // 注意：复制交换法总是会重新分配资源
    C&amp; operator=(const C&amp; other)
    {
        if (this != &amp;other) // 非自赋值
        {
            if (size != other.size) // 资源无法复用
            {
                data.reset(new int[other.size]);
                size = other.size;
            }
            std::copy(&amp;other.data[0], &amp;other.data[0] + size, &amp;data[0]);
        }
        return *this;
    }
};

int main()
{
    A a1, a2;
    std::cout &lt;&lt; "a1 = a2 调用 ";
    a1 = a2; // 用户定义的复制赋值
    
    B b1, b2;
    b2.s1 = "foo";
    b2.s2 = "bar";
    std::cout &lt;&lt; "b1 = b2 调用 ";
    b1 = b2; // 隐式定义的复制赋值
    
    std::cout &lt;&lt; "b1.s1 = " &lt;&lt; b1.s1 &lt;&lt; " b1.s2 = " &lt;&lt; b1.s2 &lt;&lt; '\n';
}
|output=
a1 = a2 调用 A 的复制赋值
b1 = b2 调用 A 的复制赋值
b1.s1 = foo b1.s2 = bar
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1353|std=C++98|before=不定义隐式声明的复制赋值运算符的条件没有考虑多维数组类型|after=考虑这些类型}}
{{dr list item|wg=cwg|dr=2094|std=C++11|before=volatile 子对象使得预置的默认复制赋值运算符不平凡（{{cwg|496}}）|after=平凡性不受影响}}
{{dr list item|wg=cwg|dr=2171|std=C++11|before={{c|1=operator=(X&amp;) = default}} 不平凡|after=令它平凡}}
{{dr list item|wg=cwg|dr=2180|std=C++11|before=类 {{tt|T}} 的预置的复制赋值运算符在 {{tt|T}} 是抽象类且拥有&lt;br&gt;无法被复制赋值的直接虚基类时不会被定义为弃置|after=此时会被定义为弃置}}
{{dr list item|wg=cwg|dr=2595|std=C++20|before=对于一个复制赋值运算符，如果存在其他更受约束但&lt;br&gt;无法满足关联约束的复制赋值运算符，那么它无法合格|after=此时它可以合格}}
{{dr list end}}

===参阅===
* {{rlp|converting constructor|转换构造函数}}
* {{rlp|copy constructor|复制构造函数}}
* {{rlp|copy elision|复制消除}}
* {{rlp|default constructor|默认构造函数}}
* {{rlp|destructor|析构函数}}
* {{rlpt|explicit}}
* {{rlp|initialization|初始化}}
** {{rlp|aggregate initialization|聚合初始化}}
** {{rlp|constant initialization|常量初始化}}
** {{rlp|copy initialization|复制初始化}}
** {{rlp|default initialization|默认初始化}}
** {{rlp|direct initialization|直接初始化}}
** {{rlp|initializer list|初始化列表}}
** {{rlp|list initialization|列表初始化}}
** {{rlp|reference initialization|引用初始化}}
** {{rlp|value initialization|值初始化}}
** {{rlp|zero initialization|零初始化}}
* {{rlp|move assignment|移动赋值}}
* {{rlp|move constructor|移动构造函数}}
* {{rlpt|new}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}