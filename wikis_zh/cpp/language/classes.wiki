{{title|类}}
{{cpp/language/classes/navbar}}
类是一种用户定义类型。

类的类型可以由类说明符定义，它在{{rlp|declarations|声明}}语法的{{spar sep|声明说明符序列}}中出现。类说明符的语法参见{{rlp|class|类声明}}。

类可以拥有下列种类的成员：
@1@ 数据成员：
:@a@ {{rlp|data members|非静态数据成员}}，包括{{rlp|bit field|位域}}。
:@b@ {{rlp|static#静态数据成员|静态数据成员}}
@2@ 成员函数：
:@a@ {{rlp|member functions|非静态成员函数}}
:@b@ {{rlp|static#静态成员函数|静态成员函数}}
@3@ 嵌套类型：
:@a@ 在类定义之中定义的{{rlp|nested types|嵌套类}}及{{rlp|enum|枚举}}
:@b@ 既存类型的别名，以 {{rlpt|typedef}} {{rev inl|since=c++11|或{{rlp|type alias|类型别名}}}}声明定义
:@c@ 就{{rlp|unqualified lookup#注入类名|查找}}而言（除非在用作{{rlp|initializer list|构造函数}}名时），类的名字在该类自身的定义中，表现为一个作为其自身的类型别名的公开成员：这被称作''{{rlp|injected-class-name|注入类名}}''
@4@ 来自定义于类中的所有无作用域枚举{{rev inl|since=c++20|，或由 {{rlp|using declaration|using 声明}}或 {{rlp|enum#using enum 声明|using enum 声明}}引入}}的{{rlp|enum|枚举项}}
@5@ {{rlp|member template|成员模板}}（{{rev inl|since=c++14|变量模板、}}类模板或函数模板）可以在任何非局部 class/struct/union 定义体内出现。

所有成员都在类定义中一次性定义，不能向已定义的类添加成员（与命名空间成员不同）

类 {{tt|T}} 的以下成员不能使用 {{tt|T}} 作为它的名字：
* 静态数据成员
* 成员函数
* 成员类型
* 成员模板
* 枚举的枚举项{{rev inl|since=c++11|（除非该枚举为有作用域）}}
* 匿名联合体成员的成员
然而非静态数据成员可使用名称 {{tt|T}}，只要没有用户声明的构造函数。

声明或继承了至少一个{{rlp|virtual|虚}}成员函数的类是''多态''{{sep}}的。此类型的对象是{{rlp|object#多态对象|多态对象}}，并拥有作为其对象表示一部分存储的运行时类型信息，它可以通过 {{rlpt|dynamic_cast}} 和 {{rlpt|typeid}} 查询到。虚成员函数参与动态绑定。

声明或继承了至少一个纯虚函数的类是{{rlp|abstract class|抽象类}}。不能创建此类型的对象。

{{rrev|since=c++11|
拥有 {{rlp|constexpr}} 构造函数的类是{{named req|LiteralType}}：此类型的对象能用 {{rlp|constexpr}} 函数在编译时进行操作。
}}

===类的性质===
{{rrev|since=c++11|1=
====可平凡复制类====
''可平凡复制类''{{sep}}是满足以下所有条件的类：
* 至少有一个合格的{{rlp|copy constructor#合格的复制构造函数|复制构造函数}}，{{rlp|move constructor#合格的移动构造函数|移动构造函数}}，{{rlp|copy assignment#合格的复制赋值运算符|复制赋值运算符}}或{{rlp|move assignment#合格的移动赋值运算符|移动赋值运算符}}，
* 每个合格的复制构造函数都是{{rlp|copy constructor#平凡的复制构造函数|平凡的}}，
* 每个合格的移动构造函数都是{{rlp|move constructor#平凡的移动构造函数|平凡的}}，
* 每个合格的复制赋值运算符都是{{rlp|copy assignment#平凡的复制赋值运算符|平凡的}}，
* 每个合格的移动赋值运算符都是{{rlp|move assignment#平凡的移动赋值运算符|平凡的}}，并且
* 有一个未被弃置的{{rlp|destructor#平凡析构函数|平凡析构函数}}。

{{rev begin}}
&lt;tr class="t-rev"&gt;
&lt;td&gt;
====平凡类====
''平凡类''{{sep}}是满足以下所有条件的类：
* 它是可平凡复制类，并且
* 有一个或多个{{rlp|default constructor#合格的默认构造函数|合格的默认构造函数}}，它们全部都是{{rlp|default constructor#平凡默认构造函数|平凡的}}。
&lt;/td&gt;
&lt;td&gt;{{mark deprecated c++26}}&lt;/td&gt;
&lt;/tr&gt;
{{rev end}}

====标准布局类====
''标准布局类''{{sep}}是满足以下所有条件的类：
* 没有具有非标准布局类类型（或这种类型的数组）或引用类型的{{rlp|data members|非静态数据成员}}，
* 没有{{rlp|virtual|虚函数}}和{{rlp|derived class#虚基类|虚基类}}，
* 所有非静态数据成员都具有相同的{{rlp|access|可访问性}}，
* 没有非标准布局的基类，
* 继承层级中仅有一个类具有非静态数据成员，并且
&lt;!-- 下条规则从标准文档中复制而来，可以用从 cpp/named_req/StandardLayoutType 页面获取的以下内容替换它：
* 不存在与如下各项具有相同类型的基类子对象：
:* 对于非联合类型，为其首个非静态数据成员（见{{rlp|ebo|空基类优化}}），递归地，若该数据成员具有非联合类类型，则为其首个数据成员，或者若该数据成员为联合体类型，则为其所有非静态数据成员，或者若该数据成员为数组类型，则为其元素类型，依此递归。
:* 对于联合体类型，为其任何非静态数据成员，递归地，若该数据成员具有非联合类类型，则为其首个数据成员，或者若该数据成员为联合体类型，则为其所有非静态数据成员，或者若该数据成员为数组类型，则为其元素类型，依此递归。
:* 对于数组类型，为数组元素的类型，递归地，若该数据成员拥有非联合类类型，则为其首个数据成员，或者若该数据成员为联合体类型，则为其所有非静态数据成员，或者若该数据成员为数组类型，则为其元素类型，依此递归。
--&gt;
* 非正式地说，该类的所有基类的类型均不同于第一个非静态数据成员。或者，正式来说，给定该类为 S，满足 M(S) 中没有 S 的基类，其中 M(X) 对于类型 X 定义如下：
:* 如果 X 是没有（可能继承来的）非静态数据成员的非联合体类类型，那么集合 M(X) 为空。
:* 如果 X 是首个非静态数据成员（可能是匿名联合体）具有 X0 类型的非联合体类类型，那么集合 M(X) 包含 X0 和 M(X0) 中的元素。
:* 如果 X 是联合体类型，那么集合 M(X) 是包含所有 Ui 的集合与每个 M(Ui) 集合的并集，其中每个 Ui 是 X 的第 i 个非静态数据成员的类型。
:* 如果 X 是元素类型为 Xe 的数组类型，那么集合 M(X) 包含 Xe 和 M(Xe) 中的元素。
:* 如果 X 不是类类型或数组类型，那么集合 M(X) 为空。

''标准布局结构体''{{sep}}是以类关键词 {{ltt|cpp/keyword/struct}} 或类关键词 {{ltt|cpp/keyword/class}} 定义的标准布局类。''标准布局联合体''{{sep}}是以类关键词 {{ltt|cpp/keyword/union}} 定义的标准布局类。
}}

====隐式生存期类====
''隐式生存期类''{{sep}}是满足以下条件之一的类：
* 它是析构函数不由{{rev inl|until=c++11|用户声明}}{{rev inl|since=c++11|{{rlp|function#由用户提供的函数|用户提供}}}}的{{rlp|aggregate initialization|聚合体}}，或
* 至少有一个平凡且合格的构造函数和一个平凡且未被弃置的析构函数。

注解：隐式生存期属性是由缺陷报告 {{wg21|P0593R6}} 明确的。

{{rev begin}}
&lt;tr class="t-rev"&gt;
&lt;td&gt;
====简旧数据类====
''简旧数据类''{{sep}}是满足以下所有条件的类：
{{rrev multi|rev1=
* 它是{{rlp|aggregate initialization|聚合体}}，
* 没有用户声明的复制赋值运算符，
* 没有用户声明的析构函数，并且
* 没有具有非简旧数据类类型（或这种类型的数组）或者引用类型的非静态数据成员。
|since2=c++11|rev2=
* 它是平凡类，
* 它是标准布局类，并且
* 没有具有非简旧数据类类型（或这种类型的数组）的非静态数据成员。
}}

''简旧数据结构体''{{sep}}是非联合体的简旧数据类。''简旧数据联合体''{{sep}}是满足简旧数据类条件的联合体。
&lt;/td&gt;
&lt;td&gt;{{mark deprecated c++20}}&lt;/td&gt;
&lt;/tr&gt;
{{rev end}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=148|std=C++98|before=简旧数据类不能包含指向成员的指针，即使它们自身就是简旧数据（标量）类型|after=移除此限制}}
{{dr list item|wg=cwg|dr=383|std=C++98|before=简旧数据类可以包含用户声明的复制赋值运算符或析构函数，只要它们没有被定义|after=不允许包含它们}}
{{dr list item|wg=cwg|dr=1363|std=C++11|before=同时有平凡和不平凡的默认构造函数的类可以是平凡类|after=它不是平凡类}}
{{dr list item|wg=cwg|dr=1496|std=C++11|before=构造函数全部被弃置的类可以是平凡类|after=它不是平凡类}}
{{dr list item|wg=cwg|dr=1672|std=C++11|before=有多个空基类的类可以是标准布局类|after=它不是标准布局类}}
{{dr list item|wg=cwg|dr=1734|std=C++11|before=可平凡复制类不能有不平凡但被弃置的复制/移动构造函数和复制/移动赋值运算符|after=被弃置时可以不平凡}}
{{dr list item|wg=cwg|dr=1813|std=C++11|before=有继承了非静态数据成员的基类的类不是标准布局类|after=它可以是标准布局类}}
{{dr list item|wg=cwg|dr=1881|std=C++11|before=对于一个标准布局类和它的所有基类，无名位域&lt;br&gt;可以在声明了所有数据成员的类以外的类声明|after=所有非静态数据成员和位域&lt;br&gt;必须在同一个类首次声明}}
{{dr list item|wg=cwg|dr=1909|std=C++98|before=成员模板的名字可以和它的类名相同|after=不能相同}}
{{dr list item|wg=cwg|dr=2120|std=C++11|before=在确定标准布局类时，M(X) 的定义没有考虑到首个成员是数组的类的情况|after=在 M(X) 的定义中处理这种情况}}
{{dr list item|wg=cwg|dr=2605|std=C++98|before=隐式生存期类的析构函数可以由用户提供|after=已禁止}}
{{dr list end}}

{{langlinks|en|es|ja|ko|pt|ru}}