{{title|变量模板 {{mark since c++14}}}}
{{cpp/language/declarations/expressions/templates/navbar}}

变量模板定义一族变量或静态数据成员。

===语法===
{{sdsc begin}}
{{sdsc|num=1|{{ttb|template}} {{ttb|&lt;}} {{spar|形参列表}} {{ttb|&gt;}} {{spar|变量声明}}}}
{{sdsc|num=2|notes={{mark since c++20}}|{{ttb|template}} {{ttb|&lt;}} {{spar|形参列表}} {{ttb|&gt;}} {{ttb|requires}} {{spar|约束}} {{spar|变量声明}}}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|变量声明}}|变量的{{rlp|declarations|声明}}。声明的变量名成为模板名。}}
{{par|{{spar|形参列表}}|非空的{{rlp|template parameters|模板形参}}的逗号分隔列表，每项是{{rlp|template parameters#非类型模板形参|非类型形参}}、{{rlp|template parameters#类型模板形参|类型形参}}、{{rlp|template parameters#模板形参|模板形参}}，或任何上述的{{rlp|parameter pack|形参包}}之一。}}
{{par|{{spar|约束}}|{{rlp|constraints|约束表达式}}，限制这个变量模板所能接受的模板形参}}
{{par end}}

===解释===
从变量模板实例化的变量被称为''被实例化变量''，从静态数据成员模板实例化的变量被称为''被实例化静态数据成员''。

变量模板可以通过处于命名空间作用域中的模板声明引入，其中 {{spar|变量声明}} 声明一个变量。

{{source|1=
template&lt;class T&gt;
constexpr T pi = T(3.1415926535897932385L); // 变量模板

template&lt;class T&gt;
T circular_area(T r) // 函数模板
{
    return pi&lt;T&gt; * r * r; // pi&lt;T&gt; 是变量模板实例化
}
}}

在类作用域中使用时，变量模板声明一个静态数据成员模板。

{{source|1=
using namespace std::literals;
struct matrix_constants
{
    template&lt;class T&gt;
    using pauli = hermitian_matrix&lt;T, 2&gt;; // 别名模版

    template&lt;class T&gt; // 静态数据成员模板
    static constexpr pauli&lt;T&gt; sigmaX = {&lt;!----&gt;{0, 1}, {1, 0}&lt;!----&gt;};

    template&lt;class T&gt;
    static constexpr pauli&lt;T&gt; sigmaY = {&lt;!----&gt;{0, -1i}, {1i, 0}&lt;!----&gt;};

    template&lt;class T&gt;
    static constexpr pauli&lt;T&gt; sigmaZ = {&lt;!----&gt;{1, 0}, {0, -1}&lt;!----&gt;};
};
}}

与其他{{rlp|static|静态成员}}一样，静态数据成员模板的需要一个定义。这种定义可以在类定义外提供。处于命名空间作用域的静态数据成员的模板声明也可以是{{rlp|member template|类模板的非模板数据成员}}的定义：

{{source|1=
struct limits
{
    template&lt;typename T&gt;
    static const T min; // 静态数据成员模板的声明
};

template&lt;typename T&gt;
const T limits::min = {}; // 静态数据成员模板的定义

template&lt;class T&gt;
class X
{
    static T s; // 类模板的非模板静态数据成员的声明
};

template&lt;class T&gt;
T X&lt;T&gt;::s = 0; // 类模板的非模板静态数据成员的定义
}}

除非变量模板被{{rlp|template specialization|显式特化}}或显式实例化，否则在变量模板的特化在要求{{rlp|definition#ODR 使用|变量定义存在}}的语境中被引用，&lt;!-- P0859R0 --&gt;或定义存在与否影响程序语义时，即表达式（可能不使用定义）{{rlp|constant expression#常量求值所需要的函数与变量|对常量求值需要}}该变量时，隐式实例化它。

如果有表达式需要某变量进行常量求值，那么变量定义存在与否会影响程序语义，即使不要求常量求值表达式，或常量表达式求值不使用该定义。

===注解===
在 C++14 引入变量模板前，参数化变量通常实现为类模板的静态数据成员，或返回所需值的 constexpr 函数模板。

变量模板不能用作{{rlp|template parameters#模板模板实参|模板模板实参}}。
{{feature test macro|__cpp_variable_templates|变量模板|value=201304L|std=C++14}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=2255|std=C++14|before=不明确静态数据成员模板的特化是不是静态数据成员|after=它是}}
{{dr list end}}

{{langlinks|en|es|ja|ru}}