{{title|运算符重载}}
{{cpp/language/expressions/navbar}}

为用户定义类型的操作数定制 C++ 运算符。

===语法===
''运算符函数''{{sep}}是具有特殊的函数名的{{rlp|function|函数}}：

{{sdsc begin}}
{{sdsc|num=1|{{ttb|operator}} {{spar|运算符}}}}
{{sdsc|num=2|{{ttb|operator}} {{ttb|new}}&lt;br&gt;{{ttb|operator}} {{ttb|new []}}}} 
{{sdsc|num=3|{{ttb|operator}} {{ttb|delete}}&lt;br&gt;{{ttb|operator}} {{ttb|delete []}}}}
{{sdsc|num=4|notes={{mark since c++20}}|{{ttb|operator}} {{ttb|co_await}}}}
{{sdsc end}}
{{par begin}}
{{par|{{spar|运算符}}|下列运算符之一：{{c|+}} {{c|-}} {{c|*}} {{c|/}} {{c|%}} {{c|^}} {{c|&amp;}} {{c|{{!}}}} {{c|~}} {{c|!}} {{c|{{=}}}} {{c|&lt;}} {{c|&gt;}} {{c|+{{=}}}} {{c|-{{=}}}} {{c|*{{=}}}} {{c|/{{=}}}} {{c|%{{=}}}} {{c|^{{=}}}} {{c|&amp;{{=}}}} {{c|{{!}}{{=}}}} {{c|&lt;&lt;}} {{c|&gt;&gt;}} {{c|&gt;&gt;{{=}}}} {{c|&lt;&lt;{{=}}}} {{c|{{=}}{{=}}}} {{c|!{{=}}}} {{c|&lt;{{=}}}} {{c|&gt;{{=}}}} {{rev inl|since=c++20|{{c|&lt;{{=}}&gt;}}}} {{c|&amp;&amp;}} {{c|{{!}}{{!}}}} {{c|++}} {{c|--}} {{c|,}} {{c|-&gt;*}} {{c|-&gt;}} {{c|()}} {{c|[]}}}}
{{par end}}

@1@ 重载的标点符号运算符。

@2@ [[cpp/memory/new/operator new|分配函数]]。

@3@ [[cpp/memory/new/operator delete|解分配函数]]。

@4@ 用于 {{rlp|coroutines#co_await|{{c/core|co_await}} 表达式}}的重载的 {{c/core|co_await}} 运算符。

非标点符号运算符的行为已在各自对应的页面描述。除非另有说明，本页余下描述不适用于这些函数。

===解释===
当{{rlp|expressions|表达式}}中出现某个运算符，且它至少有一个操作数拥有{{rlp|class|类类型}}或{{rlp|enum|枚举类型}}时，使用{{rlp|overload resolution|重载决议}}在具有与以下各项匹配的签名的函数中，确定所要调用的用户定义函数：
{|class="wikitable" style="font-size: 85%; text-align: left;"
|-
!表达式
!作为成员函数 
!作为非成员函数
!示例
|-
|@a
|(a).operator@ ( )
|operator@ (a)
|{{c|!std::cin}} 调用 {{c|std::cin.operator!()}}
|-
|a@b
|(a).operator@ (b)
|operator@ (a, b)
|{{c|std::cout &lt;&lt; 42}} 调用 {{c|std::cout.operator&lt;&lt;(42)}}
|-
|a=b
|(a).operator= (b)
|{{no|不能是非成员}}
|给定 {{c|std::string s;}}，{{c|1=s = "abc";}} 调用 {{c|1=s.operator=("abc")}}
|-
|a(b...)
|(a).operator()(b...)
|{{no|不能是非成员}}
|给定 {{c|std::random_device r;}}，{{c|1=auto n = r();}} 调用 {{c|r.operator()()}}
|-
|a[b]
|(a).operator[](b)
|{{no|不能是非成员}}
|给定 {{c|std::map&lt;int, int&gt; m;}}，{{c|1=m[1] = 2;}} 调用 {{c|m.operator[](1)}}
|-
|a-&gt;
|(a).operator-&gt;( )
|{{no|不能是非成员}}
|给定 {{c|std::unique_ptr&lt;S&gt; p;}}，{{c|p-&gt;bar()}} 调用 {{c|p.operator-&gt;()}}
|-
|a@
|(a).operator@ (0)
|operator@ (a, 0)
|给定 {{c|std::vector&lt;int&gt;::iterator i;}}，{{c|i++}} 调用 {{c|i.operator++(0)}}
|-
|colspan="4"|
在这张表中，{{ttb|@}} 是表示所有匹配运算符的占位符：@a 是所有前缀运算符，a@ 是除 -&gt; 以外的所有后缀运算符，a@b 是除 = 以外的所有其他运算符。
|}

{{rrev|since=c++20|
另外，对于比较运算符 {{c|{{==}}}}、{{c|!{{=}}}}、{{c|&lt;}}、{{c|&gt;}}、{{c|&lt;{{=}}}}、{{c|&gt;{{=}}}}、{{c|&lt;{{=}}&gt;}}，重载决议也会考虑{{rlp|overload resolution#调用重载运算符|重写候选}} {{c/core|operator{{==}}}} 或 {{c/core|operator&lt;{{=}}&gt;}}。
}}

注意：对于重载的{{rev inl|since=c++20| {{rlpt|coroutines#co_await|co_await}}、}}{{rlp|cast operator|用户定义转换函数}}、{{rlp|user literal|用户定义字面量}}、[[cpp/memory/new/operator new|分配]]与[[cpp/memory/new/operator_delete|解分配]]，可分别见对应专题。

重载的运算符（但非内建运算符）可用函数记法进行调用：
{{source|1=
std::string str = "Hello, ";
str.operator+=("world");                       // 同 str += "world";
operator&lt;&lt;(operator&lt;&lt;(std::cout, str) , '\n'); // 同 std::cout &lt;&lt; str &lt;&lt; '\n';
                                               // (C++17 起) 但定序不同
}}

{{rrev|since=c++23|1=
====静态重载运算符====
可以把作为成员函数的重载运算符声明为[[cpp/language/static#静态成员函数|静态的]]。不过只允许对 {{c/core|operator()}} 和 {{c/core|operator[]}} 这样做。

可以使用函数写法来调用这样的运算符。但是，当表达式中出现这些运算符时，仍然需要类类型的对象。

{{source|1=
struct SwapThem
{
    template&lt;typename T&gt;
    static void operator()(T&amp; lhs, T&amp; rhs) 
    {
        std::ranges::swap(lhs, rhs);
    }
    
    template&lt;typename T&gt;
    static void operator[](T&amp; lhs, T&amp; rhs)
    {
        std::ranges::swap(lhs, rhs);
    } 
};
inline constexpr SwapThem swap_them{};

void foo()
{
    int a = 1, b = 2;
    
    swap_them(a, b); // OK
    swap_them[a, b]; // OK
    
    SwapThem{}(a, b); // OK
    SwapThem{}[a, b]; // OK
    
    SwapThem::operator()(a, b); // OK
    SwapThem::operator[](a, b); // OK
    
    SwapThem(a, b); // 错误，无效的构造
    SwapThem[a, b]; // 错误
}
}}
}}

===限制===
* 运算符函数必须有一个具有类类型，到类类型的引用类型，枚举类型或到枚举类型的引用类型的函数形参或隐式对象形参。
* 不能重载 {{ttb|::}}（作用域解析）、{{ttb|.}}（成员访问）、{{ttb|.*}}（通过成员指针的成员访问）及 {{ttb|?:}}（三元条件）运算符。
* 不能创建新运算符，例如 {{ttb|**}}、{{ttb|&lt;&gt;}} 或 {{ttb|&amp;{{!}}}}。
* 无法改变运算符的优先级、结合方向或操作数的数量。
* 重载的运算符 {{ttb|-&gt;}} 必须要么返回裸指针，要么（按引用或值）返回同样重载了运算符 {{ttb|-&gt;}} 的对象。
* 运算符 {{ttb|&amp;&amp;}} 与 {{ttb|{{!!}}}} 的重载会失去短路求值。
{{rrev|until=c++17|
* {{ttb|&amp;&amp;}}、{{ttb|{{!!}}}} 和 {{ttb|,}} 在被重载时失去它们特殊的{{rlp|eval order|定序性质}}，并且即使不使用函数调用记法，也表现为与常规的函数调用相似。
}}

===规范实现===
除了上述限制外，语言对重载运算符的所作所为或返回类型（它不参与重载决议）上没有其他任何制约，但通常期待重载的运算符表现尽可能与内建运算符相似：期待 {{c/core|operator+}} 对它的实参进行相加而非相乘，期待 {{c/core|operator{{=}}}} 进行赋值，如此等等。期待相关的运算符之间的表现也相似（{{c/core|operator+}} 与 {{c/core|operator+{{=}}}} 做同一类加法运算）。返回类型被期待使用该运算符的表达式限制：例如，令赋值运算符按引用返回，以使写出 {{c|1=a = b = c = d}} 可行，因为内建运算符允许这样做。

常见的重载运算符拥有下列典型、规范形式：&lt;ref&gt;StackOverflow C++ FAQ 上的[http://stackoverflow.com/questions/4421706/operator-overloading/4421708#4421708 运算符重载]&lt;/ref&gt;

====赋值运算符====
赋值运算符 {{c/core|1=operator=}} 有特殊性质：细节见{{rlp|copy assignment|复制赋值}}与{{rlp|move assignment|移动赋值}}。

对规范的复制赋值运算符，期待它[https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c62-make-copy-assignment-safe-for-self-assignment 能安全的处理自赋值]，并按引用返回左操作数：
{{source|1=
// 复制赋值
T&amp; operator=(const T&amp; other)
{
    // 防止自赋值
    if (this == &amp;other)
        return *this;
 
    // 假设 *this 保有可重用资源，例如一个在堆的缓冲区分配的 mArray
    if (size != other.size)           // *this 中的存储不可复用
    {
        temp = new int[other.size];   // 分配存储，如果抛出异常则等同于什么也不做
        delete[] mArray;              // 销毁 *this 中的存储
        mArray = temp;
        size = other.size;
    } 
 
    std::copy(other.mArray, other.mArray + other.size, mArray);
    return *this;
}
}}

{{rrev|since=c++11|
对规范的移动赋值，期待它[https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c64-a-move-operation-should-move-and-leave-its-source-in-a-valid-state 令被移动对象遗留于合法状态]（即有完好类不变式的状态），且在自赋值时要么[https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c65-make-move-assignment-safe-for-self-assignment 不做任何事]，要么至少遗留对象于合法状态，并以非 const 引用返回左操作数，而且是 noexcept 的：
{{source|1=
T&amp; operator=(T&amp;&amp; other) noexcept // 移动赋值
{
    // 防止自赋值
    if (this == &amp;other)
        return *this; // delete[]/size=0 也可以
    
    delete[] mArray;                               // 释放 *this 中的资源
    mArray = std::exchange(other.mArray, nullptr); // 令 other 遗留在合法状态
    size = std::exchange(other.size, 0);
    return *this;
}
}}
}}

在复制赋值不能从资源复用中受益的情形下（它不管理堆分配数组，且不含这么做的（可能传递的）成员，例如 {{lc|std::vector}} 或 {{lc|std::string}} 成员），有一种流行的便捷方式：复制并交换赋值运算符，它按值接收形参（从而根据实参的值类别而同时支持复制和移动赋值），交换形参，并令析构函数进行清理。
{{source|1=
// 复制赋值（复制并交换）
T&amp; T::operator=(T other) noexcept // 调用复制/移动构造函数以构造 other
{
    std::swap(size, other.size); // 在 *this 与 other 间交换资源
    std::swap(mArray, other.mArray);
    return *this;
} // 调用 other 的析构函数以释放先前 *this 所保有的资源
}}
这种形式自动提供{{rlp|exceptions#异常安全|强异常保证}}，但禁止资源复用。

====流的提取与插入====
接受 {{c/core|std::istream&amp;}} 或 {{c/core|std::ostream&amp;}} 作为左侧实参的 {{c/core|operator&gt;&gt;}} 与 {{c/core|operator&lt;&lt;}} 的重载，被称为插入与提取运算符。因为它们接收用户定义类型为右实参（{{spar|a@b}} 中的 {{c|b}}），所以它们必须以非成员实现。
{{source|1=
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const T&amp; obj)
{
    // 向流写入 obj
    return os;
}

std::istream&amp; operator&gt;&gt;(std::istream&amp; is, T&amp; obj)
{
    // 从流读取 obj
    if( /* 不能构造 T */ )
        is.setstate(std::ios::failbit);
    return is;
}
}}
这些运算符有时实现为{{rlp|friend|友元函数}}。

====函数调用运算符====
当用户定义的类重载了函数调用运算符 {{c/core|operator()}} 时，它就成为{{named req|FunctionObject}}类型。

这种类型的对象能用于函数调用式的表达式：
{{source|1=
// 此类型的对象表示一个变量的线性函数 a * x + b。
struct Linear
{
    double a, b;
    
    double operator()(double x) const
    {
        return a * x + b;
    }
};

int main()
{
    Linear f{2, 1};  // 表示函数 2x + 1。
    Linear g{-1, 0}; // 表示函数 -x。
    // f 和 g 是能像函数一样使用的对象。
    
    double f_0 = f(0);
    double f_1 = f(1);
    
    double g_0 = g(0);
}
}}

许多标准库[[cpp/algorithm|算法]]都接受{{named req|FunctionObject}}以定制它们的行为。{{c/core|operator()}} 没有特别值得注意的规范形式，此处演示它的用法：
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Sum
{
    int sum = 0;
    void operator()(int n) { sum += n; }
};

int main()
{
    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};
    Sum s = std::for_each(v.begin(), v.end(), Sum());
    std::cout &lt;&lt; "和为 " &lt;&lt; s.sum &lt;&lt; '\n';
}

|output=
和为 15
}}

参阅 {{rlp|lambda|lambda 表达式}}。

====自增与自减====
当表达式中出现后缀自增与自减时，以一个整数实参 {{c|0}} 调用用户定义函数（{{c/core|operator++}} 或 {{c/core|operator--}}）。它典型地声明为 {{c|T operator++(int)}} 或 {{c|T operator--(int)}}，其中参数被忽略。后缀自增与自减运算符通常以前缀版本实现：
{{source|1=
struct X
{
    // 前缀自增
    X&amp; operator++()
    {
        // 实际上的自增在此进行
        return *this; // 以引用返回新值
    }
    
    // 后缀自增
    X operator++(int)
    {
        X old = *this; // 复制旧值
        operator++();  // 前缀自增
        return old;    // 返回旧值
    }
    
    // 前缀自减
    X&amp; operator--()
    {
        // 实际上的自减在此进行
        return *this; // 以引用返回新值
    }
    
    // 后缀自减
    X operator--(int)
    {
        X old = *this; // 复制旧值
        operator--();  // 前缀自减
        return old;    // 返回旧值
    }
};
}}
尽管前自增/前自减的规范形式是返回引用的，但同任何运算符重载一样，它的返回类型是用户定义的；例如这些运算符对 {{lc|std::atomic}} 的重载返回值。

====二元运算符====
典型情况下，二元运算符都被实现为两个类型对称的非成员以维持对称性（例如，将复数与整数相加时，如果 {{c/core|operator+}} 是复数类型的成员函数，那么只有{{c|复数 + 整数}}能编译，而{{c|整数 + 复数}}不能）。因为每个二元算术运算符都存在对应的复合赋值运算符，所以二元算数运算符的规范形式是基于它对应的复合赋值实现的：
{{source|1=
class X
{
public:
    X&amp; operator+=(const X&amp; rhs) // 复合赋值（不必，但通常是成员函数，以修改私有成员）
    {
        /* 将 rhs 加到 *this 发生于此 */
        return *this; // 以引用返回结果
    }
    
    // 在类体内定义的友元是 inline 的，且在非 ADL 查找中被隐藏
    friend X operator+(X lhs,        // 按值传递 lhs 有助于优化链状的 a + b + c
                       const X&amp; rhs) // 否则，两个形参都是 const 引用
    {
        lhs += rhs; // 复用复合赋值
        return lhs; // 以值返回结果（使用移动构造函数）
    }
};
}}

====比较运算符====
标准库的算法（如 {{lc|std::sort}}）和容器（如 {{lc|std::set}}）在默认情况下期待 {{c/core|operator&lt;}} 对于用户提供的类型有定义，并期待它实现严格弱序（从而满足{{named req|Compare|比较}}要求）。一种为结构体实现严格弱序的惯用方式是使用 {{lc|std::tie}} 提供的字典序比较：
{{source|1=
struct Record
{
    std::string name;
    unsigned int floor;
    double weight;
    
    friend bool operator&lt;(const Record&amp; l, const Record&amp; r)
    {
        return std::tie(l.name, l.floor, l.weight)
             &lt; std::tie(r.name, r.floor, r.weight); // 保持相同顺序
    }
};
}}

典型地，一旦提供了 {{c/core|operator&lt;}}，其他关系运算符就都能通过 {{c/core|operator&lt;}} 来实现。
{{source|1=
inline bool operator&lt; (const X&amp; lhs, const X&amp; rhs) { /* 做实际比较 */ }
inline bool operator&gt; (const X&amp; lhs, const X&amp; rhs) { return rhs &lt; lhs; }
inline bool operator&lt;=(const X&amp; lhs, const X&amp; rhs) { return !(lhs &gt; rhs); }
inline bool operator&gt;=(const X&amp; lhs, const X&amp; rhs) { return !(lhs &lt; rhs); }
}}

类似地，不相等运算符典型地通过 {{c/core|1=operator==}} 来实现：
{{source|1=
inline bool operator==(const X&amp; lhs, const X&amp; rhs) { /* 做实际比较 */ }
inline bool operator!=(const X&amp; lhs, const X&amp; rhs) { return !(lhs == rhs); }
}}

当提供了三路比较（如 {{lc|std::memcmp}} 或 {{lc|std::string::compare}}）时，所有六个双路比较运算符都能通过它表达：
{{source|1=
inline bool operator==(const X&amp; lhs, const X&amp; rhs) { return cmp(lhs,rhs) == 0; }
inline bool operator!=(const X&amp; lhs, const X&amp; rhs) { return cmp(lhs,rhs) != 0; }
inline bool operator&lt; (const X&amp; lhs, const X&amp; rhs) { return cmp(lhs,rhs) &lt;  0; }
inline bool operator&gt; (const X&amp; lhs, const X&amp; rhs) { return cmp(lhs,rhs) &gt;  0; }
inline bool operator&lt;=(const X&amp; lhs, const X&amp; rhs) { return cmp(lhs,rhs) &lt;= 0; }
inline bool operator&gt;=(const X&amp; lhs, const X&amp; rhs) { return cmp(lhs,rhs) &gt;= 0; }
}}

====数组下标运算符====
提供数组式访问并同时允许读写的用户定义类，典型地为 {{c/core|operator[]}} 定义两个重载：const 和非 const 变体：
{{source|1=
struct T
{
          value_t&amp; operator[](std::size_t idx)       { return mVector[idx]; }
    const value_t&amp; operator[](std::size_t idx) const { return mVector[idx]; }
};
}}
{{rrev|since=c++23|
此外，还可以利用{{rlps|member functions#显式对象形参}}将它们表示为单个成员函数模板：
{{source|1=
struct T
{
    decltype(auto) operator[](this auto&amp; self, std::size_t idx)
    {
        return self.mVector[idx];
    }
};
}}
}}
如果已知值类型是标量类型，那么 const 变体应按值返回。

当不希望或不可能直接访问容器元素，或者要区别左值（{{c|1=c[i] = v;}}）和右值（{{c|1=v = c[i];}}）的不同用法时，{{c/core|operator[]}} 可以返回代理。示例见 {{lc|std::bitset::operator[]}}。

{{rev begin}}
{{rev|until=c++23|
{{c/core|operator[]}} 运算符只能接收一个下标。为提供多维数组访问语义，例如实现三维数组访问 {{c|1=a[i][j][k] = x;}}，{{c/core|operator[]}} 必须返回到二维平面的引用，它必须拥有自己的 {{c/core|operator[]}} 并返回到一维行的引用，而行必须拥有返回到元素的引用的 {{c/core|operator[]}}。为避免这种复杂性，一些库选择代之以重载 {{c/core|operator()}}，使得 3D 访问表达式拥有 Fortran 式的语法 {{c|1=a(i, j, k) = x;}}。
}}
{{rev|since=c++23|
下标运算符能接收多于一个下标。例如 3D 数组类的一个声明为 {{c|T&amp; operator[](std::size_t x, std::size_t y, std::size_t z);}} 的 {{c/core|operator[]}} 能直接访问元素。
}}
{{rev end}}

{{example
|code=
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;

template&lt;typename T, std::size_t Z, std::size_t Y, std::size_t X&gt;
struct Array3d
{
    std::array&lt;T, X * Y * Z&gt; m{};
    
    constexpr T&amp; operator[](std::size_t z, std::size_t y, std::size_t x) // C++23
    {
        assert(x &lt; X and y &lt; Y and z &lt; Z);
        return m[z * Y * X + y * X + x];
    }
};

int main()
{
    Array3d&lt;int, 4, 3, 2&gt; v;
    v[3, 2, 1] = 42;
    std::cout &lt;&lt; "v[3, 2, 1] = " &lt;&lt; v[3, 2, 1] &lt;&lt; '\n';
}
|output=
v[3, 2, 1] = 42
}}
}}

====逐位算术运算符====
实现{{named req|BitmaskType|位掩码类型}}的规定的用户定义类和枚举，要求重载逐位算术运算符 {{c/core|operator&amp;}}、{{c/core|operator{{!}}}}、{{c/core|operator^}}、{{c/core|operator~}}、{{c/core|operator&amp;{{=}}}}、{{c/core|operator{{!}}{{=}}}} 及 {{c/core|operator^{{=}}}}，而且可重载位移运算符 {{c/core|operator&lt;&lt;}}、{{c/core|operator&gt;&gt;}}、{{c/core|operator&gt;&gt;{{=}}}} 及 {{c/core|operator&lt;&lt;{{=}}}}。规范实现通常遵循上述的二元算术运算符。

====布尔取反运算符====
{{rev begin}}
{{rev|until=c++11|
有意用于布尔语境的用户定义类常重载运算符 {{c/core|operator!}}。这种类也会提供到布尔类型的用户定义转换函数（标准库样例见 {{lc|std::basic_ios}}），而 {{c/core|operator!}} 的受期待行为是返回 {{c/core|operator bool}} 的取反。
}}
{{rev|since=c++11|
由于内建运算符 {{c|!}} 进行[[cpp/language/implicit_conversion#按语境转换|按语境到 {{tt|bool}} 的转换]]，有意用于布尔语境的用户定义类可以只提供 {{c/core|operator bool}} 而无需重载 {{c/core|operator!}} 。
}}
{{rev end}}

====罕有重载的运算符====
下列运算符罕有重载：
* 取址运算符 {{c/core|operator&amp;}}。如果对不完整类型的左值应用一元 &amp;，而完整类型声明了重载的 {{c/core|operator&amp;}}，那么未指明运算符拥有内建含义还是调用运算符函数。因为此运算符可能被重载，所以泛型库都用 {{lc|std::addressof}} 取得用户定义类型的对象的地址。最为人熟知的规范重载的 {{c/core|operator&amp;}} 是 Microsoft 类 [https://docs.microsoft.com/en-us/cpp/atl/reference/ccomptrbase-class?view=msvc-160#operator_amp CComPtrBase]。在 [http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/reference/operator/and_predicate.html boost.spirit] 中可以找到该运算符在 EDSL 的使用案例。
* 布尔逻辑运算符 {{c/core|operator&amp;&amp;}} 与 {{c/core|operator{{!!}}}}。不同于内建版本，重载版本无法实现短路求值。{{rev inl|until=c++17|而且不同于内建版本，它们也不会令左操作数的求值按顺序早于右操作数。}}标准库中，这些运算符仅由 {{lc|std::valarray}} 重载。
* 逗号运算符 {{c/core|operator,}}。{{rev inl|until=c++17|与内建版本不同，重载版本不会令左操作数的求值按顺序早于右操作数。}}因为此运算符可能被重载，所以泛型库都用 {{c|a, void(), b}} 这种表达式取代 {{c|a, b}}，以对用户定义类型的表达式按顺序求值。boost 库在 [http://www.boost.org/doc/libs/release/libs/assign/doc/index.html#intro boost.assign]、[https://github.com/boostorg/spirit/blob/develop/include/boost/spirit/home/qi/string/symbols.hpp#L317 boost.spirit] 及几个其他库中使用 {{tt|operator,}}。数据库访问库 [http://soci.sourceforge.net/doc.html SOCI] 也重载了 {{tt|operator,}}。
* 通过成员指针的成员访问 {{c/core|operator-&gt;*}}。重载此运算符并没有特别缺点，但实践中少有使用。有人推荐这能作为[http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf 智能指针接口]的一部分，且实际上在 [http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator boost.phoenix] 中的 actor 有实际用途。它在像 [https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557 cpp.react] 这样的 EDSL 中更常见。

===注解===
{{ftm begin|std=1|comment=1}}
{{ftm|std=C++23|value=202207L|__cpp_static_call_operator|静态的 {{c/core|operator()}}}}
{{ftm|std=C++23|value=202211L|__cpp_multidimensional_subscript|静态的 {{c/core|operator[]}}}}
{{ftm end}}

===关键词===
{{ltt|cpp/keyword/operator}}

===示例===
{{example
|code=
#include &lt;iostream&gt;

class Fraction
{
    // 或 C++17 的 std::gcd
    int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }
    
    int n, d;
public:
    Fraction(int n, int d = 1) : n(n / gcd(n, d)), d(d / gcd(n, d)) {}
    
    int num() const { return n; }
    int den() const { return d; }
    
    Fraction&amp; operator*=(const Fraction&amp; rhs)
    {
        int new_n = n * rhs.n / gcd(n * rhs.n, d * rhs.d);
        d = d * rhs.d / gcd(n * rhs.n, d * rhs.d);
        n = new_n;
        return *this;
    }
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f)
{
    return out &lt;&lt; f.num() &lt;&lt; '/' &lt;&lt; f.den() ;
}

constexpr bool operator==(const Fraction&amp; lhs, const Fraction&amp; rhs)
{
    return lhs.num() == rhs.num() &amp;&amp; lhs.den() == rhs.den();
}

constexpr bool operator!=(const Fraction&amp; lhs, const Fraction&amp; rhs)
{
    return !(lhs == rhs);
}

constexpr Fraction operator*(Fraction lhs, const Fraction&amp; rhs)
{
    return lhs *= rhs;
}

int main()
{
    Fraction f1(3, 8), f2(1, 2), f3(10, 2);
    std::cout &lt;&lt; f1 &lt;&lt; " * " &lt;&lt; f2 &lt;&lt; " = " &lt;&lt; f1 * f2 &lt;&lt; '\n'
              &lt;&lt; f2 &lt;&lt; " * " &lt;&lt; f3 &lt;&lt; " = " &lt;&lt; f2 * f3 &lt;&lt; '\n'
              &lt;&lt;  2 &lt;&lt; " * " &lt;&lt; f1 &lt;&lt; " = " &lt;&lt;  2 * f1 &lt;&lt; '\n';
}
|output=
3/8 * 1/2 = 3/16
1/2 * 5/1 = 5/2
2 * 3/8 = 3/4
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1481|std=C++98|before=非成员前缀自增运算符的形参只能具有类类型，枚举类型，或到这些类型的引用类型|after=类型没有限制}}
{{dr list item|wg=cwg|dr=2931|std=C++23|before=显式对象成员运算符函数可以没有具有类类型，枚举类型，或到这些类型的引用类型的形参|after=已禁止}}
{{dr list end}}

===参阅===
* {{rlp|operator precedence|运算符优先级}}
* {{rlp|operator alternative|代用运算符语法}}
* {{rlp|adl|实参依赖查找}}
{{cpp/language/operators}}

===外部链接===
{{eli|&lt;references/&gt;}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}