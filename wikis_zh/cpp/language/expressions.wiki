{{title|表达式}}
{{cpp/language/expressions/navbar}}
表达式是{{i|运算符}}和它们的{{i|操作数}}的序列，它指定一项计算。

表达式的求值可以产生一个结果（比如 {{c|2 + 2}} 的求值产生结果 {{c|4}}），也可能产生副作用（比如对 {{c|std::printf("%d", 4)}} 的求值在标准输出上打印字符 {{c|'4'}}）。

每个 C++ 表达式均被描述为具有两种独立的性质：类型和值类别。

====概述====
* {{rlp|value category|值类别}}（左值、右值{{rev inl|since=c++11|、泛左值、纯右值、亡值}}）是根据表达式的值所进行的分类
* 实参和子表达式的{{rlp|eval order|求值顺序}}指定获得中间结果所用的顺序

===运算符===
{{cpp/language/operators}}

* {{rlp|operator precedence|运算符优先级}}定义了运算符绑定到它的各个实参的顺序
* {{rlp|operator alternative|替代表示}}是一些运算符的其他代用书写方式
* {{rlp|operators|运算符重载}}允许对用户定义的类指定各运算符的行为。

====转换====
* {{rlp|implicit conversion|标准转换}}是从一个类型到另一类型的隐式转换
* {{rlp|const_cast|{{tt|const_cast}} 转换}}
* {{rlp|static_cast|{{tt|static_cast}} 转换}}
* {{rlp|dynamic_cast|{{tt|dynamic_cast}} 转换}}
* {{rlp|reinterpret_cast|{{tt|reinterpret_cast}} 转换}}
* {{rlp|explicit cast|显式类型转换}}，可使用 C 风格写法和函数风格写法
* {{rlp|cast operator|用户定义转换}}使得可以指定源自用户定义类的转换

====内存分配====
* {{rlp|new|new 表达式}}动态地分配内存
* {{rlp|delete|delete 表达式}}动态地解分配内存

====其他====
* {{rlp|constant expression|常量表达式}}能在编译期求值并在编译期语境（如模板实参、数组大小等等）中使用
* {{rlpt|sizeof}}
* {{rlpt|alignof}}
* {{rlpt|typeid}}
* {{rlp|throw|throw 表达式}}

===初等表达式===
任何运算符的操作数都可以是其他的表达式或初等表达式（例如，{{c|1 + 2 * 3}} 中 operator+ 的操作数是[[#完整表达式|子表达式]] {{c|2 * 3}} 和初等表达式 {{c|1}}）。

初等表达式包括以下各项：
* {{rlpt|this}}
* 字面量（例如 {{c|2}} 或 {{c|"Hello, world"}}）
* 标识表达式，包括
** 经过适当声明的{{rlps|identifiers#无限定的标识符}}（例如 {{c|n}} 或 {{c|cout}}），
** 经过适当声明的{{rlps|identifiers#有限定的标识符}}（例如 {{lc|std::string::npos}}），以及
** 在{{rlps|declarations#声明符}}中将要声明的标识符
{{rrev|since=c++26|
:* {{rlps|pack indexing#包索引表达式}}
}}
{{rev begin}}
{{rev|since=c++11|
* {{rlp|lambda|lambda 表达式}}
}}
{{rev|since=c++17|
* {{rlp|fold|折叠表达式}}
}}
{{rev|since=c++20|
* {{rlp|requires|requires 表达式}}
}}
{{rev end}}

任何带括号表达式也被归类为初等表达式：这确保了括号具有比任何运算符更高的优先级。括号保持值、类型和值类别不变。

====字面量====
字面量是 C++ 程序中用以表现嵌入到源代码中的常量值的记号。

* {{rlp|integer literal|整数字面量}}是整数类型的十进制、八进制、十六进制{{rev inl|since=c++14|或二进制}}的数值
* {{rlp|character literal|字符字面量}}是有下列类型之一的单个字符：
:* {{c/core|char}} 或 {{c/core|wchar_t}}
{{rev begin}}
{{rev|since=c++11|
:* {{c/core|char16_t}} 或 {{c/core|char32_t}}
}}
{{rev|since=c++20|
:* {{c/core|char8_t}}
}}
{{rev end}}
* {{rlp|floating literal|浮点数字面量}}是 {{c/core|float}}、{{c/core|double}} 或 {{c/core|long double}} 类型的值
* {{rlp|string literal|字符串字面量}}是有下列类型之一的字符序列：
:* {{c/core|const char[]}} 或 {{c/core|const wchar_t[]}}
{{rev begin}}
{{rev|since=c++11|
:* {{c/core|const char16_t[]}} 或 {{c/core|const char32_t[]}}
}}
{{rev|since=c++20|
:* {{c/core|const char8_t[]}}
}}
{{rev end}}
* {{rlp|bool literal|布尔字面量}}是 {{c/core|bool}} 类型的值，即 {{c|true}} 和 {{c|false}}
{{rrev|since=c++11|
* {{rlpt|nullptr}} 是指针字面量，指定一个空指针值
* {{rlp|user literal|用户定义字面量}}是用户指定的类型的常量值
}}

===完整表达式===
{{i|成分表达式}}的定义如下：
* 表达式的成分表达式是该表达式自身。
* {{rlp|initialization|花括号包围的初始化器列表}}或表达式列表的成分表达式是对应列表中所有元素的成分表达式。
* 以 {{ttb|1==}} 开头{{rlp|initialization|初始化器}}的成分表达式是{{spar sep|初始化器子句}}的成分表达式。
{{source|1=
int num1 = 0;
num1 += 1; // 情况1：“num += 1” 的成分表达式是 “num += 1”
 
int arr2[2] = {2, 22} // 情况2：“{2, 22}” 的成分表达式是 “2” 和 “22”
                      // 情况3：“= {2, 22}” 的成分表达式是 “{2, 22}” 的
                      //       成分表达式（也就是 “2” 和 “22”）
}}

表达式 {{c|E}} 的{{i|立即子表达式}}是：
* {{c|E}} 的各操作数的成分表达式，
{{rev begin}}
{{rev|since=c++14|
* {{c|E}} 创建{{rlp|aggregate initialization#定义|聚合体}}对象时，该初始化中用到的每个{{rlp|data members#成员初始化|默认成员初始化器}}的成分表达式，
}}
{{rev|since=c++11|
* {{c|E}} 是 {{rlp|lambda|lambda 表达式}}时，以复制捕获的各实体的初始化以及捕获的各初始化器的成分表达式，
}}
{{rev end}}
* {{c|E}} 隐式调用的函数调用，或
* {{c|E}} 是函数调用或隐式调用了函数时，该调用中用到的每个{{rlp|default arguments|默认实参}}的成分表达式。

表达式 {{c|E}} 的{{i|子表达式}}是 {{c|E}} 的立即子表达式或 {{c|E}} 的立即子表达式的子表达式。{{rev inl|since=c++11|注意在 lambda 表达式的“函数体”中出现的表达式不是该 lambda 表达式的子表达式。}}

{{i|完整表达式}}是：
* [[#潜在求值表达式|不求值操作数]]
* {{rlp|constant expression|常量表达式}}
{{rrev|since=c++20|
* {{rlp|consteval|立即调用}}
}}
* {{rlps|declarations#简单声明}}的声明符或{{rlp|constructor|成员初始化器}}，包括其中初始化器的成分表达式
* 对在非临时对象或生存期被延长的临时对象的{{rlp|lifetime|生存期}}结束时生成的{{rlp|destructor|析构函数}}的调用
{{rrev|since=c++26|
* {{rlp|contracts|契约断言}}的谓词
}}
* 不是其他任何表达式的子表达式的表达式

如果某个语言构造被定义成产生对函数的隐式调用，那么该语言构造的使用在该定义中会被视为表达式。为了满足在表达式中出现的语言构造的要求而对该表达式的结果应用的转换也会被视为该完整表达式的一部分。

对于初始化器，对实体进行初始化{{rev inl|since=c++14|（包括对聚合体的默认成员初始化器求值）}}也被视为完整表达式的一部分。

===潜在求值表达式===
{{rev begin}}
{{rev|until=c++11|
除了以下表达式，其他表达式都''潜在求值''：
* {{rlpt|sizeof}} 运算符的操作数
* {{rlpt|typeid}} 运算符的操作数，且指定的不是{{rlp|object#多态对象|多态}}类类型的左值
}}
{{rev|since=c++11|
以下操作数是''不求值操作数''，它们不会被求值：
* {{rlpt|typeid}} 运算符应用到的{{rlp|object#多态对象|多态}}类类型的泛左值以外的表达式
* 作为 {{rlpt|sizeof}} 运算符的操作数的表达式
* {{rlpt|noexcept}} 运算符的操作数
* {{rlpt|decltype}} 说明符的操作数
{{rrev|since=c++20|
* {{rlps|constraints#概念}}定义中的{{spar|约束表达式}}
* {{rlp|constraints#requires 子句|{{c/core|requires}} 子句}}中紧随 {{c/core|requires}} 关键词后的表达式
* 在 {{rlp|requires|{{c/core|requires}} 表达式}}中的{{spar sep|要求序列}}里面出现的表达式
}}

除了以下表达式，其他表达式都''潜在求值''：
* 不求值操作数
* 不求值操作数的子表达式
}}
{{rev end}}

潜在求值表达式被{{rlps|definition#ODR 使用}}。

{{todo|不求值操作数相关的示例}}

===弃值表达式===
{{i|弃值表达式}}是只用来实施它的副作用的表达式。从这种表达式计算的值会被舍弃。这样的表达式包括任何{{rlps|statements#表达式语句}}的完整表达式，内建逗号运算符的左边的实参，以及转换到类型 {{c/core|void}} 的类型转换表达式的实参。

弃值表达式的计算结果永远不会进行数组到指针和函数到指针转换。只有在该表达式是 {{rlp|cv|有 volatile 限定的}}{{rev inl|until=c++11|左值}}{{rev inl|since=c++11|泛左值}}，并具有下列形式之一（必须为它的内建含义，可以有括号）时才会进行左值到右值转换：
* 标识表达式（id-expression）
* 数组下标表达式
* 类成员访问表达式
* 间接寻址
* 成员指针操作
* 条件表达式，它的第二个和第三个操作数都是这些表达式中的一种
* 逗号表达式，它的右操作数是这些表达式中的一种。

此外，如果该左值拥有具有 volatile 限定的类类型，那么要求用 volatile 复制构造函数来初始化作为结果的右值临时量。

{{rrev|since=c++17|
如果表达式（经过可能会发生的任何左值向右值转换之后）是非 {{c/core|void}} 纯右值，那么就会进行{{rlps|implicit conversion#临时量实质化}}。

当表达式丢弃了声明为 {{attr|nodiscard}} 的值，而它不是转换到 {{c/core|void}} 类型的表达式时，编译器可以产生警告。
}}&lt;br&gt;

{{rrev|since=c++20|
===表达式等价===
若干表达式 {{c|e1}}、{{c|e2}}、···、{{c|eN}} 在满足以下所有条件时''表达式等价''：
# 它们具有相同效果。
# 它们要么都是{{rlps|constant expression#常量子表达式}}，要么都不是常量子表达式。
# 它们要么都是 {{rlp|noexcept spec|noexcept}}，要么都不是。

当且仅当 {{c|e1}} 与 {{c|e2}} 表达式等价时，{{c|e1}} ''表达式等价于'' {{c|e2}}（这意味着此时 {{c|e2}} 也表达式等价于 {{c|e1}}）。
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1054|std=C++98|before=为 volatile 变量赋值可能会由于需要对赋值结果&lt;br&gt;进行左值到右值转换而产生不必要的读操作|after=引入弃值表达式并将该情况排除在&lt;br&gt;需要进行该转换的情况之外}}
{{dr list item|wg=cwg|dr=1343&lt;!-- 见 P0507R0 --&gt;|std=C++98|before=聚合初始化中析构函数调用的顺序尚未指定|after=正确指定了聚合初始化中的完整表达式}}
{{dr list item|wg=cwg|dr=1383|std=C++98|before=弃值表达式中会应用左值到右值转换的表达式列表也覆盖了重载的运算符|after=只覆盖内建运算符}}
{{dr list item|wg=cwg|dr=1576|std=C++11|before=不会对弃值 volatile 亡值表达式应用作指导右值转换|after=此时会应用该转换}}
{{dr list item|wg=cwg|dr=2249|std=C++98|before=在声明符中将要声明的标识符不是标识表达式|after=是标识表达式}}
{{dr list item|wg=cwg|dr=2431|std=C++11|before=对绑定到引用的临时量的析构函数的调用不是完整表达式|after=是完整表达式}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc see c|c/language/expressions|表达式|nomono=true}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}