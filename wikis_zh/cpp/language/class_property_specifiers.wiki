{{title|类性质说明符 {{mark since c++26}}}}
{{cpp/language/classes/navbar}}

指定类{{i|可替换}}（{{c/core|replaceable_if_eligible}}），{{i|可平凡重定位}}（{{c/core|trivially_relocatable_if_eligible}}），或者类不能被{{rlp|derived class|派生}}（{{c/core|final}}）。

===语法===
{{rlp|class property specifiers|类性质说明符}}出现于类定义的开头，紧跟类名之后，并且不能出现在类声明之内。

{{sdsc begin}}
{{sdsc|{{spar|类关键词}} {{spar optional|属性}} {{spar|类头名}} {{spar optional|类性质说明符序列}} {{spar optional|基类子句}}}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|类性质说明符序列}}|一或多个 {{spar sep|类性质说明符}}，但每个最多仅可出现一次。}}
{{par|{{spar|类性质说明符}}|下列之一：{{ltt|cpp/identifier with special meaning/final}}、{{ltt|cpp/identifier with special meaning/replaceable_if_eligible}} 和 {{ltt|cpp/identifier with special meaning/trivially_relocatable_if_eligible}}。}}
{{par end}}

此前{{mark c++26}}，处于{{spar optional|类性质说明符序列}}位置的是{{spar optional|类虚说明符}}，它仅允许作为 {{rlp|final|{{tt|final}} 说明符}}的 {{c/core|final}} {{mark since c++11}}。

===解释===
{{c/core|final}}、{{c/core|replaceable_if_eligible}} 和 {{c/core|trivially_relocatable_if_eligible}} 是在类头中使用时具有特殊含义的标识符。其他语境中，它们并非保留词，且可用于命名对象和函数。

===={{c/core|final}} 说明符====
{{c/core|final}} 指定，这个类不能出现在其他类定义的{{spar sep|基类说明符列表}}中（换言之，它不能被派生）。否则程序非良构（生成一条编译时错误）。{{c/core|final}} 也可用于 {{rlp|union}} 定义，这种情况下无效果{{rev inl|since=c++14|（除了 {{lc|std::is_final}} 的结果外）}}，因为联合体不能被派生。

===={{c/core|replaceable_if_eligible}} 说明符====
{{c/core|replaceable_if_eligible}} 指定，如果这个类[[#替换的资格|{{i|有替换资格}}]]，则它[[#可替换性|{{i|可替换}}]]。

===={{c/core|trivially_relocatable_if_eligible}} 说明符====
{{c/core|trivially_relocatable_if_eligible}} 指定，如果这个类[[#可平凡重定位的资格|{{i|有可平凡重定位资格}}]]，则它[[#可平凡重定位性|{{i|可平凡重定位}}]]。

====可替换性====
如果类 {{tt|C}} [[#替换的资格|{{i|有替换资格}}]]，并且以下之一成立，则它{{i|可替换}}：
* 带有 {{c/core|replaceable_if_eligible}} {{spar|类性质说明符}}
* 是没有用户声明的{{rlps|member functions#特殊成员函数}}的 {{rlpt|union}}
* [[#默认可移动性|{{i|默认可移动}}]]

====替换的资格====
除非以下之一成立，否则类 {{tt|C}} 均{{i|有替换资格}}：
* 具有并非[[#可替换性|{{i|可替换}}]]类的{{rlp|derived_class|基类}}
* 具有并非为[[#可替换性|{{i|可替换}}]]类型的{{rlp|data members|非静态数据成员}}
* 针对以 {{tt|C}} 类型的{{rlps|value_category#亡值}}对 {{tt|C}} 类型的对象进行{{rlp|direct initialization|直接初始化}}的重载解析失败，或者找到弃置的构造函数
* 针对以 {{tt|C}} 类型的{{rlps|value category#亡值}}对 {{tt|C}} 类型的{{rlps|value_category#左值}}进行赋值的重载解析失败，或者找到弃置的赋值运算符函数
* 具有{{rlps|destructor#弃置的析构函数}}

====可平凡重定位性====
如果类[[#可平凡重定位的资格|{{i|有可平凡重定位资格}}]]，并且以下之一成立，则它{{i|可平凡重定位}}：
* 带有 {{c/core|trivially_relocatable_if_eligible}} {{spar|类性质说明符}}
* 是没有用户声明的{{rlps|member functions#特殊成员函数}}的 {{rlpt|union}}
* [[#默认可移动性|{{i|默认可移动}}]]

====可平凡重定位的资格====
除非类具有下列之一，否则类{{i|有可平凡重定位资格}}：
* 任何{{rlps|derived_class#虚基类}}
* 并非[[#可平凡重定位性|{{i|可平凡重定位}}]]类的{{rlp|derived class|基类}}
* 有{{rlp|data members|非静态数据成员}}的对象类型不是[[#可平凡重定位性|{{i|可平凡重定位}}]]类型
* {{rlps|destructor#弃置的析构函数}}
但，具有一个或多个多态类类型子对象的 [[cpp/language/union|{{c/core|union}}]] 是否{{i|有可平凡重定位资格}}是由实现定义的。

====默认可移动性====
如果以下条件均满足，那么类 {{tt|C}} 是{{i|默认可移动}}的：
* 针对以 {{tt|C}} 类型的{{rlps|value category#亡值}}对 {{tt|C}} 类型的对象进行{{rlp|direct initialization|直接初始化}}的重载解析，选择的是作为 {{tt|C}} 的直接成员的构造函数，且它既非用户提供也未被弃置。
* 针对以 {{tt|C}} 类型的{{rlps|value category#亡值}}对 {{tt|C}} 类型的{{rlps|value category#左值}}进行赋值的重载解析，选择的是作为 {{tt|C}} 的直接成员的赋值运算符函数，且它既非用户提供也未被弃置。
* {{tt|C}} 有一个{{rlp|destructor|析构函数}}且它既非用户提供也未被弃置。

===关键词===
{{ltt|cpp/identifier with special meaning/final}},
{{ltt|cpp/identifier with special meaning/replaceable_if_eligible}},
{{ltt|cpp/identifier with special meaning/trivially_relocatable_if_eligible}}

===注解===
* 并非所有{{named req|TriviallyCopyable}}类都{{i|可替换}}或[[#可平凡重定位性|{{i|可平凡重定位}}]]的。
* 在设立[[#可平凡重定位性|{{i|可平凡重定位}}]]或[[#可替换性|{{i|可替换性}}]]时，不考虑{{rlps|member functions#特殊成员函数}}的{{rlp|access|可访问性}}。
* 带有 const 限定的或者引用{{rlp|data members|非静态数据成员}}的类可以是[[#可平凡重定位性|{{i|可平凡重定位}}]]的。
* 没有用户声明{{rlps|member functions#特殊成员函数}}的 {{rlpt|union}}，和[[#默认可移动性|{{i|默认可移动}}]]的类，都是[[#可替换性|{{i|可替换}}]]且[[#可平凡重定位性|{{i|可平凡重定位}}]]的，即使定义时没有类性质说明符也是如此。

{{feature test macro|__cpp_trivial_relocatability|std=C++26|value=202502L|{{ls|#可平凡重定位性}}}}

===示例===
{{example
|code=
struct final;      // OK；声明名为 'final' 的类，未使用类性质说明符。
struct IF final;   // 非良构：类性质说明符不能出现在函数声明中。
struct F final {}; // OK；说明符将类 F 标记为不能派生。
struct D: F {};    // 非良构：类 F 不能被派生。

// OK；说明符将类 R 标记为若有资格则可替换。
struct R replaceable_if_eligible {};

// OK；说明符将类 T 标记为若有资格则可平凡定位。
struct T trivially_relocatable_if_eligible {};

// OK；一个类可以使用多个类性质说明符标记。
struct FRT final replaceable_if_eligible trivially_relocatable_if_eligible {};

// 非良构：每个类性质说明符仅可最多出现一次。
struct FRF final replaceable_if_eligible final {};

int main() {}
}}

===引用===
{{ref std c++26}}
{{ref std|section=6.8.1|title=Trivially relocatable and replaceable types|id=basic.types.general}}
{{ref std end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/language/dsc final}}&lt;!--
{{dsc inc|cpp/types/dsc is_trivially_relocatable}}--&gt;
{{dsc inc|cpp/types/dsc is_final}}
{{dsc end}}