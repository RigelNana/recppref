{{title|显式类型转换}}
{{cpp/language/expressions/navbar}}
用显式和隐式转换的组合进行类型之间的转换。

===语法===
{{sdsc begin}}
{{sdsc|num=1|{{ttb|(}} {{spar|类型标识}} {{ttb|)}} {{spar|一元表达式}}}} 
{{sdsc|num=2|{{spar|简单类型说明符}} {{ttb|(}} {{spar optional|表达式列表}} {{ttb|)}}&lt;br&gt;{{spar|简单类型说明符}} {{ttb|(}} {{spar optional|初始化器列表}} {{ttb|)}}|notes={{mark until c++11}}&lt;br&gt;{{mark since c++11}}}} 
{{sdsc|num=3|{{spar|简单类型说明符}} {{ttb|{}} {{spar optional|初始化器列表}} {{ttb|}&lt;!----&gt;}}|notes={{mark since c++11}}}}
{{sdsc|num=4|{{spar|简单类型说明符}} {{ttb|{}} {{spar|指派初始化器列表}} {{ttb|}&lt;!----&gt;}}|notes={{mark since c++20}}}}
{{sdsc|num=5|{{ttb|typename}} {{spar|标识符}} {{ttb|(}} {{spar optional|初始化器列表}} {{ttb|)}}|notes={{mark since c++11}}}}
{{sdsc|num=6|{{ttb|typename}} {{spar|标识符}} {{ttb|{}} {{spar optional|初始化器列表}} {{ttb|}&lt;!----&gt;}}|notes={{mark since c++11}}}}
{{sdsc|num=7|{{ttb|typename}} {{spar|标识符}} {{ttb|{}} {{spar|指派初始化器列表}} {{ttb|}&lt;!----&gt;}}|notes={{mark since c++20}}}}
{{sdsc end}}

将任意数量的值显式转换成目标类型的值。
@1@ 显式类型转换（cast 表示法）&lt;!--仅有此处一个用途--&gt;，也被称为 ''C 风格转换''。
@2-7@ 显式类型转换（函数表示法），也被称为''函数风格转换''。

{{par begin}}
{{par|{{spar|类型标识}}|{{rlp|type#类型的命名|类型标识}}}}
{{par|{{spar|一元表达式}}|一元表达式（即顶层运算符的{{rlp|operator precedence|优先级}}不高于 C 风格转换的表达式）}}
{{par|{{spar|简单类型说明符}}|{{rlp|declarations#说明符|简单类型说明符}}}}
{{par|{{spar|表达式列表}}|（无括号的{{rlp|operator other#内建的逗号运算符|逗号表达式}}以外的）任意表达式组成的逗号分隔列表}}
{{par|{{spar|初始化器列表}}|{{rlp|initialization|初始化器子句}}组成的逗号分隔列表}}
{{par|{{spar|指派初始化器列表}}|{{rlp|aggregate initialization#指派初始化器|指派初始化器子句}}组成的逗号分隔列表}}
{{par|{{spar|标识符}}|（可有限定的）标识符（包括{{rlps|templates#模板标识}}）}}
{{par end}}

===解释===
@1@ 遇到 C 风格转换时，编译器会尝试按以下顺序将它解释成下列转换表达式：
:@a@ {{box|{{tt|{{rlp|const_cast}}}}{{c/core|&lt;}}{{spar sep|类型标识}}{{c/core|&gt;(}}{{spar sep|一元表达式}}{{c/core|)}}}}；
:@b@ {{box|{{tt|{{rlp|static_cast}}}}{{c/core|&lt;}}{{spar sep|类型标识}}{{c/core|&gt;(}}{{spar sep|一元表达式}}{{c/core|)}}}}，带扩展：额外允许将到{{rlp|derived class|派生类}}的指针或引用转换成到无歧义基类的指针或引用（反之亦然），纵使基类{{rlp|access|不可访问}}也是如此（即此转换忽略 {{c/core|private}} 继承说明符）。同样适用于将{{rlp|pointer|成员指针}}转换到指向无歧义非虚基类的成员的指针；
:@c@ {{c/core|static_cast}}（带扩展）后随 {{c/core|const_cast}}；
:@d@ {{box|{{rlpt|reinterpret_cast}}{{c/core|&lt;}}{{spar sep|类型标识}}{{c/core|&gt;(}}{{spar sep|一元表达式}}{{c/core|)}}}}；
:@e@ {{c/core|reinterpret_cast}} 后随 {{c/core|const_cast}}。
@@ 选择首个满足相应转换运算符要求的方式，即便它非良构（见示例）。如果选择的是 {{c/core|static_cast}} 后随 {{c/core|const_cast}} 的方式，并且该转换存在多种解释，那么该转换非良构。
@@ 另外，C 风格转换写法允许从、向不完整类型的指针，或在不完整类型的指针之间进行双向转换。如果{{spar sep|一元表达式}}的类型和{{spar sep|类型标识}}都是指向不完整类型的指针类型，那么未指定选用 {{c/core|static_cast}} 还是 {{c/core|reinterpret_cast}}。

@2-7@ 函数风格转换会指定一个'''类型'''（{{spar sep|简单类型说明符}}{{rev inl|since=c++11|或{{spar sep|标识符}}}}）和一个'''初始化器'''（剩余部分），它会构造一个具有目标类型 {{tt|T}} 的值，该类型以指定的类型{{rev inl|since=c++17|和初始化器}}确定。
{{rev begin}}
{{rev|until=c++17|
{{tt|T}} 就是指定的类型。
}}
{{rev|since=c++17|
按以下方式确定 {{tt|T}}：
* 如果指定的类型是用于推导类类型的占位类型，那么 {{tt|T}} 是{{rlp|class template argument deduction|类模板推导}}的重载决议选择的函数的返回类型。
{{rrev|since=c++23|
* 否则，如果指定的类型包含{{rlp|auto|占位类型}}，那么 {{tt|T}} 是推导出的类型。
}}
* 否则 {{tt|T}} 就是指定的类型。
}}
{{rev end}}

@@ 按以下方式确定转换结果：
* 如果函数风格转换具有语法 {{v|2}}，并且圆括号恰好包含一个表达式，那么该转换等价于对应的 C 风格转换。
* 否则，如果 {{tt|T}} 是（可有 cv 限定的）{{c/core|void}}，那么结果是不进行初始化的 {{c/core|void}} 类型{{rev inl|until=c++11|右值}}{{rev inl|since=c++11|纯右值}}。
{{rev begin}}
{{rev|until=c++11|
:* 如果初始化器不是 {{c|()}}，那么程序非良构。
}}
{{rev|since=c++11|
:* 如果初始化器不是在{{rlp|pack|包展开}}（如果存在）后不是 {{c|()}} 或 {{c|{}&lt;!----&gt;}}，那么程序非良构。
}}
{{rev end}}
* 否则，如果 {{tt|T}} 是引用类型，那么该函数风格转换的效果与以指定的初始化器{{rlp|direct initialization|直接初始化}}一个 {{tt|T}} 类型虚设变量 {{c|t}} 相同，并且结果就是初始化完成时的 {{c|t}}。
{{rev begin}}
{{rev|until=c++11|
:* 结果是左值。
}}
{{rev|since=c++11|
:* 如果 {{tt|T}} 是左值引用类型或到函数类型的右值引用类型，那么结果是左值。
:* 否则结果是亡值。
}}
{{rev end}}
* 否则结果是 {{tt|T}} 类型{{rev inl|until=c++11|右值}}{{rev inl|since=c++11|纯右值}}，{{rev inl|until=c++17|它指代的临时量}}{{rev inl|since=c++17|它的结果对象}}以指定的初始化器{{rlp|direct initialization|直接初始化}}。

===解决歧义===
====有歧义的声明语句====
在以函数风格转换表达式作为最左侧子表达式的表达式语句，和声明语句间有歧义的情况下，将它当做声明来解决歧义。这种歧义消解是纯语法的：它对语句中出现的名字不考虑除了其是否为类型名之外的含义：
{{source|1=
struct M {};
struct L { L(M&amp;); };
 
M n;
void f()
{
    M(m);    // 声明，等价于 M m;
    L(n);    // 非良构的声明，等价于 L n;
    L(l)(m); // 仍然是声明，等价于 L l((m));
}
}}

{{rrev|since=c++11|
然而，如果在有歧义的声明语句中最外层的声明符有{{rlp|function|尾随返回类型}}，那么只有在尾随返回类型是 {{c/core|auto}} 的情况下才会将该语句当做声明语句：
{{source|
struct M;

struct S
{
    S* operator()();
    int N;
    int M;
    
    void mem(S s)
    {
        auto(s)()-&gt;M; // 表达式（S::M 隐藏 ::M），C++23 前非法
    }
};

void f(S s)
{
    {
        auto(s)()-&gt;N; // 表达式，C++23 前非法
        auto(s)()-&gt;M; // 函数声明，等价于 M s();
    }
    {
        S(s)()-&gt;N;    // 表达式
        S(s)()-&gt;M;    // 表达式
    }
}
}}
}}

====有歧义的函数形参====
以上歧义也可以在声明语境中发生。在该语境下，需要从“以函数风格转换作为初始化器”的对象声明，和涉及“带有被多余的圆括号包围的形参名的函数声明符”的声明中进行选择。解决方案同样是将任何可以是声明的构造视为声明（例如上述潜在的形参声明）：
{{source|1=
struct S
{
    S(int);
};
 
void foo(double a)
{
    S w(int(a)); // 函数声明：有一个类型是 int 的形参 a
    S x(int());  // 函数声明：有一个类型是 int(*)() 的无名形参，该类型从 int() 调整而来
 
    // 避免歧义的方式：
    S y((int(a))); // 对象声明：另外用一组圆括号包裹
    S y((int)a);   // 对象声明：使用 C 风格转换
    S z = int(a);  // 对象声明：使用无歧义的语法
}
}}

{{rrev|since=c++11|
然而，如果有歧义的形参声明最外层的声明符有{{rlp|function|尾随返回类型}}，那么只有在尾随返回类型是 {{c/core|auto}} 的情况下才会将它当做声明：
{{source|
typedef struct BB { int C[2]; } *B, C;

void foo()
{
    S a(B()-&gt;C);    // 对象声明：B()-&gt;C 不能声明形参
    S b(auto()-&gt;C); // 函数声明：有一个类型是 C(*)() 的无名形参，该类型从 C() 调整而来
}
}}
}}

====有歧义的类型标识====
函数风格转换和{{rlp|type#类型的命名|类型标识}}的相似之处也会引发歧义。解决方案是在这种语境中在语法上可以是类型标识的地方都会优先考虑类型标识：
{{source|1=
// int() 和 int(unsigned(a)) 都可以被解析成类型标识：
// int() 表示返回 int 且不接收实参的函数
// int(unsigned(a)) 表示返回 int 且接收一个类型是 unsigned 的实参的函数
void foo(signed char a)
{
    sizeof(int());            // 类型标识（非良构）
    sizeof(int(a));           // 表达式
    sizeof(int(unsigned(a))); // 类型标识（非良构）
 
    (int()) + 1;            // 类型标识（非良构）
    (int(a)) + 1;           // 表达式
    (int(unsigned(a))) + 1; // 类型标识（非良构）
}
}}

{{rrev|since=c++11|
然而，如果有歧义的{{rlp|type#类型的命名|类型标识}}中最外层的{{spar sep|抽象声明符}}有{{rlp|function|尾随返回类型}}，那么只有在尾随返回类型是 {{c/core|auto}} 的情况下才会将它当做类型标识：
{{source|
typedef struct BB { int C[2]; } *B, C;

void foo()
{
    sizeof(B()-&gt;C[1]);    // OK，sizeof(表达式)
    sizeof(auto()-&gt;C[1]); // 错误：对返回数组的函数使用 sizeof
}
}}
}}

===注解===
{{feature test macro|__cpp_auto_cast|{{c|auto(x)}} 和 {{c|auto{x}&lt;!----&gt;}}|value=202110L|std=C++23}}

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iostream&gt;

double f = 3.14;
unsigned int n1 = (unsigned int)f; // C 风格
unsigned int n2 = unsigned(f);     // 函数风格

class C1;
class C2;
C2* foo(C1* p)
{
    return (C2*)p; // 转换不完整类型到不完整类型
}

void cpp23_decay_copy_demo()
{
    auto inc_print = [](int&amp; x, const int&amp; y)
    {
        ++x;
        std::cout &lt;&lt; "x：" &lt;&lt; x &lt;&lt; "，y：" &lt;&lt; y &lt;&lt; '\n';
    };
    
    int p{1};
    inc_print(p, p); // 打印 x：2，y：2，因为此处的形参 y 是 p 的别名
    int q{1};
    inc_print(q, auto{q}); // 打印 x：2，y：1，auto{q}（C++23）转换为纯右值，
                           // 因此形参 y 是 q 的副本（而非 q 的别名）
}

// 在这个例子中，C 风格转换被转译成 static_cast
// 尽管它的作用也可以和 reinterpret_cast 一致
struct A {};
struct I1 : A {};
struct I2 : A {};
struct D : I1, I2 {};

int main()
{
    D* d = nullptr;
//  A* a = (A*)d;                   // 编译时错误
    A* a = reinterpret_cast&lt;A*&gt;(d); // 可以编译
    assert(a == nullptr);
    
    cpp23_decay_copy_demo();
}
|output=
x：2，y：2
x：2，y：1
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1223|paper=P2915R0|std=C++11|before=引入尾随返回类型带来了更多歧义|after=解决这些歧义}}
{{dr list item|wg=cwg|dr=1893|std=C++11|before=函数风格转换没有考虑包展开|after=考虑包展开}}
{{dr list item|wg=cwg|dr=2351|std=C++11|before={{c|void{}&lt;!----&gt;}} 非良构|after=使之良构}}
{{dr list item|wg=cwg|dr=2620|std=C++98|before=对有歧义的函数形参的解决方案可能会被误解|after=改善用词}}
{{dr list item|wg=cwg|dr=2828|std=C++98|before=C 风格转换在 {{c/core|static_cast}} 后随 {{c/core|const_cast}}&lt;br&gt;存在多种解释时非良构，即使实际不会使用这种转换|after=只会考虑实际会使用的转换}}
{{dr list item|wg=cwg|dr=2894|std=C++98|before=函数风格转换可能会创建引用右值|after=只能创建引用左值}}
{{dr list end}}

===引用===
{{ref std c++23}}
{{ref std|section=7.6.1.4|title=Explicit type conversion (functional notation)|id=expr.type.conv}}
{{ref std|section=7.6.3|title=Explicit type conversion (cast notation)|id=expr.cast}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=7.6.1.4|title=Explicit type conversion (functional notation)|id=expr.type.conv}}
{{ref std|section=7.6.3|title=Explicit type conversion (cast notation)|id=expr.cast}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=8.2.3|title=Explicit type conversion (functional notation)|id=expr.type.conv}}
{{ref std|section=8.4|title=Explicit type conversion (cast notation)|id=expr.cast}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=5.2.3|title=Explicit type conversion (functional notation)|id=expr.type.conv}}
{{ref std|section=5.4|title=Explicit type conversion (cast notation)|id=expr.cast}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=5.2.3|title=Explicit type conversion (functional notation)|id=expr.type.conv}}
{{ref std|section=5.4|title=Explicit type conversion (cast notation)|id=expr.cast}}
{{ref std end}}
{{ref std c++03}}
{{ref std|section=5.2.3|title=Explicit type conversion (functional notation)|id=expr.type.conv}}
{{ref std|section=5.4|title=Explicit type conversion (cast notation)|id=expr.cast}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=5.2.3|title=Explicit type conversion (functional notation)|id=expr.type.conv}}
{{ref std|section=5.4|title=Explicit type conversion (cast notation)|id=expr.cast}}
{{ref std end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/language/dsc const_cast}}
{{dsc inc|cpp/language/dsc static_cast}}
{{dsc inc|cpp/language/dsc dynamic_cast}}
{{dsc inc|cpp/language/dsc reinterpret_cast}}
{{dsc inc|cpp/language/dsc implicit_cast}}
{{dsc see c|c/language/cast|转换运算符|nomono=true}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}