{{title|代用运算符表示}}
{{cpp/language/expressions/navbar}}

C++（及 C）源代码可以用任何包含 {{enwiki|ISO 646|ISO 646:1983}} 不变字符集的非 ASCII 7 位字符集书写。然而，一些 C++ 运算符及标点要求 ISO 646 编码集外的字符：{{tt|{，}，[，]，#，\，^，{{!}}，~}}。为了能够使用不存在一些或全部这些符号的字符编码（例如德语 {{enwiki|DIN 66003}}），C++ 定义下列由 ISO 646 兼容字符组成的代用写法。

===代用记号===
几个使用非 ISO-646 字符的运算符和其他记号都有代用拼写。在语言的所有方面，各个代用拼写都严格与其首选记号的表现相同，除了其拼写（[[cpp/preprocessor/replace|字符串化运算符]]能使拼写可见）。双字母代用记号有时被称为“双标符 (digraphs)”。尽管有四个字母，{{c|%:%:}} 也被当作双标符。

{| class="wikitable"
|-
! 首选
! 代用
|-
|{{tt|&amp;&amp;}}
|{{ltt|cpp/keyword/and}}
|-
|{{tt|1=&amp;=}}
|{{ltt|cpp/keyword/and_eq}}
|-
|{{tt|&amp;}}
|{{ltt|cpp/keyword/bitand}}
|-
|{{tt|&amp;#124;}}
|{{ltt|cpp/keyword/bitor}}
|-
|{{tt|~}}
|{{ltt|cpp/keyword/compl}}
|-
|{{tt|!}}
|{{ltt|cpp/keyword/not}}
|-
|{{tt|1=!=}}
|{{ltt|cpp/keyword/not_eq}}
|-
|{{tt|&amp;#124;&amp;#124;}}
|{{ltt|cpp/keyword/or}}
|-
|{{tt|1=&amp;#124;=}}
|{{ltt|cpp/keyword/or_eq}}
|-
|{{tt|^}}
|{{ltt|cpp/keyword/xor}}
|-
|{{tt|1=^=}}
|{{ltt|cpp/keyword/xor_eq}}
|-
|{{tt|{}}||{{tt|&lt;%}}
|-
|{{tt|}&lt;!----&gt;}}||{{tt|%&gt;}}
|-
|{{tt|[}}||{{tt|&lt;:}}
|-
|{{tt|]}}||{{tt|:&gt;}}
|-
|{{tt|#}}||{{tt|%:}}
|-
|{{tt|##}}||{{tt|%:%:}}
|}

{{anchor|三标符}}
===三标符 {{mark until c++17|removed=yes}}===
下列三字符组（三标符，trigraph）在{{rlp|translation phases|辨识注释和字符串字面量之前被分析}}，而三标符的每次出现都会被替换成对应的首选字符：

{| class="wikitable"
|- style="text-align: left;"
! 首选
! 三标符
|-
| {{tt|{}} || {{tt|??&lt;}}
|-
| {{tt|}}} || {{tt|??&gt;}}
|-
| {{tt|[}} || {{tt|??(}}
|-
| {{tt|]}} || {{tt|??)}}
|-
| {{tt|#}} || {{tt|1=??=}}
|-
| {{tt|\}} || {{tt|??/}}
|-
| {{tt|^}} || {{tt|??'}}
|-
| {{tt|&lt;nowiki&gt;|&lt;/nowiki&gt;}} || {{tt|??!}}
|-
| {{tt|~}} || {{tt|??-}}
|}

因为三标符的处理非常早，所以像 {{c|// Will the next line be executed?????/}} 这样的注释实际上会注释掉下一行（编译时加上 {{c|-Wcomment}} 命令会对此警告），而如 {{c|"Enter date ??/??/??"}} 这样的字符串字面量将被分析为 {{c|"Enter date \\??"}}。

====注解====
字符 {{c|&amp;}} 及 {{c|!}} 在 ISO-646 下不变，但仍然为使用这些字符的记号提供了代用写法，以便能够适应更加受限的历史字符集&lt;!-- 目前找到的最好的引用“ The Danish delegation did not, in fact, have a way of representing those characters on their terminals ”，来自 https://groups.google.com/d/msg/comp.std.c/eYbj0lCIvn4/89oK8U6JpqEJ ，但它没有特别指出 &amp; 和 ! --&gt;。

没有相等运算符 {{c|1===}} 的代用拼写（如 {{c|eq}}），因为字符 {{c|1==}} 已在所有受支持字符集中存在。

===与 C 的兼容性===
C 编程语言中，同样的单词作为宏在包含文件 {{header|iso646.h|lang=c}} 中定义。因为 C++ 中它们在语言中内建，所以 {{ltt|cpp/header/ciso646|&lt;iso646.h&gt;}} 的 C++ 版本还有 {{header|ciso646}} 不定义任何内容。不过，非单词的双标符（如 {{c|&lt;%}}）是核心语言的一部分，无需包含任何头文件即可使用（否则的话，它们就无法在缺少 {{c|#}} 的任何字符集下使用了）。

===关键词===
{{ltt|cpp/keyword/and}},
{{ltt|cpp/keyword/and_eq}},
{{ltt|cpp/keyword/bitand}},
{{ltt|cpp/keyword/bitor}},
{{ltt|cpp/keyword/compl}},
{{ltt|cpp/keyword/not}},
{{ltt|cpp/keyword/not_eq}},
{{ltt|cpp/keyword/or}},
{{ltt|cpp/keyword/or_eq}},
{{ltt|cpp/keyword/xor}},
{{ltt|cpp/keyword/xor_eq}}

===示例===
{{example
|以下示例演示各种代用记号的使用。
|code=
%:include &lt;iostream&gt;

struct X
&lt;%
    compl X() &lt;%%&gt; // 析构函数
    X() &lt;%%&gt;
    X(const X bitand) = delete; // 复制构造函数
    // X(X and) = delete; // 移动构造函数
    
    bool operator not_eq(const X bitand other)
    &lt;%
        return this not_eq bitand other;
    %&gt;
%&gt;;

int main(int argc, char* argv&lt;::&gt;) 
&lt;%
    // 带引用捕获的 lambda
    auto greet = &lt;:bitand:&gt;(const char* name)
    &lt;%
        std::cout &lt;&lt; "Hello " &lt;&lt; name
                  &lt;&lt; " from " &lt;&lt; argv&lt;:0:&gt; &lt;&lt; '\n';
    %&gt;;
    
    if (argc &gt; 1 and argv&lt;:1:&gt; not_eq nullptr) 
        greet(argv&lt;:1:&gt;);
    else
        greet("Anon");
%&gt;
|p=true
|output=Hello Anon from ./a.out
}}

===引用===
{{ref std c++23}}
{{ref std|section=5.5|title=Alternative tokens|id=lex.digraph}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=5.5|title=Alternative tokens|id=lex.digraph}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=5.5|title=Alternative tokens|id=lex.digraph}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=2.4|title=Trigraph sequences|id=lex.trigraph}}
{{ref std|section=2.6|title=Alternative tokens|id=lex.digraph}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=2.4|title=Trigraph sequences|id=lex.trigraph}}
{{ref std|section=2.6|title=Alternative tokens|id=lex.digraph}}
{{ref std end}}
{{ref std c++03}}
{{ref std|section=2.3|title=Trigraph sequences|id=lex.trigraph}}
{{ref std|section=2.5|title=Alternative tokens|id=lex.digraph}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=2.3|title=Trigraph sequences|id=lex.trigraph}}
{{ref std|section=2.5|title=Alternative tokens|id=lex.digraph}}
{{ref std end}}

===参阅===
{{dsc begin}}
{{dsc see c|c/language/operator alternative|代用运算符及记号|nomono=true}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}