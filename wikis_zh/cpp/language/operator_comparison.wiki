{{title|比较运算符}}
{{cpp/language/expressions/navbar}}
比较参数。

{| class="wikitable" style="font-size: 85%;"
|-
! rowspan="2"|运算符名
! rowspan="2" style="word-break: keep-all;"|{{nbsp|3}}语法{{nbsp|3}}
! rowspan="2"|{{rlp|operators|可重载}}
! colspan="2"|原型示例（对于 {{c/core|class T}}）
|-
!类内定义
!类外定义
|-
|等于
| {{tt|1=a == b}}
| {{yes}}
| {{c|1=bool T::operator==(const U&amp; b) const;}}
| {{c|1=bool operator==(const T&amp; a, const U&amp; b);}}
|-
|不等于
| {{tt|1=a != b}}
| {{yes}}
| {{c|1=bool T::operator!=(const U&amp; b) const;}}
| {{c|1=bool operator!=(const T&amp; a, const U&amp; b);}}
|-
|小于
| {{tt|1=a &lt; b}}
| {{yes}}
| {{c|1=bool T::operator&lt;(const U&amp; b) const;}}
| {{c|1=bool operator&lt;(const T&amp; a, const U&amp; b);}}
|-
|大于
| {{tt|1=a &gt; b}}
| {{yes}}
| {{c|1=bool T::operator&gt;(const U&amp; b) const;}}
| {{c|1=bool operator&gt;(const T&amp; a, const U&amp; b);}}
|-
|小于或等于
| {{tt|1=a &lt;= b}}
| {{yes}}
| {{c|1=bool T::operator&lt;=(const U&amp; b) const;}}
| {{c|1=bool operator&lt;=(const T&amp; a, const U&amp; b);}}
|-
|大于或等于
| {{tt|1=a &gt;= b}}
| {{yes}}
| {{c|1=bool T::operator&gt;=(const U&amp; b) const;}}
| {{c|1=bool operator&gt;=(const T&amp; a, const U&amp; b);}}
|-
|三路比较{{mark c++20}}
| {{tt|1=a &lt;=&gt; b}}
| {{yes}}
|{{box|{{tti|R{{nbsp}}}}{{c/core|1=T::operator&lt;=&gt;(const U&amp; b) const;}}}}&lt;ref name="R"&gt;{{tti|R}} 是 {{c/core|1=operator&lt;=&gt;}} 的返回类型（见[[#三路比较|下文]]）&lt;/ref&gt;
|{{box|{{tti|R{{nbsp}}}}{{c/core|1=operator&lt;=&gt;(const T&amp; a, const U&amp; b);}}}}&lt;ref name="R"/&gt;
|-
| colspan="5" |
:'''注解'''&lt;br&gt;
* 内建运算符返回 {{c/core|bool}}，所以大多数{{rlp|operators|用户定义重载}}也返回 {{c/core|bool}} 以使用户定义运算符能以与内建运算符相同的方式使用。然而，在用户定义运算符重载中，任何类型都可用作返回类型（包括 {{c/core|void}}）。
* {{tt|U}} 可以是包括 {{tt|T}} 在内的任何类型
&lt;references/&gt;
|}

===双路比较===
双路比较运算符表达式的形式为

=====关系运算符=====
{{sdsc begin}}
{{sdsc|num=1|{{spar|左操作数}} {{ttb|&lt;}} {{spar|右操作数}}}}
{{sdsc|num=2|{{spar|左操作数}} {{ttb|&gt;}} {{spar|右操作数}}}}
{{sdsc|num=3|{{spar|左操作数}} {{ttb|1=&lt;=}} {{spar|右操作数}}}}
{{sdsc|num=4|{{spar|左操作数}} {{ttb|1=&gt;=}} {{spar|右操作数}}}}
{{sdsc end}}
=====相等性运算符=====
{{sdsc begin}}
{{sdsc|num=5|{{spar|左操作数}} {{ttb|1===}} {{spar|右操作数}}}}
{{sdsc|num=6|{{spar|左操作数}} {{ttb|1=!=}} {{spar|右操作数}}}}
{{sdsc end}}
@1@ 在{{spar sep|左操作数}}小于{{spar sep|右操作数}}时返回 {{c|true}}，否则返回 {{c|false}}。
@2@ 在{{spar sep|左操作数}}大于{{spar sep|右操作数}}时返回 {{c|true}}，否则返回 {{c|false}}。
@3@ 在{{spar sep|左操作数}}小于或等于{{spar sep|右操作数}}时返回 {{c|true}}，否则返回 {{c|false}}。
@4@ 在{{spar sep|左操作数}}大于或等于{{spar sep|右操作数}}时返回 {{c|true}}，否则返回 {{c|false}}。
@5@ 在{{spar sep|左操作数}}等于{{spar sep|右操作数}}时返回 {{c|true}}，否则返回 {{c|false}}。
@6@ 在{{spar sep|左操作数}}不等于{{spar sep|右操作数}}时返回 {{c|true}}，否则返回 {{c|false}}。

====内建双路比较运算符====
内建双路比较运算符都会对{{spar sep|左操作数}}和{{spar sep|右操作数}}应用{{rlps|implicit conversion#左值到右值转换}}{{rev inl|until=c++26|、{{rlps|implicit conversion#数组到指针转换}}}}和{{rlps|implicit conversion#函数到指针转换}}。

{{rev begin}}
{{rev|since=c++20|until=c++26|
如果{{spar sep|左操作数}}和{{spar sep|右操作数}}在转换前都具有数组类型，那么这种比较被弃用。
}}
{{rev|since=c++26|
对于内建关系运算符，如果其中一个操作数是指针，那么就会对另一操作数应用{{rlps|implicit conversion#数组到指针转换}}。

对于内建相等性运算符，如果其中一个操作数是指针或{{rlp|pointer#空指针|空指针常量 }}，那么就会对另一操作数应用{{rlps|implicit conversion#数组到指针转换}}。
}}
{{rev end}}

内建双路比较运算符的结果都是 {{c/core|bool}} 纯右值。

====内建算术比较====
如果两个操作数具有算术或（有作用域或无作用域）枚举类型，那么对两个操作数实施{{rlp|usual arithmetic conversions|一般算术转换}}。转换之后进行值的比较：

{{example
|code=
#include &lt;iostream&gt;

int main()
{
    static_assert(sizeof(unsigned char) &lt; sizeof(int),
                  "不能正确地比较有符号值与较小的无符号值");
    int a = -1;
    int b = 1;
    unsigned int c = 1;
    unsigned char d = 1;
    
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; "比较两个有符号值：\n"
                 " -1 == 1 ? " &lt;&lt; (a == b) &lt;&lt; "\n"
                 " -1 &lt;  1 ? " &lt;&lt; (a &lt;  b) &lt;&lt; "\n"
                 " -1 &gt;  1 ? " &lt;&lt; (a &gt;  b) &lt;&lt; "\n"
                 "比较有符号与无符号值：\n"
                 // 可能会产生“符号不同”警告信息
                 " -1 == 1 ? " &lt;&lt; (a == c) &lt;&lt; "\n"
                 // 可能会产生“符号不同”警告信息
                 " -1 &lt;  1 ? " &lt;&lt; (a &lt;  c) &lt;&lt; "\n"
                 // 可能会产生“符号不同”警告信息
                 " -1 &gt;  1 ? " &lt;&lt; (a &gt;  c) &lt;&lt; "\n"
                 "比较有符号与较小的无符号值：\n"
                 " -1 == 1 ? " &lt;&lt; (a == d) &lt;&lt; "\n"
                 " -1 &lt;  1 ? " &lt;&lt; (a &lt;  d) &lt;&lt; "\n"
                 " -1 &gt;  1 ? " &lt;&lt; (a &gt;  d) &lt;&lt; '\n';
}
|output=
比较两个有符号值：
 -1 == 1 ? false
 -1 &lt;  1 ? true
 -1 &gt;  1 ? false
比较有符号与无符号值：
 -1 == 1 ? false
 -1 &lt;  1 ? false
 -1 &gt;  1 ? true
比较无符号值和较小的有符号值：
 -1 == 1 ? false
 -1 &lt;  1 ? true
 -1 &gt;  1 ? false
}}

====内建指针相等性比较====
相等性运算符 {{tt|1===}} 和 {{tt|1=!=}} 的转换后的操作数也可以具有{{rev inl|since=c++11| {{lc|std::nullptr_t}} 类型、}}指针类型或成员指针类型。

内建指针相等性比较有三个结果：相等、不相等和未指定。相等性运算符对于内建指针相等性比较产生的结果见下表：

{|class="wikitable" style="text-align: center;"
|-
!rowspan=2|{{nbsp}}{{c|p}} 和 {{c|q}} 的比较结果{{nbsp}}
!colspan=2|表达式产生的值
|-
!{{c|1=p == q}}
!{{c|1=p != q}}
|-
|相等
|{{c|true}}
|{{c|false}}
|-
|不相等
|{{c|false}}
|{{c|true}}
|-
|未指定
|colspan=2|{{nbsp}}未指定的 {{c/core|bool}} 值{{nbsp}}
|}

如果转换后的{{spar sep|左操作数}}和{{spar sep|右操作数}}中至少有一个是（非成员）指针，那么对转换后的两个操作数应用{{rlps|implicit conversion#指针转换}}{{rev inl|since=c++17|、{{rlps|implicit conversion#函数指针转换}}}}和{{rlps|implicit conversion#限定性转换}}，以获得它们的{{rlps|pointer#合成指针类型}}。具有合成指针类型的两个指针按以下方式进行比较：
* 如果一个指针表示表示某个完整对象的{{rlp|pointer#指针|地址}}，而另一个指针
:* 表示另一个完整非数组对象的尾后地址，或者
:* 表示另一个完整数组对象的尾后元素的地址，
: 那么比较结果未指定。
* 否则，如果两个指针都为空，都指向同一函数，或者都表示相同的地址（即它们指向同一对象或者都是同一对象的尾后指针），那么它们比较相等。
* 否则它们比较不相等。

如果转换后的{{spar sep|左操作数}}和{{spar sep|右操作数}}中至少有一个是成员指针，那么对转换后的两个操作数应用{{rlps|implicit conversion#成员指针转换}}{{rev inl|since=c++17|、{{rlps|implicit conversion#函数指针转换}}}}和{{rlps|implicit conversion#限定性转换}}，以获得它们的{{rlps|pointer#合成指针类型}}。具有合成指针类型的两个成员指针按以下方式进行比较：
* 如果两个成员指针都是空成员指针值，那么它们比较相等。
* 如果只有一个成员指针是空成员指针值，那么它们比较不相等。
* 如果有一个成员指针指向{{rlp|virtual|虚成员函数}}，那么比较结果未指定。
* 如果一个成员指针表示类 {{tt|C1}} 的某个成员，而另一个成员指针表示另一个类 {{tt|C2}} 的某个成员，并且两个类都不是对方的基类，那么比较结果未指定。
* 如果两个指针表示相同{{rlp|union|联合体}}的（不一定相同）的成员，那么它们比较相等。
* 否则，如果两个成员指针表示同一个{{rlp|object#子对象|最终派生对象}}的相同成员，或者在对关联类类型的某个虚设对象进行间接寻址的情况下它们表示同一个子对象的相同成员，那么它们比较相等，否则它们比较不相等。

{{source|1=
struct P {};
struct Q : P { int x; };
struct R : P { int x; };

int P::*bx = (int(P::*)) &amp;Q::x;
int P::*cx = (int(P::*)) &amp;R::x;

bool b1 = (bx == cx); // 未指定

struct B
{
    int f();
};
struct L : B {};
struct R : B {};
struct D : L, R {};

int (B::*pb)() = &amp;B::f;
int (L::*pl)() = pb;
int (R::*pr)() = pb;
int (D::*pdl)() = pl;
int (D::*pdr)() = pr;

bool x = (pdl == pdr); // false
bool y = (pb == pl);   // true
}}

{{rrev|since=c++11|
两个 {{lc|std::nullptr_t}} 类型的操作数比较相等。一个 {{lc|std::nullptr_t}} 类型的操作数和另一个空指针常量操作数比较相等。
}}

====内建指针关系比较====
关系运算符 {{tt|&gt;}}、{{tt|&lt;}}、{{tt|1=&gt;=}} 和 {{tt|1=&lt;=}} 的转换后的操作数也可以具有（非成员）指针类型。

对不相等的两个指针 {{c|p}} 和 {{c|q}} 的内建指针关系比较有三个结果：{{c|p}} 大于 {{c|q}}、{{c|q}} 大于 {{c|p}}和未指定。关系运算符对于内建指针关系比较产生的结果见下表：

{|class="wikitable" style="text-align: center;"
|-
!rowspan=2|{{nbsp}}{{c|p}} 和 {{c|q}} 的比较结果{{nbsp}}
!colspan=4|表达式产生的值
|-
!{{nbsp}}{{c|p &gt; q}}{{nbsp}}
!{{nbsp}}{{c|p &lt; q}}{{nbsp}}
!{{nbsp}}{{c|1=p &gt;= q}}{{nbsp}}
!{{nbsp}}{{c|1=p &lt;= q}}{{nbsp}}
|-
|相等
|{{c|false}}
|{{c|false}}
|{{c|true}}
|{{c|true}}
|-
|{{c|p}} 大于 {{c|q}}
|{{c|true}}
|{{c|false}}
|{{c|true}}
|{{c|false}}
|-
|{{c|q}} 大于 {{c|p}}
|{{c|false}}
|{{c|true}}
|{{c|false}}
|{{c|true}}
|-
|未指定
|colspan=4|未指定的 {{c/core|bool}} 值
|}

如果转换后的{{spar sep|左操作数}}和{{spar sep|右操作数}}都是（非成员）指针，那么对转换后的两个操作数应用{{rlps|implicit conversion#指针转换}}{{rev inl|since=c++17|、{{rlps|implicit conversion#函数指针转换}}}}和{{rlps|implicit conversion#限定性转换}}，以获得它们的{{rlps|pointer#合成指针类型}}。具有合成指针类型的两个指针按以下方式进行比较：
* 如果两个指针比较相等，或者相等性比较结果未指定，那么关系比较结果与相等性比较结果相同。
* 否则（两个指针比较不相等），如果至少有一个指针不是指向对象的指针，那么比较结果未指定。
* 否则（两个指针都指向对象），那么结果按以下规则规定的偏序进行定义：
:* 给定某个数组的两个不同的成员 {{c|high}} 和 {{c|low}}，其中 {{c|high}} 的下标高于 {{c|low}}，如果一个指针指向 {{c|high}}（或 {{c|high}} 的某个子对象）而另一个指针指向 {{c|low}}（或 {{c|low}} 的子对象），那么前者比较大于后者。
:* 如果一个指针指向某个数组的元素 {{c|elem}}（或 {{c|elem}} 的某个子对象）而另一个指针是相同数组的尾后指针，那么尾后指针比较大于另一指针。
:* 如果一个指针指向一个完整对象，基类子对象或成员子对象 {{c|obj}}（或 {{c|obj}} 的某个子对象），而另一个指针是 {{c|obj}} 的尾后指针，那么尾后指针比较大于另一指针。
{{anchor|成员布局}}
:* 如果在非联合体类类型的对象内，两个指针指向{{rev inl|until=c++23|拥有相同{{rlp|access|成员访问}}的}}{{rev inl|since=c++20|{{rlp|attributes/no_unique_address|非零大小}}的}}不同的非静态数据成员，或（递归地）指向这种成员的子对象或数组元素，那么指向较后声明的成员的指针比较大于另一指针。
:* 否则比较结果未指定。

====指针全序====
每个程序中都有一个''由实现定义的指针严格全序''。该全序与上述偏序保持一致：原来未指定的结果改由实现定义，其他结果保持不变。

在以下情况以严格全序进行指针比较：
* 调用 {{lc|std::less}}、{{lc|std::greater}}、{{lc|std::less_equal}} 和 {{lc|std::greater_equal}} 的指针类型特化的 {{c/core|operator()}}。
{{rev begin}}
{{rev|since=c++14|
* 在特化 {{ltt|cpp/utility/functional/less_void|std::less&lt;void&gt;}}、{{ltt|cpp/utility/functional/greater_void|std::greater&lt;void&gt;}}、{{ltt|cpp/utility/functional/less_equal_void|std::less_equal&lt;void&gt;}} 和 {{ltt|cpp/utility/functional/greater_equal_void|std::greater_equal&lt;void&gt;}} 的 {{c/core|operator()}} 中调用内建的运算符比较指针。
}}
{{rev|since=c++20|
* 在 {{lc|std::compare_three_way}} 的 {{c/core|operator()}} 中调用内建的 {{c/core|1=operator&lt;=&gt;}} 比较指针。
* 在 {{ltt|cpp/utility/functional/ranges/equal_to|std::ranges::equal_to}} 和 {{ltt|cpp/utility/functional/ranges/not_equal_to|std::ranges::not_equal_to}} 的 {{c/core|operator()}} 中调用内建的 {{c/core|1=operator==}} 比较指针。
* 在 {{ltt|cpp/utility/functional/ranges/less|std::ranges::less}}、{{ltt|cpp/utility/functional/ranges/greater|std::ranges::greater}}、{{ltt|cpp/utility/functional/ranges/less_equal|std::ranges::less_equal}} 和 {{ltt|cpp/utility/functional/ranges/greater_equal|std::ranges::greater_equal}} 的 {{c/core|operator()}} 中调用内建的 {{c/core|operator&lt;}} 比较指针。
}}
{{rev end}}

{{anchor|双路比较运算符重载}}
====重载====
在{{rlp|overload resolution#调用重载运算符|针对用户定义运算符的重载决议}}中，对于（包括枚举类型的）每个提升后算术类型 {{tt|L}} 和 {{tt|R}}，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|bool operator&lt;(L, R);}}
{{dcl|bool operator&gt;(L, R);}}
{{dcl|1=bool operator&lt;=(L, R);}}
{{dcl|1=bool operator&gt;=(L, R);}}
{{dcl|1=bool operator==(L, R);}}
{{dcl|1=bool operator!=(L, R);}}
{{dcl end}}

对于每个对象指针或函数指针的类型 {{tt|P}}，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|bool operator&lt;(P, P);}}
{{dcl|bool operator&gt;(P, P);}}
{{dcl|1=bool operator&lt;=(P, P);}}
{{dcl|1=bool operator&gt;=(P, P);}}
{{dcl|1=bool operator==(P, P);}}
{{dcl|1=bool operator!=(P, P);}}
{{dcl end}}

对于每个是成员对象指针或成员函数指针{{rev inl|since=c++11|或 {{lc|std::nullptr_t}} }}的类型 {{tt|MP}}，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|1= bool operator==(MP, MP);}}
{{dcl|1= bool operator!=(MP, MP);}}
{{dcl end}}

{{example
|code=
#include &lt;iostream&gt;

struct Foo
{
    int n1;
    int n2;
};

union Union
{
    int n;
    double d;
};

int main()
{
    std::cout &lt;&lt; std::boolalpha;
    
    char a[4] = "abc";
    char* p1 = &amp;a[1];
    char* p2 = &amp;a[2];
    std::cout &lt;&lt; "指向数组元素的指针：\n"
              &lt;&lt; "p1 == p2? " &lt;&lt; (p1 == p2) &lt;&lt; '\n'
              &lt;&lt; "p1 &lt;  p2? " &lt;&lt; (p1 &lt;  p2) &lt;&lt; '\n';
    
    Foo f;
    int* p3 = &amp;f.n1;
    int* p4 = &amp;f.n2;
    std::cout &lt;&lt; "指向类成员的指针：\n"
              &lt;&lt; "p3 == p4? " &lt;&lt; (p3 == p4) &lt;&lt; '\n'
              &lt;&lt; "p3 &lt;  p4? " &lt;&lt; (p3 &lt;  p4) &lt;&lt; '\n';
    
    Union u;
    int* p5 = &amp;u.n;
    double* p6 = &amp;u.d;
    std::cout &lt;&lt; "指向联合体成员的指针：\n"
              &lt;&lt; "p5 == (void*)p6? " &lt;&lt; (p5 == (void*)p6) &lt;&lt; '\n'
              &lt;&lt; "p5 &lt;  (void*)p6? " &lt;&lt; (p5 &lt;  (void*)p6) &lt;&lt; '\n';
}
|output=
指向数组元素的指针：
p1 == p2? false
p1 &lt;  p2? true
指向类成员的指针：
p3 == p4? false
p3 &lt;  p4? true
指向联合体成员的指针：
p5 == (void*)p6? true
p5 &lt;  (void*)p6? false
}}

{{rrev|since=c++20|
===三路比较===
三路比较运算符表达式的形式为

{{sdsc begin}}
{{sdsc|{{spar|左操作数}} {{ttb|1=&lt;=&gt;}} {{spar|右操作数}}}}
{{sdsc end}}

表达式返回一个对象，使得
* 如果 {{c|a &lt; b}}，那么 {{c|1=(a &lt;=&gt; b) &lt; 0}}
* 如果 {{c|a &gt; b}}，那么 {{c|1=(a &lt;=&gt; b) &gt; 0}}
* 而如果 {{c|a}} 和 {{c|b}} 相等/等价，那么 {{c|1=(a &lt;=&gt; b) == 0}}。

如果操作数之一是 {{c/core|bool}} 类型而另一个不是，那么程序非良构。

如果两个操作数均具有算术类型，或一个具有无作用域枚举类型而另一个具有整数类型，那么对各操作数应用一般算术转换，然后

* 如果需要进行除了从整数类型到浮点数类型之外的窄化转换，那么程序非良构。
* 否则，如果各操作数均具有整数类型，那么运算符产出 {{ltt std|cpp/utility/compare/strong_ordering}} 类型的纯右值：
:* 如果两个操作数算术上相等则为 {{lc|std::strong_ordering::equal}}，
:* 如果第一操作数算术上小于第二个则为 {{lc|std::strong_ordering::less}}
:* 否则为 {{lc|std::strong_ordering::greater}}。
* 否则，操作数均具有浮点数类型，而运算符产出 {{ltt std|cpp/utility/compare/partial_ordering}} 类型的纯右值。表达式 {{c|1=a &lt;=&gt; b}} 产出
:* 如果 {{c|a}} 小于 {{c|b}} 则为 {{lc|std::partial_ordering::less}}，
:* 如果 {{c|a}} 大于 {{c|b}} 则为 {{lc|std::partial_ordering::greater}}，
:* 如果 {{c|a}} 等价于 {{c|b}} 则为 {{lc|std::partial_ordering::equivalent}}（{{c|1=-0 &lt;=&gt; +0}} 为等价），
:* 否则为 {{lc|std::partial_ordering::unordered}}（{{c|1=NaN &lt;=&gt; 任何值}} 为无序）。

如果两个操作数都具有相同的枚举类型 {{tt|E}}，那么运算符产出将各操作数转换到 E 的底层类型再对转换后的操作数应用 {{c|1=&lt;=&gt;}} 的结果。

如果至少一个操作数是指针或成员指针，那么按需应用{{rlp|implicit conversion#数组到指针转换|数组到指针转换}}、{{rlps|implicit conversion#指针转换}}和{{rlps|implicit conversion#限定性转换}}，以将它们转换到它们的{{rlps|pointer#合成指针类型}}。

对于转换后的操作数 {{c|p}} 和 {{c|q}}，{{c|1=p &lt;=&gt; q}} 返回 {{ltt|cpp/utility/compare/strong_ordering|std::strong_ordering}} 类型的纯右值：
* 如果它们[[#内建指针相等性比较|比较相等]]则为 {{lc|std::strong_ordering::equal}}
* 如果 {{c|q}} [[#内建指针关系比较|比较大于]] {{c|p}} 则为 {{lc|std::strong_ordering::less}}
* 如果 {{c|p}} 比较大于 {{c|q}} 则为 {{lc|std::strong_ordering::greater}}。
* 如果未指明这些指针值的比较，那么结果未指明。

否则程序非良构。

{{anchor|重载三路比较运算符}}
====重载====
在{{rlp|overload resolution#调用重载运算符|针对用户定义运算符的重载决议}}中，对于指针或枚举类型 {{tt|T}}，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|1= R operator&lt;=&gt;(T, T);}}
{{dcl end}}
其中 {{tt|R}} 是上文所定义的顺序类别类型。

{{example
|code=
#include &lt;compare&gt;
#include &lt;iostream&gt;
 
int main()
{
    double foo = -0.0;
    double bar = 0.0;
    
    auto res = foo &lt;=&gt; bar;
    
    if (res &lt; 0)
        std::cout &lt;&lt; "-0 小于 0";
    else if (res &gt; 0)
        std::cout &lt;&lt; "-0 大于 0";
    else if (res == 0)
        std::cout &lt;&lt; "-0 与 0 相等";
    else
        std::cout &lt;&lt; "-0 与 0 无序";
}
|output=
-0 与 0 相等
}}
}}

===注解===
因为这些运算符从左到右组合，所以表达式 {{c|a &lt; b &lt; c}} 会被解析为 {{c|(a &lt; b) &lt; c}}，而不是 {{c|a &lt; (b &lt; c)}} 或 {{c|(a &lt; b) &amp;&amp; (b &lt; c)}}。
{{example
|code=
#include &lt;iostream&gt;

int main()
{
    int a = 3, b = 2, c = 1;
    
    std::cout &lt;&lt; std::boolalpha
        &lt;&lt; (a &lt; b &lt; c) &lt;&lt; '\n' // true；可能会有警告
        &lt;&lt; ((a &lt; b) &lt; c) &lt;&lt; '\n' // true
        &lt;&lt; (a &lt; (b &lt; c)) &lt;&lt; '\n' // false
        &lt;&lt; ((a &lt; b) &amp;&amp; (b &lt; c)) &lt;&lt; '\n'; // false
}
|output=
true
true
false
false
}}

对{{rlp|operators#比较运算符|用户定义的 {{tt|operator&lt;}}}} 的一项常见要求是{{enwiki|Strict weak ordering|严格弱序}}。尤其是用{{named req|Compare}}类型进行工作的标准算法和容器，如 {{lc|std::sort}}、{{lc|std::max_element}}、{{lc|std::map}} 等，都对此有所要求。

指向相同类的不同成员的指针的[[#成员布局|比较结果]]说明了{{rev inl|until=c++23|三个成员访问模式的每一者中的}}类成员按声明顺序置于内存中。

尽管未指明对随机来源（例如不都指向同一数组中的成员）的指针比较的结果，许多实现都提供指针的{{enwiki|Total order#Strict total order|严格全序}}，例如它们被实现为连续的虚拟地址空间中的地址。不这样做的实现（例如并非指针的所有位都是内存地址的一部分而在比较中必须被忽略，或要求进行额外的计算否则指针与整数并非一对一关系），为指针提供具有这项保证的 {{lc|std::less}} 的特化。这使得程序可以将随机来源的所有指针都用作标准关联容器（如 {{lc|std::set}} 或 {{lc|std::map}}）的键。

对于同时满足{{named req|EqualityComparable}}和{{named req|LessThanComparable}}的类型，C++ 标准库在''相等''（即表达式 {{c|1=a == b}} 的值），和''等价''（即表达式 {{c|!(a &lt; b) &amp;&amp; !(b &lt; a)}} 的值）之间做出区别。

{{stddoc|N3624}} 中包含的 {{cwg|583}} 的解决方案移除了指针与空指针常量间的比较。
{{example|code=
void f(char * p)
{
    if (p &gt; 0) { /*...*/ } // 用 N3624 出错，N3624 前可编译
    if (p &gt; nullptr) { /*...*/ } // 用 N3624 出错，N3624 前可编译
}

int main() {}
}}

类类型可以自动生成三路比较，见{{rlp|default comparisons|默认比较}}。

如果两个运算数都是数组，那么三路比较非良构。

{{source|1=
unsigned int i = 1;
auto r = -1 &lt; i;    // 既存陷阱：返回 false
auto r2 = -1 &lt;=&gt; i; // 错误：要求窄化转换
}}

{{ftm begin|std=1|comment=1}}
{{ftm|std=C++20|value=201907L|__cpp_impl_three_way_comparison|三路比较（编译器支持）}}
{{ftm|std=C++20|value=201907L|__cpp_lib_three_way_comparison|三路比较（库支持）；向库添加三路比较}}
{{ftm end}}

===标准库===
标准库中的许多类都重载了比较运算符。

{{dsc begin}}
{{dsc inc|cpp/types/type_info/dsc operator cmp}}
{{dsc inc|cpp/error/error_code/dsc operator cmp}}
{{dsc inc|cpp/error/error_condition/dsc operator cmp}}
{{dsc inc|cpp/utility/pair/dsc operator cmp}}
{{dsc inc|cpp/utility/tuple/dsc operator cmp}}
{{dsc inc|cpp/utility/bitset/dsc operator cmp}}
{{dsc inc|cpp/memory/allocator/dsc operator cmp}}
{{dsc inc|cpp/memory/unique_ptr/dsc operator cmp}}
{{dsc inc|cpp/memory/shared_ptr/dsc operator cmp}}
{{dsc inc|cpp/utility/functional/function/dsc operator cmp}}
{{dsc inc|cpp/chrono/duration/dsc operator cmp}}
{{dsc inc|cpp/chrono/time_point/dsc operator cmp}}
{{dsc inc|cpp/memory/scoped_allocator_adaptor/dsc operator cmp}}
{{dsc inc|cpp/types/type_index/dsc operator cmp}}
{{dsc inc|cpp/string/basic_string/dsc operator cmp}}
{{dsc inc|cpp/locale/locale/dsc operator cmp}}
{{dsc inc|cpp/container/dsc operator cmp|array}}
{{dsc inc|cpp/container/dsc operator cmp|deque}}
{{dsc inc|cpp/container/dsc operator cmp|forward_list}}
{{dsc inc|cpp/container/dsc operator cmp|list}}
{{dsc inc|cpp/container/dsc operator cmp|vector}}
{{dsc inc|cpp/container/dsc operator cmp|map}}
{{dsc inc|cpp/container/dsc operator cmp|multimap}}
{{dsc inc|cpp/container/dsc operator cmp|set}}
{{dsc inc|cpp/container/dsc operator cmp|multiset}}
{{dsc inc|cpp/container/dsc operator cmp_unord|unordered_map}}
{{dsc inc|cpp/container/dsc operator cmp_unord|unordered_multimap}}
{{dsc inc|cpp/container/dsc operator cmp_unord|unordered_set}}
{{dsc inc|cpp/container/dsc operator cmp_unord|unordered_multiset}}
{{dsc inc|cpp/container/dsc operator cmp|queue}}
{{dsc inc|cpp/container/dsc operator cmp|stack}}
{{dsc inc|cpp/iterator/adaptor/dsc operator cmp|reverse_iterator}}
{{dsc inc|cpp/iterator/adaptor/dsc operator cmp|move_iterator}}
{{dsc inc|cpp/iterator/istream_iterator/dsc operator cmp}}
{{dsc inc|cpp/iterator/istreambuf_iterator/dsc operator cmp}}
{{dsc inc|cpp/numeric/complex/dsc operator cmp}}
{{dsc inc|cpp/numeric/valarray/dsc operator cmp}}
{{dsc inc|cpp/numeric/random/engine/dsc operator cmp|linear_congruential_engine}}
{{dsc inc|cpp/numeric/random/distribution/dsc operator cmp|poisson_distribution}}
{{dsc inc|cpp/regex/sub_match/dsc operator cmp}}
{{dsc inc|cpp/regex/match_results/dsc operator cmp}}
{{dsc inc|cpp/regex/regex_iterator/dsc operator cmp}}
{{dsc inc|cpp/regex/regex_token_iterator/dsc operator cmp}}
{{dsc inc|cpp/thread/thread/id/dsc operator cmp}}
{{dsc end}}

命名空间 {{ltt|cpp/utility/rel_ops/operator cmp|std::rel_ops}} 提供了泛型运算符 {{c|1=!=}}、{{c|&gt;}}、{{c|1=&lt;=}} 及 {{c|1=&gt;=}}：
{{dsc begin}}
{{dsc header|utility}}
{{dsc namespace|std::rel_ops}}
{{dsc inc|cpp/utility/rel_ops/dsc operator cmp}}
{{dsc end}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=583|paper=N3624|std=C++98|before=所有六个比较运算符都能用来比较指针和空指针常量|after=只有相等性运算符可以}}
{{dr list item|wg=cwg|dr=661|std=C++98|before=未指明算术比较的实际语义（例如 1 &lt; 2 会生成 {{tt|true}} 还是 {{tt|false}}）|after=指明语义}}
{{dr list item|wg=cwg|dr=879|std=C++98|before=指向函数类型或 {{c/core|void}} 的指针缺少内建比较|after=指明如何比较这些指针}}
{{dr list item|wg=cwg|dr=1596|std=C++98|before=仅就指针算术的目的认为非数组对象属于拥有一个元素的数组|after=该规则也适用于比较}}
{{dr list item|wg=cwg|dr=1598|std=C++98|before=两个成员指针在两个成员所属类不同且都不是对方的基类时&lt;br&gt;不会比较相等，即使此时被指向的成员的偏移量可能相等|after=此时结果未指明}}
{{dr list item|wg=cwg|dr=1858|std=C++98|before=表示相同联合体的不同成员的两个成员指针不明确&lt;br&gt;是否会如同它们表示相同的成员那样比较相等|after=此时它们比较相等}}
{{dr list item|wg=cwg|dr=2419|std=C++98|before=只有通过 {{tt|&amp;}} 获取的到非数组对象的指针才会在&lt;br&gt;指针比较中被视为到大小为 1 的数组的首元素的指针|after=应用到所有到非数组对象的指针}}
{{dr list item|wg=cwg|dr=2526|std=C++98|before={{stddoc|N3624}} 移除了指向 {{c/core|void}} 的指针和函数指针的关系比较（{{tt|&gt;}}、{{tt|1=&gt;=}}、{{tt|&lt;}} 和 {{tt|1=&lt;=}}）的定义|after=恢复原本定义}}
{{dr list item|wg=cwg|dr=2796|std=C++17|before=在内建指针关系比较中不会对转换后的指针操作数进行函数指针转换|after=此时会进行转换}}
{{dr list end}}

===参阅===
* {{rlp|operator precedence|运算符优先级}}
* {{rlp|operators|运算符重载}}
* {{named req|Compare}}（具名要求）

{{cpp/language/operators}}

{{dsc begin}}
{{dsc see c|c/language/operator comparison|比较运算符|nomono=true}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}