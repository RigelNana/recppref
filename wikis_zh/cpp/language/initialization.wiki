{{title|初始化}}
{{cpp/language/initialization/navbar}}
变量的''初始化''会在构造时提供变量的初始值。

初始值可以由{{rlp|declarations|声明符}}或 {{rlp|new|new 表达式}}的初始化器部分提供。在函数调用时也会发生：函数形参及函数返回值也会被初始化。

===初始化器===
对于每个声明符，''初始化器''（如果存在）必须是下列之一：

{{sdsc begin}}
{{sdsc|num=1|1=
{{ttb|1==}} {{spar|表达式}}
}}
{{sdsc|num=2|notes=&lt;br&gt;&lt;br&gt;{{mark since c++20}}|1=
{{ttb|1== {}&lt;!----&gt;}}&lt;br&gt;{{ttb|1== {}} {{spar|初始化器列表}} {{ttb|}&lt;!----&gt;}}&lt;br&gt;{{ttb|1== {}} {{spar|指派初始化器列表}} {{ttb|}&lt;!----&gt;}}
}}
{{sdsc|num=3|notes={{mark until c++11}}&lt;br&gt;{{mark since c++11}}|
{{ttb|(}} {{spar|表达式列表}} {{ttb|)}}&lt;br&gt;{{ttb|(}} {{spar|初始化器列表}} {{ttb|)}}
}}
{{sdsc|num=4|notes={{mark since c++11}}&lt;br&gt;{{mark since c++11}}&lt;br&gt;{{mark since c++20}}|
{{ttb|{}&lt;!----&gt;}}&lt;br&gt;{{ttb|{}} {{spar|初始化器列表}} {{ttb|}&lt;!----&gt;}}&lt;br&gt;{{ttb|{}} {{spar|指派初始化器列表}} {{ttb|}&lt;!----&gt;}}
}}
{{sdsc end}}

@1@ 复制初始化语法。
@2@ {{rev inl|until=c++11|聚合初始化语法。}}{{rev inl|since=c++11|列表初始化语法。}}
@3@ 直接初始化语法。
@4@ 列表初始化语法。

{{par begin}}
{{par|{{spar|表达式}}|（无括号的{{rlp|operator other#内建的逗号运算符|逗号表达式}}以外的）任意表达式}}
{{par|{{spar|表达式列表}}|（无括号的逗号表达式以外的）任意表达式组成的逗号分隔列表}}
{{par|{{spar|初始化器列表}}|初始化器子句（见下文）组成的逗号分隔列表}}
{{par|{{spar|指派初始化器列表}}|{{rlp|aggregate initialization#指派初始化器|指派初始化器子句}}组成的逗号分隔列表}}
{{par end}}


''初始化器子句''{{sep}}必须是下列之一：

{{sdsc begin}}
{{sdsc|num=1|
{{spar|表达式}}
}}
{{sdsc|num=2|
{{ttb|{}&lt;!----&gt;}}
}}
{{sdsc|num=3|
{{ttb|{}} {{spar|初始化器列表}} {{ttb|}&lt;!----&gt;}}
}}
{{sdsc|num=4|notes={{mark since c++20}}|
{{ttb|{}} {{spar|指派初始化器列表}} {{ttb|}&lt;!----&gt;}}
}}
{{sdsc end}}

语法 {{v|2-4}} 统称为''花括号包围的初始化器列表''。

====初始化器语义====
如果没有为对象指定初始化器，那么该对象会{{rlp|default initialization|默认初始化}}。如果没有为{{rlp|reference|引用}}指定初始化器，那么程序非良构。

如果为对象指定的初始化器是 {{c|()}}（由于语法限制不能在声明符中出现），那么该对象会{{rlp|value initialization|值初始化}}。如果为引用指定的初始化器是 {{c|()}}，那么程序非良构。

初始化器的语义定义如下：
* 如果要初始化的是引用，那么定义参考{{rlp|reference initialization|引用初始化}}。
* 否则要初始化的是对象。给定该对象的类型为 {{tt|T}}：
:* 如果使用的是语法 {{v|1}} 的初始化器，那么对象会{{rlp|copy initialization|复制初始化}}。
{{rev begin}}
{{rev|until=c++11|
:* 如果使用的是语法 {{v|2}} 的初始化器：
::* 如果 {{tt|T}} 是{{rlp|aggregate initialization#定义|聚合体}}，那么就会应用{{rlp|aggregate initialization|聚合初始化}}。
::* 如果 {{tt|T}} 是[[cpp/named req/ScalarType|标量类型]]，那么 {{c|1=T x = { a };}} 等价于 {{c|1=T x = a;}}。
::* 否则程序非良构。
}}
{{rev|since=c++11|
:* 如果使用的是语法 {{v|2}} 或 {{v|4}} 的初始化器，那么对象会{{rlp|list initialization|列表初始化}}。
}}
{{rev end}}
:* 如果使用的是语法 {{v|3}} 的初始化器，那么对象会{{rlp|direct initialization|直接初始化}}。

{{source|1=
#include &lt;string&gt;

std::string s1;           // 默认初始化
std::string s2();         // 不是初始化！
                          // 实际上声明了没有形参并且返回 std::string 的函数 “s2”
std::string s3 = "hello"; // 复制初始化
std::string s4("hello");  // 直接初始化
std::string s5{'a'};      // 列表初始化（C++11 起）

char a[3] = {'a', 'b'}; // 聚合初始化（C++11 起是列表初始化的一部分）
char&amp; c = a[0];         // 引用初始化
}}

===非局部变量===
所有具有静态{{rlp|storage duration|存储期}}的非局部变量的初始化，会作为程序启动的一部分在 {{rlp|main function|main 函数}}的执行之前进行（除非被延迟，见下文）。所有具有线程局部存储期的非局部变量的初始化，会作为线程启动的一部分进行，并按顺序早于线程函数的执行开始。对于这两种变量，初始化发生于两个截然不同的阶段：

====静态初始化====
静态初始化有两种形式：
@1@ 如果可能，就应用{{rlp|constant initialization|常量初始化}}。

@2@ 否则，非局部的静态及线程局域变量会被{{rlp|zero initialization|零初始化}}。

实践中：
* 常量初始化通常在编译期进行。预先被计算的对象表示会作为程序映像的一部分存储下来。如果编译器没有这样做，那么它仍然必须保证该初始化发生早于任何动态初始化。
* 零初始化的变量将被置于程序映像的 {{tt|.bss}} 段，它不占据磁盘空间，并在加载程序时由操作系统以零填充。

====动态初始化====
在所有静态初始化完成后，在下列情形中进行非局部变量的动态初始化：

@1@ ''无序的动态初始化''，仅适用于未被{{rlp|template specialization|显式特化}}的（静态/线程局域）类模板的{{rlp|static|静态数据成员}}{{rev inl|since=c++14|及{{rlp|variable template|变量模板}}}}。这些静态变量的初始化相对于所有其他动态初始化之间是顺序不确定的{{rev inl|since=c++17|，除非程序在初始化某个变量之前开始了一个线程，此时初始化则是无顺序的}}。这些线程局域变量的初始化相对于所有其他动态初始化之间是无顺序的。

{{rrev|since=c++17|
@2@ ''部分有序的动态初始化''，适用于并未被隐式或显式实例化的特化的所有内联变量。如果一个部分有序的 V 在每个翻译单元中比有序或部分有序的 W 更早定义，那么 V 的初始化按顺序早于（或若程序启动了线程，则为先发生于）W 的初始化。
}}

@3@ ''有序的动态初始化''，适用于所有其他非局部变量：在单个翻译单元中，这些变量的初始化始终严格以其定义出现于源代码中的顺序{{rlp|eval order|定序}}。不同翻译单元中的静态变量的初始化之间是顺序不确定的。不同翻译单元中的线程局域变量的初始化之间是无顺序的。

当拥有静态或线程存储期的非局部变量的初始化通过异常退出时，调用 {{lc|std::terminate}}。

====提早动态初始化====
在下列条件都满足的情况下，允许编译器将动态初始化的变量的初始化作为静态初始化（实为编译期）的一部分进行：
@1@ 初始化的动态版本不改变命名空间作用域中任何先于其初始化的对象的值
@2@ 初始化的静态版本在被初始化变量中产生的值，与当所有不要求静态初始化的变量都被动态初始化时，由动态初始化所生成的值相同。

因为上述规则，如果某对象 {{tt|o1}} 的初始化涉及到命名空间作用域对象 {{tt|o2}}，而它潜在地要求动态初始化，但在同一翻译单元中在其之后定义，那么所用的 {{tt|o2}} 是完全初始化的 {{tt|o2}} 的值（因为编译器把 {{tt|o2}} 的初始化提升到编译时）还是 {{tt|o2}} 仅被零初始化的值是未指明的。
{{source|1=
inline double fd() { return 1.0; }

extern double d1;

double d2 = d1;   // 未指明：
                  // 如果 d1 被动态初始化则动态初始化为 0.0，或
                  // 如果 d1 被静态初始化则动态初始化为 1.0，或
                  // 静态初始化为 0.0（因为当两个变量都被动态初始化时将为这个值）

double d1 = fd(); // 可能静态或动态初始化为 1.0
}}

====延迟动态初始化====
动态初始化是发生早于（对于静态变量）主函数或（对于线程局域变量）其线程的启动函数的首条语句，还是延迟到发生晚于它们，是由实现定义的。

如果{{rev inl|since=c++17|非内联变量的}}初始化延迟到发生晚于主/线程函数的首条语句，那么它发生早于与所初始化的变量定义于同一翻译单元中的任何拥有静态/线程存储期的变量的首次 {{rlps|definition#ODR 使用}}。如果给定翻译单元中没有 ODR 使用变量或函数，那么在该翻译单元定义的非局部变量可能始终不被初始化（这模仿按需的动态库的行为）。然而，只要翻译单元中 ODR 使用了任何事物，就会初始化所有在初始化或销毁中拥有副作用的非局部变量，即使程序中没有用到它们。

{{rrev|since=c++17|
如果内联变量的初始化被延迟，那么它发生早于这个特定变量的首次 {{rlps|definition#ODR 使用}}。
}}

{{source|1=
// ============
// == 文件 1 ==

#include "a.h"
#include "b.h"

B b;
A::A() { b.Use(); }

// ============
// == 文件 2 ==

#include "a.h"

A a;

// ============
// == 文件 3 ==

#include "a.h"
#include "b.h"

extern A a;
extern B b;

int main()
{
    a.Use();
    b.Use();
}

// 如果 a 在进入 main 之前被初始化，那么 b 可能在 A::A() 使用它的时间点仍未被初始化
// （因为动态初始化在翻译单元间是顺序不确定的）

// 如果 a 在某个 main 的首条语句之后的时间点初始化
// （它 ODR 使用了定义于文件 1 的函数，强制其初始化得以运行），
// 那么 b 将在 A::A 使用它前初始化
}}

===静态局部变量===
有关局部（即块作用域）的静态和线程局部变量，见{{rlps|storage duration#静态块变量}}。

拥有{{rlp|storage duration#链接|外部或内部链接}}的变量的块作用域声明中不允许初始化器。这种声明必须带 {{c/core|extern}} 出现而且不能为定义。

===类成员===
非静态数据成员可以由{{rlp|initializer list|成员初始化器列表}}或由{{rlp|data members#成员初始化|默认成员初始化器}}初始化。

===注解===
非局部变量的销毁顺序在 {{lc|std::exit}} 中描述。

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=270|std=C++98|before=未指定类模板的静态数据成员的初始化顺序|after=除显式特殊化和定义外均指定为无序}}
{{dr list item|wg=cwg|dr=441|std=C++98|before=具有静态存储期的非局部引用不一定会在动态初始化前初始化|after=归类为静态初始化，总会在动态初始化前初始化}}
{{dr list item|wg=cwg|dr=1415|std=C++98|before=块作用域 {{c/core|extern}} 变量的声明可以是定义|after=不能是定义（禁止在此类声明中出现初始化器）}}
{{dr list item|wg=cwg|dr=2599|std=C++98|before=不明确初始化是否包含对初始化器中函数实参的求值|after=包含}}
{{dr list end}}

===参阅===
* {{rlp|copy elision|复制消除}}
* {{rlp|converting constructor|转换构造函数}}
* {{rlp|copy constructor|复制构造函数}}
* {{rlp|default constructor|默认构造函数}}
* {{rlpt|explicit}}
* {{rlp|move constructor|移动构造函数}}
* {{rlpt|new}}
{{dsc begin}}
{{dsc see c|c/language/initialization|初始化|nomono=true}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}