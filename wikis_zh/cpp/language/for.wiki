{{title|{{tt|for}} 循环}}
{{cpp/language/statements/navbar}}
有条件地重复执行某条语句，并且该语句不需要管理循环条件。

===语法===
{{sdsc begin}}
{{sdsc|{{spar optional|属性}} {{ttb|for (}} {{spar|初始化语句}}&lt;!-- 请勿在此添加分号！分号是初始化语句的一部分。 --&gt; {{spar optional|条件}} {{ttb|;}} {{spar optional|表达式}} {{ttb|)}} {{spar|语句}}}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|属性}}|{{mark since c++11}} 任意数量的{{rlp|attributes|属性}}}}
{{par|{{spar|初始化语句}}|下列之一：
* {{rlps|statements#表达式语句}}（可以是空语句 {{c|;}}）
* {{rlpsd|declarations#简单声明}}（典型情况下是循环计数变量的带初始化器的声明），它可以声明任意多个变量{{rev inl|since=c++17|或{{rlp|structured binding|结构化绑定}}}}
{{rrev|since=c++23|
* {{rlp|type alias|别名声明}}
}}
注意任何{{spar sep|初始化语句}}必须以分号结束。因此它经常被非正式描述为后随分号的表达式或声明。}}
{{par|{{spar|条件}}|[[#条件|条件]]}}
{{par|{{spar|表达式}}|{{rlp|expressions|表达式}}（典型情况下是增加循环计数器的表达式）}}
{{par|{{spar|语句}}|任意{{rlp|statements|语句}}（典型情况下是复合语句）}}
{{par end}}

{{cpp/language/condition|usage=确定是否会执行{{spar|语句}}|bool=yes}}

===解释===
{{c/core|for}} 语句等价于

{{sdsc begin}}
{{sdsc| 
{{ttb|{}}&lt;br&gt;
:{{spar|初始化语句}}&lt;br&gt;
:{{ttb|while (}} {{spar|条件}} {{ttb|)}}&lt;br&gt;
:{{ttb|{}}&lt;br&gt;
::{{spar|语句}}&lt;br&gt;
::{{spar|表达式}} {{ttb|;}}&lt;br&gt;
:{{ttb|}&lt;!----&gt;}}
{{ttb|}&lt;!----&gt;}}
}}
{{sdsc end}}

但有以下不同：
* {{spar sep|初始化语句}}的作用域和{{spar sep|条件}}的作用域相同。
* {{spar sep|语句}}的作用域和{{spar sep|表达式}}的作用域不相交，且都内嵌于{{spar sep|初始化语句}}和{{spar sep|条件}}的作用域之中。
* 执行{{spar sep|语句}}中的 {{rlp|continue|{{c/core|continue}} 语句}}时会求值{{spar|表达式}}。
* 空的{{spar sep|条件}}等价于 {{c|true}}。

如果需要在{{spar sep|语句}}中结束循环，那么可以使用 {{rlp|break|{{c/core|break}} 语句}}作为终止语句。

如果需要在{{spar sep|语句}}中结束当前迭代，那么可以使用 {{rlp|continue|{{c/core|continue}} 语句}}作为快捷方式。

===注解===
与 {{rlpt|while}} 循环的情况相同，如果{{spar sep|语句}}不是复合语句，那么在其中声明的变量的作用域被限制在循环体内，如同一条复合语句。
{{source|
for (;;)
    int n;
// n 离开作用域
}}

{{cpp/language/process guarantee note}}

在 C 中，{{spar sep|初始化语句}}和{{spar sep|条件}}的作用域中声明的名字可以被{{spar sep|语句}}的作用域中的名字隐藏，而这在 C++ 中则被禁止：
{{source|1=
for (int i = 0;;)
{
    long i = 1;   // 在 C 中合法，在 C++ 中非法
    // ...
}
}}

===关键词===
{{ltt|cpp/keyword/for}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    std::cout &lt;&lt; "1) 典型的以单语句作为循环体的循环:\n";
    for (int i = 0; i &lt; 10; ++i)
        std::cout &lt;&lt; i &lt;&lt; ' ';
    
    std::cout &lt;&lt; "\n\n" "2) 初始化语句可以声明多个名字，\n"
                 "只要它们可以使用相同的声明说明符序列:\n";
    for (int i = 0, *p = &amp;i; i &lt; 9; i += 2)
        std::cout &lt;&lt; i &lt;&lt; ':' &lt;&lt; *p &lt;&lt; ' ';
    
    std::cout &lt;&lt; "\n\n" "3) （循环）条件可以是声明:\n";
    char cstr[] = "Hello";
    for (int n = 0; char c = cstr[n]; ++n)
        std::cout &lt;&lt; c;
    
    std::cout &lt;&lt; "\n\n" "4) 初始化语句可以使用 auto 类型说明符:\n";
    std::vector&lt;int&gt; v = {3, 1, 4, 1, 5, 9};
    for (auto iter = v.begin(); iter != v.end(); ++iter)
        std::cout &lt;&lt; *iter &lt;&lt; ' ';
    
    std::cout &lt;&lt; "\n\n" "5) 初始化语句可以是表达式:\n";
    int n = 0;
    for (std::cout &lt;&lt; "循环开始\n";
         std::cout &lt;&lt; "循环测试\n";
         std::cout &lt;&lt; "迭代 " &lt;&lt; ++n &lt;&lt; '\n')
    {
        if (n &gt; 1)
            break;
    }
    
    std::cout &lt;&lt; "\n" "6) 每次迭代时均会调用循环体中创建的对象的构造函数和析构函数:\n";
    struct S
    {
        S(int x, int y) { std::cout &lt;&lt; "S::S(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; "); "; }
        ~S() { std::cout &lt;&lt; "S::~S()\n"; }
    };
    for (int i{0}, j{5}; i &lt; j; ++i, --j)
        S s{i, j};
    
    std::cout &lt;&lt; "\n" "7) 初始化语句可以使用结构化绑定:\n";
    long arr[]{1, 3, 7};
    for (auto [i, j, k] = arr; i + j &lt; k; ++i)
        std::cout &lt;&lt; i + j &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
1) 典型的以单语句作为循环体的循环:
0 1 2 3 4 5 6 7 8 9

2) 初始化语句可以声明多个名字，
只要它们可以使用相同的声明说明符序列:
0:0 2:2 4:4 6:6 8:8

3) （循环）条件可以是声明:
Hello

4) 初始化语句可以使用 auto 类型说明符:
3 1 4 1 5 9

5) 初始化语句可以是表达式:
循环开始
循环测试
迭代 1
循环测试
迭代 2
循环测试

6) 每次迭代时均会调用循环体中创建的对象的构造函数和析构函数:
S::S(0, 5); S::~S()
S::S(1, 4); S::~S()
S::S(2, 3); S::~S()

7) 初始化语句可以使用结构化绑定:
4 5 6
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/language/dsc range-for}}
{{dsc see c|c/language/for}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}