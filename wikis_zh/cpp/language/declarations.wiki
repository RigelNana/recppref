{{title|声明}}
{{cpp/language/declarations/navbar}}
{{i|声明}}将名字引入（或再引入）到 C++ 程序中。不是每条声明都实际声明任何东西，且每种实体的声明方式都不同。{{rlp|definition|定义}}是足以使该名字所标识的实体被使用的声明。

声明是下列之一：

* {{rlp|function#函数定义|函数定义}}
* {{rlp|templates|模板声明}}（包括{{rlp|partial specialization|部分模板特化}}）
* {{rlp|class template#显式实例化|显式模板实例化}}
* {{rlp|template specialization|显式模板特化}}
* {{rlp|namespace|命名空间定义}}
* {{rlp|language linkage|链接说明}}
{{rrev|since=c++11|
* 属性声明（{{spar|{{rlp|attributes|属性}}}} {{ttb|;}}）
}}
* 空声明（{{ttb|;}}）
* 无{{spar sep|声明说明符序列}}的函数声明：
{{sdsc begin}}
{{sdsc|
{{spar optional|属性}} {{spar|声明符}} {{ttb|;}}
}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|属性}}|{{mark since c++11}} 任意数量{{rlp|attributes|属性}}的序列}}
{{par|{{spar|声明符}}|函数声明符}}
{{par end}}
: 此声明必须声明构造函数、析构函数或用户定义的类型{{rlp|cast operator|转换函数}}。它只能用作{{rlp|templates|模板声明}}、{{rlp|template specialization|显式特化}}或显式实例化的一部分。
* {{spar|块声明}}（能在{{rlp|statements#复合语句|块}}中出现的声明），它可以是下列之一：
:* {{rlp|asm|汇编声明}}
{{rrev|since=c++11|
:* {{rlp|type alias|类型别名声明}}
}}
:* {{rlp|namespace alias|命名空间别名定义}}
:* {{rlp|using declaration|using 声明}}
:* {{rlp|namespace#using 指令|using 指令}}
{{rev begin}}
{{rev|since=c++20|
:* {{rlp|enum#using enum 声明|using enum 声明}}
}}
{{rev|since=c++11|
:* {{rlpt|static_assert}} 声明
:* {{rlp|enum|不透明 enum 声明}}
}}
{{rev end}}
:* 简单声明

===简单声明===
简单声明是引入、创建并可能会初始化一个或数个标识符（典型地为变量）的语句。

{{sdsc begin}}
{{sdsc|num=1|
{{spar|声明说明符序列}} {{spar optional|初始化声明符列表}} {{ttb|;}}
}}
{{sdsc|num=2|notes={{mark since c++11}}|
{{spar|属性}} {{spar|声明说明符序列}} {{spar|初始化声明符列表}} {{ttb|;}}
}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|属性}}|{{mark since c++11}} 任何数量{{rlp|attributes|属性}}的序列}}
{{par|{{spar|声明说明符序列}}|[[#说明符|说明符]]序列}}
{{par|{{spar|初始化声明符列表}}|{{spar|初始化声明符}}（见下文）的逗号分隔列表}}
{{par end}}


只有在声明具名类或具名枚举时可以省略{{spar|初始化声明符列表}}。

{{rrev|since=c++17|
{{rlp|structured binding|结构化绑定声明}}也是简单声明。
}}


{{spar sep|初始化声明符}}的语法定义如下：
{{sdsc begin}}
{{sdsc|num=1|
{{spar|声明符}} {{spar|初始化器}}
}}
{{sdsc|num=2|
{{spar|声明符}} {{spar optional|requires子句}} {{spar optional|契约说明}}
}}
{{sdsc end}}

@1@ 带有初始化器的声明符。

@2@ 不带初始化器的声明符。

{{par begin}}
{{par|{{spar|声明符}}|[[#声明符|声明符]]}}
{{par|{{spar|初始化器}}|{{rlp|initialization|初始化器}}}}
{{par|{{spar|requires子句}}|{{mark since c++20}} {{rlp|constraints#requires 子句|{{c/core|requires}} 子句}}}}
{{par|{{spar|契约说明}}|{{mark since c++26}} {{rlps|function#函数契约说明符}}列表}}
{{par end}}


{{rev begin}}
{{rev|since=c++20|
{{spar sep|requires子句}}只能在{{spar sep|声明符}}声明{{rlp|templates#模板化实体|模板化函数}}时出现。
}}
{{rev|since=c++26|
{{spar sep|契约说明}}只能在{{spar sep|声明符}}声明函数或函数模板时出现。
}}
{{rev end}}

===说明符===
'''声明说明符'''（{{spar|声明说明符序列}}）是下列以空白分隔的说明符的序列，顺序不限：

* {{rlpt|typedef}} 说明符。如果存在，那么整个声明是 {{rlp|typedef|typedef 声明}}，且每个声明符引入一个新的类型名，而非对象或函数。
* 函数说明符（{{rlpt|inline}}、{{rlpt|virtual}}、{{rlpt|explicit}}），只能在{{rlp|function|函数声明}}中使用。
{{rrev|since=c++17|
* {{rlpt|inline}} 说明符也可以用于变量声明。
}}
* {{rlpt|friend}} 说明符，可以在类和函数声明中使用。
{{rev begin}}
{{rev|since=c++11|
* {{rlpt|constexpr}} 说明符，只允许在变量定义，函数及函数模板声明，以及具有字面类型的静态数据成员的声明中使用。
}}
{{rev|since=c++20|
* {{rlpt|consteval}} 说明符，只允许在函数和函数模板声明中使用。
* {{rlpt|constinit}} 说明符，只允许在拥有静态或线程存储期的变量声明中使用。{{c/core|constexpr}}、{{c/core|consteval}} 和 {{c/core|constinit}} 说明符在一个{{spar sep|声明说明符序列}}中最多只能出现一个。
}}
{{rev end}}
* {{rlp|storage duration|存储类说明符}}（{{rev inl|until=c++17|{{ltt|cpp/keyword/register}}、}}{{ltt|cpp/keyword/static}}{{rev inl|since=c++11|、{{ltt|cpp/keyword/thread_local}}}}、{{ltt|cpp/keyword/extern}}、{{ltt|cpp/keyword/mutable}}）。只能使用一个存储类说明符{{rev inl|since=c++11|，但 {{c/core|thread_local}} 可以与 {{c/core|extern}} 或 {{c/core|static}} 一同出现}}。
* '''类型说明符'''（{{spar|类型说明符序列}}），指名一个类型的说明符的序列。声明所引入的每个实体都是这个类型，并可以被声明符修饰（见下文）。这个说明符序列也用于{{rlp|type#类型的命名|类型标识}}。只有下列说明符是{{spar sep|类型说明符序列}}的一部分，顺序不限：
:* {{rlp|class|类说明符}}
:* {{rlp|enum|枚举说明符}}
:* 简单类型说明符
::* {{ltt|cpp/keyword/char}}{{rev inl|since=c++20|、{{ltt|cpp/keyword/char8_t}}}}{{rev inl|since=c++11|、{{ltt|cpp/keyword/char16_t}}、{{ltt|cpp/keyword/char32_t}}}}、{{ltt|cpp/keyword/wchar_t}}、{{ltt|cpp/keyword/bool}}、{{ltt|cpp/keyword/short}}、{{ltt|cpp/keyword/int}}、{{ltt|cpp/keyword/long}}、{{ltt|cpp/keyword/signed}}、{{ltt|cpp/keyword/unsigned}}、{{ltt|cpp/keyword/float}}、{{ltt|cpp/keyword/double}}、{{ltt|cpp/keyword/void}}
{{rev begin}}
{{rev|since=c++11|
::* {{rlpt|auto}}
::* {{rlp|decltype|decltype 说明符}}
}}
{{rev|since=c++26|
::* {{rlp|pack indexing|包索引说明符}}
}}
{{rev end}}
::* 先前声明过的类名（可{{rlp|identifiers#有限定的标识符|限定}}）
::* 先前声明过的枚举名（可{{rlp|identifiers#有限定的标识符|限定}}）
::* 先前声明过的 {{rlp|typedef|typedef 名}}{{rev inl|since=c++11|或{{rlp|type alias|类型别名}}}}（可{{rlp|identifiers#有限定的标识符|限定}}）
::* 带模板实参的模板名（可{{rlp|identifiers#有限定的标识符|限定}}，可使用 {{rlp|dependent name|template 消歧义符}}）
{{rev begin}}
{{rev|since=c++17|
::* 无模板实参的模板名（可{{rlp|identifiers#有限定的标识符|限定}}）：参阅{{rlp|class template argument deduction|类模板实参推导}}
}}{{rev end}}
:* {{rlp|elaborated type specifier|详述类型说明符}}
::* 关键词 {{ltt|cpp/keyword/class}}、{{ltt|cpp/keyword/struct}} 或 {{ltt|cpp/keyword/union}}，后随先前已定义为类名的标识符（可{{rlp|identifiers#有限定的标识符|限定}}）。
::* 关键词 {{ltt|cpp/keyword/class}}、{{ltt|cpp/keyword/struct}} 或 {{ltt|cpp/keyword/union}}，后随带模板实参的、先前已定义为类模板名字的模板名（可{{rlp|identifiers#有限定的标识符|限定}}，可使用 {{rlp|dependent name|{{c/core|template}} 消歧义符}}）。
::* 关键词 {{ltt|cpp/keyword/enum}} 后随先前已定义为枚举名的标识符（可{{rlp|identifiers#有限定的标识符|限定}}）。
:* {{rlp|dependent name|{{c/core|typename}} 说明符}}
:* {{rlp|cv|cv 限定符}}
:每个{{spar sep|声明说明符序列}}中只允许一个类型说明符，但有以下例外：
:* {{c/core|const}} 能与自身外的任何类型说明符组合。
:* {{c/core|volatile}} 能与自身外的任何类型说明符组合。
:* {{c/core|signed}} 或 {{c/core|unsigned}} 能与 {{c/core|char}}、{{c/core|long}}、{{c/core|short}} 或 {{c/core|int}} 组合。
:* {{c/core|short}} 或 {{c/core|long}} 能与 {{c/core|int}} 组合。
:* {{c/core|long}} 能与 {{c/core|double}} 组合。
{{rrev|since=c++11|
:* {{c/core|long}} 能与 {{c/core|long}} 组合。
}}

{{rlp|attributes|属性}}可以在{{spar sep|声明说明符序列}}中出现，此时它们会应用于在它之前的说明符所确定的类型。

在{{spar sep|声明说明符序列}}中重复任何说明符，如 {{c/core|const static const}} 或 {{c/core|virtual inline virtual}} 是错误{{rev inl|since=c++11|，但允许 {{c/core|long}} 出现两次}}。

===声明符===
{{spar|初始化声明符列表}} {{c|S D1, D2, D3;}} 中的每个{{spar sep|初始化声明符}}均按照如同它是拥有相同说明符的孤立声明来处理：{{c|S D1; S D2; S D3;}}。

每个声明符恰好引入一个对象、引用、函数或（对于 typedef 声明）类型别名，它的类型由{{spar sep|声明说明符序列}}提供，并且可以被声明符中的运算符，如 {{c|&amp;}}（～的引用）或 {{c|[]}}（～的数组）或 {{c|()}}（返回～的函数）所修饰。可以递归应用这些声明符，如下所示。

{{spar sep|声明符}}是下列之一：
{{sdsc begin}}
{{sdsc|num=1|
{{spar|无限定标识}} {{spar optional|属性}}
}}
{{sdsc|num=2|
{{spar|有限定标识}} {{spar optional|属性}}
}}
{{sdsc|num=3|notes={{mark since c++11}}|
{{ttb|...}} {{spar|标识符}} {{spar optional|属性}}
}}
{{sdsc|num=4|
{{ttb|*}} {{spar optional|属性}} {{spar optional|cv限定符}} {{spar|声明符}}
}}
{{sdsc|num=5|
{{spar|嵌套名说明符}} {{ttb|*}} {{spar optional|属性}} {{spar optional|cv限定符}} {{spar|声明符}}
}}
{{sdsc|num=6|
{{ttb|&amp;}} {{spar optional|属性}} {{spar|声明符}}
}}
{{sdsc|num=7|notes={{mark since c++11}}|
{{ttb|&amp;&amp;}} {{spar optional|属性}} {{spar|声明符}}
}}
{{sdsc|num=8|
{{spar|非指针声明符}} {{ttb|[}} {{spar optional|常量表达式}} {{ttb|]}} {{spar optional|属性}}
}}
{{sdsc|num=9|
{{spar|非指针声明符}} {{ttb|(}} {{spar|形参列表}} {{ttb|)}} {{spar optional|cv限定符}} {{spar optional|引用限定符}} {{spar optional|异常说明}} {{spar optional|属性}}
}}
{{sdsc end}}

@1@ 所声明的{{rlp|name|名称}}。
@2@ 使用{{rlp|identifiers#有限定的标识符|有限定的标识符}}（{{spar|有限定标识}}）定义或重声明先前声明的{{rlp|namespace#命名空间|命名空间成员}}或{{rlp|classes|类成员}}的声明符。
@3@ {{rlp|parameter pack|形参包}}，只会在{{rlp|function#形参列表|形参声明}}中出现。
@4@ {{rlp|pointer|指针声明符}}：声明 {{c|S * D;}} 将 {{tt|D}} 声明为指向{{spar sep|声明说明符序列}}所确定的类型 {{tt|S}} 的指针。
@5@ {{rlp|pointer|成员指针声明}}：声明 {{c|S C::* D;}} 将 {{tt|D}} 声明为指向 {{tt|C}} 中的类型是{{spar sep|声明说明符序列}}所确定的类型 {{tt|S}} 的成员的指针。{{spar sep|嵌套名说明符}}是{{rlp|identifiers#有限定的标识符|名字和作用域解析运算符 {{ttb|::}} 的序列}}
@6@ {{rlp|reference|左值引用声明符}}：声明 {{c|S &amp; D;}} 将 {{tt|D}} 声明为到{{spar sep|声明说明符序列}}所确定的类型 {{tt|S}} 的左值引用。
@7@ {{rlp|reference|右值引用声明符}}：声明 {{c|S &amp;&amp; D;}} 将 {{tt|D}} 声明为到{{spar sep|声明说明符序列}}所确定的类型 {{tt|S}} 的右值引用。
@8@ {{rlp|array|数组声明符}}。{{spar sep|非指针声明符}}是任意合法声明符，但如果它以 *、&amp; 或 &amp;&amp; 起始，那么就必须用括号环绕它。
@9@ {{rlp|function|函数声明符}}。{{spar sep|非指针声明符}}是任意合法声明符，但如果它以 *、&amp; 或 &amp;&amp; 起始，那么就必须用括号环绕它。{{rev inl|since=c++11|它可以以尾随返回类型结尾。}}

{{rrev|since=c++11|
所有情况下，{{spar sep|属性}}都是{{rlp|attributes|属性}}的序列。当它紧跟标识符之后出现时，它应用于所声明的对象。
}}

{{spar sep|cv限定符}}是 {{rlp|cv|const 与 volatile}} 限定符的序列，其中任一限定符在序列中至多出现一次。

{{todo|解释名字隐藏规则；变量/函数声明如何隐藏同名的类（而非 typedef）}}

===注解===
{{spar sep|块声明}}出现{{rlp|statements#复合语句|在代码块内}}，而当声明中引入的标识符之前已在某个外层代码块中声明时，该代码块的剩余部分中{{rlp|scope|外层声明被隐藏}}。

如果一个声明引入了一个具有自动存储期的变量，那么它会在执行它的声明语句时被初始化。退出代码块时，所有在该块中声明的自动变量被以它的初始化顺序的相反顺序销毁（与如何退出代码块无关：通过{{rlp|exceptions|异常}}、{{rlp|goto}} 或抵达它的结尾）。

===示例===
{{example|
注意，这个例子演示一些复杂声明式是如何依据语言文法进行分析的。其他流行的助记法包括：[https://c-faq.com/decl/spiral.anderson.html 螺旋规则]，[https://stackoverflow.com/a/34560439/273767 从内向外]读法，以及[https://stackoverflow.com/a/34552915/273767 声明与使用为镜像]等。还有一个自动分析器，位于 https://cdecl.org。
|code=
#include &lt;type_traits&gt;

struct S
{
    int member;
    // 声明说明符序列为 "int"
    // 声明符为 "member"
} obj, *pObj(&amp;obj);
// 声明说明符序列为 "struct S { int member; }"
// 声明符 "obj" 声明一个 S 类型的对象
// 声明符 "*pObj" 声明一个 S 的指针，
//     而初始化器 "(&amp;obj)" 为之初始化

int (*(*var1)(double))[3] = nullptr;
// 声明说明符序列为 "int"
// 声明符为 "(*(*var1)(double))[3]"
// 初始化器为 "= nullptr"

// 1. 声明符 "(*(*var1)(double))[3]" 是数组声明符:
//    所声明类型为: [_]的 3 元素数组 "(*(*var1)(double))"
// 2. 声明符 "(*(*var1)(double))" 是指针声明符:
//    所声明类型为: 指向[ [_]的 3 元素数组]的指针 "(*var1)(double)"
// 3. 声明符 "(*var1)(double)" 是函数声明符:
//    所声明类型为: 接受 "(double)" 返回[指向[ [_]的 3 元素数组]的指针]的函数 "(*var1)"
// 4. 声明符 "(*var1)" 是指针声明符：
//    所声明类型为: 指向[接受 "(double)" 返回[指向[ [_]的 3 元素数组]的指针]的函数]的指针 "var1"
// 5. 声明符 "var1" 为一个标识符。
// 此条声明所声明的对象 var1 具有类型“指向接受 "(double)" 返回指向 int 的 3 元素数组的指针的函数的指针”
// 初始化器 "= nullptr" 为此指针提供初值。

// C++11 的替代语法：
auto (*var2)(double) -&gt; int (*)[3] = nullptr;
// 声明说明符序列为 "auto"
// 声明符为 "(*var2)(double) -&gt; int (*)[3]"
// 初始化器为 "= nullptr"

// 1. 声明符 "(*var2)(double) -&gt; int (*)[3]" 是函数声明符:
//    所声明类型为: 接收 "(double)" 返回 "int (*)[3]" 的函数 "(*var2)"
// ...

int main()
{
    static_assert(std::is_same_v&lt;decltype(var1), decltype(var2)&gt;);
}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=482|std=C++98|before=重声明中的声明符不能有限定|after=此时允许有限定声明符}}
{{dr list item|wg=cwg|dr=569|std=C++98|before=单独的分号不是合法声明|after=它是空声明，这种声明没有任何效果}}
{{dr list item|wg=cwg|dr=1830|std=C++98|before=允许在{{spar sep|声明说明符序列}}中重复函数说明符|after=禁止重复}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc see c|c/language/declarations|声明|nomono=true}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}