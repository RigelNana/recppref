{{title|复制构造函数}}
{{cpp/language/classes/navbar}}

复制构造函数是提供一个相同类类型实参就能调用，并且在不修改实参的情况下复制该实参的内容的{{rlp|constructor|构造函数}}。

===语法===
{{sdsc begin}}
{{sdsc|num=1|{{spar sep|类名}}{{ttb|(}}{{spar sep|形参列表}}{{ttb|);}}}}
{{sdsc|num=2|{{spar sep|类名}}{{ttb|(}}{{spar sep|形参列表}}{{ttb|)}} {{spar|函数体}}}}
{{sdsc|num=3|{{spar sep|类名}}{{ttb|(}}{{spar sep|单形参列表}}{{ttb|1=) = default;}}|notes={{mark since c++11}}}}
{{sdsc|num=4|{{spar sep|类名}}{{ttb|(}}{{spar sep|形参列表}}{{ttb|1=) = delete;}}|notes={{mark since c++11}}}}
{{sdsc|num=5|{{spar sep|类名}}{{ttb|::}}{{spar sep|类名}}{{ttb|(}}{{spar sep|形参列表}}{{ttb|)}} {{spar|函数体}}}}
{{sdsc|num=6|{{spar sep|类名}}{{ttb|::}}{{spar sep|类名}}{{ttb|(}}{{spar sep|单形参列表}}{{ttb|1=) = default;}}|notes={{mark since c++11}}}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|类名}}|要声明复制构造函数的类}}
{{par|{{spar|形参列表}}|满足以下条件的非空{{rlp|function#形参列表|形参列表}}：
* 给定该类的类型为 {{tt|T}}，第一个形参的类型是 {{c/core|T&amp;}}，{{c/core|const T&amp;}}，{{c/core|volatile T&amp;}} 或 {{c/core|const volatile T&amp;}}，并且
* 要么没有其他形参，要么其他形参都有{{rlp|default arguments|默认实参}}}}
{{par|{{spar|单形参列表}}|只有一个形参的{{rlp|function#形参列表|形参列表}}，该形参没有默认实参，并且类型是 {{c/core|T&amp;}}，{{c/core|const T&amp;}}，{{c/core|volatile T&amp;}} 或 {{c/core|const volatile T&amp;}}}}
{{par|{{spar|函数体}}|复制构造函数的{{rlp|constructor|函数体}}}}
{{par end}}

===解释===
@1@ 类定义中的复制构造函数的声明。
@2-4@ 类定义中的复制构造函数的定义。
:@3@ 复制构造函数会被显式预置。
:@4@ 复制构造函数会被弃置。
@5,6@ 类定义之外的复制构造函数的定义（该类必须包含一条声明 {{v|1}}）。
:@6@ 复制构造函数会被显式预置。

{{source|1=
struct X
{
    X(X&amp; other); // 复制构造函数
//  X(X other);  // 错误：形参类型不正确
};

union Y
{
    Y(Y&amp; other, int num = 1); // 有多个形参的复制构造函数
//  Y(Y&amp; other, int num);     // 错误：num 没有默认实参
};
}}

复制构造函数会在对象从同类型的另一对象（以{{rlp|direct initialization|直接初始化}}或{{rlp|copy initialization|复制初始化}}）{{rlp|initialization|初始化}}时调用（除非{{rlp|overload resolution|重载决议}}选择了更好的匹配或它的调用被{{rlp|copy elision|消除}}），情况包括：
* 初始化：{{c|1=T a = b;}} 或 {{c|1=T a(b);}}，其中 {{c|b}} 的类型是 {{tt|T}}；
* 函数实参传递：{{c|f(a);}}，其中 {{c|a}} 的类型是 {{tt|T}} 而 {{c|f}} 是 {{c|void f(T t)}}；
* 函数返回：在像 {{c|T f()}} 这样的函数内部的 {{c|return a;}}，其中 {{c|a}} 的类型是 {{tt|T}} 且它没有{{rlp|move constructor|移动构造函数}}。

===隐式声明的复制构造函数===
如果没有向类类型提供任何用户定义的复制构造函数，那么编译器总是会声明一个复制构造函数作为这个类的非 {{rlp|explicit}} 的 {{c/core|inline public}} 成员。如果满足下列所有条件，那么这个隐式声明的复制构造函数拥有形式 {{c|T::T(const T&amp;)}}：
* {{tt|T}} 的每个直接基类和虚基类 {{tt|B}} 均拥有形参类型是 {{c/core|const B&amp;}} 或 {{c/core|const volatile B&amp;}} 的复制构造函数；
* {{tt|T}} 的每个类类型或类类型数组的非静态数据成员 {{tt|M}} 均拥有形参类型是 {{c/core|const M&amp;}} 或 {{c/core|const volatile M&amp;}} 的复制构造函数。
否则，隐式声明的复制构造函数是 {{c|T::T(T&amp;)}}。

因为这些规则，隐式声明的复制构造函数不能绑定到 {{c/core|volatile}} 左值实参。

类可以拥有多个复制构造函数，如 {{c|T::T(const T&amp;)}} 和 {{c|T::T(T&amp;)}}。

{{rrev|since=c++11|
当存在用户定义的复制构造函数时，用户仍可以使用关键词 {{c/core|default}} 强制编译器隐式声明复制构造函数。
}}

隐式声明（或在它的首个声明被预置）的复制构造函数具有{{rev inl|until=c++17|{{rlp|except spec|动态异常说明}}}}{{rev inl|since=c++17|{{rlp|noexcept spec| noexcept 说明}}}}中所描述的异常说明。

===隐式定义的复制构造函数===
如果隐式声明的复制构造函数没有被弃置，那么当它被 {{rlp|definition#ODR 使用|ODR 使用}}{{rev inl|since=c++11|&lt;!-- P0859R0 --&gt;或用于{{rlp|constant expression#常量求值所需要的函数与变量|常量求值}}}}时，它会被编译器定义（即生成并编译函数体）。对于联合体类型，隐式定义的复制构造函数（如同以 {{lc|std::memmove}}）复制它的对象表示。对于非联合类类型，该构造函数用直接初始化，按照初始化顺序，对对象的各直接基类子对象与成员子对象进行完整的逐成员复制。对每个引用类型的非静态数据成员，复制构造函数将改引用绑定到源引用所绑定到的同一对象或函数。

{{rrev|since=c++11|
如果它满足对于 {{rev inl|until=c++23|{{rlp|constexpr#constexpr 构造函数|constexpr 构造函数}}}}{{rev inl|since=c++23|{{rlp|constexpr#constexpr 函数|constexpr 函数}}}}的要求，那么生成的复制构造函数也是 {{tt|constexpr}} 的。

当 {{tt|T}} 拥有用户定义的析构函数或用户定义的复制赋值运算符时，隐式定义的复制构造函数的生成会被弃用。
}}

===弃置的复制构造函数===
如果满足以下任意条件，那么类 {{tt|T}} 中隐式声明的{{rev inl|since=c++11|或显式预置的}}复制构造函数{{rev inl|until=c++11|不被定义}}{{rev inl|since=c++11|被定义为弃置的}}：
{{rrev|since=c++11|
* {{tt|T}} 有一个具有右值引用类型的非静态数据成员。
}}
* {{tt|T}} 有一个具有类类型 {{tt|M}}（或它的可以有多维的数组类型）的{{rlp|object#潜在构造的子对象|潜在构造的子对象}}，并且
:* {{tt|M}} 有一个{{rev inl|since=c++11|被弃置或}}无法从该默认构造函数访问的析构函数，或者
:* 为寻找 {{tt|M}} 的复制构造函数而进行的重载决议
::* 没有得到可用候选，或者
::* 在该子对象是{{rlp|union#联合体式的类|变体成员}}时，选择了非平凡的函数。

{{rrev|since=c++11|
类 {{tt|T}} 中隐式声明的复制构造函数在 {{tt|T}} 声明了{{rlp|move constructor|移动构造函数}}或{{rlp|move assignment|移动赋值运算符}}的情况下会被弃置。
}}

===平凡的复制构造函数===
如果满足下列所有条件，那么类 {{tt|T}} 的复制构造函数是平凡的：
* 它不是用户提供的（即它是隐式定义或预置的）；
* {{tt|T}} 没有虚成员函数；
* {{tt|T}} 没有虚基类；
* 为 {{tt|T}} 的每个直接基类选择的复制构造函数都是平凡的；
* 为 {{tt|T}} 的每个类类型（或类类型数组）的非静态成员选择的复制构造函数都是平凡的；

非联合类的平凡复制构造函数的效果是复制实参的每个标量子对象（递归地包含子对象的子对象，以此类推），且不进行其他动作。不过不需要复制填充字节，甚至只要它们的值相同，每个复制的子对象的对象表示也不必相同。

{{named req|TriviallyCopyable}}对象可以通过手动复制其对象表示来进行复制，例如用 {{lc|std::memmove}}。所有与 C 语言兼容的数据类型（POD 类型）都可以平凡复制。

===合格的复制构造函数===
{{cpp/language/eligible special member function|复制构造函数}}

合格的复制构造函数的平凡性确定该类是否为{{rlp|lifetime#隐式生存期类型|隐式生存期类型}}，以及该类是否为[[cpp/named req/TriviallyCopyable|可平凡复制类型]]。

===注解===
许多情况下，即使复制构造函数能够产生可观测副作用，它们也会被优化掉，见{{rlp|copy elision|复制消除}}。

===示例===
{{source|code=
struct A
{
    int n;
    A(int n = 1) : n(n) {}
    A(const A&amp; a) : n(a.n) {} // 用户定义的复制构造函数
};

struct B : A
{
    // 隐式默认构造函数 B::B()
    // 隐式复制构造函数 B::B(const B&amp;)
};

struct C : B
{
    C() : B() {}
private:
    C(const C&amp;); // 不可复制，C++98 风格
};

int main()
{
    A a1(7);
    A a2(a1); // 调用复制构造函数
    
    B b;
    B b2 = b;
    A a3 = b; // 转换到 A&amp; 并调用复制构造函数
    
    volatile A va(10);
    // A a4 = va; // 编译错误
    
    C c;
    // C c2 = c; // 编译错误
}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1353|std=C++98|before=不定义隐式声明的复制构造函数的条件没有考虑多维数组类型|after=考虑这些类型}}
{{dr list item|wg=cwg|dr=2094|std=C++11|before=volatile 成员会导致复制不平凡（{{cwg|496}}）|after=平凡性不受影响}}
{{dr list item|wg=cwg|dr=2171|std=C++11|before={{c|1=X(X&amp;) = default}} 不是平凡的|after=使它平凡}}
{{dr list item|wg=cwg|dr=2595|std=C++20|before=对于一个复制构造函数，如果存在其他更受约束但&lt;br&gt;无法满足关联约束的复制构造函数，那么它无法合格|after=此时它可以合格}}
{{dr list end}}

===参阅===
* {{rlp|converting constructor|转换构造函数}}
* {{rlp|copy assignment|复制赋值}}
* {{rlp|copy elision|复制消除}}
* {{rlp|default constructor|默认构造函数}}
* {{rlp|destructor|析构函数}}
* {{rlpt|explicit}}
* {{rlp|initialization|初始化}}
** {{rlp|aggregate initialization|聚合初始化}}
** {{rlp|constant initialization|常量初始化}}
** {{rlp|copy initialization|复制初始化}}
** {{rlp|default initialization|默认初始化}}
** {{rlp|direct initialization|直接初始化}}
** {{rlp|initializer list|初始化列表}}
** {{rlp|list initialization|列表初始化}}
** {{rlp|reference initialization|引用初始化}}
** {{rlp|value initialization|值初始化}}
** {{rlp|zero initialization|零初始化}}
* {{rlp|move assignment|移动赋值}}
* {{rlp|move constructor|移动构造函数}}
* {{rlpt|new}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}