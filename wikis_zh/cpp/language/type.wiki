{{title|类型}}
{{cpp/language/basics/navbar}}
{{rlp|object|对象}}、{{rlp|reference|引用}}、{{rlp|functions|函数}}（包括{{rlp|template specialization|函数模板特化}}）和{{rlp|expressions|表达式}}具有称为''类型''{{sep}}的性质，它限制了对这些实体所容许的操作，并给原本寻常的位序列提供了语义含义。

===类型的分类===
C++ 类型系统由以下类型组成：
* {{rlp|types|基础类型}}：
:* {{c/core|void}} 类型；
{{rrev|since=c++11|
:* {{lc|std::nullptr_t}} 类型；
}}
:* 算术类型：
::* 整数类型（包括{{rlp|cv|有 cv 限定版本}}）：
:::* {{c/core|bool}} 类型；
:::* 字符类型：
::::* 窄字符类型：
:::::* 普通字符类型：{{c/core|char}}、{{c/core|signed char}}、{{c/core|unsigned char}}&lt;ref&gt;{{c/core|signed char}} 和 {{c/core|unsigned char}} 是窄字符类型，但不是字符类型。也就是说窄字符类型集合不是字符类型集合的子集。&lt;/ref&gt;
{{rrev|since=c++20|
:::::* {{c/core|char8_t}} 类型
}}
::::* 宽字符类型：{{rev inl|since=c++11|{{c/core|char16_t}}、{{c/core|char32_t}}、}}{{c/core|wchar_t}}；
:::* 有符号整数类型：
::::* 标准有符号整数类型：{{c/core|signed char}}、{{c/core|short int}}、{{c/core|int}}、{{c/core|long int}}{{rev inl|since=c++11|、{{c/core|long long int}}}}；
{{rrev|since=c++11|
::::* 扩展有符号整数类型（由实现定义）；
}}
:::* 无符号整数类型：
::::* 标准无符号整数类型：{{c/core|unsigned char}}、{{c/core|unsigned short int}}、{{c/core|unsigned int}}、{{c/core|unsigned long int}}{{rev inl|since=c++11|、{{c/core|unsigned long long int}}}}；
{{rrev|since=c++11|
::::* 扩展无符号整数类型（与扩展有符号整数类型一一对应）
}}
::* 浮点数类型：
:::* 标准浮点数类型：{{c/core|float}}、{{c/core|double}}、{{c/core|long double}}；
{{rrev|since=c++23|
:::* 扩展浮点数类型（包括{{rlp|cv|有 cv 限定版本}}）：
::::* [[cpp/types/floating-point|定宽浮点数类型]]
::::* 其他由实现定义的浮点数类型；
}}
* 复合类型：
:* {{rlp|reference|引用类型}}：
::* {{rlp|reference#左值引用|左值引用类型}}；
:::* 到对象的左值引用类型；
:::* 到函数的左值引用类型；
{{rrev|since=c++11|
::* {{rlp|reference#右值引用|右值引用类型}}；
:::* 到对象的右值引用类型；
:::* 到函数的右值引用类型；
}}
:* {{rlp|pointer#指针|指针类型}}：
::* {{rlp|pointer#对象指针|指向对象的指针（对象指针）类型}}；
::* {{rlp|pointer#函数指针|指向函数的指针（函数指针）类型}}；
:* {{rlp|pointer#成员指针|指向成员的指针（成员指针）类型}}：
::* {{rlp|pointer#数据成员指针|指向数据成员的指针}}类型；
::* {{rlp|pointer#成员函数指针|指向成员函数的指针}}类型；
:* {{rlp|array|数组类型}}；
:* {{rlp|function|函数类型}}；
:* {{rlp|enum|枚举类型}}：
::* {{rlp|enum#无作用域枚举|无作用域枚举类型}}；
{{rrev|since=c++11|
::* {{rlp|enum#有作用域枚举|有作用域枚举类型}}；
}}
:* {{rlp|class|类类型}}：
::* 非联合体类型；
::* {{rlp|union|联合体类型}}。

&lt;references/&gt;

对于除引用和函数以外的每个类型，类型系统还支持该类型的三个附加 {{rlp|cv|cv 限定版本}}（{{c/core|const}}、{{c/core|volatile}} 及 {{c/core|const volatile}}）。

&lt;div style="overflow-x: scroll;"&gt;
[[File:cpp_types.svg]]
&lt;/div&gt;

{{anchor|对象类型|标量类型|隐式生存期类型|可平凡复制类型}}
===其他类别===
''对象类型''{{sep}}是除了函数类型、引用类型以及（可有 cv 限定的）{{c/core|void}} 类型以外的（可有 cv 限定的）类型。

下列类型统称为''标量类型''（参阅 {{lc|std::is_scalar}}）：
* 算术类型
* [[cpp/language/enum|枚举类型]]
* [[cpp/language/pointer|指针类型]]
* [[cpp/language/pointer#成员指针|成员指针类型]]
{{rrev|since=c++11|
* {{lc|std::nullptr_t}}
}}
* 这些类型的有 cv 限定版本

下列类型统称为''隐式生存期类型''：
* 标量类型
* [[cpp/language/classes#隐式生存期类|隐式生存期类类型]]
* 数组类型
* 这些类型的有 cv 限定版本

{{rrev|since=c++11|
下列类型统称为''可平凡复制类型''：
* 标量类型
* [[cpp/language/classes#可平凡复制类|可平凡复制类类型]]
* 上述类型的数组
* 这些类型的有 cv 限定版本

下列类型统称为''标准布局类型''：
* 标量类型
* [[cpp/language/classes#标准布局类|标准布局类类型]]
* 上述类型的数组
* 这些类型的有 cv 限定版本
}}

{{anchor|简旧数据类型|平凡类型}}

{{cot|类型特征层次结构图}}
&lt;div style="overflow-x: scroll;"&gt;
[[File:cpp_types_v3.svg]]
&lt;/div&gt;
''注意：SVG 图片中的元素是可以点击的，但需首先在新浏览器标签页中打开此图''
{{cob}}

====被弃用的类别====
{{rev begin}}
&lt;tr class="t-rev"&gt;
&lt;td&gt;
下列类型统称为''简旧数据类型''（参阅 {{lc|std::is_pod}}）：
* 标量类型
* {{ls|cpp/language/classes#简旧数据类}}
* 上述类型的数组
* 这些类型的有 cv 限定版本
&lt;/td&gt;
&lt;td&gt;{{mark deprecated c++20}}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr class="t-rev"&gt;
&lt;td&gt;
下列类型统称为''平凡类型''（参阅 {{lc|std::is_trivial}}）：
* 标量类型
* [[cpp/language/classes#平凡类|平凡类类型]]
* 上述类型的数组
* 这些类型的有 cv 限定版本
&lt;/td&gt;
&lt;td&gt;{{mark since c++11}}&lt;br&gt;{{mark deprecated c++26}}&lt;/td&gt;
&lt;/tr&gt;
{{rev end}}

===由程序定义的类型===
''由程序定义的特化''{{sep}}是不属于 C++ [[cpp/standard library|标准库]]且不由实现定义的{{rlp|template specialization|显式特化}}或{{rlp|partial specialization|偏特化}}。

''由程序定义的类型''{{sep}}是以下类型之一：
* 不属于 C++ 标准库且不由实现定义的{{rev inl|since=c++11|非{{rlp|lambda|闭包}}}}{{rlp|class|类类型}}或{{rlp|enum|枚举类型}}。
{{rrev|since=c++11|
* 不由实现提供的 {{rlp|lambda|lambda 表达式}}的闭包类型。
}}
* 由程序定义的特化的{{rlp|templates|实例化}}。

===类型的命名===
能通过以下方式声明一个{{rlps|identifiers#名字}}以指代类型：
* {{rlp|class|类}}声明；
* {{rlp|union|联合体}}声明；
* {{rlp|enum|枚举}}声明；
* {{rlp|typedef}} 声明；
* {{rlp|type alias|类型别名}}声明。

在 C++ 程序中经常需要指代没有名字的类型；为此而设的语法被称为{{spar|类型标识}}。指明类型 {{tt|T}} 的类型标识的语法与省略了标识符的对 {{tt|T}} 类型的变量或函数的{{rlp|declarations|声明}}语法完全一致，但声明语法中的{{spar sep|声明说明符序列}}被限制为{{spar|类型说明符序列}}，另外只有在类型标识在非模板类型别名声明的右侧出现时才可以定义新类型。
{{source|1=
int* p;               // 声明一个指向 int 的指针
static_cast&lt;int*&gt;(p); // 类型标识是 "int*"

int a[3];   // 声明一个含有 3 个 int 的数组
new int[3]; // 类型标识是 "int[3]"（称作 new-类型标识）

int (*(*x[2])())[3];      // 声明一个含有 2 个函数指针的数组
                          // 这些函数指针指向的函数返回指向（含有 3 个 int 的数组）的指针
new (int (*(*[2])())[3]); // 类型标识是 "int (*(*[2])())[3]"

void f(int);                    // 声明一个接收 int 并返回 void 的函数
std::function&lt;void(int)&gt; x = f; // 类型模板形参是类型标识 "void(int)"
std::function&lt;auto(int) -&gt; void&gt; y = f; // 同上

std::vector&lt;int&gt; v;       // 声明一个含有 int 的 vector
sizeof(std::vector&lt;int&gt;); // 类型标识为 "std::vector&lt;int&gt;"

struct { int x; } b;         // 创建一个新类型并声明该类型的一个对象 b
sizeof(struct{ int x; });    // 错误：不能在 sizeof 表达式中定义新类型
using t = struct { int x; }; // 创建一个新类型并声明 t 为该类型的一个别名

sizeof(static int); // 错误：存储类说明符不是类型说明符序列的一部分
std::function&lt;inline void(int)&gt; f; // 错误：函数说明符也不是
}}
声明语法的{{spar sep|声明符}}部分在移除了名字后被称为{{spar|抽象声明符}}。

类型标识可用于下列情形：
* 指定{{rlp|expressions#转换|转型表达式}}中的目标类型；
* 作为 {{rlpt|sizeof}}、{{rlpt|alignof}}、{{rlpt|alignas}}、{{rlpt|new}} 和 {{rlpt|typeid}} 的实参；
* 在{{rlp|type alias|类型别名}}声明的右侧；
* 作为{{rlp|function|函数}}声明的尾随返回类型；
* 作为{{rlp|template parameters#模板类型形参|模板类型形参}}的默认实参；
* 作为{{rlp|template parameters#模板类型实参|模板类型形参}}的模板实参；
* 在{{rlp|except spec|动态异常说明}}中。

类型标识经过一些修改可用于下列情形：
* 在{{rlp|function#形参列表|函数}}形参列表中（省略形参名时），{{spar sep|类型标识}}用{{spar sep|声明说明符序列}}代替{{spar|类型说明符序列}}（尤其是允许使用某些存储类说明符）；
* 在{{rlp|cast operator|用户定义转换函数}}名中，抽象声明符不能包含函数或数组运算符。

{{todo|8.2[dcl.ambig.res]，如果能紧凑地总结}}
{{todo|提及并链接到 {{rlpt|decltype}} 和 {{rlpt|auto}}}}

===详述类型说明符===
详述类型说明符能用来指代先前声明过的类名（类、结构体或联合体）或先前声明过的枚举名，即使该名字{{rlp|lookup|被非类型声明隐藏}}。它们也能用来声明新的类名。

详见{{rlp|elaborated type specifier|详述类型说明符}}。

===静态类型===
对程序进行编译时分析所得到的表达式的类型被称为表达式的''静态类型''。程序执行时静态类型不会更改。

===动态类型===
如果某个{{rlp|value category|泛左值表达式}}指代某个{{rlp|object|多态对象}}，那么它的最终派生对象的类型被称为它的动态类型。
{{source|1=
// 给定
struct B { virtual ~B() {} }; // 多态类型
struct D: B {};               // 多态类型

D d; // 最终派生对象
B* ptr = &amp;d;

// (*ptr) 的静态类型是 B
// (*ptr) 的动态类型是 D
}}

对于纯右值表达式，动态类型始终与静态类型相同。

===不完整类型===
下列类型是''不完整类型''：
* {{c/core|void}} 类型（可有 {{rlp|cv}} 限定）；
* ''不完整定义的对象类型''：
** 已声明（例如由{{rlps|class#前置声明}}）但未定义的类类型；
** {{rlp|array#未知边界数组|未知边界数组}}；
** 不完整类型元素的数组
** {{rlp|enum|枚举类型}}，从它的声明点到确定它的底层类型之间。
所有其他类型都是完整的。

下列语境都要求类型 {{tt|T}} 完整：
* 返回类型是 {{tt|T}} 或参数类型是 {{tt|T}} 的函数的{{rlp|function|定义}}或调用&lt;!-- 有例外，例如函数调用是 decltype 的运算数时 --&gt;；
* {{tt|T}} 类型对象的{{rlp|definition|定义}};
* {{tt|T}} 类型{{rlp|data members|非静态数据成员}}的声明；
* {{tt|T}} 类型对象或元素类型为 {{tt|T}} 的数组的 {{rlp|new|{{tt|new}} 表达式}}；
* 对 {{tt|T}} 类型泛左值实施的{{rlp|implicit conversion#左值到右值转换|左值到右值转换}}；
* 到 {{tt|T}} 类型的{{rlp|implicit cast|隐式}}或{{rlp|explicit cast|显式}}转换；
* 到 {{c/core|T*}} 或 {{c/core|T&amp;}} 类型的 {{rlp|implicit cast|标准转换}}、{{rlpt|dynamic_cast}} 或 {{rlpt|static_cast}}，不包括从{{rlp|pointer#空指针|空指针常量}}或从{{rlp|pointer#void 的指针|指向可有 cv 限定的 void 的指针}}进行的转换；
* 对 {{tt|T}} 类型表达式运用的{{rlp|operator member access|类成员访问运算符}}；
* 对 {{tt|T}} 类型运用的 {{rlpt|typeid}}、{{rlpt|sizeof}} 或 {{rlpt|alignof}} 运算符；
* 对指向 {{tt|T}} 的指针运用的{{rlp|operator arithmetic|算术运算符}}；
* 带有基类 {{tt|T}} 的类的定义；
* 对 {{tt|T}} 类型的左值的赋值；
* 类型是 {{tt|T}}、{{c/core|T&amp;}} 或 {{c/core|T*}} 的{{rlp|catch|处理块}}。
（通常在必须知道 {{tt|T}} 的大小和布局时要求它完整。）

如果翻译单元中出现了这些情况中的任何情况，该类型的定义就必须在相同的翻译单元中出现。否则不必出现。

不完整定义的对象类型可以变完整：

* 类类型（例如 {{c/core|class X}}）可在翻译单元中的某处视为不完整类型而在之后补充完整；类型 {{c/core|class X}} 在这两处是相同的类型：
{{source|1=
class X;             // X 的声明，尚未提供定义
extern X* xp;        // xp 是指向不完整类型的指针：X 的定义不可及

void foo()
{
    xp++;            // 非良构：X 不完整
}

struct X { int i; }; // X 的定义
X x;                 // OK：X 的定义可及

void bar()
{
    xp = &amp;x;         // OK：类型是“指向 X 的指针”
    xp++;            // OK：X 完整
}
}}

* 数组对象的声明类型可以是不完整类类型的数组，它因此也不完整；如果类类型在翻译单元中的后面完整，那么该数组类型也变得完整；两处的数组类型相同。
* 数组对象的声明类型可以是未知边界数组，因此它在翻译单元的一处不完整，并在之后变完整；两处的数组类型（“含有 {{tt|T}} 的未知边界数组”与“含有 {{c|N}} 个 {{tt|T}} 的元素数组”）不同。

到未知边界数组的指针类型或引用类型始终会指向或指代不完整类型。由 {{rlpt|typedef}} 声明命名的未知边界数组始终会表示不完整类型。两种情况下该数组类型均无法补充完整：
{{source|1=
extern int arr[];   // arr 的类型不完整
typedef int UNKA[]; // UNKA 是不完整类型

UNKA* arrp;         // arrp 是指向不完整类型的指针
UNKA** arrpp;

void foo()
{
    arrp++;         // 错误：UNKA 是不完整类型
    arrpp++;        // OK：UNKA* 的大小已知
}

int arr[10];        // 现在 arr 的类型完整了

void bar()
{
    arrp = &amp;arr;    // 错误：类型不同
    arrp++;         // 错误：UNKA 无法补充完整
}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=328|std=C++98|before=类可以有不完整类类型的成员|after=非静态类类型数据成员需要完整}}
{{dr list item|wg=cwg|dr=977|std=C++98|before=不明确枚举类型在它的定义的什么地方变得完整|after=在确定底层类型时完整}}
{{dr list item|wg=cwg|dr=1352|std=C++98|before=到 {{tt|T*}} 或 {{tt|T&amp;}} 类型的用户定义转换需要 {{tt|T}} 是完整类型|after=不再需要}}
{{dr list item|wg=cwg|dr=2006|std=C++98|before=有 cv 限定的 {{c/core|void}} 类型是对象类型和完整类型|after=都不属于这两种类型}}
{{dr list item|wg=cwg|dr=2448|std=C++98|before=只有无 cv 限定的类型可以是整数和浮点数类型|after=也允许有 cv 限定的类型}}
{{dr list item|wg=cwg|dr=2630|std=C++98|before=不明确类在自身的定义出现的翻译单元外是否会被视为完整类型|after=此时该类的定义可及的情况下视为完整类型}}
{{dr list item|wg=cwg|dr=2643|std=C++98|before=指向未知边界数组的指针类型无法补充完整（但它已经是完整类型）|after=被指向的数组类型无法补充完整}}
{{dr list item|wg=lwg|dr=2139|std=C++98|before=“由用户定义的类型”的含义不明确|after=定义并改用“由程序定义的类型”}}
{{dr list item|wg=lwg|dr=3119|std=C++11|before=不明确闭包类型是不是由程序定义的类型|after=使之明确}}
{{dr list end}}

===引用===
{{ref std c++23}}
{{ref std|section=6.8.2|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=6.8.2|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=6.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=3.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=3.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=3.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}

===参阅===
{{dsc begin}}
{{dsc|'''{{ls|cpp/meta#类型特征}}'''|一种编译时查询类型属性的基于模板的接口}}
{{dsc see c|c/language/type|类型|nomono=true}}
{{dsc end}}

===外部链接===
{{elink begin}}
{{elink|[https://howardhinnant.github.io/TypeHiearchy.pdf Howard Hinnant's C++0x type tree]}}
{{elink end}}

{{langlinks|en|es|ja|ru}}