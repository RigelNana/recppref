{{title|{{tt|typedef}} 说明符}}
{{cpp/language/declarations/navbar}}

:* {{ttb|typedef}} - 创建能在任何位置代替（可能复合的）类型名的别名。

===解释===
在{{rlp|declarations|声明}}中使用 {{c/core|typedef}} 说明符，指定该声明为 ''typedef 声明'' 而非变量或函数声明。

{{c/core|typedef}} 通常在声明的起始处出现，尽管它也可以出现在{{rlp|declarations#说明符|类型说明符}}后或两个类型说明符之间。{{c/core|typedef}} 说明符不能与{{rlp|declarations#说明符|类型说明符}}以外的其他说明符组合。

typedef 声明可以在同一行声明一个或多个标识符（例如 {{c/core|int}} 和指向 {{c/core|int}} 的指针），它可以声明数组和函数类型、指针和引用、类类型等。此声明中引入的每个标识符都成为 ''typedef 名''，它是在假如关键词 {{c/core|typedef}} 被移除时标识符本应成为的对象或函数的类型的同义词。

typedef 名是既存类型的别名，而不是对新类型的声明。{{c/core|typedef}} 不能用于更改既存类型名（包括 typedef 名）的含义。一旦声明，则 typedef 名只能重声明为再次指代同一类型。typedef 名只会在它自身可见的作用域有效：可以在不同的函数或类声明中定义具有不同含义的同名类型。

{{c/core|typedef}} 说明符不能在函数形参声明中出现，也不能在{{rlps|function#函数定义}}中的{{spar sep|声明说明符序列}}中出现：
{{source|code=
void f1(typedef int param); // 非良构
typedef int f2() {}         // 非良构
}}

{{c/core|typedef}} 说明符不能在不含声明符的声明中出现：
{{source|code=
typedef struct X {}; // 非良构
}}

===以链接为目的的 typedef 名===
如果 typedef 声明定义了一个无名{{rlp|classes|类}}或{{rlp|enum|枚举}}，那么该声明声明的首个作为该类类型或枚举类型的 typedef 名是该类型的''以链接为目的的 typedef 名''。

例如在 {{c|typedef struct { /* ... */ } S;}} 中，{{tt|S}} 是以链接为目的的 typedef 名。以此方式定义的类或枚举名拥有{{rlp|storage duration#链接|外部链接}}（除非它在无名命名空间中）。

{{rrev|since=c++20|
以此方式定义的无名类应当仅含与 C 兼容的构造。具体而言，它必须不

* 声明除了非静态数据成员、成员枚举或成员类以外的任何成员，
* 拥有任何{{rlp|derived class|基类}}或{{rlp|data members#成员初始化|默认成员初始化式}}，或
* 含有 {{rlp|lambda|lambda 表达式}}，

而所有成员类也必须（递归地）满足这些要求。
}}

===注解===
{{rrev|since=c++11|
{{rlp|type alias|类型别名}}通过不同的语法提供与 typedef 声明相同的功能，而且也可以用于模板名。
}}

===关键词===
{{ltt|cpp/keyword/typedef}}

===示例===
{{source|code=
// 简单 typedef
typedef unsigned long ulong;

// 下面两个对象拥有同一类型
unsigned long l1;
ulong l2;

// 更复杂的 typedef
typedef int int_t, *intp_t, (&amp;fp)(int, ulong), arr_t[10];

// 下面两个对象拥有同一类型
int a1[10];
arr_t a2;

// 当心：下面两个对象拥有不同类型
const intp_t p1 = 0; // int *const p1 = 0
const int *p2;

// 避免必须写 "struct S" 的常见 C 手法
typedef struct {int a; int b;} S, *pS;

// 下面两个对象拥有相同类型
pS ps1;
S* ps2;
 
// 错误：存储类说明符不能在 typedef 声明中出现
// typedef static unsigned int uint;

// typedef 可以在声明说明符序列中的任何位置中使用
long unsigned typedef int long ullong;
// 写作 "typedef unsigned long long int ullong;" 更符合惯例

// std::add_const，与许多其他元函数相似，使用了成员 typedef
template&lt;class T&gt;
struct add_const
{
    typedef const T type;
};

typedef struct Node
{
    struct listNode* next; // 声明名为 listNode 的新的（不完整）结构体类型
} listNode; // 错误：与先前声明的结构体名冲突

// C++20 错误: “带有链接目的的 typedef 名的结构体”有成员函数
typedef struct { void f() {} } C_Incompatible;
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=576|std=C++98|before=不能在函数定义中的任何地方使用 {{c/core|typedef}}|after=可以在函数体中使用}}
{{dr list item|wg=cwg|dr=2071|std=C++98|before={{c/core|typedef}} 可以在不含声明符的声明中出现|after=不能出现}}
{{dr list end}}

===参阅===
* {{rlp|type alias|类型别名}}
* {{rlp|type alias|别名模板}}
{{dsc begin}}
{{dsc see c|c/language/typedef|typedef 声明}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}