{{title|名字查找}}
{{cpp/language/basics/navbar}}
名字查找，是当程序中出现一个{{rlp|name|名字}}时，将其与引入它的{{rlp|declarations|声明}}联系起来的过程。

例如，为编译 {{c|std::cout &lt;&lt; std::endl;}}，编译器进行了：
* 名字 {{tt|std}} 的无限定的名字查找，找到了头文件 {{tt|&lt;iostream&gt;}} 中的命名空间 std 的声明
* 名字 {{tt|cout}} 的有限定的名字查找，找到了命名空间 {{tt|std}} 中的一个变量声明
* 名字 {{tt|endl}} 的有限定的名字查找，找到了命名空间 {{tt|std}} 中的一个函数模板声明
* 名字 {{tt|operator &lt;&lt;}} 的{{rlp|adl|实参依赖查找}}，找到了命名空间 {{tt|std}} 中的多个函数模板声明；和名字 {{tt|std::ostream::operator&lt;&lt;}} 的有限定名字查找，找到了 {{tt|std::ostream}} 类中的多个成员函数声明

对于函数和函数模板的名字，名字查找可以将同一个名字和多个声明联系起来，而且可能从{{rlp|adl|实参依赖查找}}中得到额外的声明。还会进行{{rlp|function template|模板实参推导}}，并将声明的集合交给{{rlp|overload resolution|重载决议}}，由它选择所要使用的那个声明。{{rlp|access|成员访问}}的规则只会在名字查找和重载解析之后才被考虑，如果适用的话。

对于其他所有名字（变量，命名空间，类等等）的，名字查找如果将同一个名字和多个声明联系起来就需要它们都声明同一个{{rlp|basic concepts|实体}}，否则程序只有在只产生单个声明的情况下才能编译。对某个作用域中的名字进行查找将寻找到该名字的所有声明，但有一种例外，被称作 “struct hack” 或“类型/非类型名字隐藏”：同一作用域中，某个名字的一些出现可以代表非 {{c/core|typedef}} 的 class/struct/union/enum 声明，而其他出现要么全都代表同一个变量、非静态数据成员或者枚举项，要么全都代表可能重载的函数或函数模板名。此情况下无错误，但类型名在查找中被隐藏（代码必须用{{rlp|elaborated type specifier|详述类型说明符}}来访问它）。

===查找的类型===
如果名字紧跟在作用域解析运算符 {{ttb|::}}，或可能跟在 {{ttb|::}} 之后的消歧义关键词 {{tt|template}} 的右侧，参见
* {{rlp|qualified lookup|有限定的名字查找}}

否则，请参见
* {{rlp|unqualified lookup|无限定的名字查找}}
:* （其中对于函数名，还包括{{rlp|adl|实参依赖查找}}）

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=2063|std=C++98|before=“struct hack” 无法应用于类作用域（破坏了与 C 的兼容性）|after=可以应用}}
{{dr list item|wg=cwg|dr=2218|std=C++98|before=对函数（模板）以外的名字的查找不能与多个声明关联，即使它们都声明同一个实体|after=此时可以关联}}
{{dr list end}}

===参阅===
* {{rlp|scope|作用域}} 
* {{rlp|adl|实参依赖查找}} (ADL)
* {{rlp|function template|模板实参推导}}
* {{rlp|overload resolution|重载决议}}
{{dsc begin}}
{{dsc see c|c/language/name space|名字查找与命名空间}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}