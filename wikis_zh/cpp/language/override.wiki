{{title|{{tt|override}} 说明符 {{mark since c++11}}}}
{{cpp/language/classes/navbar}}

指定一个{{rlp|virtual|虚函数}}覆盖另一个虚函数。

===语法===
如果使用标识符 {{tt|override}}，那么它紧随成员函数声明或类定义内的成员函数定义语法中的{{rlp|function|声明符}}之后出现。

{{sdsc begin}}
{{sdsc|num=1|{{spar|声明符}} {{spar optional|虚说明符序列}} {{spar optional|纯说明符}}}}
{{sdsc|num=2|{{spar|声明符}} {{spar optional|虚说明符序列}} {{spar|函数体}}}}
{{sdsc end}}
@1@ 在成员函数声明中，{{tt|override}} 可以在紧随声明符之后并在{{rlp|abstract_class|{{spar sep|纯说明符}}}}之前（如有使用）的{{spar sep|虚说明符序列}}中出现。
@2@ 在类定义内成员函数定义中，{{tt|override}} 可以在紧随声明符之后并紧接{{spar sep|函数体}}之前的{{spar sep|虚说明符序列}}中出现。

两种情况中，如果使用{{spar|虚说明符序列}}，那么它必须是 {{tt|override}}、{{rlpt|final}}、{{c/core|final override}} 或 {{c/core|override final}} 之一。

===解释===
在成员函数的声明或定义中，{{c/core|override}} 说明符确保该函数为虚函数并覆盖某个基类中的虚函数。如果不是这样，那么程序非良构。

{{tt|override}} 是在成员函数声明符之后使用时''拥有特殊含义的标识符''；其他情况下它不是保留的{{lt|cpp/keyword|关键词}}。

===关键词===
{{ltt|cpp/identifier_with_special_meaning/override}}

===示例===
{{example
|code=
#include &lt;iostream&gt;

struct A
{
    virtual void foo();
    void bar();
    virtual ~A();
};

// struct A 的成员函数定义：
void A::foo() { std::cout &lt;&lt; "A::foo();\n"; }
A::~A() { std::cout &lt;&lt; "A::~A();\n"; }

struct B : A
{
//  void foo() const override; // 错误：B::foo 并不覆盖 A::foo
                               // （签名不匹配）
    void foo() override; // OK: B::foo 覆盖 A::foo
//  void bar() override; // 错误：A::bar 不是虚函数
    ~B() override; // OK: `override` 也能用于如析构函数这样的虚特殊成员函数
    void override(); // OK，成员函数名，并非保留关键词
};

// struct B 的成员函数定义：
void B::foo() { std::cout &lt;&lt; "B::foo();\n"; }
B::~B() { std::cout &lt;&lt; "B::~B();\n"; }
void B::override() { std::cout &lt;&lt; "B::override();\n"; }

int main()
{
    B b;
    b.foo();
    b.override(); // OK，调用成员函数 `override()`
    int override{42}; // OK，定义整数变量
    std::cout &lt;&lt; "override: " &lt;&lt; override &lt;&lt; '\n';
}
|output=
B::foo();
B::override();
override: 42
B::~B();
A::~A();
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/language/dsc final}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}