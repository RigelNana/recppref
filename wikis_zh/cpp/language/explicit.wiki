{{title|{{tt|explicit}} 说明符}}
{{cpp/language/classes/navbar}}

===语法===
{{sdsc begin}}
{{sdsc|num=1|
{{ttb|explicit}}
}}
{{sdsc|num=2|notes={{mark since c++20}}|
{{ttb|explicit (}} {{spar|表达式}} {{ttb|)}}
}}
{{sdsc end}}
{{par begin}}
{{par|{{spar|表达式}}|{{rlp|constant expression#经转换的常量表达式|经按语境转换为 {{c/core|bool}} 类型的常量表达式}}}}
{{par end}}


@1@ 指定构造函数{{rev inl|since=c++11|或转换函数}}{{rev inl|since=c++17|或{{rlp|class template argument deduction|推导指引}}}}为显式，即它不能用于{{rlp|implicit conversion|隐式转换}}和{{rlp|copy initialization|复制初始化}}。

{{rrev|since=c++20|
@2@ {{c/core|explicit}} 说明符可以与常量表达式一同使用。当且仅当该常量表达式求值为 {{c|true}} 时，函数是显式的。
}}

explicit 说明符只能在类定义之内的构造函数{{rev inl|since=c++11|或转换函数}}的{{spar sep|声明说明符序列}}中出现。

===注解===
声明时不带函数说明符 {{c/core|explicit}} 的{{rev inl|until=c++11|拥有单个无默认值形参的}}构造函数被称作{{rlp|converting constructor|转换构造函数}}。

构造函数（除了{{rlp|copy constructor|复制}}或{{rlp|move constructor|移动}}）和用户定义转换函数都可以是函数模板；{{c/core|explicit}} 的含义不变。

{{rrev|since=c++20|1=
跟随 {{c/core|explicit}} 的 {{ttb|(}} 记号始终会被解析成 explicit 说明符的一部分：
{{source|1=
struct S
{
    explicit (S)(const S&amp;);    // C++20 中错误，C++17 中 OK
    explicit (operator int)(); // C++20 中错误，C++17 中 OK
};
}}
}}
{{feature test macro|value=201806L|std=C++20|__cpp_conditional_explicit|条件性 {{c/core|explicit}}}}

===关键词===
{{ltt|cpp/keyword/explicit}}

===示例===
{{example|code=
struct A
{
    A(int) {}      // 转换构造函数
    A(int, int) {} // 转换构造函数（C++11）
    operator bool() const { return true; }
};

struct B
{
    explicit B(int) {}
    explicit B(int, int) {}
    explicit operator bool() const { return true; }
};

int main()
{
    A a1 = 1;      // OK：复制初始化选择 A::A(int)
    A a2(2);       // OK：直接初始化选择 A::A(int)
    A a3 {4, 5};   // OK：直接列表初始化选择 A::A(int, int)
    A a4 = {4, 5}; // OK：复制列表初始化选择 A::A(int, int)
    A a5 = (A)1;   // OK：显式转型进行 static_cast
    if (a1) { }    // OK：A::operator bool()
    bool na1 = a1; // OK：复制初始化选择 A::operator bool()
    bool na2 = static_cast&lt;bool&gt;(a1); // OK：static_cast 进行直接初始化
    
//  B b1 = 1;      // 错误：复制初始化不考虑 B::B(int)
    B b2(2);       // OK：直接初始化选择 B::B(int)
    B b3 {4, 5};   // OK：直接列表初始化选择 B::B(int, int)
//  B b4 = {4, 5}; // 错误：复制列表初始化不考虑 B::B(int,int)
    B b5 = (B)1;   // OK：显式转型进行 static_cast
    if (b2) { }    // OK：B::operator bool()
//  bool nb1 = b2; // 错误：复制初始化不考虑 B::operator bool()
    bool nb2 = static_cast&lt;bool&gt;(b2); // OK：static_cast 进行直接初始化
    
    [](...){}(a4, a5, na1, na2, b5, nb2); // 消除“未使用变量”警告
}
}}

===参阅===
* {{rlp|converting constructor|转换构造函数}}
* {{rlp|initialization|初始化}}
* {{rlp|copy initialization|复制初始化}}
* {{rlp|direct initialization|直接初始化}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}