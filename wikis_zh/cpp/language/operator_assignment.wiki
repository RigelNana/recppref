{{title|赋值运算符}}
{{cpp/language/expressions/navbar}}
赋值运算符修改对象的值。

{| class="wikitable" style="font-size:85%;"
|-
! rowspan="2" | 运算符名
! rowspan="2" | 语法
! rowspan="2" | {{rlp|operators|可重载}}
! colspan="2" | 原型示例（对于 {{c/core|class T}}）
|-
! 类内定义
! 类外定义
|-
| 简单赋值
| {{tt|1=a = b}} 
| {{yes}}
| {{c|1=T&amp; T::operator =(const T2&amp; b);}} 
| {{n/a}}
|-
| 加法赋值
| {{tt|1=a += b}}
| {{yes}}
| {{c|1=T&amp; T::operator +=(const T2&amp; b);}}
| {{c|1=T&amp; operator +=(T&amp; a, const T2&amp; b);}}
|-
| 减法赋值
| {{tt|1=a -= b}}
| {{yes}}
| {{c|1=T&amp; T::operator -=(const T2&amp; b);}}
| {{c|1=T&amp; operator -=(T&amp; a, const T2&amp; b);}}
|-
| 乘法赋值
| {{tt|1=a *= b}}
| {{yes}}
| {{c|1=T&amp; T::operator *=(const T2&amp; b);}}
| {{c|1=T&amp; operator *=(T&amp; a, const T2&amp; b);}}
|-
| 除法赋值
| {{tt|1=a /= b}}
| {{yes}}
| {{c|1=T&amp; T::operator /=(const T2&amp; b);}}
| {{c|1=T&amp; operator /=(T&amp; a, const T2&amp; b);}}
|-
| 取模赋值
| {{tt|1=a %= b}}
| {{yes}}
| {{c|1=T&amp; T::operator %=(const T2&amp; b);}}
| {{c|1=T&amp; operator %=(T&amp; a, const T2&amp; b);}}
|-
| 逐位与赋值
| {{tt|1=a &amp;= b}}
| {{yes}}
| {{c|1=T&amp; T::operator &amp;=(const T2&amp; b);}}
| {{c|1=T&amp; operator &amp;=(T&amp; a, const T2&amp; b);}}
|-
| 逐位或赋值
| {{tt|1=a &amp;#124;= b}}
| {{yes}}
| {{c|1=T&amp; T::operator {{!}}=(const T2&amp; b);}}
| {{c|1=T&amp; operator {{!}}=(T&amp; a, const T2&amp; b);}}
|-
| 逐位异或赋值
| {{tt|1=a ^= b}}
| {{yes}}
| {{c|1=T&amp; T::operator ^=(const T2&amp; b);}}
| {{c|1=T&amp; operator ^=(T&amp; a, const T2&amp; b);}}
|-
| 逐位左移赋值
| {{tt|1=a &lt;&lt;= b}}
| {{yes}}
| {{c|1=T&amp; T::operator &lt;&lt;=(const T2&amp; b);}}
| {{c|1=T&amp; operator &lt;&lt;=(T&amp; a, const T2&amp; b);}}
|-
| 逐位右移赋值
| {{tt|1=a &gt;&gt;= b}}
| {{yes}}
| {{c|1=T&amp; T::operator &gt;&gt;=(const T2&amp; b);}}
| {{c|1=T&amp; operator &gt;&gt;=(T&amp; a, const T2&amp; b);}}
|-
| colspan="5" |
:'''注意'''&lt;br&gt;
* 所有内建赋值运算符都返回 {{c|*this}}，而大多数{{rlp|operators|用户定义重载}}也会返回 {{c|*this}}，从而能以与内建版本相同的方式使用用户定义运算符。然而，用户定义运算符重载中，返回类型可以是任意类型（包括 {{c/core|void}}）。
* {{tt|T2}} 可以是包含 {{tt|T}} 在内的任何类型。
|}

===定义===
''复制赋值''{{sep}}以 {{c|b}} 内容的副本替换对象 {{c|a}} 的内容（不修改 {{c|b}}）。对于类类型，这会在一种特殊成员函数中进行，描述见{{rlp|copy assignment|复制赋值运算符}}。

{{rrev|since=c++11|
''移动赋值''{{sep}}以 {{c|b}} 的内容替换对象 {{c|a}} 的内容，并尽可能避免复制（可以修改 {{c|b}}）。对于类类型，这会在一种特殊成员函数中进行，描述见{{rlp|move assignment|移动赋值运算符}}。
}}

对于非类类型，对复制与移动赋值不加以区分，它们都被称作''直接赋值''。

''复合赋值''{{sep}}以 {{c|a}} 的值和 {{c|b}} 的值间的二元运算结果替换对象 {{c|a}} 的内容。

====赋值运算符语法====
赋值表达式的形式为

{{sdsc begin}}
{{sdsc|num=1|{{spar|目标表达式}} {{ttb|1==}} {{spar|新值}}}}
{{sdsc|num=2|{{spar|目标表达式 运算符 新值}}}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|目标表达式}}|要被赋值的表达式&lt;ref&gt;{{spar sep|目标表达式}}的{{rlp|operator precedence|优先级}}必须高于赋值表达式的优先级。&lt;/ref&gt;}}
{{par|{{spar|运算符}}|{{c|*{{=}}}}、{{c|/{{=}}}}、{{c|%{{=}}}}、{{c|+{{=}}}}、{{c|-{{=}}}}、{{c|&lt;&lt;{{=}}}}、{{c|&gt;&gt;{{=}}}}、{{c|&amp;{{=}}}}、{{c|^{{=}}}}、{{c|1={{!}}=}} 之一}}
{{par|{{spar|新值}}|要赋值给目标的{{rev inl|until=c++11|表达式&lt;ref&gt;{{spar sep|新值}}不能是逗号表达式，因为它的{{rlp|operator precedence|优先级}}更低。&lt;/ref&gt;}}{{rev inl|since=c++11|{{rlp|initialization#初始化器|初始化器子句}}}}}}
{{par end}}
&lt;references/&gt;

@1@ 简单赋值表达式
@2@ 复合赋值表达式

{{rrev|since=c++11|如果{{spar sep|新值}}不是表达式，那么赋值表达式不会匹配重载的复合赋值运算符。}}

===内建的简单赋值运算符===
对于内建的简单赋值，{{spar sep|目标表达式}}必须是可修改的左值。

{{spar sep|目标表达式}}指代的对象会通过以{{spar sep|新值}}的结果进行覆盖而被修改。如果指代的对象具有整数类型 {{tt|T}}，并且{{spar sep|新值}}的结果具有对应的有符号/无符号整数类型，那么该对象的值会被替换成 {{tt|T}} 类型的与{{spar sep|新值}}的结果的值表示相同的值。

内建的简单赋值是类型与{{spar sep|目标表达式}}相同，并且指代{{spar sep|目标表达式}}的左值。如果{{spar sep|目标表达式}}是{{rlp|bit field|位域}}，那么结果也是位域。

====从表达式赋值====
如果{{spar sep|新值}}是表达式，那么它会{{rlp|implicit conversion|隐式转换}}到{{spar sep|目标表达式}}具有的类型的无 cv 限定版本。在{{spar sep|目标表达式}}位域无法表示该表达式的值的情况下，位域结果值由实现定义。

如果左右操作数标识的对象之间有重叠，那么行为未定义（除非二者严格重叠且类型相同）。

{{rrev|since=c++20|
如果{{spar sep|目标表达式}}的类型具有 volatile 限定，那么该赋值被弃用，除非该（可被圆括号包围的）赋值表达式是{{rlps|expressions#弃值表达式}}或{{rlp|expressions#潜在求值表达式|不求值操作数}}。
}}


{{rrev|since=c++11|
====从非表达式初始化器子句赋值====
只有在以下情况下，{{spar sep|新值}}才可以不是表达式：
* {{spar sep|目标表达式}}具有[[cpp/named req/ScalarType|标量类型]] {{tt|T}}，并且{{spar sep|新值}}为空或者只有一个元素。此时给定以 {{box|{{c/core|1=T t =}}{{nbspt}}{{spar sep|新值}}}} 声明和初始化的虚设变量 {{c|t}}，那么 {{box|{{c/core|1=x =}}{{nbspt}}{{spar sep|新值}}}} 等价于 {{c|1=x = t}}。
* {{spar sep|目标表达式}}具有类类型。此时{{spar sep|新值}}会作为实参传递给{{rlp|overload resolution|重载决议}}选择的赋值运算符函数。

{{source|1=
#include &lt;complex&gt;

std::complex&lt;double&gt; z;
z = {1, 2};  // 表示 z.operator=({1, 2})
z += {1, 2}; // 表示 z.operator+=({1, 2})

int a, b;
a = b = {1}; // 表示 a = b = 1;
a = {1} = b; // 语法错误
}}
}}

{{rlp|overload resolution#调用重载运算符|针对用户定义运算符的重载决议}}中，对于每个类型 {{tt|T}}，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|T*&amp; operator{{=}}(T*&amp;, T*);}}
{{dcl|T*volatile &amp; operator{{=}}(T*volatile &amp;, T*);}}
{{dcl end}}

对于每个枚举或成员指针类型 {{tt|T}}（可有 volatile 限定），下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|T&amp; operator{{=}}(T&amp;, T );}}
{{dcl end}}

对于每对 {{tt|A1}} 和 {{tt|A2}}，其中 {{tt|A1}} 是算术类型（可有 volatile 限定）而 {{tt|A2}} 是提升后的算术类型，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|A1&amp; operator{{=}}(A1&amp;, A2);}}
{{dcl end}}

====内建的复合赋值运算符====
每个内建复合赋值运算符表达式 {{box|{{spar|目标表达式}}{{nbspt}}''运算符''{{sep}}{{c/core|1==}}{{nbspt}}{{spar|新值}}}} 的行为和表达式 {{box|{{spar|目标表达式}}{{nbspt}}{{c/core|1==}}{{nbspt}}{{spar|目标表达式}}{{nbspt}}''运算符''{{nbspt}}{{spar|新值}}}} 完全一致，除了{{spar sep|目标表达式}}只会求值一次。

内建的简单赋值运算符对{{spar sep|目标表达式}}和{{spar sep|新值}}的要求依然使用。另外：
* 对于 {{c|1=+=}} 和 {{c|1=-=}}，{{spar sep|目标表达式}}的类型必须是{{rlp|type|算术类型}}或指向（可有 cv 限定的）完整定义的{{rlp|type|对象类型}}的指针。
* 对于所有其他复合赋值运算符，{{spar sep|目标表达式}}的类型必须是算术类型。

在{{rlp|overload resolution#调用重载运算符|针对用户定义运算符的重载决议}}中，对每对 {{tt|A1}} 和 {{tt|A2}}，其中 {{tt|A1}} 是算术类型（可有 volatile 限定）而 {{tt|A2}} 是提升后的算术类型，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|A1&amp; operator*{{=}}(A1&amp;, A2);}}
{{dcl|A1&amp; operator/{{=}}(A1&amp;, A2);}}
{{dcl|A1&amp; operator+{{=}}(A1&amp;, A2);}}
{{dcl|A1&amp; operator-{{=}}(A1&amp;, A2);}}
{{dcl end}}

对于每对 {{tt|I1}} 与 {{tt|I2}}，其中 {{tt|I1}} 是整型类型（可有 volatile 限定）而 {{tt|I2}} 是提升后的整型类型，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|I1&amp; operator%{{=}}(I1&amp;, I2);}}
{{dcl|I1&amp; operator&lt;&lt;{{=}}(I1&amp;, I2);}}
{{dcl|I1&amp; operator&gt;&gt;{{=}}(I1&amp;, I2);}}
{{dcl|I1&amp; operator&amp;{{=}}(I1&amp;, I2);}}
{{dcl|I1&amp; operator^{{=}}(I1&amp;, I2);}}
{{dcl|I1&amp; operator{{!}}{{=}}(I1&amp;, I2);}}
{{dcl end}}

对于每个可有 cv 限定的对象类型 {{tt|T}}，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|T*&amp; operator+{{=}}(T*&amp;, std::ptrdiff_t);}}
{{dcl|T*&amp; operator-{{=}}(T*&amp;, std::ptrdiff_t);}}
{{dcl|T*volatile &amp; operator+{{=}}(T*volatile &amp;, std::ptrdiff_t);}}
{{dcl|T*volatile &amp; operator-{{=}}(T*volatile &amp;, std::ptrdiff_t);}}
{{dcl end}}

===示例===
{{example
|code=
#include &lt;iostream&gt;

int main()
{
    int n = 0;        // 不是赋值
    
    n = 1;            // 直接赋值
    std::cout &lt;&lt; n &lt;&lt; ' ';
    
    n = {};           // 零初始化，然后赋值
    std::cout &lt;&lt; n &lt;&lt; ' ';
    
    n = 'a';          // 整型提升，然后赋值
    std::cout &lt;&lt; n &lt;&lt; ' ';
    
    n = {'b'};        // 显式转型，然后赋值
    std::cout &lt;&lt; n &lt;&lt; ' ';
    
    n = 1.0;          // 浮点数转换，然后赋值
    std::cout &lt;&lt; n &lt;&lt; ' ';
    
//  n = {1.0};        // 编译错误（窄化转换）
    
    int&amp; r = n;       // 不是赋值
    r = 2;            // 通过引用赋值
    std::cout &lt;&lt; n &lt;&lt; ' ';
    
    int* p;
    p = &amp;n;           // 直接赋值
    p = nullptr;      // 空指针转换，然后赋值
    std::cout &lt;&lt; p &lt;&lt; ' ';
    
    struct { int a; std::string s; } obj;
    obj = {1, "abc"}; // 从花括号初始化器列表赋值
    std::cout &lt;&lt; obj.a &lt;&lt; ':' &lt;&lt; obj.s &lt;&lt; '\n';
}
|p=true
|output=
1 0 97 98 1 2 (nil) 1:abc
}}

===缺陷报告===
{{dr list begin}}
&lt;!-- CWG 324 的解决方案改变了有位域操作数的操作的语义，它记载在“位域”页面 --&gt;
{{dr list item|wg=cwg|dr=1527|std=C++11|before=只有在赋值由用户定义的赋值运算符定义的情况下才能将初始化列表赋给类类型对象|after=移除用户定义赋值限制}}
{{dr list item|wg=cwg|dr=1538|std=C++11|before={{c|1==E1 = {E2}&lt;!-- --&gt;}} 曾与 {{c|1==E1 = T(E2)}}（{{tt|T}} 是 {{tt|E1}} 的类型）等价，这会引入 C 风格转型|after=现在与 {{c|1=E1 = T{E2}&lt;!-- --&gt;}} 等价}}
{{dr list item|wg=cwg|dr=2654|std=C++20|before=volatile 类型的复合赋值运算符被以不一致的方式弃用|after=它们都不会被弃用}}
{{dr list item|wg=cwg|dr=2768|std=C++11|before=从非表达式初始化器子句对标量值进行赋值会进行直接列表初始化|after=改为进行复制列表初始化}}
{{dr list item|wg=cwg|dr=2901|std=C++98|before=通过 {{c/core|int}} 左值赋给 {{c/core|unsigned int}} 对象的值不明确|after=使之明确}}
{{dr list item|paper=P2327R1|std=C++20|before=volatile 类型的逐位复合赋值运算符对一些平台有用但被弃用|after=不弃用它们}}
{{dr list end}}

===参阅===
{{rlp|operator precedence|运算符优先级}}

{{rlp|operators|运算符重载}}

{{cpp/language/operators}}

{{dsc begin}}
{{dsc see c|c/language/operator assignment|赋值运算符|nomono=true}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}