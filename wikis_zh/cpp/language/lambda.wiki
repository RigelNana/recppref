{{title|lambda 表达式 {{mark since c++11}}}}
{{cpp/language/expressions/functions/navbar}}

构造{{enwiki|Closure (computer science)|闭包}}（能够捕获作用域中的变量的无名函数对象）。

===语法===
====没有显式模板形参的 lambda 表达式（可以不泛型）====
{{sdsc begin}}
{{sdsc|num=1|
{{ttb|[}}{{spar sep|捕获}}{{ttb|]}} {{spar optional|前属性}} {{ttb|(}}{{spar sep|形参列表}}{{ttb|)}} {{spar optional|说明符}} {{spar optional|异常}}&lt;br&gt;{{spar optional|后属性}} {{spar optional|尾随类型}} {{spar optional|约束}} {{spar optional|约定说明}} {{ttb|{}} {{spar|函数体}} {{ttb|}&lt;!----&gt;}}
}}
{{sdsc|num=2|notes={{mark until c++23}}|
{{ttb|[}}{{spar sep|捕获}}{{ttb|] {}} {{spar|函数体}} {{ttb|}&lt;!----&gt;}}
}}
{{sdsc|num=2|notes={{mark since c++23}}|
{{ttb|[}}{{spar sep|捕获}}{{ttb|]}} {{spar optional|前属性}} {{spar optional|尾随类型}} {{spar optional|约定说明}} {{ttb|{}} {{spar|函数体}} {{ttb|}&lt;!----&gt;}}
}}
{{sdsc|num=3|notes={{mark since c++23}}|
{{ttb|[}}{{spar sep|捕获}}{{ttb|]}} {{spar optional|前属性}} {{spar|异常}}&lt;br&gt;{{spar optional|后属性}} {{spar optional|尾随类型}} {{spar optional|约定说明}} {{ttb|{}} {{spar|函数体}} {{ttb|}&lt;!----&gt;}}
}}
{{sdsc|num=4|notes={{mark since c++23}}|
{{ttb|[}}{{spar sep|捕获}}{{ttb|]}} {{spar optional|前属性}} {{spar|说明符}} {{spar optional|异常}}&lt;br&gt;{{spar optional|后属性}} {{spar optional|尾随类型}} {{spar optional|约定说明}} {{ttb|{}} {{spar|函数体}} {{ttb|}&lt;!----&gt;}}
}}
{{sdsc end}}

====有显式模板形参的 lambda 表达式（必然泛型） {{mark since c++20}}====
{{sdsc begin}}
{{sdsc|num=1|
{{ttb|[}}{{spar sep|捕获}}{{ttb|] &lt;}}{{spar sep|模板形参}}{{ttb|&gt;}} {{spar optional|模板约束}} {{spar optional|前属性}} {{ttb|(}}{{spar sep|形参列表}}{{ttb|)}} {{spar optional|说明符}}&lt;br&gt;{{spar optional|异常}} {{spar optional|后属性}} {{spar optional|尾随类型}} {{spar optional|约束}} {{spar optional|约定说明}} {{ttb|{}} {{spar|函数体}} {{ttb|}&lt;!----&gt;}}
}}
{{sdsc|num=2|notes={{mark until c++23}}|
{{ttb|[}}{{spar sep|捕获}}{{ttb|] &lt;}}{{spar sep|模板形参}}{{ttb|&gt;}} {{spar optional|模板约束}} {{ttb|{}} {{spar|函数体}} {{ttb|}&lt;!----&gt;}}
}}
{{sdsc|num=2|notes={{mark since c++23}}|
{{ttb|[}}{{spar sep|捕获}}{{ttb|] &lt;}}{{spar sep|模板形参}}{{ttb|&gt;}} {{spar optional|模板约束}}&lt;br&gt;{{spar optional|前属性}} {{spar optional|尾随类型}} {{spar optional|约定说明}} {{ttb|{}} {{spar|函数体}} {{ttb|}&lt;!----&gt;}}
}}
{{sdsc|num=3|notes={{mark since c++23}}|
{{ttb|[}}{{spar sep|捕获}}{{ttb|] &lt;}}{{spar sep|模板形参}}{{ttb|&gt;}} {{spar optional|模板约束}} {{spar optional|前属性}} {{spar|异常}}&lt;br&gt;{{spar optional|后属性}} {{spar optional|尾随类型}} {{spar optional|约定说明}} {{ttb|{}} {{spar|函数体}} {{ttb|}&lt;!----&gt;}}
}}
{{sdsc|num=4|notes={{mark since c++23}}|
{{ttb|[}}{{spar sep|捕获}}{{ttb|] &lt;}}{{spar sep|模板形参}}{{ttb|&gt;}} {{spar optional|模板约束}} {{spar optional|前属性}} {{spar|说明符}} {{spar optional|异常}}&lt;br&gt;{{spar optional|后属性}} {{spar optional|尾随类型}} {{spar optional|约定说明}} {{ttb|{}} {{spar|函数体}} {{ttb|}&lt;!----&gt;}}
}}
{{sdsc end}}

@1@ 带形参列表的 lambda 表达式。

@2-4@ 不带形参列表的 lambda 表达式。
:@2@ 最简形式，无法应用{{spar|后属性}}。
:@3,4@ 只有在有出现{{spar sep|说明符}}或{{spar sep|异常}}的情况下才能应用{{spar|后属性}}。

===解释===
{{par begin}}
{{par|{{spar|捕获}}|指定要被[[#lambda 捕获|捕获]]的实体。}}
{{par|{{spar|模板形参}}|非空的{{rlp|template parameters|模板形参}}列表，用于为泛型 lambda 提供各模板形参的名字（见下文的 {{tt|闭包类型::operator()}}）。}}
{{par|{{spar|模板约束}}|向{{spar sep|模板形参}}添加{{rlp|constraints|约束。}}
{{rrev|since=c++23|
如果{{spar sep|模板约束}}以属性说明符序列结尾，那么该序列中的属性会被视为{{spar sep|前属性}}中的属性。
}}}}
{{par|{{spar|前属性}}|{{mark since c++23}} 适用于闭包类型的 {{c|operator()}} 的{{rlp|attributes|属性说明符序列}}（因此可以使用 {{attr|noreturn}} 属性）。}}
{{par|{{spar|形参列表}}|闭包类型的 {{c|operator()}} 的{{rlps|function#形参列表}}。
{{rrev|since=c++23|
它可以有一个{{rlp|function#形参列表|显式对象形参}}。
}}}}
{{par|{{spar|说明符}}|可包含以下说明符的序列，每个说明符在序列中最多允许出现一次。
{{cpp/language/lambda/specifiers}}}}
{{par|{{spar|异常}}|为闭包类型的 {{c|operator()}} 提供{{rev inl|until=c++20|{{rlp|except spec|动态异常说明}}或}} {{rlp|noexcept spec|noexcept 说明符}}。}}
{{par|{{spar|后属性}}|适用于闭包类型的 {{c|operator()}} 的类型的{{rlp|attributes|属性说明序列}}（因此不能使用 {{attr|noreturn}} 属性）。}}
{{par|{{spar|尾随类型}}|{{ttb|-&gt;}} {{spar|返回类型}}，其中{{spar sep|返回类型}}指定返回类型。}}
{{par|{{spar|约束}}|{{mark since c++20}} 向闭包类型的 {{c|operator()}} 添加{{rlp|constraints|约束}}。}}
{{par|{{spar|约定说明}}|{{mark since c++26}} 闭包类型的 {{c|operator()}} 的{{rlps|function#函数约定说明符列}}表。}}
{{par|{{spar|函数体}}|lambda 表达式的函数体。}}
{{par end}}


{{rrev|since=c++14|当以 {{rlpt|auto}} 为形参类型{{rev inl|since=c++20|或显式提供模板形参列表}}时，该 lambda 是''泛型 lambda''。}}

变量 {{c|__func__}} 在{{spar sep|函数体}}的开头隐式定义，它的语义可以参考{{rlp|function#func|这里}}。

===闭包类型===
lambda 表达式是纯右值表达式，它的类型是独有的无名非{{rlp|union|联合体}}非{{rlp|aggregate initialization|聚合体}}类类型，被称为''闭包类型''，它（对于{{rlp|adl|实参依赖查找}}而言）声明于含有该 lambda 表达式的最小块作用域、类作用域或命名空间作用域。

{{rrev|since=c++20|
当且仅当{{spar sep|捕获}}为空时，闭包类型是{{rlp|template parameters#模板非类型形参|结构化}}类型。
}}

闭包类型有下列成员，它们不能{{rev inl|since=c++14|被{{rlps|function template#显式实例化}}，被{{rlp|template specialization|显式特化}}，或}}在{{rlp|friend|友元声明}}中指名：

{{anchor|闭包类型函数调用运算符}}
{{member|{{small|闭包类型::}}operator()({{spar|形参}})|2=
{{dcl begin}}
{{dcl|notes={{mark|static 和 const 可能会出现，见下文}}|1=
返回类型 operator()(形参) { 函数体 }
}}
{{dcl|since=c++14|notes={{mark|泛型 lambda，static 和 const 可能会出现，见下文}}|1=
template&lt;模板形参&gt;
返回类型 operator()(形参) { 函数体 }
}}
{{dcl end}}

当被调用时，执行 lambda 表达式的函数体。当访问变量时，访问的是它被捕获的副本（对于按复制捕获的实体）或原对象（对于按引用捕获的实体）。

{{c|operator()}} 的形参列表在提供了{{spar sep|形参列表}}时是该形参列表，否则为空。

{{c|operator()}} 的返回类型是{{spar sep|尾随类型}}中指定的类型。

如果没有提供{{spar|尾随类型}}，那么 {{c|operator()}} 的返回类型会被自动{{rlp|function#返回类型推导|推导}}。&lt;ref&gt;尽管函数返回类型推导在 C++14 中引入，但是 C++11 中已经可以使用相应规则推导 lambda 返回类型。&lt;/ref&gt;

除非 lambda 的说明符中使用了关键词 {{c/core|mutable}}{{rev inl|since=c++23|，或者存在显式对象形参}}，否则 {{c|operator()}} 的 cv 限定符都会是 {{c/core|const}}，并且无法从这个 {{c|operator()}} 的内部修改按复制捕获的对象。{{c|operator()}} 始终非虚，并且不能包含 {{c/core|volatile}} 限定符。

{{rev begin}}
{{rev|since=c++17|
如果 {{c|operator()}} 满足针对 {{rlp|constexpr|constexpr 函数}}的要求，那么它始终是 constexpr 的。如果在 lambda 的说明符中使用了关键词 {{c/core|constexpr}}，那么它也是 constexpr 的。
}}
{{rev|since=c++20|
如果在 lambda 的说明符中使用了关键词 {{c/core|consteval}}，那么 {{c|operator()}} 是{{rlp|consteval|立即函数}}。
}}
{{rev|since=c++23|
如果在 lambda 的说明符中使用了关键词 {{c/core|static}}，那么 {{c|operator()}} 是{{rlps|static#静态成员函数}}。

如果{{spar sep|形参列表}}有一个显式对象形参，那么 {{c|operator()}} 是{{rlps|member functions#显式对象成员函数}}。
}}
{{rev end}}


{{rrev|since=c++14|
对于{{spar sep|形参}}中每个类型指定为 {{c/core|auto}} 的形参，以它们的出现顺序向{{spar sep|模板形参}}中添加一个虚设的模板形参。当虚设的模板形参所对应的{{spar sep|形参}}中的函数形参是函数形参包时，它可以是{{rlp|parameter pack|形参包}}。
&lt;source style="width:45em; overflow-x: hidden;" lang=cpp&gt;
// 泛型 lambda，operator() 是有两个形参的模板
auto glambda = [](auto a, auto&amp;&amp; b) { return a &lt; b; };
bool b = glambda(3, 3.14); // ok

// 泛型 lambda，operator() 是有一个形参的模板
auto vglambda = [](auto printer)
{
    return [=](auto&amp;&amp;... ts) // 泛型 lambda，ts 是形参包
    { 
        printer(std::forward&lt;decltype(ts)&gt;(ts)...);
        // 零元 lambda （不接受形参）
        return [=] { printer(ts...); };
    };
};

auto p = vglambda([](auto v1, auto v2, auto v3)
{
    std::cout &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; v3;
});

auto q = p(1, 'a', 3.14); // 输出 1a3.14
q();                      // 输出 1a3.14
&lt;/source&gt;
}}


{{rrev|since=c++20|
如果 lambda 定义使用了显式的模板形参列表，该列表会用于 {{c|operator()}}。对于{{spar sep|形参}}中的每个类型指定为 {{c/core|auto}} 的形参，都会向模板形参列表追加一个虚设的模板形参：
&lt;source style="width:45em" lang=cpp&gt;
// 泛型 lambda，operator() 是一个拥有两个（模板）形参的模板
auto glambda = []&lt;class T&gt;(T a, auto&amp;&amp; b) { return a &lt; b; };
 
// 泛型 lambda，operator() 是一个拥有一个形参包的模板
auto f = []&lt;typename... Ts&gt;(Ts&amp;&amp;... ts)
{
    return foo(std::forward&lt;Ts&gt;(ts)...);
};
&lt;/source&gt;
}}

lambda 表达式上的异常说明{{spar sep|异常}}应用于 {{c|operator()}}。

对于{{rlp|lookup|名字查找}}、确定 {{rlp|this|{{c|this}} 指针}}的类型和值以及对于访问非静态类成员而言，闭包类型的函数调用运算符的函数体被认为处于 lambda 表达式的语境中。

{{source|1=
struct X
{
    int x, y;
    int operator()(int);
    void f()
    {
        // 下列 lambda 的语境是成员函数 X::f
        [=]() -&gt; int
        {
            return operator()(this-&gt;x + y); // X::operator()(this-&gt;x + (*this).y)
                                            // this 拥有类型 X*
        };
    }
};
}}

===悬垂引用===
如果按引用隐式或显式捕获非引用实体，而在该实体的生存期结束之后调用闭包对象的 {{c|operator()}}，那么会发生未定义行为。C++ 的闭包并不延长按引用捕获的对象的生存期。

这同样适用于通过 {{ttb|this}} 捕获的当前 {{c|*this}} 对象的生存期。
}}
&lt;references/&gt;

{{member|{{small|闭包类型::}}operator {{spar|返回类型}}(*)({{spar|形参}})()|2=

{{dcl begin}}
{{dcl h|无捕获的非泛型 lambda}}
{{dcl rev multi
|dcl1=
using F = 返回类型(*)(形参);
operator F() const noexcept;
|since2=c++17|dcl2=
using F = 返回类型(*)(形参);
constexpr operator F() const noexcept; 
}}
{{dcl h|无捕获的泛型 lambda}}
{{dcl rev multi
|since1=c++14|dcl1=
template&lt;模板形参&gt; using fptr_t = /* 见下文 */;
template&lt;模板形参&gt;
operator fptr_t&lt;模板形参&gt;() const noexcept; 
|since2=c++17|dcl2=
template&lt;模板形参&gt; using fptr_t = /* 见下文 */;
template&lt;模板形参&gt;
constexpr operator fptr_t&lt;模板形参&gt;() const noexcept; 
}}
{{dcl end}}

只有在 lambda 表达式没有{{spar sep|捕获}}{{rev inl|since=c++23|且没有显式对象形参}}时才定义这个{{rlp|cast operator|用户定义转换函数}}。它是闭包对象的公开、{{rev inl|since=c++17|constexpr、}}非虚、非显式、const noexcept 成员函数。
{{rrev|since=c++20|
如果函数调用运算符（或对于泛型 lambda 的函数调用运算符特化）是立即函数，那么此函数是{{rlp|consteval|立即函数}}。
}}

{{rrev|since=c++14|
泛型无捕获 lambda 拥有一个用户定义的转换函数模板，它具有与 {{c|operator()}} 模板相同的虚设模板形参列表。
&lt;source style="width:45em" lang=cpp&gt;
void f1(int (*)(int)) {}
void f2(char (*)(int)) {}
void h(int (*)(int)) {}  // #1
void h(char (*)(int)) {} // #2

auto glambda = [](auto a) { return a; };
f1(glambda); // OK
f2(glambda); // 错误：不可转换
h(glambda);  // OK：调用 #1，因为 #2 不可转换

int&amp; (*fpi)(int*) = [](auto* a) -&gt; auto&amp; { return *a; }; // OK
&lt;/source&gt;
}}


{{rev begin}}
{{rev|until=c++14|
这个转换函数返回一个指向具有 C++ {{rlp|language linkage|语言连接}}的函数的指针，调用该函数的效果与在默认构造的闭包类型实例上调用闭包类型的函数调用运算符的效果相同。
}}
{{rev|since=c++14|until=c++23|
这个转换函数（模板）返回一个指向具有 C++ {{rlp|language linkage|语言连接}}的函数的指针，调用该函数的效果与下列效果相同：
* 对于非泛型 lambda，在默认构造的闭包类型实例上调用闭包类型的 {{c|operator()}}。
* 对于泛型 lambda，在默认构造的闭包类型实例上调用 {{c|operator()}} 模板的泛型 lambda 对应特化。
}}
{{rev|since=c++23|
这个转换函数（模板）：
* 在 {{c|operator()}} 是静态的情况下返回一个指向具有 C++ {{rlp|language linkage|语言连接}}的该 {{c|operator()}} 的指针。
* 否则返回一个指向具有 C++ {{rlp|language linkage|语言连接}}的函数的指针，调用该函数的效果与下列效果相同：
** 对于非泛型 lambda，在默认构造的闭包类型实例上调用闭包类型的 {{c|operator()}}。
** 对于泛型 lambda，在默认构造的闭包类型实例上调用 {{c|operator()}} 模板的泛型 lambda 对应特化。
}}
{{rev end}}


{{rrev|since=c++17|
如果函数调用运算符（或对于泛型 lambda 是它的特化）是 constexpr 的，那么此函数也是 constexpr 的。
&lt;source style="width:45em; overflow-x: hidden;" lang=cpp&gt;
auto Fwd = [](int(*fp)(int), auto a){ return fp(a); };
auto C = [](auto a){ return a; };
static_assert(Fwd(C, 3) == 3);  // OK

auto NC = [](auto a){ static int s; return a;};
static_assert(Fwd(NC, 3) == 3); // 错误：因为 static s 而不能为 constexpr 的特化
&lt;/source&gt;

如果闭包对象的 {{c|operator()}} 具有无抛出异常说明，那么此函数返回的指针具有指向 noexcept 函数的指针类型。
}}
}}

{{member|{{small|闭包类型::}}闭包类型()|2=
{{dcl begin}}
{{dcl|since=c++20|notes={{mark|仅当未指定任何捕获时}}|1=
闭包类型() = default;
}}
{{dcl|1=
闭包类型(const 闭包类型&amp;) = default;
}}
{{dcl|1=
闭包类型(闭包类型&amp;&amp;) = default;
}}
{{dcl end}}
{{rrev multi|
until1=c++20|rev1=
闭包类型非{{named req|DefaultConstructible}}。闭包类型没有默认构造函数。
|rev2=如果没有指定{{spar|捕获}}，那么闭包类型拥有预置的默认构造函数。否则，它没有默认构造函数（这包含有{{spar sep|默认捕获符}}的情况，即使它实际上没有捕获任何变量）。
}}
复制构造函数与移动构造函数声明为预置，并可能按照{{rlp|copy constructor|复制构造函数}}与{{rlp|move constructor|移动构造函数}}的通常规则隐式定义。
}}

{{member|{{small|闭包类型::}}operator{{=}}(const 闭包类型&amp;)|2=
{{dcl begin}}
{{dcl|until=c++20|1=
闭包类型&amp; operator=(const 闭包类型&amp;) = delete;
}}
{{dcl|since=c++20|notes={{mark|仅当未指定任何捕获时}}|1=
闭包类型&amp; operator=(const 闭包类型&amp;) = default;
闭包类型&amp; operator=(闭包类型&amp;&amp;) = default;
}}
{{dcl|since=c++20|notes={{mark|其他情况}}|1=
闭包类型&amp; operator=(const 闭包类型&amp;) = delete;
}}
{{dcl end}}
{{rrev multi|
until1=c++20|rev1=
复制赋值运算符被定义为弃置的（且未声明移动赋值运算符）。闭包类型不{{named req|CopyAssignable}}。
|rev2=如果没有指定 {{spar|捕获}}，那么闭包类型拥有预置的复制赋值运算符和预置的移动赋值运算符。否则，它拥有弃置的复制赋值运算符（这包含有{{spar sep|默认捕获符}}的情况，即使它实际上没有捕获任何变量）。
}}
}}

{{member|{{small|闭包类型::}}~闭包类型()|2=
{{ddcl|1=
~闭包类型() = default;
}}
析构函数是隐式声明的。
}}

{{member|{{small|闭包类型::}}{{spar|捕获}}|2=
{{ddcl|1=
T1 a;
T2 b;
...
}}
如果 lambda 表达式按复制（隐式地以捕获子句 {{ttb|1=[=]}} 或显式地以不含字符 &amp; 的捕获符，例如 {{ttb|[a, b, c]}}）捕获了任何内容，那么闭包类型包含保有所有被如此捕获的实体的副本的无名非静态数据成员，它们以未指明的顺序声明。

如果数据成员对应的捕获符没有初始化器，那么它们在求值 lambda 表达式时被{{rlp|direct initialization|直接初始化}}。如果有初始化器，那么按它的初始化器的要求初始化（可为复制或直接初始化）。如果捕获了数组，那么各数组元素以下标递增顺序直接初始化。初始化各数据成员所用的顺序是它们的声明顺序（即未指明）。

每个数据成员的类型是它对应的被捕获实体的类型，除非实体拥有引用类型（此时到函数的引用被捕获为到被引用函数的左值引用，而到对象的引用被捕获为被引用对象的副本）。

对于按引用捕获（以{{spar|默认捕获符}} {{ttb|[&amp;]}} 或使用了字符 &amp;，例如 {{ttb|[&amp;a, &amp;b, &amp;c]}}）的实体，闭包类型中是否声明额外的数据成员是未指明的{{rev inl|since=c++17|，但任何这种附加成员必须满足{{named req|LiteralType}}}}。
}}


{{rrev|until=c++20|{{anchor|不求值语境中的 lambda}}
不允许在{{rlps|expressions#不求值表达式}}、{{rlp|template parameters|模板实参}}、{{rlp|type alias|别名声明}}、{{rlp|typedef|typedef 声明}}，以及函数（或函数模板）声明中除了函数体和函数的{{rlp|default arguments|默认实参}}以外的任何位置中出现 lambda 表达式。
}}

===lambda 捕获===
{{spar sep|捕获}}定义了可以从 lambda 函数体之内访问的外部变量。它的语法定义如下：
{{sdsc begin}}
{{sdsc|num=1|{{spar|默认捕获符}}}}
{{sdsc|num=2|{{spar|捕获符列表}}}}
{{sdsc|num=3|{{spar|默认捕获符}} {{ttb|,}} {{spar|捕获符列表}}}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|默认捕获符}}|{{ttb|&amp;}} 和 {{ttb|1==}} 之一}}
{{par|{{spar|捕获符列表}}|逗号分隔的{{spar sep|捕获符}}列表}}
{{par end}}


{{spar sep|捕获符}}的语法定义如下：
{{sdsc begin}}
{{sdsc|num=1|{{spar|标识符}}}}
{{sdsc|num=2|{{spar|标识符}} {{ttb|...}}}}
{{sdsc|num=3|notes={{mark since c++14}}|{{spar|标识符}} {{spar|初始化器}}}}
{{sdsc|num=4|{{ttb|&amp;}} {{spar|标识符}}}}
{{sdsc|num=5|{{ttb|&amp;}} {{spar|标识符}} {{ttb|...}}}}
{{sdsc|num=6|notes={{mark since c++14}}|{{ttb|&amp;}} {{spar|标识符}} {{spar|初始化器}}}}
{{sdsc|num=7|{{ttb|this}}}}
{{sdsc|num=8|notes={{mark since c++17}}|{{ttb|*this}}}}
{{sdsc|num=9|notes={{mark since c++20}}|{{ttb|...}} {{spar|标识符}} {{spar|初始化器}}}}
{{sdsc|num=10|notes={{mark since c++20}}|{{ttb|&amp;}} {{ttb|...}} &lt;!--CWG2378--&gt;{{spar|标识符}} {{spar|初始化器}}}}
{{sdsc end}}

@1@ 简单的按复制捕获
@2@ 作为{{rlp|parameter pack|包展开}}的简单的按复制捕获 
@3@ 带{{rlp|initialization|初始化器}}的按复制捕获
@4@ 简单的按引用捕获
@5@ 作为{{rlp|parameter pack|包展开}}的简单的按引用捕获
@6@ 带初始化器的按引用捕获
@7@ 当前对象的简单的按引用捕获
@8@ 当前对象的简单的按复制捕获
@9@ 初始化器为包展开的按复制捕获
@10@ 初始化器为包展开的按引用捕获

当{{spar sep|默认捕获符}}是 {{ttb|&amp;}} 时，后继的简单捕获符不能以 {{ttb|&amp;}} 开始。
{{source|1=
struct S2 { void f(int i); };
void S2::f(int i)
{
    [&amp;] {};          // OK：默认按引用捕获
    [&amp;, i] {};       // OK：按引用捕获，但 i 按值捕获
    [&amp;, &amp;i] {};      // 错误：按引用捕获为默认时的按引用捕获
    [&amp;, this] {};    // OK：等价于 [&amp;]
    [&amp;, this, i] {}; // OK：等价于 [&amp;, i]
}
}}

当{{spar sep|默认捕获符}}是 {{ttb|1==}} 时，后继的简单捕获符必须以 {{ttb|&amp;}}、{{rev inl|since=c++17|{{ttb|*this}}}}、{{rev inl|since=c++20|{{ttb|this}}}} 之一开始。
{{source|1=
struct S2 { void f(int i); };
void S2::f(int i)
{
    [=] {};        // OK：默认按复制捕获
    [=, &amp;i] {};    // OK：按复制捕获，但 i 按引用捕获
    [=, *this] {}; // C++17 前：错误：无效语法
                   // C++17 起：OK：按复制捕获外围的 S2
    [=, this] {};  // C++20 前：错误：= 为默认时的 this
                   // C++20 起：OK：同 [=]
}
}}

任何捕获符只可以出现一次，并且名字不能与任何形参名相同：
{{source|1=
struct S2 { void f(int i); };
void S2::f(int i)
{
    [i, i] {};        // 错误：i 重复
    [this, *this] {}; // 错误："this" 重复（C++17）
    
    [i] (int i) {};   // 错误：形参和捕获的名字相同
}
}}

如果变量满足下列条件之一，那么 lambda 表达式在使用它前不需要先捕获：
* 该变量是非局部变量，或具有静态或线程局部{{rlp|storage duration|存储期}}（此时无法捕获该变量）。
* 该变量是以{{rlps|constant expression#常量表达式}}初始化的引用。

如果变量满足下列条件之一，那么 lambda 表达式在读取它的值前不需要先捕获：
* 该变量具有 const 而非 volatile 的整型或枚举类型，并已经用{{rlps|constant expression#常量表达式}}初始化。
* 该变量是 constexpr 的且没有 mutable 成员。

当出现任一{{spar sep|默认捕获符}}时，都能隐式捕获当前对象（{{c|*this}}）。如果隐式捕获它，那么会始终按引用捕获，即使{{spar sep|默认捕获符}}是 {{ttb|1==}}。{{rev inl|since=c++20|当{{spar sep|默认捕获符}}是 {{ttb|1==}} 时，{{c|*this}} 的隐式捕获被弃用。}}

只有满足以下条件的 lambda 表达式能拥有{{spar sep|默认捕获符}}或无初始化器的{{spar|捕获符}}：
* 它的最内层{{rlp|scope|外围作用域}}是{{rlps|scope#块作用域}}。
* 它在{{rlp|data members#成员初始化|默认成员初始化器}}中出现，并且它的最内层外围作用域是{{rlps|scope#类作用域}}。
{{rrev|since=c++26|
* 它在{{rlp|contracts|约定断言}}中出现，并且它的最内层外围作用域是对应的{{rlps|scope#约定断言作用域}}。
}}

对于这种 lambda 表达式，它的{{i|可达作用域}}定义为它最内层的外围函数（及它的形参）内（包含自身）的外围作用域的集合。这其中包含各个嵌套的块作用域，以及当此 lambda 为嵌套的 lambda 时也包含它的各个外围 lambda 的作用域。

（除了 {{ttb|this}} 捕获符之外的）任何无初始化器的捕获符中的{{spar sep|标识符}}，都使用通常的{{rlp|lookup|无限定名字查找}}在 lambda 的{{i|可达作用域}}中查找。查找结果必须是在可达作用域中声明的且具有自动存储期的{{rlp|object|变量}}{{rev inl|since=c++20|，或对应变量满足这种要求的{{rlp|structured binding|结构化绑定}}}}。该实体被''显式捕获''。

{{rrev|since=c++14|
带有初始化器的捕获符（称为''初始化捕获符''），其行为如同声明并显式捕获以 {{rlp|auto}} 类型说明符声明并拥有相同初始化器的变量，该变量的作用域是 lambda 表达式体（即不在初始化器的作用域内），但：
* 如果按复制捕获，则因而引入的闭包对象的非静态数据成员和该变量将被视为引用同一对象；
** 换言之，源变量并不实际存在，而经由 {{c/core|auto}} 的类型推导和初始化均应用到该非静态数据成员；
* 如果按引用捕获，那么引用变量的生存期在闭包对象的生存期结束时结束。

这可以用于，以 {{c|1=x = std::move(x)}} 这样的捕获符捕获仅可移动的类型。

这也使得通过 const 引用进行捕获成为可能，比如以 {{c|1=&amp;cr = std::as_const(x)}} 或类似的方式。

{{source|1=
int x = 4;

auto y = [&amp;r = x, x = x + 1]() -&gt; int
{
    r += 2;
    return x * x;
}(); // 更新 ::x 到 6 并初始化 y 为 25。
}}
}}

如果{{spar sep|捕获}}具有{{spar|默认捕获符}}，且未显式（以 {{c|this}} 或 {{c|*this}}）捕获它的外围对象，或任何在 lambda 体内{{rlp|definition#ODR 使用|可 ODR 使用}}的自动存储期变量{{rev inl|since=c++20|，或对应变量拥有自动存储期的{{rlp|structured binding|结构化绑定}}}}，则如果{{rlp|expressions#潜在求值表达式|潜在求值}}的表达式内的表达式（包括在使用非静态类成员前添加的隐式 {{c|this-&gt;}}）指名了该实体，则捕获列表''隐式''捕获该实体。

就确定隐式捕获的目的而言，标准认为 {{rlpt|typeid}} 决不使其操作数不求值。

{{rrev|since=c++17|
即使实体仅在 lambda 函数体的{{rlp|if#constexpr if|舍弃语句}}内被指名，它们也可能被隐式捕获。
}}

{{source|1=
void f(int, const int (&amp;)[2] = {}) {}   // #1
void f(const int&amp;, const int (&amp;)[1]) {} // #2

struct NoncopyableLiteralType
{
    constexpr explicit NoncopyableLiteralType(int n) : n_(n) {}
    NoncopyableLiteralType(const NoncopyableLiteralType&amp;) = delete;

    int n_;
};

void test()
{
    const int x = 17;
    
    auto l0 = []{ f(x); };           // OK：调用 #1，不捕获 x
    auto g0 = [](auto a) { f(x); };  // 同上

    auto l1 = [=]{ f(x); };          // OK：（P0588R1 起）捕获 x 并调用 #1
                                     // 捕获能被优化掉
    auto g1 = [=](auto a) { f(x); }; // 同上

    auto ltid = [=]{ typeid(x); };   // OK：（P0588R1 起）捕获 x
                                     // 尽管不求值 x
                                     // 捕获能被优化掉

    auto g2 = [=](auto a)
    {
        int selector[sizeof(a) == 1 ? 1 : 2] = {};
        f(x, selector); // OK：捕获 x
    };
    
    auto g3 = [=](auto a)
    {
        typeid(a + x);  // 捕获 x 而不管 a + x 是否为不求值操作数
    };

    constexpr NoncopyableLiteralType w{42};
    auto l4 = []{ return w.n_; };      // OK：不 ODR 使用 w，捕获是不必要的
    // auto l5 = [=]{ return w.n_; };  // 错误：需要按复制捕获 w
}
}}

如果 lambda 体 {{rlps|definition#ODR 使用}}了按复制捕获的实体，那么它访问的是闭包类型的成员。如果它未 ODR 使用该实体，那么访问的是原对象：
{{source|1=
void f(const int*);
void g()
{
    const int N = 10;
    [=]
    { 
        int arr[N]; // 非 ODR 使用：指代 g 的 const int N
        f(&amp;N); // ODR 使用：导致 N 被（以复制）捕获
               // &amp;N 是闭包对象的成员 N 的地址，而非 g 中的 N
    }();
}
}}

如果 lambda ODR 使用了按引用捕获的引用，那么它使用原引用所指代的对象，而非被捕获的引用自身：
{{example|code=
#include &lt;iostream&gt;

auto make_function(int&amp; x)
{
    return [&amp;] { std::cout &lt;&lt; x &lt;&lt; '\n'; };
}

int main()
{
    int i = 3;
    auto f = make_function(i); // f 中对 x 的使用直接绑定到 i
    i = 5;
    f(); // OK：打印 5
}
}}

在带{{spar|默认捕获符}} {{ttb|1==}} 的 lambda 体内，任何可捕获实体的类型都如同它被捕获一样（从而在 lambda 非 {{c/core|mutable}} 时通常会加上 const 限定），即使该实体在不求值操作数中且未被捕获（例如在 {{rlpt|decltype}} 中）也是如此：

{{source|1=
void f3()
{
    float x, &amp;r = x;
    [=]
    { // x 和 r 未被捕获（在 decltype 的操作数中出现并不是 ODR 使用）
        decltype(x) y1;        // y1 拥有 float 类型
        decltype((x)) y2 = y1; // y2 拥有 float const&amp; 类型，因为此 lambda
                               // 非 mutable 且 x 是左值
        decltype(r) r1 = y1;   // r1 拥有 float&amp; 类型（不考虑变换）
        decltype((r)) r2 = y2; // r2 拥有 float const&amp; 类型
    };
}
}}

lambda（隐式或显式）捕获的任何实体均被该 lambda 表达式 ODR 使用（因此嵌套的 lambda 的隐式捕获将触发它的外围 lambda 的隐式捕获）。

所有隐式捕获的变量必须已在 lambda 的{{i|可达作用域}}中声明。

如果 lambda（以 {{ttb|this}} 或 {{ttb|*this}}）捕获了它的外围对象，那么要么它的最接近的外围函数必须是非静态成员函数，要么该 lambda 必须处于某个{{rlp|data members#成员初始化|默认成员初始化器}}中：
{{source|1=
struct s2
{
    double ohseven = .007;
    auto f() // 以下两个 lambda 的最接近外围函数
    {
        return [this]      // 按引用捕获外围的 s2
        {
            return [*this] // 按复制捕获外围的 s2（C++17）
            {
                return ohseven; // OK
            }
        }();
    }
    
    auto g()
    {
        return [] // 无捕获
        {
            return [*this] {}; // 错误：*this 未被外层 lambda 表达式所捕获
        }();
    }
};
}}

如果 lambda 表达式{{rev inl|since=c++14|（或泛型 lambda 的函数调用运算符的一个特化）}} ODR 使用了 {{c|this}} 或任何具有自动存储期的变量，那么它必须被该 lambda 表达式所捕获。

{{source|1=
void f1(int i)
{
    int const N = 20;
    auto m1 = [=]
    {
        int const M = 30;
        auto m2 = [i]
        {
            int x[N][M]; // N 与 M 未被 ODR 使用（它们可以不被捕获）
            x[0][0] = i; // i 被 m2 显式捕获，并被 m1 隐式捕获
        };
    };
    
    struct s1 // f1() 中的局部类
    {
        int f;
        void work(int n) // 非静态成员函数
        {
            int m = n * n;
            int j = 40;
            auto m3 = [this, m]
            {
                auto m4 = [&amp;, j] // 错误：j 未被 m3 捕获
                {
                    int x = n; // 错误：n 被 m4 隐式捕获，但未被 m3 捕获
                    x += m;    // OK：m 被 m4 捕获，且被 m3 显式捕获
                    x += i;    // 错误：i 在可达作用域之外（该作用域在 work() 结束）
                    x += f;    // OK：this 被 m4 隐式捕获，且被 m3 显式捕获
                };
            };
        }
    };
}
}}

以不带有初始化器的捕获符无法显式捕获类成员（如上提及，{{spar sep|捕获符列表}}中只能有{{rlp|object|变量}}）：
{{source|1=
class S
{
    int x = 0;
    
    void f()
    {
        int i = 0;
    //  auto l1 = [i, x] { use(i, x); };    // 错误：x 不是变量
        auto l2 = [i, x = x] { use(i, x); };  // OK，复制捕获
        i = 1; x = 1; l2(); // 调用 use(0, 0)
        auto l3 = [i, &amp;x = x] { use(i, x); }; // OK，引用捕获
        i = 2; x = 2; l3(); // 调用 use(1, 2)
    }
};
}}

当 lambda 用隐式的按复制捕获捕获了某个成员时，它并不产生该成员变量的副本：对成员变量 {{tt|m}} 的使用被处理成表达式 {{c|(*this).m}}，而 {{c|*this}} 始终被隐式按引用捕获：
{{source|1=
class S
{
    int x = 0;
    
    void f()
    {
        int i = 0;
        
        auto l1 = [=] { use(i, x); }; // 捕获 i 的副本和 this 指针的副本
        i = 1; x = 1; l1();           // 调用 use(0, 1)，如同 i 按复制而 x 按引用捕获
        
        auto l2 = [i, this] { use(i, x); }; // 同上，改为显式捕获
        i = 2; x = 2; l2();           // 调用 use(1, 2)，如同 i 按复制而 x 按引用捕获
        
        auto l3 = [&amp;] { use(i, x); }; // 按引用捕获 i，并捕获 this 指针的副本
        i = 3; x = 2; l3();           // 调用 use(3, 2)，如同 i 与 x 均按引用捕获
        
        auto l4 = [i, *this] { use(i, x); }; // 制造 *this 的副本，包含 x 的副本
        i = 4; x = 4; l4();           // 调用 use(3, 2)，如同 i 与 x 均按复制捕获
    }
};
}}

如果 lambda 表达式在{{rlp|default arguments|默认实参}}中出现，那么它不能显式或隐式捕获任何内容{{rev inl|since=c++14|，除非所有捕获都带有初始化器，并满足可以在默认实参中出现的表达式的约束条件}}：
{{source|1=
void f2()
{
    int i = 1;
    
    void g1( int = [i] { return i; }() ); // 错误：有捕获内容
    void g2( int = [i] { return 0; }() ); // 错误：有捕获内容
    void g3( int = [=] { return i; }() ); // 错误：有捕获内容
    
    void g4( int = [=] { return 0; }() );       // OK：无捕获
    void g5( int = [] { return sizeof i; }() ); // OK：无捕获
 
    // C++14
    void g6( int = [x = 1] { return x; }() ); // OK：1 可以在默认实参中出现
    void g7( int = [x = i] { return x; }() ); // 错误：i 不能在默认实参中出现
}
}}

不能捕获{{rlp|union|匿名联合体}}的成员。只能以复制捕获{{rlp|bit field|位域}}。

如果嵌套的 lambda {{tt|m2}} 捕获了也被它的直接外围 lambda {{tt|m1}} 所捕获的实体，那么以如下方式将 {{tt|m2}} 的捕获进行变换：
* 如果外围 lambda {{tt|m1}} 按复制捕获，那么 {{tt|m2}} 捕获 {{tt|m1}} 的闭包类型的非静态数据成员，而非原变量或 {{c|*this}}；如果 {{tt|m1}} 非 {{tt|mutable}}，那么认为该非静态数据成员有 const 限定。
* 如果外围 lambda {{tt|m1}} 按引用捕获，那么 {{tt|m2}} 捕获原变量或 {{c|*this}}。
{{example
|code=
#include &lt;iostream&gt;

int main()
{
    int a = 1, b = 1, c = 1;
    
    auto m1 = [a, &amp;b, &amp;c]() mutable
    {
        auto m2 = [a, b, &amp;c]() mutable
        {
            std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; '\n';
            a = 4; b = 4; c = 4;
        };
        a = 3; b = 3; c = 3;
        m2();
    };
    
    a = 2; b = 2; c = 2;

    m1();                             // 调用 m2() 并打印 123
    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; '\n'; // 打印 234
}
}}

{{rrev|since=c++23|
如果 lambda 有捕获，那么函数调用表达式的显式对象形参（如果存在）的类型只能是以下之一：
* 闭包类型。
* 公开且无歧义地从闭包类型派生的类类型。
* 到可有 cv 限定性的这种类型的引用类型。

{{source|1=
struct C 
{
    template&lt;typename T&gt;
    C(T);
};

void func(int i) 
{
    int x = [=](this auto&amp;&amp;) { return i; }();  // OK
    int y = [=](this C) { return i; }();       // 错误
    int z = [](this C) { return 42; }();       // OK

    auto lambda = [n = 42] (this auto self) { return n; };
    using Closure = decltype(lambda);
    struct D : private Closure {
        D(Closure l) : Closure(l) {}
        using Closure::operator();
        friend Closure;
    };
    D{lambda}(); // 错误
}
}}
}}

===注解===
{{ftm begin|core=1|std=1|comment=1|sort=1}}
{{ftm|value=200907L|std=C++11|__cpp_lambdas|lambda 表达式}}
{{ftm|value=201304L|std=C++14|__cpp_generic_lambdas|泛型 lambda 表达式|rowspan="2"}}
{{ftm|value=201707L|std=C++20|-|泛型 lambda 表达式的显式模板形参列表}}
{{ftm|value=201304L|std=C++14|__cpp_init_captures|lambda 初始化捕获|rowspan="2"}}
{{ftm|value=201803L|std=C++20|-|允许 lambda 初始化捕获中的包展开}}
{{ftm|value=201603L|std=C++17|__cpp_capture_star_this|按值捕获 {{c|*this}}，如 {{c|1=[=, *this]}}}}
{{ftm|value=201603L|std=C++17|__cpp_constexpr|constexpr 的 lambda}}
{{ftm|value=202207L|std=C++23|__cpp_static_call_operator|无捕获 lambda 的静态 {{c|operator()}}}}
{{ftm end}}

缺陷报告 {{wg21|P0588R1}} 稍微更改了隐式 lambda 捕获的规则。到 2023-10 为止，一些主要实现没有完全实现该缺陷报告，从而有时仍在使用检测 {{rlps|definition#ODR 使用}}的旧规则。

{{cot|P0588R1 前的旧规则}}
如果{{spar sep|捕获}}具有{{spar|默认捕获符}}，且未显式（以 {{ttb|this}} 或 {{ttb|*this}}）捕获它的外围对象，或任何在 lambda 体内{{rlp|definition#ODR 使用|可 ODR 使用}}的自动存储期变量{{rev inl|since=c++20|，或对应变量拥有自动存储期的{{rlp|structured binding|结构化绑定}}}}，那么在实体符合下列条件时捕获列表会{{i|隐式}}捕获该实体：
{{rrev|since=c++14|
* 为依赖泛型 lambda 模板形参的表达式之内的{{rlp|expressions#潜在求值表达式|潜在求值}}表达式中所指名，或
}}
* 被 lambda 函数体 {{rlps|definition#ODR 使用}}。
{{cob}}

===示例===
{{example
|此示例演示如何传递 lambda 给泛型算法，以及 lambda 表达式所产生的对象能如何存储于 {{lc|std::function}} 对象。
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; c{1, 2, 3, 4, 5, 6, 7};
    int x = 5;
    c.erase(std::remove_if(c.begin(), c.end(), [x](int n) { return n &lt; x; }), c.end());

    std::cout &lt;&lt; "c: ";
    std::for_each(c.begin(), c.end(), [](int i) { std::cout &lt;&lt; i &lt;&lt; ' '; });
    std::cout &lt;&lt; '\n';

    // 闭包的类型不能被指名，但可用 auto 提及
    // C++14 起，lambda 可以有默认实参
    auto func1 = [](int i = 6) { return i + 4; };
    std::cout &lt;&lt; "func1: " &lt;&lt; func1() &lt;&lt; '\n';

    // 与所有可调用对象相同，闭包能可以被捕获到 std::function 之中
    // （这可能带来不必要的开销）
    std::function&lt;int(int)&gt; func2 = [](int i) { return i + 4; };
    std::cout &lt;&lt; "func2: " &lt;&lt; func2(6) &lt;&lt; '\n';
 
    constexpr int fib_max {8};
    std::cout &lt;&lt; "模仿递归 lambda 调用：\n斐波那契数：";
    auto nth_fibonacci = [](int n)
    {
        std::function&lt;int(int, int, int)&gt; fib = [&amp;](int n, int a, int b)
        {
            return n ? fib(n - 1, a + b, a) : b;
        };
        return fib(n, 0, 1);
    };
 
    for (int i{1}; i &lt;= fib_max; ++i)
        std::cout &lt;&lt; nth_fibonacci(i) &lt;&lt; (i &lt; fib_max ? ", " : "\n");

    std::cout &lt;&lt; "另一种 lambda 递归方案：\n斐波那契数：";
    auto nth_fibonacci2 = [](auto self, int n, int a = 0, int b = 1) -&gt; int
    {
        return n ? self(self, n - 1, a + b, a) : b;
    };
 
    for (int i{1}; i &lt;= fib_max; ++i)
        std::cout &lt;&lt; nth_fibonacci2(nth_fibonacci2, i) &lt;&lt; (i &lt; fib_max ? ", " : "\n");

#ifdef __cpp_explicit_this_parameter
    std::cout &lt;&lt; "C++23 的 lambda 递归方案：\n";
    auto nth_fibonacci3 = [](this auto self, int n, int a = 0, int b = 1) -&gt; int
    {
         return n ? self(n - 1, a + b, a) : b;
    };
 
    for (int i{1}; i &lt;= fib_max; ++i)
        std::cout &lt;&lt; nth_fibonacci3(i) &lt;&lt; (i &lt; fib_max ? ", " : "\n");
#endif
}
|p=true
|output= 
c: 5 6 7
func1: 10
func2: 10
模仿递归 lambda 调用：
斐波那契数：0, 1, 1, 2, 3, 5, 8, 13
另一种 lambda 递归方案：
斐波那契数：0, 1, 1, 2, 3, 5, 8, 13
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=974|std=C++11|before=lambda 表达式的形参列表中不能有默认实参|after=可以有}}
{{dr list item|wg=cwg|dr=1048|paper=N3638|std=C++11|before=只能对仅包含一个 {{c/core|return}} 语句的 lambda 体推导返回类型|after=改进返回类型推导}}
{{dr list item|wg=cwg|dr=1249|std=C++11|before=不明确外围非 mutable 的 lambda 所捕获的成员是否为 {{c/core|const}}|after=认为它为 {{c/core|const}}}}
{{dr list item|wg=cwg|dr=1557|std=C++11|before=未指定闭包类型的转换函数的返回函数类型的语言链接|after=它具有 C++ 语言链接}}
{{dr list item|wg=cwg|dr=1607|std=C++11|before=lambda 表达式可以在函数和函数模板签名中出现|after=已禁止}}
{{dr list item|wg=cwg|dr=1612|std=C++11|before=可以捕获匿名联合体的成员|after=已禁止}}
{{dr list item|wg=cwg|dr=1722|std=C++11|before=无捕获的 lambda 的转换函数的异常说明未指明|after=转换函数为 noexcept}}
{{dr list item|wg=cwg|dr=1772|std=C++11|before=lambda 体内 {{c|__func__}} 的语义不明确|after=它指代闭包类的 {{c|operator()}}}}
{{dr list item|wg=cwg|dr=1780|std=C++14|before=不明确泛型 lambda 的闭包类型的成员是否可以被显式实例化或被显式特化|after=两者都不允许}}
{{dr list item|wg=cwg|dr=1891|std=C++11|before=闭包带有弃置的默认构造函数和隐含的复制/移动构造函数|after=无默认及预置的复制/移动}}
{{dr list item|wg=cwg|dr=1937|std=C++11|before=未指明调用转换函数的返回值的效果与调用哪个对象的 {{c|operator()}} 相同|after=与调用默认构造的闭包类型&lt;br&gt;实例的 {{c|operator()}} 相同}}
{{dr list item|wg=cwg|dr=1973|std=C++11|before=闭包类型的 {{c|operator()}} 的形参列表可以指代{{spar sep|尾随类型}}中的形参列表|after=只能指代{{spar|形参列表}}}}
{{dr list item|wg=cwg|dr=2011|std=C++11|before=对于按引用捕获的引用，未指明该捕获符的标识符表示的是哪个实体|after=表示的是原来引用的实体}}
{{dr list item|wg=cwg|dr=2095|std=C++11|before=按复制捕获到函数的右值引用的行为不明确|after=使之明确}}
{{dr list item|wg=cwg|dr=2211|std=C++11|before=未指明捕获与形参的名字相同时的行为|after=此时程序非良构}}
{{dr list item|wg=cwg|dr=2358|std=C++14|before=在默认实参中的 lambda 表达式不能有任何捕获，&lt;br&gt;即使它们都被可以在默认实参内出现的表达式初始化|after=这种带捕获的 lambda 表达式&lt;br&gt;可以在默认实参中出现}}
{{dr list item|wg=cwg|dr=2509|std=C++17|before=说明符序列里每个声明符可以多次出现|after=只能各出现最多一次}}
{{dr list item|wg=cwg|dr=2561|std=C++23|before=有显式对象形参的 lambda 表达式可能拥有到不想要的函数指针类型的转换函数|after=没有这种转换函数}}
{{dr list item|wg=cwg|dr=2881|std=C++23|before=有显式对象形参的 {{c/core|operator()}} 能对继承非公开或有歧义的派生类实例化|after=使之非良构}}
{{dr list item|paper=P0588R1|std=C++11|before=隐式 lambda 捕获的规则检测 ODR 使用|after=简化了规则}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/language/dsc auto}}
{{dsc inc|cpp/utility/functional/dsc function}}
{{dsc inc|cpp/utility/functional/dsc move_only_function}}
{{dsc end}}

===外部链接===
{{eli|{{enwiki|Nested function|嵌套函数}} - 一个函数定义于另一个（''外围''）函数之内。}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}