{{title|引用初始化}}
{{cpp/language/initialization/navbar}}
将一个引用绑定到一个对象。

===语法===
=====非列表初始化=====
{{sdsc begin}}
{{sdsc|num=1|
{{spar sep|T}}{{ttb|&amp;}} {{spar|引用}} {{ttb|1==}} {{spar|目标}} {{ttb|;}}&lt;br&gt;
{{spar sep|T}}{{ttb|&amp;}} {{spar|引用}} {{ttb|(}} {{spar|目标}} {{ttb|);}}
}}
{{sdsc|num=2|notes={{mark since c++11}}|
{{spar sep|T}}{{ttb|&amp;&amp;}} {{spar|引用}} {{ttb|1==}} {{spar|目标}} {{ttb|;}}&lt;br&gt;
{{spar sep|T}}{{ttb|&amp;&amp;}} {{spar|引用}} {{ttb|(}} {{spar|目标}} {{ttb|);}}
}}
{{sdsc|num=3|
{{spar|接受引用的函数}} {{ttb|(}} {{spar|目标}} {{ttb|)}}
}}
{{sdsc|num=4|notes={{mark|在{{spar sep|返回引用的函数}}的定义中}}|
{{ttb|return}} {{spar|目标}} {{ttb|;}}
}}
{{sdsc|num=5|notes={{mark|在{{spar sep|类}}的定义中}}|
{{spar|类}}{{ttb|::}}{{spar|类}}{{ttb|(}}...{{ttb|) :}} {{spar|引用成员}} {{ttb|(}} {{spar|目标}} {{ttb|) {}} ... {{ttb|}&lt;!-- --&gt;}}
}}
{{sdsc end}}

=====一般列表初始化 {{mark since c++11}}=====
{{sdsc begin}}
{{sdsc|num=1|
{{spar sep|T}}{{ttb|&amp;}} {{spar|引用}} {{ttb|1== {}} {{spar|实参1}}{{ttb|,}} {{spar|实参2}}{{ttb|,}} ... {{ttb|};}}&lt;br&gt;
{{spar sep|T}}{{ttb|&amp;}} {{spar|引用}} {{ttb|{}} {{spar|实参1}}{{ttb|,}} {{spar|实参2}}{{ttb|,}} ... {{ttb|};}}
}}
{{sdsc|num=2|
{{spar sep|T}}{{ttb|&amp;&amp;}} {{spar|引用}} {{ttb|1== {}} {{spar|实参1}}{{ttb|,}} {{spar|实参2}}{{ttb|,}} ... {{ttb|};}}&lt;br&gt;
{{spar sep|T}}{{ttb|&amp;&amp;}} {{spar|引用}} {{ttb|{}} {{spar|实参1}}{{ttb|,}} {{spar|实参2}}{{ttb|,}} ... {{ttb|};}}
}}
{{sdsc|num=3|
{{spar|接受引用的函数}} {{ttb|({}} {{spar|实参1}}{{ttb|,}} {{spar|实参2}}{{ttb|,}} ... {{ttb|});}}
}}
{{sdsc end}}

=====指派列表初始化 {{mark since c++20}}=====
{{sdsc begin}}
{{sdsc|num=1|
{{spar sep|T}}{{ttb|&amp;}} {{spar|引用}} {{ttb|1== {.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!-- --&gt;}} ... {{ttb|};}}&lt;br&gt;
{{spar sep|T}}{{ttb|&amp;}} {{spar|引用}} {{ttb|{.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!-- --&gt;}} ... {{ttb|};}}
}}
{{sdsc|num=2|
{{spar sep|T}}{{ttb|&amp;&amp;}} {{spar|引用}} {{ttb|1== {.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!-- --&gt;}} ... {{ttb|};}}&lt;br&gt;
{{spar sep|T}}{{ttb|&amp;&amp;}} {{spar|引用}} {{ttb|{.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!-- --&gt;}} ... {{ttb|};}}
}}
{{sdsc|num=3|
{{spar|接受引用的函数}} {{ttb|({.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!-- --&gt;}} ... {{ttb|});}}
}}
{{sdsc end}}

到 {{tt|T}} 的引用能以 {{tt|T}} 类型的对象、{{tt|T}} 类型的函数或可以隐式转换到 {{tt|T}} 的对象初始化。引用一旦初始化，便无法引用另一对象。

引用在下列情形初始化：
@1@ 以初始化器声明具名{{rlps|reference#左值引用}}变量时。
@2@ 以初始化器声明具名{{rlps|reference#右值引用}}变量时。
@3@ 在函数调用表达式中且有函数形参拥有引用类型时。
@4@ 在函数的 {{c/core|return}} 语句中且函数返回引用类型时。{{rev inl|since=c++26|如果返回的引用被绑定到[[#临时量的生存期|临时表达式]]的结果则程序非良构。}}
@5@ 以{{rlp|initializer list|成员初始化器}}初始化引用类型的{{rlp|data members|非静态数据成员}}时。

===解释===
{{par begin}}
{{par|{{spar|T}}|被引用类型}}
{{par|{{spar|引用}}|要初始化的引用变量}}
{{par|{{spar|目标}}|使用的初始化器表达式}}
{{par|{{spar|接受引用的函数}}|参数是引用类型（{{spar sep|T}}{{tt|&amp;}}{{rev inl|since=c++11| 或 {{spar sep|T}}{{tt|&amp;&amp;}}}}）的函数}}
{{par|{{spar|返回引用的函数}}|返回类型是引用类型（{{spar sep|T}}{{tt|&amp;}}{{rev inl|since=c++11| 或 {{spar sep|T}}{{tt|&amp;&amp;}}}}）的函数}}
{{par|{{spar|类}}|类名}}
{{par|{{spar|引用成员}}|{{spar sep|类}}的引用类型（{{spar sep|T}}{{tt|&amp;}}{{rev inl|since=c++11| 或 {{spar sep|T}}{{tt|&amp;&amp;}}}}）非静态数据成员}}
{{par|{{spar|指派符1}}, {{spar|指派符2}}, ...|指派符}}
{{par|{{spar|实参1}}, {{spar|实参2}}, ...|初始化器列表中的初始化器}}
{{par end}}

===定义===
对于两个类型 {{tt|T1}} 和 {{tt|T2}}：
* 分别给定 {{tt|T1}} 和 {{tt|T2}} 的无 cv 限定版本为 {{tt|U1}} 和 {{tt|U2}}，如果 {{tt|U1}} 与 {{tt|U2}} {{rlp|implicit conversion#相似类型|相似}}，或者 {{tt|U1}} 是 {{tt|U2}} 的{{rlp|derived class|基类}}，那么 {{tt|T1}} ''引用关联于'' {{tt|T2}}。&lt;!-- “引用关联于”不是对称关系，不适合用“与...有引用关联”表示 --&gt;
* 如果类型“指向 {{tt|T2}} 的指针”的纯右值可以通过标准转换序列转换到类型“指向 {{tt|T1}} 的指针”，那么 {{tt|T1}} ''引用兼容'' {{tt|T2}}。

===初始化规则===
{{rrev|since=c++11|
如果引用初始化使用一般{{rev inl|since=c++20|或指派}}列表初始化，那么遵循{{rlp|list initialization|列表初始化}}的规则。
}}

对于非列表初始化，给定{{spar sep|目标}}的类型为 {{tt|U}}，引用要么''直接绑定''{{sep}}到{{spar sep|目标}}，要么绑定到从{{spar sep|目标}}转换到类型 {{tt|T}} 的某个值。先考虑直接绑定，再考虑间接绑定，如果没有绑定可用，那么程序非良构。

在所有情况下，当两个类型的引用兼容关系被用于建立引用绑定的有效性时，如果标准转换序列非良构，那么需要建立该绑定的程序非良构。

====直接绑定====
如果满足以下所有条件：
* 要初始化的引用是左值引用。
* {{spar sep|目标}}是非{{rlp|bit field|位域}}左值。
* {{tt|T}} 引用兼容 {{tt|U}}。
那么引用会绑定到{{spar sep|目标}}或它合适的基类子对象：
{{source|1=
double d = 2.0;
double&amp; rd = d;        // rd 引用 d
const double&amp; rcd = d; // rcd 引用 d

struct A {};
struct B : A {} b;

A&amp; ra = b;             // ra 引用 b 中的 A 子对象
const A&amp; rca = b;      // rca 引用 b 中的 A 子对象
}}

否则，如果满足以下所有条件：
* 要初始化的引用是左值引用。
* {{tt|U}} 是类类型。
* {{tt|T}} 不引用关联于 {{tt|U}}。
* {{spar sep|目标}}可以转换成某个类型 {{tt|V}} 的左值，并且 {{tt|T}} 引用兼容 {{tt|V}}。
那么引用会绑定到转换结果左值或它合适的基类子对象：
{{source|1=
struct A {};
struct B : A { operator int&amp;(); };

int&amp; ir = B(); // ir 指代 B::operator int&amp; 的结果
}}

否则，如果{{rev inl|since=c++11|要初始化的引用是左值引用，并且}} {{tt|T}} 没有 const 限定，或者具有 volatile 限定，那么程序非良构：
{{source|1=
double&amp; rd2 = 2.0; // 错误：不是左值，并且引用不是 const 的
int i = 2;
double&amp; rd3 = i;   // 错误：类型不匹配，并且引用不是 const 的
}}

否则，如果满足以下所有条件：
* {{spar sep|目标}}是以下类别之一的值：
{{rev begin}}
{{rev|until=c++11|
:* 右值
}}
{{rev|since=c++11|until=c++17|
:* 非位域亡值
:* 类纯右值
:* 数组纯右值
:* 函数左值
}}
{{rev|since=c++17|
:* 非位域右值
:* 函数左值
}}
{{rev end}}
* {{tt|T}} 引用兼容 {{tt|U}}。
那么引用会绑定到{{spar sep|目标}}或它合适的基类子对象：
{{source|1=
struct A {};
struct B : A {};
extern B f();

const A&amp; rca2 = f(); // 到 B 右值的 A 子对象。
A&amp;&amp; rra = f();       // 同上

int i2 = 42;
int&amp;&amp; rri = static_cast&lt;int&amp;&amp;&gt;(i2); // 直接绑定到 i2
}}

{{rrev|since=c++17|
如果{{spar sep|目标}}是纯右值，那么会对它应用{{rlps|implicit conversion#临时量实质化}}，此时会将该纯右值的类型视为调整后类型 {{tt|P}}。
* {{tt|P}} 是通过向{{spar sep|目标}}的类型（即 {{tt|U}}）添加 {{tt|T}} 的 cv 限定{{rlp|implicit conversion#限定性转换|调整}}得到的。

这种情况下引用会绑定到结果对象或它合适的基类子对象。
}}

否则，如果满足以下所有条件：
* {{tt|U}} 是类类型。
* {{tt|T}} 不引用关联与 {{tt|U}}。
* {{spar sep|目标}}可以转换成某个类型 {{tt|V}} 的值 {{c|v}}，并且 {{tt|T}} 引用兼容 {{tt|V}}，其中 {{c|v}} 属于是以下类别之一：
{{rev begin}}
{{rev|until=c++11|
:* 右值
}}
{{rev|since=c++11|until=c++17|
:* 亡值
:* 类纯右值
:* 函数左值
}}
{{rev|since=c++17|
:* 右值
:* 函数左值
}}
{{rev end}}
那么引用会绑定到转换结果或它合适的基类子对象：
{{source|1=
struct A {};
struct B : A {};
struct X { operator B(); } x;

const A&amp; r = x; // 绑定到转换结果的 A 子对象
B&amp;&amp; rrb = x;    // 直接绑定到转换的结果
}}

{{rrev|since=c++17|
如果转换结果是纯右值，那么会对它应用{{rlps|implicit conversion#临时量实质化}}，此时会将该纯右值的类型视为调整后类型 {{tt|P}}。
* {{tt|P}} 是通过向转换结果的类型添加 {{tt|T}} 的 cv 限定{{rlp|implicit conversion#限定性转换|调整}}得到的。

这种情况下引用会绑定到结果对象或它合适的基类子对象。
}}

====间接绑定====
如果直接绑定不可用，那么就会考虑间接绑定。此时 {{tt|T}} 不能引用关联于 {{tt|U}}。

如果 {{tt|T}} 或 {{tt|U}} 是类类型，会以通过用户定义转换进行的对类型 {{tt|T}} 对象进行{{rlp|copy initialization|复制初始化}}的规则考虑用户定义转换。如果对应的非引用复制初始化非良构，那么程序非良构。转换函数调用的结果（在非引用{{rlp|copy initialization|复制初始化}}部分描述）会用于直接初始化引用，此直接初始化不会再考虑用户定义转换。

{{rev begin}}
{{rev|until=c++17|
否则会从{{spar sep|目标}}创建并复制初始化一个类型 {{tt|T}} 的临时量。引用会绑定到该临时量。
}}
{{rev|since=c++17|
否则{{spar sep|目标}}会隐式转换成一个类型是“无 cv 限定的 {{tt|T}}” 的纯右值。然后应用临时量实质化，在将该纯右值的类型视为 {{tt|T}} 的情况下将引用绑定到结果对象。
}}
{{rev end}}

{{source|1=
const std::string&amp; rs = "abc"; // rs 指代从字符数组复制初始化的临时量
const double&amp; rcd2 = 2;        // rcd2 指代值为 2.0 的临时量
int i3 = 2;
double&amp;&amp; rrd3 = i3;            // rrd3 指代值为 2.0 的临时量
}}

===临时量的生存期===
一旦引用被绑定到临时对象或它的子对象，临时对象的生存期就被延续以匹配引用的生存期（检查{{rlp|lifetime#临时对象生存期|临时对象生存期的例外}}），其中临时对象或它的子对象由下列表达式之一代表：
{{rrev multi|rev1=
* 对象类型的{{rlps|value category#纯右值}}表达式，
|since2=c++17|rev2=
* {{rlp|implicit conversion#临时量实质化|临时量实质化转换}}，
}}
* 有括号表达式 {{c|(e)}}，其中 {{c|e}} 是这些表达式之一，
* 形式为 {{c|a[n]}} 或 {{c|n[a]}} 的{{rlp|operator member access#内建的下标运算符|内建的下标表达式}}，其中 {{c|a}} 是数组并且是这些表达式之一，
* 形式为 {{c|e.m}} 的{{rlp|operator member access#内建的成员访问运算符|类成员访问表达式}}，其中 {{c|e}} 是这些表达式之一且 {{c|m}} 指代对象类型的非静态数据成员，
* 形式为 {{c|e.*mp}} 的{{rlp|operator member access#内建的成员指针访问运算符|成员指针操作}}，其中 {{c|e}} 是这些表达式之一且 {{c|mp}} 是指向数据成员的指针，
* 无用户定义转换的 {{rlpt|const_cast}}、{{rlpt|static_cast}}、{{rlpt|dynamic_cast}} 或 {{rlpt|reinterpret_cast}} 转换，它将这些表达式之一转换成指代操作数所指代的对象，它的完整对象，或完整对象的子对象的泛左值（{{rlp|explicit cast|显式转换}}表达式被转译成这些基础转换的序列），
* 形式为 {{c|cond ? e1 : e2}} 并且是泛左值的{{rlp|operator other#条件运算符|条件表达式}}，其中 {{c|e1}} 或 {{c|e2}} 是这些表达式之一，或
* 形式为 {{c|x, e}} 并且是泛左值的{{rlp|operator other#内建的逗号运算符|内建的逗号表达式}}，其中 {{c|e}} 是这些表达式之一。

此生存期规则有下列例外：
{{rrev|until=c++26|
* {{c/core|return}} 语句中绑定到函数返回值的临时量不会被延续：它在返回表达式的末尾立即销毁。这种 {{c/core|return}} 语句始终返回悬垂引用。
}}
* 在函数调用中绑定到函数形参的临时量，存在到含这次函数调用的全表达式结尾为止：如果函数返回一个生命长于全表达式的引用，那么它会成为悬垂引用。
{{rrev|since=c++11|
* 绑定到 new 表达式中所用的初始化器中的引用的临时量，存在到含有该 new 表达式的全表达式结尾为止，而非被初始化对象的存在期间。如果被初始化对象的生命长于全表达式，那么它的引用成员将成为悬垂引用。
}}
{{rrev|since=c++20|
* 绑定到用直接初始化语法（圆括号），而非列表初始化语法（花括号）初始化的聚合体的引用元素中的引用的临时量，存在直至含该初始化器的全表达式末尾为止。
{{source|1=
struct A
{
    int&amp;&amp; r;
};

A a1{7}; // OK：延续生存期
A a2(7); // 良构，但有悬垂引用
}}
}}

总而言之，临时量的生存期不能以进一步“传递”来延续：从绑定了该临时量的引用或数据成员初始化的第二引用不影响临时量的生存期。

===注解===
只有在函数形参声明中，函数返回类型声明中，类成员声明中，以及带 {{c/core|extern}} 说明符时，引用不需要与初始化器一同出现。

在解决 {{cwg|1696}} 前，在构造函数的{{rlp|initializer list|成员初始化器列表}}中可以绑定临时量到引用成员，而临时量只持续到构造函数退出前，而非对象存在期间。这种初始化从 CWG 1696 开始非良构，不过许多编译器仍然支持它（值得注意的例外是 clang）。

===示例===
{{example
|
|code=
#include &lt;sstream&gt;
#include &lt;utility&gt;

struct S
{
    int mi;
    const std::pair&lt;int,int&gt;&amp; mp; // 引用成员
};

void foo(int) {}

struct A {};

struct B : A
{
    int n;
    operator int&amp;() { return n; };
};

B bar() { return B(); }

//int&amp; bad_r;      // 错误：没有初始化器
extern int&amp; ext_r; // OK

int main()
{
//  左值
    int n = 1;
    int&amp; r1 = n;                    // 到对象 n 的左值引用
    const int&amp; cr(n);               // 引用可以有更多 cv 限定
    volatile int&amp; cv{n};            // 可使用任何初始化器语法
    int&amp; r2 = r1;                   // 另一到对象 n 的左值引用
//  int&amp; bad = cr;                  // 错误：更少 cv 限定
    int&amp; r3 = const_cast&lt;int&amp;&gt;(cr); // 需要 const_cast

    void (&amp;rf)(int) = foo;  // 到函数的左值引用
    int ar[3];
    int (&amp;ra)[3] = ar;      // 到数组的左值引用

    B b;
    A&amp; base_ref = b;        // 到基类子对象的左值引用
    int&amp; converted_ref = b; // 到转换结果的左值引用

//  右值
//  int&amp; bad = 1;        // 错误：不能绑定左值引用到右值
    const int&amp; cref = 1; // 绑定到右值
    int&amp;&amp; rref = 1;      // 绑定到右值

    const A&amp; cref2 = bar(); // 到 B 临时量的 A 子对象的引用
    A&amp;&amp; rref2 = bar();      // 相同

    int&amp;&amp; xref = static_cast&lt;int&amp;&amp;&gt;(n); // 直接绑定到 n
//  int&amp;&amp; copy_ref = n;                 // 错误：不能绑定到左值
    double&amp;&amp; copy_ref = n;              // 绑定到值为 1.0 的右值临时量

// 临时量生存期上的限制
    std::ostream&amp; buf_ref = std::ostringstream() &lt;&lt; 'a'; // ostringstream 临时量
                      // 被绑定到 operator&lt;&lt; 的左运算数，但是它的生存期在分号结束，
                      // 所以 buf_ref 是悬垂引用。

    S a{1, {2, 3}&lt;!-- --&gt;};          // 绑定临时量 pair {2,3} 到引用成员 a.mp，
                             // 并延长它的生存期以匹配 a
    S* p = new S{1, {2, 3}&lt;!-- --&gt;}; // 绑定临时量 pair {2,3} 到引用成员 p-&gt;mp，
                             // 但是它的生存期在分号结束
                             // p-&gt;mp 是悬垂引用
    delete p;

    // 模拟对以下变量运用 [[maybe_unused]]：
    [](...){}
    (
        cv, r2, r3, rf, ra, base_ref, converted_ref,
        a, cref, rref, cref2, rref2, copy_ref, xref
    );
}
|output=
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=391|std=C++98|before=以类类型右值初始化到有 const 限定的类型的引用时可能会&lt;br&gt;创建临时量，并且该类需要提供构造函数以将右值复制到临时量|after=不会再创建临时量，&lt;br&gt;也不再需要构造函数}}
{{dr list item|wg=cwg|dr=450|std=C++98|before=到有 const 限定的数组的引用无法被引用兼容的数组右值初始化|after=允许这种初始化}}
{{dr list item|wg=cwg|dr=589|std=C++98|before=引用无法直接绑定到数组或类纯右值|after=可以直接绑定}}
{{dr list item|wg=cwg|dr=656|std=C++98|before=当到有 const 限定的类型的引用以非引用兼容但拥有到某个&lt;br&gt;引用兼容类型的转换函数的类型初始化时，该引用会绑定到从&lt;br&gt;该转换函数的返回值（或它的基类子对象）创建的一个复制|after=改为直接绑定到该返回值&lt;br&gt;（或它的基类子对象）}}
{{dr list item|wg=cwg|dr=1287|std=C++11|before=从类类型{{spar sep|目标}}到另一引用兼容类型的转换只能是隐式的|after=可以是显式的}}
{{dr list item|wg=cwg|dr=1295|std=C++11|before=引用可以绑定到位域亡值|after=已禁止}}
{{dr list item|wg=cwg|dr=1299|std=C++98|before=临时量的定义不明确|after=使之明确}}
{{dr list item|wg=cwg|dr=1571|std=C++98|before=间接绑定中的用户定义转换不会考虑{{spar sep|目标}}的类型|after=会考虑}}
{{dr list item|wg=cwg|dr=1604|std=C++98|before=间接绑定不会考虑用户定义转换|after=会考虑}}
{{dr list item|wg=cwg|dr=2352|std=C++98|before=引用兼容性不会考虑限定性转换|after=会考虑}}
{{dr list item|wg=cwg|dr=2481|std=C++17|before=间接绑定中不会向临时量实质化的结果类型添加 cv 限定|after=会添加}}
{{dr list item|wg=cwg|dr=2657|std=C++17|before=直接绑定中不会向临时量实质化的结果类型添加 cv 限定|after=会添加}}
{{dr list item|wg=cwg|dr=2801|std=C++98|before=间接绑定允许有引用关联的类型|after=已禁止}}
{{dr list end}}

===参阅===
* {{rlp|constructor|构造函数}}
* {{rlp|converting constructor|转换构造函数}}
* {{rlp|copy assignment|复制赋值}}
* {{rlp|copy constructor|复制构造函数}}
* {{rlpt|explicit}}
* {{rlp|initialization|初始化}}
** {{rlp|constant initialization|常量初始化}}
** {{rlp|copy initialization|复制初始化}}
** {{rlp|direct initialization|直接初始化}}
** {{rlp|list initialization|列表初始化}}
* {{rlp|move assignment|移动赋值}}
* {{rlp|move constructor|移动构造函数}}
* {{rlpt|new}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}