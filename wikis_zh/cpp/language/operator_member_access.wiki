{{title|成员访问运算符}}
{{cpp/language/expressions/navbar}}
访问操作数的一个成员。

{|class="wikitable" style="font-size:85%;"
|-
!rowspan="2" style="width: 10%;"|运算符名
!rowspan="2"|语法
!rowspan="2"|{{rlp|operators|可重载}}
!colspan="2"|原型示例（对于 {{c/core|class T}}）
|-
!类定义内
!类定义外
|-
|rowspan=2|下标
|{{c|a[b]}}
|rowspan=2 {{yes}}
|{{c|R&amp; T::operator[](S b);}}
|rowspan=2 {{n/a}}
|-
|{{c|a[...]}} {{mark since c++23}}
|{{c|R&amp; T::operator[](...);}}
|-
|间接寻址
|{{c|*a}}
|{{yes}}
|{{c|1=R&amp; T::operator*();}}
|{{c|1=R&amp; operator*(T a);}}
|-
|取地址
|{{c|&amp;a}}
|{{yes}}
|{{c|1=R* T::operator&amp;();}}
|{{c|1=R* operator&amp;(T a);}}
|-
|对象的成员
|{{c|a.b}}
|{{no}}
|{{n/a}}
|{{n/a}}
|-
|指针的成员
|{{c|1=a-&gt;b}}
|{{yes}}
|{{c|R* T::operator-&gt;()}}
|{{n/a}}
|-
|指向对象的成员的指针
|{{c|a.*b}}
|{{no}}
|{{n/a}}
|{{n/a}}
|-
|指向指针的成员的指针
|{{c|1=a-&gt;*b}}
|{{yes}}
|{{c|R&amp; T::operator-&gt;*(S b);}}
|{{c|R&amp; operator-&gt;*(T a, S b);}}
|-
| colspan="5" |
:'''注解'''&lt;br&gt;
* 与大多数用户定义的重载相同，返回类型应当与内建运算符所提供的返回类型相匹配，以便{{rlp|operators|用户定义的运算符}}可以和内建运算符以相同的方式使用。不过，在用户定义的运算符重载中，任何类型都可以作为它的返回类型（包括 {{c/core|void}}）。一个例外是 {{c/core|operator-&gt;}}，它必须返回一个指针或者另一个带有重载的 {{c/core|operator-&gt;}} 的类以使它真正可用。
|}

===解释===
内建的''下标''{{sep}}运算符提供对它的{{rlp|pointer|指针}}或{{rlp|array|数组}}操作数所指向的对象的访问。

内建的''间接寻址''{{sep}}运算符提供对它的指针操作数所指向的对象或函数的访问。

内建的''取地址''{{sep}}运算符创建指向它的对象或函数操作数的指针。

''对象的成员''{{sep}}和''指向对象的成员的指针''{{sep}}运算符提供对它的对象操作数的数据成员或成员函数的访问。

内建的''指针的成员''{{sep}}和''指向指针的成员的指针''{{sep}}运算符提供对它的指针操作数所指向的类的数据成员或成员函数的访问。

====内建的下标运算符====
下标运算符表达式的形式为

{{sdsc begin}}
{{sdsc|num=1|{{spar sep|表达式1}}{{ttb|[}}{{spar sep|表达式2}}{{ttb|]}}}}
{{sdsc|num=2|{{spar sep|表达式1}}{{ttb|[{}}{{spar sep|表达式}}{{tt|, ...}}{{ttb|}]}}|notes={{mark since c++11}}}}
{{sdsc|num=3|{{spar sep|表达式1}}{{ttb|[}}{{spar sep|表达式2}}{{tt|,}} {{spar sep|表达式}}{{tt|, ...}}{{ttb|]}}|notes={{mark since c++23}}}} 
{{sdsc end}}
@1@ 对于内建运算符，表达式之一（{{spar sep|表达式1}}或{{spar|表达式2}}）必须是“{{tt|T}} 的数组”类型的泛左值或“{{tt|T}} 的指针”类型的纯右值，而另一表达式（分别是 {{spar sep|表达式2}}或{{spar|表达式1}}）必须是无作用域枚举或整型类型的纯右值。此表达式的结果类型是 {{tt|T}}。{{rev inl|since=c++23|{{spar sep|表达式2}}不能是无括号的{{rlp|operator other#内建的逗号表达式|逗号表达式}}。}}
@2@ 方括号中有花括号环绕列表的形式只能用于调用重载的 {{c/core|operator[]}}。
@3@ 方括号中有逗号分隔的表达式列表的形式只能用于调用重载的 {{c/core|operator[]}}。

内建下标表达式 {{c|E1[E2]}} 除了{{rlp|value category|值类别}}（见下文）{{rev inl|since=c++17|和{{rlp|eval order|求值顺序}}}}之外与表达式 {{c|*(E1 + E2)}} 严格等同，就是说，它遵循{{rlp|operator arithmetic|指针算术}}的规则，将指针操作数（可以是数组到指针转换的结果，但它必须指向某数组的元素或末尾后一位置）调整成指向同数组的另一元素，然后再进行解引用。

应用到数组时，{{rev inl|since=c++11|如果数组是左值，那么}}下标表达式是{{rlp|value category|左值}}{{rev inl|since=c++11|，否则是{{rlp|value category|亡值}}}}。

应用到指针时，下标表达式始终是左值。

类型 {{tt|T}} 不得是{{rlp|incomplete type|不完整类型}}，即使 {{tt|T}} 的大小或它的内部结构始终不会被使用也是如此，如 {{c|&amp;x[0]}}。

{{rrev multi
|since1=c++20|rev1=
以无括号的{{rlp|operator other#内建的逗号运算符|逗号表达式}}作为下标运算符的第二（右）操作数是被弃用的。

例如，{{c|a[b, c]}} 被弃用而 {{c|a[(b, c)]}} 未被弃用。
|since2=c++23|rev2=
无括号的{{rlp|operator other#内建的逗号表达式|逗号表达式}}不能作为下标运算符的第二（右）参数。例如 {{c|a[b, c]}} 要么非良构要么与 {{c|a.operator[](b, c)}} 等价。

逗号表达式用作下标时需要括号，例如 {{c|a[(b, c)]}}。
}}

在{{rlp|overload resolution#调用重载运算符|对于用户定义运算符的重载决议}}中，对于每个对象类型 {{tt|T}}（可有 cv 限定），下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|T&amp; operator[](T*, std::ptrdiff_t);}}
{{dcl|T&amp; operator[](std::ptrdiff_t, T*);}}
{{dcl end}}

{{example
|code=
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
 
int main()
{
    int a[4] = {1, 2, 3, 4};
    int* p = &amp;a[2];
    std::cout &lt;&lt; p[1] &lt;&lt; p[-1] &lt;&lt; 1[p] &lt;&lt; (-1)[p] &lt;&lt; '\n';
    
    std::map&lt;std::pair&lt;int, int&gt;, std::string&gt; m;
    m[{1, 2}] = "abc"; // 使用 [{...}] 版本
}
|output=
4242
}}

====内建的间接寻址运算符====
间接寻址运算符表达式的形式为

{{sdsc begin}}
{{sdsc|{{ttb|*}}{{spar|表达式}}}} 
{{sdsc end}}

内建间接寻址运算符的操作数必须是对象指针或函数指针，它的结果就是{{spar sep|表达式}}指向的对象或函数。如果{{spar sep|表达式}}实际上没有指向对象或函数，那么行为未定义（{{rlpt|typeid}} 指定的情况除外）。

指向（可有 {{rlp|cv}} 限定）的 {{c/core|void}} 的指针不能解引用。指向其他不完整类型的指针可以解引用，但产生的左值只能在允许不完整类型的语境中使用，例如初始化一个引用。

在{{rlp|overload resolution#调用重载运算符|对于用户定义运算符的重载决议}}中，对于每个要么是（可有 cv 限定的）对象类型要么是（未被 const 或引用限定的）函数类型的类型 {{tt|T}}，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|T&amp; operator*(T*);}}
{{dcl end}}

{{example
|code=
#include &lt;iostream&gt;

int f() { return 42; }

int main()
{
    int n = 1;
    int* pn = &amp;n;
    
    int&amp; r = *pn; // 左值可以绑定到引用
    int m = *pn;  // 间接寻址 + 左值到右值转换
    
    int (*fp)() = &amp;f;
    int (&amp;fr)() = *fp; // 函数左值可以绑定到引用

    [](...){}(r, m, fr); // 移除可能的“未使用变量”警告
}
}}

====内建的取地址运算符====
取地址运算符表达式的形式为

{{sdsc begin}}
{{sdsc|num=1|{{ttb|&amp;}}{{spar|表达式}}}} 
{{sdsc|num=2|{{ttb|&amp;}}{{spar sep|类}}{{ttb|::}}{{spar|成员}}}} 
{{sdsc end}}

@1@ 当操作数是某个对象或函数类型 {{tt|T}} 的左值表达式时，{{c/core|operator&amp;}} 创建并返回一个有相同 cv 限定的 {{tt|T*}} 类型的纯右值，并指向由该操作数所代表的对象或函数。当它的操作数具有不完整类型时，可以构成指针，但如果该不完整类型恰好是某个定义了它自身的 {{c/core|operator&amp;}} 的类，那么使用内建还是重载运算符是未指明的。对于类型带有用户定义的 {{c/core|operator&amp;}} 的操作数，可以使用 {{lc|std::addressof}} 来获取真正的指针。注意，这和 C99 以及之后的 C 语言版本不同，不存在对一元 {{c/core|operator*}} 运算符的运算结果应用一元 {{c/core|operator&amp;}} 运算符的特殊情况。
@@ 当它的操作数是重载函数的名字时，仅当根据它的语境可以解析这个重载时才能取得它的地址。详细说明参见{{rlp|overloaded address|重载函数的地址}}。
{{rrev|since=c++23|
如果{{spar sep|表达式}}命名了{{rlp|member functions|显式对象成员函数}}，那么{{spar sep|表达式}}必须是{{rlp|identifiers#有限定的标识符|有限定标识符}}。对命名了显式对象成员函数的无限定标识符应用 {{tt|&amp;}} 非良构。
}}
@2@ 当它的操作数是{{rev inl|since=c++23|{{rlp|member functions|显式对象成员函数}}以外的}}非静态或{{rlp|union#联合体式的类|变体}}成员的限定名（比如 {{c|&amp;C::member}}）时，它的结果是 {{tt|C}} 类中的 {{tt|T}} 类型的{{rlps|pointer#成员函数指针}}或{{rlps|pointer#数据成员指针}}的纯右值。注意，{{c|&amp;member}}、{{c|C::member}}，甚至 {{c|&amp;(C::member)}} 都不能用来初始化成员指针。

在{{rlp|overload resolution#调用重载运算符|对于用户定义运算符的重载决议}}中，此运算符不引入任何额外函数签名：如果存在作为{{rlps|overload resolution#可行函数}}的重载 {{c/core|operator&amp;}}，那么内建的取址运算符不适用。

{{example
|code=
void f(int) {}
void f(double) {}

struct A { int i; };
struct B { void f(); };

int main()
{
    int n = 1;
    int* pn = &amp;n;    // 指针
    int* pn2 = &amp;*pn; // pn2 == pn
    
    int A::* mp = &amp;A::i;      // 指向数据成员的指针
    void (B::*mpf)() = &amp;B::f; // 指向成员函数的指针
    
    void (*pf)(int) = &amp;f; // 根据初始化语境进行重载决议
//  auto pf2 = &amp;f; // 错误：重载函数类型有歧义
    auto pf2 = static_cast&lt;void (*)(int)&gt;(&amp;f); // 由于转型进行重载决议
}
}}

====内建的成员访问运算符====
成员访问运算符表达式的形式为

{{sdsc begin}}
{{sdsc|num=1|{{spar sep|表达式}}{{ttb|.template}}{{mark optional}} {{spar|标识表达式}}}} 
{{sdsc|num=2|{{spar sep|表达式}}{{ttb|-&gt;template}}{{mark optional}} {{spar|标识表达式}}}} 
{{sdsc|num=3|{{spar sep|表达式}}{{ttb|.}}{{spar|伪析构函数}}}} 
{{sdsc|num=4|{{spar sep|表达式}}{{ttb|-&gt;}}{{spar|伪析构函数}}}} 
{{sdsc end}}

@1@ {{spar sep|表达式}}必须是{{rlp|type#不完整类型|完整}}类类型 {{tt|T}} 的表达式。
@@ 如果{{spar sep|标识表达式}}命名了{{rlp|static|静态成员}}或{{rlp|enum|枚举项}}，那么{{spar sep|表达式}}是{{rlps|expressions#弃值表达式}}。

@2@ {{spar sep|表达式}}必须是指向完整类类型的指针 {{tt|T*}} 的表达式。

@3,4@ {{spar sep|表达式}}必须是标量类型表达式（见下文）。

{{spar sep|标识表达式}}是 {{tt|T}} 或 {{tt|T}} 的某个无歧义且可访问的基类 {{tt|B}} 的数据成员或成员函数的名字（正式的说法是{{rlp|identifiers#在表达式中|标识表达式}}）（如 {{c|E1.E2}} 或 {{c|E1-&gt;E2}}），并可选地{{rlp|identifiers#有限定的标识符|有限定}}（如 {{c|E1.B::E2}} 或 {{c|E1-&gt;B::E2}}），并可以使用 {{rlp|dependent name#template 歧义消解符|{{c/core|template}} 歧义消解符}}（如 {{c|E1.template E2}} 或 {{c|E1-&gt;template E2}}）。

如果提供的是用户定义的 {{c/core|operator-&gt;}}，那么递归地对它的所返回的值再次调用 {{c/core|operator-&gt;}}，直到到达返回普通指针的 {{c/core|operator-&gt;}} 为止。之后再对这个指针采用内建语义。

对于内建类型，表达式 {{c|E1-&gt;E2}} 与 {{c|(*E1).E2}} 严格等价；因此以下规则只处理 {{c|E1.E2}} 的情形。

在表达式 {{c|E1.E2}} 中：
@1@ 当 {{c|E2}} 是{{rlp|static|静态数据成员}}时：
* 如果 {{c|E2}} 具有引用类型 {{tt|T&amp;}} {{rev inl|since=c++11|或 {{tt|T&amp;&amp;}}}}，那么它的结果是 {{tt|T}} 类型的左值，代表该引用绑定到的对象或函数。
* 否则，给定 {{c|E2}} 的类型为 {{tt|T}}，它的结果是 {{tt|T}} 类型的代表该静态数据成员的左值。
@@ 基本上，这两种情况下 {{c|E1}} 均被求值，随即被丢弃。
@2@ 当 {{c|E2}} 是{{rlp|data members|非静态数据成员}}时：
* 如果 {{c|E2}} 具有引用类型 {{tt|T&amp;}} {{rev inl|since=c++11|或 {{tt|T&amp;&amp;}}}}，那么它的结果是 {{tt|T}} 类型的左值，代表 {{c|E1}} 的对应引用成员绑定到的对象或函数，
* 否则，如果 {{c|E1}} 是左值，那么它的结果是代表 {{c|E1}} 的这个非静态数据成员的左值。
* 否则（{{c|E1}} 是{{rev inl|until=c++17|右值}}{{rev inl|since=c++17|亡值（可能是从纯右值{{rlp|implicit conversion#临时量实质化|实质化}}而来）}}），它的结果是代表 {{c|E1}} 的这个非静态数据成员的{{rev inl|until=c++11|右值}}{{rev inl|since=c++11|亡值}}。
@@ 如果 {{c|E2}} 不是 {{rlp|cv#mutable 说明符|mutable}} 成员，那么结果的 {{rlp|cv|cv 限定性}}是 {{c|E1}} 和 {{c|E2}} 的 cv 限定性的合并，否则（{{c|E2}} 是 mutable 成员）是 {{c|E1}} 和 {{c|E2}} 的 volatile 限定性的合并。
@3@ 当 {{c|E2}} 是（包含一个或多个{{rlp|static|静态成员函数}}和{{rlp|member functions|非静态成员函数}}的重载集）时，{{c|E1.E2}} 只能用作{{rlp|operator other#内建的函数调用运算符|成员函数调用运算符}}的左操作数（可以被圆括号包围），并且{{rlp|overload resolution#调用具名函数|函数重载决议}}会用来选择 {{c|E2}} 指代的是哪个函数，之后：
* 当 {{c|E2}} 是静态成员函数时，{{c|E1.E2}} 的结果是代表该静态成员函数的左值。基本上，这种情况下 {{c|E1}} 被求值，随即被丢弃。
* 否则（当 {{c|E2}} 是非静态成员函数时），{{c|E1.E2}} 的结果是代表 {{c|E1}} 的这个非静态成员函数纯右值。
@4@ 当 {{c|E2}} 是成员枚举项时，给定 {{c|E2}} 的类型为 {{tt|T}}，它的结果是 {{tt|T}} 类型的{{rev inl|until=c++11|右值}}{{rev inl|since=c++11|纯右值}}，该结果的值是该枚举项的值；
@5@ 当 {{c|E2}} 是{{rlp|nested classes|嵌套类型}}时，程序非良构（无法编译）；
@6@ 当 {{c|E1}} 是{{named req|ScalarType}}而 {{c|E2}} 是一个 {{ttb|~}} 之后跟着代表（移除 cv 限定后）相同类型的{{rlp|type#类型的命名|类型名}}或 {{rlp|decltype|decltype 说明符}}，可选地{{rlp|identifiers#有限定的标识符|有限定}}时，它的结果是一种特殊的纯右值，它只能用作函数调用运算符的左操作数，而不能用于其他目的。
@@ 所构成的函数调用表达式被称为''伪析构函数调用''。它不接受任何实参，返回 {{c/core|void}}，求值 {{c|E1}} 后结束它的结果对象的生存期&lt;!-- P0593R6 --&gt;。这是唯一使 {{c/core|operator.}} 的左操作数具有非类类型的情形。允许进行伪析构函数调用，使得编写代码时无须了解某个给定类型是否存在析构函数成为可能。

{{c/core|operator.}} 不能重载，而对于 {{c/core|operator-&gt;}} 来说，在{{rlp|overload resolution#调用重载运算符|对于用户定义运算符的重载决议}}中，内建运算符不引入任何额外函数签名：如果存在作为{{rlp|overload resolution#可行函数|可行函数}}的重载 {{c/core|operator&amp;}}，那么不会采用内建的 {{c/core|operator-&gt;}}。

{{example
|code=
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;

struct P
{
    template&lt;typename T&gt;
    static T* ptr() { return new T; }
};

template&lt;typename T&gt;
struct A
{
    A(int n): n(n) {}
    
    int n;
    static int sn;
    
    int f() { return 10 + n; }
    static int sf() { return 4; }
    
    class B {};
    enum E {RED = 1, BLUE = 2};
    
    void g()
    {
        typedef int U;
        
        // 待决的模板成员需要关键词 template
        int* p = P().template ptr&lt;U&gt;();
        p-&gt;~U(); // U 是 int，调用 int 的伪析构函数
        delete p;
    }
};

template&lt;&gt;
int A&lt;P&gt;::sn = 2;
 
struct UPtrWrapper
{
    std::unique_ptr&lt;std::string&gt; uPtr;
    std::unique_ptr&lt;std::string&gt;&amp; operator-&gt;() { return uPtr; }
};

int main()
{
    A&lt;P&gt; a(1);
    std::cout &lt;&lt; a.n &lt;&lt; ' '
              &lt;&lt; a.sn &lt;&lt; ' '   // A::sn 也可以
              &lt;&lt; a.f() &lt;&lt; ' ' 
              &lt;&lt; a.sf() &lt;&lt; ' ' // A::sf() 也可以
//            &lt;&lt; &amp;a.f &lt;&lt; ' '   // 错误：a.f 在作为 operator() 的
                               // 左操作数以外的情况下非良构
//            &lt;&lt; a.B &lt;&lt; ' '    // 错误：不允许嵌套类型
              &lt;&lt; a.RED &lt;&lt; ' '; // 枚举项
    
    UPtrWrapper uPtrWrap{std::make_unique&lt;std::string&gt;("wrapped")};
    assert(uPtrWrap-&gt;data() == uPtrWrap.operator-&gt;().operator-&gt;()-&gt;data());
}
|output=
1 2 11 4 1
}}

如果 {{c|E2}} 是非静态成员，并且 {{c|E1}} 的结果是一个对象，那么在 {{c|E1}} 的类型与 {{c|E1}} 的结果对象类型不{{rlp|implicit conversion#相似类型|相似}}时行为未定义：
{{source|
struct A { int i; };
struct B { int j; };
struct D : A, B {};

void f()
{
    D d;
    static_cast&lt;B&amp;&gt;(d).j;      // OK，对象表达式表示的是 d 的 B 子对象
    reinterpret_cast&lt;B&amp;&gt;(d).j; // 未定义行为
}
}}

====内建的成员指针访问运算符====
通过成员指针进行的成员访问运算符表达式的形式为

{{sdsc begin}}
{{sdsc|num=1|{{spar sep|左操作数}}{{ttb|.*}}{{spar|右操作数}}}} 
{{sdsc|num=2|{{spar sep|左操作数}}{{ttb|-&gt;*}}{{spar|右操作数}}}} 
{{sdsc end}}
@1@ {{spar sep|左操作数}}必须是类类型 {{tt|T}} 的表达式。
@2@ {{spar sep|左操作数}}必须是指向类类型指针 {{tt|T*}} 的表达式。

{{spar sep|右操作数}}必须是指向 {{tt|T}} 的（{{rlp|pointer#数据成员指针|数据}}或{{rlp|pointer#成员函数指针|函数}}）成员指针右值，或者是指向 {{tt|T}} 的无歧义且可访问基类 {{tt|B}} 成员指针右值。

对于内建类型，表达式 {{c|E1-&gt;*E2}} 严格等价于 {{c|(*E1).*E2}}；因此以下规则只处理了 {{c|E1.*E2}} 的情形。

在表达式 {{c|E1.*E2}} 中：
@1@ 当 {{c|E2}} 是指向数据成员的指针时，
* 如果 {{c|E1}} 是左值，那么它的结果是代表这个成员的左值，
* 否则（{{c|E1}} 是{{rev inl|until=c++17|右值}}{{rev inl|since=c++17|亡值（可能是从纯右值{{rlp|implicit conversion#临时量实质化|实质化}}而来）}}），它的结果是代表这个数据成员的{{rev inl|until=c++11|右值}}{{rev inl|since=c++11|亡值}}；
@2@ 当 {{c|E2}} 是指向成员函数的指针时，它的结果是代表这个成员函数的一种特殊的纯右值，它只能用作成员函数调用运算符的左运算数，而不能用于其他目的；
@3@ cv 限定性的规则与对象的成员运算符相同，但有一条额外规则：指代 mutable 成员的成员指针不能用于改动 const 对象中的这个成员；
@4@ 当 {{c|E2}} 是空成员指针值时，行为未定义；
@5@ 当 {{c|E1}} 的结果是一个对象，并且该对象的类型与 {{c|E1}} 的类型不{{rlp|implicit conversion#相似类型|相似}}或该对象的{{rlp|object#子对象|最终派生对象}}没有包含 {{c|E2}} 指代的成员时，行为未定义；
@6@ 当 {{c|E1}} 是右值而 {{c|E2}} 指向带有引用限定符 {{tt|&amp;}} 的成员函数时，程序非良构{{rev inl|since=c++20|，除非该成员函数的 cv 限定符有 {{c/core|const}} 而没有 {{c/core|volatile}}}}；

{{rrev|since=c++11|
@7@ 当 {{c|E1}} 是左值而 {{c|E2}} 指向带有引用限定符 {{tt|&amp;&amp;}} 的成员函数时，程序非良构。
}}

在{{rlp|overload resolution#调用重载运算符|对于用户定义运算符的重载决议}}中，对于每个类型 {{tt|D}}, {{tt|B}}, {{tt|R}} 的组合，其中类类型 {{tt|B}} 是与 {{tt|D}} 相同的类或 {{tt|D}} 的无歧义且可访问基类，而 {{tt|R}} 是对象或函数类型，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|R&amp; operator-&gt;*(D*, R B::*);}}
{{dcl end}}
其中两个操作数都可以有 cv 限定，此时返回类型的 cv 限定性是个操作数的 cv 限定性的合并。

{{example
|code=
#include &lt;iostream&gt;

struct S
{
    S(int n): mi(n) {}
    mutable int mi;
    int f(int n) { return mi + n; }
};

struct D: public S
{
    D(int n): S(n) {}
};

int main()
{
    int S::* pmi = &amp;S::mi;
    int (S::* pf)(int) = &amp;S::f;
    
    const S s(7);
//  s.*pmi = 10; // 错误：无法通过 mutable 进行修改
    std::cout &lt;&lt; s.*pmi &lt;&lt; '\n';
    
    D d(7); // 基类的指针可以在派生类对象上工作
    D* pd = &amp;d;
    std::cout &lt;&lt; (d.*pf)(7) &lt;&lt; ' '
              &lt;&lt; (pd-&gt;*pf)(8) &lt;&lt; '\n';
}
|output=
7
14 15
}}

===标准库===
许多标准容器类都重载了下标运算符：
{{dsc begin}}
{{dsc inc|cpp/utility/bitset/dsc operator at}}
{{dsc inc|cpp/memory/unique_ptr/dsc operator at}}
{{dsc inc|cpp/string/basic_string/dsc operator at}}
{{dsc inc|cpp/container/dsc operator at|array}}
{{dsc inc|cpp/container/dsc operator at|deque}}
{{dsc inc|cpp/container/dsc operator at|vector}}
{{dsc inc|cpp/container/dsc operator at|map}}
{{dsc inc|cpp/container/dsc operator at|unordered_map}}
{{dsc inc|cpp/iterator/reverse_iterator/dsc operator at}}
{{dsc inc|cpp/iterator/adaptor/dsc operator at|move_iterator}}
{{dsc inc|cpp/numeric/valarray/dsc operator at}}
{{dsc inc|cpp/regex/match_results/dsc operator at}}
{{dsc end}}

许多迭代器和智能指针类都重载了间接寻址和成员运算符：
{{dsc begin}}
{{dsc inc|cpp/memory/unique_ptr/dsc operator*}}
{{dsc inc|cpp/memory/shared_ptr/dsc operator*}}
{{dsc inc|cpp/memory/auto_ptr/dsc operator*}}
{{dsc inc|cpp/memory/raw_storage_iterator/dsc operator*}}
{{dsc inc|cpp/iterator/reverse_iterator/dsc operator*}}
{{dsc inc|cpp/iterator/inserter/dsc operator*|back_insert_iterator}}
{{dsc inc|cpp/iterator/inserter/dsc operator*|front_insert_iterator}}
{{dsc inc|cpp/iterator/inserter/dsc operator*|insert_iterator}}
{{dsc inc|cpp/iterator/adaptor/dsc operator*|move_iterator}}
{{dsc inc|cpp/iterator/istream_iterator/dsc operator*}}
{{dsc inc|cpp/iterator/ostream_iterator/dsc operator*}}
{{dsc inc|cpp/iterator/istreambuf_iterator/dsc operator*}}
{{dsc inc|cpp/iterator/ostreambuf_iterator/dsc operator*}}
{{dsc inc|cpp/regex/regex_iterator/dsc operator*}}
{{dsc inc|cpp/regex/regex_token_iterator/dsc operator*}}
{{dsc end}}

标准库中的类都没有重载 {{c/core|operator&amp;}}。最为人所知的重载 {{c/core|operator&amp;}} 的例子是微软的 COM 类 [http://msdn.microsoft.com/en-us/library/31k6d0k7(v=vs.100).aspx CComPtr]，但在如 [http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/reference/operator/and_predicate.html boost.spirit] 这样的 EDSL 中也会出现重载它的例子。

标准库中的类都没有重载 {{c/core|operator-&gt;*}}。曾有建议将它作为[http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf 智能指针接口]的一部分，并在 [http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator boost.phoenix] 中的 actor 上有实际应用，但它在如 [https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557 cpp.react] 这样的 EDSL 中更为常见。

===注解===
{{feature test macro|std=C++23|value=202110L|__cpp_multidimensional_subscript|[[cpp/language/operators#Array subscript operator|多维下标运算符]]}}

===缺陷报告===
{{dr list begin}}
&lt;!-- CWG 2725 的解决方案也解决了 CWG 1038 --&gt;
{{dr list item|wg=cwg|dr=1213|std=C++11|before=数组右值的下标操作导致左值|after=重分类为亡值}}
{{dr list item|wg=cwg|dr=1458|std=C++98|before=应用 {{tt|&amp;}} 到声明 {{c/core|operator&amp;}} 的不完整类型左值导致未定义行为|after=未指明使用哪个 {{tt|&amp;}}}}
{{dr list item|wg=cwg|dr=1642|std=C++98|before=内建的成员指针访问运算符的{{spar sep|右操作数}}可以是左值|after=只能是右值}}
{{dr list item|wg=cwg|dr=1800|std=C++98|before=当应用 {{tt|&amp;}} 到成员匿名联合体的非静态数据成员时，&lt;br&gt;不明确该匿名联合体是否会参与结果类型|after=结果类型不含匿名联合体}}
{{dr list item|wg=cwg|dr=2614|std=C++98|before={{c|E2}} 是引用成员或枚举项的情况下 {{c|E1.E2}} 的结果不明确|after=使之明确}}
{{dr list item|wg=cwg|dr=2725|std=C++98|before=如果 {{c|E2}} 是静态成员函数，那么 {{c|E1.E2}} 即使不是 {{c/core|operator()}} 的左操作数也良构|after=此时 {{c|E1.E2}} 非良构}}
{{dr list item|wg=cwg|dr=2748|std=C++98|before=在 {{c|E1}} 是空指针且 {{c|E2}} 指代静态成员时，{{c|E1-&gt;E2}} 的行为不明确|after=此时行为未定义}}
{{dr list item|wg=cwg|dr=2813|std=C++98|before=在 {{c|E1.E2}} 命名了静态成员或枚举项时 {{c|E1}} 不是弃值表达式|after=它是弃值表达式}}
{{dr list item|wg=cwg|dr=2823|std=C++98|before=在 {{c|expr}} 没有指向对象或函数时 {{c|*expr}} 的行为不明确|after=使之明确}}
{{dr list end}}

===参阅===
{{rlp|operator precedence|运算符优先级}}

{{rlp|operators|运算符重载}}

{{cpp/language/operators}}
{{dsc begin}}
{{dsc see c|c/language/operator member access|成员访问运算符|nomono=true}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}