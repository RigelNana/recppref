{{title|基础类型}}
{{cpp/language/basics/navbar}}

{{petty|（类型系统概览见{{rlp|type|类型}}，以及参阅 C++ 库提供的[[cpp/types|类型相关的工具列表]]）}}

T以下类型统称为''基础类型''：
* （可有 cv 限定的）{{c/core|void}}
{{rrev|since=c++11|
* （可有 cv 限定的）{{lc|std::nullptr_t}}
}}
* [[#整数类型|整数类型]]
* [[#浮点数类型|浮点数类型]]

{{anchor|void}}
==={{c/core|void}}===
:{{c/core|void}} - 值集为空的类型。它是无法变为完整的{{rlp|type#不完整类型|不完整类型}}（从而不允许存在 {{c/core|void}} 类型的对象）。不存在含有 {{c/core|void}} 的{{rlp|array|数组}}以及到 {{c/core|void}} 的{{rlp|reference|引用}}。然而存在{{rlp|pointer#void 的指针|指向 {{c/core|void}} 的指针}}和返回 {{c/core|void}} 类型的{{rlp|function|函数}}（其他语言中的''过程''）。

{{rrev|since=c++11|
{{anchor|nullptr_t}}
==={{lc|std::nullptr_t}}===
{{dcl begin}}
{{dcl header|cstddef}}
{{dcl|since=c++11|
typedef decltype(nullptr) nullptr_t;
}}
{{dcl end}}

{{lc|std::nullptr_t}} 是空指针字面量 {{rlpt|nullptr}} 的类型。它是独立的类型，既不是指针类型，也不是成员指针类型。它的所有纯右值都是{{rlp|pointer#空指针|空指针常量}}。

{{c|sizeof(std::nullptr_t)}} 等于 {{c|sizeof(void*)}}。
}}

===整数类型===
====标准整数类型====
:{{c/core|int}} - 基本整数类型。如果使用了下列任何修饰符就可以省略关键词 {{c/core|int}}。如果没有长度修饰符，那么它保证拥有至少 16 位宽度。然而在 32/64 位系统上，几乎专门保证它拥有至少 32 位宽度（见后述）。

=====修饰符=====
修饰整数类型。能以任何顺序混合使用。类型名中每组只能有一个。

* 符号性
:{{c/core|signed}} - 目标类型将拥有有符号表示（默认符号性）
:{{c/core|unsigned}} - 目标类型将拥有无符号表示
* 大小
:{{c/core|short}} - 目标类型将为空间优化，且将有至少 16 位的宽度。
:{{c/core|long}} - 目标类型将有至少 32 位的宽度。
{{rrev|since=c++11|
{{anchor|long long}}
:{{c/core|long long}} - 目标类型将有至少 64 位的宽度。
}}

注意：与所有类型说明符相同，允许采用任何顺序：{{c/core|unsigned long long int}} 与 {{c/core|long int unsigned long}} 指名同一类型。

{{anchor|整数性质}}
=====性质=====
下表总结了所有可用的标准整数类型及它们在各种常用数据模型中的性质：

{| class="wikitable" style="text-align:center;"
|-
! rowspan="2" | 类型说明符
! rowspan="2" | 等价类型
! colspan="5" | 按[[#数据模型|数据模型]]的位宽
|-
&lt;!-- --&gt;
&lt;!-- --&gt;
! C++ 标准
! LP32
! ILP32
! LLP64
! LP64
|-
| {{left|{{c/core|signed char}}}}
| {{c/core|signed char}}
| rowspan="2" | 至少 '''8'''
| rowspan="2" | '''8'''
| rowspan="2" | '''8'''
| rowspan="2" | '''8'''
| rowspan="2" | '''8'''
|-
| {{left|{{c/core|unsigned char}}}}
| {{c/core|unsigned char}}
|-
| {{left|{{c/core|short}}}}
| rowspan="4" | {{c/core|short int}}
| rowspan="6" | 至少 '''16'''  
| rowspan="6" | '''16'''  
| rowspan="6" | '''16'''  
| rowspan="6" | '''16'''  
| rowspan="6" | '''16'''  
|-
| {{left|{{c/core|short int}}}}
|-
| {{left|{{c/core|signed short}}}}
|-
| {{left|{{c/core|signed short int}}}}
|-
| {{left|{{c/core|unsigned short}}}}
| rowspan="2" | {{c/core|unsigned short int}}
|-
| {{left|{{c/core|unsigned short int}}}}
|-
| {{left|{{c/core|int}}}}
| rowspan="3" | {{c/core|int}}  
| rowspan="5" | 至少 '''16'''  
| rowspan="5" | '''16'''  
| rowspan="5" | '''32'''  
| rowspan="5" | '''32'''  
| rowspan="5" | '''32''' 
|-
| {{left|{{c/core|signed}}}}
|-
| {{left|{{c/core|signed int}}}}
|-
| {{left|{{c/core|unsigned}}}}
| rowspan="2" | {{c/core|unsigned int}}
|-
| {{left|{{c/core|unsigned int}}}}
|-
| {{left|{{c/core|long}}}}
| rowspan="4" | {{c/core|long int}}  
| rowspan="6" | 至少 '''32'''  
| rowspan="6" | '''32'''  
| rowspan="6" | '''32'''  
| rowspan="6" | '''32'''  
| rowspan="6" | '''64'''  
|-
| {{left|{{c/core|long int}}}}
|-
| {{left|{{c/core|signed long}}}}
|-
| {{left|{{c/core|signed long int}}}}
|-
| {{left|{{c/core|unsigned long}}}}
| rowspan="2" | {{c/core|unsigned long int}}
|-
| {{left|{{c/core|unsigned long int}}}}
|-
| {{left|{{c/core|long long}}}}
| rowspan="4" | {{c/core|long long int}}&lt;br&gt;{{mark c++11}}
| rowspan="6" | 至少 '''64'''  
| rowspan="6" | '''64'''  
| rowspan="6" | '''64'''  
| rowspan="6" | '''64'''  
| rowspan="6" | '''64'''  
|-
| {{left|{{c/core|long long int}}}}
|-
| {{left|{{c/core|signed long long}}}}
|-
| {{left|{{c/core|signed long long int}}}}
|-
| {{left|{{c/core|unsigned long long}}}}
| rowspan="2" | {{c/core|unsigned long long int}}&lt;br&gt;{{mark c++11}}
|-
| {{left|{{c/core|unsigned long long int}}}}
|}

注意：整数算术对有符号和无符号整数类型的定义是不同的。见{{rlp|operator arithmetic|算术运算符}}，特别是{{rlp|operator arithmetic#溢出|整数溢出}}。

{{lc|std::size_t}} 是 {{rlpt|sizeof}} 运算符{{rev inl|since=c++11|还有 {{rlpt|sizeof...}} 运算符及 {{rlpt|alignof}} 运算符}}的结果的无符号整数类型。

{{rrev|since=c++11|
====扩展整数类型====
扩展整数类型由实现定义。注意[[cpp/types/integer|定宽整数类型]]典型情况下是标准整数类型的别名。
}}

====布尔类型====
:{{c/core|bool}} - 足以存放两个值 {{rlpt|bool literal|true}} 或 {{rlpt|bool literal|false}} 之一的整数类型。{{c|sizeof(bool)}} 的值由实现定义，而且不一定是 {{c|1}}。

====字符类型====
字符类型是用于表示字符的整数类型。
:{{c/core|signed char}} - 有符号字符表示的类型。
:{{c/core|unsigned char}} - 无符号字符表示的类型。也会用来审查{{rlp|object|对象表示}}（无修饰内存）。
:{{c/core|char}} - 能在目标系统上最有效地处理的字符表示的类型（拥有与 {{c/core|signed char}} 或 {{c/core|unsigned char}} 之一相同的表示和对齐，但始终是独立的类型）。[[cpp/string/multibyte|多字节字符串]]用此类型表示编码单元。{{rev inl|since=c++11|对于每个范围 {{closed range|0|255}} 中的 {{c/core|unsigned char}} 类型值，将该值转换成 {{c/core|char}} 再转换回 {{c/core|unsigned char}} 产生原值。}} {{c/core|char}} 的符号性取决于编译器和目标平台：ARM 和 PowerPC 的默认设置通常为无符号，而 x86 与 x64 的默认设置通常有符号。
:{{c/core|wchar_t}} - 宽字符表示的类型（见[[cpp/string/wide|宽字符串]]）。它与上述整数类型之一具有相同的大小、符号性和对齐，但它是独立的类型。实践中，它在 Linux 与许多其他非 Windows 系统上为 32 位并保有 UTF-32，但在 Windows 上为 16 位并保有 UTF-16 编码单元。标准曾要求 {{c/core|wchar_t}} 足够大以保有任何受支持的字符码位。然而该要求无法在 Windows 上满足，从而它被视为[[#缺陷报告|缺陷]]并被移除。
{{rrev|since=c++11|
{{anchor|char16_t}}
:{{c/core|char16_t}} - UTF-16 字符表示的类型，要求大到足以表示任何 UTF-16 编码单元（16 位）。它与 {{lc|std::uint_least16_t}} 具有相同的大小、符号性和对齐，但它是独立的类型。
{{anchor|char32_t}}
:{{c/core|char32_t}} - UTF-32 字符表示的类型，要求大到足以表示任何 UTF-32 编码单元（32 位）。它与 {{lc|std::uint_least32_t}} 具有相同的大小、符号性和对齐，但它是独立的类型。
}}
&lt;p&gt;
{{rrev|since=c++20|
{{anchor|char8_t}}
:{{c/core|char8_t}} - UTF-8 字符表示的类型，要求大到足以表示任何 UTF-8 编码单元（8 位）。它与 {{c/core|unsigned char}} 具有相同的大小、符号性和对齐（从而与 {{c/core|char}} 和 {{c/core|signed char}} 具有相同的大小和对齐），但它是独立的类型。
}}

除了最小位数，C++ 标准还保证
:{{c|1}} {{c/core|1===}} {{c|sizeof(char)}} {{tt|&amp;le;}} {{c|sizeof(short)}} {{tt|&amp;le;}} {{c|sizeof(int)}} {{tt|&amp;le;}} {{c|sizeof(long)}} {{tt|&amp;le;}} {{c|sizeof(long long)}}.

注意：这允许一种极端情况，其中{{enwiki|Byte|字节}}有 64 位大小，所有类型（包括 {{c/core|char}}）都有 64 位宽，而 {{c/core|sizeof}} 对每个类型均返回 {{c|1}}。

===浮点数类型===
====标准浮点数类型====
下列三种类型和它们的 cv 限定版本统称为标准浮点数类型。

:{{c/core|float}} - 单精度浮点数类型。通常是 {{enwiki|Single-precision floating-point format|IEEE-754 binary32 格式}}。
:{{c/core|double}} - 双精度浮点数类型。通常是 {{enwiki|Double-precision floating-point format|IEEE-754 binary64 格式}}。
:{{c/core|long double}} - 扩展精度浮点数类型。不必映射到 IEEE-754 规定的类型。
:* 一些 HP-UX、SPARC、MIPS、ARM64 和 z/OS 实现使用 {{enwiki|Quadruple-precision floating-point format|IEEE-754 binary128 格式}}。
:* 最知名的 {{enwiki|Extended precision|IEEE-754 binary64 扩展格式}}是 80 位 x87 扩展精度格式。许多 x86 和 x86-64 实现使用它（一个典型的例外是 MSVC，它将 {{c/core|long double}} 实现为与 {{c/core|double}} 相同的格式，即 binary64）。
:* 在 PowerPC 上可以使用 {{enwiki|Quadruple-precision floating-point format#Double-double arithmetic|double-double}}。

{{rrev|since=c++23|
====扩展浮点数类型====
扩展浮点数类型由实现定义。可能会包含[[cpp/types/floating-point|定宽浮点数类型]]。
}}

{{anchor|浮点数性质}}
====性质====
浮点数类型可以支持一些[[cpp/types/numeric limits|特殊值]]：
* ''无穷''（正和负），见 {{lc|INFINITY}}
* ''负零''，{{c|-0.0}}。它与正零比较相等，但在某些算术运算中有意义，例如 {{c|1=1.0 / 0.0 == INFINITY}}，但 {{c|1=1.0 / -0.0 == -INFINITY}})，而且对某些数学函数有意义，例如 {{ltt|cpp/numeric/complex/sqrt|sqrt{{small|(std::complex)}}}}
* ''非数''（NaN），它与任何值（包括自身）比较都不相等。多个位模式都表示 NaN，见 {{lc|std::nan}}、{{lc|NAN}}。注意 C++ 并不会对发信 NaN 进行特殊对待，它会把所有 NaN 都当做静默 NaN，但提供了 {{lc|std::numeric_limits::has_signaling_NaN}} 用以检测它们的支持情况。

浮点数可以使用{{rlp|operator arithmetic|算术运算符}} + - / * 和各种来自 {{header|cmath}} 的数学函数。内建运算符和库函数都可能会引发浮点数异常，并按 {{ltt|cpp/numeric/math/math errhandling}} 中的描述设置 {{lc|errno}}。

浮点数表达式可以拥有大于它的类型所指定的值域和精度，见 {{lc|FLT_EVAL_METHOD}}。浮点数表达式也可以''收缩''，即在计算时将所有中间值视为拥有无限范围和精度，见 {{ltt|cpp/preprocessor/impl##pragma STDC|#pragma STDC FP_CONTRACT}}。标准 C++ 不限制浮点数操作的准确度。

浮点数上的某些运算受[[cpp/numeric/fenv|浮点数环境]]的状态影响，并可以对它进行修改（最值得注意的是舍入方向）。

在浮点数类型和整数类型间定义了{{rlp|implicit conversion|隐式转换}}。

浮点数类型的其他细节、界限和性质见{{ls|cpp/types/climits#浮点数类型的界限}}和 {{lc|std::numeric_limits}}。

===取值范围===
下表提供常用数值表示的界限的参考。

C++20 之前，C++ 标准曾允许任意的有符号整数表示，而 N 位有符号整数的最小保证范围从 {{mathjax-or|\(\scriptsize -(2^{N-1}-1)\)|-(2{{su|p=N-1}}-1)}} 到 {{mathjax-or|\(\scriptsize +2^{N-1}-1\)|+2{{su|p=N-1}}-1}}（例如有符号 8 位类型是 '''-127''' 到 '''127'''），这与{{enwiki|One's complement|反码}}或{{enwiki|Signed number representations#Sign-and-magnitude method|原码}}的界限对应。

然而，所有 C++ 编译器均使用{{enwiki|Two's complement|补码}}表示，而从 C++20 起，这是标准所允许的唯一表示，所保证的范围从 {{mathjax-or|\(\scriptsize -2^{N-1}\)|-2{{su|p=N-1}}}} 到 {{mathjax-or|\(\scriptsize +2^{N-1}-1\)|+2{{su|p=N-1}}-1}}（例如有符号 8 位类型是 '''-128''' 到 '''127'''）。

C++11 起（由于 {{cwg|1759}} 的解决方案）{{c/core|char}} 不能再由 8 位反码与原码表示，因为用于 {{rlp|string literal|UTF-8 字符串字面量}}的值为 0x80 的 UTF-8 编码单元必须能在 {{c/core|char}} 类型对象中存储。

浮点数类型 {{tt|T}} 的范围定义如下：
* 最低限度保证的范围是从 {{tt|T}} 能表示的最负有限浮点数到 {{tt|T}} 能表示的最正有限浮点数。
* 如果 {{tt|T}} 可以表示负无穷，那么 {{tt|T}} 的范围扩展到所有负实数。
* 如果 {{tt|T}} 可以表示正无穷，那么 {{tt|T}} 的范围扩展到所有正实数。

因为 [https://www.iso.org/standard/80985.html ISO/IEC/IEEE 60559] 格式可以表示正无穷和负无穷，所以遵守 ISO/IEC/IEEE 60559 的浮点数类型可以表示值的范围包含所有实数。

{{cpp/language/types/range of values}}

注意：这些类型能够表示的值的实际界限（与保证的最小界限相对）可以通过 [[cpp/types/climits|C 数值界限接口]]和 {{lc|std::numeric_limits}} 获得。

===数据模型===
各个实现关于基础类型大小所做的选择被统称为''数据模型''。有四个数据模型广为接受：

32 位系统：
:*'''LP32''' 或 '''2/4/4'''（{{c/core|int}} 是 16 位，{{c/core|long}} 和指针是 32 位）
::* Win16 API
:*'''ILP32''' 或 '''4/4/4'''（{{c/core|int}}、{{c/core|long}} 和指针是 32 位）
::* Win32 API
::* Unix 和类 Unix 系统（Linux、macOS）

64 位系统：
:* '''LLP64''' 或 '''4/4/8'''（{{c/core|int}} 和 {{c/core|long}} 是 32 位，指针是 64 位）
::* [https://learn.microsoft.com/en-us/windows/win32/desktop-programming Win32 API] (也叫 Windows API) 编译目标为 {{enwiki|AArch64|64-bit ARM}} (AArch64) 或者 x64 ({{enwiki|x86-64}})
:* '''LP64''' 或 '''4/8/8'''（{{c/core|int}} 是 32 位，{{c/core|long}} 和指针是 64 位）
::* Unix 和类 Unix 系统（Linux、macOS）

其他数据模型很罕见。例如，'''ILP64'''（'''8/8/8'''：{{c/core|int}}、{{c/core|long}} 和指针是 64 位）只会在某些早期 64 位 Unix 系统出现（例如 {{enwiki|UNICOS|UNICOS on Cray}}）。

===注解===
{{ftm begin|std=1|comment=1}}
{{ftm|value=200704L|std=C++11|__cpp_unicode_characters|新字符类型 ({{c/core|char16_t}} 和 {{c/core|char32_t}})}}
{{ftm|value=201811L|std=C++20|__cpp_char8_t|rowspan="2"|{{c/core|char8_t}}}}
{{ftm|value=202207L|std=C++23|-|{{c/core|char8_t}} 兼容性和移植性修复 (允许从 {{rlp|string literal|UTF-8 字符串字面量}}聚合初始化 {{tt|(unsigned) char}} 数组)}}
{{ftm end}}

===关键词===
{{ltt|cpp/keyword/void}}，
{{ltt|cpp/keyword/bool}}，
{{ltt|cpp/keyword/true}}，
{{ltt|cpp/keyword/false}}，
{{ltt|cpp/keyword/char}}，
{{ltt|cpp/keyword/char8_t}}，
{{ltt|cpp/keyword/char16_t}}，
{{ltt|cpp/keyword/char32_t}}，
{{ltt|cpp/keyword/wchar_t}}，
{{ltt|cpp/keyword/int}}，
{{ltt|cpp/keyword/short}}，
{{ltt|cpp/keyword/long}}，
{{ltt|cpp/keyword/signed}}，
{{ltt|cpp/keyword/unsigned}}，
{{ltt|cpp/keyword/float}}，
{{ltt|cpp/keyword/double}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=238|std=C++98|before=未指明浮点数实现会受哪些约束|after=指明不受约束}}
{{dr list item|wg=cwg|dr=1759|std=C++11|before=不保证 {{c/core|char}} 能表示 UTF-8 代码单元 0x80|after=已保证}}
{{dr list item|wg=cwg|dr=2689|std=C++11|before=有 cv 限定的 {{lc|std::nullptr_t}} 不是基础类型|after=是基础类型}}
{{dr list item|wg=cwg|dr=2723|std=C++98|before=未指定浮点数类型可表示的值的范围|after=已指定}}
{{dr list item|paper=P2460R2|std=C++98|before={{c/core|wchar_t}} 需要能够以不同代码表示所有支持的本地环境中最大的扩展字符集中的每个成员|after=不再需要}}
{{dr list end}}

===引用===
{{ref std c++23}}
{{ref std|section=6.8.2|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=6.8.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=6.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=3.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=3.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++03}}
{{ref std|section=3.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=3.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}

===参阅===
* {{rlp|type|C++ 类型系统概览}} 
* {{rlp|cv|const-volatile（cv）说明符与限定符}}
* {{rlp|storage duration|存储期说明符}}
{{dsc begin}}
{{dsc see c|c/language/arithmetic types|算术类型|nomono=true}}
{{dsc end}}

{{langlinks|ar|de|en|es|fr|it|ja|pl|pt|ru}}