{{title|模板}}
{{cpp/language/templates/navbar}}
模板是一个 C++ 实体，它定义以下其一：
* 一族类（{{rlp|class template|类模板}}），可以是{{rlp|member template|嵌套类}}
* 一族函数（{{rlp|function template|函数模板}}），可以是{{rlp|member template|成员函数}}
{{rrev|since=c++11|
* 一族类型的别名（{{rlp|type alias|别名模板}}）
}}
{{rrev|since=c++14|
* 一族变量（{{rlp|variable template|变量模板}}）
}}
{{rrev|since=c++20|
* 概念（{{rlp|constraints|约束与概念}}）
}}

模板以一个或多个{{rlp|template parameters|模板形参}}参数化，形参有三种：类型模板形参、非类型模板形参和模板模板形参。

当提供了模板实参，或当{{rlp|function template#模板参数推导|函数}}模板{{rev inl|since=c++17|或{{rlp|class template argument deduction|类}}}}模板的模板实参被推导出时，它们替换各模板形参，以获得模板的一个''特化''，即一个特定类型或一个特定函数左值。

特化也可以显式提供：对类{{rev inl|since=c++14|、变量}}和函数模板都允许{{rlp|template specialization|全特化}}，只允许对类模板{{rev inl|since=c++14|和变量模板}}{{rlp|partial specialization|部分特化}}。

在要求完整对象类型的语境中引用某个类模板特化时，或在要求函数定义存在的语境中引用某个函数模板特化时，除非模板已经被显式特化或显式实例化，否则模板即被''实例化''（它的代码被实际编译）。类模板的实例化不会实例化其任何成员函数，除非它们也被使用。在链接时，不同翻译单元生成的相同实例被合并。

模板的定义必须在隐式实例化点可见，这就是模板库通常都在头文件中提供所有模板定义的原因（例如[http://www.boost.org/doc/libs/release/more/getting_started/unix-variants.html#header-only-libraries 大多数 boost 库只有标头]）

===语法===
{{sdsc begin}}
{{sdsc|num=1|{{ttb|template &lt;}}{{spar sep|形参列表}}{{ttb|&gt;}} {{spar optional|requires子句}} {{spar|声明}}}}
{{sdsc|num=2|{{ttb|export template &lt;}}{{spar sep|形参列表}}{{ttb|&gt;}} {{spar|声明}}|notes={{mark until c++11}}}}
{{sdsc|num=3|{{ttb|template &lt;}}{{spar sep|形参列表}}{{ttb|&gt; concept}} {{spar|概念名}} {{ttb|1==}} {{spar sep|约束表达式}}{{ttb|;}}|notes={{mark since c++20}}}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|形参列表}}|非空的{{rlp|template parameters|模板形参}}的逗号分隔列表，其中每项是{{rlp|template parameters#非类型模板形参|非类型形参}}、{{rlp|template parameters#类型模板形参|类型形参}}、{{rlp|template parameters#模板模板形参|模板形参}}或任何这些的{{rlp|parameter pack|形参包}}之一。}}
{{par|{{spar|requires子句}}|{{mark since c++20}} 指定了各模板实参上的{{rlp|constraints|约束}}的 {{rlp|constraints#requires 子句|{{spar|requires子句}}}}。}}
{{par|{{spar|声明}}|{{rlp|class template|类}}，{{rlp|member template|成员类或成员枚举类型}}，{{rlp|function template|函数}}或{{rlp|member template|成员函数}}，命名空间作用域的静态数据成员，{{rev inl|since=c++14|{{rlp|variable template|变量或类作用域的静态数据成员}}，}}{{rev inl|since=c++11|或{{rlp|type alias|别名模板}}}}的声明。它也可以定义{{rlp|template specialization|模板特化}}。}}
{{par|{{spar|概念名}}&lt;br&gt;{{spar|约束表达式}}|见{{rlp|constraints|约束与概念}}}}
{{par end}}

{{rrev|until=c++11|
{{c/core|export}} 是一个可选的修饰符，声明模板''被导出''（用于类模板时，它声明该类的所有成员也被导出）。对被导出模板进行实例化的文件不需要包含其定义：有声明就足够了。{{c/core|export}} 的实现稀少而且在细节上互不一致。
}}

{{todo|核心语法，模板形参，以及实例化，带出 class_template 和 function_template 间的公共内容}}

===模板标识===
模板标识具有以下语法：
{{sdsc begin}}
{{sdsc|num=1|{{spar sep|模板名}}{{ttb|&lt;}}{{spar optional|模板实参列表}}{{ttb|&gt;}}}}
{{sdsc|num=2|{{ttb|operator}}{{spar sep|运算符}}{{ttb|&lt;}}{{spar optional|模板实参列表}}{{ttb|&gt;}}}}
{{sdsc|num=3|{{ttb|operator ""}} {{spar|标识符}} {{ttb|&lt;}}{{spar optional|模板实参列表}}{{ttb|&gt;}}|notes={{mark since c++11}}&lt;br&gt;{{mark deprecated}}}}
{{sdsc|num=4|{{ttb|operator}} {{spar|用户定义字符串字面量}} {{ttb|&lt;}}{{spar optional|模板实参列表}}{{ttb|&gt;}}|notes={{mark since c++11}}}}
{{sdsc end}}

@1@ ''简单模板标识''。

@2@ 运算符函数模板标识。

@3,4@ {{rlps|user literal#字面量运算符}}函数模板标识。

{{par begin}}
{{par|{{spar|模板名}}|命名模板的{{rlp|identifiers|标识符}}}}
{{par|{{spar|运算符}}|{{rlp|operators|可重载标识符}}}}
{{par|{{spar|标识符}}|标识符}}
{{par|{{spar|用户定义字符串字面量}}|{{c|""}} 后随一个标识符}}
{{par end}}

指名类模板特化的简单模板标识指名一个类。

指名别名模版特化的模板标识指名一个类型。

指名函数模板特化的模板标识指名一个函数。

模板标识在满足以下所有条件时''合法''：
* 实参数量不大于形参数量{{rev inl|since=c++11|，或有一个形参是模板{{rlp|parameter pack|形参包}}}}。
* 每个没有默认模板实参的不可推导的{{rev inl|since=c++11|非包}}形参都有一个实参。
* 每个模板实参都与对应的模板形参相匹配。
* 替换每个模板实参到它的后续模板形参（如果存在）中均成功。
{{rrev|since=c++20|
* 如果模板标识{{rlp|dependent name|非待决}}，那么它关联得约束需要按下述要求得以满足。
}}

无效的简单模板标识是编译时错误，除非它指名的是函数模板特化（此时适用 {{rlp|sfinae|SFINAE}}）。
{{source|1=
template&lt;class T, T::type n = 0&gt;
class X;

struct S
{
    using type = int;
};

using T1 = X&lt;S, int, int&gt;; // 错误：实参过多
using T2 = X&lt;&gt;;            // 错误：第一个模板形参没有默认实参
using T3 = X&lt;1&gt;;           // 错误：值 1 不匹配类型形参
using T4 = X&lt;int&gt;;         // 错误：第二个模板形参替换失败
using T5 = X&lt;S&gt;;           // OK
}}

{{rrev|since=c++20|
如果在简单模板标识的{{spar sep|模板名}}指名受约束的非函数模板或受约束的模板模板形参，但不是作为未知特化的成员的成员模板，而且简单模板标识中的所有模板实参均非待决，那么必须满足受约束模板的各项关联约束：
{{source|1=
template&lt;typename T&gt;
concept C1 = sizeof(T) != sizeof(int);

template&lt;C1 T&gt;
struct S1 {};

template&lt;C1 T&gt;
using Ptr = T*;

S1&lt;int&gt;* p;                      // 错误：不满足约束
Ptr&lt;int&gt; p;                      // 错误：不满足约束

template&lt;typename T&gt;
struct S2 { Ptr&lt;int&gt; x; };       // 错误，不要求诊断

template&lt;typename T&gt;
struct S3 { Ptr&lt;T&gt; x; };         // OK：不要求满足

S3&lt;int&gt; x;                       // 错误：不满足约束

template&lt;template&lt;C1 T&gt; class X&gt;
struct S4
{
    X&lt;int&gt; x;                    // 错误，不要求诊断
};

template&lt;typename T&gt;
concept C2 = sizeof(T) == 1;

template&lt;C2 T&gt; struct S {};

template struct S&lt;char[2]&gt;;      // 错误：不满足约束
template&lt;&gt; struct S&lt;char[2]&gt; {}; // 错误：不满足约束
}}
}}

两个模板标识在满足以下所有条件时''相同''：
* 它们的{{spar sep|模板名}}或运算符指代同一模板。
* 它们对应的类型模板实参是同一类型。
* 它们对应的非类型模板实参所确定的模板形参值{{rlp|template parameters#模板实参等价性|模板实参等价}}。
* 它们对应的模板模板实参指代同一模板。

相同的两个模板标识指代同一个{{rev inl|since=c++14|变量、}}类或函数。

===模板化实体===
''模板化实体''{{sep}}是在模板定义内定义{{rev inl|since=c++11|（或对于 {{rlp|lambda|lambda 表达式}}为创建）}}的实体。下列所有实体都是模板化实体：
* 类/函数{{rev inl|since=c++14|/变量}}模板
{{rrev|since=c++20|
* {{rlp|constraints|概念}}
}}
* 模板化实体的成员（例如类模板的非模板成员函数）
* 作为模板化实体的枚举的枚举项
* 任何模板化实体中定义或创建的实体：局部类，局部变量，友元函数，等等
{{rrev|since=c++11|
* 模板化实体的声明中出现的 lambda 表达式的闭包类型
}}

例如，在以下模板中：
{{source|1=
template&lt;typename T&gt;
struct A
{
    void f() {}
};
}}
函数 {{tt|A::f}} 不是函数模板，但它仍然会被当做是模板化的。


''模板化函数''{{sep}}是函数模板或模板化的函数。

''模板化类''{{sep}}是类模板或模板化的类。

{{rrev|since=c++14|
''模板化变量''{{sep}}是变量模板或模板化的变量。
}}

===关键词===
{{ltt|cpp/keyword/template}},
{{ltt|cpp/keyword/export}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=2293|std=C++98|before=未提供判断模板标识是否合法的规则|after=已提供}}
{{dr list item|wg=cwg|dr=2682|std=C++98&lt;br&gt;C++14|before=缺失了模板化函数/模板类（C++98）/模板化变量（C++14）的定义|after=已补充}}
{{dr list item|paper=P2308R1|std=C++98|before=当两个模板标识的对应非类型模板实参并非模板实参等价时，它们不同|after=当对应非类型模板形参值并非模板实参等价时，它们不同}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc see c|c/language/generic|泛型选择|nomono=true}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}