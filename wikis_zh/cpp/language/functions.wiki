{{title|函数}}
{{cpp/language/functions/navbar}}

函数（function）是把一个{{rlp|statements|语句}}序列（''函数体, function body''）关联到一个''名字''和零或更多个''函数形参（function parameter）''的列表的 C++ 实体。

{{source|
// 函数名：“isodd”
// 形参列表拥有一个形参，具有名字 “n” 和类型 int
// 返回类型是 bool
bool isodd(int n)
{                      // 函数体开始
    return n % 2;
}                      // 函数体结束
}}

调用函数时，例如在{{rlp|operator other#内建函数调用运算符|函数调用表达式}}中，以各个（调用场所提供或者{{rlp|default arguments|默认}}）''实参（argument）''来初始化各个形参，然后执行函数体中的语句。如果一个函数的{{rlp|function#形参列表|形参列表}}以 {{c|...}} 结尾，那么可以给该函数提供额外的实参，这样的函数被称为{{rlp|variadic arguments|变参函数}}。

{{source|
int main()
{
    for(int arg : {-3, -2, -1, 0, 1, 2, 3})
        std::cout &lt;&lt; isodd(arg) &lt;&lt; ' '; // isodd 被调用 7 次，
                                        // 每次从 arg 复制初始化 n
}
}}

函数调用表达式中{{rlp|unqualified lookup|无限定}}的函数名会使用一组额外的规则查找，它被称为{{rlp|adl|“实参依赖查找”（argument-dependent lookup/ADL）}}。

函数可以通过{{rlp|return|返回}}或者{{rlp|throw|抛出}}{{rlp|exceptions|异常}}终止。

{{rrev|since=c++20|
函数可以是{{rlp|coroutines|协程}}，在这种情况下，它可以暂停执行，并稍后恢复执行。
}}

{{rlp|function|函数声明}}可以在任何作用域中出现，但{{rlp|function|函数定义}}只能在命名空间作用域出现，或对于{{rlp|member functions|成员}}和{{rlp|friend|友元}}函数，可以在类作用域中出现。在类体中声明而不带 friend 说明符的函数是类成员函数。这种函数拥有许多附加性质，细节见{{rlp|member functions|成员函数}}。

函数不是对象：不存在函数的数组，而且函数不能按值传递或被其他函数所返回。可以有指向/到函数（除了{{rlp|main function|主函数}}{{rev inl|since=c++20|和{{rlp|extending std#取址限制|大多数标准库函数}}}}以外）的指针和引用，它们可以用于这些函数自身无法被使用的地方。因此我们说这些函数“可取址”。

每个函数都具有一个类型，它由函数的返回类型，所有形参的类型（进行数组到指针和函数到指针转换后，见{{rlp|function#形参列表|形参列表}}）{{rev inl|since=c++17|，函数是否为 {{rlpt|noexcept spec|noexcept}}}}，以及对于非静态成员函数的 cv 限定{{rev inl|since=c++11|和引用限定}}构成。函数类型同样拥有{{rlp|language linkage|语言链接}}。不存在有 cv 限定的函数类型（不要与如 {{c|int f() const;}} 这样的 {{rlp|member functions|cv 限定函数}}类型，或如 {{c|std::string const f();}} 这样的返回 {{rlp|cv|cv 限定类型}}的函数相混淆）。如果有任何 cv 限定符被添加到到函数类型的别名，那么它会被忽略。&lt;!-- CWG295 --&gt;

同一作用域中，可以有多个函数拥有相同的名称，只要其形参列表，以及对于非静态成员函数的 cv {{rev inl|since=c++11|或引用}}限定不同即可。这被称作{{rlp|overload resolution|函数重载}}。只有返回类型{{rev inl|since=c++17|及 noexcept 说明}}不同的函数声明之间无法重载。{{rlp|overloaded address|重载函数的地址}}有专门的确定方法。

{{rrev|since=c++11|
C++ 使用 {{rlp|lambda|lambda 表达式}} 实现{{enwiki|anonymous function|匿名函数}}。
}}

===函数对象===
除了函数左值，函数调用表达式还支持函数指针以及重载了函数调用运算符及可转换为函数指针的任何类类型的值{{rev inl|since=c++11|（包括 {{rlp|lambda|lambda 表达式}}）}}。这些类型被统称为{{named req|FunctionObject}}，而且在 C++ 标准库中的各处都有使用，示例可见{{named req|BinaryPredicate}}和{{named req|Compare}}的用法。

标准库也提供数个预定义的[[cpp/utility/functional|函数对象模板]]，以及一些组成新函数对象的方法（包括 {{lc|std::less}}{{rev inl|since=c++11|、{{lc|std::mem_fn}}、{{lc|std::bind}}、{{lc|std::function}}}}{{rev inl|since=c++17|、{{lc|std::not_fn}}}}{{rev inl|since=c++20|、{{lc|std::bind_front}}}}{{rev inl|since=c++23|、{{lc|std::bind_back}}、{{lc|std::move_only_function}}}}{{rev inl|since=c++26|、{{lc|std::copyable_function}} 和 {{lc|std::function_ref}}}}）。

{{langlinks|en|es|ja|ru}}