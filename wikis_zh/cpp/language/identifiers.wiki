{{title|标识符}}
{{cpp/language/basics/navbar}}
''标识符''是一个由数字，下划线，大小写拉丁字母和大多数 Unicode 字符组成的任意长度的序列。

有效的标识符的首个字符必须是以下之一：
* 大写拉丁字母 A-Z
* 小写拉丁字母 a-z
* 下划线
* 具有 Unicode 属性 [https://www.unicode.org/reports/tr31/#Table_Lexical_Classes_for_Identifiers XID_Start] 的 Unicode 字符

有效的标识符的其他字符必须是以下之一：
* 数字 0-9
* 大写拉丁字母 A-Z
* 小写拉丁字母 a-z
* 下划线
* 具有 Unicode 属性 [https://www.unicode.org/reports/tr31/#Table_Lexical_Classes_for_Identifiers XID_Continue] 的 Unicode 字符

具有 XID_Start 或 XID_Continue 属性的字符在 [https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt DerivedCoreProperties.txt] 列出。

标识符区分大小写（小写和大写字母是不同的），而且每一个字符都是起作用的。每个标识符都必须遵循[https://www.unicode.org/charts/normalization/ 正规化形式 C]。&lt;!-- P1949R7 --&gt;

注意：大多数实现中对 Unicode 标识符的支持是受限的，比如 [https://gcc.gnu.org/wiki/FAQ#What_is_the_status_of_adding_the_UTF-8_support_for_identifier_names_in_GCC.3F gcc （10 之前）]。

===在声明中===
可以用标识符来{{rlp|declarations|命名}}对象、引用、函数、枚举项、类型、类成员、命名空间、模板、模板特化{{rev inl|since=c++11|、形参包}}、goto 标号，以及其他实体，但有以下例外：
* [[cpp/keyword|关键词]]标识符不能用于其他目的。
{{rrev|since=c++11|
:* 关键词只有在{{spar sep|属性记号}}中可作他用（例如 {{c/core|[[private]]}} 是一个合法{{rlp|attributes|属性}}）。
}}
* 作为特定运算符与标点的{{rlp|operator alternative|代用表示}}不能用于其他目的。
{{rrev|since=c++11|
* 拥有特殊含义的标识符（{{c|final}}{{rev inl|since=c++20|，{{c|import}}，{{c|module}}}}和{{c|override}}）在特定语境不作为常规标识符使用，而是表达它们的特定含义。
** 除非另有规定，在给定标识符是否具有特殊含义的歧义场合，均把记号判读为常规标识符。
}}
* 有以下形式之一的{{rev inl|since=c++11|，作为记号或预处理记号（即不在形如 {{c|operator ""id}} 的{{spar sep|用户定义字符串字面量}}中）出现的}}标识符被保留：
** 在全局命名空间中，以一个下划线开始的标识符
** 除以下标识符外任何位置带有双下划线或以单下划线后随一个大写字母开始的标识符：
::* {{ls|cpp/preprocessor/replace#预定义宏}}{{rev inl|since=c++20|（包括[[cpp/feature test#语言功能特性|语言功能特性测试宏]]）}}
{{rrev|since=c++11|
::* {{lc|std::_Exit}}
::* {{rlp|function#func|{{c|__func__}}}}
}}
::* 以下在标准库中定义的宏：
:::* C 风格输入/输出库的宏 {{c|_IOFBF}}、{{c|_IOLBF}} 和 {{c|_IONBF}}
{{rev begin}}
{{rev|since=c++11|
:::* C 兼容性宏 {{c|__alignas_is_defined}} 和 {{c|__alignof_is_defined}}（在 {{ltt|cpp/header/cstdalign|&lt;stdalign.h&gt;}} 中定义）
:::* C 兼容性宏 {{c|__bool_true_false_are_defined}}（在 {{ltt|cpp/header/cstdbool|&lt;stdbool.h&gt;}} 中定义）
}}
{{rev|since=c++20|
:::* [[cpp/feature test#标准库功能特性|标准库功能特性测试宏]]
}}
{{rev end}}

这里“被保留”的意思是，标准库的头文件可能 {{c/core|#define}} 或者声明这样的标识符以便它在内部使用，编译器可能会预先定义这种非标准的标识符，而且名字重整算法可能会假定某些这样的标识符是没有被使用的。如果程序员使用了这样的标识符的话，程序非良构，不要求诊断。

此外，在一个翻译单元 {{c/core|#define}} 或 {{c/core|#undef}} 特定名字是未定义行为，详情请见[[cpp/preprocessor/replace|保留宏名]]。

====僵尸标识符====
C++14 起，某些标识符被从 C++ 标准库移除。它们列于[[cpp/symbol index/zombie names|僵尸名列表]]。

然而，这些标识符仍然在某些语境中为以前的标准化保留。可移植的代码中，被移除的成员函数名不可用做函数式宏的名字，而其他被移除的成员名不可用作对象式宏的名字。

===在表达式中===
指名某个变量、函数{{rev inl|since=c++20|、{{rlp|constraints|概念}}的特化}}或枚举项的标识符可以作为{{rlp|expressions|表达式}}使用。仅由这个标识符组成的表达式的结果，是该标识符所命名的实体。如果该标识符命名的是某个函数、变量{{rev inl|since=c++20|、{{rlp|template parameters#非类型模板形参|模板形参对象}}}}或数据成员，那么表达式的{{rlp|value category|值类别}}是''左值''，否则是{{rev inl|until=c++11|''右值''}}{{rev inl|since=c++11|''纯右值''}}（例如{{rlp|enum|枚举项}}是纯右值表达式{{rev inl|since=c++20|，概念的特化是 {{c/core|bool}} 纯右值}}）。

====类型====
标识表达式的类型就是它指名的实体的类型。

{{rrev|since=c++11|
存在以下例外：
* 如果该（无限定）标识符所指名的实体是局部实体，且在该标识符所出现的声明区之外指名它时将导致它被穿插其间的某个 {{rlp|lambda|lambda 表达式}}按复制捕获，那么该表达式的类型是指名最内层的这种穿插其间的 lambda 表达式的闭包对象中为这种捕获所声明的非静态数据成员的{{rlp|operator member access|类成员访问表达式}}的类型。
{{source|1=
void f()
{
    float x, &amp;r = x;
    
    [=]
    {
        decltype(x) y1;        // y1 拥有 float 类型
        decltype((x)) y2 = y1; // y2 拥有 float const&amp; 类型
                               // 因为此 lambda 非 mutable 而 x 是左值
        decltype(r) r1 = y1;   // r1 拥有 float&amp; 类型
        decltype((r)) r2 = y2; // r2 拥有 float const&amp; 类型
    };
}
}}
{{rrev|since=c++20|
* 如果所指名的实体是某个 {{tt|T}} 类型模板形参的模板形参对象，那么表达式的类型是 {{c/core|const T}}。
}}
}}

====无限定的标识符====
除了适当声明了的标识符之外，以下各项也可以以相同方式用在表达式中：
* 函数写法的{{rlp|operators|重载运算符}}名，比如 {{c|operator+}} 或 {{c|operator new}}；
* {{rlp|cast operator|用户定义转换函数}}的名字，比如 {{c|operator bool}}；
{{rrev|since=c++11|
* {{rlp|user literal|用户定义字面量运算符}}的名字，比如 {{c|operator ""_km}}；
}}
* {{rlp|templates|模板}}的名字后随它的实参列表，比如 {{c|MyTemplate&lt;int&gt;}}；
* {{c|~}} 字符后随类名，比如 {{c|~MyClass}}；
{{rrev|since=c++11|
* {{c|~}} 字符后随 {{rlp|decltype}} 说明符，比如 {{c|~decltype(str)}}。
}}
{{rrev|since=c++26|
* {{c|~}} 字符后随{{rlps|pack indexing#包索引说明符}}，比如 {{c|~pack...[0]}}。
}}

这些和标识符一起，被称作''无限定的标识表达式''。

====有限定的标识符====
''有限定的标识表达式''是在无限定的标识表达式前面带上作用域解析运算符 {{c|::}}，以及以作用域解析运算符分隔的包含以下任意内容的序列（可以为空）：
* 命名空间的名字
* 类的名字
{{rrev|since=c++11|
* 枚举的名字
* 表示类或枚举类型的 {{rlp|decltype|{{tt|decltype}} 说明符}}
}}
{{rrev|since=c++26|
* 表示类或枚举类型的{{rlps|pack indexing#包索引说明符}}
}}

例如，表达式 {{c|std::string::npos}} 是指名命名空间 {{c|std}} 内的类 {{c|string}} 中的静态成员 {{c|npos}} 的表达式。表达式 {{c|::tolower}} 指名的是全局命名空间内的函数 {{c|tolower}}。表达式 {{c|::std::cout}} 指名 {{c|std}} 命名空间（顶层命名空间）中的全局变量 {{c|cout}}。表达式 {{c|boost::signals2::connection}} 指名的是在 {{c|signals2}} 命名空间中声明的类型 {{c|connection}}，前者则在命名空间 {{c|boost}} 声明。

有限定标识符中，可能会需要以关键词 {{ltt|cpp/keyword/template}} 来消除{{rlp|dependent name|待决模板名}}的歧义。

关于为有限定的标识符进行的名字查找的细节，请参见{{rlp|qualified lookup|有限定的名字查找}}。

===隐式成员访问转换===
如果标识表达式 {{c|E}} 指名了类 {{tt|C}} 的某个非静态非类型成员，那么 {{c|E}} 在满足以下所有条件时会转换成类成员访问表达式 {{c|this-&gt;E}}：
* {{c|E}} 不是{{rlp|operator member access#内建的成员访问运算符|成员访问运算符}}的右操作数。
* 如果 {{c|E}} 是有限定的标识表达式，那么 {{c|E}} 不是{{rlp|operator member access#内建的取地址运算符|取地址运算符}}的未用圆括号包围的操作数。
* 满足以下任意条件：
:* {{c|E}} {{rlp|expressions#潜在求值表达式|潜在求值}}。
:* 在 {{c|E}} 处的最内层的外围类是 {{tt|C}}。
:* 在 {{c|E}} 处的最内层的外围类从 {{tt|C}} 派生。

在模板定义语境（见{{rlp|dependent name|待决名}}）中不会应用该转换。

{{source|
struct X
{
    int x;
};

struct B
{
    int b;
};

struct D : B
{
    X d;
    
    void func()
    {
        d;   // OK，会转换成 this-&gt;d
        b;   // OK，会转换成 this-&gt;b
        x;   // 错误：this-&gt;x 非良构
        
        d.x; // OK，会转换成 this-&gt;d.x
             // 而不是 d.this-&gt;x 或 this-&gt;d.this-&gt;x
    }
};
}}

===名字===
''名字''{{sep}}是以下各项之一，用来代表某个实体：
* 标识符
* 函数写法的重载运算符的名字（{{c|operator+}}、{{c|operator new}}）
* 用户定义的转换函数的名字（{{c|operator bool}}）
{{rrev|since=c++11|
* 用户定义的字面量运算符的名字（{{c|operator ""_km}}）
}}
* 模板的名字后随它的实参列表（{{c|MyTemplate&lt;int&gt;}}）

每个名字都是由{{rlp|declarations|声明}}引入到程序中来的。在多个翻译单元中使用的相同名字，可以根据它的{{rlps|storage duration#链接}}代表相同或者不同的实体。

每当编译器在程序中遇到一个未知的名字时，它就会通过进行{{rlp|lookup|名字查找}}来将它与引入这个名字的声明联系起来，但对模板的声明和定义中的{{rlp|dependent name|待决名}}不会这样做。（对于这些名字，编译器需要确定它们命名的是类型、模板还是某些其他实体，这可能需要{{rlp|dependent name|显式消歧义}}）。

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1440|std=C++11|before=在 {{tt|::}} 之前的 decltype 表达式可以表示任意类型|after=只能表示类和枚举类型}}
{{dr list item|wg=cwg|dr=1963|std=C++11|before=标识符中可以使用数字，非数字字符和通用字符名以外的由实现定义的字符|after=不能使用}}
{{dr list item|wg=cwg|dr=2521|std=C++11|before=字面量运算符的{{spar sep|用户定义字符串字面量}}中的标识符照常保留|after=规则不同}}
{{dr list item|wg=cwg|dr=2771|std=C++98|before={{c|&amp;a}} 在类语境中不会转换成 {{c|&amp;this-&gt;a}}|after=会转换}}
{{dr list item|wg=cwg|dr=2777|std=C++20|before=命名了模板形参对象的标识表达式的类型不明确|after=使之明确}}
{{dr list item|wg=cwg|dr=2818|std=C++98|before=预定义宏名会被保留|after=不会被保留}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc see c|c/language/identifier|标识符|nomono=true}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}