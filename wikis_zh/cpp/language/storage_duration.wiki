{{title|存储类说明符}}
{{cpp/language/declarations/navbar}}

存储类说明符是名字的{{rlp|declarations|声明语法}}中的{{spar sep|声明说明符序列}}的一部分。它与名字的{{rlp|scope|作用域}}一同控制名字的两个独立性质：它的“存储期”和它的“链接”。

===存储期===
''存储期''{{sep}}是{{rlp|object|对象}}的一种属性，该属性定义了包含该对象的存储的最短潜在生存期。存储期由创建对象的方式决定，并且是以下之一：
* 静态存储期
{{rrev|since=c++11|
* 线程存储期
}}
* 自动存储期
* 动态存储期

静态{{rev inl|since=c++11|、线程}}和自动存储期关联到由{{rlp|declarations|声明}}引入的对象和{{rlp|lifetime#临时对象的生存期|临时对象}}。动态存储期关联到由 {{rlp|new|{{c/core|new}} 表达式}}创建的对象和{{rlp|object#对象创建|隐式创建的对象}}。

这些存储期类别同样适用于引用。

{{rlps|object#子对象}}和引用成员的存储期就是它们的完整对象的存储期。

====说明符====
以下关键词是''存储类说明符''{{sep}}：
{{rev begin}}
{{rev|until=c++11|
* {{c/core|auto}}
}}
{{rev|until=c++17|
* {{c/core|register}}
}}
{{rev end}}
* {{c/core|static}}
{{rrev|since=c++11|
* {{c/core|thread_local}}
}}
* {{c/core|extern}}
* {{c/core|mutable}}

{{spar sep|声明说明符序列}}中只能出现一个存储类说明符{{rev inl|since=c++11|，但 {{c/core|thread_local}} 可以与 {{c/core|static}} 或 {{c/core|extern}} 一起出现}}。

{{c/core|mutable}} 不会影响存储期。它的用法参考 {{rlp|cv|const/volatile}}。

其他存储类说明符可以在以下声明的{{spar sep|声明说明符序列}}中出现：
{|class="wikitable" style="text-align: center;"
!rowspan=4|说明符
!colspan=9|可以在...的{{spar sep|声明说明符序列}}中出现
|-
!colspan=4|变量声明
!colspan=3|函数声明
!rowspan=3|{{nbsp}}结构化绑定声明{{nbsp}}&lt;br&gt;{{mark since c++17}}
|-
!colspan=2|非成员
!colspan=2|成员
!rowspan=2|非成员
!colspan=2|成员
|-
!非形参
!{{nbsp}}函数形参{{nbsp}}
!{{nbsp}}非静态{{nbsp}}
!{{nbsp}}静态{{nbsp}}
!{{nbsp}}非静态{{nbsp}}
!{{nbsp}}静态{{nbsp}}
|-
|{{c/core|auto}}
|{{maybe|{{nbsp}}仅限块作用域{{nbsp}}}}||{{yes}}||{{no}}||{{no}}
|{{no}}||{{no}}||{{no}}||{{n/a}}
|-
|{{c/core|register}}
|{{maybe|仅限块作用域}}||{{yes}}||{{no}}||{{no}}
|{{no}}||{{no}}||{{no}}||{{n/a}}
|-
|{{c/core|static}}
|{{yes}}||{{no}}||colspan=2 {{yes|声明为静态}}
|{{maybe|{{nbsp}}仅限命名空间作用域{{nbsp}}}}||colspan=2 {{yes|声明为静态}}||{{yes}}
|-
|{{nbsp}}{{c/core|thread_local}}{{nbsp}}
|{{yes}}||{{no}}||{{no}}||{{yes}}
|{{no}}||{{no}}||{{no}}||{{yes}}
|-
|{{c/core|extern}}
|{{yes}}||{{no}}||{{no}}||{{no}}
|{{yes}}||{{no}}||{{no}}||{{no}}
|}

{{rlps|union#匿名联合体}}也可以声明有 {{c/core|static}}。

{{rrev|until=c++17|
{{c/core|register}} 用来提示声明的变量会频繁使用，因此它的值可以存储在 CPU 寄存器中。此提示可以忽略，并且大多数实现在需要取声明的变量的地址的情况下都会忽略此提示。这种用法已弃用。
}}

====静态存储期====
满足以下所有条件的变量具有''静态存储期''：
* 它属于{{rlps|scope#命名空间作用域}}，或者首先声明有 {{c/core|static}} 或 {{c/core|extern}}。
{{rrev|since=c++11|
* 它不具有线程存储期。
}}

这些实体的存储在程序运行期间持续存在。

{{rrev|since=c++11|
====线程存储期====
所有声明有 {{c/core|thread_local}} 的变量都具有''线程存储期''。

这些实体的存储在创建它们的线程的持续期间持续存在。每个线程都有一个不同的对象或引用，并且使用声明的名字时会指代与当前线程关联的实体。
}}

====自动存储期====
以下变量具有''自动存储期''：
* 属于{{rlps|scope#块作用域}}并且未显式声明有 {{c/core|static}}{{rev inl|since=c++11|、{{c/core|thread_local}}}} 或 {{c/core|extern}}&lt;!-- 不需要提及 auto 和 register --&gt; 的变量。此类变量的存储持续到它们创建时所在的块退出时。
* 属于形参作用域的变量（即函数形参）。函数形参的存储持续到它{{rlp|operator other#内建的函数调用运算符|销毁}}&lt;!-- 此处请勿使用“析构”，destruction 在这里对应的是 destroy 而不是 destruct --&gt;完成时。

====动态存储期====
在程序执行过程中通过以下方式创建的对象具有''动态存储期：
* {{rlp|new|{{c/core|new}} 表达式}}。此类对象的存储会通过[[cpp/memory/new/operator new|分配函数]]进行分配，并且会通过[[cpp/memory/new/operator delete|解分配函数]]进行解分配。
* 通过其他方式{{rlp|object#对象创建|隐式创建}}的对象。此类对象的存储与某个已存在的存储重叠。
* {{rlps|throw#异常对象}}。此类对象的存储的分配和解分配方式未指定。

===链接===
名字可以具有''外部链接''{{sep}}{{rev inl|since=c++20|、''模块链接''}}、''内部链接''{{sep}}或''无链接''：
* 名字具有外部链接的实体可以在另一{{rlp|translation phases|翻译单元}}{{rlp|conflicting declarations#相同实体的多次声明|重声明}}{{rev inl|since=c++20|，并且重声明可以{{rlp|modules#模块所有权|附着于另一模块}}}}。
{{rrev|since=c++20|
* 名字具有模块链接的实体可以在另一翻译单元重声明，只需要确保重声明附着于同一模块。
}}
* 名字具有内部链接的实体可以在同一翻译单元的其他作用域重声明。
* 名字无链接的实体只能在同一作用域重声明。

以下各种链接可以被识别：

====无链接====
在块作用域声明的下列任何名字都无链接：
* 未显式声明有 {{c/core|extern}} 的变量（不管有没有 {{c/core|static}} 修饰符）；
* {{rlps|class#局部类}}和它的成员函数；
* 声明于块作用域的其他名字，例如 typedef、枚举及枚举项。

未指定为具有外部{{rev inl|since=c++20|、模块}}或内部链接的名字同样无链接，这与它的声明所处的作用域无关。

====内部链接====
声明于命名空间作用域的下列任何名字都具有内部链接：
* 声明为 {{c/core|static}} 的变量{{rev inl|since=c++14|、变量模板}}、函数或函数模板；
* 类型具有 {{rlp|cv|const 限定}} 但没有 volatile 限定的{{rev inl|since=c++14|非模板}}变量，除非：
{{rev begin}}
{{rev|since=c++17|
:* 它是{{rlp|inline|内联}}的，
}}
{{rev|since=c++20|
:* 它声明于{{rlp|modules#模块声明|模块接口单元}}（在{{rlps|modules#私有模块片段}}以外，如果存在）的视野或{{rlp|modules#模块分区|模块分区}}中
}}
{{rev end}}
:* 它显式声明为 {{c/core|extern}}，或
:* 它已在先前声明，而且先前的声明不具有内部链接；
* {{rlp|union|匿名联合体}}的数据成员。

{{rrev|since=c++11|
另外，所有声明于{{rlps|namespace#无名命名空间}}或无名命名空间内的命名空间的名字，即使显式声明为 {{c/core|extern}} 也都具有内部链接。
}}

====外部链接====
具有外部链接的变量和函数也具有{{rlp|language linkage|语言链接}}，这使得以不同编程语言编写的翻译单元可以互相链接。

声明于命名空间作用域的下列任何名字都具有外部链接，除非这些名字声明于无名命名空间{{rev inl|since=c++20|或它们声明于具名模块且未被导出}}：
* 以上未列出的变量与函数（即未声明为 {{c/core|static}} 的函数、命名空间作用域内未声明为 {{c/core|static}} 的非 const 变量，和所有声明为 {{c/core|extern}} 的变量）；
* 枚举；
* 类以及其成员函数、静态数据成员（不论是否 const）、嵌套类及枚举，及首次以类体内的 {{rlp|friend}} 声明引入的函数的名字；
* 所有未列于上的模板名（即未声明为 {{c/core|static}} 的函数模板）。

任何于块作用域首次声明的下列名称都具有外部链接：
* 声明为 {{c/core|extern}} 的变量名；
* 函数名。

{{rrev|since=c++20|
====模块链接====
如果声明于命名空间作用域的名字附着到具名模块，未被导出且无内部链接，那么它具有模块链接。
}}

{{todo|add the description of the behavior when an entity is declared with different linkages in the same translation unit (6.6 paragraph 6), note the difference between C++20 (ill-formed) and the current draft (well-formed)}}

===静态块变量===
具有静态{{rev inl|since=c++11|或线程}}存储期的块变量在控制首次经过它的声明时才会被初始化（除非它被{{rlp|zero initialization|零初始化}}或{{rlp|constant initialization|常量初始化}}，这可以在首次进入块前进行）。在其后所有的调用中，声明都会被跳过。
* 如果初始化{{rlp|throw|抛出异常}}，那么不认为变量被初始化，且控制下次经过该声明时将再次尝试初始化。
* 如果初始化递归地进入正在初始化的变量的块，那么行为未定义。
{{rrev|since=c++11|
* 如果多个线程试图同时初始化同一静态局部变量，那么初始化严格发生一次（类似的行为也可对任意函数以 {{lc|std::call_once}} 来达成）。
:* 此功能特性的通常实现都会使用双检查锁定模式的变体，这使得对已初始化的局部静态变量检查的运行时开销减少为单次非原子的布尔比较。
}}

具有静态存储期的块变量的析构函数在[[cpp/utility/program/exit|程序退出时]]调用，但仅限在它的初始化已成功的情况下。

在相同{{rlp|inline|内联函数}}（可以是隐式内联）的所有定义中的具有静态存储期的变量指代的都是在一个翻译单元中定义的同一对象，只要函数拥有外部链接。

===翻译单元局部实体===
C++20 中标准化了翻译单元局部实体的概念，详情见{{rlp|tu local|此页面}}。

满足以下情况的实体是''翻译单元局部''（简称为 ''TU 局部''）的：

* 它的名字具有内部链接，或者
* 它没有具有链接的名字，且它是在 TU 局部实体的定义之内引入的，或者
* 它是模板或模板特化，其模板实参或模板声明使用了 TU 局部实体。

如果非 TU 局部实体依赖于某个 TU 局部实体，或者非 TU 局部实体的声明{{rev inl|since=c++17|或其{{rlp|ctad|推导指引}}}}，在以下位置之外对某个 TU 局部实体进行指名，那么就会发生不好的事（通常是违反 {{rlp|definition|ODR}}）：

* 函数体（对于非内联函数或函数模板）
* 初始化器（对于变量或变量模板）
* 类定义中的友元声明
* 使用某个变量的值，该变量{{rlps|constant expression#可用于常量表达式}}

{{rrev|since=c++20|
{{rlp|modules|模块接口单元}}（其私有模块片段之外，如果有）或模块分区中不允许进行这种使用，而且其他语境中也都已被弃用。

在一个翻译单元中出现的声明，无法指名另一并非头文件单元的翻译单元中声明的 TU 局部实体。针对某{{rlp|templates|模板}}的实例化声明出现于该特化的实例化点。
}}

===注解===
位于顶层命名空间作用域（C 中的文件作用域），且是 {{c/core|const}} 而非 {{c/core|extern}} 的名字在 C 中具有外部链接，但在 C++ 中具有内部链接。

C++11 起，{{c/core|auto}} 不再是存储类说明符；它被用于指示类型推导。

{{rrev multi|until1=c++17
|rev1=
在 C 中，不能取 {{c/core|register}} 变量的地址，但在 C++ 中，声明为 {{c/core|register}} 的对象与声明不带任何存储类说明符的变量在语义上没有区别。
|rev2=
与 C 不同，在 C++ 中不能将变量声明为 {{c/core|register}}。
}}

从不同作用域指代的且带内部或外部链接的 {{c/core|thread_local}} 变量的名字可能指代相同或不同的实例，这取决于代码在相同还是不同的线程执行。

{{c/core|extern}} 关键词也能用来指定{{rlp|language linkage|语言链接}}和{{rlp|class template|显式模板实例化声明}}，但它在这些情况中不是存储类说明符（但当声明直接在语言链接说明中所包含时将声明当做如同它含 {{c/core|extern}} 说明符）。

{{c/core|thread_local}} 以外的存储类说明符都不能{{rlp|template specialization|显式特化}}及{{rlps|class template#显式实例化}}中使用：
{{source|1=
template&lt;class T&gt;
struct S
{
    thread_local static int tlm;
};

template&lt;&gt;
thread_local int S&lt;float&gt;::tlm = 0; // 这里未出现 "static"
}}

{{rev begin}}
{{rev|since=c++14|
{{c/core|const}} （可能为 {{c/core|constexpr}} 所隐含）变量模板曾默认拥有内部链接，这与其他模板化实体不一致。缺陷报告 {{wg21|CWG2387}} 更正了这点。
}}
{{rev|since=c++17|1=
{{rlpt|inline}} 表现为 {{wg21|CWG2387}} 的变通方法，由于它默认给予外部链接。这就是为何 {{c/core|inline}} 曾经被[https://wg21.link/p0607r0 添加]给许多变量模板，而在接受 CWG2387 后又被[https://github.com/cplusplus/draft/pull/4625 移除]。只要支持的编译器尚未实现 CWG2387，标准库实现也需要使用 {{c/core|inline}}。参见 [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=109126 GCC Bugzilla #109126] 与 [https://github.com/microsoft/STL/pull/4546 MSVC STL PR #4546]。
}}
{{rev end}}

{{feature test macro|__cpp_threadsafe_static_init|[[#静态块变量|并发的动态初始化和析构]]|value=200806L|std=C++11}}

===关键词===
{{ltt|cpp/keyword/auto}},
{{ltt|cpp/keyword/register}},
{{ltt|cpp/keyword/static}},
{{ltt|cpp/keyword/extern}},
{{ltt|cpp/keyword/thread_local}},
{{ltt|cpp/keyword/mutable}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;thread&gt;

thread_local unsigned int rage = 1;
std::mutex cout_mutex;

void increase_rage(const std::string&amp; thread_name)
{
    ++rage; // 在锁外修改 OK；这是线程局部变量
    std::lock_guard&lt;std::mutex&gt; lock(cout_mutex);
    std::cout &lt;&lt; thread_name &lt;&lt; " 的愤怒计数：" &lt;&lt; rage &lt;&lt; '\n';
}

int main()
{
    std::thread a(increase_rage, "a"), b(increase_rage, "b");
    
    {
        std::lock_guard&lt;std::mutex&gt; lock(cout_mutex);
        std::cout &lt;&lt; "main 的愤怒计数：" &lt;&lt; rage &lt;&lt; '\n';
    }
    
    a.join();
    b.join();
}
|p=true
|output=
a 的愤怒计数：2
main 的愤怒计数：1
b 的愤怒计数：2
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=216|std=C++98|before=无名类和无名枚举在类作用域和命名空间作用域中的链接不同|after=它们在这些作用域都有外部链接}}
{{dr list item|wg=cwg|dr=389|std=C++98|before=无链接的名字不能用来声明有链接的实体|after=无链接的类型不能作为有链接的变量或函数的&lt;br&gt;类型，除非该变量或函数已经有 C 语言链接}}
{{dr list item|wg=cwg|dr=426|std=C++98|before=可以在同一个翻译单元中对某个实体&lt;br&gt;同时进行内部链接声明和外部链接声明|after=此时程序非良构}}
{{dr list item|wg=cwg|dr=527|std=C++98|before=由 {{cwg|389}} 的解决方案引入的类型也适用于&lt;br&gt;无法在自己所在的翻译单元外被命名的变量或函数|after=解除对这些变量或函数（即无链接或具有&lt;br&gt;内部链接，或在无名命名空间内声明）的限制}}
{{dr list item|wg=cwg|dr=809|std=C++98|before={{c/core|register}} 的功能极为有限|after=将其弃用}}
{{dr list item|wg=cwg|dr=1648|std=C++11|before={{c/core|thread_local}} 即使与 {{c/core|extern}}&lt;br&gt;一起使用也意味着应用了 {{c/core|static}}|after=只有在单独使用 {{c/core|thread_local}} 时&lt;br&gt;才意味着应用了 {{c/core|static}}}}
{{dr list item|wg=cwg|dr=1686|std=C++98&lt;br&gt;C++11|before=在命名空间作用域声明的非静态变量只有在显式声明为&lt;br&gt;{{c/core|const}}（C++98）或 {{c/core|constexpr}}（C++11）时才具有内部链接|after=只需要类型有 const 限定}}
{{dr list item|wg=cwg|dr=2019|std=C++98|before=未指明引用成员的存储期|after=与它们的完整对象一致}}
{{dr list item|wg=cwg|dr=2387|std=C++14|before=不明确有 const 限定的变量模板是否默认有内部链接|after=const 限定符不影响变量&lt;br&gt;模板或它的实例的链接}}
{{dr list item|wg=cwg|dr=2533|std=C++98|before=隐式创建的对象的存储期不明确|after=使之明确}}
{{dr list item|wg=cwg|dr=2850|std=C++98|before=不明确函数形参的存储会在什么时候解分配|after=使之明确}}
{{dr list item|wg=cwg|dr=2872|std=C++98|before=“可以被指代”的含义不明确|after=改进用词}}
{{dr list item|paper=P2788R0|std=C++20|before=即使在模块单元中，在命名空间中声明&lt;br&gt;具有 const 限定的变量也会给予它内部链接|after=不给予内部链接}}
{{dr list end}}

===引用===
{{ref std c++23}}
{{ref std|section=6.7.5|title=Storage duration|id=basic.stc}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=6.7.5|title=Storage duration|id=basic.stc}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=6.7|title=Storage duration|id=basic.stc}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=3.7|title=Storage duration|id=basic.stc}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=3.7|title=Storage duration|id=basic.stc}}
{{ref std end}}
{{ref std c++03}}
{{ref std|section=3.7|title=Storage duration|id=basic.stc}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=3.7|title=Storage duration|id=basic.stc}}
{{ref std end}}

===参阅===
{{dsc begin}}
{{dsc see c|c/language/storage duration|存储类说明符|nomono=true}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}