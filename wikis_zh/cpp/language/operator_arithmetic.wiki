{{title|算术运算符}}
{{cpp/language/expressions/navbar}}
返回特定算术运算的结果。

{|class="wikitable"
|-
!rowspan="2" style="width: 8%;"|运算符名
!rowspan="2" style="width: 7%;"|语法
!colspan="2"|原型示例（对于 {{c/core|class T}}）
|-
!类内定义
!类外定义
|-
|一元加
|{{co|+a}}
|{{c|T T::operator+() const;}}
|{{c|T operator+(const T &amp;a);}}
|-
|一元减
|{{co|-a}}
|{{c|T T::operator-() const;}}
|{{c|T operator-(const T &amp;a);}}
|-
|加法
|{{co|a + b}}
|{{c|T T::operator+(const T2 &amp;b) const;}}
|{{c|T operator+(const T &amp;a, const T2 &amp;b);}}
|-
|减法
|{{co|a - b}}
|{{c|T T::operator-(const T2 &amp;b) const;}}
|{{c|T operator-(const T &amp;a, const T2 &amp;b);}}
|-
|乘法
|{{co|a * b}}
|{{c|T T::operator*(const T2 &amp;b) const;}}
|{{c|T operator*(const T &amp;a, const T2 &amp;b);}}
|-
|除法
|{{co|a / b}}
|{{c|T T::operator/(const T2 &amp;b) const;}}
|{{c|T operator/(const T &amp;a, const T2 &amp;b);}}
|-
|模
|{{co|a % b}}
|{{c|T T::operator%(const T2 &amp;b) const;}}
|{{c|T operator%(const T &amp;a, const T2 &amp;b);}}
|-
|逐位非
|{{co|~a}}
|{{c|T T::operator~() const;}}
|{{c|T operator~(const T &amp;a);}}
|-
|逐位与
|{{co|a &amp; b}}
|{{c|T T::operator&amp;(const T2 &amp;b) const;}}
|{{c|T operator&amp;(const T &amp;a, const T2 &amp;b);}}
|-
|逐位或
|{{co|a {{!}} b}}
|{{c|T T::operator{{!}}(const T2 &amp;b) const;}}
|{{c|T operator{{!}}(const T &amp;a, const T2 &amp;b);}}
|-
|逐位异或
|{{co|a ^ b}}
|{{c|T T::operator^(const T2 &amp;b) const;}}
|{{c|T operator^(const T &amp;a, const T2 &amp;b);}}
|-
|逐位左移
|{{co|a &lt;&lt; b}}
|{{c|T T::operator&lt;&lt;(const T2 &amp;b) const;}}
|{{c|T operator&lt;&lt;(const T &amp;a, const T2 &amp;b);}}
|-
|逐位右移
|{{co|a &gt;&gt; b}}
|{{c|T T::operator&gt;&gt;(const T2 &amp;b) const;}}
|{{c|T operator&gt;&gt;(const T &amp;a, const T2 &amp;b);}}
|-
|colspan="5"|
:'''注解'''&lt;br&gt;
* 此表中的所有运算符都{{rlp|operators|可重载}}。
* 所有内建运算符都返回值，而大多数{{rlp|operators|用户定义重载}}也会返回值，因此用户定义运算符能以与内建版本相同的方式使用。不过，用户定义重载中，任何类型都可以作为返回类型（包括 {{c/core|void}}）。特别是，{{c/core|operator&lt;&lt;}} 和 {{c/core|operator&gt;&gt;}} 作为流插入和流提取的重载所返回的是 {{tt|T&amp;}}。
* {{tt|T2}} 可以是包括 {{tt|T}} 在内的任何类型。
|}

===通用解释===
所有内建算术运算符计算特定算术运算的结果，并返回它的结果。不修改实参。

====转换====
如果传递给内建算术运算符的操作数是整数或无作用域枚举类型，那么在所有其他操作前（但在左值到右值转换后，如果适用）会对操作数实施{{rlpsd|implicit conversion#整数提升}}。如果操作数之一具有数组或函数类型，那么实施{{rlp|implicit conversion#数组到指针转换|数组到指针}}和{{rlp|implicit conversion#函数到指针|函数到指针}}转换。

对于（除移位之外的）二元运算符，当提升后的操作数拥有不同类型时，实施{{rlp|usual arithmetic conversions|一般算术转换}}。

====溢出====
无符号整数算术始终进行 {{math|modulo 2{{su|p=n}}}} 运算，其中 n 是该整数的位数。例如对于 {{c/core|unsigned int}}，向 {{lc|UINT_MAX}} 加一得到 {{c|0}}，而从 {{c|0}} 减一得到 {{lc|UINT_MAX}}。

有符号整数算术运算溢出（结果类型无法容纳它的结果）时，行为未定义，此类操作可能会表现为：
* 按照表示法的规则（典型为{{rlp|types#值的范围|补码}}）发生回绕，
* 在某些平台上或由于编译器选项（例如 GCC 和 Clang 中的 {{tt|-ftrapv}}）引发陷阱，
* 在某些时候饱和到最小或最大值（在许多 DSP 上），
* 完全[https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html 被编译器优化掉]。

====浮点数环境====
如果支持 {{ltt|cpp/preprocessor/impl|#pragma STDC FENV_ACCESS}} 并设置它为 {{tt|ON}}，那么所有浮点数算术运算符都服从当前浮点数[[cpp/numeric/fenv/FE_round|舍入方向]]，并报告 {{ltt|cpp/numeric/math/math_errhandling}} 中指定的浮点数算术错误，除非其在{{rlp|initialization#非局部变量|静态初始化器}}中发生（此时不引发浮点数异常，且舍入模式是最近舍入）。

====浮点数缩略====
除非支持 {{ltt|cpp/preprocessor/impl|#pragma STDC FP_CONTRACT}} 并设置它为 {{tt|OFF}}，否则所有浮点数算术都可以如同它的中间结果拥有无限范围和精度一般进行，即允许实施省略舍入误差和浮点数异常的优化。例如 C++ 允许以单条融合乘加 CPU 指令来实现 {{c|(x * y) + z}}，或把 {{c|1=a = x * x * x * x;}} 优化为 {{c|1=tmp = x * x; a = tmp * tmp}}。{{mark unreviewed dr|LWG}}&lt;!-- 于 2016 以 LWG 238 确认 --&gt;

无关乎缩略，浮点数算术的中间结果可拥有与它的类型所指定不同的范围和精度，见 {{lc|FLT_EVAL_METHOD}}。

正式来讲，C++ 标准不在浮点数运算的精度上做任何保证。

===一元算术运算符===
一元算术运算符表达式的形式为

{{sdsc begin}}
{{sdsc|num=1|{{ttb|+}} {{spar|表达式}}}}
{{sdsc|num=2|{{ttb|-}} {{spar|表达式}}}}
{{sdsc end}}
@1@ 一元加（提升）。
@2@ 一元减（取反）。

一元 {{tt|+}} 和 {{tt|-}} 运算符的{{rlp|operator precedence|优先级}}高于所有二元算术运算符，所以{{spar sep|表达式}}无法包含位于顶层的二元算术运算符。这些运算符从右到左关联：
{{source|
+a - b; // 等价于 (+a) - b，而不是 +(a - b)
-c + d; // 等价于 (-c) + d，而不是 -(c + d)

+-e; // 等价于 +(-e)，在 e 是内建类型的情况下一元 + 是无操作，
     // 因为任何提升操作都已经在取反过程中进行
}}

====内建一元算术运算符====
@1@ 对于内建一元加运算符，{{spar sep|表达式}}必须是算术、无作用域枚举或指针类型的纯右值。如果{{spar sep|表达式}}具有整数或无作用域枚举类型，那么对它实施整数提升。结果的类型是（可能为提升后的）{{spar sep|表达式}}的类型。
@@ 内建的提升操作的结果是{{spar sep|表达式}}的值。如果操作数为提升后的整数或指针类型的纯右值，则内建的一元加运算为无操作。否则，整数提升或左值到右值、数组到指针、函数到指针或用户定义转换会更改操作数的类型或值类别。例如在一元加表达式中 {{c/core|char}} 会被转换为 {{c/core|int}} {{rev inl|since=c++11|，而非泛型且无捕获的 {{rlp|lambda|lambda 表达式}}会被转换为函数指针}}。

@2@ 对于内建一元减运算符，{{spar sep|表达式}}必须是一个算术或无作用域枚举类型的纯右值。对{{spar sep|表达式}}实施整数提升，结果的类型是提升后的{{spar sep|表达式}}的类型。
@@ 内建的取反操作的结果是提升后的{{spar sep|表达式}}的相反数。对于无符号的 {{c|a}}，{{c|-a}} 的值是 {{mathjax-or|\({\small 2^N-a}\)|2{{su|p=N}}-a}}，其中 {{c|N}} 是提升后的位数。
* 也就是说，结果是操作数的补码（其中操作数和结果都视为无符号数）。

{{anchor|一元算术运算符重载}}
====重载====
在{{rlp|overload resolution#调用重载运算符|针对用户定义运算符的重载决议}}中，对于每个无 cv 限定的提升后算术类型 {{tt|A}} 和每个类型 {{tt|T}}，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|A operator+(A)}}
{{dcl|T* operator+(T*)}}
{{dcl|A operator-(A)}} 
{{dcl end}}

{{example
|code=
#include &lt;iostream&gt;

int main()
{
    char c = 0x6a;
    int n1 = 1;
    unsigned char n2 = 1;
    unsigned int n3 = 1;
    std::cout &lt;&lt; "char：" &lt;&lt; c &lt;&lt; " int：" &lt;&lt; +c &lt;&lt; '\n'
              &lt;&lt; "-1，当 1 的类型是 signed 时：" &lt;&lt; -n1 &lt;&lt; '\n'
              &lt;&lt; "-1，当 1 的类型是 unsigned char 时：" &lt;&lt; -n2 &lt;&lt; '\n'
              &lt;&lt; "-1，当 1 的类型是 unsigned int 时：" &lt;&lt; -n3 &lt;&lt; '\n';
    char a[3];
    std::cout &lt;&lt; "数组大小：" &lt;&lt; sizeof a &lt;&lt; '\n'
              &lt;&lt; "指针大小：" &lt;&lt; sizeof +a &lt;&lt; '\n';
}
|output=
char：j int：106
-1，当 1 的类型是 signed 时：-1
-1，当 1 的类型是 unsigned char 时：-1
-1，当 1 的类型是 unsigned int 时：4294967295
数组大小：3
指针大小：8
}}

===加性运算符===
二元加性运算符表达式的形式为

{{sdsc begin}}
{{sdsc|num=1|{{spar|左操作数}} {{ttb|+}} {{spar|右操作数}}}}
{{sdsc|num=2|{{spar|左操作数}} {{ttb|-}} {{spar|右操作数}}}}
{{sdsc end}}
@1@ 二元加（加法）。
@2@ 二元减（减法）。

二元 {{tt|+}} 和 {{tt|-}} 运算符的{{rlp|operator precedence|优先级}}高于 {{tt|*}}、{{tt|/}} 和 {{tt|%}} 以外的所有其他二元算术运算符。这些运算符从左到右结合：
{{source|
a + b * c;  // 等价于 a + (b * c) ，而不是 (a + b) * c
d / e - f;  // 等价于 (d / e) - f ，而不是 d / (e - f)
g + h &gt;&gt; i; // 等价于 (g + h) &gt;&gt; i，而不是 g + (h &gt;&gt; i)

j - k + l - m; // 等价于 ((j - k) + l) - m
}}

====内建加性运算符====
对于内建二元加和二元减运算符，{{spar sep|左操作数}}和{{spar sep|右操作数}}都必须是纯右值，并且必须满足以下条件之一：
* 两个操作数都具有算术或无作用域枚举类型。此时会对它们进行{{rlp|usual arithmetic conversions|一般算术转换}}。
* 恰有一个操作数具有整数或无作用域枚举类型。此时会对该操作数进行整数提升。

在本段的后续描述中，“操作数”、{{spar sep|左操作数}}和{{spar sep|右操作数}}均指代转换后或提升后的操作数。

@1@ 内建加法必须满足以下条件之一：
* 两个操作数都具有算术类型。此时结果是两个操作数的和。
* 一个操作数是指向完全定义的对象类型的指针，而另一个操作数具有整数类型。此时会从该指针加上该整数值（见{{lsd|#指针算术}}）。
@2@ 内建减法必须满足以下条件之一：
* 两个操作数都具有算术类型。此时结果是两个操作数的差。
* 一个操作数是指向完全定义的对象类型的指针，而另一个操作数具有整数类型。此时会从该指针减去该整数值（见{{lsd|#指针算术}}）。
* 两个操作数都是指向相同的完全定义的对象类型的有 cv 限定或无 cv 限定版本的指针。此时会从{{spar sep|左操作数}}减去{{spar|右操作数}}（见{{lsd|#指针算术}}）。

如果两个操作数都具有浮点数类型，并且该类型支持 IEEE 浮点数算术（见 {{lc|std::numeric_limits::is_iec559}}），那么会有以下特殊计算结果：
:* 如果操作数之一是 NaN，那么结果是 NaN。
:* 无穷减无穷是 NaN，并引发 {{lc|FE_INVALID}}。
:* 无穷加负无穷是 NaN，并引发 {{lc|FE_INVALID}}。

====指针算术====
当从具有指针类型的表达式 {{c|P}} 加上或减去具有整数类型的表达式 {{c|J}} 时，结果的类型与 {{c|P}} 相同。
* 如果 {{c|P}} 求值为{{rlp|pointer#空指针|空指针值}}且 {{c|J}} 求值为 {{c|0}}，那么结果是空指针值。
* 否则，如果 {{c|P}} 指向包含 {{c|n}} 个元素的数组对象 {{c|x}} 的第 {{tt|i}} 个元素，那么给定 {{c|J}} 的值为 {{c|j}}，按以下方式从 {{c|P}} 加上或减去值：
:* 表达式 {{c|P + J}} 和 {{c|J + P}}
::* 在 {{c|i + j}} 在 {{range|0|n}} 中时指向 {{c|x}} 的第 {{tt|i+j}} 个元素，并且
::* 在 {{c|i + j}} 是 {{c|n}} 时是 {{c|x}} 的最后一个元素的尾后指针。
:* 表达式 {{c|P - J}}
::* 在 {{c|i - j}} 在 {{range|0|n}} 中时指向 {{c|x}} 的第 {{tt|i-j}} 个元素，并且
::* 在 {{c|i - j}} 是 {{c|n}} 时是 {{c|x}} 的最后一个元素的尾后指针。
:* 其他 {{c|j}} 值都会导致未定义行为。
* 否则，如果 {{c|P}} 指向完整对象，基类子对象或成员子对象 {{c|y}}，那么给定 {{c|J}} 的值为 {{c|j}}，按以下方式从 {{c|P}} 加上或减去值：
:* 表达式 {{c|P + J}} 和 {{c|J + P}}
::* 在 {{c|j}} 是 {{c|0}} 时指向 {{c|y}}，并且
::* 在 {{c|j}} 是 {{c|1}} 时是 {{c|y}} 的尾后指针。
:* 表达式 {{c|P - J}}
::* 在 {{c|j}} 是 {{c|0}} 时指向 {{c|y}}，并且
::* 在 {{c|j}} 是 {{c|-1}} 时是 {{c|y}} 的尾后指针。
:* 其他 {{c|j}} 值都会导致未定义行为。
* 否则，如果 {{c|P}} 是对象 {{c|z}} 的尾后指针，那么给定 {{c|J}} 的值为 {{c|j}}：
:* 如果 {{c|z}} 是指向包含 {{c|n}} 个元素的数组对象，那么按以下方式从 {{c|P}} 加上或减去值：
::* 表达式 {{c|P + J}} 和 {{c|J + P}}
:::* 在 {{c|n + j}} 在 {{range|0|n}} 中时指向 {{c|z}} 的第 {{tt|n+j}} 个元素，并且
:::* 在 {{c|j}} 是 {{c|0}} 时是 {{c|z}} 的最后一个元素的尾后指针。
::* 表达式 {{c|P - J}}
:::* 在 {{c|n - j}} 在 {{range|0|n}} 中时指向 {{c|z}} 的第 {{tt|n-j}} 个元素，并且
:::* 在 {{c|j}} 是 {{c|0}} 时是 {{c|z}} 的最后一个元素的尾后指针。
::* 其他 {{c|j}} 值都会导致未定义行为。
:* 否则，按以下方式从 {{c|P}} 加上或减去值：
::* 表达式 {{c|P + J}} 和 {{c|J + P}}
:::* 在 {{c|j}} 是 {{c|-1}} 时指向 {{c|z}}，并且
:::* 在 {{c|j}} 是 {{c|0}} 时是 {{c|z}} 的尾后指针。
::* 表达式 {{c|P - J}}
:::* 在 {{c|j}} 是 {{c|1}} 时指向 {{c|z}}，并且
:::* 在 {{c|j}} 是 {{c|0}} 时是 {{c|z}} 的尾后指针。
::* 其他 {{c|j}} 值都会导致未定义行为。
* 否则行为未定义。

当两个指针表达式 {{c|P}} 和 {{c|Q}} 相减时，结果类型是 {{lc|std::ptrdiff_t}}。
* 如果 {{c|P}} 和 {{c|Q}} 都求值为{{rlp|pointer#空指针|空指针值}}，那么结果是 {{c|0}}。
* 否则，如果 {{c|P}} 和 {{c|Q}} 分别指向相同的数组对象 {{c|x}} 的第 {{tt|i}} 个和第 {{tt|j}} 个元素，那么表达式 {{c|P - Q}} 的值是 {{c|i − j}}。
:* 如果 {{c|i − j}} 无法以 {{lc|std::ptrdiff_t}} 表示，那么行为未定义。
* 否则，如果 {{c|P}} 和 {{c|Q}} 指向相同的完整对象，基类子对象或成员子对象，那么结果是 {{c|0}}。
* 否则行为未定义。

这些指针算术运算符使得指针满足{{named req|RandomAccessIterator}}的要求。

对于加法和减法，如果 {{c|P}} 或 {{c|Q}} 的类型是“指向（可有 cv 限定的）{{tt|T}} 的指针”，并且 {{tt|T}} 和数组元素类型不{{rlp|implicit conversion#相似类型|相似}}，那么行为未定义：
{{source|1=
int arr[5] = {1, 2, 3, 4, 5};
unsigned int *p = reinterpret_cast&lt;unsigned int*&gt;(arr + 1);
unsigned int k = *p; // OK：k 的值是 2
unsigned int *q = p + 1; // 未定义行为：p 指向的是 int，而不是 unsigned int
}}

{{anchor|加性运算符重载}}
====重载====
在{{rlp|overload resolution#调用重载运算符|针对用户定义运算符的重载决议}}中，对于每对提升后的算术类型 {{tt|L}} 和 {{tt|R}} 和每个对象类型 {{tt|T}}，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|LR operator+(L, R)}}
{{dcl|LR operator-(L, R)}}
{{dcl|T* operator+(T*, std::ptrdiff_t)}}
{{dcl|T* operator+(std::ptrdiff_t, T*)}}
{{dcl|T* operator-(T*, std::ptrdiff_t)}}
{{dcl|std::ptrdiff_t operator-(T*, T*)}}
{{dcl end}}
其中 {{tt|LR}} 是对 {{tt|L}} 和 {{tt|R}} 实施{{rlp|usual arithmetic conversions|一般算术转换}}的结果。

{{example
|code=
#include &lt;iostream&gt;

int main()
{
    char c = 2;
    unsigned int un = 2;
    int  n = -10;
    std::cout &lt;&lt;  " 2 + (-10)，当 2 的类型是 char 时     = " &lt;&lt; c + n &lt;&lt; '\n'
              &lt;&lt;  " 2 + (-10)，当 2 的类型是 unsigned 时 = " &lt;&lt; un + n &lt;&lt; '\n'
              &lt;&lt;  " -10 - 2.12  = " &lt;&lt; n - 2.12 &lt;&lt; '\n';

    char a[4] = {'a', 'b', 'c', 'd'};
    char* p = &amp;a[1];
    std::cout &lt;&lt; "指针相加的例子：" &lt;&lt; *p &lt;&lt; *(p + 2)
              &lt;&lt; *(2 + p) &lt;&lt; *(p - 1) &lt;&lt; '\n';
    char* p2 = &amp;a[4];
    std::cout &lt;&lt; "指针的差：" &lt;&lt; p2 - p &lt;&lt; '\n';
}
|output=&lt;nowiki/&gt;
 2 + (-10)，当 2 的类型是 char 时     = -8
 2 + (-10)，当 2 的类型是 unsigned 时 = 4294967288
 -10 - 2.12  = -12.12
指针相加的例子：bdda
指针的差：3
}}

===乘性运算符===
乘性运算符表达式的形式为

{{sdsc begin}}
{{sdsc|num=1|{{spar|左操作数}} {{ttb|*}} {{spar|右操作数}}}}
{{sdsc|num=2|{{spar|左操作数}} {{ttb|/}} {{spar|右操作数}}}}
{{sdsc|num=3|{{spar|左操作数}} {{ttb|%}} {{spar|右操作数}}}}
{{sdsc end}}
@1@ 乘法。
@2@ 除法。
@3@ 取余。

乘性运算符的{{rlp|operator precedence|优先级}}高于所有其他二元算术运算符。这些运算符从左到右结合：
{{source|
a + b * c;  // 等价于 a + (b * c) ，而不是 (a + b) * c
d / e - f;  // 等价于 (d / e) - f ，而不是 d / (e - f)
g % h &gt;&gt; i; // 等价于 (g % h) &gt;&gt; i，而不是 g % (h &gt;&gt; i)

j * k / l % m; // 等价于 ((j * k) / l) % m
}}

====内建乘性运算符====
对于内建的乘法和除法运算符，两个操作数都必须具有算术或无作用域枚举类型。对于内建的取余运算符，两个操作数都必须具有整数或无作用域枚举类型。对两个操作数应用{{rlp|usual arithmetic conversions|一般算术转换}}。

在本段的后续描述中，“操作数”、{{spar sep|左操作数}}和{{spar sep|右操作数}}均指代转换后的操作数。

@1@ 内建乘法的结果是两个操作数的积。
@@ 如果两个操作数的类型是浮点数类型，并且该类型支持 IEEE 浮点数算术（见 {{lc|std::numeric_limits::is_iec559}}），那么会有以下特殊计算结果：
* 如果操作数之一是 NaN，那么结果是 NaN。
* 无穷乘以零是 NaN，并引发 {{lc|FE_INVALID}}。

@2@ 内建除法的结果是{{spar sep|左操作数}}除以{{spar sep|右操作数}}的商。如果{{spar sep|右操作数}}为零，那么行为未定义。
@@ 如果两个操作数具有整数类型，那么结果是代数商（进行整数除法）：商向零取整（舍弃小数部分）。
@@ 如果两个操作数具有浮点数类型，并且该类型支持 IEEE 浮点数算术（见 {{lc|std::numeric_limits::is_iec559}}），那么会有以下特殊计算结果：
* 如果操作数之一是 NaN，那么结果是 NaN。
* 非零数除以 ±0.0 会得到符号正确的无穷，并引发 {{lc|FE_DIVBYZERO}}。
* 0.0 除以 0.0 是 NaN，并引发 {{lc|FE_INVALID}}。

@3@ 内建取余的结果是{{spar sep|左操作数}}按整数除法除以{{spar sep|右操作数}}的余数。如果{{spar sep|右操作数}}为零，那么行为未定义。
@@ 如果 {{c|a / b}} 能以结果类型表示，那么 {{c|1=(a / b) * b + a % b == a}}。
@@ 如果商 {{c|a / b}} 不能以结果类型表示，那么 {{tt|a / b}} 和 {{tt|a % b}} 的行为均未定义（这意味着在补码系统上 {{c|INT_MIN % -1}} 未定义）。

注意：在 {{cwg|614}} 解决（{{stddoc|n2757}}）之前，如果二元运算符 % 的一或两个操作数为负，那么余数符由实现定义，因为它取决于整数除法的舍入方向。函数 {{lc|std::div}} 在该情况下提供良好定义的行为。

注意：对于浮点数余数，见 {{lc|std::remainder}} 和 {{lc|std::fmod}}。

{{anchor|乘性运算符重载}}
====重载====
在{{rlp|overload resolution#调用重载运算符|针对用户定义运算符的重载决议中}}，对于每对提升后的算术类型 {{tt|LA}} 与 {{tt|RA}} 及每对提升后的整数类型 {{tt|LI}} 与 {{tt|RI}}，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|LRA operator*(LA, RA)}}
{{dcl|LRA operator/(LA, RA)}}
{{dcl|LRI operator%(LI, RI)}}
{{dcl end}}
其中 {{tt|LRx}} 是对 {{tt|Lx}} 和 {{tt|Rx}} 实施{{rlp|usual arithmetic conversions|一般算术转换}}的结果。

{{example
|code=
#include &lt;iostream&gt;

int main()
{
    char c = 2;
    unsigned int un = 2;
    int  n = -10;
    std::cout &lt;&lt;  "2 * (-10)，当 2 的类型是 char 时     = " &lt;&lt; c * n &lt;&lt; '\n'
              &lt;&lt;  "2 * (-10)，当 2 的类型是 unsigned 时 = " &lt;&lt; un * n &lt;&lt; '\n'
              &lt;&lt;  "-10 / 2.12  = " &lt;&lt; n / 2.12 &lt;&lt; '\n'
              &lt;&lt;  "-10 / 21  = " &lt;&lt; n / 21 &lt;&lt; '\n'
              &lt;&lt;  "-10 % 21  = " &lt;&lt; n % 21 &lt;&lt; '\n';
}
|output=
2 * (-10)，当 2 的类型是 char 时     = -20
2 * (-10)，当 2 的类型是 unsigned 时 = 4294967276
-10 / 2.12  = -4.71698
-10 / 21  = 0
-10 % 21  = -10
}}

===逐位逻辑运算符===
逐位逻辑运算符表达式的形式为

{{sdsc begin}}
{{sdsc|num=1|{{ttb|~}} {{spar|右操作数}}}}
{{sdsc|num=2|{{spar|左操作数}} {{ttb|&amp;}} {{spar|右操作数}}}}
{{sdsc|num=3|{{spar|左操作数}} {{ttb|{{!}}}} {{spar|右操作数}}}}
{{sdsc|num=4|{{spar|左操作数}} {{ttb|^}} {{spar|右操作数}}}}
{{sdsc end}}
@1@ 逐位非（NOT）。
@2@ 逐位与（AND）。
@3@ 逐位或（OR）。
@4@ 逐位异或（XOR）。

逐位非运算符的{{rlp|operator precedence|优先级}}高于所有二元算术运算符。它从右到左结合：
{{source|
~a - b; // 等价于 (~a) - b，而不是 ~(a - b)
~c * d; // 等价于 (~c) * d，而不是 ~(c * d)

~-e; // 等价于 ~(-e)
}}

{{c|~}} 在后随{{rlp|type#类型的命名|类型名}}{{rev inl|since=c++11|或 {{rlpt|decltype}} 说明符}}时在语法上有歧义：它可以是 operator~，也可以是{{rlp|destructor|析构函数}}标识符的开始。该歧义通过将 {{c|~}} 视为 operator~ 解决。只有在不能组成 operator~ 的地方才能用 {{c|~}} 作为析构函数标识符的开始。

所有其他逐位逻辑运算符的{{rlp|operator precedence|优先级}}低于所有其他二元算术运算符。此外，逐位与的优先级高于逐位异或，逐位异或的优先级高于逐位或。这些运算符从左到右结合：
{{source|
a &amp; b * c;  // 等价于 a &amp; (b * c) ，而不是 (a &amp; b) * c
d / e ^ f;  // 等价于 (d / e) ^ f ，而不是 d / (e ^ f)
g &lt;&lt; h {{!}} i; // 等价于 (g &lt;&lt; h) {{!}} i，而不是 g &lt;&lt; (h {{!}} i)

j &amp; k &amp; l; // 等价于 (j &amp; k) &amp; l
m {{!}} n ^ o  // 等价于 m {{!}} (n ^ o)
}}

====内建逐位逻辑运算符====
对于内建的逐位非运算符，{{spar sep|右操作数}}必须是整数或无作用域枚举类型的纯右值，并且会对它进行整数提升。对于其他内建的逐位逻辑运算符，两个操作数都必须具有整数或无作用域枚举类型，并且会对它们进行{{rlp|usual arithmetic conversions|一般算术转换}}。

在本段的后续描述中，“操作数”、{{spar sep|左操作数}}和{{spar sep|右操作数}}均指代转换后或提升后的操作数。

@1@ 给定操作数为 {{c|x}}，内建逐位非操作的结果为 {{c|r}}。对于 {{c|x}} 的二进制表示的每个系数 {{c|x_i}}，{{c|r}} 的二进制表示的对应系数 {{c|r_i}} 在 {{c|x_i}} 是 {{c|0}} 时是 {{c|1}}，否则是 {{c|0}}。
* 也就是说，结果是操作数的反码（其中操作数和结果都视为无符号数）。
@@ 结果 {{c|r}} 的类型就是操作数 {{c|x}} 的类型。

@2-4@ 给定操作数为 {{c|x}} 和 {{c|y}}，内建逐位逻辑操作的结果为 {{c|r}}。对于 {{c|x}} 和 {{c|y}} 的二进制表示的每对系数 {{c|x_i}} 和 {{c|y_i}}，{{c|r}} 的二进制表示的对应系数 {{c|r_i}}
:@2@ 在 {{c|x_i}} 和 {{c|y_i}} 都是 {{c|1}} 时是 {{c|1}}，否则是 {{c|0}}。
:@3@ 在 {{c|x_i}} 和 {{c|y_i}} 其中至少一个是 {{c|1}} 时是 {{c|1}}，否则是 {{c|0}}。
:@3@ 在 {{c|x_i}} 和 {{c|y_i}} 其中一个是（但不能两个都是）{{c|1}} 时是 {{c|1}}，否则是 {{c|0}}。
@@ 结果 {{c|r}} 的类型就是操作数 {{c|x}} 和 {{c|y}} 的类型。

{{anchor|逐位逻辑运算符重载}}
====重载====
在{{rlp|overload resolution#调用重载运算符|针对用户定义运算符的重载决议}}中，对于每对提升后的整数类型 {{tt|L}} 和 {{tt|R}}，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|R operator~(R)}}
{{dcl|LR operator&amp;(L, R)}}
{{dcl|LR operator^(L, R)}}
{{dcl|LR operator{{!}}(L, R)}}
{{dcl end}}
其中 {{tt|LR}} 是对 {{tt|L}} 和 {{tt|R}} 实施{{rlp|usual arithmetic conversions|一般算术转换}}的结果。

{{example
|code=
#include &lt;bitset&gt;
#include &lt;cstdint&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;

int main()
{
    uint16_t mask = 0x00f0;
    uint32_t x0 = 0x12345678;
    uint32_t x1 = x0 {{!}} mask;
    uint32_t x2 = x0 &amp; ~mask;
    uint32_t x3 = x0 &amp; mask;
    uint32_t x4 = x0 ^ mask;
    uint32_t x5 = ~x0;
    using bin16 = std::bitset&lt;16&gt;;
    using bin32 = std::bitset&lt;32&gt;;
    std::cout &lt;&lt; std::hex &lt;&lt; std::showbase
              &lt;&lt; "掩码：" &lt;&lt; mask &lt;&lt; std::setw(39) &lt;&lt; bin16(mask) &lt;&lt; '\n'
              &lt;&lt; "值：" &lt;&lt; x0 &lt;&lt; std::setw(33) &lt;&lt; bin32(x0) &lt;&lt; '\n'
              &lt;&lt; "设置各位：" &lt;&lt; x1 &lt;&lt; std::setw(33) &lt;&lt; bin32(x1) &lt;&lt; '\n'
              &lt;&lt; "清除各位：" &lt;&lt; x2 &lt;&lt; std::setw(33) &lt;&lt; bin32(x2) &lt;&lt; '\n'
              &lt;&lt; "选择各位：" &lt;&lt; x3 &lt;&lt; std::setw(39) &lt;&lt; bin32(x3) &lt;&lt; '\n'
              &lt;&lt; "异或各位：" &lt;&lt; x4 &lt;&lt; std::setw(33) &lt;&lt; bin32(x4) &lt;&lt; '\n'
              &lt;&lt; "取反各位：" &lt;&lt; x5 &lt;&lt; std::setw(33) &lt;&lt; bin32(x5) &lt;&lt; '\n';
}
|output=
掩码：0xf0                           0000000011110000
值：0x12345678       00010010001101000101011001111000
设置各位：0x123456f8 00010010001101000101011011111000
清除各位：0x12345608 00010010001101000101011000001000
选择各位：0x70       00000000000000000000000001110000
异或各位：0x12345688 00010010001101000101011010001000
取反各位：0xedcba987 11101101110010111010100110000111
}}

===移位运算符===
移位运算符表达式的形式为

{{sdsc begin}}
{{sdsc|num=1|{{spar|左操作数}} {{ttb|&lt;&lt;}} {{spar|右操作数}}}}
{{sdsc|num=2|{{spar|左操作数}} {{ttb|&gt;&gt;}} {{spar|右操作数}}}}
{{sdsc end}}
@1@ 向左移位。
@2@ 向右移位。

移位运算符的{{rlp|operator precedence|优先级}}高于逐位逻辑运算符，但低于加性和乘性运算符。这些运算符从左到右结合：
{{source|
a &gt;&gt; b * c;  // 等价于 a &gt;&gt; (b * c) ，而不是 (a &gt;&gt; b) * c
d &lt;&lt; e &amp; f;  // 等价于 (d &lt;&lt; e) &amp; f ，而不是 d &lt;&lt; (e &amp; f)

g &lt;&lt; h &gt;&gt; i; // 等价于 (g &lt;&lt; h) &gt;&gt; i，而不是 g &lt;&lt; (h &gt;&gt; i)
}}

====内建移位运算符====
对于内建的移位运算符，两个操作数都必须具有整数或无作用域枚举类型，并且会对它们进行整数提升。

在本段的后续描述中，“操作数”、{{c|a}}、{{c|b}}、{{spar sep|左操作数}}和{{spar sep|右操作数}}均指代提升后的操作数。

任何情况下，如果{{spar sep|右操作数}}的值为负或不小于{{spar sep|左操作数}}中的位数，那么行为未定义。

{{rrev multi|until1=c++20|rev1=
对于无符号 {{c|a}}，{{c|a &lt;&lt; b}} 的值是 {{math|a * 2{{su|p=b}}}} 对 {{math|2{{su|p=N}}}} 取模，其中 {{math|N}} 是返回类型中的位数（即进行逐位左移并舍弃移出目标类型的位）。

对于有符号的非负 {{c|a}}，如果 {{math|a * 2{{su|p=b}}}} 能以返回类型的无符号版本表示，那么将该值{{rlp|implicit conversion#整数转换|转换}}到有符号后即是 {{c|a &lt;&lt; b}} 的值（这使得以 {{c|1 &lt;&lt; 31}} 创建 {{lc|INT_MIN}} 合法）；否则行为未定义。

对于负 {{c|a}}，{{c|a &lt;&lt; b}} 的行为未定义。

对于无符号 {{c|a}} 和有符号的非负 {{c|a}}，{{c|a &gt;&gt; b}} 的值是 {{math|a/2{{su|p=b}}}} 的整数部分。

对于负 {{c|a}}，{{c|a &gt;&gt; b}} 的值由实现定义（大多数平台上进行算术右移，因此结果保留为负）。
|rev2=
{{c|a &lt;&lt; b}} 的值是与 {{math|a * 2{{su|p=b}}}} 对 {{math|2{{su|p=N}}}} 同余的唯一值，其中 {{math|N}} 是返回类型中的位数（即进行逐位左移并舍弃移出目标类型的位）。

{{c|a &gt;&gt; b}} 的值是 {{math|a/2{{su|p=b}}}} 向负无穷取整（换言之，有符号 {{c|a}} 上的右移是算术右移）。
}}

返回类型是{{spar sep|左操作数}}的类型。

{{anchor|移位运算符重载}}
====重载====
在{{rlp|overload resolution#调用重载运算符|针对用户定义运算符的重载决议}}中，对于每对提升后的整数类型 {{tt|L}} 和 {{tt|R}}，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|L operator&lt;&lt;(L, R)}}
{{dcl|L operator&gt;&gt;(L, R)}} 
{{dcl end}}

{{example
|code=
#include &lt;iostream&gt;

enum { ONE = 1, TWO = 2 };

int main()
{
    std::cout &lt;&lt; std::hex &lt;&lt; std::showbase;
    char c = 0x10;
    unsigned long long ull = 0x123;
    std::cout &lt;&lt; "0x123 &lt;&lt; 1 = " &lt;&lt; (ull &lt;&lt; 1) &lt;&lt; '\n'
              &lt;&lt; "0x123 &lt;&lt; 63 = " &lt;&lt; (ull &lt;&lt; 63) &lt;&lt; '\n' // 无符号中的溢出
              &lt;&lt; "0x10 &lt;&lt; 10 = " &lt;&lt; (c &lt;&lt; 10) &lt;&lt; '\n';   // 提升 char 到 int
    long long ll = -1000;
    std::cout &lt;&lt; std::dec &lt;&lt; "-1000 &gt;&gt; 1 = " &lt;&lt; (ll &gt;&gt; ONE) &lt;&lt; '\n';
}
|output=
0x123 &lt;&lt; 1 = 0x246
0x123 &lt;&lt; 63 = 0x8000000000000000
0x10 &lt;&lt; 10 = 0x4000
-1000 &gt;&gt; 1 = -500
}}

===标准库===
许多标准库类型都重载了算术运算符。

====一元算术运算符====
{{dsc begin}}
{{dsc inc|cpp/chrono/duration/dsc operator arith}}
{{dsc inc|cpp/numeric/complex/dsc operator arith2}}
{{dsc inc|cpp/numeric/valarray/dsc operator arith}}
{{dsc end}}

====加性运算符====
{{dsc begin}}
{{dsc inc|cpp/chrono/time_point/dsc operator arith2}}
{{dsc inc|cpp/chrono/duration/dsc operator arith4}}
{{dsc inc|cpp/chrono/year_month_day/dsc operator arith 2}}
{{dsc inc|cpp/string/basic_string/dsc operator+}}
{{dsc mem fun|cpp/iterator/reverse_iterator/operator arith|title=operator+&lt;br&gt;operator-|推进或减小迭代器}}
{{dsc mem fun|cpp/iterator/move_iterator/operator arith|title=operator+&lt;br&gt;operator-|推进或减小迭代器}}
{{dsc inc|cpp/numeric/complex/dsc operator arith3}}
{{dsc inc|cpp/numeric/valarray/dsc operator arith3}}
{{dsc end}}

====乘性运算符====
{{dsc begin}}
{{dsc inc|cpp/chrono/duration/dsc operator arith4}}
{{dsc inc|cpp/numeric/complex/dsc operator arith3}}
{{dsc inc|cpp/numeric/valarray/dsc operator arith3}}
{{dsc end}}

====逐位逻辑运算符====
{{dsc begin}}
{{dsc inc|cpp/utility/bitset/dsc operator logic}}
{{dsc inc|cpp/utility/bitset/dsc operator logic2}}
{{dsc mem fun|cpp/numeric/valarray/operator arith|title=operator~|对 valarray 的每个元素运用一元算术运算符}}
{{dsc tfun|cpp/numeric/valarray/operator arith3|title=operator^&lt;br&gt;operator&amp;&lt;br&gt;operator{{!}}|对两个 valarray 的每个元素，或一个 valarray 的每个元素和一个值运用二元运算符}}
{{dsc end}}

====移位运算符====
{{dsc begin}}
{{dsc tfun|cpp/numeric/valarray/operator arith3|title=operator&lt;&lt;&lt;br&gt;operator&gt;&gt;|对两个 valarray 的每个元素，或一个 valarray 的每个元素和一个值运用二元运算符}}
{{dsc mem fun|cpp/utility/bitset/operator ltltgtgt|title=operator&lt;&lt;&lt;br&gt;operator&gt;&gt;|进行二进制左移和右移}}
{{dsc end}}

====流插入/提取运算符====
整个标准库中，移位运算符常对输入/输出流（{{c/core|std::ios_base&amp;}} 或从它派生的类之一）重载，以之为左运算数和返回类型。这种运算符被称为''流插入''和''流提取''运算符：

{{dsc begin}}
{{dsc inc|cpp/io/basic_istream/dsc operator gtgt}}
{{dsc inc|cpp/io/basic_istream/dsc operator gtgt2}}
{{dsc inc|cpp/io/basic_ostream/dsc operator ltlt}}
{{dsc inc|cpp/io/basic_ostream/dsc operator ltlt2}}
{{dsc inc|cpp/numeric/complex/dsc operator ltltgtgt}}
{{dsc inc|cpp/utility/bitset/dsc operator ltltgtgt2}}
{{dsc inc|cpp/string/basic_string/dsc operator ltltgtgt}}
{{dsc inc|cpp/numeric/random/engine/dsc operator ltltgtgt|linear_congruential_engine}}
{{dsc inc|cpp/numeric/random/distribution/dsc operator ltltgtgt|uniform_int_distribution}}
{{dsc end}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=614|std=C++98|before=整数除法的算术商的取整方向由实现定义|after=向零取整（舍弃小数部分）}}
{{dr list item|wg=cwg|dr=1450|std=C++98|before=未指明 {{c|a / b}} 在无法以结果类型表示时的结果|after=此时 {{c|a / b}} 和 {{c|a % b}} 的行为均未定义}}
{{dr list item|wg=cwg|dr=1457|std=C++98|before=将正的有符号值的最左端的 1 位移入符号位的行为未定义|after=赋予良好定义}}
{{dr list item|wg=cwg|dr=1504|std=C++98|before=指向数组元素的基类子对象的指针可以用于指针算术|after=此时行为未定义}}
{{dr list item|wg=cwg|dr=1515|std=C++98|before=只有声明了 {{c/core|unsigned}} 的无符号整数需要遵循 {{math|modulo 2{{su|p=n}}}} 算术规则|after=应用到所有无符号整数}}
{{dr list item|wg=cwg|dr=1642|std=C++98|before=算术运算符的操作数可以是左值|after=部分操作数必须是右值}}
{{dr list item|wg=cwg|dr=1865|std=C++98|before={{cwg|1504}} 的解决方案导致指向数组元素的指针在指针指向&lt;br&gt;类型和数组类型的非顶层 cv 限定不同时参与指针运算的行为未定义|after=赋予良好定义}}
{{dr list item|wg=cwg|dr=1971|std=C++98|before=不明确用来解决 {{c|~}} 的歧义的规则是否适用 {{c|~X(0)}} 这种情况|after=适用这种情况}}
{{dr list item|wg=cwg|dr=2419|std=C++98|before=只有通过 {{c|&amp;}} 获取的到非数组对象的指针才会在&lt;br&gt;指针运算中被视为到大小为 1 的数组的首元素的指针|after=应用到所有到非数组对象的指针}}
{{dr list item|wg=cwg|dr=2626|std=C++98|before=内建 {{c/core|operator~}} 的结果只是“反码”，而没有适当的定义|after=结果用二进制表示进行描述}}
{{dr list item|wg=cwg|dr=2724|std=C++20|before=向右移位的取整方向不明确|after=使之明确}}
{{dr list item|wg=cwg|dr=2853|std=C++98|before=对象末尾后指针无法与整数相加或相减|after=可以相加或相减}}
{{dr list end}}

===参阅===
{{rlp|operator precedence|运算符优先级}}

{{rlp|operators|运算符重载}}

{{cpp/language/operators}}
{{dsc begin}}
{{dsc see c|c/language/operator arithmetic|算术运算符|nomono=true}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}