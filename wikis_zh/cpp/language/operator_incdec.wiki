{{title|自增/自减运算符}}
{{cpp/language/expressions/navbar}}
自增/自减运算符增加或减小对象的值。

{| class="wikitable" style="font-size:85%;"
|-
! rowspan="2" | 运算符名
! rowspan="2" | 语法
! rowspan="2" | {{rlp|operators|可重载}}
! colspan="2" | 原型示例（对于类 {{c/core|class T}}）
|-
! 类内定义
! 类外定义
|-
| 前自增
| {{tt|++a}} 
| {{yes}}
| {{c|T&amp; T::operator++();}} 
| {{c|T&amp; operator++(T&amp; a);}}
|-
| 前自减
| {{tt|--a}} 
| {{yes}}
| {{c|T&amp; T::operator--();}} 
| {{c|T&amp; operator--(T&amp; a);}}
|-
| 后自增
| {{tt|a++}} 
| {{yes}}
| {{c|T T::operator++(int);}} 
| {{c|T operator++(T&amp; a, int);}}
|-
| 后自减
| {{tt|a--}} 
| {{yes}}
| {{c|T T::operator--(int);}} 
| {{c|T operator--(T&amp; a, int);}}
|-
| colspan="5" |
:'''注解'''&lt;br&gt;
* 内建运算符的前置版本返回''引用''{{sep}}而后置版本返回''值''，典型的{{rlp|operators|用户定义重载}}也遵循该模式，从而使用户定义运算符可以与内建版本相同的方式使用。然而，用户定义重载中，能以任何类型为返回类型（包括 {{c/core|void}}）。
* {{c/core|int}} 形参是用于区别运算符的前置和后置版本的空设形参。调用用户定义的运算符时，该形参中传递的值始终为零，但通过函数调用记法调用这个运算符时可以更改它（例如 {{c|a.operator++(2)}} 或 {{c|operator++(a, 2)}}）。
|}

===前置运算符===
前置自增与自减表达式的形式为
{{sdsc begin}}
{{sdsc|{{ttb|++}} {{spar|表达式}}}}
{{sdsc|{{ttb|--}} {{spar|表达式}}}}
{{sdsc end}}
@1@ 前置自增（前自增）
@2@ 前置自减（前自减）

====内建的前置运算符====
@1@ 表达式 {{c|++x}} 等价于 {{c|1=x += 1}}，但有以下例外：
{{rev begin}}
{{rev|until=c++17|
* 如果{{spar sep|表达式}}的类型是（可有 volatile 限定的）{{c/core|bool}}，那么会将{{spar sep|表达式}}设为 {{c|true}}。此类自增已弃用。
}}
{{rev|since=c++17|
* 如果{{spar sep|表达式}}的类型是（可有 cv 限定的）{{c/core|bool}}，那么程序非良构。
}}
{{rev|since=c++20|
* 如果{{spar sep|表达式}}的类型有 volatile 限定，那么此类自增已弃用。
}}
{{rev end}}

@2@ 表达式 {{c|--x}} 等价于 {{c|1=x -= 1}}，但有以下例外：
* 如果{{spar sep|表达式}}的类型是（可有 cv 限定的）{{c/core|bool}}，那么程序非良构。
{{rrev|since=c++20|
* 如果{{spar sep|表达式}}的类型有 volatile 限定，那么此类自减已弃用。
}}

{{anchor|前置重载}}
====重载====
在{{rlp|overload resolution#调用重载运算符|针对用户定义运算符的重载决议}}中，对于每个 {{c/core|bool}} 以外的可选地有 volatile 限定的算术类型 {{tt|A}}，和对于每个可选地有 volatile 限定的指向可选地有 cv 限定的对象类型的指针 {{tt|P}}，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|A&amp; operator++(A&amp;)}}
{{dcl|bool&amp; operator++(bool&amp;)|notes={{mark deprecated}}{{mark until c++17}}}}
{{dcl|P&amp; operator++(P&amp;)}}
{{dcl|A&amp; operator--(A&amp;)}}
{{dcl|P&amp; operator--(P&amp;)}}
{{dcl end}}

===后置运算符===
后置自增与自减表达式拥有形式
{{sdsc begin}}
{{sdsc|{{spar|表达式}} {{ttb|++}}}}
{{sdsc|{{spar|表达式}} {{ttb|--}}}}
{{sdsc end}}
@1@ 后置自增（后自增）
@2@ 后置自减（后自减）

====内建的后置运算符====
后置自增和自减的结果是对{{spar sep|表达式}}（在修改前）应用{{rlps|implicit conversion#左值到右值转换}}得到的值。结果类型是{{spar sep|表达式}}的类型的无 cv 限定版本。

如果{{spar sep|表达式}}不是具有{{rev inl|since=c++17|（可有 cv 限定的）{{c/core|bool}} 以外的}}整数类型或指向完整对象类型的指针类型，那么程序非良构。

{{rrev|since=c++20|
如果{{spar sep|表达式}}的类型有 volatile 限定，那么此类自增和自减已弃用。
}}

@1@ {{spar sep|表达式}}的值如同以将它作为前置 {{tt|++}} 运算符的方式被修改。

@2@ {{spar sep|表达式}}的值如同以将它作为前置 {{tt|--}} 运算符的方式被修改。

后置自增和自减的值计算{{rlp|eval order|按顺序早于}}对{{spar sep|表达式}}的修改。对于顺序不确定的函数调用，后置自增和自减操作会被视为单次求值。

{{anchor|后置重载}}
====重载====
在{{rlp|overload resolution#调用重载运算符|针对用户定义运算符的重载决议}}中，对于每个 {{c/core|bool}} 以外的可选地有 volatile 限定的算术类型 {{tt|A}}，和对于每个可选地有 volatile 限定的指向可选地有 cv 限定的对象类型的指针 {{tt|P}}，下列函数签名参与重载决议：
{{dcl begin}}
{{dcl|A operator++(A&amp;, int)}}
{{dcl|bool operator++(bool&amp;, int)|notes={{mark deprecated}}{{mark until c++17}}}}
{{dcl|P operator++(P&amp;, int)}}
{{dcl|A operator--(A&amp;, int)}}
{{dcl|P operator--(P&amp;, int)}}
{{dcl end}}

====示例====
{{example
|code=
#include &lt;iostream&gt;

int main()
{
    int n1 = 1;
    int n2 = ++n1;
    int n3 = ++ ++n1;
    int n4 = n1++;
//  int n5 = n1++ ++;   // 错误
//  int n6 = n1 + ++n1; // 未定义行为
    std::cout &lt;&lt; "n1 = " &lt;&lt; n1 &lt;&lt; '\n'
              &lt;&lt; "n2 = " &lt;&lt; n2 &lt;&lt; '\n'
              &lt;&lt; "n3 = " &lt;&lt; n3 &lt;&lt; '\n'
              &lt;&lt; "n4 = " &lt;&lt; n4 &lt;&lt; '\n';
}
|output=
n1 = 5
n2 = 2
n3 = 4
n4 = 4
}}

===注解===
因为涉及到了副作用，所以必须谨慎使用内建的自增和自减运算符，以避免违背{{rlp|eval order|求值顺序规则}}所致的未定义行为。

因为后自增和后自减期间会构造对象的临时副本，所以在不使用返回值的语境中''前自增''{{sep}}或''前自减''{{sep}}运算符通常更有效率。

===标准库===
自增和自减运算符对许多标准库类型重载。特别是每个{{named req|Iterator|迭代器}}都重载了 {{c/core|operator++}}，而且每个{{named req|BidirectionalIterator|双向迭代器}}都重载了 {{c/core|operator--}}，即便这些运算符对于某些特定迭代器是无操作的。

{{dsc begin}}
{{dsc h2|对算术类型的重载}}
{{dsc inc|cpp/atomic/atomic/dsc operator arith}}
{{dsc inc|cpp/chrono/duration/dsc operator arith2}}
{{dsc h2|对迭代器类型的重载}}
{{dsc inc|cpp/memory/raw_storage_iterator/dsc operator arith}}
{{dsc inc|cpp/iterator/adaptor/dsc operator arith|reverse_iterator}}
{{dsc inc|cpp/iterator/adaptor/dsc operator arith|move_iterator}}
{{dsc inc|cpp/iterator/inserter/dsc operator arith|front_insert_iterator}}
{{dsc inc|cpp/iterator/inserter/dsc operator arith|back_insert_iterator}}
{{dsc inc|cpp/iterator/inserter/dsc operator arith|insert_iterator}}
{{dsc inc|cpp/iterator/istream_iterator/dsc operator arith}}
{{dsc inc|cpp/iterator/ostream_iterator/dsc operator arith}}
{{dsc inc|cpp/iterator/istreambuf_iterator/dsc operator arith}}
{{dsc inc|cpp/iterator/ostreambuf_iterator/dsc operator arith}}
{{dsc inc|cpp/regex/regex_iterator/dsc operator arith}}
{{dsc inc|cpp/regex/regex_token_iterator/dsc operator arith}}
{{dsc end}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=2855|std=C++98|before=内建前自增和前自减会应用一般算术转换，但后自增和后自减不会&lt;ref&gt;前置形式 {{c|++x}} 等价于 {{c|1=x += 1}}，而后者适用一般算术转换（即在 {{c/core|decltype(x)}} 与 {{c/core|int}} 之间产生公共类型）。然而后置形式 {{c|x++}} 的效果只是简单地“对 {{c|x}} 加一”，因为不存在二元运算符，所以也不会有一般算术转换。&lt;/ref&gt;|after=也会应用}}
{{dr list item|wg=cwg|dr=2901|std=C++98|before=内建后自增和后自减不会应用左值到右值转换|after=会应用}}
{{dr list end}}
&lt;references/&gt;

===参阅===
{{rlp|operator precedence|运算符优先级}}

{{rlp|operators|运算符重载}}
 
{{cpp/language/operators}}
{{dsc begin}}
{{dsc see c|c/language/operator incdec|自增/自减运算符|nomono=true}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}