{{title|列表初始化 {{mark since c++11}}}}
{{cpp/language/initialization/navbar}}

从{{rlp|initialization|花括号包围的初始化器列表}}列表初始化对象。

===语法===
====直接列表初始化====
{{sdsc begin}}
{{sdsc|num=1|
{{spar|T 对象}} {{ttb|{}} {{spar|实参1, 实参2, ...}} {{ttb|};}}
{{rrev|since=c++20|
{{spar|T 对象}}{{ttb|{.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|};}}
}}
}}

{{sdsc|num=2|
{{spar|T}} {{ttb|{}} {{spar|实参1, 实参2, ...}} {{ttb|}&lt;!----&gt;}}
{{rrev|since=c++20|
{{spar|T}} {{ttb|{.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|}&lt;!----&gt;}}
}}
}}

{{sdsc|num=3|
{{ttb|new}} {{spar|T}} {{ttb|{}} {{spar|实参1, 实参2, ...}} {{ttb|}&lt;!----&gt;}}
{{rrev|since=c++20|
{{ttb|new}} {{spar|T}} {{ttb|{.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|}&lt;!----&gt;}}
}}
}}

{{sdsc|num=4|
{{spar|类}} {{ttb|{}} {{spar|T 成员}} {{ttb|{}} {{spar|实参1, 实参2, ...}} {{ttb|}; };}}
{{rrev|since=c++20|
{{spar|类}} {{ttb|{}} {{spar|T 成员}} {{ttb|{.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|}; };}}
}}
}}

{{sdsc|num=5|
{{spar|类}}{{ttb|::}}{{spar|类}}{{ttb|() :}} {{spar|成员}} {{ttb|{}} {{spar|实参1, 实参2, ...}} {{ttb|} {...}}
{{rrev|since=c++20|
{{spar|类}}{{ttb|::}}{{spar|类}}{{ttb|() :}} {{spar|成员}} {{ttb|{.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!----&gt;}} {{spar|...}}{{ttb|} {...}}
}}
}}
{{sdsc end}}

====复制列表初始化====
{{sdsc begin}}
{{sdsc|num=6|
{{spar|T 对象}} {{ttb|1== {}} {{spar|实参1, 实参2, ...}} {{ttb|};}}

{{rrev|since=c++20|
{{spar|T 对象}} {{ttb|1== {.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|};}}
}}
}}

{{sdsc|num=7|
{{spar|函数}} {{ttb|({}} {{spar|实参1, 实参2, ...}} {{ttb|})}}
{{rrev|since=c++20|
{{spar|函数}} {{ttb|({.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|})}}
}}
}}

{{sdsc|num=8|
{{ttb|return {}} {{spar|实参1, 实参2, ...}} {{ttb|};}}
{{rrev|since=c++20|
{{ttb|return }}{{ttb|{.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|};}}
}}
}}

{{sdsc|num=9|
{{spar|对象}} {{ttb|[{}} {{spar|实参1, 实参2, ...}} {{ttb|}]}}
{{rrev|since=c++20|
{{spar|对象}} {{ttb|[{.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|}]}}
}}
}}

{{sdsc|num=10|
{{spar|对象}} {{ttb|1== {}} {{spar|实参1, 实参2, ...}} {{ttb|}&lt;!----&gt;}}
{{rrev|since=c++20|
{{spar|对象}} {{ttb|1== {.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|}&lt;!----&gt;}}
}}
}}

{{sdsc|num=11|
{{spar|U}} {{ttb|({}} {{spar|实参1, 实参2, ...}} {{ttb|})}}
{{rrev|since=c++20|
{{spar|U}} {{ttb|({.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|})}}
}}
}}

{{sdsc|num=12|
{{spar|类}} {{ttb|{}} {{spar|T 成员}} {{ttb|1== {}} {{spar|实参1, 实参2, ...}} {{ttb|}; };}}
{{rrev|since=c++20|
{{spar|类}} {{ttb|{}} {{spar|T 成员}} {{ttb|1== {.}}{{spar|指派符1}} {{ttb|1==}} {{spar|实参1}} {{ttb|, .}}{{spar|指派符2}} {{ttb|{}} {{spar|实参2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|}; };}}
}}
}}
{{sdsc end}}

在下列情形进行列表初始化：
* 直接列表初始化（考虑 explicit 和非 explicit 构造函数）

@1@ 以花括号包围的初始化器列表初始化具名变量
@2@ 以花括号包围的初始化器列表初始化无名临时量
@3@ 以 {{rlp|new|new 表达式}}初始化具有动态存储期的对象，它的初始化器是花括号包围的初始化器列表
@4@ 在不使用等号的非静态{{rlp|data members#成员初始化|数据成员初始化器}}中
@5@ 在构造函数的{{rlp|initializer list|成员初始化列表}}中，如果使用花括号包围的初始化器列表

* 复制列表初始化（考虑 explicit 和非 explicit 构造函数，但只能调用非 explicit 构造函数）

@6@ 以等号后的花括号包围的初始化器列表初始化具名变量
@7@ 函数调用表达式中，以花括号包围的初始化器列表作为实参，以列表初始化对函数形参进行初始化
@8@ 在以花括号包围的初始化器列表作为返回表达式的 {{c/core|return}} 语句中，以列表初始化对返回的对象进行初始化
@9@ 在具有用户定义的 {{tt|operator[]}} 的{{rlp|operator member access#内建的下标运算符|下标表达式}}中，以列表初始化对重载运算符的形参进行初始化
@10@ 在{{rlp|operator assignment|赋值表达式}}中，以列表初始化对重载的运算符的形参进行初始化
@11@ {{rlp|explicit cast|函数风格转换表达式}}或其他构造函数调用，其中花括号包围的初始化器列表用作构造函数实参。以复制初始化对构造函数的形参初始化（注意：此例中的类型 {{tt|U}} 不是被列表初始化的类型；但 {{tt|U}} 的构造函数的形参是）
@12@ 在使用等号的非静态{{rlp|data members#成员初始化|数据成员初始化器}}中

===解释===
（可有 cv 限定的）{{tt|T}} 类型对象的列表初始化的效果是：
{{rrev|since=c++20|
* 如果花括号包围的初始化器列表包含{{rlp|aggregate initialization#指派初始化器|指派初始化器列表}}，并且 {{tt|T}} 不是引用类型，那么 {{tt|T}} 必须是聚合类。由指派初始化器列表中的指派符组成的标识符序列必须是 {{tt|T}} 的非静态数据成员组成的标识符序列的子序列。进行{{rlp|aggregate initialization|聚合初始化}}。
}}
* 如果 {{tt|T}} 是聚合类且花括号包围的初始化器列表{{rev inl|since=c++20|在不含指派初始化器列表的情况下}}拥有单个（可有 cv 限定的）相同类型或派生类型的初始化器子句，那么从该子句初始化对象（对于复制列表初始化为{{rlp|copy initialization|复制初始化}}，对于直接列表初始化为{{rlp|direct initialization|直接初始化}}）。
* 否则，如果 {{tt|T}} 是字符数组且花括号包围的初始化器列表拥有单个类型适当的字符串字面量初始化器子句，那么照常{{rlp|aggregate initialization#字符数组|从字符串字面量初始化}}数组。

* 否则，如果 {{tt|T}} 是{{rlp|aggregate initialization|聚合类型}}，那么进行{{rlp|aggregate initialization|聚合初始化}}。

* 否则，如果花括号包围的初始化器列表为空，且 {{tt|T}} 是拥有默认构造函数的类类型，那么进行{{rlp|value initialization|值初始化}}。

* 否则，如果 {{tt|T}} 是 {{lc|std::initializer_list}} 的特化，那么该 {{tt|T}} 对象会按[[#列表初始化 std::initializer_list|下文]]所述初始化。

* 否则，如果 {{tt|T}} 是类类型，则以两个阶段考虑 {{tt|T}} 的构造函数：

:* 检验所有接受 {{lc|std::initializer_list}} 作为它的唯一实参，或如果剩余实参都具有默认值则以它为首个实参的构造函数，并通过{{rlp|overload resolution|重载决议}}与单个 {{lc|std::initializer_list}} 类型的实参进行匹配。

:* 如果上一个阶段未产生匹配，那么 {{tt|T}} 的所有构造函数都参与针对由花括号包围的初始化器列表的各初始化器子句所组成的实参集的{{rlp|overload resolution#列表初始化中的隐式转换序列|重载决议}}，它会受到只允许非窄化转换的限制。如果这个阶段为复制列表初始化产生的最佳匹配是 explicit 构造函数，那么编译失败（注意：简单复制初始化中完全不考虑 explicit 构造函数）。

{{rrev|since=c++17|
* 否则，如果 {{tt|T}} 是拥有固定底层类型 {{tt|U}} 的{{rlp|enum|枚举类型}}，花括号包围的初始化器列表只有一个初始化器 {{c|v}}，并且满足以下所有条件，那么就会以将 {{c|v}} 转换到 {{tt|U}} 的结果初始化该枚举：
** 初始化是直接列表初始化。
** {{c|v}} 具有[[cpp/named req/ScalarType|标量类型]]。
** {{c|v}} 可隐式转换到 {{tt|U}}。
** 从 {{c|v}} 到 {{tt|U}} 的转换不是窄化转换。
}}

* 否则（如果 {{tt|T}} 不是类类型），如果花括号包围的初始化器列表只有一个初始化器子句，且 {{tt|T}} 要么不是引用类型，要么是引用类型而它所引用的类型与该子句的类型相同或者是它的基类，那么{{rlp|direct initialization|直接初始化}}（直接列表初始化时）或{{rlp|copy initialization|复制初始化}}（复制列表初始化时）这个 {{tt|T}}，但不允许窄化转换。

* 否则，如果 {{tt|T}} 是与初始化器子句类型不兼容的引用类型，那么：
{{rev begin}}
{{rev|until=c++17|
:* 复制列表初始化一个具有由 {{tt|T}} 引用的类型的纯右值临时量，并且将引用绑定到该临时量（如果引用是非 const 左值引用则失败）。
}}
{{rev|since=c++17|
:* 生成一个纯右值。该纯右值以复制列表初始化来初始化它的结果对象。然后用该纯右值直接初始化引用（如果引用是非 const 左值引用则会失败）。该临时量的类型是由 {{tt|T}} 引用的类型{{rev inl|since=c++20|，除非 {{tt|T}} 是“到 {{tt|U}} 的未知边界的数组的引用”，此时该临时量的类型是声明 {{c|U x[] H}} 中 {{c|x}} 的类型，其中 {{tt|H}} 是对应的初始化器列表}}。
}}
{{rev end}}

* 否则，如果花括号包围的初始化器列表没有任何初始化器子句，那么{{rlp|value initialization|值初始化}} {{tt|T}}。

{{anchor|列表初始化 std::initializer_list}}
===列表初始化 {{lc|std::initializer_list}}===
类型是 {{c/core|std::initializer_list&lt;E&gt;}} 的对象从初始化器列表构造时，编译器如同生成{{rev inl|since=c++17|并{{rlp|implicit conversion#临时量实质化|实质化}}}}一个类型是“包含 {{c|N}} 个 {{c/core|const E}} 元素的数组”的{{rlp|value category|纯右值}}，其中 {{c|N}} 是初始化器列表中的初始化器子句个数；该数组被称为该初始化器列表的''基底数组''。

基底数组中的每个元素都会以初始化器列表中的对应初始化器子句{{rlp|copy initialization|复制初始化}}，并且构造的 {{c/core|std::initializer_list&lt;E&gt;}} 的对象会指代基底数组。复制操作选择的构造函数或转换函数必须在初始化器列表的语境下{{rlp|access|可访问}}。如果初始化元素时需要进行窄化转换，那么程序非良构。

基底数组的生存期与其他{{rlp|lifetime#临时对象的生存期|临时对象}}基本一样，但区别在从基底数组初始化 {{lc|std::initializer_list}} 对象时会与{{rlp|reference initialization#临时量的生存期|绑定引用到临时量}}一样延续基底数组的生存期。
{{source|1=
void f(std::initializer_list&lt;double&gt; il);

void g(float x)
{
   f({1, x, 3});
}

void h()
{
   f({1, 2, 3});
}

struct A { mutable int i; };

void q(std::initializer_list&lt;A&gt;);

void r()
{
    q({A{1}, A{2}, A{3}&lt;!----&gt;});
}

// 以上初始化会以大致与以下相同的方式实现，前提是编译器可以以一对指针构造
// initializer_list 对象，并且 __b 的生存期不会持续到 f 的调用以外。

void g(float x)
{
    const double __a[3] = {double{1}, double{x}, double{3}&lt;!----&gt;}; // 基底数组
    f(std::initializer_list&lt;double&gt;(__a, __a + 3));
}

void h()
{
    static constexpr double __b[3] =
        {double{1}, double{2}, double{3}&lt;!----&gt;}; // 基底数组
    f(std::initializer_list&lt;double&gt;(__b, __b + 3));
}

void r()
{
    const A __c[3] = {A{1}, A{2}, A{3}&lt;!----&gt;}; // 基底数组
    q(std::initializer_list&lt;A&gt;(__c, __c + 3));
}
}}

未指定基底数组是否各异（即它们各自在{{rlp|object#子对象|不重叠的对象}}中存储）：
{{source|1=
bool fun(std::initializer_list&lt;int&gt; il1, std::initializer_list&lt;int&gt; il2)
{
    return il2.begin() == il1.begin() + 1;
}

bool overlapping = fun({1, 2, 3}, {2, 3, 4}); // 结果未指定：两个基底数组可以
                                              // 在 {1, 2, 3, 4} 上共享存储
}}

===窄化转换===
列表初始化通过禁止下列转换对{{rlp|implicit conversion|隐式转换}}加以限制：

* 从浮点类型到整数类型的转换

* 从一个浮点类型 {{tt|T}} 到另一个{{rlps|usual arithmetic conversions#浮点转换等级}}既不高于也不等于 {{tt|T}} 的等级的浮点类型的转换，除非转换结果是{{rlp|constant expression|常量表达式}}并且满足以下任一条件：
** 转换后的值是有限值，并且转换没有溢出。
** 转换前后的值都是无限值。

* 从整数类型到浮点类型的转换，除非来源是能将它的值完全存储于目标类型的常量表达式

* 从整数或无作用域枚举类型到不能表示原类型所有值的整数类型的转换，除非
** 来源是宽度（记为 {{c|w}}）小于自身类型（或者对于{{rlp|enum|枚举类型}}来说是底层类型）的位域并且目标类型可以表示宽度是 {{c|w}} 且符号与原类型一致的虚设扩展整数类型的所有值，或者
** 来源是能将它的值完全存储于目标类型的常量表达式

* 从指针或成员指针类型到 {{c/core|bool}} 的转换

===注解===
每个初始化器子句均{{rlp|eval order|按顺序早于}}花括号包围的初始化器列表中后随于它的任何初始化器子句。这与{{rev inl|until=c++17|{{rlp|eval order|无顺序的}}}}{{rev inl|since=c++17|{{rlp|eval order|顺序不确定}}}}的{{rlp|operator other#内建的函数调用运算符|函数调用表达式}}不同。

花括号包围的初始化器列表不是表达式，因此它没有类型，即 {{c/core|decltype({1, 2})}} 非良构。没有类型意味着模板类型推导无法推导出与花括号包围的初始化器列表相匹配的类型，因此给定声明 {{c|template&lt;class T&gt; void f(T);}} 则表达式 {{c|f({1, 2, 3})}} 非良构。然而，模板形参可以另行推导，如 {{c|std::vector&lt;int&gt; v(std::istream_iterator&lt;int&gt;(std::cin), {})}} 的情况，其中迭代器类型从首个实参推导，但也被用于第二形参位置。对于{{rlp|template argument deduction#其他语境|使用关键词 {{c/core|auto}} 的类型推导}}中有一个例外，在复制列表初始化中将任何花括号包围的初始化器列表均推导为 {{lc|std::initializer_list}}。

同样因为花括号包围的初始化器列表没有类型，所以在将它用作重载函数调用的实参时，适用{{rlp|overload resolution#列表初始化里的隐式转换序列|重载决议的特殊规则}}。

聚合体直接从同类型的单初始化器子句花括号包围的初始化器列表进行复制/移动初始化，但非聚合体首先考虑 {{lc|std::initializer_list}} 构造函数：
{{source|1=
struct X {}; // 聚合体

struct Q     // 非聚合体
{
    Q() = default;
    Q(Q const&amp;) = default;
    Q(std::initializer_list&lt;Q&gt;) {}
};

int main()
{
    X x;
    X x2 = X{x}; // 复制构造函数（非聚合初始化）
    
    Q q;
    Q q2 = Q{q}; // initializer_list 构造函数（非复制构造函数）
}
}}

有些编译器（例如 gcc 10）仅在 C++20 模式认为从指针或成员指针到 {{c/core|bool}} 的转换是窄化的。

{{feature test macro|std=C++11|value=200806L|__cpp_initializer_lists|列表初始化和 {{lc|std::initializer_list}}}}

===示例===
{{example
|
|code=
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

struct Foo
{
    std::vector&lt;int&gt; mem = {1, 2, 3}; // 非静态成员的列表初始化
    std::vector&lt;int&gt; mem2;
    Foo() : mem2{-1, -2, -3} {} // 构造函数中的成员列表初始化
};

std::pair&lt;std::string, std::string&gt; f(std::pair&lt;std::string, std::string&gt; p)
{
    return {p.second, p.first}; // return 语句中的列表初始化
}

int main()
{
    int n0{};  // 值初始化（为零）
    int n1{1}; // 直接列表初始化
    
    std::string s1{'a', 'b', 'c', 'd'}; // initializer_list 构造函数调用
    std::string s2{s1, 2, 2};           // 常规构造函数调用
    std::string s3{0x61, 'a'}; // initializer_list 构造函数偏好 (int, char)

    int n2 = {1}; // 复制列表初始化
    double d = double{1.2}; // 纯右值的列表初始化，然后复制初始化
    auto s4 = std::string{"HelloWorld"}; // 同上， C++17 起不创建临时对象
                     
    std::map&lt;int, std::string&gt; m = // 嵌套列表初始化
    {
        {1, "a"},
        {2, {'a', 'b', 'c'}&lt;!-- --&gt;},
        {3, s1}
    };

    std::cout &lt;&lt; f({"hello", "world"}).first // 函数调用中的列表初始化
              &lt;&lt; '\n';

    const int (&amp;ar)[2] = {1, 2}; // 绑定左值引用到临时数组
    int&amp;&amp; r1 = {1}; // 绑定右值引用到临时 int
//  int&amp; r2 = {2}; // 错误：不能绑定右值到非 const 左值引用

//  int bad{1.0}; // 错误：窄化转换
    unsigned char uc1{10}; // 可以
//  unsigned char uc2{-1}; // 错误：窄化转换

    Foo f;

    std::cout &lt;&lt; n0 &lt;&lt; ' ' &lt;&lt; n1 &lt;&lt; ' ' &lt;&lt; n2 &lt;&lt; '\n'
              &lt;&lt; s1 &lt;&lt; ' ' &lt;&lt; s2 &lt;&lt; ' ' &lt;&lt; s3 &lt;&lt; '\n';
    for (auto p : m)
        std::cout &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; '\n';
    for (auto n : f.mem)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    for (auto n : f.mem2)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    
    [](...){}(d, ar, r1, uc1); // 效果同 [[maybe_unused]]
}
|output=
world
0 1 1
abcd cd aa
1 a
2 abc
3 abcd
1 2 3 -1 -2 -3 
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1288|std=C++11|before=以单初始化器子句的花括号包围的初始化器&lt;br&gt;列表初始化引用时只能绑定引用到临时量|after=合法时会直接绑定到列表&lt;br&gt;里的那个初始化器子句}}
{{dr list item|wg=cwg|dr=1290|std=C++11|before=未正确指定基底数组的生存期|after=指定为与临时对象相同}}
{{dr list item|wg=cwg|dr=1301|std=C++11|before=对源自 {{tt|{}&lt;!----&gt;}} 的初始化首先考虑值初始化|after=首先考虑聚合初始化}}
{{dr list item|wg=cwg|dr=1418|std=C++11|before=基底数组的类型缺少 {{c/core|const}}|after=添加 {{c/core|const}}}}
{{dr list item|wg=cwg|dr=1467|std=C++11|before=禁止同类型的聚合体和字符数组初始化；&lt;br&gt;单子句列表的初始化器列表构造函数优先级高于复制构造函数|after=允许同类型初始化；&lt;br&gt;单子句列表直接初始化}}
{{dr list item|wg=cwg|dr=1494|std=C++11|before=当以类型不兼容的初始化器子句列表初始化引用时，不确定会&lt;br&gt;直接列表初始化还是复制列表初始化新建的临时量|after=取决于该引用的初始化类别}}
{{dr list item|wg=cwg|dr=2137|std=C++11|before=初始化器列表构造函数在从 {{tt|{X}&lt;!-- --&gt;}} 初始化时失去复制构造函数的优先级|after=非聚合体首先考虑初始化器列表}}
{{dr list item|wg=cwg|dr=2252|std=C++17|before=枚举可以从非标量值列表初始化|after=已禁止}}
{{dr list item|wg=cwg|dr=2267|std=C++11|before={{cwg|1494}} 的解决方案明确了临时量可以被直接列表初始化|after=在列表初始化引用时它们&lt;br&gt;会被复制列表初始化}}
{{dr list item|wg=cwg|dr=2374|std=C++17|before=枚举的直接列表初始化允许了过多的源类型|after=已限制}}
{{dr list item|wg=cwg|dr=2627|std=C++11|before=具有较大整数类型的窄位域可以提升到一个较小整数类型，但是依然是窄化转换|after=不是窄化转换}}
{{dr list item|wg=cwg|dr=2713|std=C++98|before=不能以指派初始化器列表初始化到聚合类的引用|after=可以初始化}}
{{dr list item|wg=cwg|dr=2830|std=C++11|before=列表初始化没有忽略顶层 cv 限定性|after=会忽略}}
{{dr list item|wg=cwg|dr=2864|std=C++11|before=有溢出的浮点转换不是窄化转换|after=是窄化转换}}
{{dr list item|paper=P1957R2|std=C++11|before=从指针/成员指针到 {{c/core|bool}} 的转换不是窄化转换|after=认为它是窄化转换}}
{{dr list item|paper=P2752R3|std=C++11|before=生存期重叠的多个基底数组不能重叠|after=它们可以重叠}}
{{dr list end}}

===参阅===
* {{rlp|constructor|构造函数}}
* {{rlp|converting constructor|转换构造函数}}
* {{rlp|copy assignment|复制赋值}}
* {{rlp|copy constructor|复制构造函数}}
* {{rlp|copy elision|复制消除}}
* {{rlp|default constructor|默认构造函数}}
* {{rlpt|explicit}}
* {{rlp|initialization|初始化}}
** {{rlp|aggregate initialization|聚合初始化}}
** {{rlp|constant initialization|常量初始化}}
** {{rlp|copy initialization|复制初始化}}
** {{rlp|direct initialization|直接初始化}}
** {{rlp|reference initialization|引用初始化}}
** {{rlp|value initialization|值初始化}}
** {{rlp|zero initialization|零初始化}}
* {{rlp|move assignment|移动赋值}}
* {{rlp|move constructor|移动构造函数}}
* {{rlpt|new}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}