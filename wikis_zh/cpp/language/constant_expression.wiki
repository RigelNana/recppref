{{title|常量表达式}}
{{cpp/language/expressions/navbar}}

定义能在编译时求值的{{rlp|expressions|表达式}}。

这种表达式能用作非类型模板实参、数组大小，并用于其他要求常量表达式的语境，例如
{{source|1=
int n = 1;
std::array&lt;int, n&gt; a1;  // 错误：“n” 不是常量表达式
const int cn = 2;
std::array&lt;int, cn&gt; a2; // OK：“cn” 是常量表达式
}}

===定义===
{{rev begin}}
{{rev|until=c++11|
属于下列常量表达式类别之一的表达式是''常量表达式''。
{{collapse top|C++98 常量表达式类别}}
====整数常量表达式（C++98）====
在以下位置，C++ 要求表达式求值为整数或枚举常量：
* {{rlp|array|数组边界}}（包括 {{rlp|new|{{c/core|new}} 表达式}}的非第一维度）
* {{rlp|statements#标号|{{c/core|case}} 标号}}常量
* {{rlp|bit field|位域}}宽度
* {{rlp|enum|枚举项}}初始化器
* {{rlp|static|静态数据成员}}初始化器
* 整数或枚举类型的{{rlps|template parameters#非类型模板实参}}

满足以下所有条件的表达式是''整数常量表达式''：
* 它只涉及以下实体：
:* 算术类型的字面量
:* 枚举项
:* 满足以下所有条件的变量和静态数据成员：
::* 它们具有 const 限定。
::* 它们不具有 volatile 限定。
::* 它们具有整数或枚举类型。
::* 它们以常量表达式初始化。
:* 整数或枚举类型的{{rlps|template parameters#非类型模板形参}}
:* sizeof 表达式
* 它不会使用浮点数字面量，除非这些字面量被{{rlp|explicit cast|显式转换}}到整数或枚举类型。
* 它不会应用到非整数非枚举类型的转换。
* 它不会在 {{c/core|sizeof}} 的操作数以外的地方使用以下实体：
:* 函数
:* 类对象
:* 指针
:* 引用
:* 赋值运算符
:* 自增运算符
:* 自减运算符
:* 函数调用运算符
:* 逗号运算符

====其他常量表达式类别====
其他表达式只有在进行{{rlp|constant initialization|常量初始化}}的场合才会被视为常量表达式。此类常量表达式必须是以下之一：
* 求值为{{rlp|pointer#空指针|空指针值}}的表达式
* 求值为空成员指针值的表达式
* 算术常量表达式
* 地址常量表达式
* 引用常量表达式
* 对于完整对象类型的地址常量表达式，并且加上或减去一个整数常量表达式
* 成员指针常量表达式

{{i|算术常量表达式}}是满足整数常量表达式的表达式，但有以下例外：
* 浮点数常量可以不经显式转换直接使用。
* 可以应用到浮点数类型的转换。

{{i|地址常量表达式}}是满足以下所有条件的指针类型表达式：
* 指针指向的是表示具有{{rlps|storage duration#静态存储期}}的对象，{{rlp|string literal|字符串字面量}}或{{rlp|function|函数}}的左值。该对象不能是具有非{{rlps|classes#简旧数据类}}类型的{{rlps|object#子对象}}。
* 指针只能通过以下方式之一创建：
:* 显式使用取地址运算符
:* 隐式适用具有指针类型的非类型模板形参
:* 使用数组或函数类型的表达式
* 表达式不会调用任何函数。
* 表达式可以在不访问结果对象的前提下使用（{{rlpt|dynamic_cast}} 以外的）显式指针转换和以下运算符：
:* 下标运算符
:* 间接寻址运算符
:* 取地址运算符
:* 成员访问运算符
* 在使用下标运算符的情况下，它的其中一个操作数必须是整数常量表达式。

{{i|引用常量表达式}}是满足以下所有条件的引用类型表达式：
* 指针表示的是具有静态存储期的对象，字符串字面量或函数的左值。该对象不能是具有非简旧数据类类型的子对象。
* 表达式不会调用任何函数。
* 表达式可以在不访问结果对象的前提下使用（{{rlpt|dynamic_cast}} 以外的）显式指针转换和以下运算符：
:* 下标运算符
:* 间接寻址运算符
:* 取地址运算符
:* 成员访问运算符
* 在使用下标运算符的情况下，它的其中一个操作数必须是整数常量表达式。

{{i|成员指针常量表达式}}是成员指针类型的表达式，其中该指针通过对有限定标识符应用取地址运算符获得，并可以前附显式成员指针转换。
{{collapse bottom}}
}}
{{rev|since=c++11|until=c++14|
以下表达式统称为''常量表达式''：
* 非指针[[#字面类型|字面类型]]的纯右值[[#核心常量表达式|核心常量表达式]]
* 表示具有{{rlps|storage duration#静态存储期}}的对象或函数的左值核心常量表达式
* 会求值为以下值之一的指针类型的纯右值核心常量表达式：
:* 具有静态存储期的对象的地址
:* 函数的地址
:* {{rlp|pointer#空指针|空指针值}}
* {{lc|std::nullptr_t}} 类型的纯右值核心常量表达式
}}
{{rev|since=c++14|until=c++26|
以下实体是''允许的常量表达式结果''：
* 具有{{rlps|storage duration#静态存储期}}临时对象
* 满足下列约束的具有静态存储期的非临时对象
* {{rev inl|since=c++20|非{{rlp|consteval|立即}}}}函数

{{i|常量表达式}}要么是指代某个允许的常量表达式结果的泛左值[[#核心常量表达式|核心常量表达式]]，要么是其值满足以下约束的纯右值核心常量表达式：
* 如果值是类类型对象，那么它的每个具有引用类型的非静态数据成员指代的都是允许的常量表达式结果。
* 如果值是{{rlps|type#标量类型}}对象，那么它不能具有{{rlp|default initialization#不确定值和错误值|不确定}}值。
* 如果值具有{{rlp|pointer|指针类型}}，那么该值是以下之一：
:* 具有静态存储期的对象的地址
:* 具有静态存储期的对象的尾后地址
:* {{rev inl|since=c++20|非立即}}函数的地址
:* {{rlp|pointer#空指针|空指针值}}
{{rrev|since=c++20|
* 如果值具有成员指针类型，那么它不能表示立即函数。
}}
* 如果值是类类型或数组类型对象，那么它的每个子对象的值也需要满足这些约束。
}}
{{rev|since=c++26|
{{i|常量表达式}}要么是指代某个对象或非{{rlp|consteval|立即函数}}的泛左值[[#核心常量表达式|核心常量表达式]]，要么是其值满足以下约束的纯右值核心常量表达式：
* 所有[[#成分实体|成分引用]]都指代对象或非立即函数。
* 所有{{rlps|type#标量类型}}[[#成分实体|成分值]]都不是{{rlp|default initialization#不确定值和错误值|不确定值或错误值}}。
* 所有指针类型成分值都不是指向立即函数的指针或{{rlp|pointer#无效指针|无效指针值}}。
* 所有成员指针类型成分值都不会表示立即函数。
}}
{{rev end}}

当确定表达式是否为常量表达式时始终会假设不进行{{rlp|copy elision|复制消除}}。

C++98 的常量表达式定义全部在上面的折叠盒中。以下描述适用于 C++11 以及后续 C++ 版本。

===字面类型===
{{i|字面类型}}是下列之一：
* 可有 cv 限定的 {{c/core|void}}
* {{rlps|type#标量类型}}
* {{rlp|reference|引用类型}}
* 字面类型的{{rlp|array|数组}}
* 可有 cv 限定满足以下所有条件的类类型：
:* 它拥有{{rev inl|until=c++20|{{rlps|destructor#平凡析构函数}}}}{{rev inl|since=c++20| {{rlp|constexpr#constexpr 析构函数|{{c/core|constexpr}} 析构函数}}}}，
:* 它的所有非静态非可变数据成员和基类都具有非 volatile 字面类型。
:* 它是以下类型之一：
{{rrev|since=c++17|
::* {{rlps|lambda#闭包类型}}
}}
::* 满足以下任一条件的联合体{{rlp|aggregate initialization#定义|聚合}}类型：
:::* 它没有{{rlp|union#联合体式的类|变体成员}}。
:::* 它至少有一个具有无 volatile 限定的字面类型的变体成员。
::* 每个{{rlps|union#匿名联合体}}成员都满足以下任一条件的非联合体聚合类型：
:::* 没有变体成员。
:::* 至少有一个具有无 volatile 限定的字面类型的变体成员。
::* 拥有至少一个 {{c/core|constexpr}} 构造函数（模板）且非复制或移动构造函数的类型

常量表达式中只能创建具有字面类型的对象。

===核心常量表达式===
{{i|核心常量表达式}}是求值过程中'''不会'''对下列任一语言构造求值的表达式：
{|class="wikitable"
!语言构造
!style="word-break: keep-all;"|{{nbsp|5}}版本{{nbsp|5}}
!文档
|-
|{{rlpt|this}} 指针，除了在作为该表达式的一部分而求值的 {{rlp|constexpr#constexpr 函数|{{c/core|constexpr}} 函数}}之中，或者在隐式或显式的类成员访问表达式之中出现
|
|{{stddoc|N2235}}
|-
|经过具有静态或线程{{rlp|storage duration|存储期}}且不[[#可用于常量表达式|可用于常量表达式]]的{{rlp|scope#块作用域|块变量}}的声明的控制流
|{{mark since c++23}}
|{{stddoc|P2242R3}}
|}

{{todo|将内容从下方原始 HTML 有序号列表转移到上方表格，并且加上相应文档。将所有迷你示例转移到最后，整合为大型示例。}}

&lt;ol&gt;
&lt;li&gt;调用未声明为 {{rlp|constexpr}} 的函数（或构造函数）的函数调用表达式
{{source|1=
constexpr int n = std::numeric_limits&lt;int&gt;::max(); // OK：max() 是 constexpr
constexpr int m = std::time(NULL); // 错误：std::time() 非 constexpr
}}
&lt;li&gt;调用已声明但未定义的 {{c/core|constexpr}} 函数
&lt;li&gt;调用实例化无法满足{{rlp|constexpr|{{c/core|constexpr}} 函数/构造函数}}要求的 {{c/core|constexpr}} 函数/构造函数模板
&lt;li&gt;调用 {{c/core|constexpr}} 虚函数，所用对象的动态类型是 constexpr 未知的
&lt;li&gt;会超出实现定义的极限的表达式
&lt;li&gt;导致任何形式的核心语言{{rlp|ub|未定义行为}}{{rev inl|since=c++26|或错误行为}}的操作，不包括由{{rlps|attributes#标准属性}}引入的潜在未定义行为
{{source|1=
constexpr double d1 = 2.0 / 1.0; // OK
constexpr double d2 = 2.0 / 0.0; // 错误：未定义
constexpr int n = std::numeric_limits&lt;int&gt;::max() + 1; // 错误：溢出
int x, y, z[30];
constexpr auto e1 = &amp;y - &amp;x;        // 错误：未定义
constexpr auto e2 = &amp;z[20] - &amp;z[3]; // OK
constexpr std::bitset&lt;2&gt; a; 
constexpr bool b = a[2]; // 行为未定义，但未指定是否检测
}}
&lt;li&gt;{{mark until c++17}} {{rlp|lambda|lambda 表达式}}
&lt;li&gt;左值到右值{{rlp|implicit conversion|隐式转换}}，除非应用于：
&lt;ol type="a"&gt;
&lt;li&gt;（可有 cv 限定的）{{lc|std::nullptr_t}} 类型的泛左值
&lt;li&gt;指代[[#可用于常量表达式|可用于常量表达式]]的对象的非 volatile 字面类型的泛左值
{{source|1=
int main()
{
    const std::size_t tabsize = 50;
    int tab[tabsize]; // OK：tabsize 是常量表达式
                      // 因为 tabsize 可用于常量表达式
                      // 因为它有 const 限定的整数类型，且它的初始化器是常量初始化器
    
    std::size_t n = 50;
    const std::size_t sz = n;
    int tab2[sz]; // 错误：sz 不是常量表达式
                  // 因为 sz 不可用于常量表达式
                  // 因为它的初始化器不是常量初始化器
}
}}
&lt;li&gt;指代生命期始于此表达式的求值之内的非 volatile 对象的非 volatile 字面类型的泛左值
&lt;/ol&gt;
&lt;li&gt;对{{rlp|union|联合体}}的不活跃成员或它们的子对象实施的左值到右值{{rlp|implicit conversion|隐式转换}}或修改操作（即使它与活跃成员共享公共起始序列也是如此）
&lt;li&gt;{{mark since c++20}} 应用到拥有{{rlp|default initialization|不确定值}}的对象的左值到右值隐式转换
&lt;li&gt;对活跃成员（如果存在）是 mutable 的联合体调用隐式定义的复制/移动构造函数或复制/移动赋值运算符，除非该联合体对象的生存期始于此表达式的求值之内
&lt;li&gt;{{mark until c++20}} 会更改联合体的活跃成员的赋值表达式
&lt;li&gt; 从 [[cpp/language/pointer#指向 void 的指针|{{c/core|void}} 指针]]转换到对象指针类型 {{tt|T*}}{{rev inl|since=c++26|，除非这个指针持有空指针值或者指向一个与类型 {{tt|T}} {{rlp|implicit conversion#相似类型|相似}}的对象}}
&lt;li&gt; {{rev inl|since=c++20|操作数所指代对象的动态类型为 constexpr 未知的}} {{rlpt|dynamic_cast}}
&lt;li&gt;{{rlpt|reinterpret_cast}}
&lt;li&gt;{{mark until c++20}} 伪析构函数调用
&lt;li&gt;{{mark until c++14}} 自增或自减运算符
&lt;li&gt;
{{mark since c++14}} 修改对象，除非该对象拥有非 volatile 字面类型，且它的生存期始于此表达式的求值之内
{{source|1=
constexpr int incr(int&amp; n)
{
    return ++n;
}

constexpr int g(int k)
{
    constexpr int x = incr(k); // 错误：incr(k) 不是核心常量表达式
                               // 因为 k 的生存期在表达式 incr(k) 之外开始
    return x;
}

constexpr int h(int k)
{
    int x = incr(k); // OK：不要求 x 以核心常量表达式初始化
    return x;
}

constexpr int y = h(1); // OK：以值 2 初始化 y
                        // h(1) 是核心常量表达式
                        // 因为 k 的生存期始在表达式 h(1) 之内开始
}}
&lt;li&gt;{{mark since c++20}} 对于生存期不在此表达式的求值内开始的对象的析构函数调用或伪析构函数调用
&lt;li&gt;应用到多态类型泛左值{{rev inl|since=c++20|，且该泛左值所指代对象的动态类型为 constexpr 未知}}的 {{rlpt|typeid}} 表达式
&lt;li&gt; {{rlp|new|{{c/core|new}} 表达式}}{{rev inl|since=c++20|，除非满足以下任一条件：}}
{{rev begin}}
{{rev|since=c++20|
* 选中的[[cpp/memory/new/operator new|分配函数]]是全局可替换分配函数，且它分配的存储会在此表达式的求值内解分配。
}}
{{rev|since=c++26|
* 选中的分配函数是分配类型为 {{tt|T}} 的不分配形式，并且布置实参满足以下所有条件：
:* 它指向：
::* 某个类型与 {{tt|T}} 相似的对象，如果 {{tt|T}} 不是数组类型，或者
::* 某个类型与 {{tt|T}} 相似的对象的首个元素，如果 {{tt|T}} 是数组类型。
:* 它指向存储期在此表达式的求值内开始的存储。
}}
{{rev end}}
&lt;li&gt; {{rlp|delete|{{c/core|delete}} 表达式}}{{rev inl|since=c++20|，除非它解分配的是此表达式的求值内分配的存储区域}}
&lt;li&gt;{{mark since c++20}} 协程：{{rlp|coroutines#co_await|await 表达式}}或 {{rlp|coroutines#co_yield|yield 表达式}}
&lt;li&gt;{{mark since c++20}} 结果未指定的{{rlps|operator comparison#三路比较}}运算符
&lt;li&gt;结果未指定的相等或关系运算符
&lt;li&gt;{{mark until c++14}} 赋值或复合赋值运算符
&lt;li&gt;{{mark until c++26}} throw 表达式
&lt;li&gt;{{mark since c++26}} 异常对象的构造，除非异常对象和所有由 {{lc|std::current_exception}} 或 {{lc|std::rethrow_exception}} 的调用所隐式创建的副本都在此表达式的求值内部销毁
{{source|1=
constexpr void check(int i)
{
    if (i &lt; 0)
        throw i;
}

constexpr bool is_ok(int i)
{
    try {
        check(i);
    } catch (...) {
        return false;
    }
    return true;
}

constexpr bool always_throw()
{
    throw 12;
    return true;
}

static_assert(is_ok(5)); // OK
static_assert(!is_ok(-1)); // C++26 起 OK
static_assert(always_throw()); // 错误：未捕获异常
}}
&lt;li&gt;{{rlp|asm|汇编声明}}
&lt;li&gt;宏 {{lc|va_arg}} 的调用
&lt;li&gt;{{rlpt|goto}} 语句
&lt;li&gt;会抛出异常的 {{rlpt|dynamic_cast}} 或 {{rlpt|typeid}} 表达式{{rev inl|since=c++26|或 {{rlp|new|{{c/core|new}} 表达式}}}}{{rev inl|since=c++26|，且其中异常类型的定义不可达}}
&lt;li&gt;lambda 表达式中，提及 {{c|this}} 或提及于该 lambda 之外定义的变量，如果它是一次 ODR 使用
{{source|1=
void g()
{
    const int n = 0;
    
    constexpr int j = *&amp;n; // OK：lambda 表达式之外
    
    [=]
    {
        constexpr int i = n;  // OK：'n' 未被 ODR 使用且未在此处被俘获。
        constexpr int j = *&amp;n;// 非良构：'&amp;n' ODR 使用了 'n'。
    };
}
}}
{{rrev|since=c++17|
注意，如果 ODR 使用在对闭包的函数调用中发生，那么它不涉指 {{c|this}} 或外围变量，因为它所访问的是该闭包的数据成员
{{source|1=
// OK：'v' 与 'm' 被 ODR 使用，但没有在嵌套于 lambda 内的常量表达式中出现
auto monad = [](auto v){ return [=]{ return v; }; };
auto bind = [](auto m){ return [=](auto fvm){ return fvm(m()); }; };

// 在常量表达式求值中，创建对自动对象的俘获是 OK 的。
static_assert(bind(monad(2))(monad)() == monad(2)());
}}
}}
&lt;/ol&gt;

====额外要求====
即使表达式 {{c|E}} 不会求值以上任何一项，但是如果求值它会导致{{rlp|ub|运行时未定义行为}}，那么由实现定义 {{c|E}} 是否还是核心常量表达式。

即使表达式 {{c|E}} 不会求值以上任何一项，但是如果求值它会导致求值以下任何一项，那么未指定 {{c|E}} 是否还是核心常量表达式：
* 在[[cpp/standard library|标准库]]中具有未定义行为的操作。
* 宏 {{lc|va_start}} 的调用。

为确定表达式是否为核心常量表达式，在 {{tt|T}} 是字面类型时会忽略对 {{c/core|std::allocator&lt;T&gt;}} 的成员函数体的求值。

为确定表达式是否为核心常量表达式，对{{rlp|union|联合体}}的平凡的复制/移动构造函数和复制/移动赋值运算符的调用会被视为复制/移动该联合体的活跃成员，如果存在。

{{rrev|since=c++26|
为确定表达式是否为核心常量表达式，对命名了{{rlp|structured binding|结构化绑定}} {{c|bd}} 的标识表达式的求值具有以下语义：
* 如果 {{c|bd}} 是指代绑定到虚设引用 {{c|ref}} 的对象的左值，那么行为如同指名 {{c|ref}}。
* 否则，如果 {{c|bd}} 命名了数组元素，那么行为就是求值 {{c|e[i]}} 的行为，其中 {{c|e}} 是以该结构化绑定声明的初始化器初始化的变量的名字，{{c|i}} 是 {{c|bd}} 指代的元素的索引。
* 否则，如果 {{c|bd}} 命名了类成员，那么行为就是求值 {{c|e.m}} 的行为，其中 {{c|e}} 是以该结构化绑定声明的初始化器初始化的变量的名字，{{c|m}} 是 {{c|bd}} 指代的成员的名字。
}}

在表达式作为核心常量表达式的求值过程中，所有标识表达式和 {{c|*this}} 的使用，如果它指代的是在该表达式求值之外已经开始生存期的对象或引用，那么都被当做指代这个对象或引用的特定实例，且它和它的所有子对象（包括所有联合体成员）的生存期包含整个常量求值。
* 对于不可用于常量表达式的这种对象，对象的动态类型即是 ''constexpr 未知''的。
* 对于不可用于常量表达式的这种引用，将引用当做绑定到某个未指明的被引用类型的对象，它和它的所有子对象的生存期包含整个常量求值，且它的动态类型是 constexpr 未知的。

===整数常量表达式===
{{i|整数常量表达式}}是隐式转换成纯右值的整数类型或无作用域枚举类型的表达式，其中被转换的表达式是核心常量表达式。

如果期待整数常量表达式的地方使用类类型表达式，那么该表达式将被{{rlp|implicit conversion|按语境隐式转换}}成整数类型或无作用域枚举类型。

===经转换的常量表达式===
{{tt|T}} 类型的{{i|经转换的常量表达式}}是{{rlp|implicit conversion|隐式转换}}到 {{tt|T}} 类型的表达式，其中被转换后表达式是常量表达式，且隐式转换序列只含有：
:* {{c/core|constexpr}} {{rlp|cast operator|用户定义转换}}
:* {{rlps|implicit conversion#左值到右值转换}}
:* {{rlps|implicit conversion#整数提升}}
:* {{rlps|implicit conversion#非窄化整数转换}}
:* {{rlps|implicit conversion#浮点数提升}}
:* {{rlps|implicit conversion#非窄化浮点数转换}}
{{rev begin}}
{{rev|since=c++17|
:* {{rlps|implicit conversion#数组到指针转换}}
:* {{rlps|implicit conversion#函数到指针转换}}
:* {{rlps|implicit conversion#函数指针转换}}
:* {{rlps|implicit conversion#限定性转换}}
:* 源自 {{lc|std::nullptr_t}} 的{{rlp|implicit conversion#指针转换|空指针转换}}
:* 源自 {{lc|std::nullptr_t}} 的{{rlp|implicit conversion#成员指针转换|空成员指针转换}}
}}
{{rev end}}

如果发生了任何{{rlp|reference initialization|引用绑定}}，那么它只能是{{rlps|reference initialization#直接绑定}}。

下列语境要求经转换的常量表达式：
* {{rlp|switch#标号|{{c/core|case}} 标号}}的{{spar|常量表达式}}
* 底层类型已固定时的{{rlp|enum|枚举项初始化式}}
* {{rev inl|until=c++17|整数与枚举}}非类型{{rlp|template parameters|模板实参}}
{{rev begin}}
{{rev|since=c++14|
* {{rlp|array|数组边界}}
* {{rlp|new|{{c/core|new}} 表达式}}中，第一维以外的维度
}}
{{rev|since=c++26|
* {{rlp|pack indexing|参数包索引表达式}}和{{rlp|pack indexing|参数包索引说明符}}的索引
}}
{{rev end}}

{{i|按语境转换的 {{c/core|bool}} 类型的常量表达式}}是{{rlp|implicit conversion#按语境转换|按语境转换到 {{c/core|bool}}}} 的表达式，其中经转换的表达式是常量表达式，且转换序列只含上述转换。

下列语境要求按语境转换的 {{c/core|bool}} 类型的常量表达式：
* {{rlp|noexcept spec|{{c/core|noexcept}} 说明}}
{{rev begin}}
{{rev|until=c++23|
* {{rlp|static assert|{{c/core|static_assert}} 声明}}
}}
{{rev|since=c++17|until=c++23|
* {{rlp|if#constexpr if|constexpr if 语句}}
}}
{{rev|since=c++20|
* {{rlp|explicit|条件性 {{c/core|explicit}} 说明符}}
}}
{{rev end}}


{{rev begin}}
{{rev|since=c++26|
===成分实体===
对象 {{c|obj}} 的{{i|成分值}}定义如下：
* 如果 {{c|obj}} 具有标量类型，那么成分值就是 {{c|obj}} 的值。
* 否则成分值是 {{c|obj}} 的除{{rlp|union|不活跃的联合体成员}}以外的所有直接{{rlps|object#子对象}}的成分值。

对象 {{c|obj}} 的{{i|成分引用}}包含以下引用：
* {{c|obj}} 的所有具有引用类型的直接成员
* {{c|obj}} 的除不活跃的联合体成员以外的所有直接子对象的成分引用

变量 {{c|var}} 的{{i|成分值}}和{{i|成分引用}}定义如下：
* 如果 {{c|var}} 声明的是对象，那么成分值和成分引用分别是该对象的成分值和成分引用。
* 如果 {{c|var}} 声明的是引用，那么成分引用就是该引用。

对于变量 {{c|var}} 的任何成分引用 {{c|ref}}，如果 {{c|ref}} 绑定到了一个生存期延长到与 {{c|ref}} 相同的某个临时对象或其子对象，那么该临时对象的成分值和成分引用也递归地是 {{c|var}} 的成分值和成分引用。

===可 constexpr 表示的实体===
具有静态存储期的对象在程序的任何一点都''可 constexpr 引用''。

对于具有自动存储期的对象 {{c|obj}}，如果变量 {{c|var}} 的最小外围{{rlp|scope|作用域}}和点 {{ttb|P}} 的最小外围作用域是同一个不与 {{rlp|requires|{{c/core|requires}} 表达式}}关联的函数形参作用域，那么 {{c|obj}} 在 {{ttb|P}} ''可 constexpr 引用''，其中 {{c|var}} 是与 {{c|obj}} 的完整对象对应的变量或 {{c|obj}} 的生存期{{rlp|reference initialization#临时量的生存期|延长}}到的变量。

如果满足以下所有条件，那么对象或引用 {{c|x}} 在点 {{ttb|P}} ''可 constexpr 表示''：
* 对于 {{c|x}} 的每个指向对象的成分值，该对象都在 {{ttb|P}} 可 constexpr 引用。
* 对于 {{c|x}} 的每个指向对象尾后的成分值，该对象都在 {{ttb|P}} 可 constexpr 引用。
* 对于 {{c|x}} 的每个指代对象的成分引用，该对象都在 {{ttb|P}} 可 constexpr 引用。
}}
{{rev|since=c++20|
===以常量初始化的实体===
{{rev begin}}
{{rev|until=c++26|
如果满足以下所有条件，那么变量或临时对象 {{c|obj}} ''以常量初始化''：
* 要么它有初始化器，要么它的类型{{rlp|default initialization#const 对象的默认初始化|可 const 默认构造}}。
* 它的初始化的{{rlps|expressions#完整表达式}}在要求常量表达式的语境下是常量表达式，但它也可以为该对象和它的子对象调用 {{rlp|constexpr#constexpr 构造函数|{{c/core|constexpr}} 构造函数}}（即使这些对象具有非字面类类型）。
}}
{{rev|since=c++26|
如果满足以下所有条件，那么变量 {{c|obj}} ''可以常量初始化''：
* 它的初始化的{{rlps|expressions#完整表达式}}在要求常量表达式的语境下是常量表达式，其中所有{{rlp|contracts|契约断言}}都使用“忽略”求值语义。
* 在 {{c|var}} 的初始化声明后，{{c|var}} 声明的对象或引用立即变得可 constexpr 表示。
* 如果 {{c|var}} 声明的对象或引用 {{c|x}} 具有静态或线程存储期，那么 {{c|x}} 在立即作用域是紧随 {{c|var}} 的初始化声明的命名空间作用域的最近点变得可 constexpr 表示。

可以常量初始化的变量在它有初始化器或它的类型{{rlp|default initialization#const 对象的默认初始化|可 const 默认构造}}时''以常量初始化''。
}}
{{rev end}}

===可用于常量表达式===
{{rlp|constexpr#constexpr 变量|{{c/core|constexpr}} 变量}}和具有引用类型或有 const 限定且无 volatile 限定的整数或枚举类型的变量是''潜在常量的''。

对于以常量初始化的潜在常量的变量 {{c|var}} 和点 {{ttb|P}}，如果 {{c|var}} 的初始化声明 {{ttb|D}} 从 {{ttb|P}} 可及，并且满足以下任意条件，那么 {{c|var}} 在 {{ttb|P}} ''可用于常量表达式''：
* {{c|var}} 是 {{c/core|constexpr}} 变量。
* {{c|var}} 没有以{{rlp|tu local|翻译单元局部}}值初始化。
* {{ttb|P}} 和 {{ttb|D}} 在相同的翻译单元中。

{{rev begin}}
{{rev|until=c++26|
以下对象或引用在点 {{ttb|P}} ''可用于常量表达式''：
* 在 {{ttb|P}} 可用于常量表达式的变量
* 具有有 const 限定且无 volatile 限定的整数或枚举类型且生存期被延长到某个在 {{ttb|P}} 可用于常量表达式的变量的生存期的临时对象
* {{rlps|template parameters#模板形参对象}}
* {{rlp|string literal|字符串字面量}}对象
* 以上实体的非可变子对象
* 以上实体的引用成员
}}
{{rev|since=c++26|
以下对象或引用在点 {{ttb|P}} ''可潜在用于常量表达式''：
* 在 {{ttb|P}} 可用于常量表达式的变量
* 具有有 const 限定且无 volatile 限定的整数或枚举类型且生存期被延长到某个在 {{ttb|P}} 可用于常量表达式的变量的生存期的临时对象
* {{rlps|template parameters#模板形参对象}}
* {{rlp|string literal|字符串字面量}}对象
* 以上实体的非可变子对象
* 以上实体的引用成员

在点 {{ttb|P}} 可潜在用于常量表达式且可 constexpr 表示的对象或引用在 {{ttb|P}} 可用于常量表达式。
}}
{{rev end}}

===明显常量求值的表达式===
下列表达式（包括到目标类型的转换）是{{i|明显常量求值}}的：

* {{rlp|array|数组边界}}
* {{rlp|new|{{c/core|new}} 表达式}}中第一维以外的维度
* {{rlp|bit field|位域}}长度
* {{rlp|enum|枚举项}}的初始化器
* {{rlp|alignas|对齐}}
* {{rlp|switch#标号|{{c/core|case}} 标号}}的{{spar|常量表达式}}
* 非类型{{rlp|template parameters|模板实参}}
* {{rlp|noexcept spec|{{c/core|noexcept}} 说明}}中的表达式
* {{rlp|static assert|{{c/core|static_assert}} 声明}}中的表达式
* {{rlp|constexpr|{{c/core|constexpr}} 变量}}的初始化器
* {{rlp|if#constexpr if|constexpr if 语句}}中的条件
* {{rlp|explicit|条件性 {{c/core|explicit}} 说明符}}中的表达式
* {{rlp|consteval|立即调用}}
* {{rlp|constraints#概念|概念}}定义、{{rlps|constraints#嵌套要求}}及 {{rlp|constraints#requires 子句|{{c/core|requires}} 子句}}中的约束表达式，当确定约束是否满足时&lt;!-- 它们在定义时不求值 --&gt;
* 引用类型和 const 限定的整数或枚举类型的变量的初始化器，仅当初始化器是常量表达式时
* 静态及线程局域变量的初始化器，仅当初始化器的所有子表达式（含构造函数调用和隐式转换）都是常量表达式时（即该初始化器是{{rlp|constant initialization|常量初始化器}}）
&lt;!--注意最后两种情况的语境也接受非常量表达式。--&gt;

能用 {{lc|std::is_constant_evaluated}}{{rev inl|since=c++23| 和 {{rlpt|if#consteval if|if consteval}}}} 检测求值是否在明显常量求值语境中出现。
}}
{{rev end}}

===常量求值所需要的函数与变量===
下列表达式或转换会''潜在常量求值''：
* 明显常量求值的表达式
* 潜在求值的表达式
* {{rlp|initialization|花括号包围的初始化器列表}}的直接子表达式（可能需要常量求值以确定转换是否为{{rlp|list initialization#窄化转换|窄化}}）
* 在{{rlp|templates#模板化实体|模板化实体}}内出现的取址表达式（可能需要常量求值以确定这种表达式是否为{{rlp|dependent name#值待决表达式|值待决}}）
* 上述之一的子表达式，除了嵌套的{{rlp|expressions#不求值表达式|不求值操作数}}的子表达式

如果函数是 {{c/core|constexpr}} 函数且被潜在常量求值的表达式所{{rlp|definition#指名函数|指名}}，那么它''被常量求值所需要''。

如果变量是 {{c/core|constexpr}} 变量或非 volatile 的 const 限定的整数类型或引用类型的变量，且指代它的{{rlp|expressions#初等表达式|标识表达式}}被潜在常量求值，那么它''被常量求值所需要''。

如果预置函数或{{rlp|function template|函数模板}}特化{{rev inl|since=c++14|或{{rlp|variable template|变量模板}}特化}}被常量求值所需要，则出会触发该函数{{rev inl|since=c++14|或变量}}的（预置函数）定义或（模板特化）实例化。

===常量子表达式===&lt;!-- LWG 2234/2296，不是从 C++17 起 --&gt;
{{i|常量子表达式}}是在作为表达式 {{c|e}} 的{{rlp|expressions#完整表达式|子表达式}}求值时不会阻止 {{c|e}} 成为[[#核心常量表达式|核心常量表达式]]的表达式，其中 {{c|e}} 不是以下任何表达式：
* {{rlp|throw|{{c/core|throw}} 表达式}}
{{rrev|since=c++20|
* {{rlp|coroutines|yield 表达式}}
}}
* {{rlp|operator assignment|赋值表达式}}
* {{rlp|operator other#内建的逗号运算符|逗号表达式}}

===注解===
{{ftm begin|core=yes|sort=yes}}
{{ftm|value=201711L|std=C++20|dr=11|__cpp_constexpr_in_decltype|当[[#常量求值所需要的函数与变量|被常量求值所需要]]时，生成函数或变量的定义}}
{{ftm|value=201907L|std=C++20|__cpp_constexpr_dynamic_alloc|{{c/core|constexpr}} 函数中的动态存储期操作}}
{{ftm|rowspan=2|value=202306L|std=C++26|__cpp_constexpr|从 {{c/core|void*}} 进行 {{c/core|constexpr}} 转型：走向 {{c/core|constexpr}} 类型擦除}}
{{ftm|value=202406L|std=C++26|-|{{c/core|constexpr}} 的布置 {{c/core|new}} 和 {{c/core|new[]}}}}
{{ftm|value=202411L|std=C++26|__cpp_constexpr_exceptions|{{c/core|constexpr}} 异常}}
{{ftm end}}

===示例===
{{example}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=94|std=C++98|before=算术常量表达式不能涉及变量和静态数据成员|after=可以涉及}}
{{dr list item|wg=cwg|dr=366|std=C++98|before=涉及字符串字面量的表达式可以是整数常量表达式|after=不可以是}}
{{dr list item|wg=cwg|dr=457|std=C++98|before=涉及 volatile 变量的表达式可以是整数常量表达式|after=不可以是}}
{{dr list item|wg=cwg|dr=1293|std=C++11|before=不明确字符串字面量是否可用于常量表达式|after=可用于常量表达式}}
{{dr list item|wg=cwg|dr=1311|std=C++11|before=可以在常量表达式中使用 volatile 泛左值|after=禁止使用}}
{{dr list item|wg=cwg|dr=1312|std=C++11|before=已禁止在常量表达式中使用 {{c/core|reinterpret_cast}}，&lt;br&gt;但是转换到 {{c/core|void*}} 再转换到其他类型可以达到一样的效果|after=禁止从 ''cv'' {{c/core|void*}} 类型&lt;br&gt;转换到对象指针类型}}
{{dr list item|wg=cwg|dr=1313|std=C++11|before=容许未定义行为；且禁止所有指针减法|after=禁止未定义行为；允许同数组内的指针减法}}
{{dr list item|wg=cwg|dr=1405|std=C++11|before=可用于常量表达式的对象的可变子对象也可用于常量表达式|after=不可用于常量表达式}}
{{dr list item|wg=cwg|dr=1454|std=C++11|before=不能通过 {{c/core|constexpr}} 函数以引用传递常量|after=已允许}}
{{dr list item|wg=cwg|dr=1455|std=C++11|before=经转换的常量表达式只能是纯右值|after=可以是左值}}
{{dr list item|wg=cwg|dr=1456|std=C++11|before=地址常量表达式不能表示数组末尾后一位置|after=可以表示}}
{{dr list item|wg=cwg|dr=1535|std=C++11|before=操作数是/具有多态类类型的 {{c/core|typeid}} 表达式即使&lt;br&gt;不会涉及运行时检查也不是核心常量表达式|after=操作数限制仅限于&lt;br&gt;多态类类型的泛左值}}
{{dr list item|wg=cwg|dr=1581|std=C++11|before=未要求定义或实例化常量求值所需要的函数|after=已要求}}&lt;!-- P0859R0 --&gt;
{{dr list item|wg=cwg|dr=1613|std=C++11|before=核心常量表达式可以在 lambda 表达式中求值任意 ODR 使用的引用|after=不能求值某些引用}}
{{dr list item|wg=cwg|dr=1694|std=C++11|before=绑定临时量的值到静态存储期引用是常量表达式|after=它不是常量表达式}}
{{dr list item|wg=cwg|dr=1872|std=C++11|before=核心常量表达式可以调用不满足 {{c/core|constexpr}} 函数&lt;br&gt;要求的 {{c/core|constexpr}} 函数模板实例化|after=不可调用此类实例化}}
{{dr list item|wg=cwg|dr=1952|std=C++11|before=要求诊断标准库未定义行为|after=未指定是否诊断库未定义行为}}
{{dr list item|wg=cwg|dr=2022|std=C++98|before=确定常量表达式的结果可能会取决于是否进行复制消除|after=假设始终会进行复制消除}}
{{dr list item|wg=cwg|dr=2126|std=C++11|before=具有有 const 限定的字面类型且生存期因&lt;br&gt;常量初始化延续的临时量不能用于常量表达式|after=可以用于常量表达式}}
{{dr list item|wg=cwg|dr=2129|std=C++11|before=整数字面量不是常量表达式|after=是常量表达式}}
{{dr list item|wg=cwg|dr=2167|std=C++11|before=求值中局部的非成员引用会令求值为非 constexpr|after=允许非成员引用}}
{{dr list item|wg=cwg|dr=2278|std=C++98|before={{cwg|2022}} 的解决方案无法实现|after=假设始终不会进行复制消除}}
{{dr list item|wg=cwg|dr=2299|std=C++14|before=不明确 {{header|cstdarg}} 中的宏能否用于常量求值|after=禁止 {{tt|va_arg}}，未指定 {{tt|va_start}}}}
{{dr list item|wg=cwg|dr=2400|std=C++11|before=包含对 {{c/core|constexpr}} 虚函数的函数调用的表达式在调用所用的对象不可&lt;br&gt;用于常量表达式且它的生命期在此表达式之外开始时也可以是常量表达式|after=它不是常量表达式}}
{{dr list item|wg=cwg|dr=2490|std=C++20|before=常量求值中的（伪）析构函数调用缺少限制|after=添加了限制}}
{{dr list item|wg=cwg|dr=2552|std=C++23|before=在求值核心常量表达式时，控制流不可以经过非块变量的声明|after=可以经过}}
{{dr list item|wg=cwg|dr=2558|std=C++11|before=不确定值可以是常量表达式|after=不是常量表达式}}
{{dr list item|wg=cwg|dr=2647|std=C++20|before=volatile 限定类型的变量是潜在常量的|after=不是潜在常量的}}
{{dr list item|wg=cwg|dr=2763|std=C++11|before=在常量求值中不需要检测是否违背了 {{attr|noreturn}}|after=需要检测}}
{{dr list item|wg=cwg|dr=2851|std=C++11|before=经转换的常量表达式不允许浮点数转换|after=允许非窄化浮点数转换}}
{{dr list item|wg=cwg|dr=2907|std=C++11|before=核心常量表达式不可以对 {{lc|std::nullptr_t}} 泛左值引用左值到右值转换|after=可以应用此类转换}}
{{dr list item|wg=cwg|dr=2909|std=C++20|before=不带初始化器的变量只有在它的默认初始化&lt;br&gt;实际进行了某些初始化时才能以常量初始化|after=只有在它的类型可 const&lt;br&gt;默认构造时才能以常量初始化}}
{{dr list item|wg=cwg|dr=2924|std=C++11&lt;br&gt;C++23|before=未指定违背 {{attr|noreturn}}（C++11）或&lt;br&gt;{{attr|assume}}（C++23）的约束的表达式是否还是核心常量表达式|after=由实现定义}}
{{dr list item|paper=P2280R4|std=C++11|before=包含标识表达式或 {{c|*this}} 且所指代的对象或引用的&lt;br&gt;生存期在此次求值之外开始的表达式不是常量表达式|after=可以是常量表达式}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/language/dsc constexpr}}
{{dsc inc|cpp/types/dsc is_literal_type}}
{{dsc see c|c/language/constant expression|常量表达式|nomono=true}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}