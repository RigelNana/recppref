{{title|基于范围的 {{tt|for}} 循环 {{mark since c++11}}}}
{{cpp/language/statements/navbar}}
在一个范围上执行 {{c/core|for}} 循环。

用作对范围中的各个值（如容器中的所有元素）进行操作的传统 {{rlp|for|{{c/core|for}} 循环}}的更加可读的等价版本。

===语法===
{{sdsc begin}}
{{sdsc|{{spar optional|属性}} {{ttb|for (}} {{spar optional|初始化语句}} {{spar|项声明}} {{ttb|:}} {{spar|范围初始化器}} {{ttb|)}} {{spar|语句}}}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|属性}}|任意数量的{{rlp|attributes|属性}}}}
{{par|{{spar|初始化语句}}|{{mark since c++20}} 以下之一：
* {{rlp|statements|表达式语句}}（可以是空语句 {{c|;}}）
* {{rlp|declarations|简单声明}}（典型情况下是带初始化器的变量声明），可以声明任意多个变量，或者是{{rlp|structured binding|结构化绑定声明}}
{{rrev|since=c++23|
* {{rlp|type alias|别名声明}}
}}
注意，所有{{spar sep|初始化语句}}必然以分号结尾。因此它经常被非正式地描述为后随分号的表达式或声明。}}
{{par|{{spar|项声明}}|范围中每一项的声明}}
{{par|{{spar|范围初始化器}}|{{rlp|expressions|表达式}}或{{rlp|initialization|花括号包围的初始化器列表}}}}
{{par|{{spar|语句}}|任意{{rlp|statements|语句}}（典型情况下是复合语句）}}
{{par end}}

===解释===
上述语法产生的代码等价于下列代码{{rev inl|since=c++23|，但{{spar sep|范围初始化器}}中的临时量会进行生存期扩展（见[[#临时范围初始化器|下文]]）}}（以 {{c/core|/* */}} 包围的变量和表达式仅用于阐述）。

{{rev begin}}
{{rev|until=c++17|
{{ttb|{}}&lt;br&gt;
:{{ttb|auto&amp;&amp;}} {{c/core|/* range */}} {{ttb|1==}} {{spar sep|范围初始化器}}{{ttb|;}}&lt;br&gt;
:{{ttb|for (auto}} {{c/core|/* begin */}} {{ttb|1==}} {{c/core|/* 首表达式 */}}{{ttb|,}} {{c/core|/* end */}} {{ttb|1==}} {{c/core|/* 尾表达式 */}}{{ttb|;}}&lt;br&gt;
:::{{c/core|/* begin */}} {{ttb|1=!=}} {{c/core|/* end */}}{{ttb|; ++}}{{c/core|/* begin */}}{{ttb|)}}&lt;br&gt;
:{{ttb|{}}
::{{spar|项声明}} {{ttb|1== *}}{{c/core|/* begin */}}{{ttb|;}}&lt;br&gt;
::{{spar|语句}}&lt;br&gt;
:{{ttb|}&lt;!----&gt;}}&lt;br&gt;
{{ttb|}&lt;!----&gt;}}&lt;br&gt;
}}
{{rev|since=c++17|until=c++20|
{{ttb|{}}&lt;br&gt;
:{{ttb|auto&amp;&amp;}} {{c/core|/* range */}} {{ttb|1==}} {{spar sep|范围初始化器}}{{ttb|;}}&lt;br&gt;
:{{ttb|auto}} {{c/core|/* begin */}} {{ttb|1==}} {{c/core|/* 首表达式 */}}{{ttb|;}}&lt;br&gt;
:{{ttb|auto}} {{c/core|/* end */}} {{ttb|1==}} {{c/core|/* 尾表达式 */}}{{ttb|;}}&lt;br&gt;
:{{ttb|for ( ;}} {{c/core|/* begin */}} {{ttb|1=!=}} {{c/core|/* end */}}{{ttb|; ++}}{{c/core|/* begin */}}{{ttb|)}}&lt;br&gt;
:{{ttb|{}}
::{{spar|项声明}} {{ttb|1== *}}{{c/core|/* begin */}}{{ttb|;}}&lt;br&gt;
::{{spar|语句}}&lt;br&gt;
:{{ttb|}&lt;!----&gt;}}&lt;br&gt;
{{ttb|}&lt;!----&gt;}}&lt;br&gt;
}}
{{rev|since=c++20|
{{ttb|{}}&lt;br&gt;
:{{spar|初始化语句}}&lt;br&gt;
:{{ttb|auto&amp;&amp;}} {{c/core|/* range */}} {{ttb|1==}} {{spar sep|范围初始化器}}{{ttb|;}}&lt;br&gt;
:{{ttb|auto}} {{c/core|/* begin */}} {{ttb|1==}} {{c/core|/* 首表达式 */}}{{ttb|;}}&lt;br&gt;
:{{ttb|auto}} {{c/core|/* end */}} {{ttb|1==}} {{c/core|/* 尾表达式 */}}{{ttb|;}}&lt;br&gt;
:{{ttb|for ( ;}} {{c/core|/* begin */}} {{ttb|1=!=}} {{c/core|/* end */}}{{ttb|; ++}}{{c/core|/* begin */}}{{ttb|)}}&lt;br&gt;
:{{ttb|{}}
::{{spar|项声明}} {{ttb|1== *}}{{c/core|/* begin */}}{{ttb|;}}&lt;br&gt;
::{{spar|语句}}&lt;br&gt;
:{{ttb|}&lt;!----&gt;}}&lt;br&gt;
{{ttb|}&lt;!----&gt;}}&lt;br&gt;
}}
{{rev end}}

要迭代的序列或范围通过对{{spar sep|范围初始化器}}求值以确定。依次对序列的每个元素进行解引用，并赋值给具有{{spar sep|项声明}}中所给定的类型和名字的变量。

{{spar sep|项声明}}可以是以下之一：
* 具有以下限制的{{rlps|declarations#简单声明}}：
:* 它只有一个{{rlps|declarations#声明符}}。
* 该声明符不能有{{rlp|initialization|初始化器}}。
* {{rlp|declarations#说明符|声明说明符序列}}只能包含类型说明符和 {{c/core|constexpr}}，并且不能定义{{rlp|class|类}}或{{rlp|enum|枚举}}。
{{rrev|since=c++17|
* 结构化绑定声明
}}

仅用于阐述的表达式 {{c/core|/* 首表达式 */}} 和 {{c/core|/* 尾表达式 */}} 定义如下：
* 如果 {{c/core|/* range */}} 的类型是到数组类型 {{tt|R}} 的引用，那么：
:* 如果 {{tt|R}} 有 {{c|N}} 个元素，那么 {{c/core|/* 首表达式 */}} 是 {{c|/* range */}}，{{c/core|/* 尾表达式 */}} 是 {{c|/* range */ + N}}。
:* 如果 {{tt|R}} 是边界未知或元素类型不完整的数组，那么程序非良构。
* 如果 {{c/core|/* range */}} 的类型是到类类型 {{tt|C}} 的引用，并且在 {{tt|C}} 的作用域中对名字 “{{tt|begin}}” 和 “{{tt|end}}” 的查找都能各自找到至少一条声明，那么 {{c/core|/* 首表达式 */}} 是 {{c|/* range */.begin()}}，{{c/core|/* 尾表达式 */}} 是 {{c|/* range */.end()}}。
* 否则 {{c/core|/* 首表达式 */}} 是 {{c|begin(/* range */)}}，{{c/core|/* 尾表达式 */}} 是 {{c|end(/* range */)}}，其中 “{{tt|begin}}” 和 “{{tt|end}}” 会通过{{rlp|adl|实参依赖查找}}进行查找（不进行非实参依赖查找）。

如果需要在{{spar sep|语句}}中结束循环，那么可以使用 {{rlp|break|{{c/core|break}} 语句}}作为终止语句。

如果需要在{{spar sep|语句}}中结束当前迭代，那么可以使用 {{rlp|continue|{{c/core|continue}} 语句}}作为快捷方式。

如果从{{spar sep|初始化语句}}中引入的名字在{{spar sep|语句}}的最外层块被重声明，那么程序非良构：
{{source|1=
for (int i : {1, 2, 3})
    int i = 1; // 错误：重声明
}}

===临时范围初始化器===
如果{{spar sep|范围初始化器}}返回了临时量，那么它的生存期会延续到循环结尾，如绑定到转发引用 {{c/core|/* range */}} 所示，但要注意{{spar sep|范围初始化器}}中任何临时量生存期都不会延长{{rev inl|since=c++23|，除非它们本会在{{spar sep|范围初始化器}}末尾被销毁}}。
{{source|1=
// 如果 foo() 按值返回
for (auto&amp; x : foo().items()) { /* .. */ } // C++23 前为行为未定义
}}
{{rrev|since=c++20|此问题可用{{spar sep|初始化语句}}变通解决：
{{source|1=
for (T thing = foo(); auto&amp; x : thing.items()) { /* ... */ } // OK
}}
}}


{{rrev|since=c++23|注意，即便在 C++23 中，中间函数的非引用形参也不会延长生存期（因为某些 ABI 中它们在被调用方而非调用方中销毁），但这点仅对于本就有缺陷的函数才会造成问题：
{{source|1=
using T = std::list&lt;int&gt;;
const T&amp; f1(const T&amp; t) { return t; }
const T&amp; f2(T t)        { return t; } // 总是返回悬垂引用
T g();

void foo()
{
    for (auto e : f1(g())) {} // OK: g() 的返回值的生存期被延长
    for (auto e : f2(g())) {} // UB: f2 的值形参的生存期过早结束
}
}}
}}

===注解===
如果{{spar sep|范围初始化器}}是{{rlp|initialization|花括号包围的初始化器列表}}，那么 {{c/core|/* range */}} 会被推导为到 {{lc|std::initializer_list}} 的引用。

在泛型代码中，使用推导的转发引用，如 {{c|for (auto&amp;&amp; var : sequence)}}，是安全且受推荐的做法。

如果范围类型拥有名为 “{{tt|begin}}” 的成员和名为 “{{tt|end}}” 的成员，那么使用成员解释方案。其中无视成员是类型、数据成员、函数还是枚举项及其可访问性。从而像 {{c|1=class meow { enum { begin = 1, end = 2 }; /* 类的剩余部分 */ };}} 的类不能用于基于范围的 {{c/core|for}} 循环，即使有命名空间作用域的 “{{tt|begin}}”/“{{tt|end}}” 函数存在。

虽然通常在{{spar sep|语句}}中使用在{{spar sep|项声明}}中声明的变量，但并不要求这么做。

{{rrev|since=c++17|
从 C++17 开始，{{c/core|/* 首表达式 */}} 和 {{c/core|/* 尾表达式 */}} 的类型不必相同，而且实际上{{spar sep|尾表达式}}的类型不需要是迭代器：它只需要能与一个迭代器比较是否不等。这允许以一个谓词（例如“迭代器指向空字符”）对范围进行分界。
}}

当基于范围的 {{c/core|for}} 循环被用于一个具有写时复制语义的（非 const）对象时，它可能会通过（隐式）调用非 const 的 {{tt|begin()}} 成员函数触发深层复制。

{{rrev|since=c++17|
如果想要避免这种行为（比如循环实际上不会修改这个对象），那么可以使用 {{lc|std::as_const}}：

{{source|1=
struct cow_string { /* ... */ }; // 写时复制的字符串
cow_string str = /* ... */;

// for(auto x : str) { /* ... */ } // 可能会导致深层复制

for(auto x : std::as_const(str)) { /* ... */ } 
}}
}}

{{ftm begin|core=1|std=1|comment=1}}
{{ftm|value=200907L|std=C++11|__cpp_range_based_for|rowspan="3"|[[#top|基于范围的 {{c/core|for}} 循环]]}}
{{ftm|value=201603L|std=C++17|-|具有[[#解释|不同的 {{tt|begin}}/{{tt|end}}]] 类型的基于范围的 {{tt|for}} 循环}}	
{{ftm|value=202211L|std=C++23|-|对{{spar sep|范围初始化器}}中所有临时对象的生存期扩展}}
{{ftm end}}

===关键词===
{{ltt|cpp/keyword/for}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5};//创建一个vector

    for (const int&amp; i : v) // 以 const 引用访问
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    for (auto i : v) // 以值访问，i 的类型是 int
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    for (auto&amp;&amp; i : v) // 以转发引用访问，i 的类型是 int&amp;
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    const auto&amp; cv = v;
 
    for (auto&amp;&amp; i : cv) // 以转发引用访问，i 的类型是 const int&amp;
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    for (int n : {0, 1, 2, 3, 4, 5}) // 初始化器可以是花括号包围的初始化器列表
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    int a[] = {0, 1, 2, 3, 4, 5};
    for (int n : a) // 初始化器可以是数组
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    for ([[maybe_unused]] int n : a)  
        std::cout &lt;&lt; 1 &lt;&lt; ' '; // 不必使用循环变量
    std::cout &lt;&lt; '\n';
 
    for (auto n = v.size(); auto i : v) // 初始化语句（C++20）
        std::cout &lt;&lt; --n + i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    for (typedef decltype(v)::value_type elem_t; elem_t i : v)
    // typedef 声明作为初始化语句（C++20）
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    for (using elem_t = decltype(v)::value_type; elem_t i : v)
    // 别名声明作为初始化语句，同上（C++23）
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
0 1 2 3 4 5 
0 1 2 3 4 5 
0 1 2 3 4 5 
0 1 2 3 4 5 
0 1 2 3 4 5 
0 1 2 3 4 5 
1 1 1 1 1 1 
5 5 5 5 5 5 
0 1 2 3 4 5 
0 1 2 3 4 5 
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1442|std=C++11|before=未指明查找非成员 “{{tt|begin}}” 和 “{{tt|end}}” 时是否包含通常的无限定查找|after=不包含}}
{{dr list item|wg=cwg|dr=2220|std=C++11|before=可以重声明从{{spar sep|初始化语句}}中引入的名字|after=此时程序非良构}}
{{dr list item|wg=cwg|dr=2825|std=C++11|before=如果{{spar sep|范围初始化器}}是花括号包围的初始化器列表，那么会查找非成员 “{{tt|begin}}” 和 “{{tt|end}}”|after=此时会查找成员 “{{tt|begin}}” 和 “{{tt|end}}”}}
{{dr list item|paper=P0962R1|std=C++11|before=只要 “{{tt|begin}}” 和 “{{tt|end}}” 之一存在就使用成员解释方案|after=只有在两者都存在时才使用}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc for_each}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}