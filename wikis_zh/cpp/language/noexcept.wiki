{{title|{{tt|noexcept}} 运算符 {{mark since c++11}}}}
{{cpp/language/exceptions/navbar}}

{{c/core|noexcept}} 运算符进行编译时检查，在表达式声明不会抛出任何异常的情况下返回 {{c|true}}。

它可用于函数模板的 {{rlp|noexcept spec|{{c/core|noexcept}} 说明符}}中，以声明函数将对某些类型抛出异常，但不对其他类型抛出。

===语法===
{{sdsc begin}}
{{sdsc|{{ttb|noexcept(}} {{spar|表达式}} {{ttb|)}}}}
{{sdsc end}}

返回 {{c/core|bool}} 类型的{{rlp|value category|纯右值}}。如果 {{rev inl|until=c++17|{{spar sep|表达式}}的{{rlp|except spec|潜在异常}}集合为空}}{{rev inl|since=c++17|{{spar sep|表达式}}指定为{{rlp|noexcept spec|不会抛出}}}}，那么结果是 {{c|true}}，否则结果是 {{c|false}}。

{{spar sep|表达式}}是{{rlp|expressions#潜在求值表达式|不求值操作数}}。

{{rrev|since=c++17|
如果{{spar sep|表达式}}是纯右值，那么就会进行{{rlps|implicit conversion#临时量实质化}}。
}}

===注解===
即使 {{c|noexcept(expr)}} 是 {{c|true}}，对 {{c|expr}} 进行求值仍然有可能由于碰到了未定义行为而抛出异常。

{{rrev|since=c++17|
如果{{spar sep|表达式}}具有类类型或它的（可能多维的）数组类型，那么临时量实质化要求析构函数未被弃置且可访问。
}}

===关键词===
{{ltt|cpp/keyword/noexcept}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

void may_throw();
void no_throw() noexcept;
auto lmay_throw = []{};
auto lno_throw = []() noexcept {};

class T
{
public:
    ~T(){} // 析构函数妨碍了移动构造函数
           // 复制构造函数不会抛出异常
};

class U
{
public:
    ~U(){} // 析构函数妨碍了移动构造函数
           // 复制构造函数可能会抛出异常
    std::vector&lt;int&gt; v;
};

class V
{
public:
    std::vector&lt;int&gt; v;
};
 
int main()
{
    T t;
    U u;
    V v;
    
    std::cout &lt;&lt; std::boolalpha
        &lt;&lt; "may_throw() 可能会抛出异常吗？" &lt;&lt; !noexcept(may_throw()) &lt;&lt; '\n'
        &lt;&lt; "no_throw() 可能会抛出异常吗？" &lt;&lt; !noexcept(no_throw()) &lt;&lt; '\n'
        &lt;&lt; "lmay_throw() 可能会抛出异常吗？" &lt;&lt; !noexcept(lmay_throw()) &lt;&lt; '\n'
        &lt;&lt; "lno_throw() 可能会抛出异常吗？" &lt;&lt; !noexcept(lno_throw()) &lt;&lt; '\n'
        &lt;&lt; "~T() 可能会抛出异常吗？" &lt;&lt; !noexcept(std::declval&lt;T&gt;().~T()) &lt;&lt; '\n'
        // 注：以下各项测试也要求 ~T() 不会抛出异常
        // 因为 noexcept 中的表达式会构造并销毁临时量
        &lt;&lt; "T(T 右值) 可能会抛出异常吗？" &lt;&lt; !noexcept(T(std::declval&lt;T&gt;())) &lt;&lt; '\n'
        &lt;&lt; "T(T 左值) 可能会抛出异常吗？" &lt;&lt; !noexcept(T(t)) &lt;&lt; '\n'
        &lt;&lt; "U(U 右值) 可能会抛出异常吗？" &lt;&lt; !noexcept(U(std::declval&lt;U&gt;())) &lt;&lt; '\n'
        &lt;&lt; "U(U 左值) 可能会抛出异常吗？" &lt;&lt; !noexcept(U(u)) &lt;&lt; '\n'  
        &lt;&lt; "V(V 右值) 可能会抛出异常吗？" &lt;&lt; !noexcept(V(std::declval&lt;V&gt;())) &lt;&lt; '\n'
        &lt;&lt; "V(V 左值) 可能会抛出异常吗？" &lt;&lt; !noexcept(V(v)) &lt;&lt; '\n';  
}
|output=
may_throw() 可能会抛出异常吗？true
no_throw() 可能会抛出异常吗？false
lmay_throw() 可能会抛出异常吗？true
lno_throw() 可能会抛出异常吗？false
~T() 可能会抛出异常吗？false
T(T 右值) 可能会抛出异常吗？false
T(T 左值) 可能会抛出异常吗？false
U(U 右值) 可能会抛出异常吗？true
U(U 左值) 可能会抛出异常吗？true
V(V 右值) 可能会抛出异常吗？false
V(V 左值) 可能会抛出异常吗？true
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=2722|std=C++17|before=不明确在{{spar sep|表达式}}是纯右值时是否会进行临时量实质化|after=此时会进行临时量实质化}}
{{dr list item|wg=cwg|dr=2792|std=C++11|before={{c/core|noexcept}} 运算符需要确定在碰到未定义行为时是否会抛出异常|after=不需要确定}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/language/dsc noexcept spec}}
{{dsc inc|cpp/language/dsc except spec}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}