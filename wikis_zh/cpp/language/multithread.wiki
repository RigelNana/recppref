{{title|多线程执行与数据竞争 {{mark since c++11}}}}
{{cpp/language/basics/navbar}}

''执行线程''{{sep}}是程序中的控制流，它从某个特定的顶层函数调用（通过 {{lc|std::thread}}、{{lc|std::async}} {{rev inl|since=c++20|和{{lc|std::jthread}}}} 或其他方式进行）开始，并递归地包含由此线程后续执行的所有函数调用。
* 当一个线程创建另一个线程时，对新线程的顶层函数的初始调用，是由新线程而非创建线程执行的。

任何线程都能潜在地访问程序中的任何对象和函数：
* 拥有自动或线程局部{{rlp|storage duration|存储期}}的对象仍然可以被另一线程通过指针或引用访问。
* 在[[cpp/freestanding|宿主实现]]下，C++ 程序可以有多个线程同时执行。每个线程的执行按本页的余下部分定义的方式进行。整个程序的执行包含该程序的所有线程的执行。
* 在[[cpp/freestanding|独立实现]]下，由实现定义程序是否可以有多个线程。

对于并非作为 {{lc|std::raise}} 的调用结果而执行的{{ls|cpp/utility/program/signal#信号处理函数}}，未指定该信号处理函数的调用包含在哪个执行线程中。

===数据竞争===
不同的执行线程始终可以同时访问（读和写）不同的{{rlps|memory model#内存位置}}，不需要干涉或同步的任何要求。

如果一个表达式的{{rlp|eval order|求值}}修改了某个内存位置或者开始/结束了在某个内存位置的对象的生存期，而另一个表达式的求值读取或修改了相同的内存位置或者开始/结束了占据了与该内存位置有重叠的存储的对象的生存期，那么这两个表达式求值''冲突''。

拥有两个冲突的求值的程序就有''数据竞争''，除非
* 两个求值都在同一线程上，或者在同一{{ls|cpp/utility/program/signal#信号处理函数}}中执行，或
* 两个冲突的求值都是原子操作（见 {{lc|std::atomic}}），或
* 一个冲突的求值''先发生于''{{sep}}另一个（见 {{lc|std::memory_order}}）。

如果出现数据竞争，那么程序的行为未定义。

（特别是，{{lc|std::mutex}} 的释放''同步于''，从而''先发生于''{{sep}}另一线程获取同一互斥体，这使得互斥锁可以用来防止数据竞争。）

{{source|1=
int cnt = 0;
auto f = [&amp;]{ cnt++; };
std::thread t1{f}, t2{f}, t3{f}; // 未定义行为
}}
{{source|1=
std::atomic&lt;int&gt; cnt{0};
auto f = [&amp;]{ cnt++; };
std::thread t1{f}, t2{f}, t3{f}; // OK
}}

====容器数据竞争====
[[cpp/container/vector bool|{{tt|std}}{{c/core|::vector&lt;bool&gt;}}]] 以外的所有标准库[[cpp/container|容器]]保证对同一容器的不同元素中包含的对象内容的并行修改不会造成数据竞争。

{{source|1=
std::vector&lt;int&gt; vec = {1, 2, 3, 4};
auto f = [&amp;](int index) { vec[index] = 5; };
std::thread t1{f, 0}, t2{f, 1}; // OK
std::thread t3{f, 2}, t4{f, 2}; // 未定义行为
}}
{{source|1=
std::vector&lt;bool&gt; vec = {false, false};
auto f = [&amp;](int index) { vec[index] = true; };
std::thread t1{f, 0}, t2{f, 1}; // 未定义行为
}}

===内存顺序===
当线程从某个内存位置读取值时，它可能看到初值，同一线程所写入的值，或另一线程所写入的值。有关线程所作的写入操作对其他线程变为可见的顺序上的细节，见 {{lc|std::memory_order}}。

===向前进展===
====免妨碍====
当只有一个未在标准库函数中阻塞的线程执行某个免锁的[[cpp/thread#原子操作|原子函数]]时，保证该执行将会完成（所有标准库免锁操作均为{{enwiki|Non-blocking algorithm#Obstruction-freedom|免妨碍}}的）。

====免锁====
当一或多个免锁原子函数同时运行时，保证其中至少一个将会完成（所有标准库免锁操作均为{{enwiki|Non-blocking algorithm#Lock-freedom|免锁}}的——确保其他线程不能不确定地活锁它们（例如以连续窃取缓存线的方式），是实现的工作）。

====进展保证====
合法的 C++ 程序中，每个线程最终要做下列之一：
* 终止。
* 调用 {{lc|std::this_thread::yield}}。
* 调用库的某个输入/输出库函数。
* 通过 {{rlp|cv|volatile}} 泛左值进行访问。
* 进行原子操作或同步操作。
* 继续执行平凡的无限循环（见下文）。

如果线程执行了上述步骤之一，在标准库函数中阻塞，或调用由于某个未阻塞的并发线程而未能完成的原子免锁函数，那么称它''取得进展''。

这允许编译器移除、合并或重排所有无可观察行为的循环，而不必证明他们终将终止。因为实现可以假定没有线程能在不做任何这些可观察行为的情况下永远执行。平凡的无限循环具有可供性，从而不会被移除或重排。

====平凡的无限循环====
''平凡的空循环语句''{{sep}}是匹配以下格式之一的循环语句：

{{sdsc begin}}
{{sdsc|num=1|
{{ttb|while (}} {{spar|条件}} {{ttb|) ;}}
}}
{{sdsc|num=2|
{{ttb|while (}} {{spar|条件}} {{ttb|) { }&lt;!----&gt;}}
}}
{{sdsc|num=3|
{{ttb|do ; while (}} {{spar|条件}} {{ttb|) ;}} 
}}
{{sdsc|num=4|
{{ttb|do { } while (}} {{spar|条件}} {{ttb|) ;}} 
}}
{{sdsc|num=5|
{{ttb|for (}} {{spar optional|初始化语句 条件}} {{ttb|; ) ;}}
}}
{{sdsc|num=6|
{{ttb|for (}} {{spar optional|初始化语句 条件}} {{ttb|; ) { }&lt;!----&gt;}}
}}
{{sdsc end}}

@1@ 循环体是空简单语句的 {{rlp|while|{{c/core|while}} 语句}}。

@2@ 循环体是空复合语句的 {{rlp|while|{{c/core|while}} 语句}}。

@3@ 循环体是空简单语句的 {{rlp|do|{{c/core|do}}-{{c/core|while}} 语句}}。

@4@ 循环体是空复合语句的 {{rlp|do|{{c/core|do}}-{{c/core|while}} 语句}}。

@5@ 循环体是空简单语句，并且没有{{spar sep|迭代表达式}}的 {{rlp|for|{{c/core|for}} 语句}}。

@6@ 循环体是空复合语句，并且没有{{spar sep|迭代表达式}}的 {{rlp|for|{{c/core|for}} 语句}}。

平凡的空循环语句的''控制表达式''{{sep}}是：
@1-4@ {{spar|条件}}。
@5,6@ {{spar|条件}}，未提供时是 {{c|true}}。

''平凡的无限循环''{{sep}}是控制表达式在{{rlp|constant expression#明显常量求值的表达式|明显常量求值}}的情况下是{{rlp|constant expression|常量表达式}}并且求值为 {{c|true}} 的平凡的空循环语句。

平凡的无限循环的循环体会被替换成对函数 {{lc|std::this_thread::yield}} 的调用。[[cpp/freestanding|独立实现]]中是否会进行该替换由实现定义。

{{source|1=
for (;;); // 平凡的无限循环，P2809 起为良好定义的
for (;;) { int x; } // 未定义行为
}}

{{rev begin}}
{{rev|since=c++17|
====并发向前进展====
如果线程提供''并发向前进展保证''，那么只要它尚未终止，就将在有限量的时间内''取得进展''（定义如上），无关乎其他线程（如果存在）是否取得进展。

标准鼓励但不要求主线程、{{lc|std::thread}} {{rev inl|since=c++20|和 {{lc|std::jthread}}}} 所启动的线程提供并发向前进展保证。

====并行向前进展====
如果线程提供''并行向前进展保证''，那么只要线程尚未执行任何执行步骤（输入/输出、volatile、原子或同步操作），就不要求实现保证该线程终将取得进展，但一旦此线程开始执行步骤，那么它提供''并发向前进展''{{sep}}保证（此规则描述线程池中以任意顺序执行任务的线程）。

====弱并行向前进展====
如果线程提供''弱并行向前进展保证''，那么不保证它终将取得进展，无关乎其他线程是否取得进展。

此类线程仍然能通过以向前进展保证委托进行阻塞来保证取得进展：如果线程 {{tt|P}} 以此方式阻塞于线程集合 {{tt|S}} 的完成，那么 {{tt|S}} 中至少有一个线程将提供等于或强于 {{tt|P}} 的向前进展保证。一旦该线程完成，就会类似地强化 {{tt|S}} 中的另一线程。一旦该集合为空，就会解除 {{tt|P}} 的阻塞。

来自 C++ 标准库的[[cpp/algorithm|并行算法]]，均以向前保证委托阻塞于某个标准库所管理的线程的未指明集合的完成上。
}}
{{rev end}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1953|std=C++11|before=两个开始/结束了存储有重叠的对象的生存期的表达式求值不会冲突|after=会冲突}}
{{dr list item|wg=lwg|dr=2200|std=C++11|before=不明确容器数据竞争的要求是否只适用于序列容器|after=适用于所有容器}}
{{dr list item|paper=P2809R3|std=C++11|before=执行“平凡的”&lt;ref&gt;“平凡”在这里表示执行无限循环不会有任何进展。&lt;/ref&gt;无限循环的行为未定义|after=为“平凡的无限循环”提供合适定义，并使行为具有良好定义}}
{{dr list end}}

&lt;references/&gt;

{{langlinks|en|es|ja|ru}}