{{cpp/ranges/title|cbegin}}
{{cpp/ranges/navbar}}
{{dcl begin}}
{{dcl header|ranges}}
{{dcl header|iterator}}
{{dcl|notes={{mark custpt}}|since=c++20|1=
inline namespace /* 未指明 */ {
    inline constexpr /* 未指明 */ cbegin = /* 未指明 */;
}
}}
{{dcl h|调用签名}}
{{dcl|since=c++20|1=
template&lt; class T &gt;
    requires /* 见下文 */
constexpr /* 见下文 */ auto cbegin( T&amp;&amp; t );
}}
{{dcl end}}

{{rrev multi|until1=c++23
|rev1=返回指向 const 限定的实参的首元素的迭代器。
|rev2=返回指向实参的首元素的常量迭代器。}}

{{image|range-begin-end.svg}}

{{rrev multi|until1=c++23|rev1=
令 {{tt|CT}}
* 若实参为左值（即 {{tt|T}} 为左值引用类型）则为 {{c|const std::remove_reference_t&lt;T&gt;&amp;}}，
* 否则为 {{c|const T}}。
对 {{tt|ranges::cbegin}} 的调用[[cpp/language/expressions#表达式等价|表达式等价]]于 {{c|ranges::begin(static_cast&lt;CT&amp;&amp;&gt;(t))}}。
|rev2=
若实参为左值或者 {{c|ranges::enable_borrowed_range&lt;std::remove_cv_t&lt;T&gt;&gt;}} 为 {{c|true}}，则对 {{tt|ranges::cbegin}} 的调用[[cpp/language/expressions#表达式等价|表达式等价]]于：
* {{c|std::const_iterator&lt;decltype(U)&gt;(U)}} 对于某个表达式 {{c|U}} 等价于 {{box|{{c/core|ranges::begin(}}{{rlpsi|/#possibly-const-range}}{{c/core|(t)}}}}。

所有其他情况下，对 {{tt|ranges::cbegin}} 的调用都非良构，这会在调用出现于模板实例化的立即语境中时导致[[cpp/language/sfinae|代换失败]]。
}}

所有情况下，返回类型都实现 {{lc|std::input_or_output_iterator}}{{rev inl|since=c++23| 和 {{rlpi|constant_range|constant-iterator}}}}。

{{cpp/ranges/cpo}}

===注解===
对于 {{c|T}} 类型的左值范围 {{c|e}}，{{c|ranges::cbegin(e)}} 等价于
{{rrev multi|until1=c++23|rev1=
{{c|ranges::begin(std::as_const(e))}}。
|rev2=
* {{c|ranges::begin(e)}} 若 {{c|T}} 实现 {{lconcept|constant_range}}。
* 否则，{{c|ranges::begin(std::as_const(e))}} 若 {{c|const T}} 实现 {{lconcept|constant_range}}。
* 否则，{{c|std::basic_const_iterator(ranges::begin(e))}}。
}}

===示例===
{{example
|
|code=
#include &lt;cassert&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

int main() 
{
    std::vector v{3, 1, 4};
    auto vi = std::ranges::cbegin(v);
    assert(3 == *vi);
    ++vi; // OK，可以改动常量迭代器对象
    assert(1 == *vi);
    // *vi = 13; // 错误：常量迭代器指向不可改动元素

    int a[]{3, 1, 4};
    auto ai = std::ranges::cbegin(a); // cbegin 也可以对 C 数组
    assert(3 == *ai and *(ai + 1) == 1);
    // *ai = 13; // 错误：只读变量不可赋值
}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc begin}}
{{dsc inc|cpp/iterator/dsc begin}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}