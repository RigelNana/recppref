{{cpp/ranges/view_interface/title|operator bool}}
{{cpp/ranges/view_interface/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++20|
constexpr explicit operator bool() requires /* 见下文 */;
}}
{{dcl|num=2|since=c++20|
constexpr explicit operator bool() const requires /* 见下文 */;
}}
{{dcl end}}

{{c|operator bool}} 成员函数的默认实现检查视图是否为非空。它使得派生类型[[cpp/language/implicit conversion#按语境转换|可按语境转换成 {{c|bool}}]]。

@1@ 令 {{tt|derived}} 为 {{c|static_cast&lt;D&amp;&gt;(*this)}}。requires 子句中的表达式等于 {{c|requires { ranges::empty(derived); }&lt;!----&gt;}}，而函数体等价于 {{c|return !ranges::empty(derived);}}。

@2@ 同 {{v|1}}，但 {{tt|derived}} 为 {{c|static_cast&lt;const D&amp;&gt;(*this)}}。

===返回值===
若派生类型的值为空（由 {{lc|ranges::empty|std::ranges::empty}} 确定）则为 {{c|false}}，否则为 {{c|true}}。

===注解===
C++20 中，标准库中派生自 {{lc|ranges::view_interface|std::ranges::view_interface}} 的类型都不提供其自身的 {{c|operator bool}}。几乎所有这些类型都使用默认实现。

一个值得注意的例外是 {{lc|ranges::basic_istream_view|std::ranges::basic_istream_view}}。由于其迭代器类型决不满足 {{lconcept|forward_iterator}}，故视图不能使用继承的 {{c|operator bool}}。

===示例===
{{example|code=
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;

int main()
{
    const std::array ints {0, 1, 2, 3, 4};
    auto odds = ints {{!}} std::views::filter([](int i) { return 0 != i % 2; });
    auto negs = ints {{!}} std::views::filter([](int i) { return i &lt; 0; });
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; "有奇数: " &lt;&lt; (!!odds) &lt;&lt; ' ' &lt;&lt; '\n'
              &lt;&lt; "有负数: " &lt;&lt; (!!negs) &lt;&lt; ' ' &lt;&lt; '\n';
}
|output=
有奇数: true
有负数: false
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc empty}}
{{dsc inc|cpp/ranges/view_interface/dsc empty}}
{{dsc inc|cpp/iterator/dsc empty}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}