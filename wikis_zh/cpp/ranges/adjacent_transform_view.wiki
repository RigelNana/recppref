{{cpp/ranges/view title|adjacent_transform|{{small|views::}}pairwise_transform}}
{{cpp/ranges/adjacent_transform_view/navbar}}
{{dcl begin}}
{{dcl header|ranges}}
{{dcl|num=1|since=c++23|1=
template&lt; ranges::forward_range V, std::move_constructible F, std::size_t N &gt;
  requires ranges::view&lt;V&gt; &amp;&amp; (N &gt; 0) &amp;&amp; std::is_object_v&lt;F&gt; &amp;&amp;
           std::regular_invocable&lt;F&amp;,
               /*REPEAT*/(ranges::range_reference_t&lt;V&gt;, N)...&gt; &amp;&amp;
           /*can-reference*/&lt;std::invoke_result_t&lt;F&amp;,
               /*REPEAT*/(ranges::range_reference_t&lt;V&gt;, N)...&gt;&gt;
class adjacent_transform_view
    : public ranges::view_interface&lt;adjacent_transform_view&lt;V, F, N&gt;&gt;
}}
{{dcl|num=2|since=c++23|1=
namespace views {
template&lt; std::size_t N &gt;
    constexpr /* 未指明 */ adjacent_transform = /* 未指明 */;
}
}}
{{dcl|num=3|since=c++23|1=
namespace views {
    inline constexpr auto pairwise_transform = adjacent_transform&lt;2&gt;;
}
}}
{{dcl h|调用签名}}
{{dcl|since=c++23|
template&lt; ranges::viewable_range R, class F &gt;
    requires /* 见下文 */
constexpr ranges::view auto adjacent_transform&lt;N&gt;( R&amp;&amp; r, F&amp;&amp; fun );
}}
{{dcl|since=c++23|
template&lt; class F &gt;
constexpr /*范围适配器闭包*/ adjacent_transform&lt;N&gt;( F&amp;&amp; fun );
}}
{{dcl end}}

@1@ {{tt|adjacent_transform_view}} 是接受单个 {{lconcept|view}} 与一个可调用对象 {{c|fun}} 的范围适配器，其生成的 {{lconcept|view}} 的第 {{tti|i}} 个元素为对原始视图 {{range|i|i + N}} 上的每一个元素应用
{{c|fun}} 的结果。{{tt|F}} 的{{enwiki|arity|元数}}总是 {{tt|N}}。

@@ 设 {{tti|S}} 为原始视图的大小，那么生成的视图大小：
* 如果 {{c|1=S &gt;= N}} 则为 {{c|S - N + 1}}。
* 否则为 {{c|0}}，且结果视图为空。

@2@ 名字 {{c|views::adjacent_transform&lt;N&gt;}} 代表一个{{named req|RangeAdaptorObject}}。给定子表达式 {{c|e}} 与 {{c|f}}，与常量表达式 {{tt|N}}，
* 如果 {{tt|N}} 等于 {{c|0}} 且 {{c|decltype((e))}} 实现 {{lconcept|forward_range}}，则表达式 {{c|views::adjacent_transform&lt;N&gt;(e, f)}} [[cpp/language/expressions#表达式等价|表达式等价]]于 {{c|((void)e, views::zip_transform(f))}}（但 {{c|e}} 与 {{c|f}} 的求值[[cpp/language/eval order#求值顺序|顺序不确定]]），
* 否则 {{c|views::adjacent_transform&lt;N&gt;(e, f)}} 表达式等价于 {{c|adjacent_transform_view&lt;views::all_t&lt;decltype((e))&gt;, std::decay_t&lt;decltype((f))&gt;, N&gt;(e, f)}}。

@3@ 名字 {{c|views::pairwise_transform}} 代表一个{{named req|RangeAdaptorObject}}，其行为与 {{c|views::adjacent_transform&lt;2&gt;}} 严格相同。特别是，{{tt|F}} 的元数也为 {{c|2}} 并且 {{c|fun}} 为二元可调用对象。

{{tt|adjacent_transform_view}} 始终实现 {{lconcept|forward_range}}，如果适配的 {{lconcept|view}} 实现 {{lconcept|bidirectional_range}}，{{lconcept|random_access_range}}，或 {{lconcept|sized_range}} 则他也实现对应概念。
&lt;!-- {{tt|adjacent_transform_view}} models {{lconcept|common_range}} if --&gt;
&lt;!-- {{cpp/ranges/cpo|views|adjacent_transform}} --&gt;

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/ranges/adaptor/dsc constructor|adjacent_transform_view}}
{{dsc inc|cpp/ranges/adaptor/dsc begin|adjacent_transform_view}}
{{dsc inc|cpp/ranges/adaptor/dsc end|adjacent_transform_view}}
{{dsc inc|cpp/ranges/adaptor/dsc size|adjacent_transform_view}}
{{dsc inc|cpp/ranges/adaptor/dsc reserve_hint|adjacent_transform_view}}
{{cpp/ranges/view_interface/inherit|embedded=yes|size=invalid|data=invalid}}
{{dsc end}}

===嵌套类型===
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc expos mem type|InnerView|private=yes|{{c/core|ranges::adjacent_view&lt;V, N&gt;}}.}}
{{dsc expos mem type|inner_iterator|private=yes|
* {{c/core|ranges::iterator_t&lt;const InnerView&gt;}}，当 {{tt|Const}} 为 {{c|true}}。否则，
* {{c/core|ranges::iterator_t&lt;InnerView&gt;}}。}}
{{dsc expos mem type|inner_sentinel|private=yes|
* {{c/core|ranges::sentinel_t&lt;const InnerView&gt;}}，当 {{tt|Const}} 为 {{c|true}}。否则，
* {{c/core|ranges::sentinel_t&lt;InnerView&gt;}}。}}
{{dsc end}}

===数据成员===
{{dsc begin}}
{{dsc hitem|成员|描述}}
{{dsc expos mem obj|fun_|id=fun|private=yes|spec={{c/core|/*movable-box*/&lt;F&gt;}}|变换用可调用对象}}
{{dsc expos mem obj|inner_|id=inner|private=yes|spec={{c/core|ranges::adjacent_view&lt;V,N&gt;}}|所存储的视图}}
{{dsc end}}

===嵌套类===
{{dsc begin}}
{{dsc expos mem tclass|cpp/ranges/adjacent_transform_view/iterator|迭代器类型}}
{{dsc expos mem tclass|cpp/ranges/adjacent_transform_view/sentinel|当 {{tt|adjacent_transform_view}} 不满足 {{lconcept|common_range}} 时的哨位类型}}
{{dsc end}}

===注解===
{{c|views::adjacent_transform}} 仅接受向前范围，即使当 {{tt|N}} 为 {{tt|0}}。

{{feature test macro|__cpp_lib_ranges_zip|std=C++23|value=202110L|{{c/core|ranges::zip_view}},&lt;br&gt;{{c/core|ranges::zip_transform_view}},&lt;br&gt;{{c/core|ranges::adjacent_view}},&lt;br&gt;{{tt|ranges::adjacent_transform_view}}}}

===示例===
{{example
|code=
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;

int main()
{
    constexpr static std::array data{1, 2, 3, 4, 5, 6};
    constexpr int window {3};

    auto Fun = [](auto... ints) { return (... + ints); };
    // 另一种方案，Fun 也可以是任何三元（当 window == 3 时）可调用体，比如：
    // auto Fun = [](int x, int y, int z) { return x + y + z; };

    constexpr auto view = data {{!}} std::views::adjacent_transform&lt;window&gt;(Fun);

    static_assert(
        view.size() == (data.size() - window + 1)
        &amp;&amp; std::array{6, 9, 12, 15}
        == std::array{view[0], view[1], view[2], view[3]}
        &amp;&amp; view[0] == Fun(data[0], data[1], data[2])
        &amp;&amp; view[1] == Fun(data[1], data[2], data[3])
        &amp;&amp; view[2] == Fun(data[2], data[3], data[4])
        &amp;&amp; view[3] == Fun(data[3], data[4], data[5])
    );

    for (int x : view)
        std::cout &lt;&lt; x &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
6 9 12 15
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=4098|std=C++23|before={{c|views::adjacent_transform&lt;0&gt;}} 曾接受仅输入的范围|after=使之拒绝}}
{{dr list end}}

===引用===
{{ref std c++23}}
{{ref std|title=Adjacent transform view|id=range.adjacent.transform|section=26.7.27}}
{{ref std end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc adjacent_view}}
{{dsc inc|cpp/ranges/dsc transform_view}}
{{dsc inc|cpp/ranges/dsc zip_transform_view}}
{{dsc inc|cpp/algorithm/ranges/dsc transform}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}