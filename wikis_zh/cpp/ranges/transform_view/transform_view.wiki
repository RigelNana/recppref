{{cpp/ranges/transform_view/title|transform_view}}
{{cpp/ranges/transform_view/navbar}}

{{dcl begin}}
{{dcl|num=1|since=c++20|1=
transform_view() requires std::default_initializable&lt;V&gt; &amp;&amp; 
                          std::default_initializable&lt;F&gt; = default;
}}
{{dcl|num=2|since=c++20|1=
constexpr explicit transform_view( V base, F fun );
}}
{{dcl end}}

构造 {{tt|transform_view}}。

@1@ 默认构造函数。[[cpp/language/value_initialization|值初始化]]底层视图 {{rlpsi|/#base_}} 与变换函数 {{rlpsi|/#fun_}}。

@2@ 从 {{c|base}} 移动构造视图 {{rlpsi|/#base_}}，并从 {{c|fun}} 移动构造变换函数 {{rlpsi|/#fun_}}。

===参数===
{{par begin}}
{{par|base|视图}}
{{par|fun|变换函数}}
{{par end}}

===示例===
{{example
|演示使用 {{math|1}} 的反正切的级数展开的 {{math|π}} 近似：{{math|1=atan(1) = π/4 ≈ 1 - 1/3 + 1/5 - 1/7 + 1/9 - 1/11 + ...}}
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;ranges&gt;

int main()
{
    std::cout &lt;&lt; std::setprecision(15) &lt;&lt; std::fixed;
    auto atan1term{std::ranges::views::transform
    (
        [](int n) { return ((n % 2) ? -1 : 1) * 1.0 / (2 * n + 1); }
    )};
    for (const int iterations : {1, 2, 3, 4, 5, 10, 100, 1000, 1'000'000})
    {
        auto seq{std::ranges::views::iota(0, iterations) bitor atan1term};
        const double accum{*std::ranges::fold_left_first(seq, std::plus{})};
        std::cout &lt;&lt; "π ≈ " &lt;&lt; 4 * accum &lt;&lt; "（迭代 " &lt;&lt; iterations &lt;&lt; " 次）\n";
    }
    std::cout &lt;&lt; "π ≈ " &lt;&lt; std::numbers::pi &lt;&lt; "（std::numbers::pi）\n";
}
|p=true
|output=
π ≈ 4.000000000000000（迭代 1 次）
π ≈ 2.666666666666667（迭代 2 次）
π ≈ 3.466666666666667（迭代 3 次）
π ≈ 2.895238095238096（迭代 4 次）
π ≈ 3.339682539682540（迭代 5 次）
π ≈ 3.041839618929403（迭代 10 次）
π ≈ 3.131592903558554（迭代 100 次）
π ≈ 3.140592653839794（迭代 1000 次）
π ≈ 3.141591653589774（迭代 1000000 次）
π ≈ 3.141592653589793（std::numbers::pi）
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3714|paper=P2711R1|std=C++20|before=多参数构造函数不是显式的|after=改成显式的}}
{{dr list item|paper=P2325R3|std=C++20|before=如果 {{tt|F}} 不 {{lconcept|default_initializable}} ，&lt;br&gt;那么默认构造函数构造不含 {{tt|F}} 的 {{tt|transform_view}}|after={{tt|transform_view}} 也不&lt;br&gt;{{lconcept|default_initializable}}}}
{{dr list end}}

{{langlinks|de|en|es|ja|ru}}