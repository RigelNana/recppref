{{cpp/ranges/title|range}}
{{cpp/ranges/navbar}}
{{ddcl|header=ranges|since=c++20|1=
template&lt; class T &gt;
concept range = requires( T&amp; t ) {
    ranges::begin(t); // 对向前迭代器保持相等性
    ranges::end  (t);
};
}}

{{tt|range}} 概念定义允许通过指代元素范围的迭代器和哨位，在它的元素上迭代的类型。

===语义要求===
给定表达式 {{c|E}} 使得 {{c/core|decltype((E))}} 是 {{tt|T}}，只有在满足以下全部条件时 {{tt|T}} 才会实现 {{tt|range}}：
* {{range|ranges::begin(E)|ranges::end(E)}} 代表[[cpp/iterator#范围|范围]]。
* {{c|ranges::begin(E)}} 与 {{c|ranges::end(E)}} 均有均摊常量时间复杂度且不会以对于保持相等性的表达式可观察的方式更改 {{c|E}} 的值。
* 如果 {{c|ranges::begin(E)}} 的类型实现 {{lconcept|forward_iterator}}，那么 {{c|ranges::begin(E)}} 保持相等性（换言之，向前迭代器支持多趟算法）。

===注解===
一个典型的 {{tt|range}} 类只需要提供两个函数：

# 成员函数 {{tt|begin()}}，它的返回类型实现 {{lconcept|input_or_output_iterator}}。
# 成员函数 {{tt|end()}}，它的返回类型实现 {{lconcept|sentinel_for}}{{tt|&lt;It&gt;}}，其中 {{tt|It}} 是 {{tt|begin()}} 的返回类型。

它们也可以作为非成员函数实现，通过[[cpp/language/adl|实参依赖查找]]找到。

===示例===
{{example
|code=
#include &lt;ranges&gt;

// 最小化的范围
struct SimpleRange
{
    int* begin();
    int* end();
};
static_assert(std::ranges::range&lt;SimpleRange&gt;);

// 不是范围：没有 begin/end
struct NotRange
{
    int t {};
};
static_assert(!std::ranges::range&lt;NotRange&gt;);

// 不是范围：begin 返回的不是 input_or_output_iterator
struct NotRange2
{
    void* begin();
    int* end();
};
static_assert(!std::ranges::range&lt;NotRange2&gt;);

int main() {}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3915|std=C++20|before={{c|ranges::begin(t)}} 和 {{c|ranges::end(t)}} 不要求有隐式的表达式变种|after=移除此多余描述}}
{{dr list end}}

{{langlinks|en|es|ja|ru}}