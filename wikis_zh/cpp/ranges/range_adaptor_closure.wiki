{{cpp/ranges/title|range_adaptor_closure}}
{{cpp/ranges/navbar}}

{{ddcl|header=ranges|since=c++23|1=
template&lt; class D &gt;
    requires std::is_object_v&lt;D&gt; &amp;&amp; std::same_as&lt;D, std::remove_cv_t&lt;D&gt;&gt;
class range_adaptor_closure {};
}}

{{tt|std::ranges::range_adaptor_closure}} 是用于定义{{named req|RangeAdaptorClosureObject}}的辅助类模板。

令 {{c|t}} 为类型 {{tt|T}} 的对象，实现确保满足下列所有条件的 {{c|t}} 为范围适配器闭包对象：
* {{c|t}} 为接受一个 {{lconcept|range}} 实参的一元函数对象。
* {{tt|T}} 存在唯一公开基类 {{c/core|ranges::range_adaptor_closure&lt;T&gt;}}，并且对于其他任意类型 {{tt|U}}，{{tt|T}} 无基类类型 {{c/core|ranges::range_adaptor_closure&lt;U&gt;}}。
* {{tt|T}} 不满足 {{lconcept|range}}。

===注解===
{{ftm begin}}
{{ftm|__cpp_lib_ranges|value=202202L|std=C++23|{{tt|std::ranges::range_adaptor_closure}}}}
{{ftm end}}

===示例===
{{example
|code=
#include &lt;ranges&gt;
#include &lt;string_view&gt;

// 定义 Slice 为范围适配器闭包
struct Slice : std::ranges::range_adaptor_closure&lt;Slice&gt;
{
    std::size_t start = 0;
    std::size_t end = std::string_view::npos;

    constexpr std::string_view operator()(std::string_view sv) const
    {
        return sv.substr(start, end - start);
    }
};

int main()
{
    constexpr std::string_view str = "01234567";

    constexpr Slice slicer{.start = 1, .end = 6};

    // 使用 slicer 作为普通函数对象
    constexpr auto sv1 = slicer(str);
    static_assert(sv1 == "12345");

    // 使用 slicer 作为范围适配器闭包对象
    constexpr auto sv2 = str {{!}} slicer;
    static_assert(sv2 == "12345");

    // 范围适配器闭包可以如下组成
    constexpr auto slice_and_drop = slicer {{!}} std::views::drop(2);
    static_assert(std::string_view(str {{!}} slice_and_drop) == "345");
}
}}

{{langlinks|de|en|es|ja|ru}}