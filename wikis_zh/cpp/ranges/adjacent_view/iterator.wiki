{{cpp/ranges/adjacent_view/title|''iterator''}}
{{cpp/ranges/adjacent_view/navbar}}

{{ddcl|since=c++23|notes={{mark expos}}|
template&lt; bool Const &gt;
class /*iterator*/
}}

{{rlpt|begin|adjacent_view::begin}} 的返回类型，以及当底层视图 {{tt|V}} 为 {{lconcept|common_range}} 时 {{rlpt|end|adjacent_view::end}} 的返回类型。

const 限定的重载返回类型 {{c|/*iterator*/&lt;true&gt;}}。非 const 限定的重载返回类型 {{c|/*iterator*/&lt;false&gt;}}。

===成员类型===
{{dsc begin}}
{{dsc hitem|成员类型|定义}}
{{dsc expos mem type|Base|private=yes|如果 {{c|Const}} 为 {{c|true}}，则为 {{c|const V}} 否则为 {{c|V}}。}}
{{dsc|{{tt|iterator_category}}|{{c|std::input_iterator_tag}}}}
{{dsc|{{tt|iterator_concept}}|
* {{c|std::random_access_iterator_tag}}，如果 {{tti|Base}} 实现 {{lconcept|random_access_range}}。否则，
* {{c|std::bidirectional_iterator_tag}}，如果 {{tti|Base}} 实现 {{lconcept|bidirectional_range}}。否则，
* {{c|std::forward_iterator_tag}}。}}
{{dsc|{{tt|value_type}}|{{c|std::tuple&lt;/*REPEAT*/(ranges::range_value_t&lt;Base&gt;, N)...&gt;;}}}}
{{dsc|{{tt|difference_type}}|{{c|ranges::range_difference_t&lt;Base&gt;}}}}
{{dsc end}}

===数据成员===
{{dsc begin}}
{{dsc hitem|成员对象|定义}}
{{dsc expos mem obj|current_|private=yes|{{c|std::array&lt;ranges::iterator_t&lt;Base&gt;, N&gt;}}。}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc mem ctor|cpp/ranges/adjacent_view/iterator/iterator|构造一个迭代器}}
{{dsc mem fun|cpp/ranges/adjacent_view/iterator/operator*|访问元素}}
{{dsc mem fun|cpp/ranges/adjacent_view/iterator/operator_at|title=operator[]|按索引访问元素}}
{{dsc inc|cpp/ranges/adaptor/iterator/dsc operator arith|adjacent_view}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc fun|cpp/ranges/adjacent_view/iterator/operator_cmp|title=operator==&lt;br&gt;operator&lt;&lt;br&gt;operator&gt;&lt;br&gt;operator&lt;=&lt;br&gt;operator&gt;=&lt;br&gt;operator&lt;=&gt;|比较底层迭代器|notes={{mark c++23}}}}
{{dsc fun|cpp/ranges/adjacent_view/iterator/operator_arith2|title=operator+&lt;br&gt;operator-|进行迭代器算术|notes={{mark c++23}}}}
{{dsc fun|cpp/ranges/adjacent_view/iterator/iter_move|将对底层迭代器的解引用结果转换为相关的右值引用类型|notes={{mark c++23}}}}
{{dsc fun|cpp/ranges/adjacent_view/iterator/iter_swap|交换两个底层迭代器指向的对象|notes={{mark c++23}}}}
{{dsc end}}

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;concepts&gt;
#include &lt;list&gt;
#include &lt;ranges&gt;
#include &lt;tuple&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

int main()
{
    auto v = std::vector{0, 1, 2, 3, 4, 5};
    auto i = (v {{!}} std::views::adjacent&lt;3&gt;).begin();
    using I = decltype(i);
    static_assert(std::same_as&lt;I::value_type, std::tuple&lt;int, int, int&gt;&gt;);
    static_assert(std::same_as&lt;I::iterator_concept, std::random_access_iterator_tag&gt;);
    // 一些可用的运算符：
    ++i; i++; --i; i--; i += 2; i -= 2;
    assert(i[2] == std::tuple(2, 3, 4));
    using DI = decltype(*i);
    static_assert(std::same_as&lt;DI, std::tuple&lt;int&amp;, int&amp;, int&amp;&gt;&gt;);
    std::get&lt;1&gt;(*i) = 42; // 通过迭代器 i 修改 v[1]
    assert(v[1] == 42);

    auto l = std::list{0, 1, 2, 3, 4, 5};
    auto j = (l {{!}} std::views::adjacent&lt;3&gt;).begin();
    using J = decltype(j);
    static_assert(std::same_as&lt;J::value_type, std::tuple&lt;int, int, int&gt;&gt;);
    static_assert(std::same_as&lt;J::iterator_concept, std::bidirectional_iterator_tag&gt;);
    ++j; --j; j++; j--; // 一些可用的运算符
    // j += 2; j -= 2;       // 错误：这些运算符
    // std::ignore() = j[1]; //      对于双向迭代器不可用
}
}}

===引用===
{{ref std c++23}}
{{ref std|title=Class template adjacent_view::iterator|id=range.adjacent.iterator|section=26.7.25.3}}
{{ref std end}}

===参阅===
{{dsc begin}}
&lt;!--
{{dsc inc|cpp/ranges/adjacent_transform_view/dsc iterator}}
--&gt;
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}