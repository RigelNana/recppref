{{cpp/ranges/title|data}}
{{cpp/ranges/navbar}}

{{dcl begin}}
{{dcl header|ranges}}
{{dcl header|iterator}}
{{dcl|notes={{mark custpt}}|since=c++20|1=
inline namespace /* 未指定 */ {
    inline constexpr /* 未指定 */ data = /* 未指定 */;
}
}}

{{dcl h|调用签名}}
{{dcl|since=c++20|1=
template&lt; class T &gt;
    requires /* 见下文 */
constexpr std::remove_reference_t&lt;
    ranges::range_reference_t&lt;T&gt;&gt;* data( T&amp;&amp; t );
}}
{{dcl end}}

返回指向连续范围首元素的指针。

如果 {{tt|T}} 是数组类型且 {{c/core|std::remove_all_extents_t&lt;std::remove_reference_t&lt;T&gt;&gt;}} 不完整，那么 {{c|ranges::data(std::forward&lt;T&gt;(t))}} 非良构，不要求诊断。

如果实参是左值或 {{c|ranges::enable_borrowed_range&lt;std::remove_cv_t&lt;T&gt;&gt;}} 是 {{c|true}}，那么对 {{tt|ranges::data}} 的调用[[cpp/language/expressions#表达式等价|表达式等价]]于：
# {{rev inl|until=c++23|{{box|{{lti|cpp/standard library/decay-copy}}{{c/core|(t.data())}}}}}}{{rev inl|since=c++23|{{c|auto(t.data())}}}}，如果表达式合法且它的类型是指向对象的指针类型。
# 否则，如果表达式 {{c|ranges::begin(std::forward&lt;T&gt;(t))}} 合法且它的类型实现 {{lc|std::contiguous_iterator}}，则是 {{c|std::to_address(ranges::begin(std::forward&lt;T&gt;(t)))}}。

所有其他情况下，对 {{tt|ranges::data}} 的调用非良构，这能在 {{c|ranges::data(e)}} 出现于模板实例化的立即语境时导致[[cpp/language/sfinae|代换失败]]。

{{cpp/ranges/cpo}}

===注解===
如果实参是右值（即 {{tt|T}} 是对象类型）且 {{c|ranges::enable_borrowed_range&lt;std::remove_cv_t&lt;T&gt;&gt;}} 是 {{c|false}}，那么调用 {{tt|ranges::data}} 非良构，这也会导致代换失败。

如果 {{c|ranges::data(e)}} 对表达式 {{c|e}} 合法，那么它返回指向对象的指针。

{{cpp/ranges/prv}}

===示例===
{{example
|code=
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;string&gt;

int main()
{
    std::string s {"Hello world!\n"};
    
    char a[20]; // C 风格字符串的存储
    std::strcpy(a, std::ranges::data(s));
    // [data(s), data(s) + size(s)] 保证是 NTBS（空中止字节字符串）
    
    std::cout &lt;&lt; a;
}
|output=
Hello world!
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc cdata}}
{{dsc inc|cpp/ranges/dsc begin}}
{{dsc inc|cpp/iterator/dsc data}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}