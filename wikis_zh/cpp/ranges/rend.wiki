{{cpp/ranges/title|rend}}
{{cpp/ranges/navbar}}

{{dcl begin}}
{{dcl header|ranges}}
{{dcl header|iterator}}
{{dcl|notes={{mark custpt}}|since=c++20|1=
inline namespace /* 未指定 */ {
    inline constexpr /* 未指定 */ rend = /* 未指定 */;
}
}}
{{dcl h|调用签名}}
{{dcl|since=c++20|1=
template&lt; class T &gt;
    requires /* 见下文 */
constexpr std::sentinel_for&lt;
    decltype(ranges::rbegin(std::declval&lt;T&gt;()))&gt; auto rend( T&amp;&amp; t );
}}
{{dcl end}}

返回指示逆向范围末尾的哨位。

{{image|range-rbegin-rend.svg}}

如果 {{tt|T}} 是数组类型且 {{c/core|std::remove_all_extents_t&lt;std::remove_reference_t&lt;T&gt;&gt;}} 不完整，那么调用 {{tt|ranges::rend}} 非良构，不要求诊断。

如果实参是左值或者 {{c|ranges::enable_borrowed_range&lt;std::remove_cv_t&lt;T&gt;&gt;}} 是 {{c|true}}，则对 {{tt|ranges::rend}} 的调用[[cpp/language/expressions#表达式等价|表达式等价]]于：
# {{rev inl|until=c++23|{{box|{{lti|cpp/standard library/decay-copy}}{{c/core|(t.rend())}}}}}}{{rev inl|since=c++23|{{c|auto(t.rend())}}}}，如果该表达式合法且它的类型实现 {{c|std::sentinel_for&lt;decltype(ranges::rbegin(std::declval&lt;T&gt;()))&gt;}}。
# 否则是 {{rev inl|until=c++23|{{box|{{lti|cpp/standard library/decay-copy}}{{c/core|(rend(t))}}}}}}{{rev inl|since=c++23|{{c|auto(rend(t))}}}}，如果 {{tt|T}} 是类或枚举类型，而该表达式合法且它的类型实现 {{c|std::sentinel_for&lt;decltype(ranges::rbegin(std::declval&lt;T&gt;()))&gt;}}，其中如同以仅通过进行[[cpp/language/adl|实参依赖查找]]来设立 {{tt|rend}} 的含义。
# 否则是 {{c|std::make_reverse_iterator(ranges::begin(std::forward&lt;T&gt;(t)))}}，如果 {{c|ranges::begin(std::forward&lt;T&gt;(t))}} 和 {{c|ranges::end(std::forward&lt;T&gt;(t))}} 都是合法表达式，具有相同类型，且该类型实现 {{lc|std::bidirectional_iterator}}。

所有其他情况下，调用 {{tt|ranges::rend}} 非良构，这能在 {{c|ranges::rend(t)}} 出现于模板实例化的立即语境时导致[[cpp/language/sfinae|代换失败]]。

{{cpp/ranges/cpo}}

===注解===
如果实参是右值（即 {{tt|T}} 是对象类型）且 {{c|ranges::enable_borrowed_range&lt;std::remove_cv_t&lt;T&gt;&gt;}} 是 {{c|false}}，那么调用 {{tt|ranges::rend}} 非良构，这也会导致代换失败。

如果 {{c|ranges::rend(std::forward&lt;T&gt;(t))}} 合法，那么 {{c|decltype(ranges::rend(std::forward&lt;T&gt;(t)))}} 和 {{c|decltype(ranges::begin(std::forward&lt;T&gt;(t)))}} 在所有情况下都实现 {{lc|std::sentinel_for}}，同时 {{tt|T}} 实现 {{lc|std::ranges::range}}。

{{cpp/ranges/prv}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

int main() 
{
    std::vector&lt;int&gt; v = {3, 1, 4};
    namespace ranges = std::ranges;
    if (ranges::find(ranges::rbegin(v), ranges::rend(v), 5) != ranges::rend(v))
        std::cout &lt;&lt; "在 vector v 中找到了 5！\n";
    
    int a[] = {5, 10, 15};
    if (ranges::find(ranges::rbegin(a), ranges::rend(a), 5) != ranges::rend(a))
        std::cout &lt;&lt; "在数组 a 中找到了 5！\n";
}
|output=
在数组 a 中找到了 5！
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc crend}}
{{dsc inc|cpp/ranges/dsc rbegin}}
{{dsc inc|cpp/iterator/dsc rend}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}