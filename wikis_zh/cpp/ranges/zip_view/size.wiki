{{cpp/ranges/zip_view/title|size}}
{{cpp/ranges/zip_view/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++23|1=
constexpr auto size()
    requires (ranges::sized_range&lt;Views&gt; &amp;&amp; ...);
}}
{{dcl|num=2|since=c++23|1=
constexpr auto size() const
    requires (ranges::sized_range&lt;const Views&gt; &amp;&amp; ...);
}}
{{dcl end}}

返回 {{rlpt|/|zip_view}} 中的元素数量。仅当每个底层（所适配的）范围都满足 {{lconcept|sized_range}} 时才提供。

等价于：
{{source|1=
return std::apply
(
    [](auto... sizes)
    {
        using CT = /*make-unsigned-like-t*/&lt;std::common_type_t&lt;decltype(sizes)...&gt;&gt;;
        return ranges::min({CT(sizes)...});
    },
    /*tuple-transform*/(ranges::size, views_)
);
}}

===参数===
（无）

===返回值===
元素数量，为所适配 {{lconcept|view}} 的所有大小中的最小大小。

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;deque&gt;
#include &lt;forward_list&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

int main()
{
    auto x = std::vector{1, 2, 3, 4, 5};
    auto y = std::deque{'a', 'b', 'c'};
    auto z = std::forward_list{1., 2.};

    auto v1 = std::views::zip(x, y);
    assert(v1.size() == std::min(x.size(), y.size()));
    assert(v1.size() == 3);

    [[maybe_unused]] auto v2 = std::views::zip(x, z);
//  auto sz = v2.size(); // 错误，v2 没有 size()：
    static_assert(not std::ranges::sized_range&lt;decltype(z)&gt;);
}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc size}}
{{dsc inc|cpp/ranges/dsc ssize}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}