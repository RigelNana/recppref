{{cpp/ranges/title|elements_of}}
{{cpp/ranges/navbar}}

{{ddcl|header=ranges|since=c++23|1=
template&lt; ranges::range R, class Allocator = std::allocator&lt;std::byte&gt; &gt;
struct elements_of;
}}

封装一个 {{lconcept|range}}。{{tt|elements_of}} 的特化在重载集中作为标签，用以区分一个范围应当被视为序列而非单个值的情况。

===模板形参===
{{par begin}}
{{par|R|满足 {{lconcept|range}} 的类型}}
{{par|Allocator|满足{{named req|Allocator}}规定的分配器类型}}
{{par end}}

===数据成员===
{{dsc begin}}
{{dsc hitem|成员名字|定义}}
{{dsc mem obj|range|nolink=true|{{tt|R}} 类型的范围}}
{{dsc mem obj|allocator|nolink=true|{{tt|Allocator}} 类型的分配器。它带有为其自身进行值初始化的默认成员初始化式。}}
{{dsc end}}

所有这些成员都被声明为带有 {{attr|no_unique_address}} 属性。

===推导指引===
{{ddcl|since=c++23|1=
template&lt; class R, class Allocator = std::allocator&lt;std::byte&gt; &gt;
elements_of( R&amp;&amp;, Allocator = Allocator() ) -&gt; elements_of&lt;R&amp;&amp;, Allocator&gt;;
}}

===示例===
{{example
|code=
#include &lt;any&gt;
#include &lt;generator&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;string_view&gt;

template&lt;bool Elementwise&gt;
std::generator&lt;std::any&gt; gen(std::ranges::input_range auto&amp;&amp; r)
{
    if constexpr (Elementwise)
        co_yield std::ranges::elements_of(r); // 产出 r 的每个元素
    else
        co_yield r;                           // 产出 r 作为单个值
}

int main()
{
    auto test = std::string_view{"test"};

    for (std::any a : gen&lt;true&gt;(test))
        std::cout &lt;&lt; '[' &lt;&lt; std::any_cast&lt;char&gt;(a) &lt;&lt; "] ";
    std::cout &lt;&lt; '\n';

    for (std::any a : gen&lt;false&gt;(test))
        std::cout &lt;&lt; '[' &lt;&lt; std::any_cast&lt;std::string_view&gt;(a) &lt;&lt; "] ";
    std::cout &lt;&lt; '\n';
}
|output=
[t] [e] [s] [t] 
[test]
}}

===引用===
{{ref std c++23}}
{{ref std|title=Class template elements_of|id=range.elementsof|section=26.5.6}}
{{ref std end}}