{{cpp/ranges/view title|transform}}
{{cpp/ranges/transform_view/navbar}}

{{dcl begin}}
{{dcl header|ranges}}
{{dcl rev multi|num=1|since1=c++20|dcl1=
template&lt; ranges::input_range V,
          std::copy_constructible F &gt;
    requires ranges::view&lt;V&gt; &amp;&amp;
             std::is_object_v&lt;F&gt; &amp;&amp;
             std::regular_invocable&lt;F&amp;, ranges::range_reference_t&lt;V&gt;&gt; &amp;&amp;
             /* invoke_result_t&lt;F&amp;, range_reference_t&lt;V&gt;&gt;&amp; 为有效类型 */
class transform_view
    : public ranges::view_interface&lt;transform_view&lt;V, F&gt;&gt;
|since2=c++23|dcl2=
template&lt; ranges::input_range V,
          std::move_constructible F &gt;
    requires ranges::view&lt;V&gt; &amp;&amp;
             std::is_object_v&lt;F&gt; &amp;&amp;
             std::regular_invocable&lt;F&amp;, ranges::range_reference_t&lt;V&gt;&gt; &amp;&amp;
             /* invoke_result_t&lt;F&amp;, range_reference_t&lt;V&gt;&gt;&amp; 为有效类型 */
class transform_view
    : public ranges::view_interface&lt;transform_view&lt;V, F&gt;&gt;
}}
{{dcl|num=2|since=c++20|1=
namespace views {
    inline constexpr /* 未指明 */ transform = /* 未指明 */;
}
}}
{{dcl h|调用签名}}
{{dcl|since=c++20|
template&lt; ranges::viewable_range R, class F &gt;
    requires /* 见下文 */
constexpr ranges::view auto transform( R&amp;&amp; r, F&amp;&amp; fun );
}}
{{dcl|since=c++20|
template&lt; class F &gt;
constexpr /* 范围适配器闭包 */ transform( F&amp;&amp; fun );
}}
{{dcl end}}

@1@ 表示底层序列应用变换函数到每个元素后的 {{lconcept|view}} 的范围适配器。
@2@ {{named req|RangeAdaptorObject}}。对任意适合的表达式 {{c|e}} 与 {{c|f}}，表达式 {{c|views::transform(e, f)}} [[cpp/language/expressions#表达式等价|表达式等价]]于 {{c|transform_view(e, f)}}。

{{tt|transform_view}} 分别在底层视图 {{c|V}} 实现 {{lconcept|random_access_range}}、{{lconcept|bidirectional_range}}、{{lconcept|forward_range}}、{{lconcept|input_range}}、{{lconcept|common_range}} 与 {{lconcept|sized_range}} 时实现相应概念。

===数据成员===
{{dsc begin}}
{{dsc hitem|成员|说明}}
{{dsc expos mem obj|base_|id=base|private=yes|spec={{tt|V}}|底层视图}}
{{dsc expos mem obj|fun_|id=fun|private=yes|spec={{rev inl|until=c++23|{{rlpi|copyable_wrapper|copyable-box&lt;!--P2325R3--&gt;}}{{tt|&lt;F&gt;}}}}{{rev inl|since=c++23|{{rlpi|copyable_wrapper|movable-box}}{{tt|&lt;F&gt;}}}}|底层函数对象}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/ranges/adaptor/dsc constructor|transform_view}}
{{dsc inc|cpp/ranges/adaptor/dsc base|transform_view}}
{{dsc inc|cpp/ranges/adaptor/dsc begin|transform_view}}
{{dsc inc|cpp/ranges/adaptor/dsc end|transform_view}}
{{dsc inc|cpp/ranges/adaptor/dsc size|transform_view}}
{{dsc inc|cpp/ranges/adaptor/dsc reserve_hint|transform_view}}

{{cpp/ranges/view_interface/inherit|embedded=yes|size=yes|data=invalid}}
{{dsc end}}

==={{rl|deduction guides|推导指引}}===

===嵌套类===
{{dsc begin}}
{{dsc expos mem tclass|cpp/ranges/transform_view/iterator|迭代器类型}}
{{dsc expos mem tclass|cpp/ranges/transform_view/sentinel|哨位类型}} 
{{dsc end}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;iterator&gt;
#include &lt;ranges&gt;
#include &lt;string&gt;

char rot13a(const char x, const char a)
{
    return a + (x - a + 13) % 26;
}

char rot13(const char x)
{
    if ('Z' &gt;= x and x &gt;= 'A')
        return rot13a(x, 'A');
 
    if ('z' &gt;= x and x &gt;= 'a')
        return rot13a(x, 'a');
 
    return x;
}

int main()
{
    auto show = [](const unsigned char x){ std::putchar(x); };
    
    std::string in{"cppreference.com\n"};
    std::ranges::for_each(in, show);
    std::ranges::for_each(in {{!}} std::views::transform(rot13), show);
    
    std::string out;
    std::ranges::copy(std::views::transform(in, rot13), std::back_inserter(out));
    std::ranges::for_each(out, show);
    std::ranges::for_each(out {{!}} std::views::transform(rot13), show);
}
|output=
cppreference.com
pccersrerapr.pbz
pccersrerapr.pbz
cppreference.com
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc transform}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}