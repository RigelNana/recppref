{{cpp/ranges/view title|take}}
{{cpp/ranges/take_view/navbar}}

{{dcl begin}}
{{dcl header|ranges}}
{{dcl|num=1|since=c++20|1=
template&lt; ranges::view V &gt;
class take_view
    : public ranges::view_interface&lt;take_view&lt;V&gt;&gt;
}}
{{dcl|num=2|since=c++20|1=
namespace views {
    inline constexpr /* 未指定 */ take = /* 未指定 */;
}
}}
{{dcl h|调用签名}}
{{dcl|since=c++20|1=
template&lt; ranges::viewable_range R &gt;
    requires /* 见下文 */
constexpr ranges::view auto
    take( R&amp;&amp; r, ranges::range_difference_t&lt;R&gt; count );
}}
{{dcl|since=c++20|1=
template&lt; class DifferenceType &gt;
constexpr /* 范围适配器闭包 */ take( DifferenceType&amp;&amp; count );
}}
{{dcl end}}

@1@ 范围适配器，表示来自底层序列中始于开端终于给定边界的元素的 {{lconcept|view}}。
@2@ {{tt|views::take}} 是一个{{named req|RangeAdaptorObject}}。表达式 {{c|views::take(e, f)}} 产生表示来自 {{c|e}} 的前 {{c|f}} 个元素的视图。结果不一定是 {{tt|take_view}}。
&lt;!----&gt;
{{c|views::take(e, f)}} [[cpp/language/expressions#表达式等价|表达式等价]]于（其中 {{tt|T}} 是 {{c/core|std::remove_cvref_t&lt;decltype((e))&gt;}}，而 {{tt|D}} 是 {{c/core|ranges::range_difference_t&lt;decltype((e))&gt;}}）：
&lt;!----&gt;
* {{box|{{c/core|((void)f,}}{{nbspt}}{{lti|cpp/standard library/decay-copy}}{{c/core|(e))}}}}，如果 {{tt|T}} 是 {{c/core|ranges::empty_view}}，但 {{c|e}} 与 {{c|f}} 的求值顺序不确定；&lt;!-- LWG 3524 --&gt;
* {{c|U(ranges::begin(e), ranges::begin(e) + std::min&lt;D&gt;(ranges::distance(e), f))}}，如果 {{tt|T}} 是 {{c/core|std::span}}、{{lc|std::basic_string_view}} 或 {{c/core|ranges::subrange}} 的特化且它同时实现 {{lconcept|random_access_range}} 和 {{lconcept|sized_range}}，其中 {{tt|U}} 是
:* {{c/core|std::span&lt;typename T::element_type&gt;}}，如果 {{tt|T}} 是 {{c/core|std::span}} 的特化；
:* {{tt|T}}，如果 {{tt|T}} 是 {{lc|std::basic_string_view}} 的特化；
:* {{c/core|ranges::subrange&lt;ranges::iterator_t&lt;T&gt;&gt;}}，如果 {{tt|T}} 是 {{c/core|ranges::subrange}} 的特化；
* {{c multi|ranges::iota_view(*ranges::begin(e),|                  *(ranges::begin(e) + std::min&lt;D&gt;(ranges::distance(e), f)))}}，如果 {{tt|T}} 是 {{c/core|ranges::iota_view}} 的特化且同时实现 {{lconcept|random_access_range}} 和 {{lconcept|sized_range}}；
{{rrev|since=c++23|
* 否则，如果 {{tt|T}} 是 {{l2tt|cpp/ranges/repeat_view}} 的特化：
:* {{c|views::repeat(*e.value_, std::min&lt;D&gt;(ranges::distance(e), f))}}，如果 {{tt|T}} 实现 {{lconcept|sized_range}}；这种情况下 {{c|e}} 仅求值一次；
:* 否则是 {{c|views::repeat(*e.value_, static_cast&lt;D&gt;(e))}}；
}}
* 否则是 {{c|take_view(e, f)}}。
&lt;!----&gt;
所有情况下 {{c/core|decltype((f))}} 必须实现 {{c|std::convertible_to&lt;D&gt;}}。

当底层视图 {{tt|V}} 实现概念 {{lconcept|contiguous_range}}、{{lconcept|random_access_range}}、{{lconcept|bidirectional_range}}、{{lconcept|forward_range}}、{{lconcept|input_range}} 及 {{lconcept|sized_range}} 时，{{c|take_view}} 实现相应的概念。当底层视图 {{tt|V}} 同时实现 {{lconcept|sized_range}} 和 {{lconcept|random_access_range}} 时，它实现 {{lconcept|common_range}}。

===数据成员===
{{dsc begin}}
{{dsc hitem|成员|说明}}
{{dsc expos mem obj|base_|id=base|spec={{tt|V}}|底层视图}}
{{dsc expos mem obj|count_|id=count|spec={{c/core|ranges::range_difference_t&lt;V&gt;}}|要取得的元素数量}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/ranges/adaptor/dsc constructor|take_view}}
{{dsc inc|cpp/ranges/adaptor/dsc base|take_view}}
{{dsc inc|cpp/ranges/adaptor/dsc begin|take_view}}
{{dsc inc|cpp/ranges/adaptor/dsc end|take_view}}
{{dsc inc|cpp/ranges/adaptor/dsc size|take_view}}
{{dsc inc|cpp/ranges/adaptor/dsc reserve_hint|take_view}}

{{cpp/ranges/view_interface/inherit|embedded=yes|size=yes}}
{{dsc end}}

==={{rl|deduction guides|推导指引}}===

===嵌套类===
{{dsc begin}}
{{dsc expos mem tclass|cpp/ranges/take_view/sentinel|notes={{mark c++20}}|哨位类型}}
{{dsc end}}

===辅助模板===
{{ddcl|since=c++20|1=
template&lt; class T &gt;
constexpr bool enable_borrowed_range&lt;std::ranges::take_view&lt;T&gt;&gt; =
    ranges::enable_borrowed_range&lt;T&gt;;
}}
{{lc|ranges::enable_borrowed_range}} 的此特化使得 {{tt|take_view}} 在底层类型实现 {{lconcept|borrowed_range}} 时实现它。

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;

int main()
{
    namespace views = std::views;
    auto print = [](char x){ std::cout &lt;&lt; x; };

    for (const char nums[]{'1', '2', '3'};
         int n : views::iota(0, 5))
    {
        std::cout &lt;&lt; "take(" &lt;&lt; n &lt;&lt; "): ";
        // 安全地只获取至 min(n, nums.size()) 个元素：
        std::ranges::for_each(nums {{!}} views::take(n), print);
        std::cout &lt;&lt; '\n';
    }
}
|output=
take(0): 
take(1): 1
take(2): 12
take(3): 123
take(4): 123
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3407|std=C++20|before={{tt|views::take}} 有时无法构造具大小随机访问范围|after=调整结果类型使构造始终合法}}
{{dr list item|wg=lwg|dr=3494|std=c++20|before={{tt|take_view}} 决不是 {{tt|borrowed_range}}|after=在底层视图是 {{tt|borrowed_range}} 的情况下是}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc view_counted}}
{{dsc inc|cpp/ranges/dsc take_while_view}}
{{dsc inc|cpp/algorithm/ranges/dsc copy_n}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}