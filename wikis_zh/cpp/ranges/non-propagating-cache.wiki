{{title|非传播缓存 {{mark c++20}}}}
{{cpp/ranges/navbar}}

{{dcl begin}}
{{dcl|since=c++20|notes={{mark expos}}|
template&lt; class T &gt;
    requires std::is_object_v&lt;T&gt;
class /*non-propagating-cache*/;
}}
{{dcl end}}

如 {{l2tt|cpp/ranges/join_view}} 和 {{l2tt|cpp/ranges/lazy_split_view}} 等一些范围适配器会有条件地存储值（比如一个迭代器），这是基于仅用于阐述的类模板 {{tti|non-propagating-cache}} 指定的。

此包装器的行为与 {{c/core|std::optional&lt;T&gt;}} 非常相似，但：
* 它不会在复制构造或被赋值时从来源复制值，
* 当被移动走时它会重置来源的值，
* 当从之赋值时它会重置其值，并且
* 它还提供了一个成员函数模板，以使得在迭代输入视图时可以临时缓存其中的值。

这个包装器封装了包含一个值的缓存。清除缓存的操作等价于重置所含值。当复制或移动包装器时会进行这种操作。

===模板形参===
{{par begin}}
{{par|T|所含值的类型，必须是对象类型}}
{{par end}}

===成员函数===
{{member|复制和移动构造函数|
{{dcl begin}}
{{dcl|num=1|since=c++20|
constexpr /*non-propagating-cache*/
    ( const /*non-propagating-cache*/&amp; ) noexcept {}
}}
{{dcl|num=2|since=c++20|
constexpr /*non-propagating-cache*/
    ( /*non-propagating-cache*/&amp;&amp; other ) noexcept { other.reset(); }
}}
{{dcl end}}

@1@ 复制构造函数没有效果。
@2@ 移动构造函数会清除 {{c|other}} 的缓存。
}}

{{member|复制和移动赋值运算符|
{{dcl begin}}
{{dcl|num=1|since=c++20|1=
constexpr /*non-propagating-cache*/&amp;
    operator=( const /*non-propagating-cache*/&amp; other ) noexcept
{ 
    if (std::addressof(other) != this)
        reset();
    return *this;
}
}}
{{dcl|num=2|since=c++20|1=
constexpr /*non-propagating-cache*/&amp;
    operator=( /*non-propagating-cache*/&amp;&amp; other ) noexcept
{
    reset();
    other.reset();
    return *this;
}
}}
{{dcl end}}

@1@ 复制赋值运算符会清除 {{c|*this}} 的缓存。
@2@ 移动赋值运算符会同时清除 {{c|*this}} 和 {{c|other}} 的缓存。
}}

{{member|{{tt|{{small|''non-propagating-cache''&lt;T&gt;::}}''emplace-deref''}}|
{{dcl begin}}
{{dcl|since=c++20|notes={{mark expos}}|1=
template&lt; class I &gt;
constexpr T&amp; /*emplace-deref*/( const I&amp; i );
}}
{{dcl end}}

用[[cpp/language/direct initialization|直接初始化]]（但非直接列表初始化）以 {{c|*i}} 初始化所含值。调用前如果 {{c|*this}} 已经含有值，那么就会调用 {{c|reset()}}。

返回到新所含值的引用。

除非对某个虚构变量 {{c|t}} 的声明 {{c|T t(*i);}} 良构，否则程序非良构。如果 {{c|*i}} 是可能 cv 限定的 {{tt|T}} 类型的纯右值，那么它不必是可移动的。
}}

{{identical|{{small|std::}}optional|
2=&lt;!--
===嵌套类型===
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc|{{tt|value_type}}|{{tt|T}}}}
{{dsc end}}
--&gt;
===成员函数===
{{dsc begin}}
{{dsc inc|cpp/utility/optional/dsc constructor}}
{{dsc inc|cpp/utility/optional/dsc destructor}}
{{dsc inc|cpp/utility/optional/dsc operator{{=}}}}

{{dsc h2|观察器}}
{{dsc inc|cpp/utility/optional/dsc operator*}}
{{dsc inc|cpp/utility/optional/dsc operator bool}}
&lt;!--{{dsc inc|cpp/utility/optional/dsc value}}
{{dsc inc|cpp/utility/optional/dsc value_or}}--&gt;

{{dsc h2|修改器}}
&lt;!--{{dsc inc|cpp/utility/optional/dsc swap}}--&gt;
{{dsc inc|cpp/utility/optional/dsc reset}}
{{dsc inc|cpp/utility/optional/dsc emplace}}
{{dsc end}}
}}

===注解===
{{tti|non-propagating-cache}} 在实现中用于缓存 {{c|begin()}} 的结果，以提供均摊常量时间复杂度的方法。

===参阅===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc join_view}}
{{dsc inc|cpp/ranges/dsc join_with_view}}
{{dsc inc|cpp/ranges/dsc split_view}}
{{dsc inc|cpp/ranges/dsc lazy_split_view}}
{{dsc inc|cpp/ranges/dsc chunk_view}}
{{dsc end}}

{{langlinks|ar|cs|de|en|es|fr|it|ja|ko|pl|pt|ru|tr}}