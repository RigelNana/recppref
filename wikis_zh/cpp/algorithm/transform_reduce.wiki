{{cpp/title|transform_reduce}}
{{cpp/algorithm/numeric/navbar}}
{{dcl begin}}
{{dcl header|numeric}}
{{dcl|num=1|since=c++17|notes={{mark constexpr since c++20}}|
template&lt; class InputIt1, class InputIt2, class T &gt;
T transform_reduce( InputIt1 first1, InputIt1 last1,
                    InputIt2 first2, T init );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2, class T &gt;
T transform_reduce( ExecutionPolicy&amp;&amp; policy,
                    ForwardIt1 first1, ForwardIt1 last1,
                    ForwardIt2 first2, T init );
}}
{{dcl|num=3|since=c++17|notes={{mark constexpr since c++20}}|
template&lt; class InputIt1, class InputIt2, class T,
          class BinaryOp1, class BinaryOp2 &gt;
T transform_reduce( InputIt1 first1, InputIt1 last1,
                    InputIt2 first2, T init,
                    BinaryOp1 reduce, BinaryOp2 transform );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2, class T,
          class BinaryOp1, class BinaryOp2 &gt;
T transform_reduce( ExecutionPolicy&amp;&amp; policy,
                    ForwardIt1 first1, ForwardIt1 last1,
                    ForwardIt2 first2, T init,
                    BinaryOp1 reduce, BinaryOp2 transform );
}}
{{dcl|num=5|since=c++17|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class T,
          class BinaryOp, class UnaryOp &gt;
T transform_reduce( InputIt first, InputIt last, T init,
                    BinaryOp reduce, UnaryOp transform );
}}
{{dcl|num=6|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt, class T,
          class BinaryOp, class UnaryOp &gt;
T transform_reduce( ExecutionPolicy&amp;&amp; policy,
                    ForwardIt first, ForwardIt last, T init,
                    BinaryOp reduce, UnaryOp transform );
}}
{{dcl end}}

@1@ 等价于 {{c multi|transform_reduce(first1, last1, first2, init,|                 std::plus&lt;&gt;(), std::multiplies&lt;&gt;())}}，实际上是默认的 {{lc|std::inner_product}} 的等效并行版本。

@3@ 应用 {{c|transform}} 到来自范围 {{range|first1|last1}} 和从 {{c|first2}} 开始的包含 {{c|std::distance(first1, last1)}} 个元素的范围的每对元素，并在 {{c|reduce}} 上与初始值 {{c|init}} 一同规约各结果（可以以未指定行为重排聚合）。
@@ 如果 {{c|reduce}} 不可结合或不可交换（例如浮点加法），那么结果不确定。
@@ 如果以下任何值不可转换到 {{tt|T}}，那么程序非良构：
* {{c|reduce(init, init)}}
* {{c|reduce(init, transform(*first1, *first2))}}
* {{c|reduce(transform(*first1, *first2), init)}}
* {{c|reduce(transform(*first1, *first2), transform(*first1, *first2))}}
@@ 给定 {{c|last2}} 为 {{c|first2}} 的下 {{c|std::distance(first1, last1)}} 个迭代器，如果满足以下任意条件，那么行为未定义：
* {{tt|T}} 不{{named req|MoveConstructible}}.
* {{c|transform}} 或 {{c|reduce}} 会修改 {{range|first1|last1}} 或 {{range|first2|last2}} 的元素。
* {{c|transform}} 或 {{c|reduce}} 会使 {{closed range|first1|last1}} 或 {{closed range|first2|last2}} 中的迭代器或子范围失效。

@5@ 应用 {{c|transform}} 到范围 {{range|first|last}} 中的每个元素，并在 {{c|reduce}} 上与初始值 {{c|init}} 一同规约各结果（可以以未指定行为重排聚合）。
@@ 如果 {{c|reduce}} 不可结合或不可交换（例如浮点加法），那么结果不确定。
@@ 如果以下任何值不可转换到 {{tt|T}}，那么程序非良构：
* {{c|reduce(init, init)}}
* {{c|reduce(init, transform(*first))}}
* {{c|reduce(transform(*first), init)}}
* {{c|reduce(transform(*first), transform(*first))}}
@@ 如果满足以下任意条件，那么行为未定义：
* {{tt|T}} 不{{named req|MoveConstructible}}。
* {{c|transform}} 或 {{c|reduce}} 会修改 {{range|first|last}} 的元素。
* {{c|transform}} 或 {{c|reduce}} 会使 {{closed range|first|last}} 中的迭代器或子范围失效。

@2,4,6@ 同 {{v|1,3,5}}，但按照 {{c|policy}} 执行。
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

===参数===
{{par begin}}
{{par range|first1|last1|要作为 {{c|transform}} 的左操作数的}}
{{par|first2|包含要作为 {{c|transform}} 的右操作数的元素的范围开头}}
{{par range|3=要作为 {{c|transform}} 的单一操作数的}}
{{par|init|广义和的初始值}}
{{par exec pol}}
{{par|reduce|二元{{named req|FunctionObject}}，将以未指定顺序应用于 {{c|transform}} 的结果，其他 {{c|reduce}} 的结果和 {{c|init}} 之上。}}
{{par|transform|一元或二元{{named req|FunctionObject}}，将应用于输入范围的每个元素。其返回类型必须可由 {{c|reduce}} 接受为其输入。}}
{{par hreq}}
{{par req named|InputIt1, InputIt2, InputIt|InputIterator}}
{{par req named|ForwardIt1, ForwardIt2, ForwardIt|ForwardIterator}}
{{par end}}

===返回值===
@1,2@ {{c|init}} 和 {{c|values}} 在 {{c|std::plus&lt;&gt;()}} 上的广义和，其中 {{c|values}} 是通过 {{c|std::multiplies&lt;&gt;()}} 变换得到的一组值，每个值从两个输入范围中的一对元素变换而来。

@3,4@ {{c|init}} 和 {{c|values}} 在 {{c|reduce}} 上的广义和，其中 {{c|values}} 是通过 {{c|transform}} 变换得到的一组值，每个值从两个输入范围中的一对元素变换而来。

@5,6@ {{c|init}} 和 {{c|values}} 在 {{c|reduce}} 上的广义和，其中 {{c|values}} 是通过 {{c|transform}} 变换得到的一组值，每个值从输入范围中的一个元素变换而来。

一组元素在二元运算 {{c|binary_op}} 上的''广义和''{{sep}}定义如下：
* 如果元素组只有一个元素，那么和就是该元素的值。
* 否则，依次进行以下操作：
# 从元素组中取走两个元素 {{c|elem1}} 和 {{c|elem2}}。
# 计算 {{c|binary_op(elem1, elem2)}}，并将结果放回元素组。
# 重复以上两步，直到组里只剩一个元素。

===复杂度===
给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first1, last1)}}（对于重载 {{v|5,6}} 是 {{c|std::distance(first, last)}}）：

@1,2@ 分别应用 {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} 次 {{c|std::plus&lt;&gt;()}} 和 {{c|std::multiplies&lt;&gt;()}}。

@3-6@ 分别应用 {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} 次 {{c|reduce}} 和 {{c|transform}}。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior}}

===注解===
不会对 {{c|init}} 应用 {{c|transform}}。

如果 {{c|1=first == last}} 或 {{c|1=first1 == last1}}，那么返回未经修改的 {{c|init}}。

===示例===
{{example|{{tt|transform_reduce}} 能用于并行化 {{lc|std::inner_product}}。某些系统可能需要额外的支持以获得并行执行的优势。例如在 GNU/Linux 上 安装 {{enwiki|Threading Building Blocks|Intel TBB}} 并对 gcc/clang 编译器提供 {{c|-ltbb}} 选项。
|code=
#if PARALLEL
#include &lt;execution&gt;
#define PAR std::execution::par,
#else
#define PAR
#endif

#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;locale&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

// 为使不可接合的累加运算并行化，应当选择
// transform_reduce 而非 reduce；例如，a + b * b != b + a * a
void print_sum_squared(long const num)
{
    std::cout.imbue(std::locale{"en_US.UTF8"});
    std::cout &lt;&lt; "num = " &lt;&lt; num &lt;&lt; '\n';
    
    // 创建不可修改 vector 并按模式填充: 1,2,3,4, 1,2,3,4 ...
    const std::vector&lt;long&gt; v{[n = num * 4] {
        std::vector&lt;long&gt; v;
        v.reserve(n);
        std::generate_n(std::back_inserter(v), n,
            [i = 0]() mutable { return 1 + i++ % 4; });
        return v;
    }()};
    
    auto squared_sum = [](auto sum, auto val) { return sum + val * val; };
    
    auto sum1 = std::accumulate(v.cbegin(), v.cend(), 0L, squared_sum);
    std::cout &lt;&lt; "accumulate()：" &lt;&lt; sum1 &lt;&lt; '\n';
    
    auto sum2 = std::reduce(PAR v.cbegin(), v.cend(), 0L, squared_sum);
    std::cout &lt;&lt; "reduce()：" &lt;&lt; sum2 &lt;&lt; '\n';
    
    auto sum3 = std::transform_reduce(PAR v.cbegin(), v.cend(), 0L, std::plus{},
                                      [](auto val) { return val * val; });
    std::cout &lt;&lt; "transform_reduce()：" &lt;&lt; sum3 &lt;&lt; "\n\n";
}

int main()
{
    print_sum_squared(1);
    print_sum_squared(1'000);
    print_sum_squared(1'000'000);
}
|p=true
|output=
num = 1
accumulate()：30
reduce()：30
transform_reduce()：30

num = 1,000
accumulate()：30,000
reduce()：-7,025,681,278,312,630,348
transform_reduce()：30,000

num = 1,000,000
accumulate()：30,000,000
reduce()：-5,314,886,882,370,003,032
transform_reduce()：30,000,000

// 并行执行于 POSIX 之上的编译器选项:
// g++ -O2 -std=c++17 -Wall -Wextra -pedantic -DPARALLEL ./example.cpp -ltbb -o tr; ./tr
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc accumulate}}
{{dsc inc|cpp/algorithm/dsc transform}}
{{dsc inc|cpp/algorithm/dsc reduce}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}