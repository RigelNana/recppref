{{cpp/title|merge}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcla|num=1|notes={{mark constexpr since c++20}}|
template&lt; class InputIt1, class InputIt2, class OutputIt &gt;
OutputIt merge( InputIt1 first1, InputIt1 last1,
                InputIt2 first2, InputIt2 last2,
                OutputIt d_first );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2, class ForwardIt3 &gt;
ForwardIt3 merge( ExecutionPolicy&amp;&amp; policy,
                  ForwardIt1 first1, ForwardIt1 last1,
                  ForwardIt2 first2, ForwardIt2 last2,
                  ForwardIt3 d_first );
}}
{{dcla|num=3|notes={{mark constexpr since c++20}}|
template&lt; class InputIt1, class InputIt2,
          class OutputIt, class Compare &gt;
OutputIt merge( InputIt1 first1, InputIt1 last1,
                InputIt2 first2, InputIt2 last2,
                OutputIt d_first, Compare comp );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2,
          class ForwardIt3, class Compare &gt;
ForwardIt3 merge( ExecutionPolicy&amp;&amp; policy,
                  ForwardIt1 first1, ForwardIt1 last1,
                  ForwardIt2 first2, ForwardIt2 last2,
                  ForwardIt3 d_first, Compare comp );
}}
{{dcl end}}

将两个有序范围 {{range|first1|last1}} 和 {{range|first2|last2}} 合并到始于 {{c|d_first}} 的一个有序范围中。

@1@ 如果 {{range|first1|last1}} 或 {{range|first2|last2}} 没有按 {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}} {{rlp|/#要求|排序}}，那么行为未定义。

@3@ 如果 {{range|first1|last1}} 或 {{range|first2|last2}} 没有按 {{c|comp}} 排序，那么行为未定义。

@2,4@ 同 {{v|1,3}}，但按照 {{c|policy}} 执行。
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

此合并函数是稳定的，意思是对于两个原范围中的等价元素，来自第一范围的元素（保持原来的顺序）先于来自第二范围的元素（保持原来的顺序）。

如果输出范围与 {{range|first1|last1}} 或 {{range|first2|last2}} 重叠，那么行为未定义。

===参数===
{{par begin}}
{{par range|first1|last1|3=要合并的|range=第一个}}
{{par range|first2|last2|3=要合并的|range=第二个}}
{{par|d_first|目标范围的起始}}
{{par exec pol}}
{{par cmp ord|comp|p1=InputIt1|p2=InputIt2}}
{{par hreq}}
{{par req named|InputIt1, InputIt2|InputIterator}}
{{par req named|ForwardIt1, ForwardIt2, ForwardIt3|ForwardIterator}}
{{par req named|OutputIt|OutputIterator}}
{{par req named|Compare|Compare}}
{{par end}}

===返回值===
指向最后被复制元素后一元素的迭代器。

===复杂度===
给定 {{mathjax-or|\(\scriptsize N_1\)|N{{su|b=1}}}} 为 {{c|std::distance(first1, last1)}}，{{mathjax-or|\(\scriptsize N_2\)|N{{su|b=2}}}} 为 {{c|std::distance(first2, last2)}}：

@1@ 最多应用 {{mathjax-or|\(\scriptsize N_1+N_2-1\)|N{{su|b=1}}+N{{su|b=2}}-1}} 次 {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}} 进行比较。

@2@ 应用 {{mathjax-or|\(\scriptsize O(N_1+N_2)\)|O(N{{su|b=1}}+N{{su|b=2}})}} 次 {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}} 进行比较。

@3@ 最多应用 {{mathjax-or|\(\scriptsize N_1+N_2-1\)|N{{su|b=1}}+N{{su|b=2}}-1}} 次比较函数 {{c|comp}}。

@4@ 应用 {{mathjax-or|\(\scriptsize O(N_1+N_2)\)|O(N{{su|b=1}}+N{{su|b=2}})}} 次比较函数 {{c|comp}}。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===可能的实现===
参阅 [https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L4856 libstdc++] 与 [https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L4348 libc++] 中的实现。
{{eq impl
|title1=merge (1)|ver1=1|1=
template&lt;class InputIt1, class InputIt2, class OutputIt&gt;
OutputIt merge(InputIt1 first1, InputIt1 last1,
               InputIt2 first2, InputIt2 last2,
               OutputIt d_first)
{
    for (; first1 != last1; ++d_first)
    {
        if (first2 == last2)
            return std::copy(first1, last1, d_first);
        
        if (*first2 &lt; *first1)
        {
            *d_first = *first2;
            ++first2;
        }
        else
        {
            *d_first = *first1;
            ++first1;
        }
    }
    return std::copy(first2, last2, d_first);
}
|title2=merge (3)|ver2=3|2=
template&lt;class InputIt1, class InputIt2,
         class OutputIt, class Compare&gt;
OutputIt merge(InputIt1 first1, InputIt1 last1,
               InputIt2 first2, InputIt2 last2,
               OutputIt d_first, Compare comp)
{
    for (; first1 != last1; ++d_first)
    {
        if (first2 == last2)
            return std::copy(first1, last1, d_first);
        
        if (comp(*first2, *first1))
        {
            *d_first = *first2;
            ++first2;
        }
        else
        {
            *d_first = *first1;
            ++first1;
        }
    }
    return std::copy(first2, last2, d_first);
}
}}

===注解===
此算法所做的任务与 {{c|std::set_union}} 类似。它们都消耗两个有序输入范围，并产生拥有来自两个输入的元素的有序输出。此二算法的区别在于如何处理来自两个输入的比较等价（见{{named req|LessThanComparable}}的注解）的值。若任何等价的值在第一范围出现 {{c|n}} 次，在第二范围出现 {{c|m}} 次，则 {{tt|std::merge}} 会输出所有 {{c|n+m}} 次出现，而 {{tt|std::set_union}} 将只输出 {{c|std::max(n, m)}} 次。故 {{tt|std::merge}} 恰好输出 {{c|std::distance(first1, last1) + std::distance(first2, last2)}} 个值，而 {{tt|std::set_union}} 可能产生得更少。

===示例===
{{example
|
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

auto print = [](const auto rem, const auto&amp; v)
{
    std::cout &lt;&lt; rem;
    std::copy(v.begin(), v.end(), std::ostream_iterator&lt;int&gt;(std::cout, " "));
    std::cout &lt;&lt; '\n';
};

int main()
{
    // 以随机数填充 vector
    std::random_device rd;
    std::mt19937 mt(rd());
    std::uniform_int_distribution&lt;&gt; dis(0, 9);
    
    std::vector&lt;int&gt; v1(10), v2(10);
    std::generate(v1.begin(), v1.end(), std::bind(dis, std::ref(mt)));
    std::generate(v2.begin(), v2.end(), std::bind(dis, std::ref(mt)));
    
    print("原来：\nv1：", v1);
    print("v2：", v2);
    
    std::sort(v1.begin(), v1.end());
    std::sort(v2.begin(), v2.end());
    
    print("排序后：\nv1：", v1);
    print("v2：", v2);
    
    // 合并
    std::vector&lt;int&gt; dst;
    std::merge(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(dst));
    
    print("合并后：\ndst：", dst);
}
|p=true
|output=
原来：
v1：2 6 5 7 4 2 2 6 7 0
v2：8 3 2 5 0 1 9 6 5 0
排序后：
v1：0 2 2 2 4 5 6 6 7 7
v2：0 0 1 2 3 5 5 6 8 9
合并后：
dst：0 0 0 1 2 2 2 2 3 4 5 5 5 6 6 6 7 7 8 9
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=780|std=C++98|before=未定义合并运算|after=提供定义}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc inplace_merge}}
{{dsc inc|cpp/algorithm/dsc is_sorted}}
{{dsc inc|cpp/algorithm/dsc set_union}}
{{dsc inc|cpp/algorithm/dsc sort}}
{{dsc inc|cpp/algorithm/dsc stable_sort}}
{{dsc inc|cpp/algorithm/ranges/dsc merge}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}