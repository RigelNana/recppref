{{cpp/title|adjacent_find}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcla|num=1|notes={{mark constexpr since c++20}}|
template&lt; class ForwardIt &gt;
ForwardIt adjacent_find( ForwardIt first, ForwardIt last );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt &gt;
ForwardIt adjacent_find( ExecutionPolicy&amp;&amp; policy,
                         ForwardIt first, ForwardIt last );
}}
{{dcla|num=3|notes={{mark constexpr since c++20}}|
template&lt; class ForwardIt, class BinaryPred &gt;
ForwardIt adjacent_find( ForwardIt first, ForwardIt last, BinaryPred p );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt, class BinaryPred &gt;
ForwardIt adjacent_find( ExecutionPolicy&amp;&amp; policy,
                         ForwardIt first, ForwardIt last, BinaryPred p );
}}
{{dcl end}}

在范围 {{range|first|last}} 中搜索两个连续的相等元素。

@1@ 用 {{c/core|1=operator==}} 比较元素。

@3@ 用给定的二元谓词 {{c|p}} 比较元素。

@2,4@ 同 {{v|1,3}}，但按照 {{c|policy}} 执行。
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

===参数===
{{par begin}}
{{par range|3=要检验的}}
{{par exec pol}}
{{par pred2 eq|p|p1=ForwardIt}}
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req named|BinaryPred|BinaryPredicate}}
{{par end}}

===返回值===
指向首对等同元素的首个元素的迭代器，即首个满足 {{c|1=*it == *(it + 1)}}（版本 {{v|1,2}}）或 {{c|1=p(*it, *(it + 1)) != false}}（版本 {{v|3,4}}）的迭代器 {{c|it}}。

如果找不到这种元素，那么返回 {{c|last}}。

===复杂度===
给定 {{c|result}} 为 {{tt|adjacent_find}} 的返回值，{{mathjax-or|\(\scriptsize M\)|M}} 为 {{c|std::distance(first, result)}}，{{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first, last)}}：
@1@ 应用 {{mathjax-or|\(\scriptsize \min(M+1,N-1)\)|min(M+1,N-1)}} 次 {{c/core|1=operator==}} 进行比较。
@2@ 应用 {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} 次 {{c/core|1=operator==}} 进行比较。
@3@ 应用 {{mathjax-or|\(\scriptsize \min(M+1,N-1)\)|min(M+1,N-1)}} 次谓词 {{c|p}}。
@4@ 应用 {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} 次谓词 {{c|p}}。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===可能的实现===
{{eq impl
|title1=adjacent_find (1)|ver1=1|1=
template&lt;class ForwardIt&gt;
ForwardIt adjacent_find(ForwardIt first, ForwardIt last)
{
    if (first == last)
        return last;
    
    ForwardIt next = first;
    ++next;
    
    for (; next != last; ++next, ++first)
        if (*first == *next)
            return first;
    
    return last;
}
|title2=adjacent_find (3)|ver2=3|2=
template&lt;class ForwardIt, class BinaryPred&gt;
ForwardIt adjacent_find(ForwardIt first, ForwardIt last, BinaryPred p)
{
    if (first == last)
        return last;
    
    ForwardIt next = first;
    ++next;
    
    for (; next != last; ++next, ++first)
        if (p(*first, *next))
            return first;
    
    return last;
}
}}

===示例===
{{example
|
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; v1{0, 1, 2, 3, 40, 40, 41, 41, 5};
    
    auto i1 = std::adjacent_find(v1.begin(), v1.end());
    
    if (i1 == v1.end())
        std::cout &lt;&lt; "没有匹配的相邻元素\n";
    else
        std::cout &lt;&lt; "第一对相等的相邻元素位于 "
                  &lt;&lt; std::distance(v1.begin(), i1) &lt;&lt; "，*i1 = "
                  &lt;&lt; *i1 &lt;&lt; '\n';
    
    auto i2 = std::adjacent_find(v1.begin(), v1.end(), std::greater&lt;int&gt;());
    if (i2 == v1.end())
        std::cout &lt;&lt; "整个 vector 已经是升序的\n";
    else
        std::cout &lt;&lt; "非降序子序列中最后的元素位于 "
                  &lt;&lt; std::distance(v1.begin(), i2) &lt;&lt; "，*i2 = " &lt;&lt; *i2 &lt;&lt; '\n';
}
|output=
第一对相等的相邻元素位于 4，*i1 = 40
非降序子序列中最后的元素位于 7，*i2 = 41
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=240|std=C++98|before={{v|1,3}} 中谓词会应用 {{c|std::find(first, last,}}&lt;br&gt;{{c|value) - first}} 次，但 {{c|value}} 没有定义|after=应用 {{c|std::min((result - first)}}&lt;br&gt;{{c|+ 1, (last - first) - 1)}} 次}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc unique}}
{{dsc inc|cpp/algorithm/ranges/dsc adjacent_find}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}