{{cpp/title|partition_point}}
{{cpp/algorithm/navbar}}
{{ddcl|header=algorithm|since=c++11|notes={{mark constexpr since c++20}}|
template&lt; class ForwardIt, class UnaryPred &gt;
ForwardIt partition_point( ForwardIt first, ForwardIt last, UnaryPred p );
}}

检验（如同用 {{lc|std::partition}}）已划分范围 {{range|first|last}}，并定位第一分段的结尾，即首个不满足 {{c|p}} 的元素，或者在所有元素满足 {{c|p}} 时是 {{c|last}}。

如果 {{range|first|last}} 的元素 {{c|elem}} 没有按表达式 {{c|bool(p(elem))}} {{rlp|/#要求|划分}}，那么行为未定义。

===参数===
{{par begin}}
{{par range|3=要检查的|range=已划分}}
{{par pred1|p|对于在范围起始找到的元素|p1=ForwardIt}}
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req named|UnaryPred|Predicate}}
{{par end}}

===返回值===
{{range|first|last}} 内第一分段结尾后的迭代器。

===复杂度===
给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first, last)}}，应用 {{mathjax-or|\(\scriptsize O(log(N))\)|O(log(N))}} 次谓词 {{c|p}}。

===注解===
此算法是 {{lc|std::lower_bound}} 的更通用化的形式，它可以表达为以 {{c|[&amp;](const auto&amp; e) { return e &lt; value; });}} 为谓词调用 {{tt|std::partition_point}}。

===可能的实现===
{{eq fun|1=
template&lt;class ForwardIt, class UnaryPred&gt;
constexpr //&lt; C++20 起
ForwardIt partition_point(ForwardIt first, ForwardIt last, UnaryPred p)
{
    for (auto length = std::distance(first, last); 0 &lt; length; )
    {
        auto half = length / 2;
        auto middle = std::next(first, half);
        if (p(*middle))
        {
            first = std::next(middle);
            length -= (half + 1);
        }
        else
            length = half;
    }
    
    return first;
}
}}

===示例===
{{example
|
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

auto print_seq = [](auto rem, auto first, auto last)
{
    for (std::cout &lt;&lt; rem; first != last; std::cout &lt;&lt; *first++ &lt;&lt; ' ') {}
    std::cout &lt;&lt; '\n';
};

int main()
{
    std::array v{1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    auto is_even = [](int i) { return i % 2 == 0; };
    
    std::partition(v.begin(), v.end(), is_even);
    print_seq("划分后，v：", v.cbegin(), v.cend());
    
    const auto pp = std::partition_point(v.cbegin(), v.cend(), is_even);
    const auto i = std::distance(v.cbegin(), pp);
    std::cout &lt;&lt; "划分点在 " &lt;&lt; i &lt;&lt; "；v[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; *pp &lt;&lt; '\n';
    
    print_seq("第一分段（所有偶数元素）：", v.cbegin(), pp);
    print_seq("第二分段（所有奇数元素）：", pp, v.cend());
}
|p=true
|output=
划分后，v：8 2 6 4 5 3 7 1 9
划分点在 4；v[4] = 5
第一分段（所有偶数元素）：8 2 6 4
第二分段（所有奇数元素）：5 3 7 1 9
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc find}}
{{dsc inc|cpp/algorithm/dsc is_sorted}}
{{dsc inc|cpp/algorithm/dsc lower_bound}}
{{dsc inc|cpp/algorithm/ranges/dsc partition_point}}
{{dsc end}}
{{langlinks|de|en|es|fr|it|ja|pt|ru}}