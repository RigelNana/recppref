{{cpp/title|find_first_of}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcla|num=1|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class ForwardIt &gt;
InputIt find_first_of( InputIt first, InputIt last,
                       ForwardIt s_first, ForwardIt s_last );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt1, class ForwardIt2 &gt;
ForwardIt1 find_first_of( ExecutionPolicy&amp;&amp; policy,
                          ForwardIt1 first, ForwardIt1 last,
                          ForwardIt2 s_first, ForwardIt2 s_last );
}}
{{dcla|num=3|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class ForwardIt, class BinaryPred &gt;
InputIt find_first_of( InputIt first, InputIt last,
                       ForwardIt s_first, ForwardIt s_last,
                       BinaryPred p );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2, class BinaryPred &gt;
ForwardIt1 find_first_of( ExecutionPolicy&amp;&amp; policy,
                          ForwardIt1 first, ForwardIt last,
                          ForwardIt2 s_first, ForwardIt2 s_last,
                          BinaryPred p );
}}
{{dcl end}}

在范围 {{range|first|last}} 中搜索范围 {{range|s_first|s_last}} 中的任何元素。

@1@ 用 {{c/core|1=operator==}} 比较元素。

@3@ 用给定的二元谓词 {{c|p}} 比较元素。

@2,4@ 同 {{v|1,3}}，但按照 {{c|policy}} 执行。
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

===参数===
{{par begin}}
{{par range|3=要检验的}}
{{par range|s_first|s_last|要搜索的}}
{{par exec pol}}
{{par pred2 eq|p|p1=ForwardIt1|p2=ForwardIt2}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req named|ForwardIt1|ForwardIterator}}
{{par req named|ForwardIt2|ForwardIterator}}
{{par req named|BinaryPredicate|BinaryPredicate}}
{{par end}}

===返回值===
指向范围 {{range|first|last}} 中等于范围 {{range|s_first|s_last}} 中某个元素的首个元素。

如果 {{range|s_first|s_last}} 为空或找不到这种元素，那么就会返回 {{c|last}}。

===复杂度===
给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first, last)}}，{{mathjax-or|\(\scriptsize S\)|S}} 为 {{c|std::distance(s_first, s_last)}}：
@1,2@ 最多应用 {{mathjax-or|\(\scriptsize N\cdot S\)|N·S}} 次 {{c/core|1=operator==}} 进行比较。
@3,4@ 最多应用 {{mathjax-or|\(\scriptsize N\cdot S\)|N·S}} 次谓词 {{c|p}}。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===可能的实现===
{{eq impl
|title1=find_first_of (1)|ver1=1|1=
template&lt;class InputIt, class ForwardIt&gt;
InputIt find_first_of(InputIt first, InputIt last,
                      ForwardIt s_first, ForwardIt s_last)
{
    for (; first != last; ++first)
        for (ForwardIt it = s_first; it != s_last; ++it)
            if (*first == *it)
                return first;
    return last;
}
|title2=find_first_of (3)|ver2=3|2=
template&lt;class InputIt, class ForwardIt, class BinaryPred&gt;
InputIt find_first_of(InputIt first, InputIt last,
                      ForwardIt s_first, ForwardIt s_last,
                      BinaryPred p)
{
    for (; first != last; ++first)
        for (ForwardIt it = s_first; it != s_last; ++it)
            if (p(*first, *it))
                return first;
    return last;
}
}}

===示例===
{{example
|下列代码在包含整数的 vector 中搜索任何一个指定的整数：
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto print_sequence = [](const auto id, const auto&amp; seq, int pos = -1)
{
    std::cout &lt;&lt; id &lt;&lt; "{ ";
    for (int i{}; auto const&amp; e : seq)
    {
        const bool mark{i == pos};
        std::cout &lt;&lt; (i++ ? ", " : "");
        std::cout &lt;&lt; (mark ? "[ " : "") &lt;&lt; e &lt;&lt; (mark ? " ]" : "");
    }
    std::cout &lt;&lt; " }\n";
};

int main()
{
    const std::vector&lt;int&gt; v{0, 2, 3, 25, 5};
    const auto t1 = {19, 10, 3, 4};
    const auto t2 = {1, 6, 7, 9};
    
    auto find_any_of = [](const auto&amp; v, const auto&amp; t)
    {
        const auto result = std::find_first_of(v.begin(), v.end(),
                                               t.begin(), t.end());
        if (result == v.end())
        {
            std::cout &lt;&lt; "v 和 t 中没有相等的元素\n";
            print_sequence("t = ", t);
            print_sequence("v = ", v);
        }
        else
        {
            const auto pos = std::distance(v.begin(), result);
            std::cout &lt;&lt; "在位置 " &lt;&lt; pos &lt;&lt; " 找到匹配 (" &lt;&lt; *result &lt;&lt; ")\n";
            print_sequence(", where t = ", t);
            print_sequence("v = ", v, pos);
        }
    };
    
    find_any_of(v, t1);
    find_any_of(v, t2);
}
|output=
在位置 2 找到匹配 (3)
t = { 19, 10, 3, 4 }
v = { 0, 2, [ 3 ], 25, 5 }
v 和 t 中没有相等的元素
t = { 1, 6, 7, 9 }
v = { 0, 2, 3, 25, 5 }
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=576|std=C++98|before={{c|first}} 和 {{c|last}} 需要是{{named req|ForwardIterator}}|after=只需要是{{named req|InputIterator}}}}
{{dr list item|wg=lwg|dr=1205|std=C++98|before={{range|s_first|s_last}} 为空时返回值不明确|after=此时会返回 {{c|last}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc find}}
{{dsc inc|cpp/algorithm/ranges/dsc find_first_of}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}