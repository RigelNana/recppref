{{cpp/title|stable_sort}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcla|num=1|constexpr=c++26|
template&lt; class RandomIt &gt;
void stable_sort( RandomIt first, RandomIt last );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class RandomIt &gt;
void stable_sort( ExecutionPolicy&amp;&amp; policy,
                  RandomIt first, RandomIt last );
}}
{{dcla|num=3|constexpr=c++26|
template&lt; class RandomIt, class Compare &gt;
void stable_sort( RandomIt first, RandomIt last, Compare comp );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy, class RandomIt, class Compare &gt;
void stable_sort( ExecutionPolicy&amp;&amp; policy,
                  RandomIt first, RandomIt last, Compare comp );
}}
{{dcl end}}

以非降序排序范围 {{range|first|last}} 中的元素。保证保持等价元素间的顺序。

@1@ 按 {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}} 进行{{rlp|/#要求|排序}}。

@3@ 按 {{c|comp}} 进行排序。

@2,4@ 同 {{v|1,3}}，但按照 {{c|policy}} 执行。
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

如果满足以下任意条件，那么行为未定义：
{{rev begin}}
{{rev|until=c++11|
* {{c|*first}} 的类型不{{named req|Swappable}}。
}}
{{rev|since=c++11|
* {{tt|RandomIt}} 不{{named req|ValueSwappable}}。
* {{c|*first}} 的类型不{{named req|MoveConstructible}}。
* {{c|*first}} 的类型不{{named req|MoveAssignable}}。
}}
{{rev end}}

===参数===
{{par begin}}
{{par range|3=要排序的}}
{{par exec pol}}
{{par cmp ord|comp|p1=RandomIt}} 
{{par hreq}}
{{par req named|RandomIt|RandomAccessIterator}}
{{par req named|Compare|Compare}}
{{par end}}

===复杂度===
给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|last - first}}：
@1,2@ 在额外内存足够时应用 {{mathjax-or|\(\scriptsize O(N \cdot \log(N))\)|O(N·log(N))}} 次 {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}} 进行比较，否则应用 {{mathjax-or|\(\scriptsize O(N \cdot \log^{2}(N))\)|O(N·log{{su|p=2}}(N))}} 次。
@3,4@ 在额外内存足够时应用 {{mathjax-or|\(\scriptsize O(N \cdot \log(N))\)|O(N·log(N))}} 次比较函数 {{c|comp}}，否则应用 {{mathjax-or|\(\scriptsize O(N \cdot \log^{2}(N))\)|O(N·log{{su|p=2}}(N))}} 次。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===可能的实现===
参阅 [https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L4977 libstdc++] 与 [https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L4696 libc++] 中的实现。

===注解===
此函数试图分配等于待排序序列长度的临时缓冲区。如果分配失败，那么就会选择较低效的算法。

{{feature test macro|__cpp_lib_constexpr_algorithms|{{c/core|constexpr}} 的稳定排序，重载 {{vl|1}}, {{vl|3}}|value=202306L|std=C++26}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

struct Employee
{
    int age;
    std::string name; // 不参与比较
};

bool operator&lt;(const Employee&amp; lhs, const Employee&amp; rhs)
{
    return lhs.age &lt; rhs.age;
}

#if __cpp_lib_constexpr_algorithms &gt;= 202306L
consteval auto get_sorted()
{
    auto v = std::array{3, 1, 4, 1, 5, 9};
    std::stable_sort(v.begin(), v.end());
    return v;
}
static_assert(std::ranges::is_sorted(get_sorted()));
#endif

int main()
{
    std::vector&lt;Employee&gt; v{&lt;!----&gt;{108, "Zaphod"}, {32, "Arthur"}, {108, "Ford"}&lt;!----&gt;};

    std::stable_sort(v.begin(), v.end());

    for (const Employee&amp; e : v)
        std::cout &lt;&lt; e.age &lt;&lt; ", " &lt;&lt; e.name &lt;&lt; '\n';
}
|output=
32, Arthur
108, Zaphod
108, Ford
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc partial_sort}}
{{dsc inc|cpp/algorithm/dsc sort}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}