{{cpp/title|reduce}}
{{cpp/algorithm/numeric/navbar}}
{{dcl begin}}
{{dcl header|numeric}}
{{dcl|num=1|since=c++17|notes={{mark constexpr since c++20}}|
template&lt; class InputIt &gt;
typename std::iterator_traits&lt;InputIt&gt;::value_type
    reduce( InputIt first, InputIt last );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt &gt;
typename std::iterator_traits&lt;ForwardIt&gt;::value_type
    reduce( ExecutionPolicy&amp;&amp; policy,
            ForwardIt first, ForwardIt last );
}}
{{dcl|num=3|since=c++17|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class T &gt;
T reduce( InputIt first, InputIt last, T init );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt, class T &gt;
T reduce( ExecutionPolicy&amp;&amp; policy,
          ForwardIt first, ForwardIt last, T init );
}}
{{dcl|num=5|since=c++17|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class T, class BinaryOp &gt;
T reduce( InputIt first, InputIt last, T init, BinaryOp op );
}}
{{dcl|num=6|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt, class T, class BinaryOp &gt;
T reduce( ExecutionPolicy&amp;&amp; policy,
          ForwardIt first, ForwardIt last, T init, BinaryOp op );
}}
{{dcl end}}

@1@ 等价于 {{c|reduce(first, last, typename std::iterator_traits&lt;InputIt&gt;::value_type{})}}。

@3@ 等价于 {{c|reduce(first, last, init, std::plus&lt;&gt;())}}。

@5@ 在 {{c|op}} 上以初值 {{c|init}} 对范围 {{range|first|last}} 进行规约，可能以未指定方式进行排列和聚合。

@2,4,6@ 同 {{v|1,3,5}}，但按照 {{c|policy}} 执行。
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

给定 {{c|binary_op}} 为实际的二元运算：

* 如果 {{c|binary_op}} 不可结合或不可交换（例如浮点加法），那么结果不确定。

* 如果以下任何值不可转换到 {{tt|T}}，那么程序非良构：
:* {{c|binary_op(init, *first)}}
:* {{c|binary_op(*first, init)}}
:* {{c|binary_op(init, init)}}
:* {{c|binary_op(*first, *first)}}

* 如果满足以下任意条件，那么行为未定义：
:* {{tt|T}} 不{{named req|MoveConstructible}}。
:* {{c|binary_op}} 会修改 {{range|first|last}} 的元素。
:* {{c|binary_op}} 会使 {{closed range|first|last}} 中的迭代器或子范围失效。

===参数===
{{par begin}}
{{par range|3=要应用算法的}}
{{par|init|广义和的初值}}
{{par exec pol}}
{{par|op|将以未指定顺序应用于输入迭代器的解引用结果、其他 {{c|binary_op}} 的结果及 {{c|init}} 上的二元{{named req|FunctionObject}}。}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|ForwardIt|ForwardIterator}}
{{par end}}

===返回值===
@1-4@ {{c|init}} 和 {{range|first|last}} 的元素在 {{c|std::plus&lt;&gt;()}} 上的广义和。

@5,6@ {{c|init}} 和 {{range|first|last}} 的元素在 {{c|op}} 上的广义和。

一组元素在二元运算 {{c|binary_op}} 上的''广义和''{{sep}}定义如下：
* 如果元素组只有一个元素，那么和就是该元素的值。
* 否则，依次进行以下操作：
# 从元素组中取走两个元素 {{c|elem1}} 和 {{c|elem2}}。
# 计算 {{c|binary_op(elem1, elem2)}}，并将结果放回元素组。
# 重复以上两步，直到组里只剩一个元素。

===复杂度===
给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first, last)}}：

@1-4@ 应用 {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} 次 {{c|std::plus&lt;&gt;()}}。

@5,6@ 应用 {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} 次 {{c|op}}。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior}}

===注解===
{{tt|std::reduce}} 表现类似 {{lc|std::accumulate}}，但范围中的元素可能以任意顺序分组并重排。

===示例===
{{example
|{{tt|std::reduce}} 与 {{lc|std::accumulate}} 间并行的比较：
|code=
#if PARALLEL
#include &lt;execution&gt;
#define SEQ std::execution::seq,
#define PAR std::execution::par,
#else
#define SEQ
#define PAR
#endif

#include &lt;chrono&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

int main()
{
    std::cout.imbue(std::locale("en_US.UTF-8"));
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);
    
    auto eval = [](auto fun)
    {
        const auto t1 = std::chrono::high_resolution_clock::now();
        const auto [name, result] = fun();
        const auto t2 = std::chrono::high_resolution_clock::now();
        const std::chrono::duration&lt;double, std::milli&gt; ms = t2 - t1;
        std::cout &lt;&lt; std::setw(28) &lt;&lt; std::left &lt;&lt; name &lt;&lt; "和："
                  &lt;&lt; result &lt;&lt; '\t' &lt;&lt; "时间：" &lt;&lt; ms.count() &lt;&lt; " 毫秒\n";
    };
    
    {
        const std::vector&lt;double&gt; v(100'000'007, 0.1);
        
        eval([&amp;v]{ return std::pair{"std::accumulate (double)",
            std::accumulate(v.cbegin(), v.cend(), 0.0)}; });
        eval([&amp;v]{ return std::pair{"std::reduce (seq, double)",
            std::reduce(SEQ v.cbegin(), v.cend())}; });
        eval([&amp;v]{ return std::pair{"std::reduce (par, double)",
            std::reduce(PAR v.cbegin(), v.cend())}; });
    }
    
    {
        const std::vector&lt;long&gt; v(100'000'007, 1);
        
        eval([&amp;v]{ return std::pair{"std::accumulate (long)",
            std::accumulate(v.cbegin(), v.cend(), 0l)}; });
        eval([&amp;v]{ return std::pair{"std::reduce (seq, long)",
            std::reduce(SEQ v.cbegin(), v.cend())}; });
        eval([&amp;v]{ return std::pair{"std::reduce (par, long)",
            std::reduce(PAR v.cbegin(), v.cend())}; });
    }
}
|p=true
|output=
// POSIX：g++ -std=c++23 ./example.cpp -ltbb -O3; ./a.out
std::accumulate (double)    和：10,000,000.7	时间：356.9 毫秒
std::reduce (seq, double)   和：10,000,000.7	时间：140.1 毫秒
std::reduce (par, double)   和：10,000,000.7	时间：140.1 毫秒
std::accumulate (long)      和：100,000,007	时间：46.0 毫秒
std::reduce (seq, long)     和：100,000,007	时间：67.3 毫秒
std::reduce (par, long)     和：100,000,007	时间：63.3 毫秒

// POSIX：g++ -std=c++23 ./example.cpp -ltbb -O3 -DPARALLEL; ./a.out
std::accumulate (double)    和：10,000,000.7	时间：353.4 毫秒
std::reduce (seq, double)   和：10,000,000.7	时间：140.7 毫秒
std::reduce (par, double)   和：10,000,000.7	时间：24.7 毫秒
std::accumulate (long)      和：100,000,007	时间：42.4 毫秒
std::reduce (seq, long)     和：100,000,007	时间：52.0 毫秒
std::reduce (par, long)     和：100,000,007	时间：23.1 毫秒
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc accumulate}}
{{dsc inc|cpp/algorithm/dsc transform}}
{{dsc inc|cpp/algorithm/dsc transform_reduce}}
{{dsc inc|cpp/algorithm/ranges/dsc fold_left}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}