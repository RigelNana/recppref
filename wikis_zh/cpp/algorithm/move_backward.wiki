{{cpp/title|move_backward}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcla|anchor=no|since=c++11|constexpr=c++20|
template&lt; class BidirIt1, class BidirIt2 &gt;
BidirIt2 move_backward( BidirIt1 first, BidirIt1 last, BidirIt2 d_last );
}}
{{dcl end}}

移动来自范围 {{range|first|last}} 的元素到在 {{c|d_last}} 结束的另一范围。以逆序移动元素（首先复制末元素），但保持它们的相对顺序。

如果 {{c|d_last}} 在范围 {{range|first|last|left=(|right=]}} 内，那么行为未定义。此时可以改用 {{rlpt|move|std::move}}。

===参数===
{{par begin}}
{{par range|3=要移动的|range=源}}
{{par|d_last|目标范围结尾}}
{{par hreq}}
{{par req named|BidirIt1, BidirIt2|BidirectionalIterator}}
{{par end}}

===返回值===
目标范围中的迭代器，指向最后移动的元素。

===复杂度===
移动赋值 {{c|std::distance(first, last)}} 次。

===可能的实现===
{{eq fun|1=
template&lt;class BidirIt1, class BidirIt2&gt;
BidirIt2 move_backward(BidirIt1 first, BidirIt1 last, BidirIt2 d_last)
{
    while (first != last)
        *(--d_last) = std::move(*(--last));
    
    return d_last;
}
}}

===注解===
移动重叠的范围时，{{rlpt|move|std::move}} 适合向左移动（目标范围的起始在源范围外）时，而 {{tt|std::move_backward}} 适合向右移动（目标范围的结尾在源范围外）时。

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

using container = std::vector&lt;std::string&gt;;

void print(std::string_view comment, const container&amp; src, const container&amp; dst = {})
{
    auto prn = [](std::string_view name, const container&amp; cont)
    {
        std::cout &lt;&lt; name;
        for (const auto &amp;s : cont)
            std::cout &lt;&lt; (s.empty() ? "∙" : s.data()) &lt;&lt; ' ';
        std::cout &lt;&lt; '\n';
    };
    std::cout &lt;&lt; comment &lt;&lt; '\n';
    prn("src: ", src);
    if (dst.empty())
        return;
    prn("dst: ", dst);
}

int main()
{
    container src{"foo", "bar", "baz"};
    container dst{"qux", "quux", "quuz", "corge"};
    print("无重叠的情况；move_backward 之前：", src, dst);
    std::move_backward(src.begin(), src.end(), dst.end());
    print("之后：", src, dst);
    
    src = {"snap", "crackle", "pop", "lock", "drop"};
    print("有重叠的情况；move_backward 之前：", src);
    std::move_backward(src.begin(), std::next(src.begin(), 3), src.end());
    print("之后：", src);
}
|output=
无重叠的情况；move_backward 之前：
src: foo bar baz
dst: qux quux quuz corge
之后：
src: ∙ ∙ ∙
dst: qux foo bar baz
有重叠的情况；move_backward 之前：
src: snap crackle pop lock drop
之后：
src: ∙ ∙ snap crackle pop
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc move}}
{{dsc inc|cpp/algorithm/ranges/dsc move_backward}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}