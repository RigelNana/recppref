{{cpp/title|is_permutation}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|num=1|since=c++11|notes={{mark constexpr since c++20}}|
template&lt; class ForwardIt1, class ForwardIt2 &gt;
bool is_permutation( ForwardIt1 first1, ForwardIt1 last1,
                     ForwardIt2 first2 );
}}
{{dcl|num=2|since=c++11|notes={{mark constexpr since c++20}}|
template&lt; class ForwardIt1, class ForwardIt2,
          class BinaryPredicate &gt;
bool is_permutation( ForwardIt1 first1, ForwardIt1 last1,
                     ForwardIt2 first2, BinaryPredicate p );
}}
{{dcl|num=3|since=c++14|notes={{mark constexpr since c++20}}|
template&lt; class ForwardIt1, class ForwardIt2 &gt;
bool is_permutation( ForwardIt1 first1, ForwardIt1 last1,
                     ForwardIt2 first2, ForwardIt2 last2 );
}}
{{dcl|num=4|since=c++14|notes={{mark constexpr since c++20}}|
template&lt; class ForwardIt1, class ForwardIt2,
          class BinaryPredicate &gt;
bool is_permutation( ForwardIt1 first1, ForwardIt1 last1,
                     ForwardIt2 first2, ForwardIt2 last2,
                     BinaryPredicate p );
}}
{{dcl end}}

检查 {{range|first1|last1}} 是否为 {{c|first2}} 开始的另一个范围的{{enwiki|permutation|排列}}：
* 对于重载 {{v|1,2}}，第二个范围包含 {{c|std::distance(first1, last1)}} 个元素。
* 对于重载 {{v|3,4}}，第二个范围是 {{range|first2|last2}}。

@1,3@ 用 {{c/core|1=operator==}} 比较元素。

@2,4@ 用给定的二元谓词 {{c|p}} 比较元素。

如果 {{tt|ForwardIt1}} 和 {{tt|ForwardIt2}} 的[[cpp/iterator#类型与可写性|值类型]]不同，那么程序非良构。

如果比较函数不是{{enwiki|equivalence relation|等价关系}}，那么行为未定义。

===参数===
{{par begin}}
{{par range|first1|last1|range=第一个|要比较的}}
{{par range|first2|last2|range=第二个|要比较的}}
{{par pred2 eq|p|p1=InputIt1|p2=InputIt2}}
{{par hreq}}
{{par req named|ForwardIt1, ForwardIt2|ForwardIterator}}
{{par end}}

===返回值===
在范围 {{range|first1|last1}} 是 {{range|first2|last2}} 的排列时返回 {{c|true}}，否则返回 {{c|false}}。

===复杂度===
给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first1, last1)}}：

@1@ 在两个范围相等时应用 {{mathjax-or|\(\scriptsize N\)|N}} 次 {{c/core|1=operator==}} 进行比较，否则在最差情况下应用 {{mathjax-or|\(\scriptsize O(N^2)\)|O(N{{su|p=2}})}} 次。

@2@ 在两个范围相等时应用 {{mathjax-or|\(\scriptsize N\)|N}} 次谓词 {{c|p}}，否则在最差情况下应用 {{mathjax-or|\(\scriptsize O(N^2)\)|O(N{{su|p=2}})}} 次。

@3,4@ 如果 {{tt|InputIt1}} 和 {{tt|InputIt2}} 都是{{named req|RandomAccessIterator}}，并且 {{c|1=last1 - first1 != last2 - first2}} 是 {{c|true}}，那么不会进行任何比较。
@@ 否则：

:@3@ 在两个范围相等时应用 {{mathjax-or|\(\scriptsize N\)|N}} 次 {{c/core|1=operator==}} 进行比较，否则在最差情况下应用 {{mathjax-or|\(\scriptsize O(N^2)\)|O(N{{su|p=2}})}} 次。

:@4@ 在两个范围相等时应用 {{mathjax-or|\(\scriptsize N\)|N}} 次谓词 {{c|p}}，否则在最差情况下应用 {{mathjax-or|\(\scriptsize O(N^2)\)|O(N{{su|p=2}})}} 次。

===可能的实现===
{{eq fun|1=
template&lt;class ForwardIt1, class ForwardIt2&gt;
bool is_permutation(ForwardIt1 first, ForwardIt1 last,
                    ForwardIt2 d_first)
{
   // 跳过公共前缀
   std::tie(first, d_first) = std::mismatch(first, last, d_first);
    
   // 在 rest 上迭代，计数 [d_first, d_last) 中出现多少次
   // 每个来自 [first, last) 的元素
    if (first != last)
    {
        ForwardIt2 d_last = std::next(d_first, std::distance(first, last));
        for (ForwardIt1 i = first; i != last; ++i)
        {
            if (i != std::find(first, i, *i))
                continue; // 已经遇到此 *i
            
            auto m = std::count(d_first, d_last, *i);
            if (m == 0 {{!!}} std::count(i, last, *i) != m)
                return false;
        }
    }
    return true;
}
}}

===注解===
{{tt|std::is_permutation}} 能用于按照其名称地''测试''{{sep}}重排算法（例如排序、打乱、划分）的正确性。若 {{tt|x}} 为原范围而 {{tt|y}} 是''重排后''{{sep}}范围，则 {{c|1=std::is_permutation(x, y) == true}} 表示 {{tt|y}} 由可能位于其他位置的''“相同”''{{sep}}元素组成。

===示例===
{{example
|
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

template&lt;typename Os, typename V&gt;
Os&amp; operator&lt;&lt;(Os&amp; os, const V&amp; v)
{
    os &lt;&lt; "{ ";
    for (const auto&amp; e : v)
        os &lt;&lt; e &lt;&lt; ' ';
    return os &lt;&lt; '}';
}

int main()
{
    static constexpr auto v1 = {1, 2, 3, 4, 5};
    static constexpr auto v2 = {3, 5, 4, 1, 2};
    static constexpr auto v3 = {3, 5, 4, 1, 1};
    
    std::cout &lt;&lt; v2 &lt;&lt; " 是 " &lt;&lt; v1 &lt;&lt; " 的排列：" &lt;&lt; std::boolalpha
              &lt;&lt; std::is_permutation(v1.begin(), v1.end(), v2.begin()) &lt;&lt; '\n'
              &lt;&lt; v3 &lt;&lt; " 是 " &lt;&lt; v1 &lt;&lt; " 的排列：" &lt;&lt; std::boolalpha
              &lt;&lt; std::is_permutation(v1.begin(), v1.end(), v3.begin()) &lt;&lt; '\n';
}
|output=
{ 3 5 4 1 2 } 是 { 1 2 3 4 5 } 的排列：true
{ 3 5 4 1 1 } 是 { 1 2 3 4 5 } 的排列：false
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc next_permutation}}
{{dsc inc|cpp/algorithm/dsc prev_permutation}}
{{dsc inc|cpp/concepts/dsc equivalence_relation}}
{{dsc inc|cpp/algorithm/ranges/dsc is_permutation}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}