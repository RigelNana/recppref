{{cpp/title|search_n}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl rev begin|num=1}}
{{dcla|anchor=版本_1|constexpr=c++20|until=c++26|
template&lt; class ForwardIt, class Size, class T &gt;
ForwardIt search_n( ForwardIt first, ForwardIt last,
                    Size count, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class ForwardIt, class Size,
          class T = typename std::iterator_traits
                        &lt;ForwardIt&gt;::value_type &gt;
constexpr ForwardIt search_n( ForwardIt first, ForwardIt last,
                              Size count, const T&amp; value );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++17|until=c++26|
template&lt; class ExecutionPolicy,
          class ForwardIt, class Size, class T &gt;
ForwardIt search_n( ExecutionPolicy&amp;&amp; policy,
                    ForwardIt first, ForwardIt last,
                    Size count, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class ExecutionPolicy,
          class ForwardIt, class Size,
          class T = typename std::iterator_traits
                        &lt;ForwardIt&gt;::value_type &gt;
ForwardIt search_n( ExecutionPolicy&amp;&amp; policy,
                    ForwardIt first, ForwardIt last,
                    Size count, const T&amp; value );
}}
{{dcl rev end}}
{{dcl rev begin|num=3}}
{{dcla|anchor=版本_3|constexpr=c++20|until=c++26|
template&lt; class ForwardIt, class Size, class T, class BinaryPred &gt;
ForwardIt search_n( ForwardIt first, ForwardIt last,
                    Size count, const T&amp; value, BinaryPred p );
}}
{{dcl|since=c++26|1=
template&lt; class ForwardIt, class Size,
          class T = typename std::iterator_traits
                        &lt;ForwardIt&gt;::value_type,
          class BinaryPred &gt;
constexpr ForwardIt search_n( ForwardIt first, ForwardIt last,
                    Size count, const T&amp; value, BinaryPred p );
}}
{{dcl rev end}}
{{dcl rev begin|num=4}}
{{dcl|since=c++17|until=c++26|
template&lt; class ExecutionPolicy, class ForwardIt, class Size,
          class T, class BinaryPred &gt;
ForwardIt search_n( ExecutionPolicy&amp;&amp; policy,
                    ForwardIt first, ForwardIt last,
                    Size count, const T&amp; value, BinaryPred p );
}}
{{dcl|since=c++26|1=
template&lt; class ExecutionPolicy, class ForwardIt, class Size,
          class T = typename std::iterator_traits
                        &lt;ForwardIt&gt;::value_type,
          class BinaryPred &gt;
ForwardIt search_n( ExecutionPolicy&amp;&amp; policy,
                    ForwardIt first, ForwardIt last,
                    Size count, const T&amp; value, BinaryPred p );
}}
{{dcl rev end}}
{{dcl end}}

在范围 {{range|first|last}} 中搜索 {{c|count}} 个等同元素的序列，每个都等于给定的值 {{c|value}}。

@1@ 用 {{c/core|1=operator==}} 比较元素。

@3@ 用给定的二元谓词 {{c|p}} 比较元素。

@2,4@ 同 {{v|1,3}}，但按照 {{c|policy}} 执行。
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

===参数===
{{par begin}}
{{par range|3=要检验的}}
{{par|count|要搜索的序列长度}}
{{par|value|要搜索的元素值}}
{{par exec pol}}
{{par pred2 eq|p|p1=ForwardIt|t2=T}}
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req named|BinaryPred|BinaryPredicate}}
{{par req|{{tt|Size}} 必须可[[cpp/language/implicit cast|转换]]到[[cpp/language/type|整数类型]]。}}
{{par end}}

===返回值===
如果 {{c|count}} 为正，那么返回指向范围 {{range|first|last}} 中找到的序列起始的迭代器。序列中的每个迭代器 {{c|it}} 都要满足以下条件：
@1,2@ {{c|1=*it == value}} 是 {{c|true}}。
@3,4@ {{c|1=p(*it, value) != false}} 是 {{c|true}}。

找不到这种序列的情况下返回 {{c|last}}。

如果 {{c|count}} 为零或负，那么返回 {{c|first}}。

===复杂度===
给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first, last)}}：
@1,2@ 应用最多 {{mathjax-or|\(\scriptsize N\)|N}} 次 {{c/core|1=operator==}} 进行比较。
@3,4@ 应用最多 {{mathjax-or|\(\scriptsize N\)|N}} 次谓词 {{c|p}}。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===可能的实现===
{{eq impl
|title1=search_n (1)|ver1=1|1=
template&lt;class ForwardIt, class Size,
         class T = typename std::iterator_traits&lt;ForwardIt&gt;::value_type&gt;
ForwardIt search_n(ForwardIt first, ForwardIt last, Size count, const T&amp; value)
{
    if (count &lt;= 0)
        return first;
    
    for (; first != last; ++first)
    {
        if (!(*first == value))
            continue;
        
        ForwardIt candidate = first;
        
        for (Size cur_count = 1; true; ++cur_count)
        {
            if (cur_count &gt;= count)
                return candidate; // 成功
            
            ++first;
            if (first == last)
                return last; // 穷尽列表
            
            if (!(*first == value))
                break; // 栏中过少
        }
    }
    return last;
}
|title2=search_n (3)|ver2=3|2=
template&lt;class ForwardIt, class Size,
         class T = typename std::iterator_traits&lt;ForwardIt&gt;::value_type,
         class BinaryPred&gt;
ForwardIt search_n(ForwardIt first, ForwardIt last, Size count, const T&amp; value,
                   BinaryPred p)
{
    if (count &lt;= 0)
        return first;
    
    for (; first != last; ++first)
    {
        if (!p(*first, value))
            continue;
        
        ForwardIt candidate = first;
        
        for (Size cur_count = 1; true; ++cur_count)
        {
            if (cur_count &gt;= count)
                return candidate; // 成功
            
            ++first;
            if (first == last)
                return last; // 穷尽列表
            
            if (!p(*first, value))
                break; // 栏中过少
        }
    }
    return last;
}
}}

===注解===
{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|算法中的[[cpp/language/list initialization|列表初始化]] {{vl|1-4}}}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

template&lt;class Container, class Size, class T&gt;
constexpr bool consecutive_values(const Container&amp; c, Size count, const T&amp; v)
{
    return std::search_n(std::begin(c), std::end(c), count, v) != std::end(c);
}

int main()
{
    constexpr char sequence[] = ".0_0.000.0_0.";
    
    static_assert(consecutive_values(sequence, 3, '0'));
    
    for (int n : {4, 3, 2})
        std::cout &lt;&lt; std::boolalpha
                  &lt;&lt; "有 " &lt;&lt; n &lt;&lt; " 个连续的零："
                  &lt;&lt; consecutive_values(sequence, n, '0') &lt;&lt; '\n';

    std::vector&lt;std::complex&lt;double&gt;&gt; nums{&lt;!----&gt;{4, 2}, {4, 2}, {1, 3}&lt;!----&gt;};
    #ifdef __cpp_lib_algorithm_default_value_type
        auto it = std::search_n(nums.cbegin(), nums.cend(), 2, {4, 2});
    #else
        auto it = std::search_n(nums.cbegin(), nums.cend(), 2, std::complex&lt;double&gt;{4, 2});
    #endif
    assert(it == nums.begin());
}
|output=
有 4 个连续的零：false
有 3 个连续的零：true
有 2 个连续的零：true
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=283|std=C++98|before={{tt|T}} 需要是 {{named req|EqualityComparable}} 的，但是 {{tt|InputIt}} 的值类型不一定是 {{tt|T}}|after=移除该要求}}
{{dr list item|wg=lwg|dr=426|std=C++98|before=复杂度上限是 {{tt|N&amp;middot;count}}，它在 {{c|count}} 为负时也为负|after=在 {{c|count}} 非正时上限是 {{c|0}}}}
{{dr list item|wg=lwg|dr=714|std=C++98|before=复杂度上限在 {{c|count &gt; 0}} 时是 {{tt|N&amp;middot;count}}，但最差情况下也只会进行 {{tt|N}} 次比较/操作|after=将这种情况下的上限改成 {{tt|N}}}}
{{dr list item|wg=lwg|dr=2150|std=C++98|before=“出现序列”的条件不正确|after=已改正}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc find_end}}
{{dsc inc|cpp/algorithm/dsc find}}
{{dsc inc|cpp/algorithm/dsc search}}
{{dsc inc|cpp/algorithm/ranges/dsc search_n}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}