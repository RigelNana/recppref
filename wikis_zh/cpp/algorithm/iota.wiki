{{cpp/title|iota}}
{{cpp/algorithm/numeric/navbar}}
{{ddcl|header=numeric|since=c++11|notes={{mark constexpr since c++20}}|
template&lt; class ForwardIt, class T &gt;
void iota( ForwardIt first, ForwardIt last, T value );
}}

以始于 {{c|value}} 并重复地求值 {{c|++value}} 的顺序递增值填充范围 {{range|first|last}}。

等价操作（假设 {{c|++value}} 会返回自增后的值）：
{{source|1=
*first   = value;
*++first = ++value;
*++first = ++value;
*++first = ++value;
// 抵达 “last” 前重复
}}

如果满足以下任意条件，那么程序非良构：
* {{tt|T}} 不可转换到 {{tt|ForwardIt}} 的[[cpp/iterator#类型与可写性|值类型]]。
* 表达式 {{c|++val}} 非良构，其中 {{c|val}} 是 {{tt|T}} 类型变量。

===参数===
{{par begin}}
{{par range|3=要以 {{c|value}} 开始按顺序递增的值所填充的}}
{{par|value|要存储的初始值}}
{{par end}}

===复杂度===
自增与赋值 {{c|std::distance(first, last)}} 次。

===可能的实现===
{{eq fun
|1=
template&lt;class ForwardIt, class T&gt;
constexpr // C++20 起
void iota(ForwardIt first, ForwardIt last, T value)
{
    for (; first != last; ++first, ++value)
        *first = value;
}
}}

===注解===
此函数命名来源于编程语言 {{enwiki|APL (programming language)|APL}} 中的整数函数 &lt;span style="font-size: 1.5em"&gt;⍳&lt;/span&gt; &lt;!-- U+2373 APL 函数符号 IOTA --&gt;。它是 C++98 所不曾包含的 [http://www.sgi.com/tech/stl/iota.html STL 组件]之一，但最终在 C++11 进入了标准库。

===示例===
{{example
|下列代码应用 {{lc|std::shuffle}} 到 {{lc|std::list}} 的迭代器组成的 {{lc|std::vector|vector}}，因为不能直接应用 {{lc|std::shuffle}} 到 {{lc|std::list}}。用 {{tt|std::iota}} 填充两个容器。
|code=
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;numeric&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

class BigData // 复制操作低效
{
    int data[1024]; /* 一些原始数据 */
public:
    explicit BigData(int i = 0) { data[0] = i; /* ... */ }
    operator int() const { return data[0]; }
    BigData&amp; operator=(int i) { data[0] = i; return *this; }
    /* ... */
};

int main()
{
    std::list&lt;BigData&gt; l(10);
    std::iota(l.begin(), l.end(), -4);
    
    std::vector&lt;std::list&lt;BigData&gt;::iterator&gt; v(l.size());
    std::iota(v.begin(), v.end(), l.begin());
    // 用（指向原数据的）迭代器的向量来避免昂贵复制操作，
    // 也是因为无法直接对 std::list 应用 std::shuffle（见下）
    
    std::shuffle(v.begin(), v.end(), std::mt19937{std::random_device{}()});
    
    std::cout &lt;&lt; "list l 原来的内容：\t\t";
    for (const auto&amp; n : l)
        std::cout &lt;&lt; std::setw(2) &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
    
    std::cout &lt;&lt; "通过打乱的 v 看到的 l 的内容：\t";
    for (const auto i : v)
        std::cout &lt;&lt; std::setw(2) &lt;&lt; *i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|p=true
|output=
list l 原来的内容：		-4 -3 -2 -1  0  1  2  3  4  5
通过打乱的 v 看到的 l 的内容：	-1  5 -4  0  2  1  4 -2  3 -3
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc iota}}
{{dsc inc|cpp/algorithm/dsc fill}}
{{dsc inc|cpp/algorithm/ranges/dsc fill}}
{{dsc inc|cpp/algorithm/dsc generate}}
{{dsc inc|cpp/algorithm/ranges/dsc generate}}
{{dsc inc|cpp/ranges/dsc iota_view}}
{{dsc inc|cpp/ranges/dsc enumerate_view}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}