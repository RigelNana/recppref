{{cpp/title|copy_backward}}
{{cpp/algorithm/navbar}}
{{ddcl|header=algorithm|notes={{mark constexpr since c++20}}|
template&lt; class BidirIt1, class BidirIt2 &gt;
BidirIt2 copy_backward( BidirIt1 first, BidirIt1 last, BidirIt2 d_last );
}}

将范围 {{range|first|last}} 内的元素复制到终于 {{c|d_last}} 的范围。以逆序复制元素（首先复制末元素），但保持相对顺序。

如果 {{c|d_last}} 在 {{range|first|last|left=(|right=]}} 中，那么行为未定义。此时必须用 {{lc|std::copy}} 取代 {{tt|std::copy_backward}}。

===参数===
{{par begin}}
{{par range|3=要复制的|range=源}}
{{par|d_last|目标范围的结尾}}
{{par hreq}}
{{par req named|BidirIt|BidirectionalIterator}}
{{par end}}

===返回值===
指向最后复制元素的迭代器。

===复杂度===
赋值 {{c|std::distance(first, last)}} 次。

===注意===
复制重叠的范围时，在复制到左侧（目标范围的起始在源范围外）的情况下适合使用 {{lc|std::copy}}，而在复制到右侧（目标范围的结尾在源范围外）的情况下适合使用 {{tt|std::copy_backward}}。

===可能的实现===
{{eq fun|1=
template&lt;class BidirIt1, class BidirIt2&gt;
BidirIt2 copy_backward(BidirIt1 first, BidirIt1 last, BidirIt2 d_last)
{
    while (first != last)
        *(--d_last) = *(--last);
    return d_last;
}
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; source(4);
    std::iota(source.begin(), source.end(), 1); // 填充 1, 2, 3, 4
    
    std::vector&lt;int&gt; destination(6);
    
    std::copy_backward(source.begin(), source.end(), destination.end());
    
    std::cout &lt;&lt; "destination 包含：";
    for (auto i: destination)
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
destination 包含：0 0 1 2 3 4
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=1206|std=C++98|before=1. {{c|1=d_last == last}} 时行为有良好定义&lt;br&gt;2. {{c|1=d_last == first}} 时行为未定义|after=1. 此时行为未定义&lt;br&gt;2. 此时行为有良好定义}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc copy}}
{{dsc inc|cpp/algorithm/ranges/dsc copy_backward}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}