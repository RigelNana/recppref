{{cpp/title|is_partitioned}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|num=1|since=c++11|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class UnaryPred &gt;
bool is_partitioned( InputIt first, InputIt last, UnaryPred p );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt, class UnaryPred &gt;
bool is_partitioned( ExecutionPolicy&amp;&amp; policy,
                     ForwardIt first, ForwardIt last, UnaryPred p );
}}
{{dcl end}}

@1@ 检查范围 {{range|first|last}} 是否已按谓词 {{c|p}} 划分：所有满足 {{c|p}} 的元素都会在所有不满足的元素之前出现。

@2@ 同 {{v|1}}，但按照 {{c|policy}} 执行。
@@ {{cpp/algorithm/parallel overload precondition}}

===参数===
{{par begin}}
{{par range|3=要检验的}}
{{par exec pol}}
{{par pred1|p|若期待在范围开始找到该元素| p1=InputIt}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|ForwardIt|ForwardIterator|notes=并且它的值类型必须可转换到 {{tt|UnaryPred}} 的形参类型。}}
{{par req named|UnaryPred|Predicate}}
{{par end}}

===返回值===
在范围 {{range|first|last}} 的元素 {{c|e}} 已按表达式 {{c|p(e)}} 划分时返回 {{c|true}}。否则返回 {{c|false}}。

===复杂度===
最多应用 {{c|std::distance(first, last)}} 次 {{c|p}}。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=yes}}

===可能的实现===
{{eq fun | 1=
template&lt;class InputIt, class UnaryPred&gt;
bool is_partitioned(InputIt first, InputIt last, UnaryPred p)
{
    for (; first != last; ++first)
        if (!p(*first))
            break;
    for (; first != last; ++first)
        if (p(*first))
            return false;
    return true;
}
}}

===示例===
{{example
|
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;iostream&gt;

int main()
{
    std::array&lt;int, 9&gt; v{1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    auto is_even = [](int i) { return i % 2 == 0; };
    std::cout.setf(std::ios_base::boolalpha);
    std::cout &lt;&lt; std::is_partitioned(v.begin(), v.end(), is_even) &lt;&lt; ' ';
    
    std::partition(v.begin(), v.end(), is_even);
    std::cout &lt;&lt; std::is_partitioned(v.begin(), v.end(), is_even) &lt;&lt; ' ';
    
    std::reverse(v.begin(), v.end());
    std::cout &lt;&lt; std::is_partitioned(v.cbegin(), v.cend(), is_even) &lt;&lt; ' ';
    std::cout &lt;&lt; std::is_partitioned(v.crbegin(), v.crend(), is_even) &lt;&lt; '\n';
}
|output=
false true false true
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc partition}}
{{dsc inc|cpp/algorithm/dsc partition_point}}
{{dsc inc|cpp/algorithm/ranges/dsc is_partitioned}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}