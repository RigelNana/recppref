{{cpp/title|fill_n}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl rev begin|num=1}}
{{dcla|anchor=版本_1|constexpr=c++20|until=c++26|
template&lt; class OutputIt, class Size, class T &gt;
OutputIt fill_n( OutputIt first, Size count, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class OutputIt, class Size,
          class T = typename std::iterator_traits
                        &lt;OutputIt&gt;::value_type &gt;
constexpr OutputIt fill_n( OutputIt first, Size count,
                           const T&amp; value );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++17|until=c++26|
template&lt; class ExecutionPolicy,
          class ForwardIt, class Size, class T &gt;
ForwardIt fill_n( ExecutionPolicy&amp;&amp; policy,
                  ForwardIt first, Size count, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class ExecutionPolicy,
          class ForwardIt, class Size,
          class T = typename std::iterator_traits
                        &lt;OutputIt&gt;::value_type &gt;
ForwardIt fill_n( ExecutionPolicy&amp;&amp; policy,
                  ForwardIt first, Size count, const T&amp; value );
}}
{{dcl rev end}}
{{dcl end}}

@1@ 如果 {{c|count &gt; 0}}，则将给定的 {{c|value}} 赋给从 {{c|first}} 开始的范围的前 {{c|count}} 个元素。否则什么也不做。

@2@ 同 {{v|1}}，但按照 {{c|policy}} 执行。
@@ {{cpp/algorithm/parallel overload precondition}}

如果满足以下任意条件，那么程序非良构：
* {{c|value}} 不[[cpp/iterator#类型与可写性|可写入]] {{c|first}}。
* {{tt|Size}} 不可[[cpp/language/implicit cast|转换]]到[[cpp/language/type|整数类型]]。

===参数===
{{par begin}}
{{par|first|要修改的元素范围起始}}
{{par|count|要修改的元素数}}
{{par|value|要赋的值}}
{{par exec pol}}
{{par hreq}}
{{par req named|OutputIt|OutputIterator}}
{{par req named|ForwardIt|ForwardIterator}}
{{par end}}

===返回值===
{{c|count &gt; 0}} 时返回指向最后赋值元素后一位置的迭代器，否则返回 {{c|first}}。

===复杂度===
赋值 {{c|std::max(0, count)}} 次。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=yes}}

===可能的实现===
{{eq impl|ver1=1|title1=fill_n|1=
template&lt;class OutputIt, class Size,
         class T = typename std::iterator_traits&lt;OutputIt&gt;::value_type&gt;
OutputIt fill_n(OutputIt first, Size count, const T&amp; value)
{
    for (Size i = 0; i &lt; count; i++)
        *first++ = value;
    return first;
}
}}

===注解===
{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|算法中的[[cpp/language/list initialization|列表初始化]] {{vl|1,2}}}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; v1{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    // 将前 5 个元素的值替换为 -1
    std::fill_n(v1.begin(), 5, -1);

    std::copy_n(v1.cbegin(), v1.size(), std::ostream_iterator&lt;int&gt;(std::cout, " "));
    std::cout &lt;&lt; '\n';

    std::vector&lt;std::complex&lt;double&gt;&gt; nums{&lt;!----&gt;{1, 3}, {2, 2}, {4, 8}&lt;!----&gt;};
    #ifdef __cpp_lib_algorithm_default_value_type
        std::fill_n(nums.begin(), 2, {4, 2});
    #else
        std::fill_n(nums.begin(), 2, std::complex&lt;double&gt;{4, 2});
    #endif
    std::copy_n(nums.cbegin(), nums.size(),
                std::ostream_iterator&lt;std::complex&lt;double&gt;&gt;(std::cout, " "));
    std::cout &lt;&lt; '\n';
}
|output=
-1 -1 -1 -1 -1 5 6 7 8 9
(4,2) (4,2) (4,8)
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=283|std=C++98|before={{tt|T}} 需要是{{named req|CopyAssignable}}的，但是 {{tt|T}} 不一定可写入 {{tt|OutputIt}}|after=改成要求可写入}}
{{dr list item|wg=lwg|dr=426|std=C++98|before=复杂度要求是“正好赋值 {{c|count}} 次”，该要求在 {{c|count}} 为负时无法满足|after=在 {{c|count}} 非正时不会赋值}}
{{dr list item|wg=lwg|dr=865|std=C++98|before=没有返回填充范围后的首个元素的位置|after=返回该位置}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc fill}}
{{dsc inc|cpp/algorithm/ranges/dsc fill_n}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}