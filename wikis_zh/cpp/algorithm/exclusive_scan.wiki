{{cpp/title|exclusive_scan}}
{{cpp/algorithm/numeric/navbar}}
{{dcl begin}}
{{dcl header|numeric}}
{{dcl|num=1|since=c++17|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class OutputIt, class T &gt;
OutputIt exclusive_scan( InputIt first, InputIt last,
                         OutputIt d_first, T init );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2, class T &gt;
ForwardIt2 exclusive_scan( ExecutionPolicy&amp;&amp; policy,
                           ForwardIt1 first, ForwardIt1 last,
                           ForwardIt2 d_first, T init );
}}
{{dcl|num=3|since=c++17|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class OutputIt,
          class T, class BinaryOp &gt;
OutputIt exclusive_scan( InputIt first, InputIt last,
                         OutputIt d_first, T init, BinaryOp op );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2,
          class T, class BinaryOp &gt;
ForwardIt2 exclusive_scan( ExecutionPolicy&amp;&amp; policy,
                           ForwardIt1 first, ForwardIt1 last,
                           ForwardIt2 d_first, T init, BinaryOp op );
}}
{{dcl end}}

@1@ 等价于 {{c|exclusive_scan(first, last, d_first, init, std::plus&lt;&gt;()}}。

@3@ 用 {{c|op}} 计算排除性前缀和。
@@ 对于 {{range|0|std::distance(first, last)}} 中的所有整数 {{c|i}}，按顺序进行以下操作：
# 创建一个序列，它以 {{c|init}} 开始，然后按顺序后随 {{range|first|iter}} 中的所有元素，其中 {{c|iter}} 是 {{c|first}} 的下 {{c|i}} 个迭代器。
# 计算该序列在 {{c|op}} 下的广义非交换和。
# 将计算结果赋给 {{c|*dest}}，其中 {{c|dest}} 是 {{c|d_first}} 的下 {{c|i}} 个迭代器。

@2,4@ 同 {{v|1,3}}，但按照 {{c|policy}} 执行。
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

一个元素序列在二元运算 {{c|binary_op}} 上的''广义非交换和''{{sep}}定义如下：
* 如果序列只有一个元素，那么和就是该元素的值。
* 否则，依次进行以下操作：
# 从序列中选择两个相邻元素 {{c|elem1}} 和 {{c|elem2}}。
# 计算 {{c|binary_op(elem1, elem2)}}，并将序列中的这两个元素替换成计算结果。
# 重复以上两步，直到组里只剩一个元素。


给定 {{c|binary_op}} 为实际的二元运算：

* 如果 {{c|binary_op}} 不可结合（例如浮点加法），那么结果不确定。

* 如果以下任何值不可转换到 {{tt|T}}，那么程序非良构：
:* {{c|binary_op(init, *first)}}
:* {{c|binary_op(init, init)}}
:* {{c|binary_op(*first, *first)}}

* 如果满足以下任意条件，那么行为未定义：
:* {{tt|T}} 不{{named req|MoveConstructible}}。
:* {{c|binary_op}} 会修改 {{range|first|last}} 的元素。
:* {{c|binary_op}} 会使 {{closed range|first|last}} 中的迭代器或子范围失效。

===参数===
{{par begin}}
{{par range|3=要求和的}}
{{par|d_first|目标范围的起始；可以等于 {{c|first}}}}
{{par exec pol}}
{{par|init|初始值}}
{{par|op|二元{{named req|FunctionObject}}，将应用到各输入迭代器的解引用结果、其他 {{c|op}} 的结果和 {{c|init}} 之上。}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|OutputIt|OutputIterator}}
{{par req named|ForwardIt1, ForwardIt2|ForwardIterator}}
{{par end}}

===返回值===
指向最后写入元素的后一元素的迭代器。

===复杂度===
给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first, last)}}：

@1,2@ 应用 {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} 次 {{c|std::plus&lt;&gt;()}}。

@3,4@ 应用 {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} 次 {{c|op}}。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===示例===
{{cpp/algorithm/scan example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc adjacent_difference}}
{{dsc inc|cpp/algorithm/dsc accumulate}}
{{dsc inc|cpp/algorithm/dsc partial_sum}}
{{dsc inc|cpp/algorithm/dsc transform_exclusive_scan}}
{{dsc inc|cpp/algorithm/dsc inclusive_scan}}
{{dsc end}}

{{langlinks|en|es|ja}}