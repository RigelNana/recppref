{{cpp/title|reverse_copy}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|num=1|notes={{mark constexpr since c++20}}|
template&lt; class BidirIt, class OutputIt &gt;
OutputIt reverse_copy( BidirIt first, BidirIt last,
                       OutputIt d_first );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class BidirIt, class ForwardIt &gt;
ForwardIt reverse_copy( ExecutionPolicy&amp;&amp; policy,
                        BidirIt first, BidirIt last,
                        ForwardIt d_first );
}}
{{dcl end}}

@1@ 给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first, last)}}。将范围 {{range|first|last}}（源范围）中的元素复制到从 {{c|d_first}} 开始的包含 {{mathjax-or|\(\scriptsize N\)|N}} 个元素的新范围（目标范围），使得目标范围中元素以逆序排列。

@@ 表现如同通过对 {{range|0|N}} 中的每个整数 {{c|i}} 执行一次赋值 {{c|1=*(d_first + N - 1 - i) = *(first + i)}}&lt;ref name="plusminus"&gt;{{named req|OutputIterator}} 不需要支持二元 {{tt|+}} 和 {{tt|-}}。这里使用 {{tt|+}} 和 {{tt|-}} 仅用于阐述：实际运算不需要用到它们。&lt;/ref&gt;。

@@ 如果源范围与目标范围有重叠，那么行为未定义。

@2@ 同 {{v|1}}，但按照 {{c|policy}} 执行。{{cpp/algorithm/parallel overload precondition}}

===参数===
{{par begin}}
{{par range|3=要复制的|range=源}}
{{par|d_first|新范围的起始}}
{{par hreq}}
{{par req named|BidirIt|BidirectionalIterator}}
{{par req named|OutputIt|OutputIterator}}
{{par req named|ForwardIt|ForwardIterator}}
{{par end}}

===返回值===
指向最后被复制元素后一元素的迭代器。

===复杂度===
赋值 {{mathjax-or|\(\scriptsize N\)|N}} 次。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=yes}}

===可能的实现===
参阅 [https://github.com/gcc-mirror/gcc/blob/14d8a5ae472ca5743016f37da2dd4770d83dea21/libstdc%2B%2B-v3/include/bits/stl_algo.h#L1170-L1190 libstdc++]、[https://github.com/llvm/llvm-project/tree/134723edd5bf06ff6ec8aca7b87c56e5bd70ccae/libcxx/include/__algorithm/reverse_copy.h libc++] 和 [https://github.com/microsoft/STL/blob/472161105d596192194d4715ccad307c6c163b4a/stl/inc/algorithm#L4184-L4229 MSVC STL] 中的实现。
{{eq fun|1=
template&lt;class BidirIt, class OutputIt&gt;
constexpr // C++20 起
OutputIt reverse_copy(BidirIt first, BidirIt last, OutputIt d_first)
{
    for (; first != last; ++d_first)
        *d_first = *(--last);
    return d_first;
}
}}

===注解===
实现（例如 [https://github.com/microsoft/STL/blob/main/stl/src/vector_algorithms.cpp MSVC STL]）可能在两个迭代器类型均满足{{named req|ContiguousIterator}}并拥有同一值类型，且值类型{{named req|TriviallyCopyable}}时启用向量化。

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
 
int main()
{
    auto print = [](const std::vector&lt;int&gt;&amp; v)
    {
        for (const auto&amp; value : v)
            std::cout &lt;&lt; value &lt;&lt; ' ';
        std::cout &lt;&lt; '\n';
    };
    
    std::vector&lt;int&gt; v{1, 2, 3};
    print(v);
    
    std::vector&lt;int&gt; destination(3);
    std::reverse_copy(std::begin(v), std::end(v), std::begin(destination));
    print(destination);
    
    std::reverse_copy(std::rbegin(v), std::rend(v), std::begin(destination));
    print(destination);
}
|output=
1 2 3 
3 2 1 
1 2 3 
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2074|std=C++98|before=对于每个 {{c|i}}，赋值操作是&lt;br&gt;{{c|1=*(d_first + N - i) = *(first + i)}}&lt;ref name="plusminus" /&gt;|after=改成&lt;br&gt;{{c|1=*(d_first + N - 1 - i) = *(first + i)}}&lt;ref name="plusminus" /&gt;}}
{{dr list item|wg=lwg|dr=2150|std=C++98|before=只需要赋值一个元素|after=改正要求}}
{{dr list end}}
&lt;references/&gt;

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc reverse}}
{{dsc inc|cpp/algorithm/ranges/dsc reverse_copy}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}