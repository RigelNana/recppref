{{cpp/title|upper_bound}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl rev begin|num=1}}
{{dcla|anchor=版本_1|constexpr=c++20|until=c++26|
template&lt; class ForwardIt, class T &gt;
ForwardIt upper_bound( ForwardIt first, ForwardIt last,
                       const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class ForwardIt, class T = typename std::iterator_traits
                                         &lt;ForwardIt&gt;::value_type &gt;
constexpr ForwardIt upper_bound( ForwardIt first, ForwardIt last,
                                 const T&amp; value );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcla|anchor=版本_2|constexpr=c++20|until=c++26|
template&lt; class ForwardIt, class T, class Compare &gt;
ForwardIt upper_bound( ForwardIt first, ForwardIt last,
                       const T&amp; value, Compare comp );
}}
{{dcl|since=c++26|1=
template&lt; class ForwardIt, class T = typename std::iterator_traits
                                         &lt;ForwardIt&gt;::value_type,
          class Compare &gt;
constexpr ForwardIt upper_bound( ForwardIt first, ForwardIt last,
                                 const T&amp; value, Compare comp );
}}
{{dcl end}}

在已划分的范围 {{range|first|last}} 中查找第一个后序于 {{c|value}} 的元素。

@1@ 通过 {{c/core|operator&lt;}} 确定顺序：
{{rev begin}}
{{rev|until=c++20|
返回 {{range|first|last}} 中首个使得 {{c|bool(value &lt; *iter)}} 是 {{c|true}} 的迭代器 {{c|iter}}，或者在不存在这种 {{c|iter}} 的情况下返回 {{c|last}}。

如果 {{range|first|last}} 的元素 {{c|elem}} 没有按表达式 {{c|bool(value &lt; elem)}} {{rlp|/#要求|划分}}，那么行为未定义。
}}
{{rev|since=c++20|
等价于 {{c|std::upper_bound(first, last, value, std::less{})}}。
}}
{{rev end}}

@2@ 通过 {{c|comp}} 确定顺序：
@@ 返回 {{range|first|last}} 中首个使得 {{c|bool(comp(value, *iter))}} 是 {{c|true}} 的迭代器 {{c|iter}}，或者在不存在这种 {{c|iter}} 的情况下返回 {{c|last}}。
@@ 如果 {{range|first|last}} 的元素 {{c|elem}} 没有按表达式 {{c|bool(comp(value, elem))}} {{rlp|/#要求|划分}}，那么行为未定义。

===参数===
{{par begin}}
{{par range|3=要检验的|range=已划分}}
{{par|value|要与元素比较的值}}
{{par pred2|comp|如果第一个实参先序于第二个|t1=T|p2=ForwardIt|bidirectional=false}} 
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req named|Compare|BinaryPredicate|notes=不要求满足 {{named req|Compare}}。}}
{{par end}}

===返回值===
返回到范围 {{range|first|last}} 的第一个后序于 {{c|value}} 的元素的迭代器，或者在找不到这种元素时返回 {{c|last}}。

===复杂度===
给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first, last)}}：

@1,2@ 最多应用 {{mathjax-or|\(\scriptsize \log_{2}(N)+O(1)\)|log{{su|b=2}}(N)+O(1)}} 次 {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}} 进行比较。

@3,4@ 最多应用 {{mathjax-or|\(\scriptsize \log_{2}(N)+O(1)\)|log{{su|b=2}}(N)+O(1)}} 次比较函数 {{c|comp}}。

然而，如果 {{tt|ForwardIt}} 不是{{named req|RandomAccessIterator}}，那么迭代器自增次数与 {{mathjax-or|\(\scriptsize N\)|N}} 成线性。要注意 {{lc|std::map}}、{{lc|std::multimap}}、{{lc|std::set}} 和 {{lc|std::multiset}} 的迭代器不是随机访问的，因此它们的 {{tt|upper_bound}} 成员函数的表现更好。

===可能的实现===
参阅 [https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L2028 libstdc++] 和 [https://github.com/llvm/llvm-project/blob/8350d9c23d76fb95f42674a1563cbe8c32582dd5/libcxx/include/__algorithm/upper_bound.h#L35 libc++] 中的实现。

{{eq impl|title1=upper_bound (1)|ver1=1|1=
template&lt;class ForwardIt, class T = typename std::iterator_traits&lt;ForwardIt&gt;::value_type&gt;
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T&amp; value)
{
    return std::upper_bound(first, last, value, std::less{});
}
|title2=upper_bound (2)|ver2=2|2=
template&lt;class ForwardIt, class T = typename std::iterator_traits&lt;ForwardIt&gt;::value_type,
         class Compare&gt;
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T&amp; value, Compare comp)
{
    ForwardIt it;
    typename std::iterator_traits&lt;ForwardIt&gt;::difference_type count, step;
    count = std::distance(first, last);
    
    while (count &gt; 0)
    {
        it = first; 
        step = count / 2;
        std::advance(it, step);
        
        if (!comp(value, *it))
        {
            first = ++it;
            count -= step + 1;
        } 
        else
            count = step;
    }
    
    return first;
}
}}

===注解===
尽管 {{tt|std::upper_bound}} 只要求 {{range|first|last}} 已划分，但是该算法通常会在 {{range|first|last}} 已排序的情况下使用，此时二分查找对于任意 {{c|value}} 都有效。

对于 {{range|first|last}} 中的任意迭代器 {{c|iter}}，{{tt|std::upper_bound}} 要求 {{c|value &lt; *iter}} 和 {{c|comp(value, *iter)}} 良构，而 {{lc|std::lower_bound}} 要求 {{c|*iter &lt; value}} 和 {{c|comp(*iter, value)}} 良构。

{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|算法中的[[cpp/language/list initialization|列表初始化]] {{vl|1,2}}}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct PriceInfo { double price; };

int main()
{
    const std::vector&lt;int&gt; data{1, 2, 4, 5, 5, 6};
    
    for (int i = 0; i &lt; 7; ++i)
    {
        // 搜索首个大于 i 的元素
        auto upper = std::upper_bound(data.begin(), data.end(), i);
        
        std::cout &lt;&lt; i &lt;&lt; " &lt; ";
        upper != data.end()
            ? std::cout &lt;&lt; *upper &lt;&lt; " 位于索引 " &lt;&lt; std::distance(data.begin(), upper)
            : std::cout &lt;&lt; "没有找到";
        std::cout &lt;&lt; '\n';
    }
    
    std::vector&lt;PriceInfo&gt; prices = {{100.0}, {101.5}, {102.5}, {102.5}, {107.3}};
    
    for (double to_find : {102.5, 110.2})
    {
        auto prc_info = std::upper_bound(prices.begin(), prices.end(), to_find,
            [](double value, const PriceInfo&amp; info)
            {
                return value &lt; info.price;
            });
        
        prc_info != prices.end()
            ? std::cout &lt;&lt; prc_info-&gt;price &lt;&lt; " 位于索引 " &lt;&lt; prc_info - prices.begin()
            : std::cout &lt;&lt; to_find &lt;&lt; " 没有找到";
        std::cout &lt;&lt; '\n';
    }

    using CD = std::complex&lt;double&gt;;
    std::vector&lt;CD&gt; nums{&lt;!----&gt;{1, 0}, {2, 2}, {2, 1}, {3, 0}, {3, 1}&lt;!----&gt;};
    auto cmpz = [](CD x, CD y) { return x.real() &lt; y.real(); };
    #ifdef __cpp_lib_algorithm_default_value_type
        auto it = std::upper_bound(nums.cbegin(), nums.cend(), {2, 0}, cmpz);
    #else
        auto it = std::upper_bound(nums.cbegin(), nums.cend(), CD{2, 0}, cmpz);
    #endif
    assert((*it == CD{3, 0}));
}
|output=
0 &lt; 1 位于索引 0
1 &lt; 2 位于索引 1
2 &lt; 4 位于索引 2
3 &lt; 4 位于索引 2
4 &lt; 5 位于索引 3
5 &lt; 6 位于索引 5
6 &lt; 没有找到
107.3 位于索引 4
110.2 没有找到
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=270|std=C++98|before={{tt|Compare}} 需要满足{{named req|Compare}}，并且 {{tt|T}} 需要是&lt;br&gt;{{named req|LessThanComparable}}的（要求严格弱序）|after=只需要划分；&lt;br&gt;容许异相比较}}
{{dr list item|wg=lwg|dr=384|std=C++98|before=最多允许 {{mathjax-or|\(\scriptsize \log(N)+1\)|log{{su|b=2}}(N)+1}} 次比较|after=改成 {{mathjax-or|\(\scriptsize \log_{2}(N)+O(1)\)|log{{su|b=2}}(N)+O(1)}} 次}}
{{dr list item|wg=lwg|dr=577|std=C++98|before=不能返回 {{c|last}}|after=可以返回}}
{{dr list item|wg=lwg|dr=2150|std=C++98|before=如果 {{range|first|last}} 中存在任何迭代器 {{c|iter}} 使得&lt;br&gt;{{c|bool(comp(value, *iter))}} 是 {{c|true}}，那么&lt;br&gt;{{tt|std::upper_bound}} 可以返回 {{range|iter|last}} 中的任意迭代器|after=不能返回 {{c|iter}}&lt;br&gt;后的迭代器}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc equal_range}}
{{dsc inc|cpp/algorithm/dsc lower_bound}}
{{dsc inc|cpp/algorithm/dsc partition}}
{{dsc inc|cpp/algorithm/dsc partition_point}}
{{dsc inc|cpp/algorithm/ranges/dsc upper_bound}}
{{dsc inc|cpp/container/dsc upper_bound|set}}
{{dsc inc|cpp/container/dsc upper_bound|multiset}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}