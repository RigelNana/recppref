{{cpp/title|partition_copy}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcla|num=1|since=c++11|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class OutputIt1,
          class OutputIt2, class UnaryPred &gt;
std::pair&lt;OutputIt1, OutputIt2&gt;
    partition_copy( InputIt first, InputIt last,
                    OutputIt1 d_first_true, OutputIt2 d_first_false,
                    UnaryPred p );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt1, class ForwardIt2,
          class ForwardIt3, class UnaryPred &gt;
std::pair&lt;ForwardIt2, ForwardIt3&gt;
    partition_copy( ExecutionPolicy&amp;&amp; policy,
                    ForwardIt1 first, ForwardIt1 last,
                    ForwardIt2 d_first_true, ForwardIt3 d_first_false,
                    UnaryPred p );
}}
{{dcl end}}

@1@ 根据谓词 {{c|p}} 的返回值，将范围 {{range|first|last}} 中的元素复制到两个不同范围。
* 满足谓词 {{c|p}} 的元素会被复制到从 {{c|d_first_true}} 开始的范围。
* 剩余元素会被复制到从 {{c|d_first_false}} 开始的范围。

@2@ 同 {{v|1}}，但按照 {{c|policy}} 执行。
@@ {{cpp/algorithm/parallel overload precondition}}

如果 {{c|*first}} 不[[cpp/iterator#类型与可写性|可写入]] {{c|d_first_true}} 或 {{c|d_first_false}}，那么程序非良构。

在输入范围和两个输出范围中，如果其中两个范围有重叠，那么行为未定义。

===参数===
{{par begin}}
{{par range|3=要复制的|range=源}}
{{par|d_first_true|满足 {{c|p}} 的元素的输出范围起始}}
{{par|d_first_false|不满足 {{c|p}} 的元素的输出范围起始}}
{{par exec pol}}
{{par pred1|p|如果元素应置于 {{c|d_first_true}} 中|p1=InputIt}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|OutputIt1, OutputIt2|OutputIterator}}
{{par req named|ForwardIt1, ForwardIt2, ForwardIt3|ForwardIterator}}
{{par req named|UnaryPred|Predicate}}
{{par end}}

===返回值===
从指向 {{c|d_first_true}} 范围结尾的迭代器和指向 {{c|d_first_false}} 范围结尾的迭代器构造的 {{lc|std::pair}}。

===复杂度===
准确应用 {{c|std::distance(first, last)}} 次 {{c|p}}。

对于重载 {{v|2}}，如果 {{tt|ForwardIt}} 的值类型不{{named req|CopyConstructible}}，那么可能会有性能开销。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=yes}}

===可能的实现===
{{eq impl|title1=partition_copy (1)|ver1=1|1=
template&lt;class InputIt, class OutputIt1,
         class OutputIt2, class UnaryPred&gt;
constexpr //&lt; C++20 起
std::pair&lt;OutputIt1, OutputIt2&gt;
    partition_copy(InputIt first, InputIt last,
                   OutputIt1 d_first_true, OutputIt2 d_first_false,
                   UnaryPred p)
{
    for (; first != last; ++first)
    {
        if (p(*first))
        {
            *d_first_true = *first;
            ++d_first_true;
        }
        else
        {
            *d_first_false = *first;
            ++d_first_false;
        }
    }
    
    return std::pair&lt;OutputIt1, OutputIt2&gt;(d_first_true, d_first_false);
}
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;

void print(auto rem, const auto&amp; v)
{
    for (std::cout &lt;&lt; rem; const auto&amp; x : v)
        std::cout &lt;&lt; x &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    int arr[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int true_arr[5] = {0};
    int false_arr[5] = {0};
    
    std::partition_copy(std::begin(arr), std::end(arr),
                        std::begin(true_arr), std::begin(false_arr),
                        [](int i) { return 4 &lt; i; });
    
    print("true_arr ：", true_arr);
    print("false_arr：", false_arr);
}
|output=
true_arr ：5 6 7 8 9
false_arr：0 1 2 3 4
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|paper=P0896R4|std=C++11&lt;br&gt;C++17|before=1. {{tt|InputIt}} （C++11）/{{tt|ForwardIt1}}（C++17）的值类型需要{{named req|CopyAssignable}}&lt;br&gt;2. 两个输出范围可以有重叠|after=1. 不需要&lt;br&gt;2. 此时行为未定义}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc partition}}
{{dsc inc|cpp/algorithm/dsc stable_partition}}
{{dsc inc|cpp/algorithm/dsc copy}}
{{dsc inc|cpp/algorithm/dsc remove_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc partition_copy}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}