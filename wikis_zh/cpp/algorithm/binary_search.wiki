{{cpp/title|binary_search}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl rev begin|num=1}}
{{dcla|anchor=版本_1|constexpr=c++20|until=c++26|
template&lt; class ForwardIt, class T &gt;
bool binary_search( ForwardIt first, ForwardIt last,
                    const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class ForwardIt, class T = typename std::iterator_traits
                                         &lt;ForwardIt&gt;::value_type &gt;
constexpr bool binary_search( ForwardIt first, ForwardIt last,
                              const T&amp; value );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcla|anchor=版本_2|constexpr=c++20|until=c++26|
template&lt; class ForwardIt, class T, class Compare &gt;
bool binary_search( ForwardIt first, ForwardIt last,
                    const T&amp; value, Compare comp );
}}
{{dcl|since=c++26|1=
template&lt; class ForwardIt, class T = typename std::iterator_traits
                                         &lt;ForwardIt&gt;::value_type,
          class Compare &gt;
constexpr bool binary_search( ForwardIt first, ForwardIt last,
                              const T&amp; value, Compare comp );
}}
{{dcl rev end}}
{{dcl end}}

检查在已划分范围 {{range|first|last}} 中是否出现与 {{c|value}} 等价的元素。

@1@ 通过 {{c/core|operator&lt;}} 检查元素是否等价：
{{rev begin}}
{{rev|until=c++20|
如果 {{range|first|last}} 中存在迭代器 {{c|iter}} 使得 {{c|!bool(*iter &lt; value) &amp;&amp; !bool(value &lt; *iter)}} 是 {{c|true}}，那么返回 {{c|true}}。否则返回 {{c|false}}。

如果满足以下任意条件，那么行为未定义：
* {{range|first|last}} 的某些元素 {{c|elem}} 使得无法通过 {{c|bool(elem &lt; value)}} 得出 {{c|!bool(value &lt; elem)}}。
* {{range|first|last}} 的元素 {{c|elem}} 没有按表达式 {{c|bool(elem &lt; value)}} 和 {{c|!bool(value &lt; elem)}} {{rlp|/#要求|划分}}。
}}
{{rev|since=c++20|
等价于 {{c|std::binary_search(first, last, value, std::less{})}}。
}}
{{rev end}}

@2@ 通过 {{c|comp}} 检查元素是否等价：
@@ 如果 {{range|first|last}} 中存在迭代器 {{c|iter}} 使得 {{c|!bool(comp(*iter, value)) &amp;&amp; !bool(comp(value, *iter))}} 是 {{c|true}}，那么返回 {{c|true}}。否则返回 {{c|false}}。
@@ 如果满足以下任意条件，那么行为未定义：
* {{range|first|last}} 的某些元素 {{c|elem}} 使得无法通过 {{c|bool(comp(elem, value))}} 得出 {{c|!bool(comp(value, elem))}}。
* {{range|first|last}} 的元素 {{c|elem}} 没有按表达式 {{c|bool(comp(elem, value))}} 和 {{c|!bool(comp(value, elem))}} {{rlp|/#要求|划分}}。

===参数===
{{par begin}}
{{par range|3=要检验的|range=已划分}}
{{par|value|要与元素比较的值}}
{{par pred2|comp|如果第一个实参先序于第二个|p1=ForwardIt|t2=T}} 
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req named|Compare|BinaryPredicate|notes=不要求满足 {{named req|Compare|}}。}}
{{par end}}

===返回值===
找到等价于 {{c|value}} 的元素时返回 {{c|true}}，否则返回 {{c|false}}。

===复杂度===
给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first, last)}}：

@1,2@ 最多应用 {{mathjax-or|\(\scriptsize \log_{2}(N)+O(1)\)|log{{su|b=2}}(N)+O(1)}} 次 {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}} 进行比较。

@3,4@ 最多应用 {{mathjax-or|\(\scriptsize \log_{2}(N)+O(1)\)|log{{su|b=2}}(N)+O(1)}} 次比较函数 {{c|comp}}。

然而，如果 {{tt|ForwardIt}} 不是{{named req|RandomAccessIterator}}，那么迭代器自增次数与 {{mathjax-or|\(\scriptsize N\)|N}} 成线性。

===注解===
尽管 {{tt|std::binary_search}} 只要求 {{range|first|last}} 已划分，但是该算法通常会在 {{range|first|last}} 已排序的情况下使用，此时二分查找对于任意 {{c|value}} 都有效。

{{tt|std::binary_search}} 只会检查是否存在等价元素。需要获取到该元素（如果存在）的迭代器时应改用 {{lc|std::lower_bound}}。

{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|算法中的[[cpp/language/list initialization|列表初始化]] {{vl|1,2}}}}

===可能的实现===
另见 [https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L2236 libstdc++] 和 [https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L4320 libc++] 中的实现。
{{eq impl
|title1=binary_search (1)|ver1=1|1=
template&lt;class ForwardIt, class T = typename std::iterator_traits&lt;ForwardIt&gt;::value_type&gt;
bool binary_search(ForwardIt first, ForwardIt last, const T&amp; value)
{
    return std::binary_search(first, last, value, std::less{});
}
|title2=binary_search (2)|ver2=2|2=
template&lt;class ForwardIt, class T = typename std::iterator_traits&lt;ForwardIt&gt;::value_type,
         class Compare&gt;
bool binary_search(ForwardIt first, ForwardIt last, const T&amp; value, Compare comp)
{
    first = std::lower_bound(first, last, value, comp);
    return (!(first == last) and !(comp(value, *first)));
}
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; haystack{1, 3, 4, 5, 9};
    std::vector&lt;int&gt; needles{1, 2, 3};
    
    for (const auto needle : needles)
    {
        std::cout &lt;&lt; "正在搜索 " &lt;&lt; needle &lt;&lt; '\n';
        if (std::binary_search(haystack.begin(), haystack.end(), needle))
            std::cout &lt;&lt; "找到了 " &lt;&lt; needle &lt;&lt; '\n';
        else
            std::cout &lt;&lt; "没找到！\n";
    }

    using CD = std::complex&lt;double&gt;;
    std::vector&lt;CD&gt; nums{&lt;!----&gt;{1, 1}, {2, 3}, {4, 2}, {4, 3}&lt;!----&gt;};
    auto cmpz = [](CD x, CD y){ return abs(x) &lt; abs(y); };
    #ifdef __cpp_lib_algorithm_default_value_type
        assert(std::binary_search(nums.cbegin(), nums.cend(), {4, 2}, cmpz));
    #else
        assert(std::binary_search(nums.cbegin(), nums.cend(), CD{4, 2}, cmpz));
    #endif
}
|output=
正在搜索 1
找到了 1
正在搜索 2
没找到！
正在搜索 3
找到了 3
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=270|std=C++98|before={{tt|Compare}} 需要满足{{named req|Compare}}，并且 {{tt|T}} 需要是&lt;br&gt;{{named req|LessThanComparable}}的（要求严格弱序）|after=只需要划分；容许异相比较}}
{{dr list item|wg=lwg|dr=787|std=C++98|before=最多允许 {{mathjax-or|\(\scriptsize \log_{2}(N)+2\)|log{{su|b=2}}(N)+2}} 次比较|after=改成 {{mathjax-or|\(\scriptsize \log_{2}(N)+O(1)\)|log{{su|b=2}}(N)+O(1)}} 次}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc equal_range}}
{{dsc inc|cpp/algorithm/dsc lower_bound}}
{{dsc inc|cpp/algorithm/dsc upper_bound}}
{{dsc inc|cpp/algorithm/ranges/dsc binary_search}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}