{{cpp/ranges/title|replace_copy|replace_copy_if|replace_copy_result|replace_copy_if_result}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl rev begin|num=1}}
{{dcla|anchor=版本_1|since=c++20|until=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S, class T1, class T2,
          std::output_iterator&lt;const T2&amp;&gt; O, class Proj = std::identity &gt;
requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T1*&gt;
constexpr replace_copy_result&lt;I, O&gt;
    replace_copy( I first, S last, O result, const T1&amp; old_value,
                  const T2&amp; new_value, Proj proj = {} );
}}
{{dcla|since=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class O, class Proj = std::identity,
          class T1 = std::projected_value_t&lt;I, Proj&gt;,
          class T2 = std::iter_value_t&lt;O&gt; &gt;
requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T1*&gt; &amp;&amp;
         std::output_iterator&lt;O, const T2&amp;&gt;
constexpr replace_copy_result&lt;I, O&gt;
    replace_copy( I first, S last, O result, const T1&amp; old_value,
                  const T2&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::input_range R, class T1, class T2,
          std::output_iterator&lt;const T2&amp;&gt; O, class Proj = std::identity &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;
constexpr replace_copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    replace_copy( R&amp;&amp; r, O result, const T1&amp; old_value,
                  const T2&amp; new_value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::input_range R,
          class O, class Proj = std::identity,
          class T1 = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
          class T2 = std::iter_value_t&lt;O&gt; &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt; &amp;&amp;
         std::output_iterator&lt;O, const T2&amp;&gt;
constexpr replace_copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    replace_copy( R&amp;&amp; r, O result, const T1&amp; old_value,
                  const T2&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=3}}
{{dcla|anchor=版本_3|since=c++20|until=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class T, std::output_iterator&lt;const T&amp;&gt; O,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
requires std::indirectly_copyable&lt;I, O&gt;
constexpr replace_copy_if_result&lt;I, O&gt;
    replace_copy_if( I first, S last, O result, Pred pred,
                     const T&amp; new_value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class O, class T = std::iter_value_t&lt;O&gt;
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp; std::output_iterator&lt;O, const T&amp;&gt;
constexpr replace_copy_if_result&lt;I, O&gt;
    replace_copy_if( I first, S last, O result, Pred pred,
                     const T&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=4}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::input_range R,
          class T, std::output_iterator&lt;const T&amp;&gt; O,
          class Proj = std::identity,
          std::indirect_unary_predicate
              &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt;
constexpr replace_copy_if_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    replace_copy_if( R&amp;&amp; r, O result, Pred pred,
                     const T&amp; new_value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::input_range R,
          class O, class T = std::iter_value_t&lt;O&gt;
          class Proj = std::identity,
          std::indirect_unary_predicate
              &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
         std::output_iterator&lt;O, const T&amp;&gt;
constexpr replace_copy_if_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    replace_copy_if( R&amp;&amp; r, O result, Pred pred,
                     const T&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl h|辅助类型}}
{{dcl|num=5|since=c++20|1=
template&lt; class I, class O &gt;
using replace_copy_result = ranges::in_out_result&lt;I, O&gt;;
}}
{{dcl|num=6|since=c++20|1=
template&lt; class I, class O &gt;
using replace_copy_if_result = ranges::in_out_result&lt;I, O&gt;;
}}
{{dcl end}}

从源范围 {{range|first|last}} 复制元素到始于 {{c|result}} 的目标范围，以 {{c|new_value}} 替换所欲满足特定标准的元素。若源范围与目标范围重叠则行为未定义。

@1@ 替换所有等于 {{c|old_value}} 的元素，用 {{c|1=std::invoke(proj, *(first + (i - result))) == old_value}} 比较。

@3@ 替换所有谓词 {{c|pred}} 对其求值为 {{c|true}} 的元素，其中求值的表达式为 {{c|1=std::invoke(pred, std::invoke(proj, *(first + (i - result))))}}。

@2,4@ 同 {{v|1,3}}，但以 {{c|r}} 为源范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要复制的|sentinel=yes}}
{{par|r|要复制的元素范围}}
{{par|result|目标范围的起始}}
{{par|old_value|要替换的元素的值}}
{{par|new_value|用作替换品的值}}
{{par|pred|应用到投影后元素的谓词}}
{{par|proj|应用到元素的投影}}
{{par end}}

===返回值===
{{c|{last, result + N} }}，其中
@1,3@ {{c|1=N = ranges::distance(first, last)}}；
@2,4@ {{c|1=N = ranges::distance(r)}}。

===复杂度===
准确应用 {{c|N}} 次对应的谓词 {{c|comp}} 与投影 {{c|proj}}。

===可能的实现===
{{eq impl|title1=replace_copy (1,2)|ver1=1|1=
struct replace_copy_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             class O, class Proj = std::identity,
             class T1 = std::projected_value_t&lt;I, Proj&gt;,
             class T2 = std::iter_value_t&lt;O&gt;&gt;
    requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp;
             std::indirect_binary_predicate
                 &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T1*&gt; &amp;&amp;
             std::output_iterator&lt;O, const T2&amp;&gt;
    constexpr ranges::replace_copy_result&lt;I, O&gt;
        operator()(I first, S last, O result, const T1&amp; old_value,
                   const T2&amp; new_value, Proj proj = {}) const
    {
        for (; first != last; ++first, ++result)
            *result = (std::invoke(proj, *first) == old_value) ? new_value : *first;
        return {std::move(first), std::move(result)};
    }
    
    template&lt;ranges::input_range R, class O, class Proj = std::identity,
             class T1 = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
             class T2 = std::iter_value_t&lt;O&gt;&gt;
    requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
             std::indirect_binary_predicate
                 &lt;ranges::equal_to,
                  std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;
    constexpr ranges::replace_copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
        operator()(R&amp;&amp; r, O result, const T1&amp; old_value,
                   const T2&amp; new_value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(result),
                       old_value, new_value, std::move(proj));
    }
};

inline constexpr replace_copy_fn replace_copy {};
|title2=replace_copy_if (3,4)|ver2=3|2=
struct replace_copy_if_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             class O, class T = std::iter_value_t&lt;O&gt;
             class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp; std::output_iterator&lt;O, const T&amp;&gt;
    constexpr ranges::replace_copy_if_result&lt;I, O&gt;
        operator()(I first, S last, O result, Pred pred,
                   const T&amp; new_value, Proj proj = {}) const
    {
        for (; first != last; ++first, ++result)
             *result = std::invoke(pred, std::invoke(proj, *first)) ? new_value : *first;
        return {std::move(first), std::move(result)};
    }
    
    template&lt;ranges::input_range R, class O, class T = std::iter_value_t&lt;O&gt;
             class Proj = std::identity,
             std::indirect_unary_predicate
                 &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
             std::output_iterator&lt;O, const T&amp;&gt;
    constexpr ranges::replace_copy_if_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
        operator()(R&amp;&amp; r, O result, Pred pred,
                   const T&amp; new_value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(result),
                       std::move(pred), new_value, std::move(proj));
    }
};

inline constexpr replace_copy_if_fn replace_copy_if {};
}}

===注解===
{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|算法中的[[cpp/language/list initialization|列表初始化]] {{vl|1-4}}}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
 
void println(const auto rem, const auto&amp; v)
{
    for (std::cout &lt;&lt; rem &lt;&lt; ": "; const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
 
int main()
{    
    std::vector&lt;int&gt; o;
 
    std::array p{1, 6, 1, 6, 1, 6};
    o.resize(p.size());
    println("p", p);
    std::ranges::replace_copy(p, o.begin(), 6, 9);
    println("o", o);
 
    std::array q{1, 2, 3, 6, 7, 8, 4, 5};
    o.resize(q.size());
    println("q", q);
    std::ranges::replace_copy_if(q, o.begin(), [](int x) { return 5 &lt; x; }, 5);
    println("o", o);
 
    std::vector&lt;std::complex&lt;short&gt;&gt; r{{1, 3}, {2, 2}, {4, 8}};
    std::vector&lt;std::complex&lt;float&gt;&gt; s(r.size());
    println("r", r);
    #ifdef __cpp_lib_algorithm_default_value_type
        std::ranges::replace_copy(r, s.begin(),
                                  {1, 3}, // T1 被推导
                                  {2.2, 4.8}); // T2 被推导
    #else
        std::ranges::replace_copy(r, s.begin(),
                                  std::complex&lt;short&gt;{1, 3},
                                  std::complex&lt;float&gt;{2.2, 4.8});
    #endif
    println("s", s);
 
    std::vector&lt;std::complex&lt;double&gt;&gt; b{{1, 3}, {2, 2}, {4, 8}},
                                      d(b.size());
    println("b", b);
    #ifdef __cpp_lib_algorithm_default_value_type
        std::ranges::replace_copy_if(b, d.begin(),
            [](std::complex&lt;double&gt; z){ return std::abs(z) &lt; 5; },
            {4, 2}); // 可以这样做，因为 T 是被推导的。
    #else
        std::ranges::replace_copy_if(b, d.begin(),
            [](std::complex&lt;double&gt; z){ return std::abs(z) &lt; 5; },
            std::complex&lt;double&gt;{4, 2});
    #endif
    println("d", d);
}
|output=
p: 1 6 1 6 1 6
o: 1 9 1 9 1 9
q: 1 2 3 6 7 8 4 5
o: 1 2 3 5 5 5 4 5
r: (1,3) (2,2) (4,8)
s: (2.2,4.8) (2,2) (4,8)
b: (1,3) (2,2) (4,8)
d: (4,2) (4,2) (4,8)
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc replace}}
{{dsc inc|cpp/algorithm/dsc replace_copy}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}