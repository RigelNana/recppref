{{cpp/ranges/title|find|find_if|find_if_not}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl rev begin|num=1}}
{{dcla|anchor=版本_1|since=c++20|until=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class T, class Proj = std::identity &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr I find( I first, S last, const T&amp; value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;I, Proj&gt; &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr I find( I first, S last, const T&amp; value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::input_range R, class T, class Proj = std::identity &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    find( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt; &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    find( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcla|since=c++20|num=3|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr I find_if( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++20|num=4|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          std::indirect_unary_predicate
              &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    find_if( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcla|since=c++20|num=5|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr I find_if_not( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++20|num=6|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          std::indirect_unary_predicate
              &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    find_if_not( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcl end}}

返回范围 {{range|first|last}} 中首个满足特定判别标准的元素：
@1@ {{tt|find}} 搜索等于 {{c|value}} 的元素。

@3@ {{tt|find_if}} 搜索谓词 {{c|pred}} 对其返回 {{c|true}} 的元素。

@5@ {{tt|find_if_not}} 搜索谓词 {{c|pred}} 对其返回 {{c|false}} 的元素。
@2,4,6@ 同 {{v|1,3,5}}，但以 {{c|r}} 为范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要检验的|sentinel=yes}}
{{par|r|要检验的范围}}
{{par|value|要与元素比较的值}}
{{par|pred|应用到投影后元素的谓词}}
{{par|proj|应用到元素的投影}}
{{par end}}

===返回值===
指向满足条件的首个元素的迭代器，或若找不到这种元素则为等于 {{c|last}} 的迭代器。

===复杂度===
至多应用 {{c|last - first}} 次谓词与投影。

===可能的实现===
{{eq impl|title1=find (1)|ver1=1|1=
struct find_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity,
             class T = std::projected_value_t&lt;I, Proj&gt;&gt;
    requires std::indirect_binary_predicate
                 &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
    constexpr I operator()(I first, S last, const T&amp; value, Proj proj = {}) const
    {
        for (; first != last; ++first)
            if (std::invoke(proj, *first) == value)
                return first;
        return first;
    }
    
    template&lt;ranges::input_range R, class T, class Proj = std::identity&gt;
    requires std::indirect_binary_predicate&lt;ranges::equal_to,
                 std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, const T&amp; value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), value, std::ref(proj));
    }
};

inline constexpr find_fn find;
|title2=find_if (3)|ver2=3|2=
struct find_if_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr I operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        for (; first != last; ++first)
            if (std::invoke(pred, std::invoke(proj, *first)))
                return first;
        return first;
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity,
             std::indirect_unary_predicate
                 &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::ref(pred), std::ref(proj));
    }
};

inline constexpr find_if_fn find_if;
|title3=find_if_not (5)|ver3=5|3=
struct find_if_not_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr I operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        for (; first != last; ++first)
            if (!std::invoke(pred, std::invoke(proj, *first)))
                return first;
        return first;
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity,
             std::indirect_unary_predicate
                 &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::ref(pred), std::ref(proj));
    }
};

inline constexpr find_if_not_fn find_if_not;
}}

===注解===
{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|算法中的[[cpp/language/list initialization|列表初始化]] {{vl|1,2}}}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;format&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

void projector_example()
{
    struct folk_info
    {
        unsigned uid;
        std::string name, position;
    };
    
    std::vector&lt;folk_info&gt; folks
    {
        {0, "Ana", "dev"},
        {1, "Bob", "devops"},
        {2, "Eve", "ops"}
    };
    
    const auto who{"Eve"};
    
    if (auto it = std::ranges::find(folks, who, &amp;folk_info::name); it != folks.end())
        std::cout &lt;&lt; std::format("人物简介：\n"
                                 "    UID：{}\n"
                                 "    名字：{}\n"
                                 "    职位：{}\n\n",
                                 it-&gt;uid, it-&gt;name, it-&gt;position);
}

int main()
{
    namespace ranges = std::ranges;
    
    projector_example();
    
    const int n1 = 3;
    const int n2 = 5;
    const auto v = {4, 1, 3, 2};
    
    if (ranges::find(v, n1) != v.end())
        std::cout &lt;&lt; "v 包含：" &lt;&lt; n1 &lt;&lt; '\n';
    else
        std::cout &lt;&lt; "v 不包含：" &lt;&lt; n1 &lt;&lt; '\n';
    
    if (ranges::find(v.begin(), v.end(), n2) != v.end())
        std::cout &lt;&lt; "v 包含：" &lt;&lt; n2 &lt;&lt; '\n';
    else
        std::cout &lt;&lt; "v 不包含：" &lt;&lt; n2 &lt;&lt; '\n';
    
    auto is_even = [](int x) { return x % 2 == 0; };
    
    if (auto result = ranges::find_if(v.begin(), v.end(), is_even); result != v.end())
        std::cout &lt;&lt; "v 中的第一个偶数元素：" &lt;&lt; *result &lt;&lt; '\n';
    else
        std::cout &lt;&lt; "v\ 中没有偶数元素n";
    
    if (auto result = ranges::find_if_not(v, is_even); result != v.end())
        std::cout &lt;&lt; "v 中的第一个奇数元素：" &lt;&lt; *result &lt;&lt; '\n';
    else
        std::cout &lt;&lt; "v 中没有奇数元素\n";
    
    auto divides_13 = [](int x) { return x % 13 == 0; };
    
    if (auto result = ranges::find_if(v, divides_13); result != v.end())
        std::cout &lt;&lt; "v 中的第一个可被 13 整除的元素：" &lt;&lt; *result &lt;&lt; '\n';
    else
        std::cout &lt;&lt; "v 中没有可被 13 整除的元素\n";
    
    if (auto result = ranges::find_if_not(v.begin(), v.end(), divides_13);
        result != v.end())
        std::cout &lt;&lt; "v 中的第一个不可被 13 整除的元素：" &lt;&lt; *result &lt;&lt; '\n';
    else
        std::cout &lt;&lt; "v 中没有不可被 13 整除的元素\n";

    std::vector&lt;std::complex&lt;double&gt;&gt; nums{&lt;!----&gt;{4, 2}&lt;!----&gt;};
    #ifdef __cpp_lib_algorithm_default_value_type
        // (2) 中推导的 T 使得列表初始化成为可能
        const auto it = ranges::find(nums, {4, 2});
    #else
        const auto it = ranges::find(nums, std::complex&lt;double&gt;{4, 2});
    #endif
    assert(it == nums.begin());
}
|output=
人物简介：
    UID：2
    名字：Eve
    职位：ops

v 包含：3
v 不包含：5
v 中的第一个偶数元素：4
v 中的第一个奇数元素：1
v 中没有可被 13 整除的元素
v 中的第一个不可被 13 整除的元素：4
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc adjacent_find}}
{{dsc inc|cpp/algorithm/ranges/dsc find_end}}
{{dsc inc|cpp/algorithm/ranges/dsc find_first_of}}
{{dsc inc|cpp/algorithm/ranges/dsc mismatch}}
{{dsc inc|cpp/algorithm/ranges/dsc search}}
{{dsc inc|cpp/algorithm/dsc find}}
{{dsc end}}

{{langlinks|en|es|ja}}