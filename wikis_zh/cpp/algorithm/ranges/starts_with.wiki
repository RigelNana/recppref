{{cpp/ranges/title|starts_with}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl|num=1|since=c++23|1=
template&lt; std::input_iterator I1, std::sentinel_for&lt;I1&gt; S1,
          std::input_iterator I2, std::sentinel_for&lt;I2&gt; S2,
          class Pred = ranges::equal_to,
          class Proj1 = std::identity, class Proj2 = std::identity &gt;
requires std::indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
constexpr bool
    starts_with( I1 first1, S1 last1, I2 first2, S2 last2,
                 Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {} );
}}
{{dcl|num=2|since=c++23|1=
template&lt; ranges::input_range R1, ranges::input_range R2,
          class Pred = ranges::equal_to,
          class Proj1 = std::identity, class Proj2 = std::identity &gt;
requires std::indirectly_comparable&lt;ranges::iterator_t&lt;R1&gt;,
                                    ranges::iterator_t&lt;R2&gt;,
                                    Pred, Proj1, Proj2&gt;
constexpr bool
    starts_with( R1&amp;&amp; r1, R2&amp;&amp; r2,
                 Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {} );
}}
{{dcl end}}

检查第二范围是否匹配第一范围的前缀。

@1@ 令 {{tt|N1}} 与 {{tt|N2}} 分别代表范围 {{range|first1|last1}} 与 {{range|first2|last2}} 的大小。若 {{c|N1 &lt; N2}} 则返回 {{c|false}}。否则，当且仅当 {{range|first2|last2}} 范围中的每个元素均等于 {{range|first1|first1 + N2}} 中的对应元素才返回 {{c|true}}。通过应用二元谓词 {{c|pred}} 到分别由 {{c|proj1}} 与 {{c|proj2}} 投影的两个范围中的元素进行比较。

@2@ 同 {{v|1}}，但以 {{c|r1}} 与 {{c|r2}} 为源范围，如同以 {{c|ranges::begin(r1)}} 为 {{c|first1}}，以 {{c|ranges:begin(r2)}} 为 {{c|first2}}，以 {{c|ranges::end(r1)}} 为 {{c|last1}}，并以 {{c|ranges::end(r2)}} 为 {{c|last2}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|first1|last1|要检验的|sentinel=yes}}
{{par|r1|要检验的元素范围}}
{{par range|first2|last2|要用作前缀的|sentinel=yes}}
{{par|r2|要用作前缀的元素范围}}
{{par|pred|比较投影后元素的二元谓词}}
{{par|proj1|应用到要检验的元素范围的投影}}
{{par|proj2|应用到要用作前缀的元素范围的投影}}
{{par end}}

===返回值===
若第二范围匹配第一范围的前缀则为 {{c|true}}，否则为 {{c|false}}。

===复杂度===
线性：至多应用 {{c|min(N1, N2)}} 次谓词和两个投影。

===可能的实现===
{{eq fun|1=
struct starts_with_fn
{
    template&lt;std::input_iterator I1, std::sentinel_for&lt;I1&gt; S1,
             std::input_iterator I2, std::sentinel_for&lt;I2&gt; S2,
             class Pred = ranges::equal_to,
             class Proj1 = std::identity, class Proj2 = std::identity&gt;
    requires std::indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
    constexpr bool operator()(I1 first1, S1 last1, I2 first2, S2 last2,
                              Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const
    {
        return ranges::mismatch(std::move(first1), last1, std::move(first2), last2,
                                std::move(pred), std::move(proj1), std::move(proj2)
                               ).in2 == last2;
    }

    template&lt;ranges::input_range R1, ranges::input_range R2,
             class Pred = ranges::equal_to,
             class Proj1 = std::identity, class Proj2 = std::identity&gt;
    requires std::indirectly_comparable&lt;ranges::iterator_t&lt;R1&gt;,
                                        ranges::iterator_t&lt;R2&gt;,
                                        Pred, Proj1, Proj2&gt;
    constexpr bool operator()(R1&amp;&amp; r1, R2&amp;&amp; r2,
                              Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const
    {
        return (*this)(ranges::begin(r1), ranges::end(r1),
                       ranges::begin(r2), ranges::end(r2),
                       std::move(pred), std::move(proj1), std::move(proj2));
    }
};

inline constexpr starts_with_fn starts_with {};
}}

===注解===
{{feature test macro|__cpp_lib_ranges_starts_ends_with|std=C++23|value=202106L|{{tt|std::ranges::starts_with}}, {{lc|std::ranges::ends_with}}}}

===示例===
{{example|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;string_view&gt;

int main()
{
    using namespace std::literals;

    constexpr auto ascii_upper = [](char8_t c)
    {
        return u8'a' &lt;= c &amp;&amp; c &lt;= u8'z' ? static_cast&lt;char8_t&gt;(c + u8'A' - u8'a') : c;
    };

    constexpr auto cmp_ignore_case = [=](char8_t x, char8_t y)
    {
        return ascii_upper(x) == ascii_upper(y);
    };

    static_assert(std::ranges::starts_with("const_cast", "const"sv));
    static_assert(std::ranges::starts_with("constexpr", "const"sv));
    static_assert(!std::ranges::starts_with("volatile", "const"sv));

    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; std::ranges::starts_with(u8"Constantinopolis", u8"constant"sv,
                                          {}, ascii_upper, ascii_upper) &lt;&lt; ' '
              &lt;&lt; std::ranges::starts_with(u8"Istanbul", u8"constant"sv,
                                          {}, ascii_upper, ascii_upper) &lt;&lt; ' '
              &lt;&lt; std::ranges::starts_with(u8"Metropolis", u8"metro"sv,
                                          cmp_ignore_case) &lt;&lt; ' '
              &lt;&lt; std::ranges::starts_with(u8"Acropolis", u8"metro"sv,
                                          cmp_ignore_case) &lt;&lt; '\n';

    constexpr static auto v = { 1, 3, 5, 7, 9 };
    constexpr auto odd = [](int x) { return x % 2; };
    static_assert(std::ranges::starts_with(v, std::views::iota(1)
                                            {{!}} std::views::filter(odd)
                                            {{!}} std::views::take(3)));
}
|output=true false true false
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc ends_with}}
{{dsc inc|cpp/algorithm/ranges/dsc mismatch}}
{{dsc inc|cpp/string/basic_string/dsc starts_with}}
{{dsc inc|cpp/string/basic_string_view/dsc starts_with}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}