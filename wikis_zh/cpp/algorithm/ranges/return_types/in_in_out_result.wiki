{{cpp/ranges/title|in_in_out_result}}
{{cpp/algorithm/ranges/return_types/navbar}}

{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|since=c++20|1=
template&lt; class I1, class I2, class O &gt;
struct in_in_out_result;
}}
{{dcl end}}

{{tt|ranges::in_in_out_result}} 是类模板，提供存储三个迭代器为单个单元的方式。

{{cpp/algorithm/ranges/return_types/general_description}}

===模板形参===
{{par begin}}
{{par | I1, I2, O | {{tt|ranges::in_in_out_result}} 所存储的迭代器类型}}
{{par end}}

===数据成员===
{{dsc begin}}
{{dsc hitem|成员名字|定义}}
{{dsc mem obj|in1|nolink=true|{{tt|I1}} 类型的值（假定为迭代器）。}}
{{dsc mem obj|in2|nolink=true|{{tt|I2}} 类型的值（假定为迭代器）。}}
{{dsc mem obj|out|nolink=true|{{tt|O}} 类型的值（假定为迭代器）。}}
{{dsc end}}

这些成员都被声明为带有 {{attr|no_unique_address}} 属性。

===成员函数===
{{member|{{small|std::ranges::in_in_out_result::}}operator in_in_out_result&lt;II1, II2, OO&gt;|2=
{{dcl begin}}
{{dcl|num=1|1=
template&lt;class II1, class II2, class OO&gt;
requires std::convertible_to&lt;const I1&amp;, II1&gt; &amp;&amp;
         std::convertible_to&lt;const I2&amp;, II2&gt; &amp;&amp;
         std::convertible_to&lt;const O&amp;, OO&gt;
constexpr operator in_in_out_result&lt;II1, II2, OO&gt;() const &amp;;
}}
{{dcl|num=2|1=
template&lt;class II1, class II2, class OO&gt;
requires std::convertible_to&lt;I1, II1&gt; &amp;&amp;
         std::convertible_to&lt;I2, II2&gt; &amp;&amp;
         std::convertible_to&lt;O, OO&gt;
constexpr operator in_in_out_result&lt;II1, II2, OO&gt;() &amp;&amp;;
}}
{{dcl end}}
通过从 {{c|*this}} 的每个数据成员构造结果的对应成员，转换 {{c|*this}} 为结果。
@1@ 等价于 {{c|return {in1, in2, out};}}。
@2@ 等价于 {{c|return {std::move(in1), std::move(in2), std::move(out)};}}。
}}

===标准库===
下列标准库函数以 {{tt|ranges::in_in_out_result}} 为返回类型：

{{dsc begin}}
{{dsc h2|算法函数}}
{{dsc inc|cpp/algorithm/ranges/dsc transform}}
{{dsc inc|cpp/algorithm/ranges/dsc merge}}
{{dsc inc|cpp/algorithm/ranges/dsc set_union}}
{{dsc inc|cpp/algorithm/ranges/dsc set_intersection}}
{{dsc inc|cpp/algorithm/ranges/dsc set_symmetric_difference}}
{{dsc end}}

===概要===
{{source|1=
namespace std::ranges
{
    template&lt;class I1, class I2, class O&gt;
    struct in_in_out_result
    {
        [[no_unique_address]] I1 in1;
        [[no_unique_address]] I2 in2;
        [[no_unique_address]] O  out;

        template&lt;class II1, class II2, class OO&gt;
        requires std::convertible_to&lt;const I1&amp;, II1&gt; &amp;&amp;
                 std::convertible_to&lt;const I2&amp;, II2&gt; &amp;&amp;
                 std::convertible_to&lt;const O&amp;, OO&gt;
        constexpr operator in_in_out_result&lt;II1, II2, OO&gt;() const &amp;
        {
            return {in1, in2, out};
        }

        template&lt;class II1, class II2, class OO&gt;
        requires std::convertible_to&lt;I1, II1&gt; &amp;&amp;
                 std::convertible_to&lt;I2, II2&gt; &amp;&amp;
                 std::convertible_to&lt;O, OO&gt;
        constexpr operator in_in_out_result&lt;II1, II2, OO&gt;() &amp;&amp;
        {
            return {std::move(in1), std::move(in2), std::move(out)};
        }
    };
}
}}

===注解===
{{cpp/algorithm/ranges/notes return_types}}

===示例===
{{example|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;ranges&gt;

void print(auto rem, auto first, auto last)
{
    for (std::cout &lt;&lt; rem &lt;&lt; ": "; first != last; ++first)
        std::cout &lt;&lt; *first &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    constexpr static auto in1 = {1, 2, 3, 4, 5, 5};
    constexpr static auto in2 = {3, 4, 5, 6, 7};
    std::array&lt;int, std::size(in1) + std::size(in2)&gt; out;

    const auto result = std::ranges::merge(in1, in2, out.begin());
    print("in1", in1.begin(), result.in1);
    print("in2", in2.begin(), result.in2);
    print("out", out.begin(), result.out);
}
|output=
in1: 1 2 3 4 5 5 
in2: 3 4 5 6 7 
out: 1 2 3 3 4 4 5 5 5 6 7 
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/utility/dsc pair}}
{{dsc inc|cpp/utility/dsc tuple}}
{{dsc end}}

{{langlinks|cs|de|en|es|fr|it|ja|ko|pl|pt|ru}}