{{cpp/ranges/title|stable_sort}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcla|anchor=no|num=1|since=c++20|constexpr=c++26|1=
template&lt; std::random_access_iterator I, std::sentinel_for&lt;I&gt; S,
          class Comp = ranges::less, class Proj = std::identity &gt;
requires std::sortable&lt;I, Comp, Proj&gt;
    I stable_sort( I first, S last, Comp comp = {}, Proj proj = {} );
}}
{{dcla|anchor=no|num=2|since=c++20|constexpr=c++26|1=
template&lt; ranges::random_access_range R, class Comp = ranges::less,
          class Proj = std::identity &gt;
requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
ranges::borrowed_iterator_t&lt;R&gt;
    stable_sort( R&amp;&amp; r, Comp comp = {}, Proj proj = {} );
}}
{{dcl end}}

以非降序排序范围 {{range|first|last}} 中的元素。等价元素的顺序是''稳定''的，即保证得到保持。

若对于指向序列的任何迭代器 {{tt|it}} 与使得 {{tt|it + n}} 为指向序列元素的合法迭代器的任何非负整数 {{tt|n}}，{{c|std::invoke(comp, std::invoke(proj, *(it + n)), std::invoke(proj, *it)))}} 求值均为 {{c|false}}，则称序列为按照比较器 {{c|comp}} 与投影 {{c|proj}} ''有序''。

@1@ 用给定的二元比较函数 {{c|comp}} 比较元素。
@2@ 同 {{v|1}}，但以 {{c|r}} 为范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要排序的|sentinel=yes}}
{{par|r|要排序的范围}}
{{par|comp|应用到投影后元素的比较器}}
{{par|proj|应用到元素的投影}}
{{par end}}

===返回值===
等于 {{c|last}} 的迭代器。

===复杂度===
若额外内存可用则比较 {{mathjax-or|\(\scriptsize N\cdot\log{(N)}\)|N&amp;middot;log(N)}} 次；其中 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|ranges::distance(first, last)}}。否则比较 {{mathjax-or|\(\scriptsize N\cdot\log^2{(N)}\)|N&amp;middot;log&amp;sup2;(N)}} 次。两种情况下都进行二倍数量的投影。

===注解===
{{feature test macro|__cpp_lib_constexpr_algorithms|{{c/core|constexpr}} 稳定排序|value=202306L|std=C++26}}

===可能的实现===
此实现仅展示无额外内存可用时使用的较慢的算法。参阅 [https://github.com/microsoft/STL/blob/e745bad3b1d05b5b19ec652d68abb37865ffa454/stl/inc/algorithm#L7842-L8094 MSVC STL] 与 [https://github.com/gcc-mirror/gcc/blob/54258e22b0846aaa6bd3265f592feb161eecda75/libstdc%2B%2B-v3/include/bits/ranges_algo.h#L1836-L1862 libstdc++] 中的实现。
{{eq fun|1=
struct stable_sort_fn
{
    template&lt;std::random_access_iterator I, std::sentinel_for&lt;I&gt; S,
             class Comp = ranges::less, class Proj = std::identity&gt;
    requires std::sortable&lt;I, Comp, Proj&gt;
    constexpr //&lt; since C++26
    I operator()(I first, S last, Comp comp = {}, Proj proj = {}) const
    {
        auto count = ranges::distance(first, last);
        auto mid = first + count / 2;
        auto last_it = first + count;

        if (count &lt;= 1)
            return last_it;

        (*this)(first, mid, std::ref(comp), std::ref(proj));
        (*this)(mid, last_it, std::ref(comp), std::ref(proj));

        ranges::inplace_merge(first, mid, last_it);

        return last_it;
    }

    template&lt;ranges::random_access_range R, class Comp = ranges::less,
             class Proj = std::identity&gt;
    requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
    constexpr //&lt; since C++26
    ranges::borrowed_iterator_t&lt;R&gt; operator()(R&amp;&amp; r, Comp comp = {}, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(comp), std::move(proj));
    }
};

inline constexpr stable_sort_fn stable_sort{};
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;

void print(const auto&amp; seq)
{
    for (const auto&amp; elem : seq)
        std::cout &lt;&lt; elem &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

struct Particle
{
    std::string name; double mass; // MeV
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Particle&amp; p)
    {
        return os &lt;&lt; '\n' &lt;&lt; std::left &lt;&lt; std::setw(8) &lt;&lt; p.name &lt;&lt; " : " &lt;&lt; p.mass;
    }
};

int main()
{
    std::array s{5, 7, 4, 2, 8, 6, 1, 9, 0, 3};

    // 以默认的 operator&lt; 排序
    std::ranges::stable_sort(s);
    print(s);

    // 以标准库比较函数对象排序
    std::ranges::stable_sort(s, std::ranges::greater());
    print(s);

    // 以定制函数对象排序
    struct
    {
        bool operator()(int a, int b) const { return a &lt; b; }
    } customLess;
    std::ranges::stable_sort(s.begin(), s.end(), customLess);
    print(s);

    // 以 lambda 表达式排序
    std::ranges::stable_sort(s, [](int a, int b) { return a &gt; b; });
    print(s);

    // 以投影排序
    Particle particles[]
    {
        {"Electron", 0.511}, {"Muon", 105.66}, {"Tau", 1776.86},
        {"Positron", 0.511}, {"Proton", 938.27}, {"Neutron", 939.57}
    };
    print(particles);
    std::ranges::stable_sort(particles, {}, &amp;Particle::name); //&lt; 按名称排序
    print(particles);
    std::ranges::stable_sort(particles, {}, &amp;Particle::mass); //&lt; 按质量排序
    print(particles);
}
|output=
0 1 2 3 4 5 6 7 8 9
9 8 7 6 5 4 3 2 1 0
0 1 2 3 4 5 6 7 8 9
9 8 7 6 5 4 3 2 1 0

Electron : 0.511
Muon     : 105.66
Tau      : 1776.86
Positron : 0.511
Proton   : 938.27
Neutron  : 939.57

Electron : 0.511
Muon     : 105.66
Neutron  : 939.57
Positron : 0.511
Proton   : 938.27
Tau      : 1776.86

Electron : 0.511
Positron : 0.511
Muon     : 105.66
Proton   : 938.27
Neutron  : 939.57
Tau      : 1776.86
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc sort}}
{{dsc inc|cpp/algorithm/ranges/dsc partial_sort}}
{{dsc inc|cpp/algorithm/ranges/dsc stable_partition}}
{{dsc inc|cpp/algorithm/dsc stable_sort}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}