{{cpp/ranges/title|partial_sort}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl|since=c++20|num=1|1=
template&lt; std::random_access_iterator I, std::sentinel_for&lt;I&gt; S,
          class Comp = ranges::less, class Proj = std::identity &gt;
requires std::sortable&lt;I, Comp, Proj&gt;
constexpr I
    partial_sort( I first, I middle, S last, Comp comp = {}, Proj proj = {} );
}}
{{dcl|since=c++20|num=2|1=
template&lt; ranges::random_access_range R,
          class Comp = ranges::less, class Proj = std::identity &gt;
requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    partial_sort( R&amp;&amp; r, ranges::iterator_t&lt;R&gt; middle, Comp comp = {},
                  Proj proj = {} );
}}
{{dcl end}}

@1@ 重排元素，使得范围 {{range|first|middle}} 含有范围 {{range|first|last}} 中 {{c|middle - first}} 个最小的元素。

@@ ''不''保证保持相等元素间的顺序。范围 {{range|middle|last}} 中剩余元素的顺序''未指定''。

@@ 用给定的二元比较函数 {{c|comp}} 比较，用 {{c|proj}} 函数对象投影元素。

@2@ 同 {{v|1}}，但以 {{c|r}} 为范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要重排的|sentinel=yes}}
{{par|r|要重排的元素范围}}
{{par|middle|将对范围 {{range|first|middle}} 排序}}
{{par|comp|应用到投影后元素的比较器}}
{{par|proj|应用到元素的投影}}
{{par end}}

===返回值===
等于 {{c|last}} 的迭代器。

===复杂度===
{{mathjax-or|\(\scriptsize \mathcal{O}(N\cdot\log{(M)})\)|𝓞(N&amp;middot;log(M))}} 次比较和二倍次数的投影，其中 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|ranges::distance(first, last)}}，{{mathjax-or|\(\scriptsize M\)|M}} 为 {{c|ranges::distance(first, middle)}}。

===可能的实现===
{{eq fun|1=
struct partial_sort_fn
{
    template&lt;std::random_access_iterator I, std::sentinel_for&lt;I&gt; S,
             class Comp = ranges::less, class Proj = std::identity&gt;
    requires std::sortable&lt;I, Comp, Proj&gt;
    constexpr I
        operator()(I first, I middle, S last, Comp comp = {}, Proj proj = {}) const
    {
        if (first == middle)
            return ranges::next(first, last);
        ranges::make_heap(first, middle, comp, proj);
        auto it {middle};
        for (; it != last; ++it)
        {
            if (std::invoke(comp, std::invoke(proj, *it), std::invoke(proj, *first)))
            {
                ranges::pop_heap(first, middle, comp, proj);
                ranges::iter_swap(middle - 1, it);
                ranges::push_heap(first, middle, comp, proj);
            }
        }
        ranges::sort_heap(first, middle, comp, proj);
        return it;
    }

    template&lt;ranges::random_access_range R, class Comp = ranges::less,
             class Proj = std::identity&gt;
    requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, ranges::iterator_t&lt;R&gt; middle, Comp comp = {}, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), std::move(middle), ranges::end(r),
                       std::move(comp), std::move(proj));
    }
};

inline constexpr partial_sort_fn partial_sort {};
}}

===示例===
{{example|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

void print(const auto&amp; v)
{
    for (const char e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

void underscore(int n)
{
    while (n-- &gt; 0)
        std::cout &lt;&lt; "^ ";
    std::cout &lt;&lt; '\n';
}

int main()
{
    static_assert('A' &lt; 'a');
    std::vector&lt;char&gt; v {'x', 'P', 'y', 'C', 'z', 'w', 'P', 'o'};
    print(v);
    const int m {3};
    std::ranges::partial_sort(v, v.begin() + m);
    print(v), underscore(m);

    static_assert('1' &lt; 'a');
    std::string s {"3a1b41c5"};
    print(s);
    std::ranges::partial_sort(s.begin(), s.begin() + m, s.end(), std::greater {});
    print(s), underscore(m);
}
|output=
x P y C z w P o
C P P y z x w o
^ ^ ^
3 a 1 b 4 1 c 5
c b a 1 3 1 4 5
^ ^ ^
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc partial_sort_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc sort}}
{{dsc inc|cpp/algorithm/ranges/dsc stable_sort}}
{{dsc inc|cpp/algorithm/ranges/dsc nth_element}}
{{dsc inc|cpp/algorithm/ranges/dsc make_heap}}
{{dsc inc|cpp/algorithm/ranges/dsc pop_heap}}
{{dsc inc|cpp/algorithm/ranges/dsc push_heap}}
{{dsc inc|cpp/algorithm/ranges/dsc sort_heap}}
{{dsc inc|cpp/algorithm/dsc partial_sort}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}