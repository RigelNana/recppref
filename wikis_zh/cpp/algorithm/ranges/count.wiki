{{cpp/ranges/title|count|count_if}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl rev begin|num=1}}
{{dcla|anchor=版本_1|since=c++20|until=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class T, class Proj = std::identity &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr std::iter_difference_t&lt;I&gt;
    count( I first, S last, const T&amp; value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;I, Proj&gt; &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr std::iter_difference_t&lt;I&gt;
    count( I first, S last, const T&amp; value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::input_range R, class T, class Proj = std::identity &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr ranges::range_difference_t&lt;R&gt;
    count( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt; &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr ranges::range_difference_t&lt;R&gt;
    count( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcla|num=3|since=c++20|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr std::iter_difference_t&lt;I&gt;
    count_if( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++20|num=4|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
constexpr ranges::range_difference_t&lt;R&gt;
    count_if( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcl end}}

返回范围 {{range|first|last}} 中满足特定判别标准的元素数。
@1@ 计数等于 {{c|value}} 的元素数。
@3@ 计数谓词 {{c|p}} 对其返回 {{c|true}} 的元素数。
@2,4@ 同 {{v|1,3}}，但以 {{c|r}} 为源范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要检验的|sentinel=yes}}
{{par|r|要检验的元素范围}}
{{par|value|要搜索的值}}
{{par|pred|应用到被投影元素的谓词}}
{{par|proj|应用到元素的投影}}
{{par end}}

===返回值===
范围中满足条件的元素数。

===复杂度===
准确 {{c|last}} - {{c|first}} 次比较和投影。

===注解===
对于无任何判别标准的范围中的元素数，见 {{lc|std::ranges::distance}} 。

{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|算法中的[[cpp/language/list initialization|列表初始化]] {{vl|1,2}}}}

===可能的实现===
{{eq impl
|title1=count (1)|ver1=1|1=
struct count_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity, class T = std::projected_value_t&lt;I, Proj&gt;&gt;
    requires std::indirect_binary_predicate&lt;ranges::equal_to,
                                            std::projected&lt;I, Proj&gt;, const T*&gt;
    constexpr std::iter_difference_t&lt;I&gt;
        operator()(I first, S last, const T&amp; value, Proj proj = {}) const
    {
        std::iter_difference_t&lt;I&gt; counter = 0;
        for (; first != last; ++first)
            if (std::invoke(proj, *first) == value)
                ++counter;
        return counter;
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity
             class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt;
    requires std::indirect_binary_predicate&lt;ranges::equal_to,
                                            std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
                                            const T*&gt;
    constexpr ranges::range_difference_t&lt;R&gt;
        operator()(R&amp;&amp; r, const T&amp; value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), value, std::ref(proj));
    }
};

inline constexpr count_fn count;
|title2=count_if (3)|ver2=3|2=
struct count_if_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr std::iter_difference_t&lt;I&gt;
        operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        std::iter_difference_t&lt;I&gt; counter = 0;
        for (; first != last; ++first)
            if (std::invoke(pred, std::invoke(proj, *first)))
                ++counter;
        return counter;
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity,
             std::indirect_unary_predicate&lt;
                 std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    constexpr ranges::range_difference_t&lt;R&gt;
        operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r),
                       std::ref(pred), std::ref(proj));
    }
};

inline constexpr count_if_fn count_if;
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
 
int main()
{
    std::vector&lt;int&gt; v{1, 2, 3, 4, 4, 3, 7, 8, 9, 10};
    
    namespace ranges = std::ranges;
    
    // 确定 std::vector 中有多少整数匹配目标值。
    int target1 = 3;
    int target2 = 5;
    int num_items1 = ranges::count(v.begin(), v.end(), target1);
    int num_items2 = ranges::count(v, target2);
    std::cout &lt;&lt; "数字：" &lt;&lt; target1 &lt;&lt; " 计数：" &lt;&lt; num_items1 &lt;&lt; '\n';
    std::cout &lt;&lt; "数字：" &lt;&lt; target2 &lt;&lt; " 计数：" &lt;&lt; num_items2 &lt;&lt; '\n';
    
    // 用 lambda 表达式计数被 3 整除的元素。
    int num_items3 = ranges::count_if(v.begin(), v.end(), [](int i){ return i % 3 == 0; });
    std::cout &lt;&lt; "可以被 3 整除的数字：" &lt;&lt; num_items3 &lt;&lt; '\n';
    
    // 用 lambda 表达式计数被 11 整除的元素。
    int num_items11 = ranges::count_if(v, [](int i){ return i % 11 == 0; });
    std::cout &lt;&lt; "可以被 11 整除的数字：" &lt;&lt; num_items11 &lt;&lt; '\n';

    std::vector&lt;std::complex&lt;double&gt;&gt; nums{&lt;!----&gt;{4, 2}, {1, 3}, {4, 2}&lt;!----&gt;};
    #ifdef __cpp_lib_algorithm_default_value_type
        auto c = ranges::count(nums, {4, 2});
    #else
        auto c = ranges::count(nums, std::complex&lt;double&gt;{4, 2});
    #endif
    assert(c == 2);
}
|output=
数字：3 计数：2
数字：5 计数：0
可以被 3 整除的数字：3
可以被 11 整除的数字：0
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/iterator/ranges/dsc distance}}
{{dsc inc|cpp/ranges/dsc view_counted}}
{{dsc inc|cpp/ranges/dsc filter_view}}
{{dsc inc|cpp/algorithm/dsc count}}
{{dsc end}}

{{langlinks|en|es|ja}}