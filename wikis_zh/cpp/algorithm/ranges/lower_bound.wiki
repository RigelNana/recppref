{{cpp/ranges/title|lower_bound}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl rev begin|num=1}}
{{dcla|anchor=版本_1|since=c++20|until=c++26|1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
          class T, class Proj = std::identity,
          std::indirect_strict_weak_order
              &lt;const T*, std::projected&lt;I, Proj&gt;&gt; Comp = ranges::less &gt;
constexpr I lower_bound( I first, S last, const T&amp; value,
                         Comp comp = {}, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;I, Proj&gt;,
          std::indirect_strict_weak_order
              &lt;const T*, std::projected&lt;I, Proj&gt;&gt; Comp = ranges::less &gt;
constexpr I lower_bound( I first, S last, const T&amp; value,
                         Comp comp = {}, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::forward_range R,
          class T, class Proj = std::identity,
          std::indirect_strict_weak_order
              &lt;const T*, std::projected&lt;ranges::iterator_t&lt;R&gt;,
                                        Proj&gt;&gt; Comp = ranges::less &gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    lower_bound( R&amp;&amp; r, const T&amp; value, Comp comp = {}, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::forward_range R,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;
          std::indirect_strict_weak_order
              &lt;const T*, std::projected&lt;ranges::iterator_t&lt;R&gt;,
                                        Proj&gt;&gt; Comp = ranges::less &gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    lower_bound( R&amp;&amp; r, const T&amp; value, Comp comp = {}, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl end}}

@1@ 返回指向范围 {{range|first|last}} 中首个''不小于''（即大于或等于）{{c|value}} 的元素的迭代器，或若找不到这种元素时返回 {{c|last}}。
范围 {{range|first|last}} 必须已按照表达式 {{c|std::invoke(comp, std::invoke(proj, element), value)}} 划分，即所有该表达式对其为 {{c|true}} 的元素必须前趋所有该表达式对其为 {{c|false}} 的元素。完全有序范围符合此判别标准。

@2@ 同 {{v|1}}，但以 {{c|r}} 为源范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要检验的|range=部分有序|sentinel=yes}}
{{par|r|要检验的部分有序范围}}
{{par|value|要与投影后元素比较的值}}
{{par|comp|应用到投影后元素的比较谓词}}
{{par|proj|应用到元素的投影}}
{{par end}}

===返回值===
指向首个''不小于'' {{c|value}} 的元素的迭代器，或若找不到这种元素则为 {{c|last}}。

===复杂度===
比较和应用投影的次数与 {{c|first}} 和 {{c|last}} 之间的距离成对数（至多比较和应用投影 {{math|log{{su|b=2}}(last - first) + O(1)}} 次）。然而，对于不实现 {{lconcept|random_access_iterator}} 的迭代器，迭代器自增次数为线性。

===注解===
{{tt|std::ranges::lower_bound}} 实现在经投影后完全有序范围（或更通用地，相对于 {{c|value}} 部分有序的范围）上的二叉搜索算法。因此，{{lc|ranges::binary_search|std::ranges::binary_search}} 可以用它实现。

{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|算法中的[[cpp/language/list initialization|列表初始化]] {{vl|1,2}}}}

===可能的实现===

{{eq fun|1=
struct lower_bound_fn
{
    template&lt;std::forward_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             class T = std::projected_value_t&lt;I, Proj&gt;,
             std::indirect_strict_weak_order
                 &lt;const T*, std::projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
    constexpr I operator()(I first, S last, const T&amp; value,
                           Comp comp = {}, Proj proj = {}) const
    {
        I it;
        std::iter_difference_t&lt;I&gt; count, step;
        count = std::ranges::distance(first, last);
        
        while (count &gt; 0)
        {
            it = first;
            step = count / 2;
            ranges::advance(it, step, last);
            if (comp(std::invoke(proj, *it), value))
            {
                first = ++it;
                count -= step + 1;
            }
            else
                count = step;
        }
        return first;
    }
    
    template&lt;ranges::forward_range R, class Proj = std::identity,
          class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;
          std::indirect_strict_weak_order
              &lt;const T*, std::projected&lt;ranges::iterator_t&lt;R&gt;,
                                        Proj&gt;&gt; Comp = ranges::less&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, const T&amp; value, Comp comp = {}, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), value,
                       std::ref(comp), std::ref(proj));
    }
};

inline constexpr lower_bound_fn lower_bound;
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

namespace ranges = std::ranges;

template&lt;std::forward_iterator I, std::sentinel_for&lt;I&gt; S, class T,
         class Proj = std::identity,
         std::indirect_strict_weak_order
             &lt;const T*, std::projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
constexpr I binary_find(I first, S last, const T&amp; value, Comp comp = {}, Proj proj = {})
{
    first = ranges::lower_bound(first, last, value, comp, proj);
    return first != last &amp;&amp; !comp(value, proj(*first)) ? first : last;
}

int main()
{
    std::vector data{1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5};
    //                                 ^^^^^^^^^^
    auto lower = ranges::lower_bound(data, 4);
    auto upper = ranges::upper_bound(data, 4);

    std::cout &lt;&lt; "found a range [" &lt;&lt; ranges::distance(data.cbegin(), lower)
              &lt;&lt; ", " &lt;&lt; ranges::distance(data.cbegin(), upper) &lt;&lt; ") = { ";
    ranges::copy(lower, upper, std::ostream_iterator&lt;int&gt;(std::cout, " "));
    std::cout &lt;&lt; "}\n";

    // 经典二分搜索，仅若存在才返回值

    data = {1, 2, 4, 8, 16};
    //               ^
    auto it = binary_find(data.cbegin(), data.cend(), 8); // '5' would return end()

    if (it != data.cend())
        std::cout &lt;&lt; *it &lt;&lt; " found at index " &lt;&lt; ranges::distance(data.cbegin(), it);

    using CD = std::complex&lt;double&gt;;
    std::vector&lt;CD&gt; nums{{1, 0}, {2, 2}, {2, 1}, {3, 0}};
    auto cmpz = [](CD x, CD y) { return x.real() &lt; y.real(); };
    #ifdef __cpp_lib_algorithm_default_value_type
        auto it2 = ranges::lower_bound(nums, {2, 0}, cmpz);
    #else
        auto it2 = ranges::lower_bound(nums, CD{2, 0}, cmpz);
    #endif
    assert((*it2 == CD{2, 2}));
}
|output=
found a range [6, 10) = { 4 4 4 4 }
8 found at index 3
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc equal_range}}
{{dsc inc|cpp/algorithm/ranges/dsc partition}}
{{dsc inc|cpp/algorithm/ranges/dsc partition_point}}
{{dsc inc|cpp/algorithm/ranges/dsc upper_bound}}
{{dsc inc|cpp/algorithm/dsc lower_bound}}
{{dsc end}}

{{langlinks|en|es|ja}}