{{cpp/ranges/title|inplace_merge}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|è°ƒç”¨ç­¾å}}
{{dcla|anchor=no|num=1|since=c++20|constexpr=c++26|1=
template&lt; std::bidirectional_iterator I, std::sentinel_for&lt;I&gt; S,
          class Comp = ranges::less, class Proj = std::identity &gt;
requires std::sortable&lt;I, Comp, Proj&gt;
    I inplace_merge( I first, I middle, S last,
                     Comp comp = {}, Proj proj = {} );
}}
{{dcla|anchor=no|num=2|since=c++20|constexpr=c++26|1=
template&lt; ranges::bidirectional_range R, class Comp = ranges::less,
          class Proj = std::identity &gt;
requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
ranges::borrowed_iterator_t&lt;R&gt;
    inplace_merge( R&amp;&amp; r, ranges::iterator_t&lt;R&gt; middle,
                   Comp comp = {}, Proj proj = {} );
}}
{{dcl end}}

å°†ä¸¤ä¸ª''æœ‰åº''èŒƒå›´ {{range|first|middle}} ä¸ {{range|middle|last}} å½’å¹¶åˆ°ä¸€ä¸ª''æœ‰åº''èŒƒå›´ {{range|first|last}} ä¸­ã€‚

è‹¥å¯¹åº”æŒ‡å‘åºåˆ—çš„ä»»ä½•è¿­ä»£å™¨ {{tt|it}} ä¸ä½¿å¾— {{tt|it + n}} ä¸ºæŒ‡å‘åºåˆ—å…ƒç´ çš„åˆæ³•è¿­ä»£å™¨çš„ä»»ä½•éè´Ÿæ•´æ•° {{tt|n}}ï¼Œ {{c|std::invoke(comp, std::invoke(proj, *(it + n)), std::invoke(proj, *it)))}} æ±‚å€¼ä¸º {{c|false}}ï¼Œåˆ™ç§°åºåˆ—ä¸ºæŒ‰ç…§æ¯”è¾ƒå™¨ {{c|comp}} ä¸æŠ•å½± {{c|proj}} ''æœ‰åº''ã€‚

æ­¤å½’å¹¶å‡½æ•°æ˜¯''ç¨³å®š''çš„ï¼Œè¿™è¡¨ç¤ºå¯¹äºåŸåœ¨ä¸¤ä¸ªèŒƒå›´ä¸­çš„ç­‰ä»·å…ƒç´ ï¼Œæ¥è‡ªç¬¬ä¸€èŒƒå›´çš„å…ƒç´ ï¼ˆä¿æŒå…¶åŸé¡ºåºï¼‰å…ˆäºæ¥è‡ªç¬¬äºŒèŒƒå›´çš„å…ƒç´ ï¼ˆä¿æŒå…¶åŸé¡ºåºï¼‰ã€‚

@1@ ç”¨ç»™å®šçš„äºŒå…ƒæ¯”è¾ƒå‡½æ•° {{c|comp}} ä¸æŠ•å½±å¯¹è±¡ {{c|proj}} æ¯”è¾ƒå…ƒç´ ï¼Œè€ŒèŒƒå›´å¿…é¡»æŒ‰åŒæ ·æ–¹å¼æ’åºã€‚

@2@ åŒ {{v|1}}ï¼Œä½†ä»¥ {{c|r}} ä¸ºèŒƒå›´ï¼Œå¦‚åŒä»¥ {{c|ranges::begin(r)}} ä¸º {{c|first}} å¹¶ä»¥ {{c|ranges::end(r)}} ä¸º {{c|last}}ã€‚

{{cpp/ranges/niebloid}}

===å‚æ•°===
{{par begin}}
{{par range|first|middle|è¦å½’å¹¶çš„|range=ç¬¬ä¸€ä¸ªæœ‰åº}}
{{par range|middle|last|è¦å½’å¹¶çš„|range=ç¬¬äºŒä¸ªæœ‰åº|sentinel=yes}}
{{par|r|è¦åŸä½å½’å¹¶çš„å…ƒç´  {{lconcept|range}}}}
{{par|comp|åº”ç”¨åˆ°æŠ•å½±åå…ƒç´ çš„æ¯”è¾ƒå™¨}}
{{par|proj|åº”ç”¨åˆ°èŒƒå›´ä¸­å…ƒç´ çš„æŠ•å½±}}
{{par end}}

===è¿”å›å€¼===
ç­‰äº {{c|last}} çš„è¿­ä»£å™¨ã€‚

===å¤æ‚åº¦===
è‹¥é¢å¤–å†…å­˜å¯ç”¨ï¼Œåˆ™å‡†ç¡®æ¯”è¾ƒ {{c|N âˆ’ 1}} æ¬¡ï¼Œå…¶ä¸­ {{c|1= N = ranges::distance(first, last)}}ã€‚å¦åˆ™æ¯”è¾ƒ {{mathjax-or|\(\scriptsize \mathcal{O}(N\cdot\log{(N)})\)|ğ“(Nâ€¢log(N))}} æ¬¡ã€‚å¦å¤–åœ¨ä¸¤ç§æƒ…å†µä¸‹éƒ½è¿›è¡ŒäºŒå€æ¬¡æ•°çš„æŠ•å½±ã€‚

===æ³¨è§£===
æ­¤å‡½æ•°å°è¯•åˆ†é…ä¸´æ—¶ç¼“å†²åŒºã€‚è‹¥åˆ†é…å¤±è´¥ï¼Œåˆ™é€‰æ‹©è¾ƒä½æ•ˆçš„ç®—æ³•ã€‚

{{feature test macro|__cpp_lib_constexpr_algorithms|{{c/core|constexpr}} ç¨³å®šæ’åº|value=202306L|std=C++26}}

===å¯èƒ½çš„å®ç°===
æ­¤å®ç°ä»…å±•ç¤ºæ— é¢å¤–å†…å­˜å¯ç”¨æ—¶ä½¿ç”¨çš„è¾ƒæ…¢çš„ç®—æ³•ã€‚å‚é˜… [https://github.com/microsoft/STL/blob/e745bad3b1d05b5b19ec652d68abb37865ffa454/stl/inc/algorithm#L7131-L7235 MSVC STL] ä¸ [https://github.com/gcc-mirror/gcc/blob/54258e22b0846aaa6bd3265f592feb161eecda75/libstdc%2B%2B-v3/include/bits/ranges_algo.h#L2573-L2602 libstdc++] ä¸­çš„å®ç°ã€‚
{{eq fun|1=&lt;!-- å¤åˆ¶è‡ª libstdc++ --&gt;
struct inplace_merge_fn
{
    template&lt;std::bidirectional_iterator I, std::sentinel_for&lt;I&gt; S,
             class Comp = ranges::less, class Proj = std::identity&gt;
    requires std::sortable&lt;I, Comp, Proj&gt;
    constexpr I operator()(I first, I middle, S last, Comp comp = {}, Proj proj = {}) const
    {
        I last_it = ranges::next(middle, last);
        inplace_merge_slow(first, middle, last_it,
                           ranges::distance(first, middle),
                           ranges::distance(middle, last_it),
                           std::ref(comp), std::ref(proj));
        return last_it;
    }

    template&lt;ranges::bidirectional_range R, class Comp = ranges::less,
             class Proj = std::identity&gt;
    requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, ranges::iterator_t&lt;R&gt; middle,
                   Comp comp = {}, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), std::move(middle), ranges::end(r),
                       std::move(comp), std::move(proj));
    }

private:
    template&lt;class I, class Comp, class Proj&gt;
    static constexpr void inplace_merge_slow(I first, I middle, I last,
                                             std::iter_difference_t&lt;I&gt; n1,
                                             std::iter_difference_t&lt;I&gt; n2,
                                             Comp comp, Proj proj)
    {
        if (n1 == 0 {{!!}} n2 == 0)
            return;
        if (n1 + n2 == 2 &amp;&amp; comp(proj(*middle), proj(*first)))
        {
            ranges::iter_swap(first, middle);
            return;
        }

        I cut1 = first, cut2 = middle;
        std::iter_difference_t&lt;I&gt; d1{}, d2{};

        if (n1 &gt; n2)
        {
            d1 = n1 / 2;
            ranges::advance(cut1, d1);
            cut2 = ranges::lower_bound(middle, last, *cut1,
                                       std::ref(comp), std::ref(proj));
            d2 = ranges::distance(middle, cut2);
        }
        else
        {
            d2 = n2 / 2;
            ranges::advance(cut2, d2);
            cut1 = ranges::upper_bound(first, middle, *cut2,
                                       std::ref(comp), std::ref(proj));
            d1 = ranges::distance(first, cut1);
        }

        I new_middle = ranges::rotate(cut1, middle, cut2);
        inplace_merge_slow(first, cut1, new_middle, d1, d2,
                           std::ref(comp), std::ref(proj));
        inplace_merge_slow(new_middle, cut2, last, n1 - d1, n2 - d2,
                           std::ref(comp), std::ref(proj));
    }
};

inline constexpr inplace_merge_fn inplace_merge {};
}}

===ç¤ºä¾‹===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;complex&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

void print(auto const&amp; v, auto const&amp; rem, int middle = -1)
{
    for (int i{}; auto n : v)
        std::cout &lt;&lt; (i++ == middle ? "â”‚ " : "") &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; rem &lt;&lt; '\n';
}

template&lt;std::random_access_iterator I, std::sentinel_for&lt;I&gt; S&gt;
requires std::sortable&lt;I&gt;
void merge_sort(I first, S last)
{
    if (last - first &gt; 1)
    {
        I middle{first + (last - first) / 2};
        merge_sort(first, middle);
        merge_sort(middle, last);
        std::ranges::inplace_merge(first, middle, last);
    }
}

int main()
{
    // å®šåˆ¶å½’å¹¶æ’åºæ¼”ç¤º
    std::vector v {8, 2, 0, 4, 9, 8, 1, 7, 3};
    print(v, ": before sort");
    merge_sort(v.begin(), v.end());
    print(v, ": after sort\n");

    // ä»¥æ¯”è¾ƒå‡½æ•°å¯¹è±¡å’ŒæŠ•å½±è¿›è¡Œå½’å¹¶
    using CI = std::complex&lt;int&gt;;
    std::vector&lt;CI&gt; r{{0,1}, {0,2}, {0,3}, {1,1}, {1,2}};
    const auto middle{std::ranges::next(r.begin(), 3)};
    auto comp{std::ranges::less{}&lt;!----&gt;};
    auto proj{[](CI z) { return z.imag(); }&lt;!----&gt;};

    print(r, ": before merge", middle - r.begin());
    std::ranges::inplace_merge(r, middle, comp, proj);
    print(r, ": after merge");
}
 | output=
8 2 0 4 9 8 1 7 3 : before sort
0 1 2 3 4 7 8 8 9 : after sort

(0,1) (0,2) (0,3) â”‚ (1,1) (1,2) : before merge
(0,1) (1,1) (0,2) (1,2) (0,3) : after merge
}}

===å‚é˜…===
{{dsc begin}}
{{dsc inc | cpp/algorithm/ranges/dsc merge}}
{{dsc inc | cpp/algorithm/ranges/dsc set_union}}
{{dsc inc | cpp/algorithm/ranges/dsc is_sorted}}
{{dsc inc | cpp/algorithm/ranges/dsc sort}}
{{dsc inc | cpp/algorithm/dsc inplace_merge}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}