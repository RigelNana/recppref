{{cpp/ranges/title|inplace_merge}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcla|anchor=no|num=1|since=c++20|constexpr=c++26|1=
template&lt; std::bidirectional_iterator I, std::sentinel_for&lt;I&gt; S,
          class Comp = ranges::less, class Proj = std::identity &gt;
requires std::sortable&lt;I, Comp, Proj&gt;
    I inplace_merge( I first, I middle, S last,
                     Comp comp = {}, Proj proj = {} );
}}
{{dcla|anchor=no|num=2|since=c++20|constexpr=c++26|1=
template&lt; ranges::bidirectional_range R, class Comp = ranges::less,
          class Proj = std::identity &gt;
requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
ranges::borrowed_iterator_t&lt;R&gt;
    inplace_merge( R&amp;&amp; r, ranges::iterator_t&lt;R&gt; middle,
                   Comp comp = {}, Proj proj = {} );
}}
{{dcl end}}

将两个''有序''范围 {{range|first|middle}} 与 {{range|middle|last}} 归并到一个''有序''范围 {{range|first|last}} 中。

若对应指向序列的任何迭代器 {{tt|it}} 与使得 {{tt|it + n}} 为指向序列元素的合法迭代器的任何非负整数 {{tt|n}}， {{c|std::invoke(comp, std::invoke(proj, *(it + n)), std::invoke(proj, *it)))}} 求值为 {{c|false}}，则称序列为按照比较器 {{c|comp}} 与投影 {{c|proj}} ''有序''。

此归并函数是''稳定''的，这表示对于原在两个范围中的等价元素，来自第一范围的元素（保持其原顺序）先于来自第二范围的元素（保持其原顺序）。

@1@ 用给定的二元比较函数 {{c|comp}} 与投影对象 {{c|proj}} 比较元素，而范围必须按同样方式排序。

@2@ 同 {{v|1}}，但以 {{c|r}} 为范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|first|middle|要归并的|range=第一个有序}}
{{par range|middle|last|要归并的|range=第二个有序|sentinel=yes}}
{{par|r|要原位归并的元素 {{lconcept|range}}}}
{{par|comp|应用到投影后元素的比较器}}
{{par|proj|应用到范围中元素的投影}}
{{par end}}

===返回值===
等于 {{c|last}} 的迭代器。

===复杂度===
若额外内存可用，则准确比较 {{c|N − 1}} 次，其中 {{c|1= N = ranges::distance(first, last)}}。否则比较 {{mathjax-or|\(\scriptsize \mathcal{O}(N\cdot\log{(N)})\)|𝓞(N•log(N))}} 次。另外在两种情况下都进行二倍次数的投影。

===注解===
此函数尝试分配临时缓冲区。若分配失败，则选择较低效的算法。

{{feature test macro|__cpp_lib_constexpr_algorithms|{{c/core|constexpr}} 稳定排序|value=202306L|std=C++26}}

===可能的实现===
此实现仅展示无额外内存可用时使用的较慢的算法。参阅 [https://github.com/microsoft/STL/blob/e745bad3b1d05b5b19ec652d68abb37865ffa454/stl/inc/algorithm#L7131-L7235 MSVC STL] 与 [https://github.com/gcc-mirror/gcc/blob/54258e22b0846aaa6bd3265f592feb161eecda75/libstdc%2B%2B-v3/include/bits/ranges_algo.h#L2573-L2602 libstdc++] 中的实现。
{{eq fun|1=&lt;!-- 复制自 libstdc++ --&gt;
struct inplace_merge_fn
{
    template&lt;std::bidirectional_iterator I, std::sentinel_for&lt;I&gt; S,
             class Comp = ranges::less, class Proj = std::identity&gt;
    requires std::sortable&lt;I, Comp, Proj&gt;
    constexpr I operator()(I first, I middle, S last, Comp comp = {}, Proj proj = {}) const
    {
        I last_it = ranges::next(middle, last);
        inplace_merge_slow(first, middle, last_it,
                           ranges::distance(first, middle),
                           ranges::distance(middle, last_it),
                           std::ref(comp), std::ref(proj));
        return last_it;
    }

    template&lt;ranges::bidirectional_range R, class Comp = ranges::less,
             class Proj = std::identity&gt;
    requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, ranges::iterator_t&lt;R&gt; middle,
                   Comp comp = {}, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), std::move(middle), ranges::end(r),
                       std::move(comp), std::move(proj));
    }

private:
    template&lt;class I, class Comp, class Proj&gt;
    static constexpr void inplace_merge_slow(I first, I middle, I last,
                                             std::iter_difference_t&lt;I&gt; n1,
                                             std::iter_difference_t&lt;I&gt; n2,
                                             Comp comp, Proj proj)
    {
        if (n1 == 0 {{!!}} n2 == 0)
            return;
        if (n1 + n2 == 2 &amp;&amp; comp(proj(*middle), proj(*first)))
        {
            ranges::iter_swap(first, middle);
            return;
        }

        I cut1 = first, cut2 = middle;
        std::iter_difference_t&lt;I&gt; d1{}, d2{};

        if (n1 &gt; n2)
        {
            d1 = n1 / 2;
            ranges::advance(cut1, d1);
            cut2 = ranges::lower_bound(middle, last, *cut1,
                                       std::ref(comp), std::ref(proj));
            d2 = ranges::distance(middle, cut2);
        }
        else
        {
            d2 = n2 / 2;
            ranges::advance(cut2, d2);
            cut1 = ranges::upper_bound(first, middle, *cut2,
                                       std::ref(comp), std::ref(proj));
            d1 = ranges::distance(first, cut1);
        }

        I new_middle = ranges::rotate(cut1, middle, cut2);
        inplace_merge_slow(first, cut1, new_middle, d1, d2,
                           std::ref(comp), std::ref(proj));
        inplace_merge_slow(new_middle, cut2, last, n1 - d1, n2 - d2,
                           std::ref(comp), std::ref(proj));
    }
};

inline constexpr inplace_merge_fn inplace_merge {};
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;complex&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

void print(auto const&amp; v, auto const&amp; rem, int middle = -1)
{
    for (int i{}; auto n : v)
        std::cout &lt;&lt; (i++ == middle ? "│ " : "") &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; rem &lt;&lt; '\n';
}

template&lt;std::random_access_iterator I, std::sentinel_for&lt;I&gt; S&gt;
requires std::sortable&lt;I&gt;
void merge_sort(I first, S last)
{
    if (last - first &gt; 1)
    {
        I middle{first + (last - first) / 2};
        merge_sort(first, middle);
        merge_sort(middle, last);
        std::ranges::inplace_merge(first, middle, last);
    }
}

int main()
{
    // 定制归并排序演示
    std::vector v {8, 2, 0, 4, 9, 8, 1, 7, 3};
    print(v, ": before sort");
    merge_sort(v.begin(), v.end());
    print(v, ": after sort\n");

    // 以比较函数对象和投影进行归并
    using CI = std::complex&lt;int&gt;;
    std::vector&lt;CI&gt; r{{0,1}, {0,2}, {0,3}, {1,1}, {1,2}};
    const auto middle{std::ranges::next(r.begin(), 3)};
    auto comp{std::ranges::less{}&lt;!----&gt;};
    auto proj{[](CI z) { return z.imag(); }&lt;!----&gt;};

    print(r, ": before merge", middle - r.begin());
    std::ranges::inplace_merge(r, middle, comp, proj);
    print(r, ": after merge");
}
 | output=
8 2 0 4 9 8 1 7 3 : before sort
0 1 2 3 4 7 8 8 9 : after sort

(0,1) (0,2) (0,3) │ (1,1) (1,2) : before merge
(0,1) (1,1) (0,2) (1,2) (0,3) : after merge
}}

===参阅===
{{dsc begin}}
{{dsc inc | cpp/algorithm/ranges/dsc merge}}
{{dsc inc | cpp/algorithm/ranges/dsc set_union}}
{{dsc inc | cpp/algorithm/ranges/dsc is_sorted}}
{{dsc inc | cpp/algorithm/ranges/dsc sort}}
{{dsc inc | cpp/algorithm/dsc inplace_merge}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}