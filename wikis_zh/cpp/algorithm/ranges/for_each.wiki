{{cpp/ranges/title|for_each|for_each_result}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl|num=1|since=c++20|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
          std::indirectly_unary_invocable&lt;std::projected&lt;I, Proj&gt;&gt; Fun &gt;
constexpr for_each_result&lt;I, Fun&gt;
    for_each( I first, S last, Fun f, Proj proj = {} );
}}
{{dcl|num=2|since=c++20|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          std::indirectly_unary_invocable&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Fun &gt;
constexpr for_each_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, Fun&gt;
    for_each( R&amp;&amp; r, Fun f, Proj proj = {} );
}}
{{dcl h|辅助类型}}
{{dcl|num=3|since=c++20|1=
template&lt; class I, class F &gt;
using for_each_result = ranges::in_fun_result&lt;I, F&gt;;
}}
{{dcl end}}

@1@ 按顺序，将给定的函数对象 {{c|f}} 应用于范围 {{range|first|last}} 中每个迭代器投影的值的结果。
@2@ 与 {{v|1}} 相同，但以 {{c|r}} 为源范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

对于两个重载，如果迭代器的类型是可变的，则 {{c|f}} 可能会通过解引用迭代器去修改范围中的元素。如果 {{c|f}} 会返回结果，则忽略此结果。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|sentinel=yes|3=要对之应用函数的}}
{{par|r|要将函数应用到的元素范围}}
{{par|f|应用到投影后范围的元素}}
{{par|proj|应用范围的投影}}
{{par end}}

===返回值===
{{c|{ranges::next(std::move(first), last), std::move(f)} }}

===复杂度===
准确 {{c|ranges::distance(first, last)}} 次应用 {{c|f}} 和 {{c|proj}}。

===可能的实现===
{{eq fun|1=
struct for_each_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirectly_unary_invocable&lt;std::projected&lt;I, Proj&gt;&gt; Fun&gt;
    constexpr ranges::for_each_result&lt;I, Fun&gt;
        operator()(I first, S last, Fun f, Proj proj = {}) const
    {
        for (; first != last; ++first)
            std::invoke(f, std::invoke(proj, *first));
        return {std::move(first), std::move(f)};
    }
  
    template&lt;ranges::input_range R, class Proj = std::identity,
             std::indirectly_unary_invocable&lt;std::projected&lt;ranges::iterator_t&lt;R&gt;,
             Proj&gt;&gt; Fun&gt;
    constexpr ranges::for_each_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, Fun&gt;
        operator()(R&amp;&amp; r, Fun f, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(f), std::ref(proj));
    }
};

inline constexpr for_each_fn for_each;
}}

===示例===
{{example
 | 下述的示例用 [[cpp/language/lambda|lambda 表达式]]递增 {{tt|vector}} 所有的元素，然后用函数对象中重载的 {{tt|operator()}} 计算它们的和。注意，要计算总和的话，建议使用专用的算法 {{lc|std::accumulate}}。
 | code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

struct Sum
{
    void operator()(int n) { sum += n; }
    int sum{0};
};

int main()
{
    std::vector&lt;int&gt; nums{3, 4, 2, 8, 15, 267};

    auto print = [](const auto&amp; n) { std::cout &lt;&lt; ' ' &lt;&lt; n; };

    namespace ranges = std::ranges;
    std::cout &lt;&lt; "之前:";
    ranges::for_each(std::as_const(nums), print);
    print('\n');

    ranges::for_each(nums, [](int&amp; n){ ++n; });

    // 对每个数调用 Sum::operator()
    auto [i, s] = ranges::for_each(nums.begin(), nums.end(), Sum());
    assert(i == nums.end());

    std::cout &lt;&lt; "之后: ";
    ranges::for_each(nums.cbegin(), nums.cend(), print);

    std::cout &lt;&lt; "\n" "和: " &lt;&lt; s.sum &lt;&lt; '\n';

    using pair = std::pair&lt;int, std::string&gt;; 
    std::vector&lt;pair&gt; pairs{{1,"one"}, {2,"two"}, {3,"three"}};

    std::cout &lt;&lt; "投影 pair::first: ";
    ranges::for_each(pairs, print, [](const pair&amp; p) { return p.first; });

    std::cout &lt;&lt; "\n" "投影 pair::second:";
    ranges::for_each(pairs, print, &amp;pair::second);
    print('\n');
}
|output=
之前: 3 4 2 8 15 267 
之后:  4 5 3 9 16 268
和: 305
投影 pair::first:  1 2 3
投影 pair::second: one two tree
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/language/dsc range-for}}
{{dsc inc|cpp/algorithm/ranges/dsc transform}}
{{dsc inc|cpp/algorithm/ranges/dsc for_each_n}}
{{dsc inc|cpp/algorithm/dsc for_each}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|en}}