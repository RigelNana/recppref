{{cpp/ranges/title|sample}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|è°ƒç”¨ç­¾å}}
{{dcl|num=1|since=c++20|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          std::weakly_incrementable O, class Gen &gt;
requires (std::forward_iterator&lt;I&gt; {{!!}} std::random_access_iterator&lt;O&gt;) &amp;&amp;
          std::indirectly_copyable&lt;I, O&gt; &amp;&amp;
          std::uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt;
O sample( I first, S last, O out, std::iter_difference_t&lt;I&gt; n, Gen&amp;&amp; gen );
}}
{{dcl|num=2|since=c++20|1=
template&lt; ranges::input_range R, std::weakly_incrementable O, class Gen &gt;
requires (ranges::forward_range&lt;R&gt; {{!!}} std::random_access_iterator&lt;O&gt;) &amp;&amp;
          std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
          std::uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt;
O sample( R&amp;&amp; r, O out, ranges::range_difference_t&lt;R&gt; n, Gen&amp;&amp; gen );
}}
{{dcl end}}

@1@ ä»åºåˆ— {{range|first|last}} é€‰æ‹© {{c|1= M = min(n, last - first)}} ä¸ªå…ƒç´ ï¼ˆæ— æ›¿ä»£ï¼‰ä½¿å¾—æ¯ä¸ªå¯èƒ½çš„''æ ·æœ¬''æ‹¥æœ‰ç›¸ç­‰çš„å‡ºç°æ¦‚ç‡ï¼Œå¹¶å°†é‚£äº›é€‰æ‹©çš„å…ƒç´ å†™åˆ°å§‹äº {{c|out}} çš„èŒƒå›´ä¸­ã€‚

@@ ä»…è‹¥ {{tt|I}} å®ç° {{c|std::forward_iterator}} ç®—æ³•æ‰''ç¨³å®š''ï¼ˆä¿æŒè¢«é€‰æ‹©å…ƒç´ çš„ç›¸å¯¹é¡ºåºï¼‰ã€‚

@@ è‹¥ {{c|out}} åœ¨ {{range|first|last}} ä¸­åˆ™è¡Œä¸ºæœªå®šä¹‰ã€‚

@2@ åŒ {{v|1}}ï¼Œä½†ä»¥ {{c|r}} ä¸ºæºèŒƒå›´ï¼Œå¦‚åŒä»¥ {{c|ranges::begin(r)}} ä¸º {{c|first}} å¹¶ä»¥ {{c|ranges::end(r)}} ä¸º {{c|last}}ã€‚

{{cpp/ranges/niebloid}}

===å‚æ•°===
{{par begin}}
{{par range|3=ä»ä¸­é‡‡æ ·çš„èŒƒå›´ï¼ˆ''æ€»ä½“''ï¼‰|sentinel=yes}}
{{par|r|ä»ä¸­é‡‡æ ·çš„èŒƒå›´ï¼ˆ''æ€»ä½“''ï¼‰}}
{{par|out|ç”¨ä»¥å†™å…¥æ ·æœ¬çš„è¾“å‡ºè¿­ä»£å™¨}}
{{par|n|è¦æŠ½å–çš„æ ·æœ¬æ•°}}
{{par|gen|ç”¨ä½œéšæœºæ€§æºçš„éšæœºæ•°ç”Ÿæˆå™¨}}
{{par end}}

===è¿”å›å€¼===
ç­‰äº {{tt|out + M}} çš„è¿­ä»£å™¨ï¼Œå³ç»“æœé‡‡æ ·èŒƒå›´çš„æœ«å°¾ã€‚

===å¤æ‚åº¦===
''çº¿æ€§''ï¼š ğ“{{tt|(last - first)}}ã€‚

===æ³¨è§£===
æ­¤å‡½æ•°å¯èƒ½å®ç°''é€‰æ‹©æŠ½æ ·''æˆ–{{enwiki|reservoir sampling|è“„æ°´æ± æŠ½æ ·}}ã€‚

===å¯èƒ½çš„å®ç°===
{{eq fun|1=
struct sample_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             std::weakly_incrementable O, class Gen&gt;
    requires (std::forward_iterator&lt;I&gt; or
              std::random_access_iterator&lt;O&gt;) &amp;&amp;
              std::indirectly_copyable&lt;I, O&gt; &amp;&amp;
              std::uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt;
    O operator()(I first, S last, O out, std::iter_difference_t&lt;I&gt; n, Gen&amp;&amp; gen) const
    {
        using diff_t = std::iter_difference_t&lt;I&gt;;
        using distrib_t = std::uniform_int_distribution&lt;diff_t&gt;;
        using param_t = typename distrib_t::param_type;
        distrib_t D{};

        if constexpr (std::forward_iterator&lt;I&gt;)
        {
            // æ­¤åˆ†æ”¯ä¿æŒæ ·æœ¬å…ƒç´ â€œç¨³å®šæ€§â€
            auto rest{ranges::distance(first, last)};
            for (n = ranges::min(n, rest); n != 0; ++first)
                if (D(gen, param_t(0, --rest)) &lt; n)
                {
                    *out++ = *first;
                    --n;
                }
            return out;
        }
        else
        {
            // D ä¸º random_access_iterator
            diff_t sample_size{};
            // å¤åˆ¶ [first, first + M) å…ƒç´ åˆ°â€œéšæœºè®¿é—®â€è¾“å‡º
            for (; first != last &amp;&amp; sample_size != n; ++first)
                out[sample_size++] = *first;
            // ä»¥éšæœºé€‰æ‹©çš„å€¼é‡å†™æŸäº›å¤åˆ¶çš„å…ƒç´ 
            for (auto pop_size{sample_size}; first != last; ++first, ++pop_size)
            {
                const auto i{D(gen, param_t{0, pop_size})};
                if (i &lt; n)
                    out[i] = *first;
            }
            return out + sample_size;
        }
    }

    template&lt;ranges::input_range R, std::weakly_incrementable O, class Gen&gt;
    requires (ranges::forward_range&lt;R&gt; or std::random_access_iterator&lt;O&gt;) &amp;&amp;
              std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
              std::uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt;
    O operator()(R&amp;&amp; r, O out, ranges::range_difference_t&lt;R&gt; n, Gen&amp;&amp; gen) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(out), n,
                       std::forward&lt;Gen&gt;(gen));
    }
};

inline constexpr sample_fn sample {};
}}

===ç¤ºä¾‹===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

void print(auto const&amp; rem, auto const&amp; v)
{
    std::cout &lt;&lt; rem &lt;&lt; " = [" &lt;&lt; std::size(v) &lt;&lt; "] { ";
    for (auto const&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; "}\n";
}

int main()
{
    const auto in = {1, 2, 3, 4, 5, 6};
    print("in", in);

    std::vector&lt;int&gt; out;
    const int max = in.size() + 2;
    auto gen = std::mt19937{std::random_device{}()};

    for (int n{}; n != max; ++n)
    {
        out.clear();
        std::ranges::sample(in, std::back_inserter(out), n, gen);
        std::cout &lt;&lt; "n = " &lt;&lt; n;
        print(", out", out);
    }
}
|p=true
|output=
in = [6] { 1 2 3 4 5 6 }
n = 0, out = [0] { }
n = 1, out = [1] { 5 }
n = 2, out = [2] { 4 5 }
n = 3, out = [3] { 2 3 5 }
n = 4, out = [4] { 2 4 5 6 }
n = 5, out = [5] { 1 2 3 5 6 }
n = 6, out = [6] { 1 2 3 4 5 6 }
n = 7, out = [6] { 1 2 3 4 5 6 }
}}

===å‚é˜…===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc shuffle}}
{{dsc inc|cpp/algorithm/dsc sample}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|en}}