{{cpp/ranges/title|prev_permutation|prev_permutation_result}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl|num=1|since=c++20|1=
template&lt; std::bidirectional_iterator I, std::sentinel_for&lt;I&gt; S,
          class Comp = ranges::less, class Proj = std::identity &gt;
requires std::sortable&lt;I, Comp, Proj&gt;
constexpr prev_permutation_result&lt;I&gt;
    prev_permutation( I first, S last, Comp comp = {}, Proj proj = {} );
}}
{{dcl|num=2|since=c++20|1=
template&lt; ranges::bidirectional_range R, class Comp = ranges::less,
          class Proj = std::identity &gt;
requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
constexpr prev_permutation_result&lt;ranges::borrowed_iterator_t&lt;R&gt;&gt;
    prev_permutation( R&amp;&amp; r, Comp comp = {}, Proj proj = {} );
}}
{{dcl h|辅助类型}}
{{dcl|since=c++20|num=3|1=
template&lt; class I &gt;
using prev_permutation_result = ranges::in_found_result&lt;I&gt;;
}}
{{dcl end}}

@1@ 变换范围 {{range|first|last}} 到前一{{enwiki|permutation|排列}}，其中所有排列的集合在{{enwiki|Lexicographic order|词法上}}按照函数对象 {{c|comp}} 与投影函数对象 {{c|proj}} 定序。
@@ 返回：
* 若存在''“前一排列”''，则返回 {{c|{last, true}&lt;!----&gt;}}。
* 否则返回 {{c|{last, false}&lt;!----&gt;}}，并将范围变换为（词法上的）最后排列，如同
{{source|
ranges::sort(first, last, comp, proj);
ranges::reverse(first, last);
}}

@2@ 同 {{v|1}}，但以 {{c|r}} 为源范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要“重排”的|sentinel=yes}}
{{par|r|要“重排”的元素 {{lconcept|range}}}}
{{par|comp|若第一实参“小于”第二个则返回 {{c|true}} 的比较{{named req|FunctionObject|函数对象}}}}
{{par|proj|应用到元素的投影}}
{{par end}}

===返回值===
@1@ 若新排列词法上小于旧者则为 {{c|ranges::prev_permutation_result&lt;I&gt;{last, true}&lt;!----&gt;}}。若抵达首个排列并设置范围为末排列则为 {{c|ranges::prev_permutation_result&lt;I&gt;{last, false}&lt;!----&gt;}}。

@2@ 同 {{v|1}}，但返回类型为 {{c|ranges::prev_permutation_result&lt;ranges::borrowed_iterator_t&lt;R&gt;&gt;}}。

===异常===
任何从迭代器操作或元素交换抛出的异常。

===复杂度===
至多交换 {{mathjax-or|\(\scriptsize N/2\)|N/2}} 次，其中 {{mathjax-or|\(\scriptsize N\)|N}} 在情况 {{v|1}} 中为 {{c|ranges::distance(first, last)}}，在情况 {{v|2}} 中为 {{c|ranges::distance(r)}}。在整个重排序列中，典型实现平均每次调用使用 3 次比较和 1.5 次交换。

===注解===
{{cpp/algorithm/notes swap vectorization}}

===可能的实现===
{{eq fun|1=
struct prev_permutation_fn
{
    template&lt;std::bidirectional_iterator I, std::sentinel_for&lt;I&gt; S,
             class Comp = ranges::less, class Proj = std::identity&gt;
    requires std::sortable&lt;I, Comp, Proj&gt;
    constexpr ranges::prev_permutation_result&lt;I&gt;
        operator()(I first, S last, Comp comp = {}, Proj proj = {}) const
    {
        // 检查序列是否拥有至少二个元素
        if (first == last)
            return {std::move(first), false};
        auto i{first};
        ++i;
        if (i == last)
            return {std::move(i), false};
        auto i_last{ranges::next(first, last)};
        i = i_last;
        --i;
        // 主“重排”循环
        for (;;)
        {
            auto i1{i};
            --i;
            if (std::invoke(comp, std::invoke(proj, *i1), std::invoke(proj, *i)))
            {
                auto j{i_last};
                while (!std::invoke(comp, std::invoke(proj, *--j), std::invoke(proj, *i)))
                    ;
                ranges::iter_swap(i, j);
                ranges::reverse(i1, last);
                return {std::move(i_last), true};
            }
            // 耗尽重排“空格”
            if (i == first)
            {
                ranges::reverse(first, last);
                return {std::move(i_last), false};
            }
        }
    }

    template&lt;ranges::bidirectional_range R, class Comp = ranges::less,
             class Proj = std::identity&gt;
    requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
    constexpr ranges::prev_permutation_result&lt;ranges::borrowed_iterator_t&lt;R&gt;&gt;
        operator()(R&amp;&amp; r, Comp comp = {}, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r),
                       std::move(comp), std::move(proj));
    }
};

inline constexpr prev_permutation_fn prev_permutation {};
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;compare&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

struct S
{
    char c{};
    int i{};
    auto operator&lt;=&gt;(const S&amp;) const = default;
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const S&amp; s)
    {
        return os &lt;&lt; "{'" &lt;&lt; s.c &lt;&lt; "', " &lt;&lt; s.i &lt;&lt; "}";
    }
};

auto print = [](auto const&amp; v, char term = ' ')
{
    std::cout &lt;&lt; "{ ";
    for (const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '}' &lt;&lt; term;
};

int main()
{
    std::cout &lt;&lt; "生成所有排列（迭代器情形）:\n";
    std::string s{"cba"};
    do print(s);
    while (std::ranges::prev_permutation(s.begin(), s.end()).found);

    std::cout &lt;&lt; "\n生成所有排列（范围情形）:\n";
    std::array a{'c', 'b', 'a'};
    do print(a);
    while (std::ranges::prev_permutation(a).found);

    std::cout &lt;&lt; "\n使用比较器生成所有排列:\n";
    using namespace std::literals;
    std::array z{"▁"s, "▄"s, "█"s};
    do print(z);
    while (std::ranges::prev_permutation(z, std::greater()).found);

    std::cout &lt;&lt; "\n使用投影生成所有排列:\n";
    std::array&lt;S, 3&gt; r{S{'C',1}, S{'B',2}, S{'A',3}&lt;!----&gt;};
    do print(r, '\n');
    while (std::ranges::prev_permutation(r, {}, &amp;S::c).found);
}
|output=
生成所有排列（迭代器情形）:
{ c b a } { c a b } { b c a } { b a c } { a c b } { a b c }
生成所有排列（范围情形）:
{ c b a } { c a b } { b c a } { b a c } { a c b } { a b c }
使用比较器生成所有排列:
{ ▁ ▄ █ } { ▁ █ ▄ } { ▄ ▁ █ } { ▄ █ ▁ } { █ ▁ ▄ } { █ ▄ ▁ }
使用投影生成所有排列:
{ {'C', 1} {'B', 2} {'A', 3} }
{ {'C', 1} {'A', 3} {'B', 2} }
{ {'B', 2} {'C', 1} {'A', 3} }
{ {'B', 2} {'A', 3} {'C', 1} }
{ {'A', 3} {'C', 1} {'B', 2} }
{ {'A', 3} {'B', 2} {'C', 1} }
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc next_permutation}}
{{dsc inc|cpp/algorithm/ranges/dsc is_permutation}}
{{dsc inc|cpp/algorithm/dsc next_permutation}}
{{dsc inc|cpp/algorithm/dsc prev_permutation}}
{{dsc inc|cpp/algorithm/dsc is_permutation}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}