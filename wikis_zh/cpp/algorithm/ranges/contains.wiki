{{cpp/ranges/title|contains|contains_subrange}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl rev multi|num=1|anchor=1|since1=c++23|until1=c++26|dcl1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class T,
          class Proj = std::identity &gt;
requires std::indirect_binary_predicate&lt;ranges::equal_to, std::projected&lt;I, Proj&gt;,
                                        const T*&gt;
constexpr bool contains( I first, S last, const T&amp; value, Proj proj = {} );
|dcl2=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;I, Proj&gt; &gt;
requires std::indirect_binary_predicate&lt;ranges::equal_to, std::projected&lt;I, Proj&gt;,
                                        const T*&gt;
constexpr bool contains( I first, S last, const T&amp; value, Proj proj = {} );
}}
{{dcl rev multi|num=2|since1=c++23|until1=c++26|dcl1=
template&lt; ranges::input_range R,
          class T,
          class Proj = std::identity &gt;
requires std::indirect_binary_predicate&lt;ranges::equal_to,
                                        std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
                                        const T*&gt;
constexpr bool contains( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
|dcl2=
template&lt; ranges::input_range R,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt; &gt;
requires std::indirect_binary_predicate&lt;ranges::equal_to,
                                        std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
                                        const T*&gt;
constexpr bool contains( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
}}
{{dcla|since=c++23|num=3|1=
template&lt; std::forward_iterator I1, std::sentinel_for&lt;I1&gt; S1,
          std::forward_iterator I2, std::sentinel_for&lt;I2&gt; S2,
          class Pred = ranges::equal_to,
          class Proj1 = std::identity, class Proj2 = std::identity &gt;
requires std::indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
constexpr bool contains_subrange( I1 first1, S1 last1, I2 first2, S2 last2,
                                  Pred pred = {},
                                  Proj1 proj1 = {}, Proj2 proj2 = {} );
}}
{{dcl|since=c++23|num=4|1=
template&lt; ranges::forward_range R1, ranges::forward_range R2,
          class Pred = ranges::equal_to,
          class Proj1 = std::identity, class Proj2 = std::identity &gt;
requires std::indirectly_comparable&lt;ranges::iterator_t&lt;R1&gt;,
                                    ranges::iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
constexpr bool contains_subrange( R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                                  Proj1 proj1 = {}, Proj2 proj2 = {} );
}}
{{dcl end}}

@1@ 基于搜索的算法，通过迭代器-哨兵对检查给定范围是否包含一个值。
@2@ 与 {{v|1}} 相同，但使用 {{c|r}} 作为源范围，就像使用 {{c|ranges::begin(r)}} 作为 {{c|first}} 和 {{c|ranges::end(r)}} 作为 {{c|last}} 一样。
@3@ 基于搜索的算法，通过迭代器-哨兵对检查给定范围是否包含一个值。
@4@ 与 {{v|3}} 相同，但使用 {{c|r1}} 作为第一个源范围，使用 {{c|r2}} 作为第二个源范围，就像使用 {{c|ranges::begin(r1)}} 作为 {{c|first1}}，{{c|ranges::end(r1)}} 作为 {{c|last1}}，{{c|ranges::begin(r2)}} 作为 {{c|first2}}，{{c|ranges::end(r2)}} 作为 {{c|last2}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要检验的|sentinel=yes}}
{{par|r|要检验的元素的范围}}
{{par|value|和元素进行比较的值}}
{{par|pred|适用于投影元素的谓词}}
{{par|proj|应用到元素的投影}}
{{par end}}

===返回值===
@1,2@：{{c|1=ranges::find(std::move(first), last, value, proj) != last}}

@3,4@：{{c|1=first2 == last2 {{!!}} !ranges::search(first1, last1, first2, last2, pred, proj1, proj2).empty()}}

===复杂度===
最多应用 {{c|last - first}} 次谓词和投影。

===注解===
在 C++20 之前，我们必须编写 {{c|1= std::ranges::find(r, value) != std::ranges::end(r)}} 来确定单个值是否在范围内。而要检查范围是否包含感兴趣的子范围，我们使用 {{c|1= not std::ranges::search(haystack, needle).empty()}}}。这样做虽然准确，但并不一定方便，也很难表达意图（尤其是在后一种情况下）。如果用 {{c|std::ranges::contains(r, value)}} 可以解决这两个问题。

{{tt|ranges::contains_subrange}} 和 {{lc|ranges::search}} 类似，但和 {{lc|std::search}} 不同，不提供对 {{named req|Searcher}}（例如 [[cpp/utility/functional#搜索器|Boyer-Moore]]）的支持。

{{ftm begin}}
{{ftm|__cpp_lib_ranges_contains|value=202207L|std=C++23|{{ttt|std::ranges::contains}} 和 {{ttt|ranges::contains_subrange}}}}
{{ftm|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|算法中的[[cpp/language/list initialization|列表初始化]] {{vl|1,2}}}}
{{ftm end}}

===可能的实现===
{{eq impl
|title1=contains (1,2)|ver1=1|1=
struct __contains_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity,
             class T = std::projected_value_t&lt;I, Proj&gt;&gt;
    requires std::indirect_binary_predicate&lt;ranges::equal_to, std::projected&lt;I, Proj&gt;,
                                            const T*&gt;
    constexpr bool operator()(I first, S last, const T&amp; value, Proj proj = {}) const
    {
        return ranges::find(std::move(first), last, value, proj) != last;
    }

    template&lt;ranges::input_range R,
             class Proj = std::identity,
             class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt;
    requires std::indirect_binary_predicate&lt;ranges::equal_to,
                                            std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
                                            const T*&gt;
    constexpr bool operator()(R&amp;&amp; r, const T&amp; value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(value), proj);
    }
};

inline constexpr __contains_fn contains {};
|title2=contains_subrange (3,4)|ver2=3|2=
struct __contains_subrange_fn
{
    template&lt;std::forward_iterator I1, std::sentinel_for&lt;I1&gt; S1,
             std::forward_iterator I2, std::sentinel_for&lt;I2&gt; S2,
             class Pred = ranges::equal_to,
             class Proj1 = std::identity, class Proj2 = std::identity&gt;
    requires std::indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
    constexpr bool operator()(I1 first1, S1 last1,
                              I2 first2, S2 last2,
                              Pred pred = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {}) const
    {
        return (first2 == last2) {{!!}}
               !ranges::search(first1, last1, first2, last2, pred, proj1, proj2).empty();
    }

    template&lt;ranges::forward_range R1, ranges::forward_range R2,
             class Pred = ranges::equal_to,
             class Proj1 = std::identity, class Proj2 = std::identity&gt;
    requires std::indirectly_comparable&lt;ranges::iterator_t&lt;R1&gt;,
                                        ranges::iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
    constexpr bool operator()(R1&amp;&amp; r1, R2&amp;&amp; r2,
                              Pred pred = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {}) const
    {
        return (*this)(ranges::begin(r1), ranges::end(r1),
                       ranges::begin(r2), ranges::end(r2), std::move(pred),
                       std::move(proj1), std::move(proj2));
    }
};

inline constexpr __contains_subrange_fn contains_subrange {};
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;complex&gt;

namespace ranges = std::ranges;

int main()
{
    constexpr auto haystack = std::array{3, 1, 4, 1, 5};
    constexpr auto needle = std::array{1, 4, 1};
    constexpr auto bodkin = std::array{2, 5, 2};

    static_assert(
        ranges::contains(haystack, 4) &amp;&amp;
       !ranges::contains(haystack, 6) &amp;&amp;
        ranges::contains_subrange(haystack, needle) &amp;&amp;
       !ranges::contains_subrange(haystack, bodkin)
    );

    constexpr std::array&lt;std::complex&lt;double&gt;, 3&gt; nums{&lt;!----&gt;{&lt;!----&gt;{1, 2}, {3, 4}, {5, 6}&lt;!----&gt;}&lt;!----&gt;};
    #ifdef __cpp_lib_algorithm_default_value_type
        static_assert(ranges::contains(nums, {3, 4}));
    #else
        static_assert(ranges::contains(nums, std::complex&lt;double&gt;{3, 4}));
    #endif
}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc find}}
{{dsc inc|cpp/algorithm/ranges/dsc search}}
{{dsc inc|cpp/algorithm/ranges/dsc binary_search}}
{{dsc inc|cpp/algorithm/ranges/dsc includes}}
{{dsc inc|cpp/algorithm/ranges/dsc all_any_none_of}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|en}}