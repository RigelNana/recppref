{{cpp/ranges/title|all_of|any_of|none_of}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcla|since=c++20|num=1|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr bool all_of( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++20|num=2|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;,Proj&gt;&gt; Pred &gt;
constexpr bool all_of( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcla|since=c++20|num=3|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr bool any_of( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++20|num=4|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;,Proj&gt;&gt; Pred &gt;
constexpr bool any_of( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcla|since=c++20|num=5|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr bool none_of( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++20|num=6|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;,Proj&gt;&gt; Pred &gt;
constexpr bool none_of( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcl end}}

@1@ 检查一元谓词 {{c|pred}} 是否对范围 {{range|first|last}} 中至少一个元素（以投影 {{c|proj}} 投影后）返回 {{c|false}}。

@3@ 检查一元谓词 {{c|pred}} 是否对范围 {{range|first|last}} 中至少一个元素（以投影 {{c|proj}} 投影后）返回 {{c|true}}。

@5@ 检查一元谓词 {{c|pred}} 是否不对范围 {{range|first|last}} 中任何元素（以投影 {{c|proj}} 投影后）返回 {{c|true}}。

@2,4,6@ 同 {{v|1,3,5}}，但以 {{c|r}} 为源范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要检验的|sentinel=yes}}
{{par|r|要检验的元素范围}}
{{par|pred|应用到投影后元素的谓词}}
{{par|proj|应用到元素的投影}}
{{par end}}

===返回值===
@1-2@ 在 {{c|1=std::invoke(pred, std::invoke(proj, *i)) != false}} 对范围中的每个迭代器 {{c|i}} 成立时返回 {{c|true}}，否则返回 {{c|false}}。范围为空时返回 {{c|true}}。

@3-4@ 在 {{c|1=std::invoke(pred, std::invoke(proj, *i)) != false}} 对范围中的至少一个迭代器 {{c|i}} 成立时返回 {{c|true}}，否则返回 {{c|false}}。范围为空时返回 {{c|false}}。

@5-6@ 在 {{c|1=std::invoke(pred, std::invoke(proj, *i)) == false}} 对范围中的每个迭代器 {{c|i}} 成立时返回 {{c|true}}，否则返回 {{c|false}}。范围为空时返回 {{c|true}}。

{{cpp/algorithm/truth table all any none}}

===复杂度===
最多应用 {{c|last - first}} 次谓词和投影。

===可能的实现===
{{eq impl
|title1=all_of (1,2)|ver1=1|1=
struct all_of_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        return ranges::find_if_not(first, last, std::ref(pred), std::ref(proj)) == last;
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity,
             std::indirect_unary_predicate&lt;
                 std::projected&lt;ranges::iterator_t&lt;R&gt;,Proj&gt;&gt; Pred&gt;
    constexpr bool operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return operator()(ranges::begin(r), ranges::end(r),
                          std::ref(pred), std::ref(proj));
    }
};

inline constexpr all_of_fn all_of;
|title2=any_of (3,4)|ver2=3|2=
struct any_of_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        return ranges::find_if(first, last, std::ref(pred), std::ref(proj)) != last;
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity,
             std::indirect_unary_predicate&lt;
                 std::projected&lt;ranges::iterator_t&lt;R&gt;,Proj&gt;&gt; Pred&gt;
    constexpr bool operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return operator()(ranges::begin(r), ranges::end(r),
                          std::ref(pred), std::ref(proj));
    }
};

inline constexpr any_of_fn any_of;
|title3=none_of (5,6)|ver3=5|3=
struct none_of_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        return ranges::find_if(first, last, std::ref(pred), std::ref(proj)) == last;
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity,
             std::indirect_unary_predicate&lt;
                 std::projected&lt;ranges::iterator_t&lt;R&gt;,Proj&gt;&gt; Pred&gt;
    constexpr bool operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return operator()(ranges::begin(r), ranges::end(r),
                          std::ref(pred), std::ref(proj));
    }
};

inline constexpr none_of_fn none_of;
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

namespace ranges = std::ranges;

constexpr bool some_of(auto&amp;&amp; r, auto&amp;&amp; pred) // 一些但非全部
{
    return not (ranges::all_of(r, pred) or ranges::none_of(r, pred));
}

constexpr auto w = {1, 2, 3};
static_assert(!some_of(w, [](int x) { return x &lt; 1; }));
static_assert( some_of(w, [](int x) { return x &lt; 2; }));
static_assert(!some_of(w, [](int x) { return x &lt; 4; }));

int main()
{
    std::vector&lt;int&gt; v(10, 2);
    std::partial_sum(v.cbegin(), v.cend(), v.begin());
    std::cout &lt;&lt; "这些数中：";
    ranges::copy(v, std::ostream_iterator&lt;int&gt;(std::cout, " "));
    std::cout &lt;&lt; '\n';
    
    if (ranges::all_of(v.cbegin(), v.cend(), [](int i) { return i % 2 == 0; }))
        std::cout &lt;&lt; "全部都是偶数\n";

    if (ranges::none_of(v, std::bind(std::modulus&lt;int&gt;(), std::placeholders::_1, 2)))
        std::cout &lt;&lt; "没有奇数\n";
    
    auto DivisibleBy = [](int d)
    {
        return [d](int m) { return m % d == 0; };
    };
    
    if (ranges::any_of(v, DivisibleBy(7)))
        std::cout &lt;&lt; "至少一个数可被 7 整除\n";
}
|output=
这些数中：2 4 6 8 10 12 14 16 18 20
全部都是偶数
没有奇数
至少一个数可被 7 整除
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc all_any_none_of}}
{{dsc end}}

{{langlinks|en|es|ja}}