{{cpp/ranges/title|iota|iota_result}}
{{cpp/algorithm/ranges/numeric/navbar}}
{{dcl begin}}
{{dcl header|numeric}}
{{dcl h|调用签名}}
{{dcl|num=1|since=c++23|1=
template&lt; std::input_or_output_iterator O, std::sentinel_for&lt;O&gt; S,
          std::weakly_incrementable T &gt;
requires std::indirectly_writable&lt;O, const T&amp;&gt;
constexpr iota_result&lt;O, T&gt;
    iota( O first, S last, T value );
}}
{{dcl|num=2|since=c++23|1=
template&lt; std::weakly_incrementable T, ranges::output_range&lt;const T&amp;&gt; R &gt;
constexpr iota_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, T&gt;
    iota( R&amp;&amp; r, T value );
}}
{{dcl h|辅助类型}}
{{dcl|since=c++23|num=3|1=
template&lt; class O, class T &gt;
using iota_result = ranges::out_value_result&lt;O, T&gt;;
}}
{{dcl end}}

用依次递增的值填充范围 {{range|first|last}}，起始为 {{c|value}} 并重复应用 {{c|++value}}。

等价操作：

{{source|1=
*(first)     = value;
*(first + 1) = ++value;
*(first + 2) = ++value;
*(first + 3) = ++value;
...
}}

===参数===
{{par begin}}
{{par range|3=要以从 {{c|value}} 开始依次递增的数值填充的|sentinel=yes}}
{{par|value|起始值；表达式 {{c|++value}} 必须良构}}
{{par end}}

===返回值===
{{c|1={last, value + ranges::distance(first, last)} }}

===复杂度===
准确 {{c|last - first}} 次递增和赋值。

===可能的实现===
{{eq fun|1=
struct iota_fn
{
    template&lt;std::input_or_output_iterator O, std::sentinel_for&lt;O&gt; S,
            std::weakly_incrementable T&gt;
    requires std::indirectly_writable&lt;O, const T&amp;&gt;
    constexpr iota_result&lt;O, T&gt; operator()(O first, S last, T value) const
    {
        while (first != last)
        {
            *first = as_const(value);
            ++first;
            ++value;
        }
        return {std::move(first), std::move(value)};
    }

    template&lt;std::weakly_incrementable T, std::ranges::output_range&lt;const T&amp;&gt; R&gt;
    constexpr iota_result&lt;std::ranges::borrowed_iterator_t&lt;R&gt;, T&gt;
    operator()(R&amp;&amp; r, T value) const
    {
        return (*this)(std::ranges::begin(r), std::ranges::end(r), std::move(value));
    }
};
 
inline constexpr iota_fn iota;
}}

===注解===
该函数以 {{enwiki|APL_(programming_language)|APL}} 编程语言中的整数函数 &lt;span style="font-size: 1.5em"&gt;⍳&lt;/span&gt; &lt;!-- ⍳ : U+2373 APL FUNCTIONAL SYMBOL IOTA --&gt; 命名。

{{feature test macro|__cpp_lib_ranges_iota|std=C++23|value=202202L|{{tt|std::ranges::iota}}}}

===示例===
{{example
|使用 {{lc|std::vector|vector}} 的迭代器（{{c|std::vector&lt;std::list&lt;T&gt;::iterator&gt;}}）作为代理，对 {{lc|std::list}} 中的元素进行洗牌，因为 {{lc|ranges::shuffle}} 无法直接应用于 {{lc|std::list}}。
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;numeric&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

template &lt;typename Proj = std::identity&gt;
void println(auto comment, std::ranges::input_range auto&amp;&amp; range, Proj proj = {})
{
    for (std::cout &lt;&lt; comment; auto const &amp;element : range)
        std::cout &lt;&lt; proj(element) &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    std::list&lt;int&gt; list(8);

    // 以升序值填充 list: 0, 1, 2, ..., 7
    std::ranges::iota(list, 0);
    println("list: ", list);

    // 迭代器的 vector（见示例的注释）
    std::vector&lt;std::list&lt;int&gt;::iterator&gt; vec(list.size());

    // 以 list 各连续元素的迭代器填充
    std::ranges::iota(vec.begin(), vec.end(), list.begin());

    std::ranges::shuffle(vec, std::mt19937 {std::random_device {}()});
    println("通过 vector 所见的 list: ", vec, [](auto it) { return *it; });
}
|p=true
|output=
list: 0 1 2 3 4 5 6 7
通过 vector 所见的 list: 5 7 6 0 1 3 4 2
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc fill}}
{{dsc inc|cpp/algorithm/ranges/dsc fill}}
{{dsc inc|cpp/algorithm/dsc generate}}
{{dsc inc|cpp/algorithm/ranges/dsc generate}}
{{dsc inc|cpp/ranges/dsc iota_view}}
{{dsc inc|cpp/algorithm/dsc iota}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|en}}