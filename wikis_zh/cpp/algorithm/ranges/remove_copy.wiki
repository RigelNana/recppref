{{cpp/ranges/title|remove_copy|remove_copy_if|remove_copy_result|remove_copy_if_result}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl rev begin|num=1}}
{{dcla|anchor=版本_1|since=c++20|until=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          std::weakly_incrementable O, class T, class Proj = std::identity &gt;
requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr remove_copy_result&lt;I, O&gt;
    remove_copy( I first, S last, O result, const T&amp; value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          std::weakly_incrementable O, class Proj = std::identity,
          class T = std::projected_value_t&lt;I, Proj&gt; &gt;
requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr remove_copy_result&lt;I, O&gt;
    remove_copy( I first, S last, O result, const T&amp; value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::input_range R, 
          std::weakly_incrementable O, class T, class Proj = std::identity &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr remove_copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    remove_copy( R&amp;&amp; r, O result, const T&amp; value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::input_range R, 
          std::weakly_incrementable O, class Proj = std::identity,
          class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt; &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr remove_copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    remove_copy( R&amp;&amp; r, O result, const T&amp; value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcla|num=3|since=c++20|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          std::weakly_incrementable O, class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
requires std::indirectly_copyable&lt;I, O&gt;
constexpr remove_copy_if_result&lt;I, O&gt;
    remove_copy_if( I first, S last, O result, Pred pred, Proj proj = {} );
}}
{{dcl|num=4|since=c++20|1=
template&lt; ranges::input_range R,
          std::weakly_incrementable O, class Proj = std::identity,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt;
constexpr remove_copy_if_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    remove_copy_if( R&amp;&amp; r, O result, Pred pred, Proj proj = {} );
}}
{{dcl h|辅助类型}}
{{dcl|num=5|since=c++20|1=
template&lt; class I, class O &gt;
using remove_copy_result = ranges::in_out_result&lt;I, O&gt;;
}}
{{dcl|num=6|since=c++20|1=
template&lt; class I, class O &gt;
using remove_copy_if_result = ranges::in_out_result&lt;I, O&gt;;
}}
{{dcl end}}

复制来自源范围 {{range|first|last}} 的元素到始于 {{c|result}} 的目标范围，忽略（在由 {{c|proj}} 投影后）满足特定判别标准的元素。若源范围与目标范围重叠则行为未定义。

@1@ 忽略所有等于 {{c|value}} 的元素。

@3@ 忽略所有谓词 {{c|pred}} 对其返回 {{c|true}} 的元素。

@2,4@ 同 {{v|1,3}}，但以 {{c|r}} 为源范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要处理的|range=源|sentinel=yes}}
{{par|r|要处理的源元素范围}}
{{par|result|目标范围的起始}}
{{par|value|'''不'''复制的元素的值}}
{{par|comp|比较投影后元素的二元谓词}}
{{par|proj|应用到元素的投影}}
{{par end}}

===返回值===
{{c|{last, result + N} }}，其中 {{c|N}} 是复制的元素数。

===复杂度===
准确应用 {{c|ranges::distance(first, last)}} 次对应的谓词 {{c|comp}} 与任何投影 {{c|proj}}。

===注解===
算法是稳定的，即保持被复制元素的相对顺序。

{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|算法中的[[cpp/language/list initialization|列表初始化]] {{vl|1,2}}}}

===可能的实现===
{{eq impl|title1=remove_copy (1,2)|ver1=1|1=
struct remove_copy_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             std::weakly_incrementable O, class Proj = std::identity,
             class T = std::projected_value_t&lt;I, Proj&gt;&gt;
    requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp;
             std::indirect_binary_predicate&lt;ranges::equal_to,
                                            std::projected&lt;I, Proj&gt;, const T*&gt;
    constexpr ranges::remove_copy_result&lt;I, O&gt;
        operator()(I first, S last, O result, const T&amp; value, Proj proj = {}) const
    {
        for (; !(first == last); ++first)
            if (value != std::invoke(proj, *first))
            {
                *result = *first;
                ++result;
            }
        return {std::move(first), std::move(result)};
    }
    
    template&lt;ranges::input_range R, 
             std::weakly_incrementable O, class Proj = std::identity,
             class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt;
    requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
             std::indirect_binary_predicate&lt;ranges::equal_to,
             std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
    constexpr ranges::remove_copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
        operator()(R&amp;&amp; r, O result, const T&amp; value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(result), value,
                       std::move(proj));
    }
};

inline constexpr remove_copy_fn remove_copy {};
|title2=remove_copy_if (3,4)|ver2=3|2=
struct remove_copy_if_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, std::weakly_incrementable O,
             class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires std::indirectly_copyable&lt;I, O&gt;
    constexpr ranges::remove_copy_if_result&lt;I, O&gt;
        operator()(I first, S last, O result, Pred pred, Proj proj = {}) const
    {
        for (; first != last; ++first)
            if (false == std::invoke(pred, std::invoke(proj, *first)))
            {
                *result = *first;
                ++result;
            }
        return {std::move(first), std::move(result)};
    }
    
    template&lt;ranges::input_range R, std::weakly_incrementable O,
             class Proj = std::identity,
             std::indirect_unary_predicate&lt;
                 std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt;
    constexpr ranges::remove_copy_if_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
        operator()(R&amp;&amp; r, O result, Pred pred, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(result),
                       std::move(pred), std::move(proj));
    }
};

inline constexpr remove_copy_if_fn remove_copy_if {};
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;complex&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

void println(const auto rem, const auto&amp; v)
{
    std::cout &lt;&lt; rem &lt;&lt; ' ';
    for (const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    // 从给定的字符串滤出散列记号。
    const std::string_view str{"#Small #Buffer #Optimization"};
    std::cout &lt;&lt; "before: " &lt;&lt; std::quoted(str) &lt;&lt; '\n';

    std::cout &lt;&lt; "after:  \"";
    std::ranges::remove_copy(str.begin(), str.end(),
                             std::ostream_iterator&lt;char&gt;(std::cout), '#');
    std::cout &lt;&lt; "\"\n";

    // 仅复制有正虚部的复数
    using Ci = std::complex&lt;int&gt;;
    constexpr std::array&lt;Ci, 5&gt; source
    {
        Ci{1, 0}, Ci{0, 1}, Ci{2, -1}, Ci{3, 2}, Ci{4, -3}
    };
    std::vector&lt;std::complex&lt;int&gt;&gt; target;

    std::ranges::remove_copy_if
    (
        source,
        std::back_inserter(target),
        [](int imag) { return imag &lt;= 0; },
        [](Ci z) { return z.imag(); }
    );

    println("source:", source);
    println("target:", target);

    std::vector&lt;std::complex&lt;float&gt;&gt; nums{{2, 2}, {1, 3}, {4, 8}, {1, 3}};
    std::vector&lt;std::complex&lt;double&gt;&gt; outs;
    #ifdef __cpp_lib_algorithm_default_value_type
        std::remove_copy(nums.cbegin(), nums.cend(), std::back_inserter(outs),
                         {1, 3}); // T 被推导为 std::complex&lt;float&gt;
    #else
        std::remove_copy(nums.cbegin(), nums.cend(), std::back_inserter(outs),
                         std::complex&lt;float&gt;{1, 3});
    #endif
    println("nums:  ", nums);
    println("outs:  ", outs);
}
|output=
before: "#Small #Buffer #Optimization"
after:  "Small Buffer Optimization"
source: (1,0) (0,1) (2,-1) (3,2) (4,-3)
target: (0,1) (3,2)
nums:   (2,2) (1,3) (4,8) (1,3)
outs:   (2,2) (4,8)
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc remove}}
{{dsc inc|cpp/algorithm/ranges/dsc copy}}
{{dsc inc|cpp/algorithm/ranges/dsc copy_n}}
{{dsc inc|cpp/algorithm/ranges/dsc copy_backward}}
{{dsc inc|cpp/algorithm/ranges/dsc replace_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc reverse_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc rotate_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc unique_copy}}
{{dsc inc|cpp/algorithm/dsc remove_copy}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}