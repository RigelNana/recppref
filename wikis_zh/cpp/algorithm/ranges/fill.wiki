{{cpp/ranges/title|fill}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl rev begin|num=1}}
{{dcla|anchor=版本_1|since=c++20|until=c++26|
template&lt; class T, std::output_iterator&lt;const T&amp;&gt; O, std::sentinel_for&lt;O&gt; S &gt;
constexpr O fill( O first, S last, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class O, std::sentinel_for&lt;O&gt; S, class T = std::iter_value_t&lt;O&gt; &gt;
requires std::output_iterator&lt;O, const T&amp;&gt;
constexpr O fill( O first, S last, const T&amp; value );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++20|until=c++26|
template&lt; class T, ranges::output_range&lt;const T&amp;&gt; R &gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt; fill( R&amp;&amp; r, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class R, class T = ranges::range_value_t&lt;R&gt; &gt;
requires ranges::output_range&lt;R, const T&amp;&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt; fill( R&amp;&amp; r, const T&amp; value );
}}
{{dcl end}}

@1@ 将给定值 {{c|value}} 赋值给范围 {{range|first|last}} 中的元素。
@2@ 同 {{v|1}}，但以 {{c|r}} 为源范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要修改的|sentinel=yes}}
{{par|r|要修改的元素范围}}
{{par|value|要赋的值}}
{{par end}}

===返回值===
比较等于 {{c|last}} 的输出迭代器。

===复杂度===
准确 {{c|last - first}} 次赋值。

===可能的实现===
{{eq fun|1=
struct fill_fn
{
    template&lt;class O, std::sentinel_for&lt;O&gt; S, class T = std::iter_value_t&lt;O&gt;&gt;
    requires std::output_iterator&lt;O, const T&amp;&gt;
    constexpr O operator()(O first, S last, const T&amp; value) const
    {
        while (first != last)
            *first++ = value;
        
        return first;
    }

    template&lt;class R, class T = ranges::range_value_t&lt;R&gt;&gt;
    requires ranges::output_range&lt;R, const T&amp;&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt; operator()(R&amp;&amp; r, const T&amp; value) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), value);
    }
};

inline constexpr fill_fn fill;
}}

===注解===
{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|算法中的[[cpp/language/list initialization|列表初始化]] {{vl|1,2}}}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

void println(const auto&amp; seq)
{
    for (const auto&amp; e : seq)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5};

    // 使用重载 (1) 将所有元素设为 -1
    std::ranges::fill(v.begin(), v.end(), -1);
    println(v);

    // 使用重载 (2) 将所有元素设为 10
    std::ranges::fill(v, 10);
    println(v);

    std::vector&lt;std::complex&lt;double&gt;&gt; nums{&lt;!----&gt;{1, 3}, {2, 2}, {4, 8}&lt;!----&gt;};
    println(nums);
    #ifdef __cpp_lib_algorithm_default_value_type
        std::ranges::fill(nums, {4, 2}); // T 被推导
    #else
        std::ranges::fill(nums, std::complex&lt;double&gt;{4, 2});
    #endif
    println(nums);
}
|output=
-1 -1 -1 -1 -1 -1
10 10 10 10 10 10
(1,3) (2,2) (4,8)
(4,2) (4,2) (4,2)
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc fill_n}}
{{dsc inc|cpp/algorithm/ranges/dsc copy}}
{{dsc inc|cpp/algorithm/ranges/dsc generate}}
{{dsc inc|cpp/algorithm/ranges/dsc transform}}
{{dsc inc|cpp/numeric/random/ranges/dsc generate_random}}
{{dsc inc|cpp/algorithm/dsc fill}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}