{{cpp/ranges/title|copy|copy_if|copy_result|copy_if_result}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcla|since=c++20|num=1|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S, std::weakly_incrementable O &gt;
requires std::indirectly_copyable&lt;I, O&gt;
constexpr copy_result&lt;I, O&gt;
    copy( I first, S last, O result );
}}
{{dcl|since=c++20|num=2|1=
template&lt; ranges::input_range R, std::weakly_incrementable O &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt;
constexpr copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    copy( R&amp;&amp; r, O result );
}}
{{dcla|since=c++20|num=3|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S, std::weakly_incrementable O,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
requires std::indirectly_copyable&lt;I, O&gt;
constexpr copy_if_result&lt;I, O&gt;
    copy_if( I first, S last, O result, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++20|num=4|1=
template&lt; ranges::input_range R, std::weakly_incrementable O,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt;
constexpr copy_if_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    copy_if( R&amp;&amp; r, O result, Pred pred, Proj proj = {} );
}}
{{dcl h|辅助类型}}
{{dcl|since=c++20|num=5|1=
template&lt; class I, class O &gt;
using copy_result = ranges::in_out_result&lt;I, O&gt;;
}}
{{dcl|since=c++20|num=6|1=
template&lt; class I, class O &gt;
using copy_if_result = ranges::in_out_result&lt;I, O&gt;;
}}
{{dcl end}}

复制 {{range|first|last}} 所定义的范围中的元素到始于 {{c|result}} 的另一范围。
@1@ 复制范围 {{range|first|last}} 中的所有元素，从 {{c|first}} 开始并持续到 {{c|last - 1}}。若 {{c|result}} 在范围 {{range|first|last}} 内则行为未定义。此情况下，可用 {{lc|ranges::copy_backward}} 代替。
@3@ 仅复制谓词 {{c|pred}} 对其返回 {{c|true}} 的元素。保持复制的元素顺序。若源与目标范围重叠则行为未定义。
@2,4@ 同 {{v|1,3}}，但以 {{c|r}} 为源范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要复制的|sentinel=yes}}
{{par|r|要复制的元素范围}}
{{par|result|目标范围的起始}}
{{par|pred|应用到投影后元素的谓词}}
{{par|proj|应用到元素的投影}}
{{par end}}

===返回值===
含有等于 {{c|last}} 的输入迭代器和指向最后复制元素后一位置的输出迭代器的 {{lc|ranges::in_out_result}}。

===复杂度===
@1,2@ 准确 {{c|(last - first)}} 次赋值。

@3,4@ 准确 {{c|(last - first)}} 次应用谓词与投影，而赋值次数从 {{c|0}} 到 {{c|last - first}} 之间（对每个谓词返回 {{c|true}} 的元素赋值，取决于谓词与输入数据）。

===注解===
实践中，{{tt|ranges::copy}} 的实现若值类型为{{named req|TriviallyCopyable}}且迭代器类型满足 {{lconcept|contiguous_iterator}}，则避免多次赋值并使用如 {{lc|std::memmove}} 的大块复制函数。

复制重叠的范围时，{{tt|std::ranges::copy}} 在向左复制（目标范围的起始在源范围外）时适合，而 {{rlpt|copy_backward|ranges::copy_backward}} 在向右复制（目标范围的末尾在源范围外）时适合。

===可能的实现 ===
{{eq impl
|title1=copy (1)(2)|ver1=1|1=
struct copy_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, std::weakly_incrementable O&gt;
    requires std::indirectly_copyable&lt;I, O&gt;
    constexpr ranges::copy_result&lt;I, O&gt; operator()(I first, S last, O result) const
    {
        for (; first != last; ++first, (void)++result)
            *result = *first;
        return {std::move(first), std::move(result)};
    }

    template&lt;ranges::input_range R, std::weakly_incrementable O&gt;
    requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt;
    constexpr ranges::copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
        operator()(R&amp;&amp; r, O result) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(result));
    }
};

inline constexpr copy_fn copy;
|title2=copy_if (3)(4)|ver2=3|2=
struct copy_if_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, std::weakly_incrementable O,
             class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires std::indirectly_copyable&lt;I, O&gt;
    constexpr ranges::copy_if_result&lt;I, O&gt;
        operator()(I first, S last, O result, Pred pred, Proj proj = {}) const
    {
        for (; first != last; ++first)
            if (std::invoke(pred, std::invoke(proj, *first)))
            {
                *result = *first;
                ++result;
            }
        return {std::move(first), std::move(result)};
    }

    template&lt;ranges::input_range R, std::weakly_incrementable O,
             class Proj = std::identity,
             std::indirect_unary_predicate&lt;
                 std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt;
    constexpr ranges::copy_if_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
        operator()(R&amp;&amp; r, O result, Pred pred, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(result),
                       std::ref(pred), std::ref(proj));
    }
};

inline constexpr copy_if_fn copy_if;
}}

===示例===
{{example
|下列代码用 {{tt|ranges::copy}} 复制 {{lc|std::vector}} 的内容到另一 {{tt|std::vector}} 并显示结果 {{tt|vector}}。
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; source(10);
    std::iota(source.begin(), source.end(), 0);
    std::vector&lt;int&gt; destination;
    std::ranges::copy(source.begin(), source.end(), std::back_inserter(destination));

// 或者另外使用
//  std::vector&lt;int&gt; destination(source.size());
//  std::ranges::copy(source.begin(), source.end(), destination.begin());
// 都等价于
//  std::vector&lt;int&gt; to_vector = from_vector;

    std::cout &lt;&lt; "目标包含: ";
    std::ranges::copy(destination, std::ostream_iterator&lt;int&gt;(std::cout, " "));
    std::cout &lt;&lt; '\n';

    std::cout &lt;&lt; "目标中的奇数有: ";
    std::ranges::copy_if(destination, std::ostream_iterator&lt;int&gt;(std::cout, " "),
                         [](int x) { return (x % 2) == 1; });
    std::cout &lt;&lt; '\n';
}
|output=
目标包含: 0 1 2 3 4 5 6 7 8 9
目标中的奇数有: 1 3 5 7 9
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc copy_backward}}
{{dsc inc|cpp/algorithm/ranges/dsc reverse_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc copy_n}}
{{dsc inc|cpp/algorithm/ranges/dsc fill}}
{{dsc inc|cpp/algorithm/ranges/dsc remove_copy}}
{{dsc inc|cpp/algorithm/dsc copy}}
{{dsc end}}

{{langlinks|en|es|ja}}