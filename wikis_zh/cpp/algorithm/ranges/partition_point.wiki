{{cpp/ranges/title|partition_point}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl|num=1|since=c++20|1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr I
    partition_point( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|num=2|since=c++20|1=
template&lt; ranges::forward_range R,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    partition_point( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcl end}}

检验已划分（如同用 {{lc|ranges::partition}}）范围 {{range|first|last}} 或 {{c|r}} 并定位第一划分的结尾，即不满足 {{c|pred}} 的被投影元素，或若所有投影后元素均满足 {{c|pred}} 则为 {{c|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要检验的|range=部分有序|sentinel=yes}}
{{par|r|要检验的部分有序范围}}
{{par|pred|应用到投影后元素的谓词}}
{{par|proj|应用到元素的投影}}
{{par end}}

===返回值===
{{range|first|last}} 内第一划分的尾后位置迭代器，或若所有投影后元素均满足 {{c|pred}} 则为等于 {{c|last}} 的迭代器。

===复杂度===
给定 {{c|1=N = ranges::distance(first, last)}}，应用 {{math|O(log N)}} 次谓词 {{c|pred}} 与投影 {{c|proj}}。

然而，若哨位不实现 {{c|std::sized_sentinel_for&lt;I&gt;}}，则迭代器自增次数为 {{math|O(N)}}。

===注解===
此算法是 {{tt|ranges::lower_bound}} 的更通用的形式，能用 {{tt|ranges::partition_point}} 用 {{c|[&amp;](auto const&amp; e) { return std::invoke(pred, e, value); });}} 为谓词表达它。

===示例===
{{example|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

auto print_seq = [](auto rem, auto first, auto last)
{
    for (std::cout &lt;&lt; rem; first != last; std::cout &lt;&lt; *first++ &lt;&lt; ' ') {}
    std::cout &lt;&lt; '\n';
};

int main()
{
    std::array v {1, 2, 3, 4, 5, 6, 7, 8, 9};

    auto is_even = [](int i) { return i % 2 == 0; };

    std::ranges::partition(v, is_even);
    print_seq("After partitioning, v: ", v.cbegin(), v.cend());

    const auto pp = std::ranges::partition_point(v, is_even);
    const auto i = std::ranges::distance(v.cbegin(), pp);
    std::cout &lt;&lt; "Partition point is at " &lt;&lt; i &lt;&lt; "; v[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; *pp &lt;&lt; '\n';

    print_seq("First partition (all even elements): ", v.cbegin(), pp);
    print_seq("Second partition (all odd elements): ", pp, v.cend());
}
|p=true
|output=
After partitioning, v: 2 4 6 8 5 3 7 1 9
Partition point is at 4; v[4] = 5
First partition (all even elements): 2 4 6 8
Second partition (all odd elements): 5 3 7 1 9
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc is_sorted}}
{{dsc inc|cpp/algorithm/ranges/dsc lower_bound}}
{{dsc inc|cpp/algorithm/dsc partition_point}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}