{{cpp/ranges/title|transform|unary_transform_result|binary_transfor_result}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl|since=c++20|num=1|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S, std::weakly_incrementable O,
          std::copy_constructible F, class Proj = std::identity &gt;
requires std::indirectly_writable&lt;O,
                                  std::indirect_result_t&lt;F&amp;, std::projected&lt;I, Proj&gt;&gt;&gt;
constexpr unary_transform_result&lt;I, O&gt;
    transform( I first1, S last1, O result, F op, Proj proj = {} );
}}
{{dcl|since=c++20|num=2|1=
template&lt; ranges::input_range R, std::weakly_incrementable O,
          std::copy_constructible F, class Proj = std::identity &gt;
requires std::indirectly_writable&lt;O,
             std::indirect_result_t&lt;F&amp;, std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt;&gt;
constexpr unary_transform_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    transform( R&amp;&amp; r, O result, F op, Proj proj = {} );
}}
{{dcl|since=c++20|num=3|1=
template&lt; std::input_iterator I1, std::sentinel_for&lt;I1&gt; S1,
          std::input_iterator I2, std::sentinel_for&lt;I2&gt; S2,
          std::weakly_incrementable O,
          std::copy_constructible F,
          class Proj1 = std::identity, class Proj2 = std::identity &gt;
requires std::indirectly_writable&lt;O,
             std::indirect_result_t&lt;F&amp;,
                                    std::projected&lt;I1, Proj1&gt;,
                                    std::projected&lt;I2, Proj2&gt;&gt;&gt;
constexpr binary_transform_result&lt;I1, I2, O&gt;
    transform( I1 first1, S1 last1, I2 first2, S2 last2, O result,
               F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {} );
}}
{{dcl|since=c++20|num=4|1=
template&lt; ranges::input_range R1,
          ranges::input_range R2,
          std::weakly_incrementable O,
          std::copy_constructible F,
          class Proj1 = std::identity, class Proj2 = std::identity &gt;
requires std::indirectly_writable&lt;O,
             std::indirect_result_t&lt;F&amp;,
                 std::projected&lt;ranges::iterator_t&lt;R1&gt;, Proj1&gt;,
                 std::projected&lt;ranges::iterator_t&lt;R2&gt;, Proj2&gt;&gt;&gt;
constexpr binary_transform_result&lt;ranges::borrowed_iterator_t&lt;R1&gt;,
                                  ranges::borrowed_iterator_t&lt;R2&gt;, O&gt;
    transform( R1&amp;&amp; r1, R2&amp;&amp; r2, O result, F binary_op,
               Proj1 proj1 = {}, Proj2 proj2 = {} );
}}
{{dcl h|辅助类型}}
{{dcl|since=c++20|num=5|1=
template&lt; class I, class O &gt;
using unary_transform_result = ranges::in_out_result&lt;I, O&gt;;
}}
{{dcl|since=c++20|num=6|1=
template&lt; class I1, class I2, class O &gt;
using binary_transform_result = ranges::in_in_out_result&lt;I1, I2, O&gt;;
}}
{{dcl end}}

对范围应用给定的函数并将结果存储于始于 {{c|result}} 的另一范围。
@1@ 应用一元运算 {{c|op}} 到 {{range|first1|last1}} 所定义的范围（在以投影 {{c|proj}} 投影后）。
@2@ 同 {{v|1}}，但以 {{c|r}} 为源范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。
@3@ 应用二元运算 {{c|binary_op}} 到来自两个范围的元素：一个由 {{range|first1|last1}} 定义而另一个由 {{range|first2|last2}} 定义（在分别以投影 {{c|proj1}} 与 {{c|proj2}} 投影后）。
@4@ 同 {{v|3}}，但以 {{c|r1}} 为第一源范围，如同以 {{c|ranges::begin(r1)}} 为 {{c|first1}} 并以 {{c|ranges::end(r1)}} 为 {{c|last1}}，而对 {{c|r2}} 也类似。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|first1|last1|要变换的|range=第一|sentinel=yes}}
{{par|r, r1|要变换的元素范围}}
{{par range|first2|last2|要变换的|range=第二|sentinel=yes}}
{{par|r2|要变换的第二元素范围}}
{{par|result|目标范围的起始，可以等于 {{tt|first1}} 或 {{tt|first2}} }}
{{par|op, binary_op|应用到投影后元素的操作}}
{{par|proj1|应用到第一范围中的元素的投影}}
{{par|proj2|应用到第二范围中的元素的投影}}
{{par end}}

===返回值===
@1,2@ {{tt|unary_transform_result}}，含有等于 {{c|last}} 的输入迭代器与指向最后变换元素后一元素的输出迭代器。
@3,4@ {{tt|binary_transform_result}}，含有分别作为 {{tt|in1}} 与 {{tt|in2}} 的指向来自范围 {{range|first1|last1}} 与 {{range|first2|last2}} 的最后变换元素的输入迭代器，与作为 {{c|out}} 的指向最后变换元素后一元素的输出迭代器。

===复杂度===
@1,2@ 准确应用 {{c|ranges::distance(first1, last1)}} 次 {{c|op}} 与 {{c|proj}}。

@3,4@ 准确应用 {{c|ranges::min(ranges::distance(first1, last1), ranges::distance(first2, last2))}} 次 {{c|binary_op}} 与投影。

===可能的实现===
{{eq fun|1=
struct transform_fn
{
    // 版本 (1)
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, std::weakly_incrementable O,
             std::copy_constructible F, class Proj = std::identity&gt;
    requires std::indirectly_writable&lt;O, std::indirect_result_t&lt;F&amp;,
                                                                std::projected&lt;I, Proj&gt;&gt;&gt;
    constexpr ranges::unary_transform_result&lt;I, O&gt;
        operator()(I first1, S last1, O result, F op, Proj proj = {}) const
    {
        for (; first1 != last1; ++first1, (void)++result)
            *result = std::invoke(op, std::invoke(proj, *first1));

        return {std::move(first1), std::move(result)};
    }

    // 版本 (2)
    template&lt;ranges::input_range R, std::weakly_incrementable O,
             std::copy_constructible F, class Proj = std::identity&gt;
    requires std::indirectly_writable&lt;O,
                 std::indirect_result_t&lt;F&amp;, std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt;&gt;
    constexpr ranges::unary_transform_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
        operator()(R&amp;&amp; r, O result, F op, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(result),
                       std::move(op), std::move(proj));
    }

    // 版本 (3)
    template&lt;std::input_iterator I1, std::sentinel_for&lt;I1&gt; S1,
             std::input_iterator I2, std::sentinel_for&lt;I2&gt; S2,
             std::weakly_incrementable O,
             std::copy_constructible F,
             class Proj1 = std::identity, class Proj2 = std::identity&gt;
    requires std::indirectly_writable&lt;O,
                 std::indirect_result_t&lt;F&amp;,
                                        std::projected&lt;I1, Proj1&gt;,
                                        std::projected&lt;I2, Proj2&gt;&gt;&gt;
    constexpr ranges::binary_transform_result&lt;I1, I2, O&gt;
        operator()(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                   F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {}) const
    {
        for (; first1 != last1 &amp;&amp; first2 != last2;
             ++first1, (void)++first2, (void)++result)
            *result = std::invoke(binary_op,
                                  std::invoke(proj1, *first1),
                                  std::invoke(proj2, *first2));

        return {std::move(first1), std::move(first2), std::move(result)};
    }

    // 版本 (4)
    template&lt;ranges::input_range R1, ranges::input_range R2,
             std::weakly_incrementable O, std::copy_constructible F,
             class Proj1 = std::identity, class Proj2 = std::identity&gt;
    requires std::indirectly_writable&lt;O,
                 std::indirect_result_t&lt;F&amp;,
                     std::projected&lt;ranges::iterator_t&lt;R1&gt;, Proj1&gt;,
                     std::projected&lt;ranges::iterator_t&lt;R2&gt;, Proj2&gt;&gt;&gt;
    constexpr ranges::binary_transform_result&lt;ranges::borrowed_iterator_t&lt;R1&gt;,
                                              ranges::borrowed_iterator_t&lt;R2&gt;, O&gt;
        operator()(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,
                   F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {}) const
    {
        return (*this)(ranges::begin(r1), ranges::end(r1),
                       ranges::begin(r2), ranges::end(r2),
                       std::move(result), std::move(binary_op),
                       std::move(proj1), std::move(proj2));
    }
};

inline constexpr transform_fn transform;
}}

===注解===
{{tt|std::ranges::transform}} 不保证按顺序应用 {{tt|op}} 或 {{tt|binary_op}}。为按顺序应用函数导序列或应用修改元素的函数到序列，请用 {{lc|std::ranges::for_each}}。

===示例===
{{example
 | 下列代码用 {{tt|ranges::transform}} 以 {{lc|std::toupper}} 函数原地转换为大写，然后变换每个 {{c/core|char}} 为其序数值。然后以一个投影用 {{tt|ranges::transform}} 将 {{c/core|std::vector&lt;Foo&gt;}} 的元素变换为 {{c/core|char}}，并填充一个 {{lc|std::string}}。
 | code=
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
 
int main()
{
    std::string s{"hello"};
    auto op = [](unsigned char c) -&gt; unsigned char { return std::toupper(c); };
  
    namespace ranges = std::ranges;

    // 字符串就地改为大写
    ranges::transform(s.begin(), s.end(), s.begin(), op );

    std::vector&lt;std::size_t&gt; ordinals;
    // 将每个 char 转换为 size_t
    ranges::transform(s, std::back_inserter(ordinals),
                      [](unsigned char c) -&gt; std::size_t { return c; });

    std::cout &lt;&lt; s &lt;&lt; ':';
    for (auto ord : ordinals)
        std::cout &lt;&lt; ' ' &lt;&lt; ord;

    // 使每个序数倍增
    ranges::transform(ordinals, ordinals, ordinals.begin(), std::plus{});

    std::cout &lt;&lt; '\n';
    for (auto ord : ordinals)
        std::cout &lt;&lt; ord &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    struct Foo { char bar; };
    const std::vector&lt;Foo&gt; f = {{'h'},{'e'},{'l'},{'l'},{'o'}};
    std::string result;
    // 投影，然后转大写
    ranges::transform(f, std::back_inserter(result), op, &amp;Foo::bar);
    std::cout &lt;&lt; result &lt;&lt; '\n';
}
|output=
HELLO: 72 69 76 76 79
144 138 152 152 158
HELLO
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc for_each}}
{{dsc inc|cpp/ranges/dsc transform_view}}
{{dsc inc|cpp/algorithm/dsc transform}}
{{dsc end}}

{{langlinks|en|es|ja}}