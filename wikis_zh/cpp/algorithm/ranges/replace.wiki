{{cpp/ranges/title|replace|replace_if}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl rev begin|num=1}}
{{dcla|anchor=版本_1|since=c++20|until=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class T1, class T2, class Proj = std::identity &gt;
requires std::indirectly_writable&lt;I, const T2&amp;&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T1*&gt;
constexpr I replace( I first, S last, const T1&amp; old_value,
                     const T2&amp; new_value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          class T1 = std::projected_value_t&lt;I, Proj&gt;, class T2 = T1 &gt;
requires std::indirectly_writable&lt;I, const T2&amp;&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T1*&gt;
constexpr I replace( I first, S last, const T1&amp; old_value,
                     const T2&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::input_range R,
          class T1, class T2, class Proj = std::identity &gt;
requires std::indirectly_writable&lt;ranges::iterator_t&lt;R&gt;, const T2&amp;&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    replace( R&amp;&amp; r, const T1&amp; old_value,
             const T2&amp; new_value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::input_range R,
          class Proj = std::identity,
          class T1 = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
          class T2 = T1 &gt;
requires std::indirectly_writable&lt;ranges::iterator_t&lt;R&gt;, const T2&amp;&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    replace( R&amp;&amp; r, const T1&amp; old_value,
             const T2&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=3}}
{{dcla|anchor=版本_3|since=c++20|until=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class T, class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
requires std::indirectly_writable&lt;I, const T&amp;&gt;
constexpr I replace_if( I first, S last, Pred pred,
                        const T&amp; new_value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;I, Proj&gt;,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
requires std::indirectly_writable&lt;I, const T&amp;&gt;
constexpr I replace_if( I first, S last, Pred pred,
                        const T&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=4}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::input_range R, class T, class Proj = std::identity,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
requires std::indirectly_writable&lt;ranges::iterator_t&lt;R&gt;, const T&amp;&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    replace_if( R&amp;&amp; r, Pred pred, const T&amp; new_value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
requires std::indirectly_writable&lt;ranges::iterator_t&lt;R&gt;, const T&amp;&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    replace_if( R&amp;&amp; r, Pred pred, const T&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl end}}

以 {{c|new_value}} 替换范围 {{range|first|last}} 中所有满足特定判别标准的元素。

@1@ 替换所有等于 {{tt|old_value}} 的元素。用 {{c|1=std::invoke(proj, *i) == old_value}} 比较。
@3@ 替换所有谓词 {{tt|pred}} 对其求值为 {{c|true}} 的元素，其中求值的表达式为 {{c|std::invoke(pred, std::invoke(proj, *i))}}。
@2,4@ 同 {{v|1,3}}，但以 {{tt|r}} 为范围，如同以 {{c|ranges::begin(r)}} 为 {{tt|first}} 并以 {{c|ranges::end(r)}} 为 {{tt|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要处理的|sentinel=yes}}
{{par|r|要处理的元素范围}}
{{par|old_value|要替换的元素的值}}
{{par|new_value|要用作替换品的值}}
{{par|pred|应用到投影后元素的谓词}}
{{par|proj|应用到谓词的投影}}
{{par end}}

===返回值===
等于 {{tt|last}} 的迭代器。

===复杂度===
准确应用 {{c|ranges::distance(first, last)}} 次对应的谓词 {{tt|comp}} 与任何投影 {{tt|proj}}。

===注解===
由于算法按引用接收 {{c|old_value}} 与 {{c|new_value}} ，它可能在任一参数为到范围 {{range|first|last}} 中元素的引用时有非期待的行为。

{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|算法中的[[cpp/language/list initialization|列表初始化]] {{vl|1-4}}}}

===可能的实现===
{{eq impl|
|title1=replace (1,2)|ver1=1|1=
struct replace_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             class T1 = std::projected_value_t&lt;I, Proj&gt;, class T2 = T1&gt;
    requires std::indirectly_writable&lt;I, const T2&amp;&gt; &amp;&amp; 
             std::indirect_binary_predicate
                 &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T1*&gt;
    constexpr I operator()(I first, S last, const T1&amp; old_value,
                           const T2&amp; new_value, Proj proj = {}) const
    {
        for (; first != last; ++first)
            if (old_value == std::invoke(proj, *first))
                *first = new_value;
        return first;
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity
             class T1 = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
             class T2 = T1&gt;
    requires std::indirectly_writable&lt;ranges::iterator_t&lt;R&gt;, const T2&amp;&gt; &amp;&amp;
             std::indirect_binary_predicate&lt;ranges::equal_to,
             std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, const T1&amp; old_value,
                   const T2&amp; new_value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), old_value,
                       new_value, std::move(proj));
    }
};

inline constexpr replace_fn replace{};
|title2=replace_if (3,4)|ver2=3|2=
struct replace_if_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity, class T = std::projected_value_t&lt;I, Proj&gt;,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires std::indirectly_writable&lt;I, const T&amp;&gt;
    constexpr I operator()(I first, S last, Pred pred,
                           const T&amp; new_value, Proj proj = {}) const
    {
        for (; first != last; ++first)
            if (!!std::invoke(pred, std::invoke(proj, *first)))
                *first = new_value;
        return std::move(first);
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity,
             class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;
             std::indirect_unary_predicate
                 &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires std::indirectly_writable&lt;ranges::iterator_t&lt;R&gt;, const T&amp;&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, Pred pred, const T&amp; new_value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(pred),
                       new_value, std::move(proj));
    }
};

inline constexpr replace_if_fn replace_if{};
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;

void println(const auto&amp; v)
{
    for (const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    namespace ranges = std::ranges;
 
    std::array p{1, 6, 1, 6, 1, 6};
    println(p);
    ranges::replace(p, 6, 9);
    println(p);
 
    std::array q{1, 2, 3, 6, 7, 8, 4, 5};
    println(q);
    ranges::replace_if(q, [](int x) { return 5 &lt; x; }, 5);
    println(q);
 
    std::array&lt;std::complex&lt;double&gt;, 2&gt; nums{&lt;!----&gt;{&lt;!----&gt;{1, 3}, {1, 3}&lt;!----&gt;}&lt;!----&gt;};
    println(nums);
    #ifdef __cpp_lib_algorithm_default_value_type
        ranges::replace(nums, {1, 3}, {4, 2});
    #else
        ranges::replace(nums, std::complex&lt;double&gt;{1, 3}, std::complex&lt;double&gt;{4, 2});
    #endif
    println(nums);
}
|output=
1 6 1 6 1 6
1 9 1 9 1 9
1 2 3 6 7 8 4 5
1 2 3 5 5 5 4 5
(1,3) (1,3)
(4,2) (4,2)
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc replace_copy}}
{{dsc inc|cpp/algorithm/dsc replace}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}