{{cpp/ranges/title|adjacent_find}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl|since=c++20|num=1|1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
          std::indirect_binary_predicate&lt;
              std::projected&lt;I, Proj&gt;,
              std::projected&lt;I, Proj&gt;&gt; Pred = ranges::equal_to &gt;
constexpr I
    adjacent_find( I first, S last, Pred pred = {}, Proj proj = {} );
}}
{{dcl|since=c++20|num=2|1=
template&lt; ranges::forward_range R, class Proj = std::identity,
          std::indirect_binary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred = ranges::equal_to &gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    adjacent_find( R&amp;&amp; r, Pred pred = {}, Proj proj = {} );
}}
{{dcl end}}

搜索范围 {{range|first|last}} 中首次出现的两个连续的相等元素。

@1@ 用 {{c|pred}}（在以投影 {{c|proj}} 投影后）比较元素。
@2@ 同 {{v|1}}，但以 {{c|r}} 为源范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要检验的|sentinel=yes}}
{{par|r|要检验的范围}}
{{par|pred|应用到投影后元素的谓词}}
{{par|proj|应用到元素的投影}}
{{par end}}

===返回值===
指向首对等同元素的前一者的迭代器，即首个使得 {{c|bool(std::invoke(pred, std::invoke(proj1, *it), std::invoke(proj, *(it + 1))))}} 为 {{c|true}} 的 {{tt|it}}。

若找不到这种元素，则返回等于 {{c|last}} 的迭代器。

===复杂度===
准确应用 {{c|min((result - first) + 1, (last - first) - 1)}} 次谓词与投影，其中 {{tt|result}} 是返回值。

===可能的实现===
{{eq fun | 1=
struct adjacent_find_fn
{
    template&lt;std::forward_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirect_binary_predicate&lt;
                 std::projected&lt;I, Proj&gt;,
                 std::projected&lt;I, Proj&gt;&gt; Pred = ranges::equal_to&gt;
    constexpr I operator()(I first, S last, Pred pred = {}, Proj proj = {}) const
    {
        if (first == last)
            return first;
        auto next = ranges::next(first);
        for (; next != last; ++next, ++first)
            if (std::invoke(pred, std::invoke(proj, *first), std::invoke(proj, *next)))
                return first;
        return next;
    }

    template&lt;ranges::forward_range R, class Proj = std::identity,
             std::indirect_binary_predicate&lt;
                 std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
                 std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred = ranges::equal_to&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, Pred pred = {}, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::ref(pred), std::ref(proj));
    }
};

inline constexpr adjacent_find_fn adjacent_find;
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;

constexpr bool some_of(auto&amp;&amp; r, auto&amp;&amp; pred) // 一些但非全部
{
    return std::ranges::cend(r) != std::ranges::adjacent_find(r,
        [&amp;pred](auto const&amp; x, auto const&amp; y)
        {
            return pred(x) != pred(y);
        });
}

// 测试 some_of
constexpr auto a = {0, 0, 0, 0}, b = {1, 1, 1, 0}, c = {1, 1, 1, 1};
auto is_one = [](auto x){ return x == 1; };
static_assert(!some_of(a, is_one) &amp;&amp; some_of(b, is_one) &amp;&amp; !some_of(c, is_one));

int main()
{
    const auto v = {0, 1, 2, 3, 40, 40, 41, 41, 5}; /*
                                ^^          ^^       */
    namespace ranges = std::ranges;

    if (auto it = ranges::adjacent_find(v.begin(), v.end()); it == v.end())
        std::cout &lt;&lt; "无匹配的相邻元素\n";
    else
        std::cout &lt;&lt; "相邻的相等元素对中的第一个位于 ["
                  &lt;&lt; ranges::distance(v.begin(), it) &lt;&lt; "] == " &lt;&lt; *it &lt;&lt; '\n';

    if (auto it = ranges::adjacent_find(v, ranges::greater()); it == v.end())
        std::cout &lt;&lt; "整个 vector 以升序排序\n";
    else
        std::cout &lt;&lt; "非降序子序列中最后一个元素位于 ["
                  &lt;&lt; ranges::distance(v.begin(), it) &lt;&lt; "] == " &lt;&lt; *it &lt;&lt; '\n';
}
|output=
相邻的相等元素对中的第一个位于 [4] == 40
非降序子序列中最后一个元素位于 [7] == 41
}}

===参阅===
{{dsc begin}}
{{dsc inc | cpp/algorithm/ranges/dsc unique}}
{{dsc inc | cpp/algorithm/dsc adjacent_find}}
{{dsc end}}

{{langlinks|en|es|ja}}