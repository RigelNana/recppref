{{cpp/ranges/title|find_last|find_last_if|find_last_if_not}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl rev multi|num=1|since1=c++23|until1=c++26|dcl1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
          class T,
          class Proj = std::identity &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr ranges::subrange&lt;I&gt;
    find_last( I first, S last, const T&amp; value, Proj proj = {} );
|dcl2=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;I, Proj&gt; &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr ranges::subrange&lt;I&gt;
    find_last( I first, S last, const T&amp; value, Proj proj = {} );
}}
{{dcl rev multi|num=2|since1=c++23|until1=c++26|dcl1=
template&lt; ranges::forward_range R,
          class T,
          class Proj = std::identity &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    find_last( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
|dcl2=
template&lt; ranges::forward_range R,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;iterator_t&lt;R&gt;, Proj&gt; &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    find_last( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
}}
{{dcla|since=c++23|num=3|1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr ranges::subrange&lt;I&gt;
    find_last_if( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++23|num=4|1=
template&lt; ranges::forward_range R,
          class Proj = std::identity,
          std::indirect_unary_predicate
              &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    find_last_if( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcla|since=c++23|num=5|1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr ranges::subrange&lt;I&gt;
    find_last_if_not( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++23|num=6|1=
template&lt; ranges::forward_range R,
          class Proj = std::identity,
          std::indirect_unary_predicate
              &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    find_last_if_not( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcl end}}

返回范围 {{range|first|last}} 中符合特定条件的最后一个元素：
@1@ {{tt|find_last}} 搜索等于 {{c|value}} 的元素。

@3@ {{tt|find_last_if}} 搜索范围 {{range|first|last}} 中谓词 {{c|pred}} 为之返回 {{c|true}} 的最后一个元素。

@5@ {{tt|find_last_if_not}} 搜索范围 {{range|first|last}} 中谓词 {{c|pred}} 为之返回 {{c|false}} 的最后一个元素。

@2,4,6@ 与 {{v|1,3,5}} 相同，但使用 {{c|r}} 作为源范围，就像使用 {{c|ranges::begin(r)}} 作为 {{c|first}} 和 {{c|ranges::end(r)}} 作为 {{c|last}} 一样。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要检验的|sentinel=yes}}
{{par|r|要检查的元素的范围}}
{{par|value|和元素进行比较的值}}
{{par|pred|应用到投影后元素的谓词}}
{{par|proj|应用到元素的投影}}
{{par end}}

===返回值===
@1,2,3@ 设 {{tt|i}} 是 {{range|first|last}} 范围内使得 {{c|E}} 是 {{c|true}} 的最后一个迭代器。
@@ 返回 {{c|ranges::subrange&lt;I&gt;{i, last}&lt;!----&gt;}}，如果不存在这样的迭代器，则返回 {{c|ranges::subrange&lt;I&gt;{last, last}&lt;!----&gt;}}。
:@1@ {{c|E}} 是 {{c|1=bool(std::invoke(proj, *i) == value)}}。
:@3@ {{c|E}} 是 {{c|bool(std::invoke(pred, std::invoke(proj, *i)))}}。
:@5@ {{c|E}} 是 {{c|bool(!std::invoke(pred, std::invoke(proj, *i)))}}。

@2,4,6@ 和 {{v|1,3,5}} 类似，但是返回值类型是 {{c|ranges::borrowed_subrange_t&lt;I&gt;}}。

===复杂度===
最多应用 {{c|last - first}} 次谓词和投影。

===注解===
如果 {{tt|ranges::find_last}}、{{tt|ranges::find_last_if}}、{{tt|ranges::find_last_if_not}} 的 {{c|I}} 为 {{lconcept|bidirectional_iterator}} 或（更好的）{{lconcept|random_access_iterator}}，则它们在通用实现上的效率更高。

{{ftm begin}}
{{ftm|std=C++23|value=202207L|__cpp_lib_ranges_find_last|{{tt|ranges::find_last}}，&lt;br&gt;{{tt|ranges::find_last_if}}，&lt;br&gt;{{tt|ranges::find_last_if_not}}}}
{{ftm|__cpp_lib_algorithm_default_value_type|value=202403L|std=C++26|算法的[[cpp/language/list initialization|列表初始化]] {{vl|1,2}}}}
{{ftm end}}

===可能的实现===
这个实现只展示 {{tt|I}} 为 {{lconcept|forward_iterator}} 时较慢的算法。
{{eq impl
|title1=find_last (1,2)|ver1=1|1=
struct find_last_fn
{
    template&lt;std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity,
             class T = std::projected_value_t&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;
    requires std::indirect_binary_predicate
                 &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
    constexpr ranges::subrange&lt;I&gt;
        operator()(I first, S last, const T &amp;value, Proj proj = {}) const
    {
        // 注意：如果 I 只是 forward_iterator，那么只能从头走到尾。
        std::optional&lt;I&gt; found;
        for (; first != last; ++first)
            if (std::invoke(proj, *first) == value)
                found = first;
        
        if (!found)
            return {first, first};
        
        return {*found, std::ranges::next(*found, last)};
    }
    
    template&lt;ranges::forward_range R,
             class Proj = std::identity,
             class T = std::projected_value_t&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;
    requires std::indirect_binary_predicate
                 &lt;ranges::equal_to,
                  std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
    constexpr ranges::borrowed_subrange_t&lt;R&gt;
        operator()(R&amp;&amp; r, const T &amp;value, Proj proj = {}) const
    {
        return this-&gt;operator()(ranges::begin(r), ranges::end(r), value, std::ref(proj));
    }
};

inline constexpr find_last_fn find_last;
|title2=find_last_if (3,4)|ver2=3|2=
struct find_last_if_fn
{
    template&lt;std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr ranges::subrange&lt;I&gt;
        operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        // 注意：如果 I 只是 forward_iterator，那么只能从头走到尾。
        std::optional&lt;I&gt; found;
        for (; first != last; ++first)
            if (std::invoke(pred, std::invoke(proj, *first)))
                found = first;
        
        if (!found)
            return {first, first};
        
        return {*found, std::ranges::next(*found, last)};
    }
    
    template&lt;ranges::forward_range R, class Proj = std::identity,
             std::indirect_unary_predicate
                 &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    constexpr ranges::borrowed_subrange_t&lt;R&gt;
        operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return this-&gt;operator()(ranges::begin(r), ranges::end(r),
                                std::ref(pred), std::ref(proj));
    }
};

inline constexpr find_last_if_fn find_last_if;
|title3=find_last_if_not (5,6)|ver3=5|3=
struct find_last_if_not_fn
{
    template&lt;std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr ranges::subrange&lt;I&gt;
        operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        // 注意：如果 I 只是 forward_iterator，那么只能从头走到尾。
        std::optional&lt;I&gt; found;
        for (; first != last; ++first)
            if (!std::invoke(pred, std::invoke(proj, *first)))
                found = first;
        
        if (!found)
            return {first, first};
        
        return {*found, std::ranges::next(*found, last)};
    }
    
    template&lt;ranges::forward_range R, class Proj = std::identity,
             std::indirect_unary_predicate
                 &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    constexpr ranges::borrowed_subrange_t&lt;R&gt;
        operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return this-&gt;operator()(ranges::begin(r), ranges::end(r),
                                std::ref(pred), std::ref(proj));
    }
};

inline constexpr find_last_if_not_fn find_last_if_not;
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;forward_list&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;

int main()
{
    namespace ranges = std::ranges;
    
    constexpr static auto v = {1, 2, 3, 1, 2, 3, 1, 2};
    
    {
        constexpr auto i1 = ranges::find_last(v.begin(), v.end(), 3);
        constexpr auto i2 = ranges::find_last(v, 3);
        static_assert(ranges::distance(v.begin(), i1.begin()) == 5);
        static_assert(ranges::distance(v.begin(), i2.begin()) == 5);
    }
    {
        constexpr auto i1 = ranges::find_last(v.begin(), v.end(), -3);
        constexpr auto i2 = ranges::find_last(v, -3);
        static_assert(i1.begin() == v.end());
        static_assert(i2.begin() == v.end());
    }
    
    auto abs = [](int x) { return x &lt; 0 ? -x : x; };
    
    {
        auto pred = [](int x) { return x == 3; };
        constexpr auto i1 = ranges::find_last_if(v.begin(), v.end(), pred, abs);
        constexpr auto i2 = ranges::find_last_if(v, pred, abs);
        static_assert(ranges::distance(v.begin(), i1.begin()) == 5);
        static_assert(ranges::distance(v.begin(), i2.begin()) == 5);
    }
    {
        auto pred = [](int x) { return x == -3; };
        constexpr auto i1 = ranges::find_last_if(v.begin(), v.end(), pred, abs);
        constexpr auto i2 = ranges::find_last_if(v, pred, abs);
        static_assert(i1.begin() == v.end());
        static_assert(i2.begin() == v.end());
    }
    
    {
        auto pred = [](int x) { return x == 1 or x == 2; };
        constexpr auto i1 = ranges::find_last_if_not(v.begin(), v.end(), pred, abs);
        constexpr auto i2 = ranges::find_last_if_not(v, pred, abs);
        static_assert(ranges::distance(v.begin(), i1.begin()) == 5);
        static_assert(ranges::distance(v.begin(), i2.begin()) == 5);
    }
    {
        auto pred = [](int x) { return x == 1 or x == 2 or x == 3; };
        constexpr auto i1 = ranges::find_last_if_not(v.begin(), v.end(), pred, abs);
        constexpr auto i2 = ranges::find_last_if_not(v, pred, abs);
        static_assert(i1.begin() == v.end());
        static_assert(i2.begin() == v.end());
    }
    
    using P = std::pair&lt;std::string_view, int&gt;;
    std::forward_list&lt;P&gt; list
    {
        {"one", 1}, {"two", 2}, {"three", 3},
        {"one", 4}, {"two", 5}, {"three", 6},
    };
    auto cmp_one = [](const std::string_view &amp;s) { return s == "one"; };
    
    // 寻找满足比较器的最后一个元素，其按 pair::first 投影
    const auto subrange = ranges::find_last_if(list, cmp_one, &amp;P::first);
    
    std::cout &lt;&lt; "所找到的元素和其后的尾部为:\n";
    for (P const&amp; e : subrange)
        std::cout &lt;&lt; '{' &lt;&lt; std::quoted(e.first) &lt;&lt; ", " &lt;&lt; e.second &lt;&lt; "} ";
    std::cout &lt;&lt; '\n';
    
#if __cpp_lib_algorithm_default_value_type
    const auto i3 = ranges::find_last(list, {"three", 3}); // (2) C++26
#else
    const auto i3 = ranges::find_last(list, P{"three", 3}); // (2) C++23
#endif
    assert(i3.begin()-&gt;first == "three" &amp;&amp; i3.begin()-&gt;second == 3);
}
|output=
所找到的元素和其后的尾部为:
{"one", 4} {"two", 5} {"three", 6}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc find_end}}
{{dsc inc|cpp/algorithm/ranges/dsc find}}
{{dsc inc|cpp/algorithm/ranges/dsc search}}
{{dsc inc|cpp/algorithm/ranges/dsc includes}}
{{dsc inc|cpp/algorithm/ranges/dsc binary_search}}
{{dsc inc|cpp/algorithm/ranges/dsc contains}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|en}}