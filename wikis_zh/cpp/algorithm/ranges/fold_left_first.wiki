{{cpp/ranges/title|fold_left_first}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|调用签名}}
{{dcl|num=1|since=c++23|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          /*indirectly-binary-left-foldable*/&lt;std::iter_value_t&lt;I&gt;, I&gt; F &gt;
requires std::constructible_from&lt;std::iter_value_t&lt;I&gt;, std::iter_reference_t&lt;I&gt;&gt;
constexpr auto
    fold_left_first( I first, S last, F f );
}}
{{dcl|num=2|since=c++23|1=
template&lt; ranges::input_range R,
          /*indirectly-binary-left-foldable*/&lt;
                ranges::range_value_t&lt;R&gt;, ranges::iterator_t&lt;R&gt;&gt; F &gt;
requires std::constructible_from&lt;
             ranges::range_value_t&lt;R&gt;, ranges::range_reference_t&lt;R&gt;&gt;
constexpr auto
    fold_left_first( R&amp;&amp; r, F f );
}}
{{dcl h|辅助概念}}
{{dcl|num=3|notes={{mark expos}}|1=
template&lt; class F, class T, class I &gt;
concept /*indirectly-binary-left-foldable*/ = /* 见说明 */;
}}
{{dcl end}}

左{{enwiki|Fold (higher-order function)|折叠}}给定范围的元素，当 {{tt|x{{sub|1}}}}, {{tt|x{{sub|2}}}}, ..., {{tt|x{{sub|n}}}} 为范围内元素时返回链式表达式 {{tt|f(f(f(f(x{{sub|1}}, x{{sub|2}}), x{{sub|3}}), ...), x{{sub|n}})}} 的求值结果。

非正式地说，除了将 {{c|*first}} 用作首个元素之外，{{tt|ranges::fold_left_first}} 行为类似 {{lc|std::accumulate}} 接受二元谓词的重载。

如果 {{range|first|last}} 不是有效范围则行为未定义。

@1@ 范围为 {{range|first|last}}。它等价于
{{c|return ranges::fold_left_first_with_iter(std::move(first), last, f).value}}。

@2@ 同 {{v|1}}，但使用 {{c|r}} 作为其范围，如同使用 {{c|ranges::begin(r)}} 作为 {{c|first}} 并且使用 {{c|ranges::end(r)}} 作为 {{c|last}}。

{{ranges_fold_algos_helper_concepts}}
{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要折叠的|sentinel=yes}}
{{par|r|应用折叠的范围}}
{{par|f|二元{{named req|FunctionObject|函数对象}}}}
{{par end}}

===返回值===
容纳了给定范围上执行 {{c|f}} 的左{{enwiki|Fold (higher-order function)|折叠}}结果的 {{c|std::optional&lt;U&gt;}} 类型对象，其中{{c|U}} 等价于
{{c|decltype(ranges::fold_left(std::move(first), last, std::iter_value_t&lt;I&gt;(*first), f))}}。

如果范围为空，返回{{c|std::optional&lt;U&gt;()}}。

===可能的实现===
{{eq fun
|1=
struct fold_left_first_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             /*indirectly-binary-left-foldable*/&lt;std::iter_value_t&lt;I&gt;, I&gt; F&gt;
    requires
        std::constructible_from&lt;std::iter_value_t&lt;I&gt;, std::iter_reference_t&lt;I&gt;&gt;
    constexpr auto operator()(I first, S last, F f) const
    {
        using U = decltype(
            ranges::fold_left(std::move(first), last, std::iter_value_t&lt;I&gt;(*first), f)
        );
        if (first == last)
            return std::optional&lt;U&gt;();
        std::optional&lt;U&gt; init(std::in_place, *first);
        for (++first; first != last; ++first)
            *init = std::invoke(f, std::move(*init), *first);
        return std::move(init);
    }

    template&lt;ranges::input_range R,
             /*indirectly-binary-left-foldable*/&lt;
                 ranges::range_value_t&lt;R&gt;, ranges::iterator_t&lt;R&gt;&gt; F&gt;
    requires
        std::constructible_from&lt;ranges::range_value_t&lt;R&gt;, ranges::range_reference_t&lt;R&gt;&gt;
    constexpr auto operator()(R&amp;&amp; r, F f) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::ref(f));
    }
};

inline constexpr fold_left_first_fn fold_left_first;
}}

===复杂度===
准确应用 {{c|ranges::distance(first, last) - 1}}（假设范围不为空）次函数对象 {{c|f}}。

===注解===
{{ranges_fold_algos_table}}

{{feature test macro|__cpp_lib_ranges_fold|std=C++23|value=202207L|{{tt|std::ranges}} [[cpp/algorithm/ranges#受约束的折叠操作|折叠算法]]}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;functional&gt;
#include &lt;ranges&gt;
#include &lt;utility&gt;
 
int main()
{
    constexpr std::array v{1, 2, 3, 4, 5, 6, 7, 8};
    static_assert
    (
         *std::ranges::fold_left_first(v.begin(), v.end(), std::plus{}) == 36
         &amp;&amp; *std::ranges::fold_left_first(v, std::multiplies{}) == 40320
    );
 
    constexpr std::array w
    {
        1, 2, 3, 4, 13,
        1, 2, 3, 4, 13,
        1, 2, 3, 4, 13,
        1, 2, 3, 4,
    };
    static_assert
    (
        "查找唯一（作为前提条件）出现奇数次的值："
        &amp;&amp; *std::ranges::fold_left_first(w, [](int p, int q){ return p ^ q; }) == 13
    );
 
    constexpr auto pairs = std::to_array&lt;std::pair&lt;char, float&gt;&gt;
    ({
        {'A', 3.0f},
        {'B', 3.5f},
        {'C', 4.0f}
    });
    static_assert
    (
        "获得所有 pair 的 pair::second 的乘积："
        &amp;&amp; *std::ranges::fold_left_first
        (
            pairs {{!}} std::ranges::views::values, std::multiplies{}
        ) == 42
    );
}
}}

===引用===
{{ref std c++23}}
{{ref std|title=Fold|id=alg.fold|section=27.6.18}}
{{ref std end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc fold_left}}
{{dsc inc|cpp/algorithm/ranges/dsc fold_right}}
{{dsc inc|cpp/algorithm/ranges/dsc fold_right_last}}
{{dsc inc|cpp/algorithm/ranges/dsc fold_left_with_iter}}
{{dsc inc|cpp/algorithm/ranges/dsc fold_left_first_with_iter}}
{{dsc inc|cpp/algorithm/dsc accumulate}}
{{dsc inc|cpp/algorithm/dsc reduce}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|en}}