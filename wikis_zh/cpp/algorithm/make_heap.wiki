{{cpp/title|make_heap}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|num=1|notes={{mark constexpr since c++20}}|
template&lt; class RandomIt &gt;
void make_heap( RandomIt first, RandomIt last );
}}
{{dcl|num=2|notes={{mark constexpr since c++20}}|
template&lt; class RandomIt, class Compare &gt;
void make_heap( RandomIt first, RandomIt last, Compare comp );
}}
{{dcl end}}

在范围 {{range|first|last}} 中构造{{rlp|/#堆操作|堆}}。

@1@ 构造关于 {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}} 的堆。
@2@ 构造关于 {{c|comp}} 的堆。

如果满足以下任意条件，那么行为未定义：
{{rev begin}}
{{rev|until=c++11|
* {{c|*first}} 的类型不{{named req|Swappable}}。
}}
{{rev|since=c++11|
* {{tt|RandomIt}} 不{{named req|ValueSwappable}}。
* {{c|*first}} 的类型不{{named req|MoveConstructible}}。
* {{c|*first}} 的类型不{{named req|MoveAssignable}}。
}}
{{rev end}}

===参数===
{{par begin}}
{{par range|3=构造二叉堆的}}
{{par cmp|comp|p1=RandomIt}} 
{{par hreq}}
{{par req named|RandomIt|RandomAccessIterator}}
{{par req named|Compare|Compare}}
{{par end}}

===复杂度===
给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first, last)}}：
@1@ 最多应用 {{mathjax-or|\(\scriptsize 3N\)|3N}} 次 {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}} 进行比较。
@2@ 最多应用 {{mathjax-or|\(\scriptsize 3N\)|3N}} 次比较函数 {{c|comp}}。

===示例===
{{example
|
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

void print(std::string_view text, const std::vector&lt;int&gt;&amp; v = {})
{
    std::cout &lt;&lt; text &lt;&lt; "：";
    for (const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    print("最大堆");
    
    std::vector&lt;int&gt; v{3, 2, 4, 1, 5, 9};
    print("一开始，v", v);
    
    std::make_heap(v.begin(), v.end());
    print("make_heap 后，v", v);
    
    std::pop_heap(v.begin(), v.end());
    print("pop_heap 后，v", v);
    
    auto top = v.back();
    v.pop_back();
    print("之前的顶端元素", {top});
    print("移除之前的顶端元素后，v", v);
    
    print("\n最小堆");
    
    std::vector&lt;int&gt; v1{3, 2, 4, 1, 5, 9};
    print("一开始，v1", v1);
    
    std::make_heap(v1.begin(), v1.end(), std::greater&lt;&gt;{});
    print("make_heap 后，v1", v1);
    
    std::pop_heap(v1.begin(), v1.end(), std::greater&lt;&gt;{});
    print("pop_heap 后，v1", v1);
    
    auto top1 = v1.back();
    v1.pop_back();
    print("之前的顶端元素", {top1});
    print("移除之前的顶端元素后，v1", v1);
}
|output=
最大堆：
一开始，v：3 2 4 1 5 9
make_heap 后，v：9 5 4 1 2 3
pop_heap 后，v：5 3 4 1 2 9
之前的顶端元素：9
移除之前的顶端元素后，v：5 3 4 1 2

最小堆：
一开始，v1：3 2 4 1 5 9
make_heap 后，v1：1 2 4 3 5 9
pop_heap 后，v1：2 3 4 9 5 1
之前的顶端元素：1
移除之前的顶端元素后，v1：2 3 4 9 5
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3032|std=C++98|before={{range|first|last}} 的元素不需要可交换|after=需要}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc is_heap}}
{{dsc inc|cpp/algorithm/dsc is_heap_until}}
{{dsc inc|cpp/algorithm/dsc push_heap}}
{{dsc inc|cpp/algorithm/dsc pop_heap}}
{{dsc inc|cpp/algorithm/dsc sort_heap}}
{{dsc inc|cpp/container/dsc priority_queue}}
{{dsc inc|cpp/algorithm/ranges/dsc make_heap}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}