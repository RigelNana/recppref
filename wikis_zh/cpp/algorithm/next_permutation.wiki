{{cpp/title|next_permutation}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|num=1|notes={{mark constexpr since c++20}}|
template&lt; class BidirIt &gt;
bool next_permutation( BidirIt first, BidirIt last );
}}
{{dcl|num=2|notes={{mark constexpr since c++20}}|
template&lt; class BidirIt, class Compare &gt;
bool next_permutation( BidirIt first, BidirIt last, Compare comp );
}}
{{dcl end}}

将范围 {{range|first|last}} 变换为下个{{enwiki|permutation|排列}}。这种排列存在时返回 {{c|true}}，否则将范围变换为首个排列（如同用 {{lc|std::sort}}）并返回 {{c|false}}。

@1@ 所有排列的集合按相对于 {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}} 的字典序排序。

@2@ 所有排列的集合按相对于 {{c|comp}} 的字典序排序。

如果 {{rev inl|until=c++11|{{c|*first}} 的类型不{{named req|Swappable}}}}{{rev inl|since=c++11|{{tt|BidirIt}} 不{{named req|ValueSwappable}}}}，那么行为未定义。

===参数===
{{par begin}}
{{par range|3=要重排的}}
{{par cmp|comp|p1=BidirIt}}
{{par hreq}}
{{par req named|BidirIt|BidirectionalIterator}}
{{par end}}

===返回值===
新排列按字典序大于旧排列时返回 {{c|true}}。抵达最后排列并重置范围为首个排列时返回 {{c|false}}。

===复杂度===
给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first, last)}}：

@1,2@ 最多交换 {{mathjax-or|\(\scriptsize \frac{N}{2}\)|{{mfrac|N|2}}}} 次。

===异常===
从迭代器操作或元素交换抛出的任何异常。

===可能的实现===
{{eq fun
|1=
template&lt;class BidirIt&gt;
bool next_permutation(BidirIt first, BidirIt last)
{
    auto r_first = std::make_reverse_iterator(last);
    auto r_last = std::make_reverse_iterator(first);
    auto left = std::is_sorted_until(r_first, r_last);
    
    if (left != r_last)
    {
        auto right = std::upper_bound(r_first, left, *left);
        std::iter_swap(left, right);
    }
    
    std::reverse(left.base(), last);
    return left != r_last;
}
}}

===注解===
典型实现在排列的整个序列上，平均每次调用使用约 3 次比较和 1.5 次交换。

{{cpp/algorithm/notes swap vectorization}}

===示例===
{{example
|下列代码打印字符串 {{c/core|"aba"}} 的全部三种排列。
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::string s = "aba";
    
    do
    {
        std::cout &lt;&lt; s &lt;&lt; '\n';
    }
    while (std::next_permutation(s.begin(), s.end()));
    
    std::cout &lt;&lt; s &lt;&lt; '\n';
}
|output=
aba
baa
aab
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc is_permutation}}
{{dsc inc|cpp/algorithm/dsc prev_permutation}}
{{dsc inc|cpp/algorithm/ranges/dsc next_permutation}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}