{{cpp/title|transform}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcla|num=1|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class OutputIt, class UnaryOp &gt;
OutputIt transform( InputIt first1, InputIt last1,
                    OutputIt d_first, UnaryOp unary_op );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2, class UnaryOp &gt;
ForwardIt2 transform( ExecutionPolicy&amp;&amp; policy,
                      ForwardIt1 first1, ForwardIt1 last1,
                      ForwardIt2 d_first, UnaryOp unary_op );
}}
{{dcla|num=3|notes={{mark constexpr since c++20}}|
template&lt; class InputIt1, class InputIt2,
          class OutputIt, class BinaryOp &gt;
OutputIt transform( InputIt1 first1, InputIt1 last1, InputIt2 first2,
                    OutputIt d_first, BinaryOp binary_op );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2,
          class ForwardIt3, class BinaryOp &gt;
ForwardIt3 transform( ExecutionPolicy&amp;&amp; policy,
                      ForwardIt1 first1, ForwardIt1 last1,
                      ForwardIt2 first2,
                      ForwardIt3 d_first, BinaryOp binary_op );
}}
{{dcl end}}

{{tt|std::transform}} 应用给定的函数到某个/些输入范围中的元素，并将结果存储到从 {{c|d_first}} 开始的输出范围。

@1@ 应用一元函数 {{c|unary_op}} 到 {{range|first1|last1}} 中的元素。
@@ 如果 {{c|unary_op}} 使以下某个范围中的某个迭代器失效，或者修改了以下某个范围中的某个元素，那么行为未定义：
* {{closed range|first1|last1}}。
* 包含 {{c|std::distance(first1, last1) + 1}} 个元素的从 {{c|d_first}} 开始的范围。

@3@ 应用二元函数 {{c|binary_op}} 到来自两个范围的元素对：一个范围是 {{range|first1|last1}}，而另一个范围包含 {{c|std::distance(first1, last1)}} 个元素并从 {{c|first2}} 开始。
@@ 如果 {{c|binary_op}} 使以下某个范围中的某个迭代器失效，或者修改了以下某个范围中的某个元素，那么行为未定义：
* {{closed range|first1|last1}}。
* 包含 {{c|std::distance(first1, last1) + 1}} 个元素的从 {{c|first2}} 开始的范围。
* 包含 {{c|std::distance(first1, last1) + 1}} 个元素的从 {{c|d_first}} 开始的范围。

@2,4@ 同 {{v|1,3}}，但按照 {{c|policy}} 执行。
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

===参数===
{{par begin}}
{{par range|first1|last1|要变换的第一|range=源}}
{{par|first2|要变换的第二元素范围的起始，仅限 {{vl|3,4}}}}
{{par|d_first|目标范围的起始，可以等于 {{c|first1}} 或 {{c|first2}}}}
{{par exec pol}}
{{par op1|unary_op|rp=OutputIt|p1=InputIt}}
{{par op2|binary_op|rp=OutputIt|p1=InputIt1|p2=InputIt2}}
{{par hreq}}
{{par req named|InputIt, InputIt1, InputIt2|InputIterator}}
{{par req named|OutputIt|OutputIterator}}
{{par req named|ForwardIt1, ForwardIt2, ForwardIt3|ForwardIterator}}
{{par end}}

===返回值===
指向最后一个变换的元素的输出迭代器。

===复杂度===
给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first1, last1)}}：
@1,2@ 应用 {{mathjax-or|\(\scriptsize N\)|N}} 次 {{c|unary_op}}。

@3,4@ 应用 {{mathjax-or|\(\scriptsize N\)|N}} 次 {{c|binary_op}}。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===可能的实现===
{{eq impl
|title1=transform (1)|ver1=1|1=
template&lt;class InputIt, class OutputIt, class UnaryOp&gt;
constexpr //&lt; C++20 起
OutputIt transform(InputIt first1, InputIt last1,
                   OutputIt d_first, UnaryOp unary_op)
{
    for (; first1 != last1; ++d_first, ++first1)
        *d_first = unary_op(*first1);

    return d_first;
}
|title2=transform (3)|ver2=3|2=
template&lt;class InputIt1, class InputIt2, 
         class OutputIt, class BinaryOp&gt;
constexpr //&lt; C++20 起
OutputIt transform(InputIt1 first1, InputIt1 last1, InputIt2 first2,
                   OutputIt d_first, BinaryOp binary_op)
{
    for (; first1 != last1; ++d_first, ++first1, ++first2)
        *d_first = binary_op(*first1, *first2);

    return d_first;
}
}}

===注解===
{{tt|std::transform}} 不保证按顺序应用 {{c|unary_op}} 或 {{c|binary_op}}。为按顺序应用函数到数列，或应用修改序列元素的函数，应使用 {{lc|std::for_each}}。

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

void print_ordinals(const std::vector&lt;std::size_t&gt;&amp; ordinals)
{
    std::cout &lt;&lt; "序数：";
    for (std::size_t ord : ordinals)
        std::cout &lt;&lt; std::setw(3) &lt;&lt; ord &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

char to_uppercase(unsigned char c)
{
    return std::toupper(c);
}

void to_uppercase_inplace(char&amp; c)
{
    c = to_uppercase(c);
}

void unary_transform_example(std::string&amp; hello, std::string world)
{
    // 原位变换字符串为大写

    std::transform(hello.cbegin(), hello.cend(), hello.begin(), to_uppercase);
    std::cout &lt;&lt; "hello = " &lt;&lt; std::quoted(hello) &lt;&lt; '\n';
    
    // for_each 版本（见上文注解部分）
    std::for_each(world.begin(), world.end(), to_uppercase_inplace);
    std::cout &lt;&lt; "world = " &lt;&lt; std::quoted(world) &lt;&lt; '\n';
}

void binary_transform_example(std::vector&lt;unsigned&gt; ordinals)
{
    // 变换数值为两倍的值

    print_ordinals(ordinals);
    
    std::transform(ordinals.cbegin(), ordinals.cend(), ordinals.cbegin(),
                   ordinals.begin(), std::plus&lt;&gt;{});

    print_ordinals(ordinals);
}

int main()
{
    std::string hello("hello");
    unary_transform_example(hello, "world");
    
    std::vector&lt;unsigned&gt; ordinals;
    std::copy(hello.cbegin(), hello.cend(), std::back_inserter(ordinals));
    binary_transform_example(std::move(ordinals));
}
|output=
hello = "HELLO"
world = "WORLD"
序数： 72  69  76  76  79 
序数：144 138 152 152 158
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=242|std=C++98|before={{c|unary_op}} 和 {{c|binary_op}} 不能有任何副作用|after=它们不能修改涉及到的范围}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc for_each}}
{{dsc inc|cpp/algorithm/ranges/dsc transform}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}