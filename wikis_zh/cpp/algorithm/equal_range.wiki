{{cpp/title|equal_range}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl rev begin|num=1}}
{{dcla|anchor=版本_1|constexpr=c++20|until=c++26|
template&lt; class ForwardIt, class T &gt;
std::pair&lt;ForwardIt, ForwardIt&gt; 
    equal_range( ForwardIt first, ForwardIt last, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class ForwardIt, class T = typename std::iterator_traits
                                         &lt;ForwardIt&gt;::value_type &gt;
constexpr std::pair&lt;ForwardIt, ForwardIt&gt; 
    equal_range( ForwardIt first, ForwardIt last, const T&amp; value );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcla|anchor=版本_2|constexpr=c++20|until=c++26|
template&lt; class ForwardIt, class T, class Compare &gt;
std::pair&lt;ForwardIt, ForwardIt&gt; 
    equal_range( ForwardIt first, ForwardIt last,
                 const T&amp; value, Compare comp );
}}
{{dcl|since=c++26|1=
template&lt; class ForwardIt, class T = typename std::iterator_traits
                                         &lt;ForwardIt&gt;::value_type,
          class Compare &gt;
constexpr std::pair&lt;ForwardIt, ForwardIt&gt; 
    equal_range( ForwardIt first, ForwardIt last,
                 const T&amp; value, Compare comp );
}}
{{dcl end}}

返回范围 {{range|first|last}} 中包含所有等价于 {{c|value}} 的元素的范围。

@1@ 通过 {{c/core|operator&lt;}} 检查元素是否等价：
{{rev begin}}
{{rev|until=c++20|
返回 {{c|std::lower_bound(first, last, value)}} 和 {{c|std::upper_bound(first, last, value)}} 的结果。

如果满足以下任意条件，那么行为未定义：
* {{range|first|last}} 的某些元素 {{c|elem}} 使得无法通过 {{c|bool(elem &lt; value)}} 得出 {{c|!bool(value &lt; elem)}}。
* {{range|first|last}} 的元素 {{c|elem}} 没有按表达式 {{c|bool(elem &lt; value)}} 和 {{c|!bool(value &lt; elem)}} {{rlp|/#要求|划分}}。
}}
{{rev|since=c++20|
等价于 {{c|std::binary_search(first, last, value, std::less{})}}。
}}
{{rev end}}

@2@ 通过 {{c|comp}} 检查元素是否等价：
@@ 返回 {{c|std::lower_bound(first, last, value, comp)}} 和 {{c|std::upper_bound(first, last, value, comp)}} 的结果。
@@ 如果满足以下任意条件，那么行为未定义：
* {{range|first|last}} 的某些元素 {{c|elem}} 使得无法通过 {{c|bool(comp(elem, value))}} 得出 {{c|!bool(comp(value, elem))}}。
* {{range|first|last}} 的元素 {{c|elem}} 没有按表达式 {{c|bool(comp(elem, value))}} 和 {{c|!bool(comp(value, elem))}} {{rlp|/#要求|划分}}。

===参数===
{{par begin}}
{{par range|3=要检验的|range=已划分}}
{{par|value|要与元素比较的值}}
{{par pred2|comp|如果第一个实参先序于第二个|bidirectional=true|t1=T|p2=ForwardIt}} 
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req named|Compare|BinaryPredicate|notes=不要求满足{{named req|Compare}}。}}
{{par end}}

===返回值===
包含一对迭代器的 {{lc|std::pair}}，其中：
* {{tt|first}} 是到范围 {{range|first|last}} 的第一个不先序于 {{c|value}} 的元素的迭代器（或者在找不到这种元素时是 {{c|last}}）。
* {{tt|second}} 是到范围 {{range|first|last}} 的第一个后序于 {{c|value}} 的元素的迭代器（或者在找不到这种元素时是 {{c|last}}）。

===复杂度===
给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first, last)}}：

@1,2@ 最多应用 {{mathjax-or|\(\scriptsize 2\log_{2}(N)+O(1)\)|2log{{su|b=2}}(N)+O(1)}} 次 {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}} 进行比较。

@3,4@ 最多应用 {{mathjax-or|\(\scriptsize 2\log_{2}(N)+O(1)\)|2log{{su|b=2}}(N)+O(1)}} 次比较函数 {{c|comp}}。

然而，如果 {{tt|ForwardIt}} 不是{{named req|RandomAccessIterator}}，那么迭代器自增次数与 {{mathjax-or|\(\scriptsize N\)|N}} 成线性。要注意 {{lc|std::set}} 和 {{lc|std::multiset}} 的迭代器不是随机访问的，因此应当优先使用它们的成员函数{{lc|std::set::equal_range}} 和 {{lc|std::multiset::equal_range}}。

{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|算法中的[[cpp/language/list initialization|列表初始化]] {{vl|1,2}}}}

===可能的实现===
{{eq impl|title1=equal_range (1)|ver1=1|1=
template&lt;class ForwardIt,
         class T = typename std::iterator_traits&lt;ForwardIt&gt;::value_type&gt;
constexpr std::pair&lt;ForwardIt, ForwardIt&gt; 
    equal_range(ForwardIt first, ForwardIt last, const T&amp; value)
{
    return std::equal_range(first, last, value, std::less{});
}
|title2=equal_range (2)|ver2=2|2=
template&lt;class ForwardIt,
         class T = typename std::iterator_traits&lt;ForwardIt&gt;::value_type,
         class Compare&gt;
constexpr std::pair&lt;ForwardIt, ForwardIt&gt;
    equal_range(ForwardIt first, ForwardIt last, const T&amp; value, Compare comp)
{
    return std::make_pair(std::lower_bound(first, last, value, comp),
                          std::upper_bound(first, last, value, comp));
}
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct S
{
    int number;
    char name;
    // 注意：此比较运算符会忽略 name
    bool operator&lt; ( const S&amp; s ) const { return number &lt; s.number; }
};

struct Comp
{
    bool operator() ( const S&amp; s, int i ) const { return s.number &lt; i; }
    bool operator() ( int i, const S&amp; s ) const { return i &lt; s.number; }
};

int main()
{
    // 注意：无序，只按下面定义的 S 划分
    const std::vector&lt;S&gt; vec{&lt;!----&gt;{1, 'A'}, {2, 'B'}, {2, 'C'},
                             {2, 'D'}, {4, 'G'}, {3, 'F'}&lt;!----&gt;};
    const S value = {2, '?'};
    
    std::cout &lt;&lt; "使用 S::operator&lt;() 进行比较：";
    const auto p = std::equal_range(vec.begin(), vec.end(), value);
    
    for (auto it = p.first; it != p.second; ++it)
        std::cout &lt;&lt; it-&gt;name &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    std::cout &lt;&lt; "使用异相比较：";
    const auto p2 = std::equal_range(vec.begin(), vec.end(), 2, Comp{});

    for (auto it = p2.first; it != p2.second; ++it)
        std::cout &lt;&lt; it-&gt;name &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    using CD = std::complex&lt;double&gt;;
    std::vector&lt;CD&gt; nums{&lt;!----&gt;{1, 0}, {2, 2}, {2, 1}, {3, 0}, {3, 1}&lt;!----&gt;};
    auto cmpz = [](CD x, CD y) { return x.real() &lt; y.real(); };
    #ifdef __cpp_lib_algorithm_default_value_type
        auto p3 = std::equal_range(nums.cbegin(), nums.cend(), {2, 0}, cmpz);
    #else
        auto p3 = std::equal_range(nums.cbegin(), nums.cend(), CD{2, 0}, cmpz);
    #endif
 
    for (auto it = p3.first; it != p3.second; ++it)
        std::cout &lt;&lt; *it &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
使用 S::operator&lt;() 进行比较：B C D 
使用异相比较：B C D 
(2,2) (2, 1)
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=270|std=C++98|before={{tt|Compare}} 需要满足{{named req|Compare}}，并且 {{tt|T}} 需要是&lt;br&gt;{{named req|LessThanComparable}}的（要求严格弱序）|after=只需要划分；&lt;br&gt;允许异相比较}}
{{dr list item|wg=lwg|dr=384|std=C++98|before=最多允许 {{mathjax-or|\(\scriptsize 2\log_{2}(N)+1\)|2log{{su|b=2}}(N)+1}} 次比较，但是无法实现&lt;ref&gt;对包含单个元素的范围应用 {{tt|equal_range}} 至少需要 2 次比较，但是复杂度要求最多只允许 1 次比较&lt;/ref&gt;|after=改成 {{mathjax-or|\(\scriptsize 2\log_{2}(N)+O(1)\)|2log{{su|b=2}}(N)+O(1)}} 次}}
{{dr list end}}
&lt;references/&gt;

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc lower_bound}}
{{dsc inc|cpp/algorithm/dsc upper_bound}}
{{dsc inc|cpp/algorithm/dsc binary_search}}
{{dsc inc|cpp/algorithm/dsc partition}}
{{dsc inc|cpp/algorithm/dsc equal}}
{{dsc inc|cpp/container/dsc equal_range|set}}
{{dsc inc|cpp/container/dsc equal_range|multiset}}
{{dsc inc|cpp/algorithm/ranges/dsc equal_range}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}