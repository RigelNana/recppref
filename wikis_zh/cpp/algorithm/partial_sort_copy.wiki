{{cpp/title|partial_sort_copy}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|num=1|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class RandomIt &gt;
RandomIt partial_sort_copy( InputIt first, InputIt last,
                            RandomIt d_first, RandomIt d_last );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt, class RandomIt &gt;
RandomIt partial_sort_copy( ExecutionPolicy&amp;&amp; policy,
                            ForwardIt first, ForwardIt last,
                            RandomIt d_first, RandomIt d_last );
}}
{{dcl|num=3|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class RandomIt, class Compare &gt;
RandomIt partial_sort_copy( InputIt first, InputIt last,
                            RandomIt d_first, RandomIt d_last,
                            Compare comp );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt, class RandomIt, class Compare &gt;
RandomIt partial_sort_copy( ExecutionPolicy&amp;&amp; policy,
                            ForwardIt first, ForwardIt last,
                            RandomIt d_first, RandomIt d_last,
                            Compare comp );}}
{{dcl end}}

以升序排序范围 {{range|first|last}} 中的某些元素，存储结果于范围 {{range|d_first|d_last}}。

至多将 {{c|d_last - d_first}} 个元素有序放置到范围 {{range|d_first|d_first + n}} 中。其中 {{c|n}} 是要排序的元素数（{{c|std::min(std::distance(first, last), d_last - d_first)}}）。不保证保持相等元素的顺序。

@1@ 按 {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}} 进行{{rlp|/#要求|排序}}。

@3@ 按 {{c|comp}} 进行排序。

@2,4@ 同 {{v|1,3}}，但按照 {{c|policy}} 执行。
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

如果 {{c|*first}} 不[[cpp/iterator#类型与可写性|可写入]] {{c|d_first}}，那么程序非良构。

如果满足以下任意条件，那么行为未定义：
{{rev begin}}
{{rev|until=c++11|
* {{c|*d_first}} 的类型不{{named req|Swappable}}。
}}
{{rev|since=c++11|
* {{tt|RandomIt}} 不{{named req|ValueSwappable}}。
* {{c|*d_first}} 的类型不{{named req|MoveConstructible}}。
* {{c|*d_first}} 的类型不{{named req|MoveAssignable}}。
}}
{{rev end}}

===参数===
{{par begin}}
{{par range|3=要排序的}}
{{par range|d_first|d_last|要将排序后数据向之赋值的}}
{{par exec pol}}
{{par cmp ord|comp|p1=RandomIt}} 
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req named|RandomIt|RandomAccessIterator}}
{{par req named|Compare|Compare}}
{{par end}}

===返回值===
指向定义已排序范围上界的元素的迭代器，即 {{c|d_first + std::min(std::distance(first, last), d_last - d_first)}}。

===复杂度===
给定 {{mathjax-or|\(\scriptsize N\)|N}} 为 {{c|std::distance(first, last)}}，{{mathjax-or|\(\scriptsize D\)|D}} 为 {{c|d_last - d_first}}：
@1,2@ 应用大约 {{mathjax-or|\(\scriptsize N \cdot \log(\min(N,D))\)|N·log(min(N,D))}} 次 {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}} 进行比较。
@3,4@ 应用大约 {{mathjax-or|\(\scriptsize N \cdot \log(\min(N,D))\)|N·log(min(N,D))}} 次比较函数 {{c|comp}}。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===可能的实现===
参阅 [https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L1669 libstdc++] 与 [https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L5064 libc++] 中的实现。

===示例===
{{example
|下列代码排序 int 的 vector 并将它们复制到较小和较大的 vector 中。
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;
 
void println(std::string_view rem, const auto&amp; v)
{
    std::cout &lt;&lt; rem;
    if constexpr (std::is_scalar_v&lt;std::decay_t&lt;decltype(v)&gt;&gt;)
        std::cout &lt;&lt; v;
    else
        for (int e : v)
            std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    const auto v0 = {4, 2, 5, 1, 3};
    std::vector&lt;int&gt; v1{10, 11, 12};
    std::vector&lt;int&gt; v2{10, 11, 12, 13, 14, 15, 16};
    std::vector&lt;int&gt;::iterator it;
    
    it = std::partial_sort_copy(v0.begin(), v0.end(), v1.begin(), v1.end());
    println("以升序写入较小 vector 得到: ", v1);
    
    if (it == v1.end())
        println("返回值为末尾迭代器", ' ');
    
    it = std::partial_sort_copy(v0.begin(), v0.end(), v2.begin(), v2.end(),
                                std::greater&lt;int&gt;());
    
    println("以降序写入较大 vector 得到: ", v2);
    println("返回值迭代器指向 ", *it);
}
|output=
以升序写入较小 vector 得到: 1 2 3
返回值为末尾迭代器
以降序写入较大 vector 得到: 5 4 3 2 1 15 16
返回值迭代器指向 15
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|paper=P0896R4|std=C++98|before={{c|*first}} 不需要可写入 {{c|d_first}}|after=不可写入时程序非良构}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc partial_sort}}
{{dsc inc|cpp/algorithm/dsc sort}}
{{dsc inc|cpp/algorithm/dsc stable_sort}}
{{dsc inc|cpp/algorithm/ranges/dsc partial_sort_copy}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}