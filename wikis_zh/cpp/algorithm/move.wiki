{{cpp/title|move}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|num=1|since=c++11|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class OutputIt &gt;
OutputIt move( InputIt first, InputIt last,
               OutputIt d_first );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt1, class ForwardIt2 &gt;
ForwardIt2 move( ExecutionPolicy&amp;&amp; policy,
                 ForwardIt1 first, ForwardIt1 last,
                 ForwardIt2 d_first );
}}
{{dcl end}}

@1@ 移动范围 {{range|first|last}} 中的元素到从 {{c|d_first}} 开始的另一范围，从 {{c|first}} 开始逐次到 {{c|last}}。此操作后被移动范围中的元素将仍然含有适合类型的合法值，但不必与移动前的值相同。

@2@ 同 {{v|1}}，但按照 {{c|policy}} 执行。
@@ {{cpp/algorithm/parallel overload precondition}}

如果 {{c|d_first}} 在范围 {{range|first|last}} 中，那么行为未定义。此时可以改用 {{lc|std::move_backward}}。

===参数===
{{par begin}}
{{par range|3=要移动的|range=源}}
{{par|d_first|目标范围起始}}
{{par exec pol}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|OutputIt|OutputIterator}}
{{par req named|ForwardIt1, ForwardIt2|ForwardIterator}}
{{par end}}

===返回值===
指向最后移动元素后一位置的迭代器。

===复杂度===
移动赋值 {{c|std::distance(first, last)}} 次。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=yes}}

===可能的实现===
{{eq fun | 1=
template&lt;class InputIt, class OutputIt&gt;
OutputIt move(InputIt first, InputIt last, OutputIt d_first)
{
    for (; first != last; ++d_first, ++first)
        *d_first = std::move(*first);
    
    return d_first;
}
}}

===注解===
移动重叠的范围时，{{tt|std::move}} 在向左侧移动（目标范围的起始在源范围外）时适合，而 {{tt|std::move_backward}} 在向右侧移动（目标范围的结尾在源范围外）时适合。

===示例===
下列代码从一个容器移动线程对象（自身不可复制）到另一个。

{{example
|code=
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;list&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

void f(int n)
{
    std::this_thread::sleep_for(std::chrono::seconds(n));
    std::cout &lt;&lt; "线程 " &lt;&lt; n &lt;&lt; " 终止" &lt;&lt; std::endl;
}

int main() 
{
    std::vector&lt;std::jthread &gt; v;
    v.emplace_back(f, 1);
    v.emplace_back(f, 2);
    v.emplace_back(f, 3);
    std::list&lt;std::jthread &gt; l;

    // copy() 无法编译，因为 std::jthread 不可复制
    std::move(v.begin(), v.end(), std::back_inserter(l));
}
|output=
线程 1 终止
线程 2 终止
线程 3 终止
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc move_backward}}
{{dsc inc|cpp/utility/dsc move}}
{{dsc inc|cpp/algorithm/ranges/dsc move}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}