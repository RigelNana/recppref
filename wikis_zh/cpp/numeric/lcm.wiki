{{cpp/title|lcm}}
{{cpp/numeric/navbar}}
{{ddcl|header=numeric|since=c++17|
template&lt; class M, class N &gt;
constexpr std::common_type_t&lt;M, N&gt; lcm( M m, N n );
}}

计算整数 {{c|m}} 与 {{c|n}} 的{{enwiki|least common multiple|最小公倍数}}。

如果 {{tt|M}} 或 {{tt|N}} 任一不是整数类型，或任一是（可为 cv 限定的）{{c|bool}}，则程序非良构。

如果 {{tt|{{!}}m{{!}}}}、{{tt|{{!}}n{{!}}}} 或 {{tt|{{!}}m{{!}}}} 和 {{tt|{{!}}n{{!}}}} 的最小公倍数不能表示为 {{c|std::common_type_t&lt;M, N&gt;}} 类型的值，则行为未定义。

===参数===
{{par begin}}
{{par|m, n|整数值}}
{{par end}}

===返回值===
若 {{c|m}} 或 {{c|n}} 任一者为零，则返回零。否则，返回 {{c|{{!}}m{{!}}}} 与 {{c|{{!}}n{{!}}}} 的最小公倍数。

===异常===
不抛异常。

===注解===
{{feature test macro|__cpp_lib_gcd_lcm|{{lc|std::gcd}}, {{tt|std::lcm}}|value=201606L|std=C++17}}

===示例===
{{example|code=
#include &lt;iostream&gt;
#include &lt;numeric&gt;

#define OUT(...) std::cout &lt;&lt; #__VA_ARGS__ &lt;&lt; " = " &lt;&lt; __VA_ARGS__ &lt;&lt; '\n'

constexpr auto lcm(auto x, auto... xs)
{
    return ((x = std::lcm(x, xs)), ...);
}

int main()
{
    constexpr int p{2 * 2 * 3};
    constexpr int q{2 * 3 * 3};
    static_assert(2 * 2 * 3 * 3 == std::lcm(p, q));
    static_assert(225 == std::lcm(45, 75));

    static_assert(std::lcm( 6,  10) == 30);
    static_assert(std::lcm( 6, -10) == 30);
    static_assert(std::lcm(-6, -10) == 30);

    static_assert(std::lcm( 24, 0) == 0);
    static_assert(std::lcm(-24, 0) == 0);

    OUT(lcm(2 * 3, 3 * 4, 4 * 5));
    OUT(lcm(2 * 3 * 4, 3 * 4 * 5, 4 * 5 * 6));
    OUT(lcm(2 * 3 * 4, 3 * 4 * 5, 4 * 5 * 6, 5 * 6 * 7));
}
|output=
lcm(2 * 3, 3 * 4, 4 * 5) = 60
lcm(2 * 3 * 4, 3 * 4 * 5, 4 * 5 * 6) = 120
lcm(2 * 3 * 4, 3 * 4 * 5, 4 * 5 * 6, 5 * 6 * 7) = 840
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/dsc gcd}}
{{dsc end }}

{{langlinks|de|en|es|ja|ru}}