{{cpp/title|has_single_bit}}
{{cpp/utility/bit/navbar}}
{{ddcl|since=c++20|header=bit|
template&lt; class T &gt;
constexpr bool has_single_bit( T x ) noexcept;
}}

检查 {{c|x}} 是否为二的整数次幂。

{{cpp/enable_if| {{tt|T}} 为无符号整数类型（即 {{c/core|unsigned char}}、{{c/core|unsigned short}}、{{c/core|unsigned int}}、{{c/core|unsigned long}}、{{c/core|unsigned long long}} 或扩展无符号整数类型）}}。

===参数===
{{par begin}}
{{par|x|无符号整数类型的值}}
{{par end}}

===返回值===
若 {{c|x}} 为二的整数次幂则为 {{c|true}}；否则为 {{c|false}}。

===注解===
{{petty|{{stddoc|P1956R1}} 以前，为这个函数模板提出的名字是 {{tt|ispow2}}。}}

{{feature test macro|__cpp_lib_int_pow2|std=C++20|value=202002L|[[cpp/utility/bit|{{math|2}} 的整数次幂运算]]}}

===可能的实现===
{{eq fun|1=
template&lt;typename T, typename ... U&gt;
concept neither = (!std::same_as&lt;T, U&gt; &amp;&amp; ...);
 
template&lt;typename T&gt;
concept strict_unsigned_integral = std::unsigned_integral&lt;T&gt; &amp;&amp;
    neither&lt;T, bool, char, char8_t, char16_t, char32_t, wchar_t&gt;;
 
// 第一版
constexpr bool has_single_bit(strict_unsigned_integral auto x) noexcept
{
    return x &amp;&amp; !(x &amp; (x - 1));
}
 
// 第二版
constexpr bool has_single_bit(strict_unsigned_integral auto x) noexcept
{
    return std::popcount(x) == 1;
}
}}

===示例===
{{example
|code=
#include &lt;bit&gt;
#include &lt;bitset&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;

int main()
{
    for (auto u{0u}; u != 0B1010; ++u)
    {
        std::cout &lt;&lt; "u = " &lt;&lt; u &lt;&lt; " = " &lt;&lt; std::bitset&lt;4&gt;(u);
        if (std::has_single_bit(u))
            std::cout &lt;&lt; " = 2^" &lt;&lt; std::log2(u) &lt;&lt; " (为二的幂)";
        std::cout &lt;&lt; '\n';
    }
}
|output=
u = 0 = 0000
u = 1 = 0001 = 2^0 (为二的幂)
u = 2 = 0010 = 2^1 (为二的幂)
u = 3 = 0011
u = 4 = 0100 = 2^2 (为二的幂)
u = 5 = 0101
u = 6 = 0110
u = 7 = 0111
u = 8 = 1000 = 2^3 (为二的幂)
u = 9 = 1001
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/dsc popcount}}
{{dsc inc|cpp/utility/bitset/dsc count}}
{{dsc inc|cpp/utility/bitset/dsc test}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}