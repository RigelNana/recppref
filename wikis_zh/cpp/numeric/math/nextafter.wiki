{{cpp/title|nextafter|nextafterf|nextafterl|nexttoward|nexttowardf|nexttowardl}}
{{cpp/numeric/math/navbar}}
{{dcl begin}}
{{dcl header|cmath}}
{{dcl rev multi|num=1|since1=c++11|dcl1=
float       nextafter ( float from, float to );
double      nextafter ( double from, double to );
long double nextafter ( long double from, long double to );
|since2=c++23|dcl2=
constexpr /* floating-point-type */
            nextafter ( /* floating-point-type */ from,
                        /* floating-point-type */ to );
}}
{{dcl|num=2|since=c++11|notes={{mark constexpr since c++23}}|
float       nextafterf( float from, float to );
}}
{{dcl|num=3|since=c++11|notes={{mark constexpr since c++23}}|
long double nextafterl( long double from, long double to );
}}
{{dcl rev multi|num=4|since1=c++11|dcl1=
float       nexttoward ( float from, long double to );
double      nexttoward ( double from, long double to );
long double nexttoward ( long double from, long double to );
|since2=c++23|dcl2=
constexpr /* floating-point-type */
            nexttoward ( /* floating-point-type */ from,
                         long double to );
}}
{{dcl|num=5|since=c++11|notes={{mark constexpr since c++23}}|
float       nexttowardf( float from, long double to );
}}
{{dcl|num=6|since=c++11|notes={{mark constexpr since c++23}}|
long double nexttowardl( long double from, long double to );
}}
{{dcl h|[[#注解|额外重载]]}}
{{dcl header|cmath}}
{{dcl|num=A|since=c++11|notes={{mark constexpr since c++23}}|
template&lt; class Arithmetic1, class Arithmetic2 &gt;
/* common-floating-point-type */
    nextafter( Arithmetic1 from, Arithmetic2 to );
}}
{{dcl|num=B|since=c++11|notes={{mark constexpr since c++23}}|
template&lt; class Integer &gt;
double nexttoward( Integer from, long double to );
}}
{{dcl end}}

返回 {{c|from}} 往 {{c|to}} 方向的下个可表示值。

@1-3@ 如果 {{c|from}} 等于 {{c|to}}，那么返回 {{c|to}}。{{rev inl|since=c++23|标准库提供所有以无 cv 限定的浮点数类型作为形参 {{c|from}} 和 {{c|to}} 的类型的 {{tt|std::nextafter}} 重载。}}
@4-6@ 如果 {{c|from}} 等于 {{c|to}}，那么返回从 {{c/core|long double}} 转换到函数返回类型的 {{c|to}}，而不带范围或精度的损失。
{{rrev|since=c++23|
标准库提供所有以无 cv 限定的浮点数类型作为形参 {{c|from}} 的类型的 {{tt|std::nexttoward}} 重载。然而如果 {{c|from}} 对应的实参具有[[cpp/language/types#扩展浮点数类型|扩展浮点数类型]]，那么对 {{tt|std::nexttoward}} 的调用非良构，因为下个可表示值（或 {{c|to}}）不保证能以 {{c/core|long double}} 表示。
}}
@A@ 为算术类型的所有其他组合提供额外的 {{tt|std::nextafter}} 重载。
@B@ 为所有整数类型提供额外的 {{tt|std::nexttoward}} 重载，将它们当做 {{c/core|double}}。

===参数===
{{par begin}}
{{par|from, to|浮点数或整数}}
{{par end}}

===返回值===
如果没有发生错误，那么返回 {{c|from}} 往 {{c|to}} 的方向的下个可表示值。如果 {{c|from}} 等于 {{c|to}}，那么返回 {{c|to}}。

如果发生上溢导致的值域错误，那么返回 {{lc|HUGE_VAL|±HUGE_VAL}}、{{tt|±HUGE_VALF}} 或 {{tt|±HUGE_VALL}}（所带符号同 {{c|from}}）。

如果发生下溢导致的值域错误，那么返回正确结果。

===错误处理===
报告 {{lc|math_errhandling}} 中指定的错误。

如果实现支持 IEEE 浮点数算术（IEC 60559），那么
* 如果 {{c|from}} 有限，但期待的结果无限，那么引发 {{lc|FE_INEXACT}} 和 {{lc|FE_OVERFLOW}}。
* 如果 {{c|from}} 不等于 {{c|to}} 且结果非正规或为零，那么引发 {{lc|FE_INEXACT}} 和 {{lc|FE_UNDERFLOW}}。
* 任何情况下，返回值独立于当前舍入模式。
* 如果 {{c|from}} 或 {{c|to}} 为 NaN，那么返回 NaN。

===注解===
[https://pubs.opengroup.org/onlinepubs/9699919799/functions/nextafter.html POSIX 指定]上溢和下溢条件是值域错误（可以设置 {{lc|errno}}）。

IEC 60559 推荐凡在 {{c|1=from == to}} 时返回 {{c|from}}。这些函数改成返回 {{c|to}}，这使得围绕零的行为一致：{{c|std::nextafter(-0.0, +0.0)}} 返回 {{c|+0.0}} 而 {{c|std::nextafter(+0.0, -0.0)}} 返回 {{c|-0.0}}。

{{tt|std::nextafter}} 常通过操纵 IEEE 表示实现（[https://github.com/bminor/glibc/blob/master/math/s_nextafter.c glibc]，[https://github.com/ifduyue/musl/blob/master/src/math/nextafter.c musl]）。

{{cpp/numeric/math/additional overload note|nextafter}}

{{cpp/numeric/math/additional integer overload note|nexttoward}}

===示例===
{{example
|code=
#include &lt;cfenv&gt;
#include &lt;cfloat&gt;
#include &lt;cmath&gt;
#include &lt;concepts&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
 
int main()
{
    float from1 = 0, to1 = std::nextafter(from1, 1.f);
    std::cout &lt;&lt; "在 " &lt;&lt; std::setprecision(20) &lt;&lt; from1
              &lt;&lt; " 后的下个可表示的 float 是 " &lt;&lt; to1
              &lt;&lt; std::hexfloat &lt;&lt; "（" &lt;&lt; to1 &lt;&lt; "）\n" &lt;&lt; std::defaultfloat;
    
    float from2 = 1, to2 = std::nextafter(from2, 2.f);
    std::cout &lt;&lt; "在 " &lt;&lt; from2 &lt;&lt; " 后的下个可表示的 float 是 " &lt;&lt; to2
              &lt;&lt; std::hexfloat &lt;&lt; "（" &lt;&lt; to2 &lt;&lt; "）\n" &lt;&lt; std::defaultfloat;
    
    double from3 = std::nextafter(0.1, 0), to3 = 0.1;
    std::cout &lt;&lt; "数字 0.1 位于两个有效 double 之间：\n"
              &lt;&lt; std::setprecision(56) &lt;&lt; "   " &lt;&lt; from3
              &lt;&lt; std::hexfloat &lt;&lt; "（" &lt;&lt; from3 &lt;&lt; "）" &lt;&lt; std::defaultfloat
              &lt;&lt; "\n和 " &lt;&lt; to3 &lt;&lt; std::hexfloat &lt;&lt; " （" &lt;&lt; to3 &lt;&lt; "）\n"
              &lt;&lt; std::defaultfloat &lt;&lt; std::setprecision(20);
    
    std::cout &lt;&lt; "\nnextafter 和 nexttoward 的区别：\n";
    long double dir = std::nextafter(from1, 1.0L); // 第一个次正规 long double
    float x = std::nextafter(from1, dir); // 首先将 dir 转换到 float，得到 0
    std::cout &lt;&lt; "通过 nextafter 得到的 " &lt;&lt; from1
              &lt;&lt; " 之后的下一个 float 是 " &lt;&lt; x &lt;&lt; '\n';
    x = std::nexttoward(from1, dir);
    std::cout &lt;&lt; "通过 nexttoward 得到的 " &lt;&lt; from1
              &lt;&lt; " 之后的下一个 float 是 " &lt;&lt; x &lt;&lt; '\n';
    
    std::cout &lt;&lt; "\n特殊值：\n";
    {
        // #pragma STDC FENV_ACCESS ON
        std::feclearexcept(FE_ALL_EXCEPT);
        double from4 = DBL_MAX, to4 = std::nextafter(from4, INFINITY);
        std::cout &lt;&lt; "在 " &lt;&lt; std::setprecision(6) &lt;&lt; from4
                  &lt;&lt; std::hexfloat &lt;&lt; "（" &lt;&lt; from4 &lt;&lt; "）" &lt;&lt; std::defaultfloat
                  &lt;&lt; " 后的下个可表示的 double 是 " &lt;&lt; to4
                  &lt;&lt; std::hexfloat &lt;&lt; "（" &lt;&lt; to4 &lt;&lt; "）\n" &lt;&lt; std::defaultfloat;
 
        if (std::fetestexcept(FE_OVERFLOW))
            std::cout &lt;&lt; "   发生 FE_OVERFLOW\n";
        if (std::fetestexcept(FE_INEXACT))
            std::cout &lt;&lt; "   发生 FE_INEXACT\n";
    } // 结束 FENV_ACCESS 块
    
    float from5 = 0.0, to5 = std::nextafter(from5, -0.0);
    std::cout &lt;&lt; "std::nextafter(+0.0, -0.0) 给出 " &lt;&lt; std::fixed &lt;&lt; to5 &lt;&lt; '\n';
    
    auto precision_loss_demo = []&lt;std::floating_point Fp&gt;(const auto rem, const Fp start)
    {
        std::cout &lt;&lt; rem;
        for (Fp from = start, to, Δ;
            (Δ = (to = std::nextafter(from, +INFINITY)) - from) &lt; Fp(10.0);
            from *= Fp(10.0))
            std::cout &lt;&lt; "nextafter(" &lt;&lt; std::scientific &lt;&lt; std::setprecision(0) &lt;&lt; from 
                      &lt;&lt; ", INF) 给出 " &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; to
                      &lt;&lt; "；Δ = " &lt;&lt; Δ &lt;&lt; '\n';
    };
    
    precision_loss_demo("\nfloat 精度损失演示：\n", 10.0f);
    precision_loss_demo("\ndouble 精度损失演示：\n", 10.0e9);
    precision_loss_demo("\nlong double 精度损失演示：\n", 10.0e17L);
}
|output=
在 0 后的下个可表示的 float 是 1.4012984643248170709e-45（0x1p-149）
在 1 后的下个可表示的 float 是 1.0000001192092895508（0x1.000002p+0）
数字 0.1 位于两个有效 double 之间：
   0.09999999999999999167332731531132594682276248931884765625（0x1.9999999999999p-4）
和 0.1000000000000000055511151231257827021181583404541015625 （0x1.999999999999ap-4）
 
nextafter 和 nexttoward 的区别：
通过 nextafter 得到的 0 之后的下一个 float 是 0
通过 nexttoward 得到的 0 之后的下一个 float 是 1.4012984643248170709e-45

特殊值：
在 1.79769e+308（0x1.fffffffffffffp+1023）后的下个可表示的 double 是 inf（inf）
   发生 FE_OVERFLOW
   发生 FE_INEXACT
std::nextafter(+0.0, -0.0) 给出 -0.000000

float 精度损失演示：
nextafter(1e+01, INF) 给出 10.000001；Δ = 0.000001
nextafter(1e+02, INF) 给出 100.000008；Δ = 0.000008
nextafter(1e+03, INF) 给出 1000.000061；Δ = 0.000061
nextafter(1e+04, INF) 给出 10000.000977；Δ = 0.000977
nextafter(1e+05, INF) 给出 100000.007812；Δ = 0.007812
nextafter(1e+06, INF) 给出 1000000.062500；Δ = 0.062500
nextafter(1e+07, INF) 给出 10000001.000000；Δ = 1.000000
nextafter(1e+08, INF) 给出 100000008.000000；Δ = 8.000000

double 精度损失演示：
nextafter(1e+10, INF) 给出 10000000000.000002；Δ = 0.000002
nextafter(1e+11, INF) 给出 100000000000.000015；Δ = 0.000015
nextafter(1e+12, INF) 给出 1000000000000.000122；Δ = 0.000122
nextafter(1e+13, INF) 给出 10000000000000.001953；Δ = 0.001953
nextafter(1e+14, INF) 给出 100000000000000.015625；Δ = 0.015625
nextafter(1e+15, INF) 给出 1000000000000000.125000；Δ = 0.125000
nextafter(1e+16, INF) 给出 10000000000000002.000000；Δ = 2.000000

long double 精度损失演示：
nextafter(1e+18, INF) 给出 1000000000000000000.062500；Δ = 0.062500
nextafter(1e+19, INF) 给出 10000000000000000001.000000；Δ = 1.000000
nextafter(1e+20, INF) 给出 100000000000000000008.000000；Δ = 8.000000
}}

===参阅===
{{dsc begin}}
{{dsc see c|c/numeric/math/nextafter}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}