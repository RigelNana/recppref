{{cpp/title|logb|logbf|logbl}}
{{cpp/numeric/math/navbar}}
{{cpp/numeric/math/declarations
|family=logb
|param1=num
|constexpr_since=23
|desc=从浮点数实参 {{c|num}} 提取独立于基底的无偏指数，并将它作为浮点数返回。
}}

正式而言，无偏指数是非零 {{c|num}} 的 {{math|log{{su|b=r}}{{!}}num{{!}}}} 的有符号整数部分（此函数作为浮点数值返回），其中 {{c|r}} 是 {{c|std::numeric_limits&lt;T&gt;::radix}} 而 {{tt|T}} 是 {{c|num}} 的浮点数类型。如果 {{c|num}} 非正规，那么将它视为正规。

===参数===
{{par begin}}
{{par|num|浮点数或整数}}
{{par end}}

===返回值===
如果没有发生错误，那么返回作为有符号浮点数的 {{c|num}} 的无偏指数。

如果发生定义域错误，那么返回值由实现定义。

如果发生极点错误，那么返回 {{lc|HUGE_VAL|-HUGE_VAL}}、{{tt|-HUGE_VALF}} 或 {{tt|-HUGE_VALL}}。

===错误处理===
报告 {{lc|math_errhandling}} 中指定的错误。

如果 {{c|num}} 为零，那么可能发生定义域或值域错误。

如果实现支持 IEEE 浮点数算术（IEC 60559），那么
* 如果 {{c|num}} 是 ±0，那么返回 -∞ 并引发 {{lc|FE_DIVBYZERO}}。
* 如果 {{c|num}} 是 ±∞，那么返回 +∞。
* 如果 {{c|num}} 是 NaN，那么返回 NaN。
* 所有其他情况下，结果是准确的（决不引发 {{lc|FE_INEXACT}}）且忽略[[cpp/numeric/fenv/FE_round|当前舍入模式]]。

===注解===
[https://pubs.opengroup.org/onlinepubs/9699919799/functions/logb.html POSIX 要求]在 {{c|num}} 是 ±0 时发生极点错误。

{{tt|std::logb}} 返回的指数值始终比 {{lc|std::frexp}} 所返回的小 1，因为正规化要求不同：对于 {{tt|std::logb}} 返回的指数 {{c|e}}，{{math|{{!}}num*r{{su|p=-e}}{{!}}}} 在 {{c|1}} 和 {{c|r}} 之间（典型地在 {{c|1}} 和 {{c|2}} 之间），但对于 {{lc|std::frexp}} 返回的指数 {{c|e}}，{{math|{{!}}num*2{{su|p=-e}}{{!}}}} 在 {{c|0.5}} 和 {{c|1}} 之间。

{{cpp/numeric/math/additional integer overload note|logb}}

===示例===
{{example
|比较不同的浮点数分解函数：
|code=
#include &lt;cfenv&gt;
#include &lt;cmath&gt;
#include &lt;limits&gt;
#include &lt;iostream&gt;
// #pragma STDC FENV_ACCESS ON

int main()
{
    double f = 123.45;
    std::cout &lt;&lt; "给定数字 " &lt;&lt; f &lt;&lt; "（十六进制表示为 " &lt;&lt; std::hexfloat
              &lt;&lt; f &lt;&lt; std::defaultfloat &lt;&lt; "），\n";
    
    double f3;
    double f2 = std::modf(f, &amp;f3);
    std::cout &lt;&lt; "modf() 会把它拆分成 " &lt;&lt; f3 &lt;&lt; " + " &lt;&lt; f2 &lt;&lt; '\n';

    int i;
    f2 = std::frexp(f, &amp;i);
    std::cout &lt;&lt; "frexp() 会把它拆分成 " &lt;&lt; f2 &lt;&lt; " * 2^" &lt;&lt; i &lt;&lt; '\n';

    i = std::ilogb(f);
    std::cout &lt;&lt; "logb()/ilogb() 会把它拆分成 " &lt;&lt; f / std::scalbn(1.0, i) &lt;&lt; " * "
              &lt;&lt; std::numeric_limits&lt;double&gt;::radix
              &lt;&lt; "^" &lt;&lt; std::ilogb(f) &lt;&lt; '\n';

    // 错误处理
    std::feclearexcept(FE_ALL_EXCEPT);
    
    std::cout &lt;&lt; "logb(0) = " &lt;&lt; std::logb(0) &lt;&lt; '\n';
    if (std::fetestexcept(FE_DIVBYZERO))
        std::cout &lt;&lt; "    发生 FE_DIVBYZERO\n";
}
|p=true
|output=
给定数字 123.45（十六进制表示为 0x1.edccccccccccdp+6），
modf() 会把它拆分成 123 + 0.45
frexp() 会把它拆分成 0.964453 * 2^7
logb()/ilogb() 会把它拆分成 1.92891 * 2^6
logb(0) = -Inf
    发生 FE_DIVBYZERO
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc frexp}}
{{dsc inc|cpp/numeric/math/dsc ilogb}}
{{dsc inc|cpp/numeric/math/dsc scalbn}}
{{dsc see c|c/numeric/math/logb}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}