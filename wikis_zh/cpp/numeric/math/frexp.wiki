{{cpp/title|frexp|frexpf|frexpl}}
{{cpp/numeric/math/navbar}}
{{dcl begin}}
{{dcl header|cmath}}
{{dcl rev multi|num=1|dcl1=
float       frexp ( float num, int* exp );
double      frexp ( double num, int* exp );
long double frexp ( long double num, int* exp );
|since2=c++23|dcl2=
constexpr /* floating-point-type */
            frexp ( /* floating-point-type */ num, int* exp );
}}
{{dcl|num=2|since=c++11|notes={{mark constexpr since c++23}}|
float       frexpf( float num, int* exp );
}}
{{dcl|num=3|since=c++11|notes={{mark constexpr since c++23}}|
long double frexpl( long double num, int* exp );
}}
{{dcl h|[[#注解|额外重载]] {{mark since c++11}}}}
{{dcl header|cmath}}
{{dcl|num=A|notes={{mark constexpr since c++23}}|
template&lt; class Integer &gt;
double      frexp ( Integer num, int* exp );
}}
{{dcl end}}

@1-3@ 分解给定的浮点数 {{c|x}} 为正规化小数和二的整数指数。{{rev inl|since=c++23|标准库提供所有以无 cv 限定的浮点数类型作为参数 {{c|num}} 的类型的 {{tt|std::frexp}} 重载。}}

{{rrev|since=c++11|
@A@ 为所有整数类型提供额外重载，将它们当做 {{c/core|double}}。
}}

===参数===
{{par begin}}
{{par|num|浮点数或整数}}
{{par|exp|指向要存储指数到的整数的指针}}
{{par end}}

===返回值===
如果 {{c|num}} 为零，那么返回零并将零存储到 {{c|*exp}}。

否则（如果 {{c|num}} 非零）如果没有发生错误，那么返回范围 {{tt|(-1, -0.5], [0.5, 1)}} 中满足 {{math|1=x&amp;times;2{{su|p=(*exp)}}=num}} 的值 {{c|x}} 和存储到 {{c|*exp}} 的整数。

如果存储到 {{c|*exp}} 的值在 {{c/core|int}} 的范围外，那么行为未指定。

===错误处理===
此函数不受制于任何指定于 {{lc|math_errhandling}} 的错误。

如果实现支持 IEEE 浮点数算术（IEC 60559），那么
* 如果 {{c|num}} 是 ±0，那么返回不修改的该值，并将 {{c|0}} 存储到 {{c|*exp}}。
* 如果 {{c|num}} 是 ±∞，那么返回它，并存储未指定值到 {{c|*exp}}。
* 如果 {{c|num}} 是 NaN，那么返回 NaN，并存储未指定值到 {{c|*exp}}。
* 不引发浮点数异常。
* 如果 {{lc|FLT_RADIX}} 是 2（或 2 的幂），那么返回值准确，忽略[[cpp/numeric/fenv/FE_round|当前舍入模式]]。

===注解===
在二进制系统（其中 {{lc|FLT_RADIX}} 是 {{c|2}}）上，{{tt|std::frexp}} 可实现为
{{source|1={
    *exp = (value == 0) ? 0 : (int)(1 + std::logb(value));
    return std::scalbn(value, -(*exp));
}
}}

函数 {{tt|std::frexp}} 与其对偶 {{lc|std::ldexp}} 能一起用于操纵浮点数的表示，而无需直接进行位操作。

{{cpp/numeric/math/additional integer overload note|frexp}}

===示例===
{{example
|比较不同的浮点数分解函数：
|code=
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;

int main()
{
    double f = 123.45;
    std::cout &lt;&lt; "给定数字 " &lt;&lt; f &lt;&lt; "（十六进制表示为 " &lt;&lt; std::hexfloat
              &lt;&lt; f &lt;&lt; std::defaultfloat &lt;&lt; "），\n";
    
    double f3;
    double f2 = std::modf(f, &amp;f3);
    std::cout &lt;&lt; "modf() 会把它拆分成 " &lt;&lt; f3 &lt;&lt; " + " &lt;&lt; f2 &lt;&lt; '\n';
    
    int i;
    f2 = std::frexp(f, &amp;i);
    std::cout &lt;&lt; "frexp() 会把它拆分成 " &lt;&lt; f2 &lt;&lt; " * 2^" &lt;&lt; i &lt;&lt; '\n';
    
    i = std::ilogb(f);
    std::cout &lt;&lt; "logb()/ilogb() 会把它拆分成 " &lt;&lt; f / std::scalbn(1.0, i)
              &lt;&lt; " * " &lt;&lt; std::numeric_limits&lt;double&gt;::radix
              &lt;&lt; "^" &lt;&lt; std::ilogb(f) &lt;&lt; '\n';
}
|p=true
|output=
给定数字 123.45（十六进制表示为 0x1.edccccccccccdp+6），
modf() 会把它拆分成 123 + 0.45
frexp() 会把它拆分成 0.964453 * 2^7
logb()/ilogb() 会把它拆分成 1.92891 * 2^6
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc ldexp}}
{{dsc inc|cpp/numeric/math/dsc logb}}
{{dsc inc|cpp/numeric/math/dsc ilogb}}
{{dsc inc|cpp/numeric/math/dsc modf}}
{{dsc see c|c/numeric/math/frexp}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru|tr}}