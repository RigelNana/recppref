{{ctitle|HUGE_VALF|HUGE_VAL|HUGE_VALL}}
{{cpp/numeric/math/navbar}}
{{dcl begin}}
{{dcl header|cmath}}
{{dcl|since=c++11|
#define HUGE_VALF /* 由实现定义 */
}}
{{dcl|
#define HUGE_VAL  /* 由实现定义 */
}}
{{dcl|since=c++11|
#define HUGE_VALL /* 由实现定义 */
}}
{{dcl end}}

{{c|HUGE_VALF}}、{{c|HUGE_VAL}} 和 {{c|HUGE_VALL}} 宏展开成正浮点数常量表达式，它们比较等于浮点数函数和运算符在上溢时返回的值（见 {{ltt|cpp/numeric/math/math_errhandling}}）。

{{dsc begin}}
{{dsc hitem|常量|解释}}
{{dsc|{{tt|HUGE_VALF}}|展开成指示上溢的正 {{c/core|float}} 表达式}}
{{dsc|{{tt|HUGE_VAL}}|展开成指示上溢的正 {{c/core|double}} 表达式，不必可表示为 {{c/core|float}}}}
{{dsc|{{tt|HUGE_VALL}}|展开成指示上溢的正 {{c/core|long double}} 表达式，不必可表示为 {{c/core|float}} 或 {{c|double}}}}
{{dsc end}}

在支持浮点数无穷大的平台上，这些宏始终分别展开成 {{c/core|float}}、{{c/core|double}} 和 {{c/core|long double}} 的正无穷大。

===注解===
在不支持浮点数无穷大的平台上，这些宏会展开成对应类型的最大有限数字。

C++98 添加了数学函数的 {{c/core|float}} 和 {{c/core|double}} 重载。这样就存在一个问题：{{c/core|float}} 重载不能返回 {{c|HUGE_VAL}} 来表示上溢，因为该宏不一定能表示为 {{c/core|float}}。

{{lwg|357}} 试图解决该问题。LWG 发现 C99 也有同样的问题（C99 也添加了 {{c/core|float}} 和 {{c/core|double}} 重载），并且 C99 通过添加宏 {{c|HUGE_VALF}} 和 {{c|HUGE_VALL}} 来解决这个问题。因此 LWG 357 被关闭，并且 C++11 采用了 C99 的解决方案。

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc INFINITY}}}
{{dsc see c|c/numeric/math/HUGE_VAL}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}