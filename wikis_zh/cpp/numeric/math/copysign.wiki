{{cpp/title|copysign|copysignf|copysignl}}
{{cpp/numeric/math/navbar}}
{{cpp/numeric/math/declarations
|family=copysign
|param1=mag
|param2=sgn
|constexpr_since=23
|desc=以 {{c|mag}} 的模和 {{c|sgn}} 的正负号组成浮点数。
}}

===参数===
{{par begin}}
{{par|mag, sgn|浮点数或整数}}
{{par end}}

===返回值===
如果没有错误发生，那么返回以 {{c|mag}} 的模与 {{c|sgn}} 的正负号组成的浮点数。

如果 {{c|mag}} 是 NaN，那么返回带 {{c|sgn}} 正负号的 NaN。

如果 {{c|sgn}} 是 -0，那么只有在实现支持与算术运算一致的有符号零时结果才会为负。

===错误处理===
此函数不受制于任何指定于 {{lc|math_errhandling}} 的错误。

如果实现支持 IEEE 浮点数算术（IEC 60559），那么
* 返回值是准确的（决不引发 {{lc|FE_INEXACT}}）且独立于当前[[cpp/numeric/fenv/FE_round|舍入模式]]。

===注解===
{{tt|std::copysign}} 是操作 NaN 值正负号的唯一可移植方式（使用 {{lc|std::signbit}} 也可以检验 NaN 的正负号）。

{{cpp/numeric/math/additional overload note|copysign}}

===示例===
{{example
|code=
#include &lt;cmath&gt;
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; std::showpos
              &lt;&lt; "copysign(1.0,+2.0) = " &lt;&lt; std::copysign(1.0, +2.0) &lt;&lt; '\n'
              &lt;&lt; "copysign(1.0,-2.0) = " &lt;&lt; std::copysign(1.0, -2.0) &lt;&lt; '\n'
              &lt;&lt; "copysign(inf,-2.0) = " &lt;&lt; std::copysign(INFINITY, -2.0) &lt;&lt; '\n'
              &lt;&lt; "copysign(NaN,-2.0) = " &lt;&lt; std::copysign(NAN, -2.0) &lt;&lt; '\n';
}
|output=
copysign(1.0,+2.0) = +1
copysign(1.0,-2.0) = -1
copysign(inf,-2.0) = -inf
copysign(NaN,-2.0) = -nan
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc fabs}}
{{dsc inc|cpp/numeric/math/dsc signbit}}
{{dsc see c|c/numeric/math/copysign}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}