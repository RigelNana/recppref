{{cpp/title|trunc|truncf|truncl}}
{{cpp/numeric/math/navbar}}
{{cpp/numeric/math/declarations
|family=trunc
|param1=num
|constexpr_since=23
|desc=计算绝对值不大于 {{c|num}} 的最接近整数。
}}

===参数===
{{par begin}}
{{par|num|浮点数或整数}}
{{par end}}

===返回值===
如果没有发生错误，那么返回绝对值不大于 {{c|num}} 的最接近整数（换言之，将 {{c|num}} 向零舍入）。

{{plot|left=返回值|bottom={{c|num}}|math-trunc.svg}}

===错误处理===
报告 {{lc|math_errhandling}} 中指定的错误。

如果实现支持 IEEE 浮点数算术（IEC 60559），那么
* 当前[[cpp/numeric/fenv/FE_round|舍入模式]]无效。
* 如果 {{c|num}} 是 ±∞，那么返回不修改的该值。
* 如果 {{c|num}} 是 ±0，那么返回不修改的该值。
* 如果 {{c|num}} 是 NaN，那么返回 NaN

===注解===
截断非整数有限值时可以（但不要求）引发 {{lc|FE_INEXACT}}。

因为所有标准浮点数格式的最大可表示浮点数值都是准确的整数，所以此函数自身永远不会上溢；然而将结果存储到整数对象时，结果可以溢出任何整数类型（包含 {{lc|std::intmax_t}}）。

从浮点数到整数类型的{{lt|cpp/language/implicit conversion|隐式转换}}始终向零舍入，但它被限制于能表示成目标类型的值。

{{cpp/numeric/math/additional integer overload note|trunc}}

===示例===
{{example
|code=
#include &lt;cmath&gt;
#include &lt;initializer_list&gt;
#include &lt;iostream&gt;
 
int main()
{
    const auto data = std::initializer_list&lt;double&gt;
    {
        +2.7, -2.9, +0.7, -0.9, +0.0, 0.0, -INFINITY, +INFINITY, -NAN, +NAN
    };
    
    std::cout &lt;&lt; std::showpos;
    for (double const x : data)
        std::cout &lt;&lt; "trunc(" &lt;&lt; x &lt;&lt; ") == " &lt;&lt; std::trunc(x) &lt;&lt; '\n';
}
|p=true
|output=
trunc(+2.7) == +2
trunc(-2.9) == -2
trunc(+0.7) == +0
trunc(-0.9) == -0
trunc(+0) == +0
trunc(+0) == +0
trunc(-inf) == -inf
trunc(+inf) == +inf
trunc(-nan) == -nan
trunc(+nan) == +nan
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc floor}}
{{dsc inc|cpp/numeric/math/dsc ceil}}
{{dsc inc|cpp/numeric/math/dsc round}}
{{dsc see c|c/numeric/math/trunc}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}