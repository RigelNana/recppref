{{cpp/title|pow|powf|powl}}
{{cpp/numeric/math/navbar}}
{{dcl begin}}
{{dcl header|cmath}}
{{dcl rev multi|num=1|dcl1=
float       pow ( float base, float exp );
double      pow ( double base, double exp );
long double pow ( long double base, long double exp );
|since2=c++23|dcl2=
/* floating-point-type */
            pow ( /* floating-point-type */ base,
                  /* floating-point-type */ exp )
}}
{{dcl|num=2|until=c++11|
float       pow ( float base, int exp );
double      pow ( double base, int exp );
long double pow ( long double base, int exp );
}}
{{dcl|num=3|since=c++11|
float       powf( float base, float exp );
}}
{{dcl|num=4|since=c++11|
long double powl( long double base, long double exp );
}}
{{dcl h|[[#注解|额外重载]] {{mark since c++11}}}}
{{dcl header|cmath}}
{{dcl|num=A|notes={{mark constexpr since c++26}}|
template&lt; class Arithmetic1, class Arithmetic2 &gt;
/* common-floating-point-type */
            pow ( Arithmetic1 base, Arithmetic2 exp );
}}
{{dcl end}}

@1-4@ 计算 {{c|base}} 的 {{c|exp}} 次幂。{{rev inl|since=c++23|标准库提供所有以无 cv 限定的浮点数类型作为参数 {{c|base}} 和 {{c|exp}} 的类型的 {{tt|std::pow}} 重载。}}

{{rrev|since=c++11|
@A@ 为算术类型的所有其他组合提供额外重载。
}}

===参数===
{{par begin}}
{{par|base|作为底数的浮点数或整数}}
{{par|exp|作为指数的浮点数或整数}}
{{par end}}

===返回值===
如果没有发生错误，那么返回 {{c|base}} 的 {{c|exp}} 次幂（{{math|base{{su|p=exp}}}}）。

如果发生定义域错误，那么返回值由实现定义（在支持的平台上是 NaN）。

如果发生极点错误或上溢导致的值域错误，那么返回 {{lc|HUGE_VAL|±HUGE_VAL}}、{{tt|±HUGE_VALF}} 或 {{tt|±HUGE_VALL}}。

如果发生下溢导致的值域错误，那么返回（舍入后的）正确结果。

===错误处理===
报告 {{lc|math_errhandling}} 中指定的错误。

如果 {{c|base}} 有限且为负，且 {{c|exp}} 有限且为非整数，那么发生现定义域错误，并可能发生值域错误。

如果 {{c|base}} 为零且 {{c|exp}} 为零，那么可能发生定义域错误。

如果 {{c|base}} 为零且 {{c|exp}} 为负，那么可能发生定义域错误或极点错误。

如果实现支持 IEEE 浮点数算术（IEC 60559），那么
* {{c|pow(+0, exp)}}，其中 {{c|exp}} 是负奇数，返回 +∞ 并引发 {{lc|FE_DIVBYZERO}}
* {{c|pow(-0, exp)}}，其中 {{c|exp}} 是负奇数，返回 -∞ 并引发 {{lc|FE_DIVBYZERO}}
* {{c|pow(±0, exp)}}，其中 {{c|exp}} 是有限负数，并且是偶数或非整数，那么返回 +∞ 并引发 {{lc|FE_DIVBYZERO}}
* {{c|pow(±0, -∞)}} 返回 +∞ 并可能引发 {{lc|FE_DIVBYZERO}}
* {{c|pow(+0, exp)}}，其中 {{c|exp}} 是正奇数，返回 +0
* {{c|pow(-0, exp)}}，其中 {{c|exp}} 是正奇数，返回 -0
* {{c|pow(±0, exp)}}，其中 {{c|exp}} 是正非整数或正偶数，返回 +0
* {{c|pow(-1, ±∞)}} 返回 1
* {{c|pow(+1, exp)}} 对于任何 {{c|exp}} 返回 1，即使 {{c|exp}} 是 NaN
* {{c|pow(base, ±0)}} 对于任何 {{c|base}} 返回 1，即使 {{c|base}} 是 NaN
* {{c|pow(base, exp)}} 返回 NaN 并引发 {{lc|FE_INVALID}}，如果 {{c|base}} 是有限负数且 {{c|exp}} 是有限非整数。
* {{c|pow(base, -∞)}} 对任何 {{tt|{{!}}base{{!}}&lt;1}} 返回 +∞
* {{c|pow(base, -∞)}} 对任何 {{tt|{{!}}base{{!}}&gt;1}} 返回 +0
* {{c|pow(base, +∞)}} 对任何 {{tt|{{!}}base{{!}}&lt;1}} 返回 +0
* {{c|pow(base, +∞)}} 对任何 {{tt|{{!}}base{{!}}&gt;1}} 返回 +∞
* {{c|pow(-∞, exp)}} 返回 -0，如果 {{c|exp}} 是负奇整数
* {{c|pow(-∞, exp)}} 返回 +0，如果 {{c|exp}} 是负非整数或负偶数
* {{c|pow(-∞, exp)}} 返回 -∞，如果 {{c|exp}} 是正奇整数
* {{c|pow(-∞, exp)}} 返回 +∞，如果 {{c|exp}} 是正非整数或正偶数
* {{c|pow(+∞, exp)}} 对任何 {{c|exp}} 返回 +0
* {{c|pow(+∞, exp)}} 对任何 {{c|exp}} 返回 +∞
* 除了以上规则，如果有任何实参是 NaN，那么返回 NaN

===注解===
C++98 在 C {{ltf|c/numeric/math/pow}} 的基础上添加了 {{c|exp}} 具有 {{c/core|int}} 类型的重载，并且 {{c/core|std::pow(float, int)}} 的返回类型是 {{c/core|float}}。然而在 C++11 中新增的额外重载指定 {{c/core|std::pow(float, int)}} 应该返回 {{c/core|double}}。因此提出 {{lwg|550}} 以解决此冲突，解决方案是移除 {{c/core|int}} {{c|exp}} 重载。

尽管 {{tt|std::pow}} 不能获得负数的开方根，不过提供了 {{lc|std::cbrt}} 来处理 {{c|exp}} 是 1/3 的常用情况。

{{cpp/numeric/math/additional overload note|pow}}

===示例===
{{example
|code=
#include &lt;cerrno&gt;
#include &lt;cfenv&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
// #pragma STDC FENV_ACCESS ON
 
int main()
{
    // 通常用法
    std::cout &lt;&lt; "pow(2, 10) = " &lt;&lt; std::pow(2, 10) &lt;&lt; '\n'
              &lt;&lt; "pow(2, 0.5) = " &lt;&lt; std::pow(2, 0.5) &lt;&lt; '\n'
              &lt;&lt; "pow(-2, -3) = " &lt;&lt; std::pow(-2, -3) &lt;&lt; '\n';
    
    // 特殊值
    std::cout &lt;&lt; "pow(-1, NAN) = " &lt;&lt; std::pow(-1, NAN) &lt;&lt; '\n'
              &lt;&lt; "pow(+1, NAN) = " &lt;&lt; std::pow(+1, NAN) &lt;&lt; '\n'
              &lt;&lt; "pow(INFINITY, 2) = " &lt;&lt; std::pow(INFINITY, 2) &lt;&lt; '\n'
              &lt;&lt; "pow(INFINITY, -1) = " &lt;&lt; std::pow(INFINITY, -1) &lt;&lt; '\n';
    
    // 错误处理
    errno = 0;
    std::feclearexcept(FE_ALL_EXCEPT);
    
    std::cout &lt;&lt; "pow(-1, 1/3) = " &lt;&lt; std::pow(-1, 1.0 / 3) &lt;&lt; '\n';
    if (errno == EDOM)
        std::cout &lt;&lt; "    errno == EDOM " &lt;&lt; std::strerror(errno) &lt;&lt; '\n';
    if (std::fetestexcept(FE_INVALID))
        std::cout &lt;&lt; "    发生 FE_INVALID\n";
    
    std::feclearexcept(FE_ALL_EXCEPT);
    
    std::cout &lt;&lt; "pow(-0, -3) = " &lt;&lt; std::pow(-0.0, -3) &lt;&lt; '\n';
    if (std::fetestexcept(FE_DIVBYZERO))
        std::cout &lt;&lt; "    发生 FE_DIVBYZERO\n";
}
|p=true
|output=
pow(2, 10) = 1024
pow(2, 0.5) = 1.41421
pow(-2, -3) = -0.125
pow(-1, NAN) = nan
pow(+1, NAN) = 1
pow(INFINITY, 2) = inf
pow(INFINITY, -1) = 0
pow(-1, 1/3) = -nan
    errno == EDOM Numerical argument out of domain
    发生 FE_INVALID
pow(-0, -3) = -inf
    发生 FE_DIVBYZERO
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc sqrt}}
{{dsc inc|cpp/numeric/math/dsc cbrt}}
{{dsc inc|cpp/numeric/math/dsc hypot}}
{{dsc inc|cpp/numeric/complex/dsc pow}}
{{dsc inc|cpp/numeric/valarray/dsc pow}}
{{dsc see c|c/numeric/math/pow}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}