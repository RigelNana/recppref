{{cpp/title|round|roundf|roundl|lround|lroundf|lroundl|llround|llroundf|llroundl}}
{{cpp/numeric/math/navbar}}
{{dcl begin}}
{{dcl header|cmath}}
{{dcl h|舍入到浮点数类型}}
{{dcl rev multi|num=1|since1=c++11|dcl1=
float       round ( float num );
double      round ( double num );
long double round ( long double num );
|since2=c++23|dcl2=
constexpr /* floating-point-type */
            round ( /* floating-point-type */ num );
}}
{{dcla|anchor=no|num=2|since=c++11|constexpr=c++23|
float       roundf( float num );
}}
{{dcla|anchor=no|num=3|since=c++11|constexpr=c++23|
long double roundl( long double num );
}}
{{dcl h|舍入到 {{c/core|long}}}}
{{dcl rev multi|num=4|since1=c++11|dcl1=
long lround ( float num );
long lround ( double num );
long lround ( long double num );
|since2=c++23|dcl2=
constexpr long lround( /* floating-point-type */ num );
}}
{{dcla|anchor=no|num=5|since=c++11|constexpr=c++23|
long lroundf( float num );
}}
{{dcla|anchor=no|num=6|since=c++11|constexpr=c++23|
long lroundl( long double num );
}}
{{dcl h|舍入到 {{c/core|long long}}}}
{{dcl rev multi|num=7|since1=c++11|dcl1=
long long llround ( float num );
long long llround ( double num );
long long llround ( long double num );
|since2=c++23|dcl2=
constexpr long long llround( /* floating-point-type */ num );
}}
{{dcla|anchor=no|num=8|since=c++11|constexpr=c++23|
long long llroundf( float num );
}}
{{dcla|anchor=no|num=9|since=c++11|constexpr=c++23|
long long llroundl( long double num );
}}
{{dcl h|[[#注解|额外重载]]}}
{{dcl header|cmath}}
{{dcla|anchor=no|num=A|since=c++11|constexpr=c++23|
template&lt; class Integer &gt;
double round( Integer num );
}}
{{dcla|anchor=no|num=B|since=c++11|constexpr=c++23|
template&lt; class Integer &gt;
long lround( Integer num );
}}
{{dcla|anchor=no|num=C|since=c++11|constexpr=c++23|
template&lt; class Integer &gt;
long long llround( Integer num );
}}
{{dcl end}}

@1-3@ 计算 {{c|num}} 的最接近整数（以浮点数格式），中点情况舍入为远离零，无关乎当前舍入模式。{{rev inl|since=c++23|标准库提供所有以无 cv 限定的浮点数类型作为实参 {{c|num}} 的类型的 {{tt|std::round}} 重载。}}
@4-9@ 计算 {{c|num}} 的最接近整数（以整数格式），中点情况舍入为远离零，无关乎当前舍入模式。{{rev inl|since=c++23|标准库提供所有以无 cv 限定的浮点数类型作为实参 {{c|num}} 的类型的 {{tt|std::lround}} 和 {{tt|std::llround}} 重载。}}
@A-C@ 为所有整数类型提供额外重载，将它们当做 {{c/core|double}}。

===参数===
{{par begin}}
{{par|num|浮点数或整数}}
{{par end}}

===返回值===
如果没有发生错误，那么返回 {{c|num}} 的最接近整数的值，中点情况为远离零者。

{{plot|left=返回值|bottom={{c|num}}|math-round_away_zero.svg}}

如果发生定义域错误，那么返回值由实现定义。

===错误处理===
报告 {{lc|math_errhandling}} 中指定的错误。

如果 {{tt|std::lround}} 或 {{tt|std::llround}} 的结果在返回类型的可表示范围外，那么可能发生定义域错误或值域错误。

如果实现支持 IEEE 浮点数算术（IEC 60559），那么
: 对于 {{tt|std::round}} 函数：
:* 当前[[cpp/numeric/fenv/FE_round|舍入模式]]无效。
:* 如果 {{c|num}} 是 ±∞，那么返回不修改的该值。
:* 如果 {{c|num}} 是 ±0，那么返回不修改的该值。
:* 如果 {{c|num}} 是 NaN，那么返回 NaN。
: 对于 {{tt|std::lround}} 和 {{tt|std::llround}} 函数：
:* 决不引发 {{lc|FE_INEXACT}}。
:* 当前[[cpp/numeric/fenv/FE_round|舍入模式]]无效。
:* 如果 {{c|num}} 是 ±∞，那么引发 {{lc|FE_INVALID}} 并返回实现定义值。
:* 如果舍入结果在返回类型范围外，那么引发 {{lc|FE_INVALID}} 并返回实现定义值。
:* 如果 {{c|num}} 是 NaN，那么引发 {{lc|FE_INVALID}} 并返回实现定义值。

===注解===
舍入非整数有限值时 {{tt|std::round}} 可以（但不要求）引发 {{lc|FE_INEXACT}}。

因为所有标准浮点数格式的最大可表示浮点数值都是准确的整数，所以 {{tt|std::round}} 自身永远不会上溢；然而在存储到整数对象时，结果可能溢出任何整数类型（包括 {{lc|std::intmax_t}}）。

[https://pubs.opengroup.org/onlinepubs/9699919799/functions/lround.html POSIX 指定] {{tt|std::lround}} 或 {{tt|std::llround}} 引发 {{lc|FE_INEXACT}} 的所有情况都是定义域错误。

{{tt|std::round}} 的 {{c/core|double}} 版本表现为如同实现如下：
{{source|1=
#include &lt;cfenv&gt;
#include &lt;cmath&gt;

#pragma STDC FENV_ACCESS ON

double round(double x)
{
    const int save_round = std::fegetround();
    std::fesetround(FE_TOWARDZERO);
    const double result = std::rint(std::copysign(0.5 + std::fabs(x), x));
    std::fesetround(save_round);
    return result;
}
}}

{{cpp/numeric/math/additional integer overload note|round}}

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;cfenv&gt;
#include &lt;cfloat&gt;
#include &lt;climits&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;

// #pragma STDC FENV_ACCESS ON

double custom_round(double x)
{
    const int save_round = std::fegetround();
    std::fesetround(FE_TOWARDZERO);
    const double result = std::rint(std::copysign(0.5 + std::fabs(x), x));
    std::fesetround(save_round);
    return result;
}

void test_custom_round()
{
    for (const double x :
        {
            0.0, 0.3,
            0.5 - DBL_EPSILON / 2,
            0.5,
            0.5 + DBL_EPSILON / 2,
            0.7, 1.0, 2.3, 2.5, 2.7, 3.0,
            static_cast&lt;double&gt;(INFINITY)
        })
        assert(round(+x) == custom_round(+x) &amp;&amp; round(-x) == custom_round(-x));
}

int main()
{
    test_custom_round();

    std::cout &lt;&lt; std::showpos;

    // round
    std::cout &lt;&lt; "round(+2.3) = " &lt;&lt; std::round(2.3)
              &lt;&lt; "  round(+2.5) = " &lt;&lt; std::round(2.5)
              &lt;&lt; "  round(+2.7) = " &lt;&lt; std::round(2.7) &lt;&lt; '\n'
              &lt;&lt; "round(-2.3) = " &lt;&lt; std::round(-2.3)
              &lt;&lt; "  round(-2.5) = " &lt;&lt; std::round(-2.5)
              &lt;&lt; "  round(-2.7) = " &lt;&lt; std::round(-2.7) &lt;&lt; '\n';
    
    std::cout &lt;&lt; "round(-0.0) = " &lt;&lt; std::round(-0.0)  &lt;&lt; '\n'
              &lt;&lt; "round(-Inf) = " &lt;&lt; std::round(-INFINITY) &lt;&lt; '\n';
    
    // lround
    std::cout &lt;&lt; "lround(+2.3) = " &lt;&lt; std::lround(2.3)
              &lt;&lt; "  lround(+2.5) = " &lt;&lt; std::lround(2.5)
              &lt;&lt; "  lround(+2.7) = " &lt;&lt; std::lround(2.7) &lt;&lt; '\n'
              &lt;&lt; "lround(-2.3) = " &lt;&lt; std::lround(-2.3)
              &lt;&lt; "  lround(-2.5) = " &lt;&lt; std::lround(-2.5)
              &lt;&lt; "  lround(-2.7) = " &lt;&lt; std::lround(-2.7) &lt;&lt; '\n';
    
    std::cout &lt;&lt; "lround(-0.0) = " &lt;&lt; std::lround(-0.0)  &lt;&lt; '\n'
              &lt;&lt; "lround(-Inf) = " &lt;&lt; std::lround(-INFINITY) &lt;&lt; '\n';
    
    // 错误处理
    std::feclearexcept(FE_ALL_EXCEPT);
    
    std::cout &lt;&lt; "std::lround(LONG_MAX+1.5) = "
              &lt;&lt; std::lround(LONG_MAX + 1.5) &lt;&lt; '\n';
    if (std::fetestexcept(FE_INVALID))
        std::cout &lt;&lt; "    发生 FE_INVALID\n";
}
|p=true
|output=
round(+2.3) = 2  round(+2.5) = 3  round(+2.7) = 3
round(-2.3) = -2  round(-2.5) = -3  round(-2.7) = -3
round(-0.0) = -0
round(-Inf) = -inf
lround(+2.3) = 2  lround(+2.5) = 3  lround(+2.7) = 3
lround(-2.3) = -2  lround(-2.5) = -3  lround(-2.7) = -3
lround(-0.0) = 0
lround(-Inf) = -9223372036854775808
std::lround(LONG_MAX+1.5) = -9223372036854775808
    发生 FE_INVALID
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc floor}}
{{dsc inc|cpp/numeric/math/dsc ceil}}
{{dsc inc|cpp/numeric/math/dsc trunc}}
{{dsc see c|c/numeric/math/round}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}