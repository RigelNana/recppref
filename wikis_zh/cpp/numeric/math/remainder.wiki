{{cpp/title|remainder|remainderf|remainderl}}
{{cpp/numeric/math/navbar}}
{{cpp/numeric/math/declarations
|family=remainder
|param1=x
|param2=y
|constexpr_since=23
|desc=计算浮点数除法运算 {{c|x / y}} 的 IEEE 余数。
}}

此函数所计算的除法运算 {{c|x / y}} 的 IEEE 浮点数余数，准确地为值 {{c|x - quo * y}}，其中值 {{c|quo}} 是最接近 {{c|x / y}} 准确值的整数。{{math|{{!}}quo-x/y{{!}} {{=}} ½}} 时，选择作为偶数的 {{c|quo}}。

与 {{lc|std::fmod}} 相反，不保证返回值拥有与 {{c|x}} 相同的正负号。

如果返回值为零，那么它拥有与 {{c|x}} 相同的正负号。

===参数===
{{par begin}}
{{par|x, y|浮点数或整数}}
{{par end}}

===返回值===
在成功时返回在上文定义的除法 {{c|x / y}} 浮点数余数。

如果出现定义域错误，那么返回值由实现定义（受支持的平台上是 NaN）。

如果出现下溢导致的值域错误，那么返回正确结果。

如果 {{c|y}} 为零但不出现定义域错误，那么返回零。

===错误处理===
报告 {{lc|math_errhandling}} 中指定的错误。

如果 {{c|y}} 为零，那么可能发生定义域错误。

如果实现支持 IEEE 浮点数算术（IEC 60559），那么
* 当前[[cpp/numeric/fenv/FE_round|舍入模式]]无效。
* 决不引发 {{lc|FE_INEXACT}}，结果始终准确。
* 如果 {{c|x}} 是 ±∞ 且 {{c|y}} 非 NaN，那么返回 NaN 并引发 {{lc|FE_INVALID}}。
* 如果 {{c|y}} 是 ±0 且 {{c|x}} 非 NaN，那么返回 NaN 并引发 {{lc|FE_INVALID}}。
* 如果任一参数是 NaN，那么返回 NaN。

===注解===
[https://pubs.opengroup.org/onlinepubs/9699919799/functions/remainder.html POSIX 要求]在 {{c|x}} 是无穷大或 {{c|y}} 为零时发生定义域错误。

{{lc|std::fmod}}，但不是 {{tt|std::remainder}}，适于安静地包装浮点数类型到无符号整数类型：{{c|1=(0.0 &lt;= (y = std::fmod(std::rint(x), 65536.0))) ? y : 65536.0 + y}} 在范围 {{range|-0.0|65535.0|]}} 内，它对应 {{c/core|unsigned short}} ，但 {{c|std::remainder(std::rint(x), 65536.0)}} 在范围 {{range|-32767.0|+32768.0|]}} 内，它在 {{c/core|signed short}} 的范围外。

{{cpp/numeric/math/additional overload note|remainder}}

===示例===
{{example
|code=
#include &lt;cfenv&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
// #pragma STDC FENV_ACCESS ON

int main()
{
    std::cout &lt;&lt; "remainder(+5.1, +3.0) = " &lt;&lt; std::remainder(5.1, 3) &lt;&lt; '\n'
              &lt;&lt; "remainder(-5.1, +3.0) = " &lt;&lt; std::remainder(-5.1, 3) &lt;&lt; '\n'
              &lt;&lt; "remainder(+5.1, -3.0) = " &lt;&lt; std::remainder(5.1, -3) &lt;&lt; '\n'
              &lt;&lt; "remainder(-5.1, -3.0) = " &lt;&lt; std::remainder(-5.1, -3) &lt;&lt; '\n';
    
    // 特殊值
    std::cout &lt;&lt; "remainder(-0.0, 1.0) = " &lt;&lt; std::remainder(-0.0, 1) &lt;&lt; '\n'
              &lt;&lt; "remainder(5.1, Inf) = " &lt;&lt; std::remainder(5.1, INFINITY) &lt;&lt; '\n';
    
    // 错误处理
    std::feclearexcept(FE_ALL_EXCEPT);
    std::cout &lt;&lt; "remainder(+5.1, 0) = " &lt;&lt; std::remainder(5.1, 0) &lt;&lt; '\n';
    if (fetestexcept(FE_INVALID))
        std::cout &lt;&lt; "    发生 FE_INVALID\n";
}
|p=true
|output=
remainder(+5.1, +3.0) = -0.9
remainder(-5.1, +3.0) = 0.9
remainder(+5.1, -3.0) = -0.9
remainder(-5.1, -3.0) = 0.9
remainder(-0.0, 1.0) = -0
remainder(5.1, Inf) = 5.1
remainder(+5.1, 0) = -nan
    发生 FE_INVALID
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc div}}
{{dsc inc|cpp/numeric/math/dsc fmod}}
{{dsc inc|cpp/numeric/math/dsc remquo}}
{{dsc see c|c/numeric/math/remainder}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|ko|pt|ru}}