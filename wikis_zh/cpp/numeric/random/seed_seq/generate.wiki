{{cpp/numeric/random/seed_seq/title|generate}}
{{cpp/numeric/random/seed_seq/navbar}}
{{ddcl|since=c++11|1=
template&lt; class RandomIt &gt;
void generate( RandomIt begin, RandomIt end );
}}

基于 {{rlpsi|/#v}} 中存储的（可能有偏差的）种子，通过以 32 位无符号整数值填充范围 {{range|begin|end}} 的方式生成无偏差种子。
* 如果 {{c|1=begin == end}} 是 {{c|true}}，那么什么也不做。
* 否则，按照如下所述的生成算法生成种子。

如果 {{c/core|std::iterator_traits&lt;RandomIt&gt;::value_type}} 不是无符号整数类型，或者它的宽度小于 32，那么程序非良构。

如果 {{tt|RandomIt}} 不满足{{named req|RandomAccessIterator}}的要求，或者它不[[cpp/iterator|可变]]，那么行为未定义。

===生成算法===
给定以下值和操作：
{{dsc begin}}
{{dsc hitem|值|定义}}
{{dsc|{{c|z}}|{{box|{{rlpsi|/#v}}{{sep}}{{c/core|.size()}}}}}}
{{dsc|{{c|n}}|{{c|end - begin}}}}
{{dsc|{{c|m}}|{{c|std::max(z + 1, n)}}}}
{{dsc|{{c|t}}|{{c|1=(n &gt;= 623) ? 11 : (n &gt;= 68) ? 7 : (n &gt;= 39) ? 5 : (n &gt;= 7) ? 3 : (n - 1) / 2}}}}
{{dsc|{{c|p}}|{{c|(n - t) / 2}}}}
{{dsc|{{c|q}}|{{c|p + t}}}}
{{dsc hitem|操作|定义}}
{{dsc|{{mathjax-or|\(\scriptsize \mathsf{xor} \)|xor}}|内建的[[cpp/language/operator arithmetic#逐位逻辑运算符|逐位异或]]}}
{{dsc|{{mathjax-or|\(\scriptsize \mathsf{rshift} \)|rshift}}|内建的[[cpp/language/operator arithmetic#移位运算符|向右移位]]}}
{{dsc|{{mathjax-or|\(\scriptsize T(x) \)|T(x)}}|{{mathjax-or|\(\scriptsize x\ \mathsf{xor}\ (x\ \mathsf{rshift}\ 27) \)|x xor (x rshift 27)}}}}
{{dsc end}}

生成算法包含以下步骤，其中 {{mathjax-or|\(\scriptsize S_i \)|S{{su|b=i}}}} 表示 {{c|begin[i % n]}}，{{mathjax-or|\(\scriptsize V_i \)|V{{su|b=i}}}} 表示 {{box|{{rlpsi|/#v}}{{sep}}{{c/core|[i]}}}}：

@1@ 将输出范围中的所有元素都设置为 {{c|0x8b8b8b8b}}。

@2@ 对 {{range|0|m}} 中的所有整数 {{c|k}}，依次按顺序进行以下操作：

:@1@ 设 {{mathjax-or|\(\scriptsize r_1 \)|r{{su|b=1}}}} 为 {{mathjax-or|\(\scriptsize 1664525 \cdot T(S_k\ \mathsf{xor}\ S_{k+p}\ \mathsf{xor}\ S_{k-1}) \)|1664525·T(S{{su|b=k}} xor S{{su|b=k+p}} xor S{{su|b=k-1}})}}。

:@2@ 设 {{mathjax-or|\(\scriptsize r_2 \)|r{{su|b=2}}}} 为 {{mathjax-or|\(\scriptsize r_1 + j \)|r{{su|b=1}}+j}}，其中 {{mathjax-or|\(\scriptsize j \)|j}} 是：
* {{mathjax-or|\(\scriptsize z \)|z}}，如果 {{mathjax-or|1=\(\scriptsize k=0 \)|2=k=0}}
* {{mathjax-or|\(\scriptsize (k \mod n)+V_{k-1} \)|(k mod n)+V{{su|b=k-1}}}}，如果 {{mathjax-or|\(\scriptsize 0&lt;k⩽z \)|0&lt;k⩽z}}
* {{mathjax-or|\(\scriptsize k \mod n \)|k mod n}}，如果 {{mathjax-or|\(\scriptsize z&lt;k \)|z&lt;k}}

:@3@ 将 {{mathjax-or|\(\scriptsize S_{k+p} \)|S{{su|b=k+p}}}} 设置为 {{mathjax-or|\(\scriptsize (S_{k+p}+r_1) \mod 2^{32} \)|(S{{su|b=k+p}}+r{{su|b=1}}) mod 2{{su|p=32}}}}。

:@4@ 将 {{mathjax-or|\(\scriptsize S_{k+q} \)|S{{su|b=k+q}}}} 设置为 {{mathjax-or|\(\scriptsize (S_{k+q}+r_2) \mod 2^{32} \)|(S{{su|b=k+q}}+r{{su|b=2}}) mod 2{{su|p=32}}}}。

:@5@ 将 {{mathjax-or|\(\scriptsize S_k \)|S{{su|b=k}}}} 设置为 {{mathjax-or|\(\scriptsize r_2 \mod 2^{32} \)|r{{su|b=2}} mod 2{{su|p=32}}}}。

@3@ 对 {{range|m|m + n}} 中的所有整数 {{c|k}}，依次按顺序进行以下操作：

:@1@ 设 {{mathjax-or|\(\scriptsize r_3 \)|r{{su|b=3}}}} 为 {{mathjax-or|\(\scriptsize 1566083941 \cdot T(S_k+S_{k+p}+S_{k-1}) \)|1566083941·T(S{{su|b=k}}+S{{su|b=k+p}}+S{{su|b=k-1}})}}。

:@2@ 设 {{mathjax-or|\(\scriptsize r_4 \)|r{{su|b=4}}}} 为 {{mathjax-or|\(\scriptsize r_3-(k \mod n) \)|r{{su|b=3}}-(k mod n)}}。

:@3@ 将 {{mathjax-or|\(\scriptsize S_{k+p} \)|S{{su|b=k+p}}}} 设置为 {{mathjax-or|\(\scriptsize (S_{k+p}\ \mathsf{xor}\ r_3) \mod 2^{32} \)|(S{{su|b=k+p}} xor r{{su|b=3}}) mod 2{{su|p=32}}}}。

:@4@ 将 {{mathjax-or|\(\scriptsize S_{k+q} \)|S{{su|b=k+q}}}} 设置为 {{mathjax-or|\(\scriptsize (S_{k+q}\ \mathsf{xor}\ r_4) \mod 2^{32} \)|(S{{su|b=k+q}} xor r{{su|b=4}}) mod 2{{su|p=32}}}}。

:@5@ 将 {{mathjax-or|\(\scriptsize S_k \)|S{{su|b=k}}}} 设置为 {{mathjax-or|\(\scriptsize r_4 \mod 2^{32} \)|r{{su|b=4}} mod 2{{su|p=32}}}}。

===参数===
{{par begin}}
{{par|begin, end|表示输出范围的迭代器}}
{{par end}}

===异常===
只会抛出在 {{c|begin}} 和 {{c|end}} 上的 {{tt|RandomIt}} 操作抛出的异常。

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cstdint&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;

// std::seed_seq 主体部分的雏形……
struct seed_seq
{
    std::vector&lt;std::uint32_t&gt; v;
    
    seed_seq(std::initializer_list&lt;std::uint32_t&gt; const il) : v{il} {}
    
    template&lt;typename RandomIt&gt;
    void generate(RandomIt first, RandomIt last)
    {
        if (first == last)
            return;
        //
        // 假定 v = {1,2,3,4,5} 且 distance(first, last) == 10。
        //
        // 步骤 1：以 0x8b8b8b8b 填充
        // seeds = {2341178251, 2341178251, 2341178251, 2341178251, 2341178251,
        //          2341178251, 2341178251, 2341178251, 2341178251, 2341178251}
        //
        std::fill(first, last, 0x8b8b8b8b);
        //
        // 步骤 2：
        // n = 10, s = 5, t = 3, p = 3, q = 6, m = 10
        //
        const std::uint32_t n = last - first;
        const std::uint32_t s = v.size();
        const std::uint32_t t = (n &lt; 7) ? (n - 1) / 2
                              : (n &lt; 39) ? 3
                              : (n &lt; 68) ? 5
                              : (n &lt; 623) ? 7
                              : 11;
        const std::uint32_t p = (n - t) / 2;
        const std::uint32_t q = p + t;
        const std::uint32_t m = std::max(s + 1, n);
        //
        // 首次迭代，k = 0；r1 = 1371501266，r2 = 1371501271
        //
        // seeds = {1371501271, 2341178251, 2341178251, 3712679517, 2341178251,
        //          2341178251, 3712679522, 2341178251, 2341178251, 2341178251}
        //
        // 从 k = 1 到 k = 5 迭代（r2 = r1 + k % n + v[k - 1]）
        //
        // r1 = 2786190137, 3204727651, 4173325571, 1979226628, 401983366
        // r2 = 2786190139, 3204727655, 4173325577, 1979226636, 401983376
        //
        // seeds = {3350727907, 3188173515, 3204727655, 4173325577, 1979226636,
        //           401983376, 3591037797, 2811627722, 1652921976, 2219536532}
        //
        // 从 k = 6 到 k = 9 迭代（r2 = r1 + k % n）
        //
        // r1 = 2718637909, 1378394210, 2297813071, 1608643617
        // r2 = 2718637915, 1378394217, 2297813079, 1608643626
        //
        // seeds = { 434154821, 1191019290, 3237041891, 1256752498, 4277039715,
        //          2010627002, 2718637915, 1378394217, 2297813079, 1608643626}
        //
        auto begin_mod = [first, n](std::uint32_t u) -&gt; decltype(*first)&amp;
        {
            return first[u % n]; // 即 begin[x] 按 modulo n 取值
        };
        auto T = [](std::uint32_t x) { return x ^ (x &gt;&gt; 27); };
        
        for (std::uint32_t k = 0, r1, r2; k &lt; m; ++k)
        {
            r1 = 1664525 * T(begin_mod(k) ^ begin_mod(k + p) ^ begin_mod(k - 1));
            r2 = (k == 0) ? r1 + s
               : (k &lt;= s) ? r1 + k % n + v[k - 1]
               :            r1 + k % n;
            begin_mod(k + p) += r1;
            begin_mod(k + q) += r2;
            begin_mod(k) = r2;
        }
        //
        // 步骤 3
        // 从 k = 10 到 k = 19 迭代，用 ^= 修改输出
        //
        // r1 = 1615303485, 3210438310, 893477041, 2884072672, 1918321961,
        // r2 = 1615303485, 3210438309, 893477039, 2884072669, 1918321957
        //
        // seeds = { 303093272, 3210438309,  893477039, 2884072669, 1918321957,
        //          1117182731, 1772877958, 2669970405, 3182737656, 4094066935}
        //
        // r1 =  423054846, 46783064, 3904109085, 1534123446, 1495905687
        // r2 =  423054841, 46783058, 3904109078, 1534123438, 1495905678
        //
        // seeds = { 4204997637, 4246533866, 1856049002, 1129615051, 690460811,
        //           1075771511,   46783058, 3904109078, 1534123438, 1495905678}
        //
        for (std::uint32_t k = m, r3, r4; k &lt; m + n; ++k)
        {
            r3 = 1566083941 * T(begin_mod(k) + begin_mod(k + p) + begin_mod(k - 1));
            r4 = r3 - k % n;
            begin_mod(k+p) ^= r3;
            begin_mod(k+q) ^= r4;
            begin_mod(k) = r4;
        }
    }
};

int main()
{
    const auto input = std::initializer_list&lt;std::uint32_t&gt;{1, 2, 3, 4, 5};
    const auto output_size = 10;
    
    // 使用 std 版本的 seed_seq
    std::seed_seq seq(input);
    std::vector&lt;std::uint32_t&gt; seeds(output_size);
    seq.generate(seeds.begin(), seeds.end());
    for (const std::uint32_t n : seeds)
        std::cout &lt;&lt; n &lt;&lt; '\n';
    
    // 使用自定义版本的 seed_seq
    seed_seq seq2(input);
    std::vector&lt;std::uint32_t&gt; seeds2(output_size);
    seq2.generate(seeds2.begin(), seeds2.end());
    
    assert(seeds == seeds2);
}
|output=
4204997637
4246533866
1856049002
1129615051
690460811
1075771511
46783058
3904109078
1534123438
1495905678 
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2180|std=C++11|before={{tt|seed_seq::generate}} 不会抛出异常|after=它可以抛出异常}}
{{dr list end}}

{{langlinks|cs|de|en|es|fr|it|ja|ko|pl|pt|ru}}