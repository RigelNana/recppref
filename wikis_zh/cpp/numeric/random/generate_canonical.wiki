{{cpp/title|generate_canonical}}
{{cpp/numeric/random/navbar}}
{{ddcl|header=random|since=c++11|
template&lt; class RealType, std::size_t Bits, class Generator &gt;
RealType generate_canonical( Generator&amp; g );
}}

生成范围 {{range|0|1}} 中的随机浮点数。

为生成足够的熵，{{c|generate_canonical()}} 将准确调用 {{c|g()}} {{mathjax-or|\(\small k\)|k}} 次，其中 {{mathjax-or|1= \(\small k = \max(1, \lceil \frac{b}{\log_2 R} \rceil)\) |2=k = max(1, ⌈ b / log{{su|b=2}} R ⌉)}} 且

* {{c|1=b = std::min(Bits, std::size_t {std::numeric_limits&lt;RealType&gt;::digits})}}，
* {{c|1=R = g.max() - g.min() + 1}}。

===参数===
{{par begin}}
{{par|g|用于取得熵的生成器}}
{{par end}}

===返回值===
范围 {{range|0|1}} 中的浮点数。

===异常===
无，除了 {{c|g}} 所抛者。

===注解===
一些既存实现拥有漏洞，若 {{tt|RealType}} 为 {{c/core|float}}，则它们有时可以返回 {{c|1.0}} [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63176 GCC #63176] [https://bugs.llvm.org/show_bug.cgi?id=18767 LLVM #18767] [https://github.com/microsoft/STL/issues/1074 MSVC STL #1074]。此为 {{lwg|2524}}。&lt;!--  
http://stackoverflow.com/questions/25668600/is-1-0-a-valid-random-number --&gt;

===示例===
{{example
|产生有 10 位随机性的随机数：这仅可能产生 {{c|k * R}} 个相异值
|code=
#include &lt;iostream&gt;
#include &lt;random&gt;

int main()
{
    std::random_device rd;
    std::mt19937 gen(rd());
    for (int n = 0; n &lt; 10; ++n)
        std::cout &lt;&lt; std::generate_canonical&lt;double, 10&gt;(gen) &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|p=true
|output=
0.208143 0.824147 0.0278604 0.343183 0.0173263 0.864057 0.647037 0.539467 0.0583497 0.609219 
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/random/dsc uniform_real_distribution}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}