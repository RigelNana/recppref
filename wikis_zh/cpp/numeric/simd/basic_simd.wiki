{{cpp/title|{{petty|datapar::}}basic_simd|{{petty|datapar::}}simd}}
{{cpp/numeric/simd/basic_simd/navbar}}
{{dcl begin}}
{{dcl header|simd}}
{{dcl|num=1|since=c++26|1=
template&lt; class T, class Abi = /*native-abi*/&lt;T&gt; &gt;
class basic_simd;
}}
{{dcl|num=2|since=c++26|1=
template&lt; class T, /*simd-size-type*/ N = /*simd-size-v*/&lt;T, /*native-abi*/&lt;T&gt;&gt; &gt;
using simd = basic_simd&lt;T, /*deduce-abi-t*/&lt;T, N&gt;&gt;;
}}
{{dcl end}}

@1@ {{tt|std::datapar::basic_simd}} 的特化是数据并行类型。默认的 ABI 标签由实现在编译时决定。
@2@ {{tt|std::datapar::simd}} 是允许用户指定某个特定大小的宽度的别名模板。默认宽度由实现在编译时决定。

{{tt|basic_simd}} 的特化都是完整类型。
* 如果 {{tt|T}} 是{{rlp|/#可向量化类型|可向量化类型}}，并且范围 {{closed range|1|64}} 中存在某个值 {{tt|M}} 使得 {{tt|Abi}} 为 {{box/core|{{lti|cpp/numeric/simd#deduce-abi-t|deduce-abi-t}}{{c/core|&lt;T, M&gt;}}}}，那么此特化被''启用''，
* 否则，如果 {{tt|T}} 不是可向量化类型，那么此特化被''禁用''，
* 否则，这种特化是否被启用由实现定义。

如果 {{c/core|basic_simd&lt;T, Abi&gt;}} 被禁用，那么此特化的默认构造函数、析构函数、复制构造函数和复制赋值都被弃置。此外，仅提供下述的成员类型。

如果 {{c/core|basic_simd&lt;T, Abi&gt;}} 被启用，那么 {{c/core|basic_simd&lt;T, Abi&gt;}} 是{{named req|TriviallyCopyable}}。

===模板形参===
{{par begin}}
{{par|T|元素类型；为可向量化类型}}
{{par|Abi|用于确定宽度和存储的{{rlp|/#ABI 标签|标签类型}}}}
{{par|N|数据并行类型的宽度；元素个数}}
{{par end}}

===成员类型===
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc|{{tt|value_type}}|{{tt|T}}}}
{{dsc|{{tt|mask_type}}|{{c/core|datapar::basic_simd_mask&lt;sizeof(T), Abi&gt;}}}}
{{dsc|{{tt|abi_type}}|{{tt|Abi}}}}
{{dsc end}}

===成员常量===
{{dsc begin}}
{{dsc hitem|名称|说明}}
{{dsc mem sconst|nolink=true|{{dsc small|{{box/core|{{c/core|constexpr std::integral_constant&lt;}}{{lsi|cpp/numeric/simd#simd-size-type}}{{c/core|,}}{{nbspt}}{{lsi|cpp/numeric/simd#simd-size-v}}{{c/core|&lt;T, Abi&gt;&gt;}}}}}} size|{{tt|basic_simd}} 的宽度}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/basic_simd/dsc constructor}}
{{dsc inc|cpp/numeric/simd/basic_simd/dsc operator_at}}
{{dsc inc|cpp/numeric/simd/basic_simd/dsc operator_mem_arith}}
{{dsc inc|cpp/numeric/simd/basic_simd/dsc operator_mem_arith2}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/basic_simd/dsc operator_arith}}
{{dsc inc|cpp/numeric/simd/basic_simd/dsc operator_compound}}
{{dsc inc|cpp/numeric/simd/basic_simd/dsc operator_cmp}}
{{dsc break}}
{{dsc inc|cpp/numeric/simd/basic_simd/dsc simd_select}}
{{dsc end}}

===推导指引===
{{ddcl|since=c++26|1=
template&lt; class R, class... Ts &gt;
basic_simd( R&amp;&amp; r, Ts... ) -&gt; /* 见下文 */;
}}
仅当以下情况下提供推导指引：
* {{tt|R}} 实现 {{lconcept|contiguous_range}} 和 {{lconcept|sized_range}}，且
* {{c|ranges::size(r)}} 是{{lt|cpp/language/constant expression|常量表达式}}。

推导的类型等价于 {{c/core|datapar::simd&lt;ranges::range_value_t&lt;R&gt;, ranges::size(r)&gt;}}。

===注解===
建议各实现支持 {{tt|basic_simd}} 的被启用特化和适当的实现定义类型之间的显式转换。这些适当类型是实现中提供的非标准向量类型。

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/dsc basic_simd_mask}}
{{dsc inc|cpp/numeric/simd/dsc simd_mask}}
{{dsc inc|cpp/numeric/dsc valarray}}
{{dsc end}}

{{langlinks|en}}