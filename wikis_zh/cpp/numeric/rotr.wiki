{{cpp/title|rotr}}
{{cpp/utility/bit/navbar}}
{{ddcl|header=bit|since=c++20|
template&lt; class T &gt;
constexpr T rotr( T x, int s ) noexcept;
}}

计算将 {{c|x}} 右旋转 {{c|s}} 位的结果。此运算被称为右{{enwiki|Circular_shift|循环移位}}。

正式而言，令 {{tt|N}} 为 {{c/core|std::numeric_limits&lt;T&gt;::digits}}，并令 {{c|r}} 为 {{c|s % N}}。
* 若 {{c|r}} 为 {{c|0}}，则返回 {{c|x}}；
* 若 {{c|r}} 为正，则返回 {{c|(x &gt;&gt; r) {{!}} (x &lt;&lt; (N - r))}}；
* 若 {{c|r}} 为负，则返回 {{c|std::rotl(x, -r)}} 。

{{cpp/enable_if| {{tt|T}} 为无符号整数类型（即 {{c/core|unsigned char}}、{{c/core|unsigned short}}、{{c/core|unsigned int}}、{{c/core|unsigned long}}、{{c/core|unsigned long long}} 或扩展无符号整数类型）}}。

===参数===
{{par begin}}
{{par|x|无符号整数类型的值}}
{{par|s|移位的位数}}
{{par end}}

===返回值===
将 {{c|x}} 右旋转 {{c|s}} 位的结果。

===注解===
{{feature test macro|__cpp_lib_bitops|std=C++20|value=201907L|[[cpp/utility/bit|位运算]]}}

===示例===
{{example
|code=
#include &lt;bit&gt;
#include &lt;bitset&gt;
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main()
{
    using bin = std::bitset&lt;8&gt;;
    const std::uint8_t x{0b00011101};
    std::cout &lt;&lt; bin(x) &lt;&lt; " &lt;- x\n";
    for (const int s : {0, 1, 9, -1, 2})
        std::cout &lt;&lt; bin(std::rotr(x, s)) &lt;&lt; " &lt;- rotr(x, " &lt;&lt; s &lt;&lt; ")\n";
}
|output=
00011101 &lt;- x
00011101 &lt;- rotr(x, 0)
10001110 &lt;- rotr(x, 1)
10001110 &lt;- rotr(x, 9)
00111010 &lt;- rotr(x, -1)
01000111 &lt;- rotr(x, 2)
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/dsc rotl}}
{{dsc inc|cpp/utility/bitset/dsc operator_ltltgtgt}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}