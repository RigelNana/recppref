{{cpp/title|saturate_cast}}
{{cpp/numeric/sat_math/navbar}}
{{ddcl|header=numeric|since=c++26|
template&lt; class T, class U &gt;
constexpr T saturate_cast( U x ) noexcept;
}}

将值 {{c|x}} 转换为 {{tt|T}} 类型的值，并使得 {{c|x}} 夹在 {{tt|T}} 类型的最小值和最大值之间。

如果 {{tt|T}} 或者 {{tt|U}} 不是有符号或者无符号[[cpp/language/types#整数类型|整数类型]]（包括[[cpp/language/types#标准整数类型|标准整数类型]]和[[cpp/language/types#扩展整数类型|扩展整数类型]]），则结果未定义。

===参数===
{{par begin}}
{{par|x|整数}}
{{par end}}

===返回值===
* {{c|x}}，如果 {{c|x}} 表示 {{tt|T}} 类型的值。否则，
* {{tt|T}} 类型的最接近 {{c|x}} 的最大值或者最小值。

===注解===
{{feature test macro|__cpp_lib_saturation_arithmetic|饱和算术|value=202311L|std=C++26}}

===可能的实现===
参考 [https://github.com/gcc-mirror/gcc/blob/07fe07935ddb9228b4426dbfdb62d4a7e7337efe/libstdc%2B%2B-v3/include/bits/sat_arith.h#L106 libstdc++ (GCC)]&lt;!--, [ libc++ (Clang)], and [ MSVC STL]--&gt;。

===示例===
{{example
|可以在 [https://godbolt.org/z/5P149Y377 Compiler Explorer] 上预览。
|code=
#include &lt;cstdint&gt;
#include &lt;limits&gt;
#include &lt;numeric&gt;

int main()
{
    constexpr std::int16_t x1{696};

    constexpr std::int8_t x2 = std::saturate_cast&lt;std::int8_t&gt;(x1);
    static_assert(x2 == std::numeric_limits&lt;std::int8_t&gt;::max());

    constexpr std::uint8_t x3 = std::saturate_cast&lt;std::uint8_t&gt;(x1);
    static_assert(x3 == std::numeric_limits&lt;std::uint8_t&gt;::max());

    constexpr std::int16_t y1{-696};

    constexpr std::int8_t y2 = std::saturate_cast&lt;std::int8_t&gt;(y1);
    static_assert(y2 == std::numeric_limits&lt;std::int8_t&gt;::min());

    constexpr std::uint8_t y3 = std::saturate_cast&lt;std::uint8_t&gt;(y1);
    static_assert(y3 == 0);
}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/dsc bit_cast}}
{{dsc inc|cpp/algorithm/dsc clamp}}
{{dsc inc|cpp/utility/dsc in_range}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}