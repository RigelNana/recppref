{{cpp/title|lerp}}
{{cpp/numeric/navbar}}
{{dcl begin}}
{{dcl header|cmath}}
{{dcl rev multi|num=1|since1=c++20|dcl1=
constexpr float       lerp( float a, float b, float t ) noexcept;
constexpr double      lerp( double a, double b, double t ) noexcept;
constexpr long double lerp( long double a, long double b,
                            long double t ) noexcept;
|since2=c++23|dcl2=
constexpr /* floating-point-type */
    lerp( /* floating-point-type */ a,
          /* floating-point-type */ b,
          /* floating-point-type */ t ) noexcept;
}}
{{dcl h|[[#注解|额外重载]]}}
{{dcl header|cmath}}
{{dcl|num=A|since=c++20|
template&lt; class Arithmetic1, class Arithmetic2, class Arithmetic3 &gt;
constexpr /* common-floating-point-type */
    lerp( Arithmetic1 a, Arithmetic2 b, Arithmetic3 t ) noexcept;
}}
{{dcl end}}

@1@ 如果形参 {{c|t}} 在 {{range|0|1}} 之内，则计算 {{c|a}} 与 {{c|b}} 间参的{{enwiki|Linear interpolation|线性内插}}（否则是{{enwiki|Extrapolation#Linear|线性外插}}），即其结果为 {{mathjax-or|\(a+t(b−a)\)|a+t(b−a)}}（计入浮点数运算的不精确性）。{{rev inl|since=c++23|标准库提供所有以无 cv 限定的浮点数类型作为参数 {{c|a}}，{{c|b}} 和 {{c|t}} 的类型的重载。}}
@A@ 为算术类型的所有其他组合提供额外重载。

===参数===
{{par begin}}
{{par|a, b, t|浮点数或整数}}
{{par end}}

===返回值===
{{mathjax-or|\(a + t(b − a)\)|a + t(b − a)}}

当 {{c|std::isfinite(a) &amp;&amp; std::isfinite(b)}} 是 {{c|true}} 时，保证下列属性：
* 如果 {{c|1=t == 0}}，那么结果等于 {{c|a}}。
* 如果 {{c|1=t == 1}}，那么结果等于 {{c|b}}。
* 如果 {{c|1=t &gt;= 0 &amp;&amp; t &lt;= 1}}，那么结果有限。
* 如果 {{c|1=isfinite(t) &amp;&amp; a == b}}，那么结果等于 {{c|a}}。
* 如果 {{c|1=isfinite(t) {{!!}} (b - a != 0 &amp;&amp; std::isinf(t))}}，那么结果非 {{ltt|cpp/numeric/math/NAN|NaN}}。

令 {{c|CMP(x, y)}} 在 {{c|x &gt; y}} 时是 {{c|1}}，在 {{c|x &lt; y}} 时是 {{c|-1}}，否则是 {{c|0}}。对于任意 {{c|t1}} 与 {{c|t2}}，以下三者的积非负（即 {{tt|std::lerp}} 单调）：
* {{c|CMP(std::lerp(a, b, t2), std::lerp(a, b, t1))}}
* {{c|CMP(t2, t1)}}
* {{c|CMP(b, a)}}

===注解===
{{cpp/numeric/math/additional overload note|lerp}}

{{feature_test_macro|__cpp_lib_interpolate|value=201902L|std=C++20|{{tt|std::lerp}}, {{lc|std::midpoint}}}}

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;

float naive_lerp(float a, float b, float t)
{
    return a + t * (b - a);
}

int main()
{
    std::cout &lt;&lt; std::boolalpha;
    
    const float a = 1e8f, b = 1.0f;
    const float midpoint = std::lerp(a, b, 0.5f);
    
    std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; "，" &lt;&lt; "b = " &lt;&lt; b &lt;&lt; '\n'
              &lt;&lt; "中点 = " &lt;&lt; midpoint &lt;&lt; '\n';
    
    std::cout &lt;&lt; "std::lerp 是否精确？："
              &lt;&lt; (a == std::lerp(a, b, 0.0f)) &lt;&lt; ' '
              &lt;&lt; (b == std::lerp(a, b, 1.0f)) &lt;&lt; '\n';
    
    std::cout &lt;&lt; "naive_lerp 是否精确？："
              &lt;&lt; (a == naive_lerp(a, b, 0.0f)) &lt;&lt; ' '
              &lt;&lt; (b == naive_lerp(a, b, 1.0f)) &lt;&lt; '\n';
    
    std::cout &lt;&lt; "std::lerp(a, b, 1.0f) = " &lt;&lt; std::lerp(a, b, 1.0f) &lt;&lt; '\n'
              &lt;&lt; "naive_lerp(a, b, 1.0f) = " &lt;&lt; naive_lerp(a, b, 1.0f) &lt;&lt; '\n';
    
    assert(not std::isnan(std::lerp(a, b, INFINITY))); // 这里的 lerp 可以是 -inf
    
    std::cout &lt;&lt; "演示外插，给定 std::lerp(5, 10, t)：\n";
    for (auto t{-2.0}; t &lt;= 2.0; t += 0.5)
        std::cout &lt;&lt; std::lerp(5.0, 10.0, t) &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
a = 1e+08，b = 1
中点 = 5e+07
std::lerp 是否精确？：true true
naive_lerp 是否精确？：true false
std::lerp(a, b, 1.0f) = 1
naive_lerp(a, b, 1.0f) = 0
演示外插，给定 std::lerp(5, 10, t)：
-5 -2.5 0 2.5 5 7.5 10 12.5 15
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/dsc midpoint}}
{{dsc end}}

{{langlinks|en|es|ja}}