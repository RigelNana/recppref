{{title|数据并行类型 (SIMD) {{mark since c++26}}}}
{{cpp/numeric/simd/navbar}}

这个库提供数据并行类型和对这些类型的操作：它们是一组可移植的类型，用于明确指定数据并行性，并于数据并行执行资源可用时在其中组织数据，这种资源包括 {{enwiki|Single instruction, multiple data|SIMD}} 寄存器和指令，或由某个公共指令解码器驱动的执行单元。

{{anchor|可向量化类型}}
''可向量化类型'' 集合包括：
* 所有的标准整数和字符类型；
* 大多数浮点数类型，包括 {{c/core|float}}、{{c/core|double}} 以及选定的扩展浮点数类型：{{c/core|std::float16_t}}、{{c/core|std::float32_t}} 和 {{c/core|std::float64_t}}（若有所定义）；以及
* {{c/core|std::complex&lt;T&gt;}} 其中 {{tt|T}} 为可向量化的浮点数类型。

''数据并行类型''{{sep}}由一个或多个底层的可向量化类型元素组成，这成为其{{i|元素类型}}。元素的个数，称为其{{i|宽度}}，对于每个数据并行类型来说是常量。

数据并行类型指代类模板 {{tt|basic_simd}} 和 {{tt|basic_simd_mask}} 的所有启用的特化。

数据并行类型的''数据并行对象''{{sep}}的表现模仿 {{tt|T}} 类型的对象。但 {{tt|T}} 是存储并操作单个值，而元素类型为 {{tt|T}} 的数据并行类型则存储并操作多个值。

数据并行对象上的每种运算（除了如归约这样的横向运算，它们都是标明的），都表现为运用于对象的每个元素上或者两个对象的对应元素上的''逐元素''操作。每次这种运用之间都是无顺序的。这条简单规则表现了数据并行性，并由编译器所运用以生成 SIMD 指令和/或独立执行流。

数据并行类型上，（除了非 {{c/core|constexpr}} 数学函数重载）的所有运算都是 {{c/core|constexpr}} 的：在常量表达式的求值中创建并使用数据并行对象是有可能的。

别名模板 {{tt|simd}} 和 {{tt|simd_mask}} 的定义允许用户指定其具有特定大小的宽度。默认的宽度有实现在编译时确定。

{{dsc begin}}
{{dsc header|simd}}
{{dsc namespace|std::datapar}}
{{dsc end}}

===主类===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/dsc basic_simd}}
{{dsc inc|cpp/numeric/simd/dsc simd}}
{{dsc inc|cpp/numeric/simd/dsc basic_simd_mask}}
{{dsc inc|cpp/numeric/simd/dsc simd_mask}}
{{dsc end}}

===加载与存储标志===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/dsc flags}}
{{dsc inc|cpp/numeric/simd/dsc flag_default}}
{{dsc inc|cpp/numeric/simd/dsc flag_convert}}
{{dsc inc|cpp/numeric/simd/dsc flag_aligned}}
{{dsc inc|cpp/numeric/simd/dsc flag_overaligned}}
{{dsc end}}

===加载与存储操作===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/dsc load}}
{{dsc inc|cpp/numeric/simd/dsc store}}
{{dsc end}}

===转换===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/dsc chunk}}
{{dsc inc|cpp/numeric/simd/dsc cat}}
{{dsc end}}

===算法===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/dsc min_max}}
{{dsc inc|cpp/numeric/simd/dsc clamp}}
{{dsc inc|cpp/numeric/simd/dsc select}}
{{dsc end}}

===归约===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/dsc reduce}}
{{dsc inc|cpp/numeric/simd/dsc all_any_none_of}}
{{dsc inc|cpp/numeric/simd/dsc reduce_count}}
{{dsc inc|cpp/numeric/simd/dsc reduce_min_max_index}}
{{dsc end}}

===特征===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/dsc alignment}}
{{dsc inc|cpp/numeric/simd/dsc rebind}}
{{dsc inc|cpp/numeric/simd/dsc resize}}
{{dsc end}}

===数学函数===
{{header|cmath}} 和 {{header|complex}} 中的所有函数都为 {{tt|basic_simd}} 进行了重载。

{{todo|description}}

===为操纵函数===
{{header|bit}} 中的所有为操纵函数都为 {{tt|basic_simd}} 进行了重载。

{{todo|description}}

===实现细节===
====ABI 标签====
数据并行类型 {{tt|basic_simd}} 和 {{tt|basic_simd_mask}} 都关联一组 {{i|ABI 标签}}。这些标签是用于指定数据并行对象的大小和二进制表示的类型。其设计意图是使大小和二进制表示基于目标架构和编译器选项而变化。ABI 标签和元素类型一同决定其宽度。

ABI 标签保持与机器指令集的选择无关。所选机器指令集限制了可用的 ABI 标签类型。这些 ABI 标签使得用户可以安全地跨越翻译单元边界而传递数据并行类型的对象。
{{todo}}

====仅用于阐释的实体====
{{todo|needs update}}

{{dcl begin}}
{{dcla|num=1|anchor=simd-size-type|expos=yes|1=
using /*simd-size-type*/ = /* 见描述 */;
}}
{{dcla|num=2|anchor=integer-from|expos=yes|1=
template&lt; std::size_t Bytes &gt;
using /*integer-from*/ = /* 见描述 */;
}}
{{dcla|num=3|anchor=simd-size-v|expos=yes|1=
template&lt; class T, class Abi &gt;
constexpr /*simd-size-type*/ /*simd-size-v*/ = /* 见描述 */;
}}
{{dcla|num=4|anchor=mask-element-size|expos=yes|1=
template&lt; class T &gt;
constexpr std::size_t /*mask-element-size*/ = /* 见描述 */;
}}
{{dcla|num=5|anchor=constexpr-wrapper-like|expos=yes|1=
template&lt; class T &gt;
concept /*constexpr-wrapper-like*/ = /* 见描述 */;
}}
{{dcla|num=6|anchor=deduced-simd-t|expos=yes|1=
template&lt; class T &gt;
using /*deduced-simd-t*/ = /* 见描述 */;
}}
{{dcla|num=7|anchor=make-compatible-simd-t|expos=yes|1=
template&lt; class V, class T &gt;
using /*make-compatible-simd-t*/ = /* 见描述 */;
}}
{{dcl end}}
@1@ {{c/core|/*simd-size-type*/}} 是某个有符号整数类型的别名。实现可自由选择任何有符号整数类型。
@2@ {{c/core|/*integer-from*/&lt;Bytes&gt;}} 是某个有符号整数类型 {{tt|T}} 的别名，使得 {{c|sizeof(T)}} 等于 {{c|Bytes}}。
@3@ {{c/core|/*simd-size-v*/&lt;T, Abi&gt;}} 代表被启用的 {{tt|basic_simd&lt;T, Abi&gt;}} 特化的宽度，否则为 {{c|0}}。
@4@ 如果 {{tt|T}} 代表 {{c/core|std::datapar::basic_simd_mask&lt;Bytes, Abi&gt;}}，那么 {{c/core|/*mask-element-size*/&lt;T&gt;}} 等于 {{c|Bytes}}。
@5@ 概念 {{c/core|/*constexpr-wrapper-like*/}} 定义为：
{{source|1=
template&lt; class T &gt;
concept /*constexpr-wrapper-like*/ =
    std::convertible_to&lt;T, decltype(T::value)&gt; &amp;&amp;
    std::equality_comparable_with&lt;T, decltype(T::value)&gt; &amp;&amp;
    std::bool_constant&lt;T() {{==}} T::value&gt;::value &amp;&amp;
    std::bool_constant&lt;static_cast&lt;decltype(T::value)&gt;(T()) {{==}} T::value&gt;::value;
}}
@6@ 令 {{c|x}} 为 {{c/core|const T}} 类型的左值。{{c/core|/*deduced-simd-t*/&lt;T&gt;}} 是等价于以下类型的别名：
* {{c/core|decltype(x + x)}}，如果 {{c|x + x}} 的类型是被启用的 {{tt|basic_simd}} 特化；否则为
* {{c/core|void}}。
@7@ 令 {{c|x}} 为 {{c/core|const T}} 类型的左值。{{c/core|/*make-compatible-simd-t*/&lt;V, T&gt;}} 是等价于以下类型的别名：
* {{c/core|/*deduced-simd-t*/&lt;T&gt;}}，如果此类型并非 {{c/core|void}}，否则为
* {{c/core|std::datapar::simd&lt;decltype(x + x), V​::​size()&gt;}}。

{{dcl begin}}
{{dcl h|数学函数要求}}
{{dcla|num=8|anchor=simd-floating-point|expos=yes|1=
template&lt; class V &gt;
concept /*simd-floating-point*/ = /* 见描述 */;
}}
{{dcla|num=9|anchor=math-floating-point|expos=yes|1=
template&lt; class... Ts &gt;
concept /*math-floating-point*/ = /* 见描述 */;
}}
{{dcla|num=10|anchor=math-common-simd-t|expos=yes|1=
template&lt; class... Ts &gt;
  requires /*math-floating-point*/&lt;Ts...&gt;
using /*math-common-simd-t*/ = /* 见描述 */;
}}
{{dcla|num=11|anchor=reduction-binary-operation|expos=yes|1=
template&lt; class BinaryOp, class T &gt;
concept /*reduction-binary-operation*/ = /* 见描述 */;
}}
{{dcl end}}
@8@ The concept {{c/core|/*simd-floating-point*/}} is defined as:
{{source|1=
template&lt; class V &gt;
concept /*simd-floating-point*/ =
    std::same_as&lt;V,
                 std::datapar::basic_simd&lt;typename V::value_type,
                 typename V::abi_type&gt;&gt; &amp;&amp;
    std::is_default_constructible_v&lt;V&gt; &amp;&amp; 
    std::floating_point&lt;typename V::value_type&gt;;
}}
@9@ The concept {{c/core|/*math-floating-point*/}} is defined as:
{{source|1=
template&lt; class... Ts &gt;
concept /*math-floating-point*/ =
    (/*simd-floating-point*/&lt;/*deduced-simd-t*/&lt;Ts&gt;&gt; {{!!}} ...);
}}
@10@ 令 {{tt|T0}} 代表 {{c/core|Ts...[0]}}，{{tt|T1}} 代表 {{c/core|Ts...[1]}}，并令 {{tt|TRest}} 代表使得 {{c/core|T0, T1, TRest...}} 等价于 {{c/core|Ts...}} 的包。从而 {{c/core|/*math-common-simd-t*/&lt;Ts...&gt;}} 是等价于以下类型的别名：
* {{c/core|/*deduced-simd-t*/&lt;T0&gt;}}，如果 {{c|1=sizeof...(Ts) == 1}} 为 {{c|true}}
* 否则为 {{c/core|std::common_type_t&lt;/*deduced-simd-t*/&lt;T0&gt;, /*deduced-simd-t*/&lt;T1&gt;&gt;}}，如果 {{c|1=sizeof...(Ts) == 2}} 为 {{c|true}} 且 {{c|1=/*math-floating-point*/&lt;T0&gt; &amp;&amp; /*math-floating-point*/&lt;T1&gt;}} 为 {{c|true}}，
* 否则为 {{c/core|std::common_type_t&lt;/*deduced-simd-t*/&lt;T0&gt;, T1&gt;}}，如果 {{c|1=sizeof...(Ts) == 2}} 为 {{c|true}} 且 {{c|1=/*math-floating-point*/&lt;T0&gt;}} 为 {{c|true}}，
* 否则为 {{c/core|std::common_type_t&lt;T0, /*deduced-simd-t*/&lt;T1&gt;&gt;}}，如果 {{c|1=sizeof...(Ts) == 2}} 为 {{c|true}}，
* 否则为 {{c/core|std::common_type_t&lt;/*math-common-simd-t*/&lt;T0, T1&gt;, TRest...&gt;}}，如果 {{c/core|/*math-common-simd-t*/&lt;T0, T1&gt;}} 是有效类型，
* 否则为 {{c/core|std::common_type_t&lt;/*math-common-simd-t*/&lt;TRest...&gt;, T0, T1&gt;}}。

@11@ 概念 {{c/core|/*reduction-binary-operation*/}} 定义为：
{{source|1=
template&lt; class BinaryOp, class T &gt;
concept /*reduction-binary-operation*/ =
    requires (const BinaryOp binary_op, const std::datapar::simd&lt;T, 1&gt; v) {
        { binary_op(v, v) } -&gt; std::same_as&lt;std::datapar::simd&lt;T, 1&gt;&gt;;
    };
}}
仅当以下情况下，{{c/core|/*reduction-binary-operation*/&lt;BinaryOp, T&gt;}} 被实现：
:* {{tt|BinaryOp}} 是具有交换性的二元逐元素运算，并且
:* {{tt|BinaryOp}} 类型的对象，对于某个未指明的 ABI 标签 {{tt|Abi}}，可以以两个 {{c/core|std::datapar::basic_simd&lt;T, Abi&gt;}} 类型的实参调用并返回 {{c/core|std::datapar::basic_simd&lt;T, Abi&gt;}}。

{{dcl begin}}
{{dcl h|SIMD ABI 标签}}
{{dcla|num=12|anchor=native-abi|expos=yes|1=
template&lt; class T &gt;
using /*native-abi*/ = /* 见描述 */;
}}
{{dcla|num=13|anchor=deduce-abi-t|expos=yes|1=
template&lt; class T, /*simd-size-type*/ N &gt;
using /*deduce-abi-t*/ = /* 见描述 */;
}}
{{dcl end}}
@12@ {{c/core|/*native-abi*/&lt;T&gt;}} 是某个 ABI 标签的由实现定义的别名。这是进行高效的显式向量化时首选使用的 ABI 标签。这导致 {{c/core|basic_simd&lt;T, /*native-abi*/&lt;T&gt;&gt;}} 是被启用的特化。
@13@ {{c/core|/*deduce-abi-t*/&lt;T, N&gt;}} 是指名某个 ABI 标签类型的别名，使得：
* {{c/core|/*simd-size-v*/&lt;T, /*deduce-abi-t*/&lt;T, N&gt;&gt;}} 等于 {{c|N}}，
* {{c/core|std::datapar::basic_simd&lt;T, /*deduce-abi-t*/&lt;T, N&gt;&gt;}} 是被启用的特化，并且
* {{c/core|std::datapar::basic_simd_mask&lt;sizeof(T), /*deduce-abi-t*/&lt;/*integer-from*/&lt;sizeof(T)&gt;, N&gt;&gt;}} 是被启用的特化。
仅当 {{tt|T}} 是可向量化类型，且 {{c|1=N &gt; 0 &amp;&amp; N &lt;= M}} 为 {{c|true}} 时才有定义，其中 {{c|M}} 某个由实现定义的最大值，它至少为 {{c|64}} 并可以根据 {{tt|T}} 而有所不同。

{{dcl begin}}
{{dcl h|加载与存储标志}}
{{dcla|num=14|anchor=convert-flag|expos=yes|1=
struct /*convert-flag*/;
}}
{{dcla|num=15|anchor=aligned-flag|expos=yes|1=
struct /*aligned-flag*/;
}}
{{dcla|num=16|anchor=overaligned-flag|expos=yes|1=
template&lt; std::size_t N &gt;
struct /*overaligned-flag*/;
}}
{{dcl end}}
@14-16@ 这些标签类型被用作 {{tt|std::datapar::flags}} 的模板实参。参见{{rl|flags|加载与存储标志}}查看它们的相应用法。

===注解===
{{feature test macro|__cpp_lib_simd|std=C++26|value=202411L|数据并行类型及运算}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;simd&gt;
#include &lt;string_view&gt;

namespace dp = std::datapar;

void println(std::string_view name, auto const&amp; a)
{
    std::cout &lt;&lt; name &lt;&lt; ": ";
    for (std::size_t i{}; i != a.size(); ++i)
        std::cout &lt;&lt; a[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

template&lt;class A&gt;
constexpr dp::basic_simd&lt;int, A&gt; my_abs(dp::basic_simd&lt;int, A&gt; x)
{
    return dp::select(x &lt; 0, -x, x);
}

int main()
{
    constexpr dp::simd&lt;int&gt; a = 1;
    println("a", a);

    constexpr dp::simd&lt;int&gt; b([](int i) { return i - 2; });
    println("b", b);

    constexpr auto c = a + b;
    println("c", c);

    constexpr auto d = my_abs(c);
    println("d", d);

    constexpr auto e = d * d;
    println("e", e);

    constexpr auto inner_product = dp::reduce(e);
    std::cout &lt;&lt; "内积: " &lt;&lt; inner_product &lt;&lt; '\n';

    constexpr dp::simd&lt;double, 16&gt; x([](int i) { return i; });
    println("x", x);
    // &lt;simd&gt; 中定义了重载的数学函数
    println("cos²(x) + sin²(x)", std::pow(std::cos(x), 2) + std::pow(std::sin(x), 2));
}
|output=
a: 1 1 1 1 
b: -2 -1 0 1 
c: -1 0 1 2 
d: 1 0 1 2 
e: 1 0 1 4 
内积: 6
x: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
cos²(x) + sin²(x): 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/dsc valarray}}
{{dsc end}}

===外部链接===
{{elink begin}}
{{elink|1=[https://github.com/VcDevel/std-simd ISO/IEC TS 19570:2018 第 9 章 "数据并行类型" 的实现] — github.com}}
{{elink|1=TS 实现抵达 [https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=libstdc%2B%2B-v3/include/experimental/simd;hb=HEAD GCC/libstdc++] (GCC-11 提供 {{tt|std::experimental::simd}}) — gcc.gnu.org}}
{{elink end}}

{{langlinks|en|es|ja|ru}}