{{cpp/title|acosh{{small|(std::complex)}}}}
{{cpp/numeric/complex/navbar}}
{{ddcl|header=complex|since=c++11|1=
template&lt; class T &gt; 
complex&lt;T&gt; acosh( const complex&lt;T&gt;&amp; z );
}}

计算复数值 {{c|z}} 的复反双曲余弦，分支切割在沿实轴小于 1 的值上。

===参数===
{{par begin}}
{{par|z|复数值}}
{{par end}}

===返回值===
若不出现错误，则返回 {{c|z}} 的复反双曲余弦，值域为沿实轴的非负数和沿虚轴的区间 {{math|[−iπ; +iπ]}} 的半条带。

===错误处理及特殊值===
报告的错误与 {{lc|math_errhandling}} 一致。

若实现支持 IEEE 浮点算术，则
* {{c|std::acosh(std::conj(z)) {{==}} std::conj(std::acosh(z))}}
* 若 {{c|z}} 为 {{tt|(±0,+0)}}，则结果为 {{tt|(+0,π/2)}}
* 若 {{c|z}} 为 {{tt|(x,+∞)}}（对于任何有限 x），则结果为 {{tt|(+∞,π/2)}}
* 若 {{c|z}} 为 {{tt|(x,NaN)}}（对于任何&lt;ref&gt;由 [http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1892.htm#dr_471 C11 DR471]，这只对非零 x 成立。若 {{tt|z}} 为 {{tt|(0,NaN)}}，则结果应为 {{tt|(NaN,π/2)}}&lt;/ref&gt;有限 x），则结果为 {{tt|(NaN,NaN)}} 并可能引发 {{lc|FE_INVALID}}。
* 若 {{c|z}} 为 {{tt|(-∞,y)}}（对于任何有限正 y），则结果为 {{tt|(+∞,π)}}
* 若 {{c|z}} 为 {{tt|(+∞,y)}}（对于任何有限正 y），则结果为 {{tt|(+∞,+0)}}
* 若 {{c|z}} 为 {{tt|(-∞,+∞)}}，则结果为 {{tt|(+∞,3π/4)}}
* 若 {{c|z}} 为 {{tt|(±∞,NaN)}}，则结果为 {{tt|(+∞,NaN)}}
* 若 {{c|z}} 为 {{tt|(NaN,y)}}（对于任何有限 y），则结果为 {{tt|(NaN,NaN)}} 并可能引发 {{lc|FE_INVALID}}。
* 若 {{c|z}} 为 {{tt|(NaN,+∞)}}，则结果为 {{tt|(+∞,NaN)}}
* 若 {{c|z}} 为 {{tt|(NaN,NaN)}}，则结果为 {{tt|(NaN,NaN)}}
&lt;references/&gt;

===注解===
尽管 C++ 标准命名此函数为“复弧双曲余弦”，双曲函数的反函数是面积函数。其实参为双曲扇形的面积，而非弧长。正确名称是“复反双曲余弦”，和更少见的“复面积双曲余弦”。

反双曲余弦是多值函数，在复平面上要求分支切割。约定将分支切割置于实轴的线段 {{math|(-∞,+1)}} 上。

复反双曲余弦主值的数学定义是 {{math|acosh z {{=}} ln(z + {{mrad|z+1}} {{mrad|z-1}})}}。

对于任何 {{c|z}}，{{math|acosh(z) {{=}} {{mfrac|{{mrad|z-1}}|{{mrad|1-z}}}} acos(z) }}，或在复平面上半部简单地为 {{math|i acos(z)}}。

===示例===
{{example
|code=
#include &lt;complex&gt;
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; std::fixed;
    std::complex&lt;double&gt; z1(0.5, 0);
    std::cout &lt;&lt; "acosh" &lt;&lt; z1 &lt;&lt; " = " &lt;&lt; std::acosh(z1) &lt;&lt; '\n';

    std::complex&lt;double&gt; z2(0.5, -0.0);
    std::cout &lt;&lt; "acosh" &lt;&lt; z2 &lt;&lt; " (the other side of the cut) = "
              &lt;&lt; std::acosh(z2) &lt;&lt; '\n';

    // 在上半平面，acosh = i acos 
    std::complex&lt;double&gt; z3(1, 1), i(0, 1);
    std::cout &lt;&lt; "acosh" &lt;&lt; z3 &lt;&lt; " = " &lt;&lt; std::acosh(z3) &lt;&lt; '\n'
              &lt;&lt; "i*acos" &lt;&lt; z3 &lt;&lt; " = " &lt;&lt; i*std::acos(z3) &lt;&lt; '\n';
}
|output=
acosh(0.500000,0.000000) = (0.000000,-1.047198)
acosh(0.500000,-0.000000) (the other side of the cut) = (0.000000,1.047198)
acosh(1.000000,1.000000) = (1.061275,0.904557)
i*acos(1.000000,1.000000) = (1.061275,0.904557)
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/complex/dsc acos}}
{{dsc inc|cpp/numeric/complex/dsc asinh}}
{{dsc inc|cpp/numeric/complex/dsc atanh}}
{{dsc inc|cpp/numeric/complex/dsc cosh}}
{{dsc inc|cpp/numeric/math/dsc acosh}}
{{dsc see c|c/numeric/complex/cacosh}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}