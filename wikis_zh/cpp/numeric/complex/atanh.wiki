{{cpp/title|atanh{{small|(std::complex)}}}}
{{cpp/numeric/complex/navbar}}
{{ddcl|header=complex|since=c++11|1=
template&lt; class T &gt; 
complex&lt;T&gt; atanh( const complex&lt;T&gt;&amp; z );
}}

计算 {{c|z}} 的复反双曲正切，其分支切割为沿实轴的 {{math|[−1; +1]}} 区间外部。

===参数===
{{par begin}}
{{par|z|复数值}}
{{par end}}

===返回值===
若不发生错误，则返回 {{c|z}} 的复反双曲正切，值域为在数学上沿实轴无界，沿虚轴为区间 {{math|[−iπ/2; +iπ/2]}} 的半条带。

===错误处理及特殊值===
报告的错误与 {{lc|math_errhandling}} 一致。

若实现支持 IEEE 浮点算术，则
* {{c|std::atanh(std::conj(z)) {{==}} std::conj(std::atanh(z))}}
* {{c|std::atanh(-z) {{==}} -std::atanh(z)}}
* 若 {{c|z}} 为 {{tt|(+0,+0)}}，则结果为 {{tt|(+0,+0)}}
* 若 {{c|z}} 为 {{tt|(+0,NaN)}}，则结果为 {{tt|(+0,NaN)}}
* 若 {{c|z}} 为 {{tt|(+1,+0)}}，则结果为 {{tt|(+∞,+0)}} 并引发 {{lc|FE_DIVBYZERO}}
* 若 {{c|z}} 为 {{tt|(x,+∞)}}（对于任何有限正 x），则结果为 {{tt|(+0,π/2)}}
* 若 {{c|z}} 为 {{tt|(x,NaN)}}（对于任何有限非零 x），则结果为 {{tt|(NaN,NaN)}} 并可能引发 {{lc|FE_INVALID}}
* 若 {{c|z}} 为 {{tt|(+∞,y)}}（对于任何有限正 y），结果为 {{tt|(+0,π/2)}}
* 若 {{c|z}} 为 {{tt|(+∞,+∞)}}，则结果为 {{tt|(+0,π/2)}}
* 若 {{c|z}} 为 {{tt|(+∞,NaN)}}，则结果为 {{tt|(+0,NaN)}}
* 若 {{c|z}} 为 {{tt|(NaN,y)}}（对于任何有限的 y），则结果为 {{tt|(NaN,NaN)}} 并可能引发 {{lc|FE_INVALID}}
* 若 {{c|z}} 为 {{tt|(NaN,+∞)}}，则结果为 {{tt|(±0,π/2)}}（实部的符号未指定）
* 若 {{c|z}} 为 {{tt|(NaN,NaN)}}，则结果为 {{tt|(NaN,NaN)}}

===注解===
尽管 C++ 标准命名此函数为“复弧双曲正切”，双曲函数的反函数却是面积函数。其参数是双曲扇形的面积，而非弧长。正确的名称是“复反双曲正切”，和较少见的“复面积双曲正切”。

反双曲正切是多值函数，并要求复平面上的分支切割。我们约定将分支切割置于实轴的划分线 {{math|(-∞,-1]}} 和 {{math|[+1,+∞)}}。

反双曲正切的主值的数学定义是 {{math|1=atanh z = {{mfrac|ln(1+z) - ln(z-1)|2}}}}。&lt;br&gt;

对于任何 {{c|z}}，{{math|1=atanh(z) = {{mfrac|atan(iz)|i}}}}。

===示例===
{{example|
|code=
#include &lt;complex&gt;
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; std::fixed;
    std::complex&lt;double&gt; z1(2.0, 0.0);
    std::cout &lt;&lt; "atanh" &lt;&lt; z1 &lt;&lt; " = " &lt;&lt; std::atanh(z1) &lt;&lt; '\n';

    std::complex&lt;double&gt; z2(2.0, -0.0);
    std::cout &lt;&lt; "atanh" &lt;&lt; z2 &lt;&lt; " (the other side of the cut) = "
              &lt;&lt; std::atanh(z2) &lt;&lt; '\n';

    // for any z, atanh(z) = atanh(iz) / i
    std::complex&lt;double&gt; z3(1.0, 2.0);
    std::complex&lt;double&gt; i(0.0, 1.0);
    std::cout &lt;&lt; "atanh" &lt;&lt; z3 &lt;&lt; " = " &lt;&lt; std::atanh(z3) &lt;&lt; '\n'
              &lt;&lt; "atan" &lt;&lt; z3 * i &lt;&lt; " / i = " &lt;&lt; std::atan(z3 * i) / i &lt;&lt; '\n';
}
|output=
atanh(2.000000,0.000000) = (0.549306,1.570796)
atanh(2.000000,-0.000000) (the other side of the cut) = (0.549306,-1.570796)
atanh(1.000000,2.000000) = (0.173287,1.178097)
atan(-2.000000,1.000000) / i = (0.173287,1.178097)
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/complex/dsc asinh}}
{{dsc inc|cpp/numeric/complex/dsc acosh}}
{{dsc inc|cpp/numeric/complex/dsc tanh}}
{{dsc inc|cpp/numeric/math/dsc atanh}}
{{dsc see c|c/numeric/complex/catanh}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}