{{cpp/title|pow{{petty|(std::complex)}}}}
{{cpp/numeric/complex/navbar}}
{{dcl begin}}
{{dcl header|complex}}
{{dcl|num=1|until=c++11|1=
template&lt; class T &gt;
std::complex&lt;T&gt; pow( const std::complex&lt;T&gt;&amp; x, int y );
}}
{{dcl|num=2|1=
template&lt; class T &gt;
std::complex&lt;T&gt; pow( const std::complex&lt;T&gt;&amp; x, const std::complex&lt;T&gt;&amp; y );
}}
{{dcl|num=3|1=
template&lt; class T &gt;
std::complex&lt;T&gt; pow( const std::complex&lt;T&gt;&amp; x, const T&amp; y );
}}
{{dcl|num=4|1=
template&lt; class T &gt;
std::complex&lt;T&gt; pow( const T&amp; x, const std::complex&lt;T&gt;&amp; y );
}}
{{dcl h|[[#注解|额外重载]] {{mark since c++11}}}}
{{dcl header|complex}}
{{dcl rev multi|num=A|dcl1=
template&lt; class T1, class T2 &gt;
std::complex&lt;/* common-type */&gt;
    pow( const std::complex&lt;T1&gt;&amp; x, const std::complex&lt;T2&gt;&amp; y );
|since2=c++23|dcl2=
template&lt; class T1, class T2 &gt;
std::complex&lt;std::common_type_t&lt;T1, T2&gt;&gt;
    pow( const std::complex&lt;T1&gt;&amp; x, const std::complex&lt;T2&gt;&amp; y );
}}
{{dcl rev multi|num=B|dcl1=
template&lt; class T, class NonComplex &gt;
std::complex&lt;/* common-type */&gt;
    pow( const std::complex&lt;T&gt;&amp; x, const NonComplex&amp; y );
|since2=c++23|dcl2=
template&lt; class T, class NonComplex &gt;
std::complex&lt;std::common_type_t&lt;T, NonComplex&gt;&gt;
    pow( const std::complex&lt;T&gt;&amp; x, const NonComplex&amp; y );
}}
{{dcl rev multi|num=C|dcl1=
template&lt; class T, class NonComplex &gt;
std::complex&lt;/* common-type */&gt;
    pow( const NonComplex&amp; x, const std::complex&lt;T&gt;&amp; y );
|since2=c++23|dcl2=
template&lt; class T, class NonComplex &gt;
std::complex&lt;std::common_type_t&lt;T, NonComplex&gt;&gt;
    pow( const NonComplex&amp; x, const std::complex&lt;T&gt;&amp; y );
}}
{{dcl end}}

@1-4@ 计算复数 {{c|x}} 的 {{c|y}} 次复数幂，第一实参的分支切割线沿负实轴。非复数实参被当作拥有正零虚部的复数。

{{rrev|since=c++11|
@A-C@ 提供额外重载。其中 {{tt|NonComplex}} 不是 {{lc|std::complex}} 的特化。
}}

===参数===
{{par begin}}
{{par|x|底数}}
{{par|y|指数}}
{{par end}}

===返回值===
@1-4@ 如果不出现错误，那么返回复幂 {{math|x{{su|p=y}}}}。
@@ 错误和特殊情况按照如同以 {{c|std::exp(y * std::log(x))}} 实现运算一般处理。
@@ {{c|std::pow(0, 0)}} 的结果由实现定义。
@A-C@ 同 {{v|2-4}}。

===注解===
C++98 提供重载 {{v|1}} 以匹配 {{lc|std::pow}} 的多个重载 {{v|2}}。那些重载通过 {{lwg|550}} 的解决方案移除，而重载 {{v|1}} 通过 {{lwg|844}} 的解决方案移除。

额外重载不需要以 {{v|A-C}} 的形式提供。它们只需要能够对它们的第一个实参 {{c|base}} 和第二个实参 {{c|exponent}} 满足以下要求：
{{rev begin}}
{{rev|until=c++23|
如果 {{c|base}} 和/或 {{c|exponent}} 具有 {{c/core|std::complex&lt;T&gt;}} 类型：
* 如果 {{c|base}} 和/或 {{c|exponent}} 具有 {{c/core|std::complex&lt;long double&gt;}} 或 {{c/core|long double}} 类型，那么 {{box|{{tt|std::pow(base, exponent)}}}} 和 {{box|{{tt|std::pow}}{{c/core|(std::complex&lt;long double&gt;(base),}}&lt;br&gt;{{c/core|         std::complex&lt;long double&gt;(exponent))}}}} 的效果相同。
* 否则，如果 {{c|base}} 和/或 {{c|exponent}} 具有 {{c/core|std::complex&lt;double&gt;}}，{{c/core|double}} 或整数类型，那么 {{box|{{tt|std::pow(base, exponent)}}}} 和 {{box|{{tt|std::pow}}{{c/core|(std::complex&lt;double&gt;(base),}}&lt;br&gt;{{c/core|         std::complex&lt;double&gt;(exponent))}}}} 的效果相同。
* 否则，如果 {{c|base}} 和/或 {{c|exponent}} 具有 {{c/core|std::complex&lt;float&gt;}} 或 {{c/core|float}} 类型，那么 {{box|{{tt|std::pow(base, exponent)}}}} 和 {{box|{{tt|std::pow}}{{c/core|(std::complex&lt;float&gt;(base),}}&lt;br&gt;{{c/core|         std::complex&lt;float&gt;(exponent))}}}} 的效果相同。
}}
{{rev|since=c++23|
如果一个实参具有 {{c/core|std::complex&lt;T1&gt;}} 类型，而另一个实参具有 {{tt|T2}} 或 {{c/core|std::complex&lt;T2&gt;}} 类型，那么 {{box|{{tt|std::pow(base, exponent)}}}} 和 {{box|{{tt|std::pow}}{{c/core|(std::complex&lt;std::common_type_t&lt;T1, T2&gt;&gt;(base),
         std::complex&lt;std::common_type_t&lt;T1, T2&gt;&gt;(exponent))}}}} 的效果相同。

如果 {{c/core|std::common_type_t&lt;T1, T2&gt;}} 非良构，那么程序也非良构。
}}
{{rev end}}

===示例===
{{example|
|code=
#include &lt;complex&gt;
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; std::fixed;
    
    std::complex&lt;double&gt; z(1.0, 2.0);
    std::cout &lt;&lt; "(1,2)^2 = " &lt;&lt; std::pow(z, 2) &lt;&lt; '\n';
    
    std::complex&lt;double&gt; z2(-1.0, 0.0); // -1 的平方根
    std::cout &lt;&lt; "-1^0.5 = " &lt;&lt; std::pow(z2, 0.5) &lt;&lt; '\n';
    
    std::complex&lt;double&gt; z3(-1.0, -0.0); // 切割的另一侧
    std::cout &lt;&lt; "(-1,-0)^0.5 = " &lt;&lt; std::pow(z3, 0.5) &lt;&lt; '\n';
    
    std::complex&lt;double&gt; i(0.0, 1.0); // i^i = exp(-pi/2)
    std::cout &lt;&lt; "i^i = " &lt;&lt; std::pow(i, i) &lt;&lt; '\n';
}
|output=
(1,2)^2 = (-3.000000,4.000000)
-1^0.5 = (0.000000,1.000000)
(-1,-0)^0.5 = (0.000000,-1.000000)
i^i = (0.207880,0.000000)
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/complex/dsc sqrt}}
{{dsc inc|cpp/numeric/math/dsc pow}}
{{dsc inc|cpp/numeric/valarray/dsc pow}}
{{dsc see c|c/numeric/complex/cpow}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}