{{cpp/title|get{{petty|(std::complex)}}}}
{{cpp/numeric/complex/navbar}}
{{dcl begin}}
{{dcl header|complex}}
{{dcl|num=1|since=c++26|
template&lt; std::size_t I &gt;
friend constexpr T&amp; get( std::complex&lt;T&gt;&amp; x );
}}
{{dcl|num=2|since=c++26|
template&lt; std::size_t I &gt;
friend constexpr const T&amp; get( const std::complex&lt;T&gt;&amp; x );
}}
{{dcl|num=3|since=c++26|
template&lt; std::size_t I &gt;
friend constexpr T&amp;&amp; get( std::complex&lt;T&gt;&amp;&amp; x );
}}
{{dcl|num=4|since=c++26|
template&lt; std::size_t I &gt;
friend constexpr const T&amp;&amp; get( const std::complex&lt;T&gt;&amp;&amp; x );
}}
{{dcl end}}

当 {{c|1=I == 0}} 或 {{c|1=I == 1}} 时分别返回对 {{tt|complex}} 的实部或虚部的引用。主要为支持结构化绑定而提供。

===参数===
{{par begin}}
{{par|x|{{tt|complex}}}}
{{par end}}

===返回值===
@1-4@ 当 {{c|1=I == 0}} 或 {{c|1=I == 1}} 时分别返回对所存储的实部或虚部的引用。

===注解===
{{feature test macro|__cpp_lib_tuple_like|std=C++26|value=202311L|为 {{lc|std::complex}} 添加元组协议}}

===示例===
{{example
|code=
#include &lt;complex&gt;

static_assert([z = std::complex(1.0, 2.0)]
{
#if __cpp_lib_tuple_like &gt;= 202311L
    return std::get&lt;0&gt;(z) == 1.0 and std::get&lt;1&gt;(z) == 2.0;
#else
    return z.real() == 1.0 and z.imag() == 2.0;
#endif
}());

int main() {}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/language/dsc structured binding}}
{{dsc inc|cpp/utility/tuple/dsc get}}
{{dsc inc|cpp/utility/pair/dsc get}}
{{dsc inc|cpp/container/array/dsc get}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}