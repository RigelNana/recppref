{{cpp/title|bit_floor}}
{{cpp/utility/bit/navbar}}
{{ddcl|since=c++20|header=bit|
template&lt; class T &gt;
constexpr T bit_floor( T x ) noexcept;
}}

若 {{c|x}} 非零，则计算不大于 {{c|x}} 的最大的二的整数次幂。若 {{c|x}} 为零，则返回零。

{{cpp/enable_if| {{tt|T}} 为无符号整数类型（即 {{c/core|unsigned char}}、{{c/core|unsigned short}}、{{c/core|unsigned int}}、{{c/core|unsigned long}}、{{c/core|unsigned long long}} 或扩展无符号整数类型）}}。

===参数===
{{par begin}}
{{par|x|无符号整数值}}
{{par end}}

===返回值===
若 {{c|x}} 为零则为零；否则为不大于 {{c|x}} 的最大的二的整数次幂。

===注解===
{{petty|{{stddoc|P1956R1}} 以前，为这个函数模板提出的名字是 {{tt|floor2}}。}}

{{feature test macro|__cpp_lib_int_pow2|std=C++20|value=202002L|[[cpp/utility/bit|{{math|2}} 的整数次幂运算]]}}

===可能的实现===
{{eq fun
|1=
template&lt;typename T, typename ... U&gt;
concept neither = (!std::same_as&lt;T, U&gt; &amp;&amp; ...);

template&lt;std::unsigned_integral T&gt;
    requires neither&lt;T, bool, char, char8_t, char16_t, char32_t, wchar_t&gt;
constexpr T bit_floor(T x) noexcept
{
    if (x != 0)
        return T{1} &lt;&lt; (std::bit_width(x) - 1);
    return 0;
}
}}

===示例===
{{example
|code=
#include &lt;bit&gt;
#include &lt;bitset&gt;
#include &lt;iostream&gt;

int main()
{
    using bin = std::bitset&lt;8&gt;;

    for (unsigned x{}; x != 012; ++x)
        std::cout &lt;&lt; "bit_floor( " &lt;&lt; bin(x) &lt;&lt; " ) = "
                  &lt;&lt; bin(std::bit_floor(x)) &lt;&lt; '\n';
}
|output=
bit_floor( 00000000 ) = 00000000
bit_floor( 00000001 ) = 00000001
bit_floor( 00000010 ) = 00000010
bit_floor( 00000011 ) = 00000010
bit_floor( 00000100 ) = 00000100
bit_floor( 00000101 ) = 00000100
bit_floor( 00000110 ) = 00000100
bit_floor( 00000111 ) = 00000100
bit_floor( 00001000 ) = 00001000
bit_floor( 00001001 ) = 00001000
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/numeric/dsc bit_ceil}}
{{dsc inc|cpp/numeric/dsc rotr}}
{{dsc inc|cpp/numeric/dsc bit_width}}
{{dsc inc|cpp/numeric/dsc has_single_bit}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}