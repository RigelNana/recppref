{{cpp/title|byteswap}}
{{cpp/utility/bit/navbar}}
{{ddcl|since=c++23|header=bit|
template&lt; class T &gt;
constexpr T byteswap( T n ) noexcept;
}}

逆转给定整数 {{c|n}} 中的字节。

{{tt|std::byteswap}} 仅若 {{tt|T}} 满足 {{lconcept|integral}}（即 {{tt|T}} 为整数类型）才参与重载决议。若 {{tt|T}} 拥有填充位则程序非良构。

===参数===
{{par begin}}
{{par|n|整数}}
{{par end}}

===返回值===
{{tt|T}} 类型的整数，其对象表示由 {{c|n}} 的对象表示的字节按逆序组成。

===注解===
此函数对处理有不同端序的数据有用。
{{feature test macro|__cpp_lib_byteswap|std=C++23|value=202110L|{{tt|std::byteswap}}}}

===可能的实现===
{{eq fun
|1=
template&lt;std::integral T&gt;
constexpr T byteswap(T value) noexcept
{
    static_assert(std::has_unique_object_representations_v&lt;T&gt;, 
                  "T 不能有填充位");
    auto value_representation = std::bit_cast&lt;std::array&lt;std::byte, sizeof(T)&gt;&gt;(value);
    std::ranges::reverse(value_representation);
    return std::bit_cast&lt;T&gt;(value_representation);
}
}}

===示例===
{{example|code=
#include &lt;bit&gt;
#include &lt;concepts&gt;
#include &lt;cstdint&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;

template &lt;std::integral T&gt;
void dump(T v, char term = '\n')
{
    std::cout &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; std::setfill('0')
              &lt;&lt; std::setw(sizeof(T) * 2) &lt;&lt; v &lt;&lt; " : ";
    for (std::size_t i{}; i != sizeof(T); ++i, v &gt;&gt;= 8)
        std::cout &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;unsigned&gt;(T(0xFF) &amp; v) &lt;&lt; ' ';
    std::cout &lt;&lt; std::dec &lt;&lt; term;
}

int main()
{
    static_assert(std::byteswap('a') == 'a');

    std::cout &lt;&lt; "U16 的 byteswap:\n";
    constexpr auto x = std::uint16_t(0xCAFE);
    dump(x);
    dump(std::byteswap(x));

    std::cout &lt;&lt; "\nU32 的 byteswap:\n";
    constexpr auto y = std::uint32_t(0xDEADBEEFu);
    dump(y);
    dump(std::byteswap(y));

    std::cout &lt;&lt; "\nU64 的 byteswap:\n";
    constexpr auto z = std::uint64_t{0x0123456789ABCDEFull};
    dump(z);
    dump(std::byteswap(z));
}
|p=true
|output=
U16 的 byteswap:
CAFE : FE CA
FECA : CA FE

U32 的 byteswap:
DEADBEEF : EF BE AD DE
EFBEADDE : DE AD BE EF

U64 的 byteswap:
0123456789ABCDEF : EF CD AB 89 67 45 23 01
EFCDAB8967452301 : 01 23 45 67 89 AB CD EF
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc endian}}
{{dsc inc|cpp/numeric/dsc rotl}}
{{dsc inc|cpp/numeric/dsc rotr}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}