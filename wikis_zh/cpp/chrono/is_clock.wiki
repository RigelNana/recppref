{{cpp/chrono/title|is_clock}}
{{cpp/chrono/navbar}}
{{ddcl|header=chrono|since=c++20|
template&lt; class T &gt;
struct is_clock;
}}

如果 {{tt|T}} 满足{{named req|Clock}}，那么提供等于 {{c|true}} 的成员常量 {{c|value}}，对于任何其他类型，{{c|value}} 是 {{c|false}}。

就此特征而言，不指定实现确定类型不能满足{{named req|Clock}}的其他要求，但至少保证 {{tt|T}} 在没有满足以下所有条件时不应当有资格作为{{named req|Clock}}：
* 以下每个{{ls|cpp/language/identifiers#有限定的标识符}}都合法，并且代表一个类型：
:* {{tt|T::rep}}
:* {{tt|T::period}}
:* {{tt|T::duration}}
:* {{tt|T::time_point}}
* 以下每个表达式在作为[[cpp/language/expressions#潜在求值表达式|不求值操作数]]时都良构：
:* {{tt|T::is_steady}}
:* {{tt|T::now()}}

{{cpp/types/nospec|pv}}

===模板形参===
{{par begin}}
{{par|T|要检查的类型}}
{{par end}}

===辅助变量模板===
{{ddcl|since=c++20|1=
template&lt; class T &gt;
constexpr bool is_clock_v = is_clock&lt;T&gt;::value;
}}

{{cpp/types/integral_constant/inherit|{{tt|T}} 满足{{named req|Clock}}要求}}

===可能的实现===
{{eq fun|
template&lt;class&gt;
struct is_clock : std::false_type {};
 
template&lt;class T&gt;
    requires
        requires
        {
            typename T::rep;
            typename T::period;
            typename T::duration;
            typename T::time_point;
            T::is_steady; // 不检查类型
            T::now();     // 不检查返回类型
        }
struct is_clock&lt;T&gt; : std::true_type {};
}}

===注解===
如果 {{tt|T}} 满足了{{named req|Clock}}规定，但 {{tt|T::is_steady}} 的类型不是 {{c/core|const bool}}，或者 {{tt|T::now()}} 的类型不是 {{c/core|T::time_point}}，那么不指明 {{tt|is_clock_v&lt;T&gt;}} 的结果。

===示例===
{{example
|code=
#include &lt;chrono&gt;
#include &lt;ratio&gt;

static_assert
(
    std::chrono::is_clock_v&lt;std::chrono::utc_clock&gt; and
    not std::chrono::is_clock_v&lt;std::chrono::duration&lt;int, std::exa&gt;&gt;
);

int main() {}
}}

{{langlinks|en|ja|ru}}