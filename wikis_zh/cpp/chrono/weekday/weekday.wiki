{{cpp/chrono/weekday/title|1=weekday}}
{{cpp/chrono/weekday/navbar}}
{{dcl begin}}
{{dcl|since=c++20|num=1|1=
weekday() = default;
}}
{{dcl|since=c++20|num=2|
constexpr explicit weekday( unsigned wd ) noexcept;
}}
{{dcl|since=c++20|num=3|
constexpr weekday( const std::chrono::sys_days&amp; sd ) noexcept;
}}
{{dcl|since=c++20|num=4|
constexpr explicit weekday( const std::chrono::local_days&amp; ld ) noexcept;
}}
{{dcl end}}

构造 {{tt|weekday}} 对象。

@1@ 默认构造函数保留星期之日值未初始化。
@2@ 构造保有星期之日值 {{c|wd}} 的 {{tt|weekday}} 对象。若 {{c|1=wd == 7}}，则保有的值为 {{c|0}}。若 {{c|wd &gt; 255}}，则保有的值未指定。
@3@ 构造表示 {{c|sd}} 所对应星期之日的 {{tt|weekday}}。此构造函数定义从 {{lc|std::chrono::sys_days}} 到 {{tt|weekday}} 的隐式转换。
@4@ 构造表示 {{c|ld}} 所对应星期之日的 {{tt|weekday}}，如同用 {{c|weekday(std::chrono::sys_days(ld.time_since_epoch()))}}。

===参数===
{{par begin}}
{{par|wd|星期之日值}}
{{par|sd|系统日期对象}}
{{par|ld|本地日期对象}}
{{par end}}

===示例===
{{example
|code=
#include &lt;chrono&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;

int main()
{
    constexpr std::chrono::weekday friday{5}; // 使用重载 (2)
    static_assert(friday == std::chrono::Friday);

    for (int y{2020}; y &lt;= 2024; ++y)
    {
        const std::chrono::year cur_year{y};
        for (int cur_month{1}; cur_month != 13; ++cur_month)
        {
            const std::chrono::year_month_day ymd{cur_year/cur_month/13};
            const std::chrono::weekday cur_weekday{std::chrono::sys_days(ymd)}; // (3)
            if (cur_weekday == friday)
                std::cout &lt;&lt; ymd &lt;&lt; " is " &lt;&lt; friday &lt;&lt; '\n';
        }
    }
}
|output=
2020-03-13 is Fri
2020-11-13 is Fri
2021-08-13 is Fri
2022-05-13 is Fri
2023-01-13 is Fri
2023-10-13 is Fri
2024-09-13 is Fri
2024-12-13 is Fri
}}

{{langlinks|en|es|ja|ru}}