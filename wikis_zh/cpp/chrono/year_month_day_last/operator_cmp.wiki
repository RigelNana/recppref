{{cpp/chrono/title|1=operator==,&lt;=&gt;{{small|(std::chrono::year_month_day_last)}}}}
{{cpp/chrono/year_month_day_last/navbar}}
{{dcl begin}}
{{dcl header|chrono}}
{{dcl|since=c++20|num=1|1=
constexpr bool operator==( const std::chrono::year_month_day_last&amp; x,
                           const std::chrono::year_month_day_last&amp; y ) noexcept;
}}
{{dcl|since=c++20|num=2|1=
constexpr std::strong_ordering
    operator&lt;=&gt;( const std::chrono::year_month_day_last&amp; x,
                 const std::chrono::year_month_day_last&amp; y ) noexcept;
}}
{{dcl end}}

比较两个 {{tt|year_month_day_last}} 值 {{c|x}} 与 {{c|y}}。这是字典序比较：首先比较 {{rlpf|accessors|year}}，再比较 {{rlpf|accessors|month}}。

{{cpp/note synthesized compare}}

=== 返回值 ===
@1@ {{c|1=x.year() == y.year() &amp;&amp; x.month() == y.month()}}
@2@ {{c|1=x.year() &lt;=&gt; y.year() != 0 ? x.year() &lt;=&gt; y.year() : x.month() &lt;=&gt; y.month()}}

=== 注解 ===
若 {{c|x}} 和 {{c|y}} 均表示合法日期（{{c|1=x.ok() &amp;&amp; y.ok() == true}}），则字典序比较的结果与日历顺序一致。

=== 示例 ===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;

int main()
{
    auto ymdl1{11/std::chrono::last/2020};
    auto mdl{std::chrono::last/std::chrono::November};
    auto ymdl2{mdl/2020};
    assert(ymdl1 == ymdl2);

    ymdl1 -= std::chrono::months{2};
    ymdl2 -= std::chrono::months{1};
    assert(ymdl1 &lt; ymdl2);
}
}}

{{langlinks|en|es|ja|ru}}