{{cpp/memory/allocator_traits/title|allocate_at_least}}
{{cpp/memory/allocator_traits/navbar}}
{{ddcl|since=c++23|
static constexpr std::allocation_result&lt;pointer, size_type&gt;
    allocate_at_least( Alloc&amp; a, size_type n );
}}

{{tt|allocate_at_least}} 调用 {{c|a.allocate_at_least(n)}} 并返回它的结果，如果该调用良构，否则它等价于 {{c|return {a.allocate(n), n};}}。

{{tt|allocator_at_least}} 尝试分配至少 {{c|n}} 个 {{tt|value_type}} 对象的存储，并提供恰为 {{c|n}} 个对象的存储的后备机制。

===参数===
{{par begin}}
{{par|a|用于分配存储的分配器}}
{{par|n|要分配存储的对象数的下界}}
{{par end}}

===返回值===
{{c|a.allocate_at_least(n)}}，如果良构。

否则返回 {{c|std::allocation_result&lt;pointer, size_type&gt;{a.allocate(n), n}&lt;!----&gt;}}。

===异常===
在选择的分配函数抛出异常时会抛出该异常。

===注解===
{{named req|Allocator}}类型的 {{tt|allocate_at_least}} 成员函数主要为连续容器，例如 {{lc|std::vector}} 与 {{lc|std::basic_string}} 提供，以通过使得其容量在可能时匹配实际分配的大小减少重分配。由于 {{tt|allocate_at_least}} 提供后备机制，所以能在适合处直接使用它。

给定 {{tt|Alloc}} 类型的分配器对象 {{c|a}}，令 {{c|result}} 代表从 {{c|std::allocator_traits&lt;Alloc&gt;::allocate_at_least(a, n)}} 返回的值，应该由 {{c|a.deallocate(result.ptr, m)}}（常经由 {{c|std::allocator_traits&lt;Alloc&gt;::deallocate(a, result.ptr, m)}} 调用）解分配存储以避免内存泄漏。

用于解分配的参数 {{c|m}} 必须不小于 {{c|n}} 且不大于 {{c|result.count}}，否则行为未定义。注意如果分配器不提供 {{tt|allocate_at_least}}，那么 {{c|n}} 始终等于 {{c|result.count}}，这表示要求 {{c|m}} 等于 {{c|n}}。

{{feature test macro|__cpp_lib_allocate_at_least|std=C++23|value=202302L|{{ttt|allocate_at_least}} 等}}

===示例===
{{example}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3887|std=C++23|before={{stddoc|P2652R0}} 没有更新功能特性测试宏|after=已更新}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/allocator/dsc allocate_at_least}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}