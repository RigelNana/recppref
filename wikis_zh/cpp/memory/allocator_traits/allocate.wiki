{{cpp/memory/allocator_traits/title|allocate}}
{{cpp/memory/allocator_traits/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcla|num=1|anchor=no|since=c++11|constexpr=c++20|
static pointer allocate( Alloc&amp; a, size_type n );
}}
{{dcla|num=2|anchor=no|since=c++11|constexpr=c++20|
static pointer allocate( Alloc&amp; a, size_type n, const_void_pointer hint );
}}
{{dcl end}}

用分配器 {{c|a}} 分配 {{c|n*sizeof(Alloc::value_type)}} 字节的未初始化存储。于该存储创建 {{c|Alloc::value_type[n]}} 类型的数组，但不构造其任何元素。

@1@ 调用 {{c|a.allocate(n)}}。

@2@ 附带地传递内存位置提示 {{c|hint}}。若可能则调用 {{c|a.allocate(n, hint)}}。若不可能（例如 {{c|a}} 没有双参数成员函数 {{tt|allocate()}}），则调用 {{c|a.allocate(n)}}。

===参数===
{{par begin}}
{{par|a|使用的分配器}}
{{par|n|要分配存储的对象数}}
{{par|hint|指向临近内存位置的指针}}
{{par end}}

===返回值===
调用 {{c|a.allocate(n)}} 所返回的指针。

===注解===
在 {{wg21|P0593R6}} 前不保证 {{tt|Alloc::allocate}} 创建数组对象，这使得按照核心语言规范，对 {{lc|std::vector}} 及某些其他容器使用非默认分配器并非实际良定义。

在调用 {{tt|allocate}} 后、构造元素前，{{c|Alloc::value_type*}} 的指针算术在分配的数组内是良定义的，但若访问元素则行为未定义。

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/allocator/dsc allocate}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}