{{cpp/ranges/title|uninitialized_default_construct}}
{{cpp/memory/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcl h|调用签名}}
{{dcla|num=1|since=c++20|constexpr=c++26|
template&lt; no-throw-forward-iterator I, no-throw-sentinel-for&lt;I&gt; S &gt;
    requires std::default_initializable&lt;std::iter_value_t&lt;I&gt;&gt;
I uninitialized_default_construct( I first, S last );
}}
{{dcla|num=2|since=c++20|constexpr=c++26|
template&lt; no-throw-forward-range R &gt;
    requires std::default_initializable&lt;ranges::range_value_t&lt;R&gt;&gt;
ranges::borrowed_iterator_t&lt;R&gt;
    uninitialized_default_construct( R&amp;&amp; r );
}}
{{dcl end}}

@1@ 如同用以下方式在未初始化内存区域 {{range|first|last}} 上通过[[cpp/language/default initialization|默认初始化]]构造 {{c/core|std::iter_value_t&lt;I&gt;}} 类型对象：
{{box|
{{c/core|1=for (; first != last; ++first)}}&lt;br&gt;
{{nbspt|4}}{{c/core|::new (}}{{lti|cpp/memory/voidify}}{{c/core|(*first))}}&lt;br&gt;
{{nbspt|8}}{{c/core|std::remove_reference_t&lt;std::iter_reference_t&lt;I&gt;&gt;;}}&lt;br&gt;
{{c/core|return first;}}
}}
@@ 如果初始化中抛出了异常，那么以未指定的顺序销毁已构造的对象。

@2@ 等价于 {{c|ranges::uninitialized_default_construct(ranges::begin(r), ranges::end(r))}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要初始化的|sentinel=yes}}
{{par|r|要初始化的元素 {{lconcept|range}}}}
{{par end}}

===返回值===
如上所述。

===复杂度===
与 {{c|first}} 和 {{c|last}} 间的距离成线性。

===异常===
构造目标范围中的元素时抛出的任何异常。

===注解===
如果默认初始化 {{c/core|std::iter_value_t&lt;I&gt;}} 对象时不调用非平凡的默认构造函数，那么实现可以跳过对象构造（而不更改可观察效果），这能由 {{lc|std::is_trivially_default_constructible}} 检测。

{{feature test macro|__cpp_lib_raw_memory_algorithms|std=C++26|value=202411L|{{c/core|constexpr}} 的 [[cpp/memory#未初始化内存算法|特化的内存算法]], {{vl|1,2}} }}

===可能的实现===
{{eq fun|1=
struct uninitialized_default_construct_fn
{
    template&lt;no-throw-forward-iterator I, no-throw-sentinel-for&lt;I&gt; S&gt;
        requires std::default_initializable&lt;std::iter_value_t&lt;I&gt;&gt;
    constexpr I operator()(I first, S last) const
    {
        using ValueType = std::remove_reference_t&lt;std::iter_reference_t&lt;I&gt;&gt;;
        if constexpr (std::is_trivially_default_constructible_v&lt;ValueType&gt;)
            return ranges::next(first, last); // 跳过初始化
        I rollback{first};
        try
        {
            for (; !(first == last); ++first)
                ::new (static_cast&lt;void*&gt;(std::addressof(*first))) ValueType;
            return first;
        }
        catch (...) // 回滚：销毁构造的元素
        {
            for (; rollback != first; ++rollback)
                ranges::destroy_at(std::addressof(*rollback));
            throw;
        }
    }
    
    template&lt;no-throw-forward-range R&gt;
        requires std::default_initializable&lt;ranges::range_value_t&lt;R&gt;&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt; operator()(R&amp;&amp; r) const
    {
        return (*this)(ranges::begin(r), ranges::end(r));
    }
};

inline constexpr uninitialized_default_construct_fn uninitialized_default_construct{};
}}

===示例===
{{example
|code=
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

int main()
{
    struct S { std::string m{ "▄▀▄▀▄▀▄▀" }; };
    
    constexpr int n{4};
    alignas(alignof(S)) char out[n * sizeof(S)];
    
    try
    {
        auto first{reinterpret_cast&lt;S*&gt;(out)};
        auto last{first + n};
        
        std::ranges::uninitialized_default_construct(first, last);
        
        auto count{1};
        for (auto it{first}; it != last; ++it)
            std::cout &lt;&lt; count++ &lt;&lt; ' ' &lt;&lt; it-&gt;m &lt;&lt; '\n';
        
        std::ranges::destroy(first, last);
    }
    catch (...) { std::cout &lt;&lt; "异常！\n"; }
    
    // 注意对于“平凡类型” uninitialized_default_construct 通常不以零填充给定的未初始化内存区域。
    constexpr char sample[]{'A', 'B', 'C', 'D', '\n'};
    char v[]{'A', 'B', 'C', 'D', '\n'};
    std::ranges::uninitialized_default_construct(std::begin(v), std::end(v));
    if (std::memcmp(v, sample, sizeof(v)) == 0)
    {
        std::cout &lt;&lt; "  ";
        // 可能为未定义行为，等待 CWG 1997 得到解决：
        // for (const char c : v) { std::cout &lt;&lt; c &lt;&lt; ' '; }
        for (const char c : sample)
            std::cout &lt;&lt; c &lt;&lt; ' ';
    }
    else
        std::cout &lt;&lt; "未指定\n";
}
|p=true
|output=
1 ▄▀▄▀▄▀▄▀
2 ▄▀▄▀▄▀▄▀
3 ▄▀▄▀▄▀▄▀
4 ▄▀▄▀▄▀▄▀
  A B C D
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3870|std=C++20|before=此算法可能在 {{c/core|const}} 存储上创建对象|after=保持禁止}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/ranges/dsc uninitialized_default_construct_n}}
{{dsc inc|cpp/memory/ranges/dsc uninitialized_value_construct}}
{{dsc inc|cpp/memory/ranges/dsc uninitialized_value_construct_n}}
{{dsc inc|cpp/memory/dsc uninitialized_default_construct}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}