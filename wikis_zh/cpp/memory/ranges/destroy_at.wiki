{{cpp/ranges/title|destroy_at}}
{{cpp/memory/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcl h|调用签名}}
{{dcl|since=c++20|
template&lt; std::destructible T &gt;
constexpr void destroy_at( T* p ) noexcept;
}}
{{dcl end}}

若 {{tt|T}} 不是数组类型，则在 {{c|p}} 所指向的对象上调用析构函数，如同通过 {{tt|p-&gt;~T()}}。否则，按顺序递归地销毁 {{c|*p}} 的元素，如同通过调用 {{c|std::destroy(std::begin(*p), std::end(*p))}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par|p|指向要被销毁的对象的指针}}
{{par end}}

===返回值===
（无）

===可能的实现===
{{eq fun|1=
struct destroy_at_fn
{
    template&lt;std::destructible T&gt;
    constexpr void operator()(T *p) const noexcept
    {
        if constexpr (std::is_array_v&lt;T&gt;)
            for (auto &amp;elem : *p)
                operator()(std::addressof(elem));
        else
            p-&gt;~T();
    }
};

inline constexpr destroy_at_fn destroy_at{};
}}

===注解===
{{tt|destroy_at}} 推导要被销毁的对象的类型，从而避免在析构函数调用中显式写出它。

在某[[cpp/language/constant expression|常量表达式]] {{c|e}} 的求值中调用 {{tt|destroy_at}} 时，实参 {{c|p}} 必须指向生存期始于 {{c|e}} 的求值内的对象。

===示例===
{{cpp/memory/destroy example|ranges::destroy_at}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/ranges/dsc destroy}}
{{dsc inc|cpp/memory/ranges/dsc destroy_n}}
{{dsc inc|cpp/memory/ranges/dsc construct_at}}
{{dsc inc|cpp/memory/dsc destroy_at}}
{{dsc end}}

{{langlinks|de|en|es|ru|ja}}