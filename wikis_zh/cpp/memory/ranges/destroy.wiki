{{cpp/ranges/title|destroy}}
{{cpp/memory/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcl h|调用签名}}
{{dcl|since=c++20|num=1|
template&lt; no-throw-input-iterator I, no-throw-sentinel-for&lt;I&gt; S &gt;
    requires std::destructible&lt;std::iter_value_t&lt;I&gt;&gt;
constexpr I destroy( I first, S last ) noexcept;
}}
{{dcl|since=c++20|num=2|
template&lt; no-throw-input-range R &gt;
    requires std::destructible&lt;ranges::range_value_t&lt;R&gt;&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt; destroy( R&amp;&amp; r ) noexcept;
}}
{{dcl end}}

@1@ 销毁范围 {{range|first|last}} 中的对象，如同用
{{source|1=
for (; first != last; ++first)
    std::ranges::destroy_at(std::addressof(*first));
return first;
}}

@2@ 同 {{v|1}}，但以 {{c|r}} 为源范围，如同以 {{c|ranges::begin(r)}} 为 {{c|first}} 并以 {{c|ranges::end(r)}} 为 {{c|last}}。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par range|3=要销毁的|sentinel=yes}}
{{par|r|要销毁的 {{lconcept|range}}}}
{{par end}}

===返回值===
比较等于 {{c|last}} 的迭代器。

===复杂度===
与 {{c|first}} 和 {{c|last}} 间的距离成线性。

===可能的实现===
{{eq fun|1=
struct destroy_fn
{
    template&lt;no-throw-input-iterator I, no-throw-sentinel-for&lt;I&gt; S&gt;
        requires std::destructible&lt;std::iter_value_t&lt;I&gt;&gt;
    constexpr I operator()(I first, S last) const noexcept
    {
        for (; first != last; ++first)
            std::ranges::destroy_at(std::addressof(*first));
        return first;
    }

    template&lt;no-throw-input-range R&gt;
        requires std::destructible&lt;std::ranges::range_value_t&lt;R&gt;&gt;
    constexpr std::ranges::borrowed_iterator_t&lt;R&gt; operator()(R&amp;&amp; r) const noexcept
    {
        return operator()(std::ranges::begin(r), std::ranges::end(r));
    }
};

inline constexpr destroy_fn destroy{};
}}

===示例===
{{cpp/memory/destroy example|ranges::destroy}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/ranges/dsc destroy_n}}
{{dsc inc|cpp/memory/ranges/dsc destroy_at}}
{{dsc inc|cpp/memory/dsc destroy}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}