{{cpp/ranges/title|uninitialized_fill_n}}
{{cpp/memory/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcl h|调用签名}}
{{dcla|since=c++20|constexpr=c++26|
template&lt; no-throw-forward-range I, class T &gt;
    requires std::constructible_from&lt;std::iter_value_t&lt;I&gt;, const T&amp;&gt;
I uninitialized_fill_n( I first, std::iter_difference_t&lt;I&gt; count,
                        const T&amp; value );
}}
{{dcl end}}

如同用以下方式将 {{c|value}} 复制到未初始化内存区域 {{counted range|first|count}}：
{{c multi|
return ranges::uninitialized_fill(std::counted_iterator(first, count),|                                  std::default_sentinel, value).base();
}}

如果初始化中抛出了异常，那么以未指定的顺序销毁已构造的对象。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par|first|要初始化的元素范围的起始}}
{{par|count|构造的元素数}}
{{par|value|用以构造元素的值}}
{{par end}}

===返回值===
如上所述。

===复杂度===
与 {{c|count}} 成线性。

===异常===
构造目标范围中的元素时抛出的任何异常。

===注解===
如果输出范围的值类型是{{named req|TrivialType}}，那么实现可能提升 {{tt|ranges::uninitialized_fill_n}} 的效率，例如用 {{lc|ranges::fill_n}}。

{{feature test macro|__cpp_lib_raw_memory_algorithms|std=C++26|value=202411L|{{c/core|constexpr}} 的[[cpp/memory#未初始化内存算法|特化内存算法]]}}

===可能的实现===
{{eq fun|1=
struct uninitialized_fill_n_fn
{
    template&lt;no-throw-forward-range I, class T&gt;
        requires std::constructible_from&lt;std::iter_value_t&lt;I&gt;, const T&amp;&gt;
    constexpr I operator()(I first, std::iter_difference_t&lt;I&gt; count,
                           const T&amp; value) const
    {
        I rollback{first};
        try
        {
            for (; count-- &gt; 0; ++first)
                ranges::construct_at(std::addressof(*first), value);
            return first;
        }
        catch (...) // 回滚：销毁已构造的元素
        {
            for (; rollback != first; ++rollback)
                ranges::destroy_at(std::addressof(*rollback));
            throw;
        }
    }
};

inline constexpr uninitialized_fill_n_fn uninitialized_fill_n{};
}}

===示例===
{{example|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

int main()
{
    constexpr int n{3};
    alignas(alignof(std::string)) char out[n * sizeof(std::string)];
    
    try
    {
        auto first{reinterpret_cast&lt;std::string*&gt;(out)};
        auto last = std::ranges::uninitialized_fill_n(first, n, "cppreference");
        
        for (auto it{first}; it != last; ++it)
            std::cout &lt;&lt; *it &lt;&lt; '\n';
        
        std::ranges::destroy(first, last);
    }
    catch (...)
    {
        std::cout &lt;&lt; "异常！\n";
    }
}
|output=
cppreference
cppreference
cppreference
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3870|std=C++20|before=此算法可能在 {{c/core|const}} 存储上创建对象|after=保持禁止}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/ranges/dsc uninitialized_fill}}
{{dsc inc|cpp/memory/dsc uninitialized_fill_n}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}