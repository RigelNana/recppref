{{cpp/memory/unique_ptr/title|~unique_ptr}}
{{cpp/memory/unique_ptr/navbar}}
{{ddcl|since=c++11|notes={{mark|constexpr since C++23}}|
~unique_ptr();
}}
若 {{lc|get()}} {{tt|1= == }} {{c|nullptr}} 则无效果。否则，通过 {{lc|get_deleter()}}{{tt|(}}{{lc|get()}}{{tt|)}} 销毁拥有的对象。

要求 {{tt|get_deleter()(get())}} 不抛异常。

===注解===
虽然拥有默认删除器的 {{tt|std::unique_ptr&lt;T&gt;}} 能以[[cpp/language/type#不完整类型|不完整类型]] {{tt|T}} 构造，但在调用析构函数的代码位置，{{tt|T}} 也必须完整。

===示例===
{{example
|下列程序演示定制删除器的用法。
|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;
 
int main () 
{
    auto deleter = [](int* ptr)
    {
        std::cout &lt;&lt; "[调用删除器]\n";
        delete ptr;
    };
 
    std::unique_ptr&lt;int,decltype(deleter)&gt; uniq(new int, deleter);
    std::cout &lt;&lt; (uniq ? "非空\n" : "空\n");
    uniq.reset();
    std::cout &lt;&lt; (uniq ? "非空\n" : "空\n");
}
|output=
非空
[调用删除器]
空
}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}