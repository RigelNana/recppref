{{cpp/memory/unique_ptr/title|operator*|operator-&gt;}}
{{cpp/memory/unique_ptr/navbar}}
{{dcl begin}}
{{dcla|num=1|since=c++11|constexpr=c++23|
typename std::add_lvalue_reference&lt;T&gt;::type operator*() const
    noexcept(noexcept(*std::declval&lt;pointer&gt;()));
}}
{{dcla|num=2|since=c++11|constexpr=c++23|
pointer operator-&gt;() const noexcept;
}}
{{dcl end}}

{{c/core|operator*}} 和 {{c/core|operator-&gt;}} 提供到 {{c|*this}} 所占有的对象的访问。

仅为单独对象的 {{tt|unique_ptr}}，即主模板提供这些成员函数。

{{rrev|since=c++23|
@1@ 如果 {{c multi|std::reference_converts_from_temporary_v|    &lt;std::add_lvalue_reference_t&lt;T&gt;,|     decltype(*std::declval&lt;pointer&gt;())&gt;}} 是 {{c|true}}，那么程序非良构。
}}

如果 {{c|get()}} 是空指针，那么行为未定义。

===返回值===
@1@ 返回 {{c|*this}} 所占有的对象，等价于 {{c|*get()}}。

@2@ 返回指向 {{c|*this}} 所占有对象的指针，即 {{c|get()}}。

===异常===
@1@ {{tt|pointer}} 拥有抛出的 {{c/core|operator*}} 时可能会抛出。

===注解===
使用 {{lc|std::add_lvalue_reference}} 使得可以实例化 {{c/core|std::unique_ptr&lt;void&gt;}}，因为 C++ 不允许 {{c/core|void&amp;}} 而 {{c/core|std::add_lvalue_reference&lt;void&gt;}} 产生的是 {{c/core|void}}。详情见 {{wg21|LWG673}}。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;

struct Foo
{
    void bar() { std::cout &lt;&lt; "Foo::bar\n"; }
};

void f(const Foo&amp;) 
{
    std::cout &lt;&lt; "f(const Foo&amp;)\n";
}

int main() 
{
    std::unique_ptr&lt;Foo&gt; ptr(new Foo);
    
    ptr-&gt;bar();
    f(*ptr);
}
|output=
Foo::bar
f(const Foo&amp;)
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2762|std=C++11|before=即使 {{c|*get()}} 是 noexcept 的，{{c/core|operator*}} 仍可能会潜在抛出|after=添加了条件性异常说明}}
{{dr list item|wg=lwg|dr=4148|std=C++23|before={{tt|element_type*}} 与 {{tt|Deleter::pointer}} 不同的情况下 {{c/core|operator*}} 可能会返回悬垂引用|after=此时程序非良构}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/unique_ptr/dsc get}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}