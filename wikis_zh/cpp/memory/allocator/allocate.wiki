{{cpp/memory/allocator/title|allocate}}
{{cpp/memory/allocator/navbar}}
{{dcl begin}}
{{dcl rev begin|num=1}}
{{dcl|until=c++17|1=
pointer allocate( size_type n, const void* hint = 0 );
}}
{{dcl|since=c++17|deprecated=yes|removed=c++20|1=
T* allocate( std::size_t n, const void* hint );
}}
{{dcl rev end}}
{{dcl rev multi|num=2|since1=c++17|dcl1=
T* allocate( std::size_t n );
|since2=c++20|dcl2=
constexpr T* allocate( std::size_t n );
}}
{{dcl end}}

调用 {{c|::operator new(std::size_t)}} {{rev inl|since=c++17|或 {{c|::operator new(std::size_t, std::align_val_t)}} }}分配 {{c|n * sizeof(T)}} 字节的未初始化存储，但何时及如何调用此函数是未指定的。指针 {{c|hint}} 可用于提供引用的局部性：如果实现支持，那么 allocator 会试图分配尽可能接近 {{c|hint}} 的新内存块。

然后，此函数在该存储中创建一个 {{tt|T[n]}} 数组并开始其生存期，但不开始其任何元素的生存期。

如果 {{tt|T}} 是[[cpp/language/type#不完整类型|不完整类型]]，那么此函数的使用非良构。&lt;!-- LWG 3307 --&gt;

{{rrev|since=c++20|
为了在常量表达式中使用此函数，必须在同一表达式的求值内解分配它分配的存储。
}}

===参数===
{{par begin}}
{{par|n|要分配存储的对象数}}
{{par|hint|指向临近内存位置的指针}}
{{par end}}

===返回值===
指向 {{tt|T}} 类型的 {{c|n}} 个对象的数组首元素的指针，数组元素尚未构造。

===异常===
{{rrev|since=c++11|
如果 {{c|std::numeric_limits&lt;std::size_t&gt;::max() / sizeof(T) &lt; n}}，那么就会抛出 {{lc|std::bad_array_new_length}}。
}}
如果分配失败，那么就会抛出 {{lc|std::bad_alloc}}。

===注解===
遣词“未指定何时及如何”令标准库容器可以[[cpp/language/new#分配|组合或优化掉堆分配]]，即使对直接调用 {{tt|::operator new}} 禁止这种优化。例如 libc++ 实现了它（[https://github.com/llvm-mirror/libcxx/blob/master@%7B2017-02-09%7D/include/memory#L1766-L1772] 与 [https://github.com/llvm-mirror/libcxx/blob/master@%7B2017-02-09%7D/include/new#L211-L217]）

在调用 {{tt|allocate()}} 后、构造元素前，{{tt|T*}} 的指针算术在分配的数组内是良定义的，但如果访问元素那么行为未定义。

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=578|std=C++98|before={{c|hint}} 必须是 {{c|0}} 或者先前从 {{tt|allocate()}}&lt;br&gt;返回但还没有传递给 {{lc|deallocate()}} 的指针|after=移除该要求}}
{{dr list item|wg=lwg|dr=3190|std=c++11|before={{tt|allocate()}} 可能分配大小错误的存储|after=改成抛出 {{lc|std::bad_array_new_length}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/allocator_traits/dsc allocate}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}