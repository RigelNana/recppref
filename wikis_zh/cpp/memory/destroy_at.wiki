{{cpp/title|destroy_at}}
{{cpp/memory/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcl rev multi
|since1=c++17|dcl1=  
template&lt; class T &gt;
void destroy_at( T* p );
|since2=c++20|dcl2=  
template&lt; class T &gt;
constexpr void destroy_at( T* p );
}}
{{dcl end}}

若 {{tt|T}} 不是数组类型，则调用 {{c|p}} 所指向对象的析构函数，如同用 {{c|p-&gt;~T()}}。

若 {{tt|T}} 是数组类型，则{{rev inl|until=c++20|程序非良构}}{{rev inl|since=c++20|按顺序递归地销毁 {{c|*p}} 的元素，如同通过调用 {{c|std::destroy(std::begin(*p), std::end(*p))}}}}。

===参数===
{{par begin}}
{{par|p|指向要被销毁的对象的指针}}
{{par end}}

===返回值===
（无）

===可能的实现===
{{eq fun|1=
template&lt;class T&gt;
constexpr void destroy_at(T* p) 
{
    if constexpr (std::is_array_v&lt;T&gt;)
        for (auto &amp;elem : *p)
            (destroy_at)(std::addressof(elem));
    else
        p-&gt;~T(); 
}
// C++17 版本：
// template&lt;class T&gt; void destroy_at(T* p) { p-&gt;~T(); }
}}

===注解===
{{tt|destroy_at}} 推导要销毁的对象类型，从而避免在析构函数调用中显式写出它。

{{rrev|since=c++20|
在某[[cpp/language/constant expression|常量表达式]] {{c|e}} 的求值中调用 {{tt|destroy_at}} 时，参数 {{c|p}} 必须指向生存期始于 {{c|e}} 的求值内的对象。
}}

===示例===
{{cpp/memory/destroy example|destroy_at}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/dsc destroy}}
{{dsc inc|cpp/memory/dsc destroy_n}}
{{dsc inc|cpp/memory/dsc construct_at}}
{{dsc inc|cpp/memory/ranges/dsc destroy_at}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}