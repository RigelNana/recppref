{{cpp/title|make_shared|make_shared_for_overwrite}}
{{cpp/memory/shared_ptr/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcl|num=1|since=c++11|
template&lt; class T, class... Args &gt;
shared_ptr&lt;T&gt; make_shared( Args&amp;&amp;... args );
}}
{{dcla|num=2|since=c++20|
template&lt; class T &gt;
shared_ptr&lt;T&gt; make_shared( std::size_t N );
}}
{{dcl|num=3|since=c++20|
template&lt; class T &gt;
shared_ptr&lt;T&gt; make_shared();
}}
{{dcl|num=4|since=c++20|
template&lt; class T &gt;
shared_ptr&lt;T&gt; make_shared( std::size_t N, const std::remove_extent_t&lt;T&gt;&amp; u );
}}
{{dcl|num=5|since=c++20|
template&lt; class T &gt;
shared_ptr&lt;T&gt; make_shared( const std::remove_extent_t&lt;T&gt;&amp; u );
}}
{{dcla|num=6|since=c++20|
template&lt; class T &gt;
shared_ptr&lt;T&gt; make_shared_for_overwrite();
}}
{{dcl|num=7|since=c++20|
template&lt; class T &gt;
shared_ptr&lt;T&gt; make_shared_for_overwrite( std::size_t N );
}}
{{dcl end}}

为某个对象分配内存并以提供的实参初始化该对象。返回管理新创建的对象的 {{lc|std::shared_ptr}} 对象。

@1@ 该对象具有 {{tt|T}} 类型，并如同以 {{c|::new (pv) T(std::forward&lt;Args&gt;(args)...)}} 构造，其中 {{c|pv}} 是指向适合持有 {{tt|T}} 类型对象的存储的 {{c/core|void*}} 指针。如果该对象要被销毁，那么它会如同以 {{c|pt-&gt;~T()}} 被销毁，其中 {{c|pt}} 是指向该 {{tt|T}} 类型对象的指针。
{{rrev|since=c++20|
{{cpp/enable if| {{tt|T}} 不是数组类型}}。
}}

@2@ 该对象具有 {{c/core|std::remove_extent_t&lt;T&gt;[N]}} 类型。每个元素都具有默认的初始值。
@@ {{cpp/enable if| {{tt|T}} 是无边界的数组类型}}。

@3@ 该对象具有 {{tt|T}} 类型。每个元素都具有默认的初始值。
@@ {{cpp/enable if| {{tt|T}} 是有边界的数组类型}}。

@4@ 该对象具有 {{c/core|std::remove_extent_t&lt;T&gt;[N]}} 类型。每个元素都具有初始值 {{c|u}}。
@@ {{cpp/enable if| {{tt|T}} 是无边界的数组类型}}。

@5@ 该对象具有 {{tt|T}} 类型。每个元素都具有初始值 {{c|u}}。
@@ {{cpp/enable if| {{tt|T}} 是有边界的数组类型}}。

@6@ 该对象具有 {{tt|T}} 类型。
* 如果 {{tt|T}} 不是数组类型，那么如同以 {{c|::new (pv) T}} 构造该对象，其中 {{c|pv}} 是指向适合持有 {{tt|T}} 类型对象的存储的 {{c/core|void*}} 指针。如果该对象要被销毁，那么它会如同以 {{c|pt-&gt;~T()}} 被销毁，其中 {{c|pt}} 是指向该 {{tt|T}} 类型对象的指针。
* 如果 {{tt|T}} 是有边界的数组类型，那么不指定每个元素的初始值。
@@ {{cpp/enable if| {{tt|T}} 不是数组类型，或者是有边界的数组类型}}。

@7@ 该对象具有 {{c/core|std::remove_extent_t&lt;T&gt;[N]}} 类型。不指定每个元素的初始值。
@@ {{cpp/enable if| {{tt|T}} 是无边界的数组类型}}。

{{rrev|since=c++20|
====初始化和销毁数组元素====
{{tt|U}} 类型的数组元素会以它们地址的升序进行初始化。

* 如果 {{tt|U}} 不是数组类型，那么每个元素如同以以下表达式构造，其中 {{c|pv}} 是指向适合持有 {{tt|U}} 类型对象的存储的 {{c/core|void*}} 指针：
@2,3@ {{c|::new (pv) U()}}
@4,5@ {{c|::new (pv) U(u)}}
@6,7@ {{c|::new (pv) U}}

* 否则递归地初始化每个元素各自的元素。对于数组的下一维度：
:* {{tt|U}} 变成 {{c/core|std::remove_extent_t&lt;U&gt;}}。
:* 对于重载 {{v|4,5}}，{{c|u}} 变成它的对应元素。

当返回的 {{lc|std::shared_ptr}} 管理的对象的生存期结束，或初始化数组元素时抛出异常，那么已初始化的元素会按构造时的逆序销毁。

对于每一个要被销毁的具有非数组类型 {{tt|U}} 的数组元素，它如同以 {{c|pu-&gt;~U()}} 被销毁，其中 {{c|pu}} 是指向该 {{tt|U}} 类型数组元素的指针。
}}

===参数===
{{par begin}}
{{par|args|将用以构造 {{tt|T}} 对象的实参列表}}
{{par|N|要使用的数组大小}}
{{par|u|用以初始化数组每个元素的初值}}
{{par end}}

===返回值===
指向具有 {{tt|T}} 类型{{rev inl|since=c++20|或在 {{tt|T}} 是无边界的数组类型时具有 {{c/core|std::remove_extent_t&lt;T&gt;[N]}} 类型}}的对象的 {{lc|std::shared_ptr}}。

对于返回的 {{lc|std::shared_ptr}} {{c|r}}，{{c|r.get()}} 会返回非空指针，且 {{c|r.use_count()}} 会返回 {{c|1}}。

===异常===
可能抛出 {{lc|std::bad_alloc}} 或任何 {{tt|T}} 构造函数所抛的异常。如果抛出异常，那么函数无效果。{{rev inl|since=c++20|如果异常在数组的构造中抛出，那么已初始化元素以逆序销毁。}}

===注解===
这些函数通常会分配多于 {{c|sizeof(T)}} 的内存以储存内部记录结构，例如引用计数。

此函数可用作 {{c|std::shared_ptr&lt;T&gt;(new T(args...))}} 的替代品。得失是：
* {{c|std::shared_ptr&lt;T&gt;(new T(args...))}} 进行至少二次分配（一次为 {{tt|T}} 而另一次为共享指针的控制块），而 {{c|std::make_shared&lt;T&gt;}} 典型地仅进行一次分配（标准推荐但不要求如此，所有已知实现均如此）。
* 如果在所有共享拥有者的生存期结束后仍有任何 {{lc|std::weak_ptr}} 引用 {{tt|std::make_shared}} 所创建的控制块，那么 {{tt|T}} 所占有的内存持续存在，直至所有弱拥有者亦被销毁，在 {{c|sizeof(T)}} 较大时这可能是不想要的行为。
* 如果在可访问 {{tt|T}} 的非公开构造函数的语境中执行，那么 {{c|std::shared_ptr&lt;T&gt;(new T(args...))}} 可能会调用它，而 {{tt|std::make_shared}} 要求对被选择构造函数的公开访问。
* 不同于 {{lc|std::shared_ptr}} 构造函数，{{tt|std::make_shared}} 不允许自定义删除器。
* {{tt|std::make_shared}} 使用 {{c|::new}}，因此如果用类特定的 {{ltt|cpp/memory/new/operator new}} 设置了任何特殊行为，那么它将异于 {{c|std::shared_ptr&lt;T&gt;(new T(args...))}}。
{{rrev|until=c++20|* {{lc|std::shared_ptr}} 支持数组类型（从 C++17 起），但 {{tt|std::make_shared}} 不支持。[http://www.boost.org/doc/libs/1_66_0/libs/smart_ptr/doc/html/smart_ptr.html#make_shared {{tt|boost::make_shared}}] 支持此功能。
}}
{{rrev|until=c++17|* 如 {{c|f(std::shared_ptr&lt;int&gt;(new int(42)), g())}} 的代码，如果 {{c|g}} 在 {{c|new int(42)}} 后得到调用且抛出异常，那么可能导致内存泄漏，而 {{c|f(std::make_shared&lt;int&gt;(42), g())}} 是安全的，因为两次函数调用[[cpp/language/eval order|决不会穿插]]。}}
{{cpp/memory/shared_ptr/enabling shared_from_this}}

{{ftm begin|comment=yes|std=yes}}
{{ftm|__cpp_lib_shared_ptr_arrays|{{ttt|std::make_shared}} 的数组支持；重载 {{vl|2-5}}|value=201707L|std=C++20}}
{{ftm|__cpp_lib_smart_ptr_for_overwrite|进行默认初始化的智能指针创建 ({{lc|std::allocate_shared_for_overwrite}}、{{tt|std::make_shared_for_overwrite}}、{{lc|std::make_unique_for_overwrite}})；重载 {{vl|6,7}}|value=202002L|std=C++20}}
{{ftm end}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;

struct C
{
    // &lt; 需要构造函数 (C++20 前)
    C(int i) : i(i) {}
    C(int i, float f) : i(i), f(f) {}
    int i;
    float f{};
};

int main()
{
    // 为 “sp1” 的类型使用 “auto”
    auto sp1 = std::make_shared&lt;C&gt;(1); // 重载 (1)
    static_assert(std::is_same_v&lt;decltype(sp1), std::shared_ptr&lt;C&gt;&gt;);
    std::cout &lt;&lt; "sp1-&gt;{ i:" &lt;&lt; sp1-&gt;i &lt;&lt; ", f:" &lt;&lt; sp1-&gt;f &lt;&lt; " }\n";
    
    // 明确 “sp2” 的类型
    std::shared_ptr&lt;C&gt; sp2 = std::make_shared&lt;C&gt;(2, 3.0f); // 重载 (1)
    static_assert(std::is_same_v&lt;decltype(sp2), std::shared_ptr&lt;C&gt;&gt;);
    static_assert(std::is_same_v&lt;decltype(sp1), decltype(sp2)&gt;);
    std::cout &lt;&lt; "sp2-&gt;{ i:" &lt;&lt; sp2-&gt;i &lt;&lt; ", f:" &lt;&lt; sp2-&gt;f &lt;&lt; " }\n";
    
    // 指向值初始化的 float[64] 的 shared_ptr；重载 (2):
    std::shared_ptr&lt;float[]&gt; sp3 = std::make_shared&lt;float[]&gt;(64);
    
    // 指向值初始化的 long[5][3][4] 的 shared_ptr；重载 (2):
    std::shared_ptr&lt;long[][3][4]&gt; sp4 = std::make_shared&lt;long[][3][4]&gt;(5);
    
    // 指向值初始化的 short[128] 的 shared_ptr；重载 (3):
    std::shared_ptr&lt;short[128]&gt; sp5 = std::make_shared&lt;short[128]&gt;();
    
    // 指向值初始化的 int[7][6][5] 的 shared_ptr；重载 (3):
    std::shared_ptr&lt;int[7][6][5]&gt; sp6 = std::make_shared&lt;int[7][6][5]&gt;();
    
    // 指向 double[256] 的 shared_ptr，其各元素均为 2.0；重载 (4):
    std::shared_ptr&lt;double[]&gt; sp7 = std::make_shared&lt;double[]&gt;(256, 2.0);
    
    // 指向 double[7][2] 的 shared_ptr，其各 double[2] 元素均为 {3.0, 4.0}；重载 (4):
    std::shared_ptr&lt;double[][2]&gt; sp8 = std::make_shared&lt;double[][2]&gt;(7, {3.0, 4.0});
    
    // 指向 vector&lt;int&gt;[4] 的 shared_ptr，其各向量的内容均为 {5, 6}；重载 (4):
    std::shared_ptr&lt;std::vector&lt;int&gt;[]&gt; sp9 =
        std::make_shared&lt;std::vector&lt;int&gt;[]&gt;(4, {5, 6});
    
    // 指向 float[512] 的 shared_ptr，其各元素均为 1.0；重载 (5):
    std::shared_ptr&lt;float[512]&gt; spA = std::make_shared&lt;float[512]&gt;(1.0);
    
    // 指向 double[6][2] 的 shared_ptr，其各 double[2] 元素均为 {1.0, 2.0}；重载 (5):
    std::shared_ptr&lt;double[6][2]&gt; spB = std::make_shared&lt;double[6][2]&gt;({1.0, 2.0});
    
    // 指向 vector&lt;int&gt;[4] 的 shared_ptr，其各向量的内容均为 {5, 6}；重载 (5):
    std::shared_ptr&lt;std::vector&lt;int&gt;[4]&gt; spC =
        std::make_shared&lt;std::vector&lt;int&gt;[4]&gt;({5, 6});
}
|output=
sp1-&gt;{ i:1, f:0 }
sp2-&gt;{ i:2, f:3 }
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=4024|std=C++20|before=不明确如何销毁 {{tt|std::make_shared_for_overwrite}} 中构造的对象|after=使之明确}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/shared_ptr/dsc constructor}}
{{dsc inc|cpp/memory/shared_ptr/dsc allocate_shared}}
{{dsc inc|cpp/memory/dsc enable_shared_from_this}}
{{dsc inc|cpp/memory/unique_ptr/dsc make_unique}}
{{dsc inc|cpp/memory/new/dsc operator_new}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}