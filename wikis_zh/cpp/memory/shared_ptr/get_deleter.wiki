{{cpp/title|get_deleter}}
{{cpp/memory/shared_ptr/navbar}}
{{ddcl|header=memory|since=c++11|
template&lt; class Deleter, class T &gt;
Deleter* get_deleter( const std::shared_ptr&lt;T&gt;&amp; p ) noexcept;
}}

访问 {{c|p}} 的删除器。若共享指针 {{c|p}} 拥有无 cv 限定的 {{tt|Deleter}} 类型的删除器（例如，若以接收删除器为参数的构造函数之一创建它），则返回指向删除器的指针。否则，返回空指针。

===参数===
{{par begin}}
{{par|p|需要访问其删除器的共享指针}}
{{par end}}

===返回值===
指向所拥有的删除器的指针或 {{ltt|cpp/language/nullptr}}。只要至少还有一个 {{lc|std::shared_ptr|shared_ptr}} 实例拥有返回的指针，它就合法。

===注解===
返回的指针可能比最后一个 {{lc|std::shared_ptr|shared_ptr}} 的生存期更持久，例如，仍有剩余的 {{lc|std::weak_ptr}} 且实现在销毁整个控制块前不销毁删除器。

===示例===
{{example
|演示 {{lc|std::shared_ptr}} 删除器独立于 {{lc|std::shared_ptr|shared_ptr}} 的类型
|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;

struct Foo { int i; };
void foo_deleter(Foo* p)
{
    std::cout &lt;&lt; "调用 foo_deleter！\n";
    delete p;
}

int main()
{
    std::shared_ptr&lt;int&gt; aptr;

    {
        // 创建拥有一个 Foo 和一个删除器的 shared_ptr
        auto foo_p = new Foo;
        std::shared_ptr&lt;Foo&gt; r(foo_p, foo_deleter);
        aptr = std::shared_ptr&lt;int&gt;(r, &amp;r-&gt;i); // 别名使用构造函数
        // aptr 现在指向一个 int，但管理整个 Foo
    } // r 被销毁（不调用删除器）

    // 获得指向删除器的指针：
    if (auto del_p = std::get_deleter&lt;void(*)(Foo*)&gt;(aptr))
    {
        std::cout &lt;&lt; "shared_ptr&lt;int&gt; 拥有一个删除器\n";
        if(*del_p == foo_deleter)
            std::cout &lt;&lt; "...而且它等于 &amp;foo_deleter\n";
    }
    else
        std::cout &lt;&lt; "shared_ptr&lt;int&gt; 的删除器为空！\n";
} // 于此调用删除器
|output=
shared_ptr&lt;int&gt; 拥有一个删除器
...而且它等于 &amp;foo_deleter
调用 foo_deleter！
}}

===参阅===
{{dsc begin}}
{{dsc mem ctor|cpp/memory/shared_ptr/shared_ptr |{{lc|std::shared_ptr}} 构造函数}}
{{dsc inc|cpp/memory/unique_ptr/dsc get_deleter}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}