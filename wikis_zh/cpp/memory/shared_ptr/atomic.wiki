{{cpp/title|atomic_...{{dsc small|&lt;std::shared_ptr&gt;}}}}
{{cpp/memory/shared_ptr/navbar}}

{{dcl begin}}
{{dcl header|memory}}
{{dcl|num=1|since=c++11|deprecated=c++20|until=c++26|1=
template&lt; class T &gt;
bool atomic_is_lock_free( const std::shared_ptr&lt;T&gt;* p );
}}
{{dcl|num=2|since=c++11|deprecated=c++20|until=c++26|1=
template&lt; class T &gt;
std::shared_ptr&lt;T&gt; atomic_load( const std::shared_ptr&lt;T&gt;* p );
}}
{{dcl|num=3|since=c++11|deprecated=c++20|until=c++26|1=
template&lt; class T &gt;
std::shared_ptr&lt;T&gt; atomic_load_explicit
    ( const std::shared_ptr&lt;T&gt;* p, std::memory_order mo );
}}
{{dcl|num=4|since=c++11|deprecated=c++20|until=c++26|1=
template&lt; class T &gt;
void atomic_store( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt; r );
}}
{{dcl|num=5|since=c++11|deprecated=c++20|until=c++26|1=
template&lt; class T &gt;
void atomic_store_explicit
    ( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt; r,
      std::memory_order mo );
}}
{{dcl|num=6|since=c++11|deprecated=c++20|until=c++26|1=
template&lt; class T &gt;
std::shared_ptr&lt;T&gt; atomic_exchange
    ( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt; r );
}}
{{dcl|num=7|since=c++11|deprecated=c++20|until=c++26|1=
template&lt; class T &gt;
std::shared_ptr&lt;T&gt; atomic_exchange_explicit
    ( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt; r,
      std::memory_order mo );
}}
{{dcl|num=8|since=c++11|deprecated=c++20|until=c++26|1=
template&lt; class T &gt;
bool atomic_compare_exchange_weak
    ( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt;* expected,
      std::shared_ptr&lt;T&gt; desired );
}}
{{dcl|num=9|since=c++11|deprecated=c++20|until=c++26|1= 
template&lt; class T &gt;
bool atomic_compare_exchange_strong
    ( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt;* expected,
      std::shared_ptr&lt;T&gt; desired );
}}
{{dcl|num=10|since=c++11|deprecated=c++20|until=c++26|1= 
template&lt; class T &gt;
bool atomic_compare_exchange_strong_explicit
    ( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt;* expected,
      std::shared_ptr&lt;T&gt; desired,
      std::memory_order success, std::memory_order failure );
}}
{{dcl|num=11|since=c++11|deprecated=c++20|until=c++26|1= 
template&lt; class T &gt;
bool atomic_compare_exchange_weak_explicit
    ( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt;* expected,
      std::shared_ptr&lt;T&gt; desired,
      std::memory_order success, std::memory_order failure );
}}
{{dcl end}}

如果多个执行线程无同步地访问同一 {{lc|std::shared_ptr}} 对象，而其中由任何访问使用了 {{lc|shared_ptr}} 的非 const 成员函数，那么就会发生数据竞争，除非所有这种访问都通过这些作为对应原子访问函数（{{lc|std::atomic_load}}、{{lc|std::atomic_store}} 等）重载的函数进行。

注意 {{tt|shared_ptr}} 的控制块是线程安全的：多个线程能同时用可改操作访问不同的 {{lc|std::shared_ptr}} 对象，如 {{c/core|1=operator=}} 或 {{tt|reset}}，即使这些实例都是副本，并内部共享同一控制块也是如此。

@1@ 确定到 {{c|p}} 指向的共享指针的原子访问是否无锁。

@2@ 等价于 {{c|atomic_load_explicit(p, std::memory_order_seq_cst)}}。

@3@ 返回 {{c|p}} 指向的共享指针。
@@ 与未特化的 {{lc|std::atomic_load_explicit}} 相同，如果 {{c|mo}} 是 {{c|std::memory_order_release}} 或 {{c|std::memory_order_acq_rel}}，那么行为未定义。

@4@ 等价于 {{c|atomic_store_explicit(p, r, std::memory_order_seq_cst)}}。

@5@ 将共享指针 {{c|r}} 原子地存储到 {{c|p}} 指向的共享指针，{{lt|cpp/language/as if|如同}}执行 {{c|p-&gt;swap(r)}}。
@@ 与未特化的 {{lc|std::atomic_load_explicit}} 相同，如果 {{c|mo}} 是 {{c|std::memory_order_acquire}} 或 {{c|std::memory_order_acq_rel}}，那么行为未定义。

@6@ 等价于 {{c|atomic_exchange_explicit(p, r, std::memory_order_seq_cst)}}。

@7@ 将共享指针 {{c|r}} 原子地存储到 {{c|p}} 指向的共享指针，并返回 {{c|p}} 先前指向的值。{{lt|cpp/language/as if|如同}}执行 {{c|p-&gt;swap(r)}} 并返回交换后 {{c|r}} 的副本。

@8@ 等价于
@@ {{c multi
|atomic_compare_exchange_weak_explicit
|    (p, expected, desired, std::memory_order_seq_cst,
|                           std::memory_order_seq_cst)}}。

@9@ 等价于
@@ {{c multi
|atomic_compare_exchange_strong_explicit
|    (p, expected, desired, std::memory_order_seq_cst,
|                           std::memory_order_seq_cst)}}。

@10,11@ 比较 {{c|p}} 和 {{c|expected}} 指向的共享指针。
* 如果它们等价（存储同一指针值，共享同一对象的所有权或均为空），那么用 {{c|success}} 指定的内存定序制约将 {{c|desired}} 赋给 {{c|*p}} 并返回 {{c|true}}。
* 如果它们不等价，那么用 {{c|failure}} 指定的内存定序制约将 {{c|*p}} 赋给 {{c|*expected}} 并返回 {{c|false}}。
@@ {{tt|atomic_compare_exchange_weak_explicit}} 可能会虚假地失败。
@@ 如果 {{c|exptected}} 是空指针，或者 {{c|failure}} 是 {{c|std::memory_order_release}} 或 {{c|std::memory_order_acq_rel}}，那么行为未定义。

如果 {{c|p}} 是空指针，那么这些函数的行为均未定义。

===参数===
{{par begin}}
{{par|p, expected|指向 {{lc|std::shared_ptr}} 的指针}}
{{par|r, desired|一个 {{lc|std::shared_ptr}}}}
{{par|mo, success, failure|{{lc|std::memory_order}} 类型的内存定序选择符}}
{{par end}}

===异常===
这些函数不会抛出异常。

===返回值===
@1@ 在原子访问使用无锁指令时返回 {{c|true}}。
@2,3@ 被指向的共享指针的副本。
@4,5@ （无）
@6,7@ 先前被指向的共享指针的副本
@8-11@ 在共享指针等价并进行了交换时返回 {{c|true}}，否则返回 {{c|false}}。

===注解===
这些函数典型地利用互斥体实现，互斥体存储于一个全局散列表中，其中以指针值为键。

[[cpp/experimental/concurrency|并发 TS]] 提供原子智能指针类 {{tt|atomic_shared_ptr}} 和 {{tt|atomic_weak_ptr}} 作为使用这些函数的替代品。

{{rrev multi|since1=c++20|until1=c++26|rev1=
这些函数被弃用，取代者是 {{lc|std::atomic}} 模板的特化：{{c/core|std::atomic&lt;std::shared_ptr&gt;}} 和 {{c/core|std::atomic&lt;std::weak_ptr&gt;}}。
|rev2=
这些函数被删除，取代者是 {{lc|std::atomic}} 模板的特化：{{c/core|std::atomic&lt;std::shared_ptr&gt;}} 和 {{c/core|std::atomic&lt;std::weak_ptr&gt;}}。
}}

===示例===
{{example}} &lt;!-- 从 http://stackoverflow.com/a/16617935/273767 适配 --&gt;

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2172|std=C++11|before={{c|expected}} 可以是空指针|after=此时行为未定义}}
{{dr list item|wg=lwg|dr=2980|std=C++11|before=空的 {{tt|shared_ptr}} 决不等价|after=在它们存储同一指针值的情况下等价}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/atomic/dsc atomic_is_lock_free}}
{{dsc inc|cpp/atomic/dsc atomic_store}}
{{dsc inc|cpp/atomic/dsc atomic_load}}
{{dsc inc|cpp/atomic/dsc atomic_exchange}}
{{dsc inc|cpp/atomic/dsc atomic_compare_exchange}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}