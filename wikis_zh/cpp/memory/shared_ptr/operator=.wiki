{{cpp/memory/shared_ptr/title|operator{{=}}}}
{{cpp/memory/shared_ptr/navbar}}
{{dcl begin}}
{{dcl|num=1|1= 
shared_ptr&amp; operator=( const shared_ptr&amp; r ) noexcept;
}}
{{dcl|num=2|1= 
template&lt; class Y &gt; 
shared_ptr&amp; operator=( const shared_ptr&lt;Y&gt;&amp; r ) noexcept;
}}
{{dcl|num=3|1= 
shared_ptr&amp; operator=( shared_ptr&amp;&amp; r ) noexcept;
}}
{{dcl|num=4|1= 
template&lt; class Y &gt; 
shared_ptr&amp; operator=( shared_ptr&lt;Y&gt;&amp;&amp; r ) noexcept;
}}
{{dcl|num=5|deprecated=c++11|until=c++17|1= 
template&lt; class Y &gt; 
shared_ptr&amp; operator=( std::auto_ptr&lt;Y&gt;&amp;&amp; r );
}}
{{dcl|num=6|1= 
template&lt; class Y, class Deleter &gt; 
shared_ptr&amp; operator=( std::unique_ptr&lt;Y, Deleter&gt;&amp;&amp; r );
}}
{{dcl end}}

以 {{c|r}} 所管理者替换被管理对象。

若 {{c|*this}} 已拥有对象且它是最后一个拥有该对象的 {{tt|shared_ptr}}，且 {{c|r}} 与 {{c|*this}} 不相同，则通过所拥有的删除器销毁对象。

@1,2@ 共享 {{c|r}} 所管理对象的所有权。若 {{c|r}} 不管理对象，则 {{c|*this}} 亦不管理对象。等价于 {{c|shared_ptr&lt;T&gt;(r).swap(*this)}}。

@3,4@ 从 {{c|r}} 移动赋值 {{tt|shared_ptr}}。赋值后，{{c|*this}} 含有先前 {{c|r}} 状态的副本，而 {{c|r}} 为空，等价于 {{c|shared_ptr&lt;T&gt;(std::move(r)).swap(*this)}}。

@3@ 转移 {{c|r}} 所管理对象的所有权给 {{c|*this}}。若 {{c|r}} 不管理对象，则 {{c|*this}} 亦不管理对象。赋值后，{{c|*this}} 含有先前 {{c|r}} 所保有的对象，且 {{c|1=use_count() == 1}}；而 {{c|r}} 为空。等价于 {{c|shared_ptr&lt;T&gt;(r).swap(*this)}}。

@4@ 转移 {{c|r}} 所管理对象的所有权给 {{c|*this}}。为将来删除被管理对象，存储 {{c|r}} 所关联的删除器。调用后 {{c|r}} 不管理对象。等价于 {{c|shared_ptr&lt;T&gt;(std::move(r)).swap(*this)}}。

===参数===
{{par begin}}
{{par|r|要获得所有权或共享所有权的另一智能指针}}
{{par end}} 

===返回值===
{{c|*this}}

===注解===
实现可以满足要求而无需创建临时的 {{tt|shared_ptr}} 对象。

===异常===
@5,6@ {{cpp/impldef exception item}}

===示例===
{{example
|code=
|output=
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/shared_ptr/dsc reset}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}