{{cpp/memory/shared_ptr/title|use_count}}
{{cpp/memory/shared_ptr/navbar}}
{{ddcl|
long use_count() const noexcept;
}}

返回管理当前对象的不同 {{tt|shared_ptr}} 实例的数量（包含 {{c|*this}}）。若无管理对象，则返回 {{c|0}}。

多线程环境中，{{tt|use_count}} 原子地获得实例的数量（典型实现使用 {{c|std::memory_order_release}} 加载）。

===参数===
（无）

===返回值===
管理当前对象的 {{lc|std::shared_ptr}} 实例的数量，或若无被管理对象则为 {{c|0}}。

===注解===
常用用法包括
* 与 {{c|0}} 比较。若 {{tt|use_count}} 返回 0，则智能指针为''空''{{sep}}且不管理对象（无论被存储指针是否为空）。多线程环境中，这不隐含被管理对象的析构函数已完成。
* 与 {{c|1}} 比较。若 {{tt|use_count}} 返回 1，则无其他共享拥有者。{{rev inl|until=c++20|被{{rev inl|since=c++17|弃用}}的成员函数 {{lc|unique()}} 用于支持此用法。}}

多线程环境中

{{tt|use_count}} 返回的值应被认做近似值，因为在原子地获取值，到有意义地使用值期间，共享拥有者的数量可能在其他线程中改变。当 {{tt|use_count}} 返回 1 时，不隐含对象可以安全修改，因为先前拥有者对被管理对象的访问可能未完成，而新的共享拥有者可以在其他线程中创建，例如使用 {{lc|std::weak_ptr::lock}}。只有当 {{tt|use_count}} 返回 0 时，数量才是准确的。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;

void fun(std::shared_ptr&lt;int&gt; sp)
{
    std::cout &lt;&lt; "in fun(): sp.use_count() == " &lt;&lt; sp.use_count()
              &lt;&lt; " (object @ " &lt;&lt; sp &lt;&lt; ")\n";
}

int main()
{
    auto sp1 = std::make_shared&lt;int&gt;(5);
    std::cout &lt;&lt; "in main(): sp1.use_count() == " &lt;&lt; sp1.use_count()
              &lt;&lt; " (object @ " &lt;&lt; sp1 &lt;&lt; ")\n";

    fun(sp1);
}
|p=true
|output=
in main(): sp1.use_count() == 1 (object @ 0x20eec30)
in fun(): sp.use_count() == 2 (object @ 0x20eec30)
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/shared_ptr/dsc unique}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}