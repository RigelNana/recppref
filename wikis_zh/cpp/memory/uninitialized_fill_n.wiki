{{cpp/title|uninitialized_fill_n}}
{{cpp/memory/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcla|num=1|constexpr=c++26|
template&lt; class NoThrowForwardIt, class Size, class T &gt;
NoThrowForwardIt uninitialized_fill_n( NoThrowForwardIt first,
                                       Size count, const T&amp; value );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy,
          class NoThrowForwardIt, class Size, class T &gt;
NoThrowForwardIt uninitialized_fill_n( ExecutionPolicy&amp;&amp; policy,
                                       NoThrowForwardIt first,
                                       Size count, const T&amp; value );
}}
{{dcl end}}

@1@ 如同用以下方式将 {{c|value}} 复制到未初始化内存区域 {{counted range|first|count}}：
{{box|
{{c/core|for (; count--; ++first)}}&lt;br&gt;
{{nbspt|4}}{{c/core|::new (}}{{rlpi|voidify}}{{c/core|(*first))}}&lt;br&gt;
{{nbspt|8}}{{c/core|typename std::iterator_traits&lt;NoThrowForwardIt&gt;::value_type(value);}}&lt;br&gt;
{{c/core|return first;}}
}}
@@ 如果初始化中抛出了异常，那么以未指定的顺序销毁已构造的对象。

@2@ 同 {{v|1}}，但按照 {{c|policy}} 执行。
@@ {{cpp/algorithm/parallel overload precondition}}

===参数===
{{par begin}}
{{par|first|要初始化的元素范围起始}}
{{par|count|要构造的元素数量}}
{{par|value|构造元素所用的值}}
{{par hreq}}
{{par req named|NoThrowForwardIt|ForwardIterator}}
{{par req|通过 {{tt|NoThrowForwardIt}} 合法实例的自增、赋值、比较或间接均不可抛异常。{{rev inl|until=c++11|将 {{c/core|&amp;*}} 应用到 {{tt|NoThrowForwardIt}} 值的情况下必须产生指向它的值类型的指针。}}}}
{{par end}}

===返回值===
如上所述。

===复杂度===
与 {{c|count}} 成线性。

===异常===
{{cpp/algorithm/parallel exceptions reporting behavior}}

===注解===
{{feature test macro|__cpp_lib_raw_memory_algorithms|std=C++26|value=202411L|{{c/core|constexpr}} 的[[cpp/memory#未初始化内存算法|特化内存算法]], {{vl|1}}}}

===可能的实现===
{{eq fun|1=
template&lt;class NoThrowForwardIt, class Size, class T&gt;
constexpr NoThrowForwardIt uninitialized_fill_n(NoThrowForwardIt first,
                                                Size count, const T&amp; value)
{
    using V = typename std::iterator_traits&lt;NoThrowForwardIt&gt;::value_type;
    NoThrowForwardIt current = first;
    try
    {
        for (; count &gt; 0; ++current, (void) --count)
            ::new (static_cast&lt;void*&gt;(std::addressof(*current))) V(value);
        return current;
    }
    catch (...)
    {
        for (; first != current; ++first)
            first-&gt;~V();
        throw;
    }
    return current;
}
}}

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

int main()
{
    std::string* p;
    std::size_t sz;
    std::tie(p, sz) = std::get_temporary_buffer&lt;std::string&gt;(4);
    std::uninitialized_fill_n(p, sz, "Example");
    
    for (std::string* i = p; i != p + sz; ++i)
    {
        std::cout &lt;&lt; *i &lt;&lt; '\n';
        i-&gt;~basic_string&lt;char&gt;();
    }
    std::return_temporary_buffer(p);
}
|output=
Example
Example
Example
Example
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=866|std=C++98|before=给定 {{tt|T}} 为 {{tt|NoThrowForwardIt}} 的值类型，如果存在&lt;br&gt;{{c/core|T::operator new}}，那么程序可能会非良构|after=改用全局的布置 {{c/core|new}}}}
{{dr list item|wg=lwg|dr=1339|std=C++98|before=没有返回填充范围后的首个元素的位置|after=返回该位置}}
{{dr list item|wg=lwg|dr=2433|std=C++11|before=此算法可能被重载的 {{c/core|operator&amp;}} 劫持|after=使用 {{lc|std::addressof}}}}
{{dr list item|wg=lwg|dr=3870|std=C++20|before=此算法可能在 {{c/core|const}} 存储上创建对象|after=保持不允许}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/dsc uninitialized_fill}}
{{dsc inc|cpp/memory/ranges/dsc uninitialized_fill_n}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}