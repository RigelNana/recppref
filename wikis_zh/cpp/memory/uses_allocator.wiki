{{cpp/title|uses_allocator}}
{{cpp/memory/navbar}}
{{ddcl|header=memory|since=c++11|
template&lt; class T, class Alloc &gt;
struct uses_allocator;
}}

如果 {{tt|T}} 拥有嵌套类型 {{tt|allocator_type}}，且该类型能从 {{tt|Alloc}} 转换，那么成员常量 {{c|value}} 是 {{c|true}}。否则 {{c|value}} 是 {{c|false}}。

===辅助变量模板===
{{ddcl|since=c++17|1=
template&lt; class T, class Alloc &gt;
constexpr bool uses_allocator_v = uses_allocator&lt;T, Alloc&gt;::value;
}}

{{cpp/types/integral_constant/inherit|{{tt|T}} 使用分配器 {{tt|Alloc}}}}

===使用分配器构造===
传递分配器 {{c|alloc}} 给某类型 {{tt|T}} 的构造函数有三种约定：
* 如果 {{tt|T}} 不使用兼容的分配器（{{lc|std::uses_allocator_v&lt;T, Alloc&gt;}} 是 {{c|false}}），那么就会忽略 {{c|alloc}}。
* 否则 {{lc|std::uses_allocator_v&lt;T, Alloc&gt;}} 是 {{c|true}}，而
:* 如果 {{tt|T}} 使用''前导分配器约定''（可用 {{c|T(std::allocator_arg, alloc, args...)}} 调用），那么使用分配器构造使用此形式。
:* 如果 {{tt|T}} 使用''尾随分配器约定''（可用 {{c|T(args..., alloc)}} 调用），那么使用分配器构造使用此形式。
:* 否则，程序非良构（这表示 {{c|std::uses_allocator_v&lt;T, Alloc&gt;}} 是 {{c|true}}，但类型不遵守两种允许的约定之一）。
* 作为特例，{{lc|std::pair}} 被当做使用分配器类型，虽然 {{tt|std::uses_allocator}} 对 {{tt|pair}} 为 {{tt|false}}（与 {{lc|std::tuple}} 等不同）；见 {{rev inl|until=c++20|{{lc|std::polymoprhic_allocator::construct}} 与 {{lc|std::scoped_allocator_adaptor::construct}}}}{{rev inl|since=c++20|{{lc|std::uses_allocator_construction_args}}}} 的 {{tt|pair}} 特定重载。

{{rrev|since=c++20|
工具函数 {{lc|std::make_obj_using_allocator}} 和 {{lc|std::uninitialized_construct_using_allocator}} 可用于显式创建遵循上述协议的对象，而 {{lc|std::uses_allocator_construction_args}} 能用于准备匹配类型所期待的使用分配器构造的形式的实参列表。
}}

===特化===
给定某个没有嵌套 {{tt|allocator_type}} 的{{ls|cpp/language/type#由程序定义的类型}} {{tt|T}}，只要满足以下任意条件，程序就可以为 {{tt|T}} 特化 {{tt|std::uses_allocator}}，使其从 {{lc|std::true_type}} 派生：
* {{tt|T}} 拥有接收 {{lc|std::allocator_arg_t}} 为首个实参，{{tt|Alloc}} 为第二实参的构造函数。
* {{tt|T}} 拥有接收 {{tt|Alloc}} 为最后实参的构造函数。

上述情况中，{{tt|Alloc}} 是满足{{named req|Allocator}}要求的类型{{rev inl|since=libfund_ts|，或是可转换到 {{lc|std::experimental::pmr::memory_resource*}} 的指针类型}}。

标准库已提供下列特化：
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc uses_allocator}}
{{dsc inc|cpp/container/dsc uses_allocator|queue}}
{{dsc inc|cpp/container/dsc uses_allocator|priority_queue}}
{{dsc inc|cpp/container/dsc uses_allocator|stack}}
{{dsc inc|cpp/container/dsc uses_allocator|flat_map}}
{{dsc inc|cpp/container/dsc uses_allocator|flat_set}}
{{dsc inc|cpp/container/dsc uses_allocator|flat_multimap}}
{{dsc inc|cpp/container/dsc uses_allocator|flat_multiset}}
{{dsc inc|cpp/utility/functional/function/dsc uses_allocator}}
{{dsc inc|cpp/thread/promise/dsc uses_allocator}}
{{dsc inc|cpp/thread/packaged_task/dsc uses_allocator}}
{{dsc end}}

===注解===
{{lc|std::tuple}}、{{lc|std::scoped_allocator_adaptor}} 和 {{lc|std::pmr::polymorphic_allocator}} 使用这个类型特征。自定义分配器或封装类型也可以使用它，以确定要构造的对象或成员是否有能力使用分配器（例如是容器的情况），该情况下应传递分配器给它的构造函数。

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/dsc allocator_arg}}
{{dsc inc|cpp/memory/dsc uses_allocator_construction_args}}
{{dsc inc|cpp/memory/dsc make_obj_using_allocator}}
{{dsc inc|cpp/memory/dsc uninitialized_construct_using_allocator}}
{{dsc inc|cpp/memory/dsc scoped_allocator_adaptor}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}