{{cpp/title|scoped_allocator_adaptor}}
{{cpp/memory/scoped_allocator_adaptor/navbar}}
{{ddcl|header=scoped_allocator|since=c++11|1=
template&lt; class OuterAlloc, class... InnerAllocs &gt;
class scoped_allocator_adaptor
    : public OuterAlloc;
}}

{{tt|std::scoped_allocator_adaptor}} 类模板是可用于多层容器（比如 map 的 tuple 的 list 的 set 的 vector 等等）的分配器。它以外层分配器类型 {{tt|OuterAlloc}} 与零或更多个内层分配器类型 {{tt|InnerAlloc...}} 实例化。直接以 {{tt|scoped_allocator_adaptor}} 构造的容器用 {{tt|OuterAlloc}} 分配其元素，但若元素自身是容器，则它使用首个内存分配器。该容器的元素，若其自身是容器，则使用第二个内存分配器，以此类推。若容器的层级多于内层分配器的数量，则最内层分配器为所有进一步内嵌的容器再度使用。

此适配器的目的是在内嵌容器中正确初始化有状态分配器，例如在所有层次的嵌套容器都必须置于同一共享内存段时。适配器的构造函数接收列表中所有分配器的参数，而每个内嵌容器从适配器按需获得其分配器的状态。

为了 {{tt|scoped_allocator_adaptor}} 的目的，若下个内层分配器是 {{tt|A}}，则任何满足 {{c|1=std::uses_allocator&lt;T,A&gt;::value == true}} 的类 {{tt|T}} 如同它是容器一样参与递归，另外，{{lc|std::pair}} 通过 {{l2tt|cpp/memory/scoped_allocator_adaptor/construct}} 的特定重载亦被当做这种容器。

典型实现保有一个 {{tt|std::scoped_allocator_adaptor&lt;InnerAllocs...&gt;}} 作为成员对象。

注意，{{ltt|cpp/memory/polymorphic_allocator|std::pmr::polymorphic_allocator}} 遵循{{lsd|cpp/memory/uses allocator#使用分配器构造}}传播给嵌套容器，而无需 {{tt|std::scoped_allocator_adaptor}}（且无法与其合作）。

===成员类型===
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc|{{tt|outer_allocator_type}}|{{tt|OuterAlloc}}}}
{{dsc|{{tt|inner_allocator_type}}|
* {{c|1=sizeof...(OuterAlloc)}} 为零时是 {{c/core|scoped_allocator_adaptor&lt;InnerAllocs...&gt;}}
* 否则是 {{c/core|scoped_allocator_adaptor&lt;InnerAllocs&gt;}}}}
{{dsc|{{tt|value_type}}|{{c/core|std::allocator_traits&lt;OuterAlloc&gt;::value_type}}}}
{{dsc|{{tt|size_type}}|{{c/core|std::allocator_traits&lt;OuterAlloc&gt;::size_type}}}}
{{dsc|{{tt|difference_type}}|{{c/core|std::allocator_traits&lt;OuterAlloc&gt;::difference_type}}}}
{{dsc|{{tt|pointer}}|{{c/core|std::allocator_traits&lt;OuterAlloc&gt;::pointer}}}}
{{dsc|{{tt|const_pointer}}|{{c/core|std::allocator_traits&lt;OuterAlloc&gt;::const_pointer}}}}
{{dsc|{{tt|void_pointer}}|{{c/core|std::allocator_traits&lt;OuterAlloc&gt;::void_pointer}}}}
{{dsc|{{tt|const_void_pointer}}|{{c/core|std::allocator_traits&lt;OuterAlloc&gt;::const_void_pointer}}}}
{{dsc end}}


给定包含 {{tt|OuterAlloc}} 和 {{tt|InnerAlloc...}} 的所有类型的集合为 {{tt|Allocs}}：
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc|{{tt|propagate_on_container_copy_assignment}}|
* {{tt|Allocs}} 中存在类型 {{tt|A}} 使得 {{c multi|std::allocator_traits&lt;A&gt;::|    propagate_on_container_copy_assignment::value}} 是 {{c|true}} 时是 {{lc|std::true_type}}
* 否则是 {{lc|std::false_type}}}}
{{dsc|{{tt|propagate_on_container_move_assignment}}|
* {{tt|Allocs}} 中存在类型 {{tt|A}} 使得 {{c multi|std::allocator_traits&lt;A&gt;::|    propagate_on_container_move_assignment::value}} 是 {{c|true}} 时是 {{lc|std::true_type}}
* 否则是 {{lc|std::false_type}}}}
{{dsc|{{tt|propagate_on_container_swap}}|
* {{tt|Allocs}} 中存在类型 {{tt|A}} 使得 {{c multi|std::allocator_traits&lt;A&gt;::|    propagate_on_container_swap::value}} 是 {{c|true}} 时是 {{lc|std::true_type}}
* 否则是 {{lc|std::false_type}}}}
{{dsc|{{tt|is_always_equal}}|
* {{tt|Allocs}} 中存在类型 {{tt|A}} 使得 {{c multi|std::allocator_traits&lt;A&gt;::|    is_always_equal::value}} 是 {{c|true}} 时是 {{lc|std::true_type}}
* 否则是 {{lc|std::false_type}}}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/memory/scoped_allocator_adaptor/dsc scoped_allocator_adaptor}}
{{dsc inc|cpp/memory/scoped_allocator_adaptor/dsc ~scoped_allocator_adaptor}}
{{dsc inc|cpp/memory/scoped_allocator_adaptor/dsc operator{{=}}}}
{{dsc inc|cpp/memory/scoped_allocator_adaptor/dsc inner_allocator}}
{{dsc inc|cpp/memory/scoped_allocator_adaptor/dsc outer_allocator}}
{{dsc inc|cpp/memory/scoped_allocator_adaptor/dsc allocate}}
{{dsc inc|cpp/memory/scoped_allocator_adaptor/dsc deallocate}}
{{dsc inc|cpp/memory/scoped_allocator_adaptor/dsc max_size}}
{{dsc inc|cpp/memory/scoped_allocator_adaptor/dsc construct}}
{{dsc inc|cpp/memory/scoped_allocator_adaptor/dsc destroy}}
{{dsc inc|cpp/memory/scoped_allocator_adaptor/dsc select_on_container_copy_construction}}
{{dsc h2|仅用于阐述的函数模板}}
{{dsc expos mem fun|cpp/memory/scoped_allocator_adaptor/helpers|title=''outermost''|获取最外层分配器}}
{{dsc expos mem fun|cpp/memory/scoped_allocator_adaptor/helpers|title=''outermost-construct''|使用最外层分配器构造对象}}
{{dsc expos mem fun|cpp/memory/scoped_allocator_adaptor/helpers|title=''outermost-destroy''|使用最外层分配器销毁对象}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/memory/scoped_allocator_adaptor/dsc operator cmp}}
{{dsc end}}

===[[cpp/memory/scoped_allocator_adaptor/deduction_guides|推导指引]]{{mark since c++17}}===

===嵌套类===
{{dsc begin}}
{{dsc hitem|类|定义}}
{{dsc|{{tt|rebind}}{{nbsp}}|{{c|
template&lt; class T &gt;
struct rebind
{
    using other {{=}} scoped_allocator_adaptor
                      &lt;std::allocator_traits&lt;OuterAlloc&gt;::template rebind_alloc&lt;T&gt;, 
                       InnerAllocs...&gt;;
};
}}
}}
{{dsc end}}

===示例===
{{example
|code=
#include &lt;boost/interprocess/allocators/adaptive_pool.hpp&gt;
#include &lt;boost/interprocess/managed_shared_memory.hpp&gt;
#include &lt;scoped_allocator&gt;
#include &lt;vector&gt;

namespace bi = boost::interprocess;

template&lt;class T&gt;
using alloc = bi::adaptive_pool&lt;T, bi::managed_shared_memory::segment_manager&gt;;

using ipc_row = std::vector&lt;int, alloc&lt;int&gt;&gt;;

using ipc_matrix = std::vector&lt;ipc_row, std::scoped_allocator_adaptor&lt;alloc&lt;ipc_row&gt;&gt;&gt;;

int main()
{
    bi::managed_shared_memory s(bi::create_only, "Demo", 65536);
    
    // 在共享内存中创建 vector 的 vector
    ipc_matrix v(s.get_segment_manager()); 
    
    // 对于所有这些附加项，内层 vector 从外层 vector 的 scoped_allocator_adaptor
    // 获得其分配器实参
    v.resize(1);
    v[0].push_back(1);
    v.emplace_back(2);
    std::vector&lt;int&gt; local_row = {1, 2, 3};
    v.emplace_back(local_row.begin(), local_row.end());
    
    bi::shared_memory_object::remove("Demo");
}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|std=C++11|dr=2108|before=没有方法证明 {{tt|scoped_allocator_adaptor}} 是否有状态|after=提供了 {{tt|is_always_equal}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/dsc allocator_traits}}
{{dsc inc|cpp/memory/dsc uses_allocator}}
{{dsc inc|cpp/memory/dsc allocator}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}