{{title|{{small|operator}} delete{{small|, operator}} delete[]}}
{{cpp/memory/new/navbar}}
{{dcl begin}}
{{dcl header|new}}
{{dcl h|可替换的常规解分配函数}}
{{dcl rev multi|num=1|anchor=1|until1=c++11
|dcl1=void operator delete  ( void* ptr ) throw();
|dcl2=void operator delete  ( void* ptr ) noexcept;
}}
{{dcl rev multi|num=2|anchor=2|until1=c++11
|dcl1=void operator delete[]( void* ptr ) throw();
|dcl2=void operator delete[]( void* ptr ) noexcept;
}}
{{dcl|num=3|since=c++17|void operator delete  ( void* ptr, std::align_val_t al ) noexcept;}}
{{dcl|num=4|since=c++17|void operator delete[]( void* ptr, std::align_val_t al ) noexcept;}}
{{dcl|num=5|since=c++14|void operator delete  ( void* ptr, std::size_t sz ) noexcept; }}
{{dcl|num=6|since=c++14|void operator delete[]( void* ptr, std::size_t sz ) noexcept; }}
{{dcl|num=7|since=c++17|void operator delete  ( void* ptr, std::size_t sz,
                        std::align_val_t al ) noexcept; }}
{{dcl|num=8|since=c++17|void operator delete[]( void* ptr, std::size_t sz,
                        std::align_val_t al ) noexcept; }}
{{dcl h|可替换的布置解分配函数}}
{{dcl rev multi|num=9|anchor=9|until1=c++11
|dcl1=void operator delete  ( void* ptr, const std::nothrow_t&amp; tag ) throw();
|dcl2=void operator delete  ( void* ptr, const std::nothrow_t&amp; tag ) noexcept;
}}
{{dcl rev multi|num=10|anchor=10|until1=c++11
|dcl1=void operator delete[]( void* ptr, const std::nothrow_t&amp; tag ) throw();
|dcl2=void operator delete[]( void* ptr, const std::nothrow_t&amp; tag ) noexcept;
}}
{{dcl|num=11|since=c++17|void operator delete  ( void* ptr, std::align_val_t al,
                        const std::nothrow_t&amp; tag ) noexcept; }}
{{dcl|num=12|since=c++17|void operator delete[]( void* ptr, std::align_val_t al,
                        const std::nothrow_t&amp; tag ) noexcept; }}
{{dcl h|不分配布置解分配函数}}
{{dcl rev multi|num=13|anchor=13|until1=c++11
|dcl1=void operator delete  ( void* ptr, void* place ) throw();
|dcl2=void operator delete  ( void* ptr, void* place ) noexcept;
}}
{{dcl rev multi|num=14|anchor=14|until1=c++11
|dcl1=void operator delete[]( void* ptr, void* place ) throw();
|dcl2=void operator delete[]( void* ptr, void* place ) noexcept;
}}
{{dcl h|用户定义的布置解分配函数}}
{{dcl|num=15|void operator delete  ( void* ptr, args... ); }}
{{dcl|num=16|void operator delete[]( void* ptr, args... ); }}
{{dcl h|类特定常规解分配函数}}
{{dcl|num=17|void T::operator delete  ( void* ptr ); }}
{{dcl|num=18|void T::operator delete[]( void* ptr ); }}
{{dcl|num=19|since=c++17|void T::operator delete  ( void* ptr, std::align_val_t al ); }}
{{dcl|num=20|since=c++17|void T::operator delete[]( void* ptr, std::align_val_t al ); }}
{{dcl|num=21|void T::operator delete  ( void* ptr, std::size_t sz ); }}
{{dcl|num=22|void T::operator delete[]( void* ptr, std::size_t sz ); }}
{{dcl|since=c++17|num=23|void T::operator delete  ( void* ptr, std::size_t sz, std::align_val_t al ); }}
{{dcl|since=c++17|num=24|void T::operator delete[]( void* ptr, std::size_t sz, std::align_val_t al ); }}
{{dcl h|类特定布置解分配函数}}
{{dcl|num=25|void T::operator delete  ( void* ptr, args... ); }}
{{dcl|num=26|void T::operator delete[]( void* ptr, args... ); }}
{{dcl h|类特定销毁解分配函数}}
{{dcl|num=27|since=c++20|void T::operator delete( T* ptr, std::destroying_delete_t);}}
{{dcl|num=28|since=c++20|void T::operator delete( T* ptr, std::destroying_delete_t,
                         std::align_val_t al );}}
{{dcl|num=29|since=c++20|void T::operator delete( T* ptr, std::destroying_delete_t, std::size_t sz );}}
{{dcl|num=30|since=c++20|void T::operator delete( T* ptr, std::destroying_delete_t,
                         std::size_t sz, std::align_val_t al );}}
{{dcl end}}

解分配先前由匹配的 {{lc|operator new}} 所分配的存储。这些解分配函数会被 [[cpp/language/delete|{{c/core|delete}}、{{c/core|delete[]}}]] 和[[cpp/language/new#布置new|布置 {{c/core|new}} 表达式]]调用，以在析构（或构造失败）拥有动态存储期的对象后解分配内存。它们也可以用常规函数调用语法调用。

@1-12@ [[cpp/language/replacement function|可替换]]的解分配函数。标准库会为这些函数提供默认实现，默认实现的效果见[[#全局替换|下文]]。

:@1-8@ 被 {{c/core|delete}} 表达式调用。使所有非空 {{c|ptr}} 失效。

:@9-12@ 被布置 {{c/core|new}} 表达式在{{ls|cpp/language/new#初始化失败}}时调用。{{c/core|operator delete[]}} 会使所有非空 {{c|ptr}} 失效。

: 如果 {{c|ptr}} 不是空指针，并且满足以下任一条件，那么行为未定义：
:* 对于 {{c/core|operator delete}}，{{c|ptr}} 的值表示的不是由先前的某次对（可能被替换的）{{c/core|operator new(std::size_t)}}（对于重载 {{v|1,5,9}}）或 {{c/core|operator new(std::size_t, std::align_val_t)}}（对于重载 {{v|3,7,11}}）调用分配的且尚未因其他 {{c/core|operator delete}} 调用而失效的内存块。
:* 对于 {{c/core|operator delete[]}}，{{c|ptr}} 的值表示的不是由先前的某次对（可能被替换的）{{c/core|operator new[](std::size_t)}}（对于重载 {{v|1,5,9}}）或 {{c/core|operator new[](std::size_t, std::align_val_t)}}（对于重载 {{v|3,7,11}}）调用分配的且尚未因其他 {{c/core|operator delete[]}} 调用而失效的内存块。

@13,14@ 在有调用{{rlp|operator new#版本 9|不分配布置分配函数}}的布置 {{c/core|new}} 表达式中，在初始化因抛出异常而终止时被该表达式调用。不进行任何操作。

@15-30@ 被 {{c/core|delete}}、{{c/core|delete[]}} 和布置 {{c/core|new}} 表达式调用的用户定义解分配函数。

@27-30@ 有定义时 {{c/core|delete}} 表达式在调用 {{c/core|operator delete}} 前不会对 {{c|*ptr}} 执行析构函数。析构函数改为由此 {{c/core|operator delete}} 负责直接调用，例如用 {{c|ptr-&gt;~T();}}。

即使不包含标头 {{header|new}}，重载 {{vl|1-8}} 也会在每个翻译单元隐式声明。

选择重载的标准见 [[cpp/language/delete|{{c/core|delete}} 表达式]]。

===参数===
{{par begin}}
{{par|ptr|指向要解分配的内存块的指针或空指针}}
{{par|sz|传递给匹配的分配函数的大小}}
{{par|place|用作匹配的布置 new 中布置参数的指针}}
{{par|tag|匹配不抛出 operator new 所用标签的重载消歧义标签}}
{{par|al|被分配的对象或数组元素的对齐}}
{{par|args|匹配布置分配函数的任意参数（可包含 {{lc|std::size_t}} 与 {{lc|std::align_val_t}}）}}
{{par end}}

===异常===
{{rrev|since=c++11|所有解分配函数均为 {{c/core|noexcept(true)}}，除非在声明中另外说明。}}
如果解分配函数以抛异常终止，那么行为未定义{{rev inl|since=c++11|，即使它以 {{c/core|noexcept(false)}} 声明}}。

===全局替换===
重载 {{vl|1-8}} [[cpp/language/replacement function|可以替换]]。默认版本的效果如下：

@1@ 如果 {{c|ptr}} 为空，那么什么也不做。否则回收先前 {{c/core|operator new}} 调用分配的存储。

@2@ 调用 {{c|operator delete(ptr)}}，此时重载 {{v|1}} 如同可以回收先前 {{c/core|operator new[]}} 调用分配的存储。

@3@ 同 {{v|1}}。

@4@ 调用 {{c|operator delete(ptr, al)}}，此时重载 {{v|3}} 如同可以回收先前 {{c/core|operator new[]}} 调用分配的存储。

@5@ 调用 {{c|operator delete(ptr)}}。

@6@ 调用 {{c|operator delete[](ptr)}}。

@7@ 调用 {{c|operator delete(ptr, al)}}。

@8@ 调用 {{c|operator delete[](ptr, al)}}。

@9@ 调用 {{c|operator delete(ptr)}}。

@10@ 调用 {{c|operator delete[](ptr)}}。

@11@ 调用 {{c|operator delete(ptr, al)}}。

@12@ 调用 {{c|operator delete[](ptr, al)}}。

{{cpp/memory/new/minimal replacement example}}

{{c/core|operator delete}} 与 {{c/core|operator delete[]}} 带额外用户定义形参的重载（“布置形式”，{{vl|15,16}}）可照常在全局作用域声明，而且会被匹配的布置形式 {{c/core|new}} 表达式在所分配的对象的构造函数抛出异常时调用。

{{c/core|operator delete}} 与 {{c/core|operator delete[]}} 的标准库布置形式 {{vl|13,14}} 不能替换，而且只有在布置 {{c/core|{{c/core|new}} 表达式不使用 {{c/core|::new}} 时语法才能被自定义，通过提供拥有匹配签名的类特定布置 delete {{vl|25,26}}：{{c/core|void T::operator delete(void*, void*)}} 或 {{c/core|void T::operator delete[](void*, void*)}}。

===类特定重载===
解分配函数 {{v|17-24|17}} 可定义为类的静态成员函数。如果提供这些解分配函数，那么它们被 {{c/core|delete}} 表达式在删除此类的对象 {{vl|17,19,21}} 和数组 {{vl|18,20,22}} 时调用，除非 {{c/core|delete}} 表达式使用跳过类作用域查找的形式 {{c/core|::delete}}。关键词 {{c/core|static}} 对这些函数声明是可选的：不管是否使用该关键词，解分配函数都始终是静态成员函数。

{{c/core|delete}} 表达式从类作用域开始查找适当的解分配函数名（数组形式在数组元素类的作用域查找），然后在找不到成员时再继而照常寻找全局作用域。注意，同每个[[cpp/language/lookup|名称查找规则]]，在类作用域声明的任何解分配函数都会隐藏所有全局解分配函数。

如果正在删除的对象的静态类型和动态类型不同（例如通过指向基类的指针删除一个[[cpp/language/object|多态]]对象），且静态类型中的析构函数是虚的，那么 delete 的单对象形式从它的虚析构函数的最终覆盖者的定义点开始查找解分配函数的名称。无关乎运行时会执行哪个析构函数，为了能够编译，{{c/core|operator delete}} 的静态可见版本必须可访问。其他情况下，当通过指向基类的指针删除数组，或通过带非虚析构函数的指针删除时，行为未定义。

如果未提供单参数重载 {{vl|17,18}}，但提供接收 {{lc|std::size_t}} 为第二形参的具大小重载 {{vl|21,22}}，那么正常解分配调用具大小形式，且 C++ 运行时传递要被解分配的对象大小为第二实参。如果定义两种形式，那么调用不具大小的版本。

{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;

// 指定大小的类特定解分配函数
struct X
{
    static void operator delete(void* ptr, std::size_t sz)
    {
        std::cout &lt;&lt; "自定义 delete，大小是 " &lt;&lt; sz &lt;&lt; '\n';
        ::operator delete(ptr);
    }
    
    static void operator delete[](void* ptr, std::size_t sz)
    {
        std::cout &lt;&lt; "自定义 delete，大小是 " &lt;&lt; sz &lt;&lt; '\n';
        ::operator delete(ptr);
    }
};

int main()
{
    X* p1 = new X;
    delete p1;
    
    X* p2 = new X[10];
    delete[] p2;
}
|p=true
|output=
自定义 delete，大小是 1
自定义 delete，大小是 18
}}

带额外用户定义形参的 {{c/core|operator delete}} 与 {{c/core|operator delete[]}}（“布置形式”，{{v|25,26|25}}）也可以定义为类成员。在失败的布置 {{c/core|new}} 表达式查找将调用的对应布置 {{c/core|delete}} 函数时，它首次从类作用域开始，在全局作用域之前查找，并且查找匹配布置 {{c/core|new}} 签名的函数：

{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

struct X
{
    X() { throw std::runtime_error("X(): std::runtime_error"); }
    
    // 自定义布置 new
    static void* operator new(std::size_t sz, bool b)
    {
        std::cout &lt;&lt; "已调用自定义布置 new，b = " &lt;&lt; b &lt;&lt; '\n';
        return ::operator new(sz);
    }
    
    // 自定义布置 delete
    static void operator delete(void* ptr, bool b)
    {
        std::cout &lt;&lt; "已调用自定义布置 delete，b = " &lt;&lt; b &lt;&lt; '\n';
        ::operator delete(ptr);
    }
};

int main()
{
    try
    {
        [[maybe_unused]] X* p1 = new (true) X;
    }
    catch (const std::exception&amp; ex)
    {
        std::cout &lt;&lt; ex.what() &lt;&lt; '\n';
    }
}
|output=
已调用自定义布置 new，b = 1
已调用自定义布置 delete，b = 1
X(): std::runtime_error
}}

如果类级别的 {{c/core|operator delete}} 是模板函数，那么它的返回类型必须是 {{c/core|void}}，首个实参必须是 {{c/core|void*}}，而且必须拥有两个或更多形参。换言之，只有布置形式可以是模板。模板实例始终不是常规解分配函数，无论其签名如何。模板 {{c/core|operator delete}} 的特化由[[cpp/language/template argument deduction|模板实参推导]]选择。

===注解===
在多态类上调用类特定的 {{c/core|T::operator delete}} 是仅有的通过动态派发调用静态成员函数的情况。

{{cpp/memory/thread safety note}}
{{ftm begin|std=1|comment=1|sort=1}}
{{ftm|std=C++14|value=201309L|__cpp_sized_deallocation|具大小解分配}}
{{ftm|std=C++20|value=201806L|__cpp_impl_destroying_delete|销毁 operator delete (编译器支持)}}
{{ftm|std=C++20|value=201806L|__cpp_lib_destroying_delete|销毁 operator delete (库支持)}}
{{ftm end}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=220|std=C++98|before=允许用户定义的解分配函数抛出异常|after=从解分配函数抛出异常会导致未定义行为}}
{{dr list item|wg=cwg|dr=1438|std=C++98|before=任何非法指针值的使用都是未定义行为|after=只有间接和解分配是}}
{{dr list item|wg=lwg|dr=206|std=C++98|before=替换掉 {{vl|2}} 不会影响 {{vl|10}} 的默认行为|after=默认行为也会有相应变更}}
{{dr list item|wg=lwg|dr=298|std=C++98|before=替换掉 {{vl|1}} 不会影响 {{vl|9}} 的默认行为|after=默认行为也会有相应变更}}
&lt;!-- LWG 298 的解决方案实际上使得 (10) 的默认行为受 (9) 而不是 (2) 影响（(9) 的默认行为受 (1) 影响），后续应用的 LWG 206 的解决方案解决了这个问题。 --&gt;
{{dr list item|wg=lwg|dr=404|std=C++98|before=可替换的解分配函数在替换时可以声明为 {{c/core|inline}}|after=已禁止，不要求诊断}}
{{dr list item|wg=lwg|dr=2458|std=C++14|before=有一个接受 {{c/core|(void*, std::size_t, const}}&lt;br&gt;{{c/core|std::nothrow_t&amp;)}} 的重载，但它无法被调用|after=移除虚假重载}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/coroutine/generator/promise_type/dsc operator delete}}
{{dsc inc|cpp/memory/new/dsc operator new}}
{{dsc inc|cpp/memory/dsc return_temporary_buffer}}
{{dsc inc|cpp/memory/c/dsc free}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}