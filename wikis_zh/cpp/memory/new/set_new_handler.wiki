{{cpp/title|set_new_handler}}
{{cpp/memory/new/navbar}}
{{dcl begin}}
{{dcl header|new}}
{{dcl rev multi|until1=c++11
|dcl1=
std::new_handler set_new_handler( std::new_handler new_p ) throw();
|dcl2=
std::new_handler set_new_handler( std::new_handler new_p ) noexcept;
}}
{{dcl end}}

令 {{c|new_p}} 成为新的全局 new 处理函数并返回先前安装的 new 处理函数。

''new 处理函数''是由{{rlp|operator_new|分配函数}}在凡是内存分配尝试失败时调用的函数。其目的是三件事之一：

@1@ 令更多内存可用

@2@ 终止程序（例如通过调用 {{lc|std::terminate}}）

@3@ 抛出 {{lc|std::bad_alloc}} 或派生于 {{lc|std::bad_alloc}} 的类型的异常。

默认实现抛 {{lc|std::bad_alloc}}。用户可以安装自己的 ''new 处理函数''，并可以提供异于默认者的行为。

若 ''new 处理函数''返回，则分配函数重复先前失败的分配，并若分配再次失败则调用 ''new 处理函数''。为终止循环， ''new 处理函数''可调用 {{c|std::set_new_handler(nullptr)}}：若在失败的分配尝试后，分配函数发现 {{lc|std::get_new_handler}} 返回空指针值，则它会抛出 {{lc|std::bad_alloc}}。

在程序启动时，''new 处理函数''是空指针。

{{rrev|since=c++11|
此函数是线程安全的。每次对 {{tt|std::set_new_handler}} 的调用''同步于''（见 {{lc|std::memory_order}}）后继的 {{tt|std::set_new_handler}} 和 {{lc|std::get_new_handler}} 调用。
}}

===参数===
{{par begin}}
{{par|new_p|{{lc|std::new_handler}} 类型的指向函数指针，或空指针}}
{{par end}}

===返回值===
先前安装的 new 处理函数，或若无安装者则返回空指针。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;new&gt;

void handler()
{
    std::cout &lt;&lt; "内存分配失败，终止程序\n";
    std::set_new_handler(nullptr);
}

int main()
{
    std::set_new_handler(handler);
    try
    {
        while (true)
        {
            new int[1000'000'000ul]();
        }
    }
    catch (const std::bad_alloc&amp; e)
    {
        std::cout &lt;&lt; e.what() &lt;&lt; '\n';
    }
}
|p=true
|output=
内存分配失败，终止程序
std::bad_alloc
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/new/dsc operator_new}}
{{dsc inc|cpp/memory/new/dsc get_new_handler}}
{{dsc inc|cpp/memory/new/dsc new_handler}}
{{dsc inc|cpp/memory/new/dsc bad_alloc}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}