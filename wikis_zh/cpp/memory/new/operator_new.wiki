{{title|{{small|operator}} new{{small|, operator}} new[]}}
{{cpp/memory/new/navbar}}
{{dcl begin}}
{{dcl header|new}}
{{dcl h|可替换的分配函数}}
{{dcla|num=1|
void* operator new  ( std::size_t count );
}}
{{dcla|num=2|
void* operator new[]( std::size_t count );
}}
{{dcla|num=3|since=c++17|
void* operator new  ( std::size_t count, std::align_val_t al );
}}
{{dcla|num=4|since=c++17|
void* operator new[]( std::size_t count, std::align_val_t al );
}}
{{dcl h|可替换的不抛出分配函数}}
{{dcla|num=5|noexcept=c++11|
void* operator new  ( std::size_t count, const std::nothrow_t&amp; tag );
}}
{{dcla|num=6|noexcept=c++11|
void* operator new[]( std::size_t count, const std::nothrow_t&amp; tag );
}}
{{dcla|num=7|since=c++17|
void* operator new  ( std::size_t count, std::align_val_t al,
                      const std::nothrow_t&amp; tag ) noexcept;
}}
{{dcla|num=8|since=c++17|
void* operator new[]( std::size_t count, std::align_val_t al,
                      const std::nothrow_t&amp; tag ) noexcept;
}}
{{dcl h|不分配布置分配函数}}
{{dcla|num=9|noexcept=c++11|constexpr=c++26|
void* operator new  ( std::size_t count, void* ptr );
}}
{{dcla|num=10|noexcept=c++11|constexpr=c++26|
void* operator new[]( std::size_t count, void* ptr );
}}
{{dcl h|用户定义布置分配函数}}
{{dcla|num=11|
void* operator new  ( std::size_t count, /* 实参... */ );
}}
{{dcla|num=12|
void* operator new[]( std::size_t count, /* 实参... */ );
}}
{{dcla|num=13|since=c++17|
void* operator new  ( std::size_t count,
                      std::align_val_t al, /* 实参... */ );
}}
{{dcla|num=14|since=c++17|
void* operator new[]( std::size_t count,
                      std::align_val_t al, /* 实参... */ );
}}
{{dcl h|类特定分配函数}}
{{dcla|num=15|
void* T::operator new  ( std::size_t count );
}}
{{dcla|num=16|
void* T::operator new[]( std::size_t count );
}}
{{dcla|num=17|since=c++17|
void* T::operator new  ( std::size_t count, std::align_val_t al );
}}
{{dcla|num=18|since=c++17|
void* T::operator new[]( std::size_t count, std::align_val_t al );
}}
{{dcl h|类特定布置分配函数}}
{{dcla|num=19|
void* T::operator new  ( std::size_t count, /* 实参... */ );
}}
{{dcla|num=20|
void* T::operator new[]( std::size_t count, /* 实参... */ );
}}
{{dcla|num=21|since=c++17|
void* T::operator new  ( std::size_t count,
                         std::align_val_t al, /* 实参... */ );
}}
{{dcla|num=22|since=c++17|
void* T::operator new[]( std::size_t count,
                         std::align_val_t al, /* 实参... */ );
}}
{{dcl end}}

尝试分配请求数量的字节，而且分配请求可能会失败（即使请求分配的字节数为零）。这些分配函数会被 [[cpp/language/new|{{c/core|new}} 表达式]]调用，以分配将被初始化的对象所在的内存。它们也可以通过常规函数调用语法调用。

@1-8@ [[cpp/language/replacement function|可替换]]的分配函数。标准库会为这些函数提供默认实现，默认实现的效果见[[#全局替换|下文]]。

@9,10@ 被标准[[cpp/language/new#布置new|布置 {{c/core|new}} 表达式]]调用。不会进行任何动作并直接返回未经修改的 {{c|ptr}}。
@@ 如果通过布置 {{c/core|new}} 调用此函数而 {{c|ptr}} 是空指针，那么行为未定义。&lt;!-- CWG 1748 --&gt;

@11-22@ 被 {{c/core|new}} 表达式调用的用户定义分配函数。

即使不包含标头 {{header|new}}，重载 {{vl|1-4}} 也会在每个翻译单元隐式声明。

选择重载的标准见 [[cpp/language/new|{{c/core|new}} 表达式]]。

===参数===
{{par begin}}
{{par|count|要分配的字节数}}
{{par|ptr|指向要初始化的对象所在的内存区域的指针}}
{{par|tag|用于选择不抛出重载的消歧义标签}}
{{par|al|使用的对齐，对齐值无效时行为未定义}}
{{par end}}

===返回值===
@1-4@ 分配成功时返回指向拥有至少 {{c|size}} 大小的适当对齐的内存的非空指针 {{c|p0}}，它与之前返回的任何值 {{c|p1}} 均不相同，除非 {{c|p1}} 在返回后已经传递给了可替换的{{rlp|operator delete|解分配函数}}；分配失败时不返回（此时会抛出异常，见下文）

@5-8@ 同 {{vl|1-4}}，但在分配失败时返回空指针

@9-10@ {{c|ptr}}

@11-22@ 函数在分配失败时不返回的情况下同 {{vl|1-4}}，否则同 {{vl|5-8}}

===异常===
@1-4@ 在分配内存失败时抛出能与类型为 {{lc|std::bad_alloc}} 的处理块匹配的异常

@11-22@ 如果函数在分配失败时不返回则同 {{vl|1-4}}，否则同 {{vl|5-8}}

===全局替换===
重载 {{vl|1-8}} [[cpp/language/replacement function|可以替换]]。默认版本的效果如下：

@1@ 尝试分配请求的存储。未指定该尝试是否会涉及对 {{lc|std::malloc}} 或 {{lc|std::aligned_alloc}} 的调用。
* 如果尝试成功，那么返回到分配的存储的指针。
* 否则，如果当前没有安装 {{rlp|set_new_handler|new 处理函数}}，那么就会抛出 {{lc|std::bad_alloc}}。
* 否则就会调用当前安装的 new 处理函数。
** 如果 new 处理函数返回，那么就会重新尝试。
** 否则就会退出当前调用。

@2@ 返回 {{c|operator new(count)}}。

@3@ 同 {{v|1}}。

@4@ 返回 {{c|operator new(count, al)}}。

@5-8@ 以 {{c|tag}} 以外的相同实参分别调用 {{v|1-4}}。
* 如果调用正常返回，那么返回该调用的结果。
* 否则返回空指针。

{{rrev|since=c++26|
在[[cpp/freestanding|独立实现]]上，{{vl|1-8}} 的默认版本的行为是否满足以上要求由实现定义。建议独立实现在其中有任何默认版本满足宿主实现的要求的情况下，其他所有版本都应同时满足。
}}

{{cpp/memory/new/minimal replacement example}}

{{tt|operator new}} 和 {{tt|operator new[]}} 带额外用户定义参数的重载（“布置形式”，版本 {{vl|11-14}}）可以照常在全局作用域声明，而且会被匹配的[[cpp/language/new#布置 new|布置形式]] {{c/core|new}} 表达式调用。

标准库的 {{tt|operator new}} 的不分配布置形式 {{vl|9,10}} 不能被替换，而且只能在布置 {{c/core|new}} 表达式不使用 {{c|::new}} 语法时才能通过提供类特定的带匹配签名的布置 {{c/core|new}} {{vl|19,20}}自定义：{{c/core|void* T::operator new(size_t, void*)}} 或 {{c/core|void* T::operator new[](size_t, void*)}}。

{{rrev|since=c++14|
不能使用布置形式 {{c/core|void* operator new(std::size_t, std::size_t)}}，因为对应的解分配函数的匹配签名 {{c/core|void operator delete(void*, std::size_t)}} 是通常（非布置）的解分配函数。
}}

===类特定重载===
单对象和数组分配函数都可以定义为类的公开静态成员函数（版本 {{vl|15-18}}。有定义时 {{c/core|new}} 表达式会调用这些函数，以分配此类单个对象或数组的内存，除非 {{c/core|new}} 表达式使用 {{c/core|::new}} 形式，这样就会跳过类作用域查找。对这些函数不需要使用关键词 {{ltt|cpp/keyword/static}}：不管是否使用，分配函数都是静态成员函数。

{{c/core|new}} 表达式首先在类作用域中查找适当的函数名，然后在全局作用域查找。注意，与每个[[cpp/language/lookup|名称查找规则]]一样，就试图分配此类对象的 {{c/core|new}} 表达式而言，任何在类作用域声明的分配函数都会隐藏所有全局分配函数。

{{rrev|since=c++17|
在分配对齐超出 {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}} 的对象或元素对齐超出 {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}} 的对象数组时，进行两次重载决议：首先，针对具对齐的函数签名，然后，针对无对齐的函数签名。这意味着如果某个拥有扩展对齐的类拥有针对无对齐的类特定分配函数，那么该函数，而非全局的具对齐分配函数将会被调用。这是有意的：类成员应该对如何处理该类有最好的理解。
}}

{{rrev|since=c++20|
在分配对齐没有超出 {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}} 的对象或元素对齐没有超出 {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}} 的对象数组时，进行两次重载决议：首先，针对无对齐的函数签名，然后，针对具对齐的函数签名。
}}

{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;

// 类特定分配函数
struct X
{
    static void* operator new(std::size_t count)
    {
        std::cout &lt;&lt; "大小为 " &lt;&lt; count &lt;&lt; " 的自定义 new\n";
        return ::operator new(count);
    }
    
    static void* operator new[](std::size_t count)
    {
        std::cout &lt;&lt; "大小为 " &lt;&lt; count &lt;&lt; " 的自定义 new[]\n";
        return ::operator new[](count);
    }
};

int main()
{
    X* p1 = new X;
    delete p1;
    X* p2 = new X[10];
    delete[] p2;
}
|p=true
|output=
大小为 1 的自定义 new
大小为 10 的自定义 new[]
}}

{{tt|operator new}} 和 {{tt|operator new[]}} 带额外用户定义形参（“布置形式”）的重载也可以定义为类成员 {{vl|19-22}}。在拥有匹配签名的布置 {{c/core|new}} 表达式查找要调用的对应分配函数时，查找在检验全局作用域前，从类作用域开始，且在提供了类特定的布置 {{c/core|new}} 时会调用它。

{{rrev|since=c++17|
在分配对齐超出 {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}} 的对象或元素对齐超出 {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}} 的对象数组时，与通常形式一样对布置形式进行两次重载决议：首先，针对具对齐的函数签名，然后，针对无对齐的函数签名。
}}

{{rrev|since=c++20|
在分配对齐没有超出 {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}} 的对象或元素对齐没有超出 {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}} 的对象数组时，与通常形式一样对布置形式进行两次重载决议：首先，针对无对齐的函数签名，然后，针对具对齐的函数签名。
}}

{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

struct X
{
    X() { throw std::runtime_error(""); }
    
    // 自定义布置 new
    static void* operator new(std::size_t count, bool b)
    {
        std::cout &lt;&lt; "调用自定义的布置 new，b = " &lt;&lt; b &lt;&lt; '\n';
        return ::operator new(count);
    }
    
    // 自定义布置 delete
    static void operator delete(void* ptr, bool b)
    {
        std::cout &lt;&lt; "调用自定义的布置 delete，b = " &lt;&lt; b &lt;&lt; '\n';
        ::operator delete(ptr);
    }
};

int main()
{
    try
    {
        [[maybe_unused]] X* p1 = new (true) X;
    }
    catch (const std::exception&amp;)
    {}
}
|output=
调用自定义的布置 new，b = 1
调用自定义的布置 delete，b = 1
}}

如果类级别的 {{tt|operator new}} 是模板函数，那么它必须拥有返回类型 {{c/core|void*}}，第一实参类型 {{lc|std::size_t}}，且它必须拥有两个或更多形参。换言之，只有布置形式可以是模板。

===注解===
尽管不分配布置 {{c/core|new}} {{vl|9,10}} 不能被替换，但在上面描述的类作用域也可以定义拥有相同签名的函数。另外，可以使用像是布置 {{c/core|new}} 但接受非 {{c/core|void}} 指针类型作为第二实参的全局重载，所以希望确保调用真正的布置 {{c/core|new}} 的代码（例如 {{lc|std::allocator::construct}}）必须使用 {{c/core|::new}} 并将指针转型到 {{c/core|void*}}。

如果解分配函数的行为无法满足默认约束，则其行为未定义。

{{cpp/memory/thread safety note}}

{{tt|operator new}} 的库版本是否产生任何对 {{lc|std::malloc}} {{rev inl|since=c++17|或 {{lc|std::aligned_alloc}}}} 的调用是未指定的。

对于加载大文件，经由如 POSIX 上的 {{posix|mmap}} 或 Windows 上的 {{tt|CreateFileMapping}}([https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga {{tt|A}}]/[https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-createfilemappingw {{tt|W}}]) 伴随 [https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile {{tt|MapViewOfFile}}] 的操作系统特定函数进行文件映射，比为文件读取分配缓冲区更适合。

{{ftm begin}}
{{ftm|__cpp_lib_freestanding_operator_new|rowspan=2|value=202306L|std=C++26|可替换的 {{c/core|operator new}} 的独立支持&lt;ref&gt;正式而言，此宏会在所有可替换的全局分配函数的默认版本都满足宿主实现的要求的情况下展开为 {{c|202306L}}。&lt;/ref&gt;}}
{{ftm|-|value=0|std=C++26|无独立支持}}
{{ftm|__cpp_lib_constexpr_new|value=202406L|std=C++26|{{c/core|constexpr}} 的布置 {{c/core|new}} 和 {{c/core|new[]}}}}
{{ftm end}}
&lt;references/&gt;

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=cwg|dr=521|std=C++98|before=任何从 {{lc|std::bad_alloc}} 派生的类都可以抛出，&lt;br&gt;即使该 {{lc|std::bad_alloc}} 基有歧义或不可访问|after=抛出的异常应与类型是&lt;br&gt;{{lc|std::bad_alloc}} 的处理块匹配}}
{{dr list item|wg=lwg|dr=9|std=C++98|before=多次请求分配零字节的调用可以产生相同的指针|after=只有在之前产生的这些指针都&lt;br&gt;被传递给解分配函数时才可以}}
{{dr list item|wg=lwg|dr=206|std=C++98|before=替换掉可替换的分配函数不会影响对应的可替换的不抛出分配函数的默认行为|after=默认行为也会有相应变更}}
{{dr list item|wg=lwg|dr=404|std=C++98|before=可替换的分配函数在替换时可以声明为 {{c/core|inline}}|after=已禁止，不要求诊断}}
{{dr list end}}

===引用===
{{ref std c++23}}
{{ref std|section=17.7|title=Dynamic memory management|id=support.dynamic}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=17.6|title=Dynamic memory management|id=support.dynamic}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=21.6|title=Dynamic memory management|id=support.dynamic}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=18.6|title=Dynamic memory management|id=support.dynamic}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=18.6|title=Dynamic memory management|id=support.dynamic}}
{{ref std end}}
{{ref std c++03}}
{{ref std|section=18.4|title=Dynamic memory management|id=lib.support.dynamic}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=18.4|title=Dynamic memory management|id=lib.support.dynamic}}
{{ref std end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/coroutine/generator/promise_type/dsc operator new}}
{{dsc inc|cpp/memory/new/dsc operator_delete}}
{{dsc inc|cpp/memory/new/dsc get_new_handler}}
{{dsc inc|cpp/memory/new/dsc set_new_handler}}
{{dsc inc|cpp/memory/dsc get_temporary_buffer}}
{{dsc inc|cpp/memory/c/dsc malloc}}
{{dsc inc|cpp/memory/c/dsc aligned_alloc}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}