{{cpp/memory/weak_ptr/title|lock}}
{{cpp/memory/weak_ptr/navbar}}
{{ddcl|since=c++11|
std::shared_ptr&lt;T&gt; lock() const noexcept;
}}

创建共享被管理对象的所有权的新 {{lc|std::shared_ptr}} 对象。若无被管理对象，即 {{c|*this}} 为空，则返回的 {{tt|shared_ptr}} 也为空。

相当于返回 {{c|expired() ? shared_ptr&lt;T&gt;() : shared_ptr&lt;T&gt;(*this)}}，原子地执行。

===参数===
（无）

===返回值===
若 {{lc|std::weak_ptr::expired}} 返回 {{c|false}} 则为共享被占有对象所有权的 {{tt|shared_ptr}}。否则返回默认构造的 T 类型的 {{tt|shared_ptr}}。

===注解===
此函数和 {{lc|std::shared_ptr}} 的构造函数可能获得 {{tt|std::weak_ptr}} 所指向的被管理对象的临时所有权。区别是 {{lc|std::shared_ptr}} 的构造函数在其 {{tt|std::weak_ptr}} 为空时抛异常，而 {{lc|std::weak_ptr&lt;T&gt;::lock()}} 构造空的 {{lc|std::shared_ptr&lt;T&gt;}}。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;

void observe(std::weak_ptr&lt;int&gt; weak)
{
    if (auto p = weak.lock())
        std::cout &lt;&lt; "\tobserve() 可以锁定 weak_ptr&lt;&gt;, value=" &lt;&lt; *p &lt;&lt; '\n';
    else
        std::cout &lt;&lt; "\tobserve() 无法锁定 weak_ptr&lt;&gt;\n";
}

int main()
{
    std::weak_ptr&lt;int&gt; weak;
    std::cout &lt;&lt; "weak_ptr&lt;&gt; 尚未初始化\n";
    observe(weak);
    
    {
        auto shared = std::make_shared&lt;int&gt;(42);
        weak = shared;
        std::cout &lt;&lt; "weak_ptr&lt;&gt; 以 shared_ptr 初始化\n";
        observe(weak);
    }

    std::cout &lt;&lt; "shared_ptr&lt;&gt; 已因退出作用域而析构\n";
    observe(weak);
}
|output=
weak_ptr&lt;&gt; 尚未初始化
        observe() 无法锁定 weak_ptr&lt;&gt;
weak_ptr&lt;&gt; 以 shared_ptr 初始化
        observe() 可以锁定 weak_ptr&lt;&gt;, value=42
shared_ptr&lt;&gt; 已因退出作用域而析构
        observe() 无法锁定 weak_ptr&lt;&gt;
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2316|std=C++11|before=不要求 lock() 是原子的，但要求为 noexcept，这导致矛盾|after=指定为原子的}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/weak_ptr/dsc expired}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}