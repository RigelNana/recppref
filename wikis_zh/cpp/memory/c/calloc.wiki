{{cpp/title|calloc}}
{{cpp/memory/navbar}}
{{ddcl|header=cstdlib|
void* calloc( std::size_t num, std::size_t size );
}}

分配 {{c|num}} 个大小为 {{c|size}} 的对象的数组，并初始化所有位为零（在目标区域[[cpp/language/object#对象创建|隐式创建]]对象）。

若分配成功，则返回指向为任何对象类型适当对齐的，被分配内存块最低（首）字节的指针。

若 {{c|size}} 为零，则行为是实现定义的（可以返回空指针，亦可返回某个不可用于访问存储的非空指针）。

{{cpp/memory/thread_safety_note}}

===参数===
{{par begin}}
{{par|num|对象数量}}
{{par|size|每个对象的大小}}
{{par end}}

===返回值===
成功时，返回指向新分配内存起始的指针。为避免内存泄漏，返回的指针必须以 {{lc|std::free()}} 或 {{lc|std::realloc()}} 解分配。

失败时，返回空指针。

===注解===
因为对齐要求，分配的字节数不需要等于 {{c|num * size}}。

将所有位初始化为零不保证浮点数或指针各被初始化到 0.0 与空指针值（尽管所有常见平台上都是如此）。

最初（C89 中），添加对零大小的支持是为了接纳下面这种代码
{{source|1=
OBJ *p = calloc(0, sizeof(OBJ)); // “零长度”占位
...
while(1) { 
    p = realloc(p, c * sizeof(OBJ)); // 重分配直至大小稳定
    ... // 可能更改 c 或打破循环的代码
}
}}

===示例===
{{example
|code=
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;

int main()
{
    int* p1 = (int*)std::calloc(4, sizeof(int)); // 分配并清零 4 个 int 的数组
    int* p2 = (int*)std::calloc(1, sizeof(int[4])); // 同上，直接指名数组类型
    int* p3 = (int*)std::calloc(4, sizeof *p3);   // 同上，不重复类型名

    if(p2)
        for (int n = 0; n &lt; 4; ++n) // 打印数组
            std::cout &lt;&lt; "p2[" &lt;&lt; n &lt;&lt; "] == " &lt;&lt; p2[n] &lt;&lt; '\n';

    std::free(p1);
    std::free(p2);
    std::free(p3);
}
|output=
p2[0] == 0
p2[1] == 0
p2[2] == 0
p2[3] == 0
}}

===参阅===
{{dsc begin}}
{{dsc see c|c/memory/calloc}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}