{{cpp/memory/out_ptr_t/title|operator Pointer*|operator void**}}
{{cpp/memory/out_ptr_t/navbar}}
{{dcl begin}}
{{dcl | num=1 | since=c++23 |
operator Pointer*() const noexcept;
}}
{{dcl | num=2 | since=c++23 |
operator void**() const noexcept;
}}
{{dcl end}}

暴露 {{tt|Pointer}} 或 {{c|void*}} 对象的地址给一般会重初始化它的外来函数。

@1@ 转换 {{c|*this}} 为所存储的 {{tt|Pointer}} 对象的地址。

@2@ 转换 {{c|*this}} 为一个 {{c|void*}} 对象的地址。此转换函数仅若 {{tt|Pointer}} 与 {{c|void*}} 不同才参与重载决议，而若 {{tt|Pointer}} 不是指针类型则程序非良构。&lt;br&gt;{{c|void*}} 对象的初值等于存储的 {{tt|Pointer}} 对象的值转换到 {{c|void*}}，而任何对它的修改都对用于{{rlp|~out_ptr_t|析构函数}}的 {{tt|Pointer}} 值有影响。在 {{c|*this}} 的生存期外访问该 {{c|void*}} 拥有未定义行为。

一旦在一个 {{tt|out_ptr_t}} 对象上调用了这两个转换函数之一，则不应当调用另一个，否则行为未定义。

===参数===
（无）

===返回值===
@1@ 存储的 {{tt|Pointer}} 对象的地址。

@2@ 满足前述要求的 {{c|void*}} 对象的地址。

===注解===
若返回值所指向的对象未被写入，则它等于 {{c|nullptr}}。

常见实现上，每个作为指针类型的 {{tt|Pointer}} 对象表示均与 {{c|void*}} 的兼容，从而这些实现常在 {{tt|Pointer}} 对象的存储内存储该 {{c|void*}} 对象，不需要额外存储：
* 若实现启用基于类型的别名分析（依赖[[cpp/language/reinterpret_cast#类型别名化|严格别名化规则]]），则可以使用正确对齐的 {{c|std::byte[sizeof(void*)]}} 成员子对象，而两个转换函数都返回在该数组内[[cpp/language/object#对象创建|隐式创建]]的对象的地址。
* 否则，可将 {{tt|Pointer}} 成员子对象用于两个转换函数，而 {{v|2}} 可以直接返回 {{ltt|cpp/language/reinterpret_cast}} 成 {{c|void**}} 的其地址。

若 {{tt|Pointer}} 是对象表示与 {{c|void*}} 的不兼容的指针类型，则可能需要额外的 {{c|bool}} 标志记录是否调用了 {{v|1}}（或 {{v|2}}）。

===示例===
{{example}}

{{langlinks|en|es|ja|ru}}