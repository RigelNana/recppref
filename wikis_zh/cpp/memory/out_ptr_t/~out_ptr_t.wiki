{{cpp/memory/out_ptr_t/title|~out_ptr_t}}
{{cpp/memory/out_ptr_t/navbar}}
{{ddcl | since=c++23 |
~out_ptr_t();
}}

以修改的 {{tt|Pointer}} 对象（或若调用了 {{c|operator void**()}} 则为 {{c|void*}} 对象）的值捕获的实参重设适配的 {{tt|Smart}} 对象。

令
* {{tt|s}} 代表适配的 {{tt|Smart}} 对象，
* {{tt|args...}} 代表捕获的实参，
* {{tt|p}} 代表存储的 {{tt|Pointer}} 的值，或若调用了 {{c|operator void**}} 则为 {{c|static_cast&lt;Pointer&gt;(*operator void**())}}，
* {{tt|SP}} 为
** {{c|Smart::pointer}}，若它合法并代表类型，否则为
** {{c|Smart::element_type*}}，若 {{c|Smart::element_type}} 并代表类型，否则为
** {{c|std::pointer_traits&lt;Smart&gt;::element_type*}}，若 {{c|std::pointer_traits&lt;Smart&gt;::element_type}} 合法并代表类型，否则为
** {{tt|Pointer}}。

若 {{c|s.reset(static_cast&lt;SP&gt;(p), std::forward&lt;Args&gt;(args)...)}} 良构，则析构函数进行
:{{c|if (p) s.reset(static_cast&lt;SP&gt;(p), std::forward&lt;Args&gt;(args)...);}}，
否则，若 {{c|std::is_constructible_v&lt;Smart, SP, Args...&gt;}} 为 {{c|true}}，则析构函数进行
:{{c|1=if (p) s = Smart(static_cast&lt;SP&gt;(p), std::forward&lt;Args&gt;(args)...);}}，
否则程序非良构。

===注解===
若 {{tt|Smart}} 是 {{lc|std::shared_ptr}} 的特化，则实现可以在构造时分配重设新的控制块的存储，以将不抛出的工作留给析构函数。

在重设后销毁按值捕获的实参。

{{langlinks|en|es|ja|ru}}