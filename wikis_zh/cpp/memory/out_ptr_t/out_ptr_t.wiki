{{cpp/memory/out_ptr_t/title|out_ptr_t}}
{{cpp/memory/out_ptr_t/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++23|
explicit out_ptr_t( Smart &amp;sp, Args... args );
}}
{{dcl|num=2|since=c++23|1=
out_ptr_t( const out_ptr_t&amp; ) = delete;
}}
{{dcl end}}

@1@ 创建 {{tt|out_ptr_t}}。如同将 {{c|sp}} 绑定到 {{c|Smart&amp;}} 成员一般适配它，如同用 {{c|std::forward&lt;T&gt;(t)}} 初始化对应的 {{tt|Args...}} 中类型 {{tt|T}} 的成员一般捕获 {{tt|args...}} 中的实参 {{tt|t}}，然后值初始化存储的 {{tt|Pointer}}。&lt;br&gt;
然后若 {{c|sp.reset()}} 良构则调用它；否则若 {{c|std::is_default_constructible_v&lt;Smart&gt;}} 为 {{c|true}} 则调用 {{c|1=sp = Smart()}}。若两种重置操作均为非良构，则程序非良构。

@2@ 复制构造函数被显示弃置。{{tt|out_ptr_t}} 既不可复制又不可移动。

===参数===
{{par begin}}
{{par|sp|要适配的对象（常为智能指针）}}
{{par|args...|要捕获的用于重设的实参}}
{{par end}}

===返回值===
（无）

{{cpp/impldef exception}}

===注解===
构造后，任一转换函数的返回值所指向的 {{tt|Pointer}} 或 {{c|void*}} 对象都等于 {{c|nullptr}}。

{{c|args...}} 中的每个实参若拥有对象类型则被移动到创建的 {{tt|out_ptr_t}} 中，而若拥有引用类型则保持原状转移到创建的 {{tt|out_ptr_t}} 中。

允许 {{tt|out_ptr_t}} 抛出异常。例如当 {{c|sp}} 为 {{lc|std::shared_ptr}} 时，新的控制块的分配可以在构造函数而非析构函数内进行。

===示例===
{{example}}

{{langlinks|en|es|ja|ru}}