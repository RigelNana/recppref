{{cpp/title|owner_less}}
{{cpp/memory/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcl rev begin|num=1}}
{{dcl|since=c++11|until=c++17|
template&lt; class T &gt;
struct owner_less; /* 未定义 */
}}
{{dcl|since=c++17|1=
template&lt; class T = void &gt;
struct owner_less; /* 未定义 */
}}
{{dcl rev end}}
{{dcl|since=c++11|num=2|
template&lt; class T &gt;
struct owner_less&lt;std::shared_ptr&lt;T&gt;&gt;;
}}
{{dcl|since=c++11|num=3|
template&lt; class T &gt;
struct owner_less&lt;std::weak_ptr&lt;T&gt;&gt;;
}}
{{dcl|since=c++17|num=4|
template&lt;&gt;
struct owner_less&lt;void&gt;;
}}
{{dcl end}}

此函数对象提供基于拥有者（而不是基于值）的，{{lc|std::weak_ptr}} 和 {{lc|std::shared_ptr}} 两者的混合类型定序。这种排序中满足仅当两个智能指针均为空或共享所有权时才会比较等价，即使由 {{tt|get()}} 获得的裸指针值不同（例如因为它们指向同一对象中的不同子对象）也是如此。

@1@ 不会为 {{lc|std::shared_ptr}} 和 {{lc|std::weak_ptr}} 以外的类型提供基于拥有者的混合类型定序。

@2@ {{lc|std::shared_ptr}} 的基于拥有者的混合类型定序。
@@ 在以 {{lc|std::shared_ptr}} 为键建立关联容器时，最好使用此比较断言，即 {{c/core|std::map&lt;std::shared_ptr&lt;T&gt;, U, std::owner_less&lt;std::shared_ptr&lt;T&gt;&gt;&gt;}}。

@3@ {{lc|std::weak_ptr}} 的基于拥有者的混合类型定序。
@@ 在以 {{lc|std::weak_ptr}} 为键建立关联容器时，最好使用此比较断言，即 {{c/core|std::map&lt;std::weak_ptr&lt;T&gt;, U, std::owner_less&lt;std::weak_ptr&lt;T&gt;&gt;&gt;}}。

@4@ {{c/core|void}} 特化会从各实参推导出形参类型。

默认的 {{c/core|operator&lt;}} 并没有为弱指针提供定义，并且它可能错误地认为指向同一对象的两个共享指针不等价（见 {{l2tt std|cpp/memory/shared_ptr/owner_before}}）。

{{rrev|since=c++17|
===特化===
标准库提供 {{tt|std::owner_less}} 在不指定 {{tt|T}} 时的特化。此情况下，从实参类型推导各形参类型（每个实参都必须是 {{lc|std::shared_ptr}} 或 {{lc|std::weak_ptr}}）。
{{dsc begin}}
{{dsc inc|cpp/memory/dsc owner_less_void}}
{{dsc end}}
}}


{{rrev|until=c++20|
===嵌套类型===
{{dsc begin}}
{{dsc hitem|嵌套类型|定义}}
{{dsc|{{tt|result_type}} {{mark deprecated c++17}}|{{v|2,3}} {{c/core|bool}}}}
{{dsc|{{tt|first_argument_type}} {{mark deprecated c++17}}|{{v|2}} {{c/core|std::shared_ptr&lt;T&gt;}}&lt;br&gt;{{v|3}} {{c/core|std::weak_ptr&lt;T&gt;}}}}
{{dsc|{{tt|second_argument_type}} {{mark deprecated c++17}}|{{v|2}} {{c/core|std::shared_ptr&lt;T&gt;}}&lt;br&gt;{{v|3}} {{c/core|std::weak_ptr&lt;T&gt;}}}}
{{dsc end}}
}}

===成员函数===
{{dsc begin}}
{{dsc fun|cpp/memory/owner_less|title=operator()|inlinemem=true|用基于拥有者的语义比较其实参}}
{{dsc end}}

{{member|{{small|std::owner_less::}}operator()|
{{dcl begin}}
{{dcl h|特化 {{v|2}} 才有的成员}}
{{dcl|since=c++11|
bool operator()( const std::shared_ptr&lt;T&gt;&amp; lhs, 
                 const std::shared_ptr&lt;T&gt;&amp; rhs ) const noexcept;
}}
{{dcl h|特化 {{v|3}} 才有的成员}}
{{dcl|since=c++11|
bool operator()( const std::weak_ptr&lt;T&gt;&amp; lhs, 
                 const std::weak_ptr&lt;T&gt;&amp; rhs ) const noexcept;
}}
{{dcl h|两个模板特化都有的成员}}
{{dcl|since=c++11|
bool operator()( const std::shared_ptr&lt;T&gt;&amp; lhs, 
                 const std::weak_ptr&lt;T&gt;&amp; rhs ) const noexcept;
}}
{{dcl|since=c++11|
bool operator()( const std::weak_ptr&lt;T&gt;&amp; lhs, 
                 const std::shared_ptr&lt;T&gt;&amp; rhs ) const noexcept;
}}
{{dcl end}}

用基于拥有者的语义比较 {{c|lhs}} 和 {{c|rhs}}。等价于调用 {{c|lhs.owner_before(rhs)}}。

此顺序是严格弱序关系。

仅当 {{c|lhs}} 和 {{c|rhs}} 均为空或共享所有权时它们才会相等。

===参数===
{{par begin}}
{{par|lhs, rhs|要比较的共享所有权指针}}
{{par end}}

===返回值===
在按基于拥有者的顺序确定 {{c|lhs}} ''小于'' {{c|rhs}} 时返回 {{c|true}}，否则返回 {{c|false}}。
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2873|std=C++11|before={{c/core|operator()}} 不需要是 noexcept 的|after=需要是 noexcept 的}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/memory/shared_ptr/dsc owner_before}}
{{dsc inc|cpp/memory/weak_ptr/dsc owner_before}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}