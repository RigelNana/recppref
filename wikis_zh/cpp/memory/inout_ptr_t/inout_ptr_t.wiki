{{cpp/memory/inout_ptr_t/title|inout_ptr_t}}
{{cpp/memory/inout_ptr_t/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++23|
explicit inout_ptr_t( Smart &amp;sp, Args... args );
}}
{{dcl|num=2|since=c++23|1=
inout_ptr_t( const inout_ptr_t&amp; ) = delete;
}}
{{dcl end}}

@1@ 创建 {{tt|inout_ptr_t}}。如同将 {{c|sp}} 绑定到 {{c|Smart&amp;}} 成员一般适配它，如同用 {{c|std::forward&lt;T&gt;(t)}} 初始化对应的 {{tt|Args...}} 中类型 {{tt|T}} 的成员一般捕获 {{c|args...}} 中的实参 {{tt|t}}，然后若 {{tt|Smart}} 为指针类型则以 {{c|sp}} 初始化存储的 {{tt|Pointer}}，否则以 {{c|sp.get()}} 初始化它。若 {{tt|Smart}} 不是指针类型则可能调用 {{c|sp.release()}}，该情况下不会再于析构函数内调用它。

@2@ 复制构造函数被显示删除。{{tt|inout_ptr_t}} 既不可复制又不可移动。

===参数===
{{par begin}}
{{par|sp|要适配的对象（常为智能指针）}}
{{par|args...|要捕获的用于重设的实参}}
{{par end}}

===返回值===
（无）

{{cpp/impldef exception}}

===注解===
若 {{tt|Smart}} 不是指针类型且构造函数不调用 {{c|sp.release()}}，则析构函数在重设前可能调用它。

{{c|args...}} 中的每个参数若拥有对象类型则被移动到创建的 {{tt|inout_ptr_t}} 中，而若拥有引用类型则保持原状转移到创建的 {{tt|inout_ptr_t}} 中。

允许 {{tt|inout_ptr_t}} 抛出异常。例如当 {{tt|sp}} 为带有控制块的侵入式指针时，新的控制块的分配可以在构造函数而非析构函数内进行。

===示例===
{{example}}

{{langlinks|en|es|ja|ru}}