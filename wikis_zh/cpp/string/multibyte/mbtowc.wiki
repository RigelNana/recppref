{{cpp/title|mbtowc}}
{{cpp/string/multibyte/navbar}}
{{ddcl|header=cstdlib|
int mbtowc( wchar_t* pwc, const char* s, std::size_t n );
}}

将 {{c|s}} 指向其首字节的多字节字符转换成宽字符，若 {{c|pwc}} 非空则写入 {{c|*pwc}}。

若 {{c|s}} 为空指针，则重置全局转换状态并确定是否使用迁移序列。

===参数===
{{par begin}}
{{par|s|指向多字节字符的指针}}
{{par|n|{{c|s}} 中能被检验的字节数的限制}}
{{par|pwc|指向输出用宽字符的指针}}
{{par end}}

===返回值===
若 {{c|s}} 不是空指针，则返回多字节字符所含的字节数，或若 {{c|s}} 所指的首字节不组成合法多字节字符则返回 {{c|-1}}，或若 {{c|s}} 指向空字符 {{c|'\0'}} 则返回 {{c|0}}。

若 {{c|s}} 是空指针，则重置内部转换状态为初始迁移状态，并若当前多字节编码非状态依赖（不使用迁移序列）则返回 {{c|0}}，或若当前多字节编码为状态依赖（使用迁移序列）则返回非零值。

===注解===
每次对 {{tt|mbtowc}} 的调用更新内部全局转换状态（{{lc|std::mbstate_t}} 类型的静态对象，只为此函数所知）。若多字节编码使用迁移状态，则必须留意以避免回撤或多次扫描。任何情况下，多线程不应调用 {{tt|mbtowc}} 而不同步：可用 {{lc|std::mbrtowc}} 代替。

===示例===
{{example
|code=
#include &lt;clocale&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

int print_mb(const char* ptr)
{
    std::mbtowc(nullptr, 0, 0); // 重置转换状态
    const char* end = ptr + std::strlen(ptr);
    int ret;
    for (wchar_t wc; (ret = std::mbtowc(&amp;wc, ptr, end - ptr)) &gt; 0; ptr += ret)
        std::wcout &lt;&lt; wc;
    std::wcout &lt;&lt; '\n';
    return ret;
}

int main()
{
    std::setlocale(LC_ALL, "en_US.utf8");
    // UTF-8 窄多字节编码
    const char* str = "z\u00df\u6c34\U0001d10b"; // 或 "zß水🍌"
                      // 或 "\x7a\xc3\x9f\xe6\xb0\xb4\xf0\x9d\x84\x8b";
    print_mb(str);
}
|output=
zß水🍌
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/string/multibyte/dsc mbrtowc}}
{{dsc inc|cpp/string/multibyte/dsc mblen}}
{{dsc inc|cpp/locale/codecvt/dsc do_in}}
{{dsc see c|c/string/multibyte/mbtowc}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}