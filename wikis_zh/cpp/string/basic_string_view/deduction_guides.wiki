{{title|{{tt|std::basic_string_view}} 的推导指引}}
{{cpp/string/basic_string_view/navbar}}
{{dcl begin}}
{{dcl header|string_view}}
{{dcl|num=1|since=c++20|
template&lt; class It, class End &gt;
basic_string_view( It, End ) -&gt; basic_string_view&lt;std::iter_value_t&lt;It&gt;&gt;;
}}
{{dcl|num=2|since=c++23|
template&lt; class R &gt;
basic_string_view( R&amp;&amp; ) -&gt; basic_string_view&lt;ranges::range_value_t&lt;R&gt;&gt;;
}}
{{dcl end}}

为 {{lc|std::basic_string_view}} 提供这些[[cpp/language/class template argument deduction|推导指引]]。

@1@ 此推导指引允许从迭代器-哨位对推导字符类型。{{cpp/enable_if| {{tt|It}} 满足 {{lconcept|contiguous_iterator}} 且 {{tt|End}} 满足 {{tt|It}} 的 {{lconcept|sized_sentinel_for}} }}。

@2@ 此推导指引允许从范围推导字符类型。{{cpp/enable_if| {{tt|R}} 满足 {{lconcept|contiguous_range}} }}。

===示例===
{{example
|code=
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;

int main()
{
    std::array a1 {'n', 'u', 'c', 'l', 'e', 'o', 'n', 's', ':', '\n'};
    std::basic_string_view s1(a1.cbegin(), a1.cend()); // 推导： CharT -&gt; char
    static_assert(std::is_same_v&lt;decltype(s1)::value_type, char&gt;);
    std::cout &lt;&lt; s1;

    std::array a2 {L'p', L'r', L'o', L't', L'o', L'n', L's', L'\n'};
    std::basic_string_view s2(a2.cbegin(), a2.cend()); // 推导： CharT -&gt; wchar_t
    static_assert(std::is_same_v&lt;decltype(s2)::value_type, wchar_t&gt;);
    std::wcout &lt;&lt; s2;

    std::array&lt;long, 9&gt; a3 {'n', 'e', 'u', 't', 'r', 'o', 'n', 's', '\n'};
    std::basic_string_view s3(a3.cbegin(), a3.cend()); // 推导： CharT -&gt; long
    static_assert(std::is_same_v&lt;decltype(s3)::value_type, long&gt;);
    for (const auto e : s3)
        std::cout &lt;&lt; static_cast&lt;char&gt;(e);
}
|output=
nucleons:
protons
neutrons
}}

{{langlinks|en|es|ja|ru}}