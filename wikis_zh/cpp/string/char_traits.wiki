{{cpp/title|char_traits}}
{{cpp/string/char_traits/navbar}}
{{ddcl|header=string|1=
template&lt;
    class CharT 
&gt; class char_traits;
}}

{{tt|char_traits}} 类是一种特征类模板，对给定的字符类型抽象基础字符和字符串比较操作。其所定义的操作集，使得各种泛型算法几乎总是可以基于它实现。从而可以将这些算法用于几乎任何可能的字符或字符串类型，只需提供自定义的 {{tt|char_traits}} 类即可。

{{tt|char_traits}} 类模板表现为显式实例化的基础。用户可以对任何自定义字符类型[[cpp/language/extending std|提供特化]]。标准字符类型上已定义了数种特化（见下文），其他特化不需要满足{{named req|CharTraits}}的要求。

===特化===
标准库提供以下标准特化：
{{dsc begin}}
{{dsc header|string}}
{{dsc|{{c/core|std::char_traits&lt;char&gt;}}|{{c/core|char}} 的标准字符特征}}
{{dsc|{{c/core|std::char_traits&lt;wchar_t&gt;}}|{{c/core|wchar_t}} 的标准字符特征}}
{{dsc|{{c/core|std::char_traits&lt;char8_t&gt;}} {{mark c++20}}|{{c/core|char8_t}} 的标准字符特征}}
{{dsc|{{c/core|std::char_traits&lt;char16_t&gt;}} {{mark c++11}}|{{c/core|char16_t}} 的标准字符特征}}
{{dsc|{{c/core|std::char_traits&lt;char32_t&gt;}} {{mark c++11}}|{{c/core|char32_t}} 的标准字符特征}}
{{dsc end}}

所有这些特化都满足{{named req|CharTraits}}的要求。

====成员类型====
标准特化定义了由{{named req|CharTraits}}要求的以下成员类型：
{|class=wikitable style="text-align: center;"
!rowspan=2|{{tt|CharT}}
!colspan=5|成员类型
|-
!{{nbsp}}{{tt|char_type}}{{nbsp}}
!{{tt|int_type}}
!{{tt|off_type}}
!{{tt|pos_type}}
!{{tt|state_type}}
|-
|{{c/core|char}}
|{{c/core|char}}
|{{c/core|int}}
|rowspan=5|{{nbsp}}{{lc|std::streamoff}}{{nbsp}}
|{{lc|std::streampos}}
|rowspan=5|{{nbsp}}{{lc|std::mbstate_t}}{{nbsp}}
|-
|{{c/core|wchar_t}}
|{{c/core|wchar_t}}
|{{ltt|cpp/string/wide#类型|std::wint_t}}
|{{lc|std::wstreampos}}
|-
|{{c/core|char8_t}}
|{{c/core|char8_t}}
|{{c/core|unsigned int}}
|{{lc|std::u8streampos}}
|-
|{{nbsp}}{{c/core|char16_t}}{{nbsp}}
|{{c/core|char16_t}}
|{{nbsp}}{{lc|std::uint_least16_t}}{{nbsp}}
|{{nbsp}}{{lc|std::u16streampos}}{{nbsp}}
|-
|{{c/core|char32_t}}
|{{c/core|char32_t}}
|{{lc|std::uint_least32_t}}
|{{lc|std::u32streampos}}
|}

{{rrev|since=c++20|
另外，标准特化将成员类型 {{tt|comparison_category}} 定义为 {{ltt std|cpp/utility/compare/strong_ordering}}。
}}

====成员函数====
标准特化定义了由{{named req|CharTraits}}要求的以下静态成员函数：
{{dsc begin}}
{{dsc inc|cpp/string/char_traits/dsc assign}}
{{dsc inc|cpp/string/char_traits/dsc cmp}}
{{dsc inc|cpp/string/char_traits/dsc move}}
{{dsc inc|cpp/string/char_traits/dsc copy}}
{{dsc inc|cpp/string/char_traits/dsc compare}}
{{dsc inc|cpp/string/char_traits/dsc length}}
{{dsc inc|cpp/string/char_traits/dsc find}}
{{dsc inc|cpp/string/char_traits/dsc to_char_type}}
{{dsc inc|cpp/string/char_traits/dsc to_int_type}}
{{dsc inc|cpp/string/char_traits/dsc eq_int_type}}
{{dsc inc|cpp/string/char_traits/dsc eof}}
{{dsc inc|cpp/string/char_traits/dsc not_eof}}
{{dsc end}}

===注解===
{{named req|CharTraits}}不要求将以上列出的类型和函数定义为直接成员，它只要求类似 {{tt|X::type}} 的类型和类似 {{c|X::func(args)}} 的表达式合法并具有要求的语义。用户定义的字符特征可以从其它字符特征派生，并只需要覆盖部分成员，见下方示例。

===示例===
{{example
|用户定义的字符特征可以用于提供[http://www.gotw.ca/gotw/029.htm 无关大小写的比较]：
|code=
#include &lt;cctype&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
 
struct ci_char_traits : public std::char_traits&lt;char&gt;
{
    static char to_upper(char ch)
    {
        return std::toupper((unsigned char) ch);
    }
    
    static bool eq(char c1, char c2)
    {
        return to_upper(c1) == to_upper(c2);
    }
    
    static bool lt(char c1, char c2)
    {
         return to_upper(c1) &lt; to_upper(c2);
    }
    
    static int compare(const char* s1, const char* s2, std::size_t n)
    {
        while (n-- != 0)
        {
            if (to_upper(*s1) &lt; to_upper(*s2))
                return -1;
            if (to_upper(*s1) &gt; to_upper(*s2))
                return 1;
            ++s1;
            ++s2;
        }
        return 0;
    }
    
    static const char* find(const char* s, std::size_t n, char a)
    {
        const auto ua{to_upper(a)};
        while (n-- != 0) 
        {
            if (to_upper(*s) == ua)
                return s;
            s++;
        }
        return nullptr;
    }
};
 
template&lt;class DstTraits, class CharT, class SrcTraits&gt;
constexpr std::basic_string_view&lt;CharT, DstTraits&gt;
    traits_cast(const std::basic_string_view&lt;CharT, SrcTraits&gt; src) noexcept
{
    return {src.data(), src.size()};
}
 
int main()
{
    using namespace std::literals;
    
    constexpr auto s1 = "Hello"sv;
    constexpr auto s2 = "heLLo"sv;
    
    if (traits_cast&lt;ci_char_traits&gt;(s1) == traits_cast&lt;ci_char_traits&gt;(s2))
        std::cout &lt;&lt; s1 &lt;&lt; " 和 " &lt;&lt; s2 &lt;&lt; " 相等\n";
}
|output=
Hello 和 heLLo 相等
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/string/dsc basic_string}}
{{dsc inc|cpp/string/dsc basic_string_view}}
{{dsc inc|cpp/io/dsc basic_istream}}
{{dsc inc|cpp/io/dsc basic_ostream}}
{{dsc inc|cpp/io/dsc basic_streambuf}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}