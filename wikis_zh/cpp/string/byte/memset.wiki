{{cpp/title|memset}}
{{cpp/string/byte/navbar}}
{{ddcl|header=cstring|
void* memset( void* dest, int ch, std::size_t count );
}}

将值 {{c|static_cast&lt;unsigned char&gt;(ch)}} 复制到 {{c|dest}} 所指向对象的前 {{c|count}} 个字节中。若该对象是[[cpp/language/object#子对象|潜在重叠的子对象]]或非{{named req|TriviallyCopyable}}（例如标量、C 兼容的结构体或可平凡复制类型的数组），则行为未定义。若 {{c|count}} 大于 {{c|dest}} 所指向的对象大小，则行为未定义。

===参数===
{{par begin}}
{{par|dest|指向要填充的对象的指针}}
{{par|ch|填充字节}}
{{par|count|要填充的字节数}}
{{par end}}

===返回值===
{{c|dest}}

===注解===
若 {{tt|std::memset}} 所修改的对象在其生存期的剩余部分不再被访问，则此函数可以被优化掉（在[[cpp/language/as if|如同]]规则下）（例如 [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=8537 gcc 漏洞 8537]）。为此，此函数不能用于擦洗内存（例如以零填充存储密码的数组）。

该问题的解决方案包含 volatile 指针的 {{ltt|cpp/algorithm/fill|std::fill}}，{{mark c23}} {{ltf|c/string/byte/memset|memset_explicit}}，{{mark c11}} {{ltt|c/string/byte/memset|memset_s}}，FreeBSD [https://www.freebsd.org/cgi/man.cgi?query=explicit_bzero explicit_bzero]，或 Microsoft [https://msdn.microsoft.com/en-us/library/windows/desktop/aa366877.aspx {{tt|SecureZeroMemory}}]。

===示例===
{{example
|code=
#include &lt;bitset&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

int main()
{
    int a[4];
    using bits = std::bitset&lt;sizeof(int) * CHAR_BIT&gt;;
    std::memset(a, 0b1111'0000'0011, sizeof a);
    for (int ai : a)
        std::cout &lt;&lt; bits(ai) &lt;&lt; '\n';
}
|output=
00000011000000110000001100000011
00000011000000110000001100000011
00000011000000110000001100000011
00000011000000110000001100000011
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/string/byte/dsc memcpy}}
{{dsc inc|cpp/string/byte/dsc memmove}}
{{dsc inc|cpp/string/wide/dsc wmemset}}
{{dsc inc|cpp/algorithm/dsc fill}}
{{dsc inc|cpp/algorithm/dsc fill_n}}
{{dsc inc|cpp/types/dsc is_trivially_copyable}}
{{dsc see c|c/string/byte/memset}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}