{{cpp/title|memmove}}
{{cpp/string/byte/navbar}}
{{ddcl|header=cstring|
void* memmove( void* dest, const void* src, std::size_t count );
}}

按顺序进行以下操作：
# 在 {{c|dest}} [[cpp/language/object#对象创建|隐式创建]]对象。
# 从 {{c|src}} 所指向的对象复制 {{c|count}} 个（如同具有 {{c/core|unsigned char}} 类型的，下同）字符到包含 {{c|count}} 个字符的数组 {{c|arr}} 中，其中 {{c|arr}} 不与 {{c|dest}} 和 {{c|src}} 分别指向的两个对象重合。
# 从 {{c|arr}} 复制 {{c|count}} 个字符到 {{c|dest}} 所指向的对象中。

如果 {{c|dest}} 或 {{c|src}} 是{{ls|cpp/language/pointer#空指针}}或{{ls|cpp/language/pointer#无效指针}}，那么行为未定义。

===参数===
{{par begin}}
{{par|dest|指向复制目的的内存位置的指针}}
{{par|src|指向复制来源的内存位置的指针}}
{{par|count|要复制的字节数}}
{{par end}}

===返回值===
如果存在[[cpp/language/object#对象创建|已适当创建的对象]]，那么返回指向该对象的指针；否则返回 {{c|dest}}。

===注解===
尽管规范说明了使用临时缓冲区，此函数的实际实现并不会带来二次复制或额外内存的开销。对于小 {{lc|count}}，它可能加载并写入寄存器；对于更大的内存块，常用方法（glibc 和 bsd libc）是目标在源之前开始的情况下会从缓冲区开始正向复制，否则从末尾反向复制，完全无重叠时回落到更高效的 {{lc|std::memcpy}}。

在{{ls|cpp/language/object#严格的别名使用}}禁止检验同一内存为两个不同类型的值处，可用 {{tt|std::memmove}} 转换值。

===示例===
{{example
|code=
#include &lt;cstring&gt;
#include &lt;iostream&gt;

int main()
{
    char str[] = "1234567890";
    std::cout &lt;&lt; str &lt;&lt; '\n';
    std::memmove(str + 4, str + 3, 3); // 从 [4, 5, 6] 复制到 [5, 6, 7]
    std::cout &lt;&lt; str &lt;&lt; '\n';
}
|output=
1234567890
1234456890
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=4064|std=C++98|before=不明确返回的指针是否指向已适当创建的对象|after=使之明确}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/string/byte/dsc memcpy}}
{{dsc inc|cpp/string/byte/dsc memset}}
{{dsc inc|cpp/string/wide/dsc wmemmove}}
{{dsc inc|cpp/algorithm/dsc copy}}
{{dsc inc|cpp/algorithm/dsc copy_backward}}
{{dsc inc|cpp/types/dsc is_trivially_copyable}}
{{dsc see c|c/string/byte/memmove}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pl|pt|ru}}