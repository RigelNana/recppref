{{cpp/title|memcmp}}
{{cpp/string/byte/navbar}}
{{ddcl|header=cstring|
int memcmp( const void* lhs, const void* rhs, std::size_t count );
}}

转译 {{c|lhs}} 和 {{c|rhs}} 所指向的对象为 {{c/core|unsigned char}} 数组，并比较这些数组的前 {{c|count}} 个字节。按字典序比较。

结果的正负号是在被比较对象中首对相异的字节值（都转译成 {{c/core|unsigned char}}）的差的正负号。

===参数===
{{par begin}}
{{par|lhs, rhs|指向要比较的内存缓冲区的指针}}
{{par|count|要检验的字节数}}
{{par end}}

===返回值===
在 {{c|lhs}} 中首个有差别的字节（转译为 {{c/core|unsigned char}}）小于 {{c|rhs}} 中的对应字节的情况下返回负值。

在 {{c|lhs}} 和 {{c|rhs}} 的所有 {{c|count}} 个字节相等的情况下返回 {{c|0}}。

在 {{c|lhs}} 中首个有差别的字节大于 {{c|rhs}} 中的对应字节的情况下返回正值。

===注解===
此函数读取[[cpp/language/object#对象表示与值表示|对象表示]]，而非对象值，而且典型地只对无填充的可平凡复制对象有意义。例如两个 {{lc|std::string}} 或 {{lc|std::vector}} 类型对象间的 {{tt|memcmp()}} 将不比较它们的内容，而两个 {{c|struct {char c; int n;}&lt;!----&gt;}} 类型对象间的 {{tt|memcmp()}} 将比较填充字节，它们的值在 {{c|c}} 和 {{c|n}} 相同时也可以不同，而且即使没有填充字节，可能在考虑端序的情况下比较 {{tt|int}}。

===示例===
{{example
|code=
#include &lt;cstring&gt;
#include &lt;iostream&gt;

void demo(const char* lhs, const char* rhs, std::size_t sz)
{
    std::cout &lt;&lt; std::string(lhs, sz) &lt;&lt; " 在字典序中";
    int rc = std::memcmp(lhs, rhs, sz);
    if (rc == 0)
        std::cout &lt;&lt; "与 " &lt;&lt; std::string(rhs, sz) &lt;&lt; " 比较相等\n";
    else if (rc &lt; 0)
        std::cout &lt;&lt; "先于 " &lt;&lt; std::string(rhs, sz) &lt;&lt; '\n';
    else if (rc &gt; 0)
        std::cout &lt;&lt; "后于 " &lt;&lt; std::string(rhs, sz) &lt;&lt; '\n';
}

int main()
{
    char a1[] = {'a','b','c'};
    char a2[sizeof a1] = {'a','b','d'};

    demo(a1, a2, sizeof a1);
    demo(a2, a1, sizeof a1);
    demo(a1, a1, sizeof a1);
}
|output=
abc 在字典序中先于 abd
abd 在字典序中后于 abc
abc 在字典序中与 abc 比较相等
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/string/byte/dsc strcmp}}
{{dsc inc|cpp/string/byte/dsc strncmp}}
{{dsc see c|c/string/byte/memcmp}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}