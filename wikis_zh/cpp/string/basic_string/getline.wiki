{{cpp/title|getline}}
{{cpp/string/basic_string/navbar}}
{{dcl begin}}
{{dcl header|string}}
{{dcl|num=1|1=
template&lt; class CharT, class Traits, class Allocator &gt;
std::basic_istream&lt;CharT, Traits&gt;&amp;
    getline( std::basic_istream&lt;CharT, Traits&gt;&amp; input,
             std::basic_string&lt;CharT, Traits, Allocator&gt;&amp; str, CharT delim );
}}
{{dcl|since=c++11|num=2|1=
template&lt; class CharT, class Traits, class Allocator &gt;
std::basic_istream&lt;CharT, Traits&gt;&amp;
    getline( std::basic_istream&lt;CharT, Traits&gt;&amp;&amp; input,
             std::basic_string&lt;CharT, Traits, Allocator&gt;&amp; str, CharT delim );
}}
{{dcl|num=3|1=
template&lt; class CharT, class Traits, class Allocator &gt;
std::basic_istream&lt;CharT, Traits&gt;&amp;
    getline( std::basic_istream&lt;CharT, Traits&gt;&amp; input,
             std::basic_string&lt;CharT, Traits, Allocator&gt;&amp; str );
}}
{{dcl|since=c++11|num=4|1=
template&lt; class CharT, class Traits, class Allocator &gt;
std::basic_istream&lt;CharT, Traits&gt;&amp;
    getline( std::basic_istream&lt;CharT, Traits&gt;&amp;&amp; input,
             std::basic_string&lt;CharT, Traits, Allocator&gt;&amp; str );
}}
{{dcl end}}

{{tt|getline}} 从输入流读取字符并将它们放进字符串：

@1@ 表现为{{named req|UnformattedInputFunction}}，但它不影响 {{c|input.gcount()}}。构造并检查哨兵对象后，进行下列操作：
:@1@ 调用 {{c|str.erase()}}
:@2@ 从 {{c|input}} 提取字符并后附它们到 {{c|str}}，直到满足下列任一条件（按顺序检查）：
::@a@ {{c|input}} 上的文件尾条件，此时 {{tt|getline}} 会设置 {{ltt|cpp/io/ios_base/iostate|eofbit}}。
::@b@ 下个可用输入字符是 {{c|delim}}，以 {{c|Traits::eq(c, delim)}} 进行检测，此时从 {{c|input}} 提取分隔字符，但不后附它到 {{c|str}}。
::@c@ 已经存储了 {{c|str.max_size()}} 个字符，此时 {{tt|getline}} 设置 {{ltt|cpp/io/ios_base/iostate|failbit}} 并返回。
:@3@ 如果由于某种原因，字符一个都没有被提取（甚至连会被丢弃的分隔符都没有被提取），那么 {{tt|getline}} 将设置 {{ltt|cpp/io/ios_base/iostate|failbit}} 并返回。

@2@ 同 {{c|getline(input, str, input.widen('\n'))}}，即默认分隔符是换行符。

===参数===
{{par begin}}
{{par|input|获取数据来源的流}}
{{par|str|放置数据的目标字符串}}
{{par|delim|分隔字符}}
{{par end}}

===返回值===
{{c|input}}

===注解===
消耗空白符分隔的输入（例如 {{c|int n; std::cin &gt;&gt; n;}}）时，任何后随的空白符，包括换行符都会被留在流中。然后当切换到面向行的输入时，以 {{tt|getline}} 取得的首行只会是该空白符。多数情况下这是不想要的行为，可能的解法包括：
* 对 {{tt|getline}} 的显式的额外初始调用
* 以 {{c|std::cin &gt;&gt; std::ws}} 移除额外的空白符
* 以 {{c|std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');}} 忽略输入行上剩下的全部字符

===示例===
{{example
|p=true
|下列代码演示如何用 {{tt|getline}} 函数读取用户输入以及如何逐行处理文件。
|code=
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
 
int main()
{
    // 问候用户
    std::string name;
    std::cout &lt;&lt; "你的名字是？";
    std::getline(std::cin, name);
    std::cout &lt;&lt; "你好 " &lt;&lt; name &lt;&lt; "，很高兴见到你。\n";
 
    // 逐行读文件
    std::istringstream input;
    input.str("1\n2\n3\n4\n5\n6\n7\n");
    int sum = 0;
    for (std::string line; std::getline(input, line); )
        sum += std::stoi(line);
    std::cout &lt;&lt; "\n总和是 " &lt;&lt; sum &lt;&lt; "。\n";
 
    // 使用分隔符读取文本行的各部分
    std::istringstream input2;
    input2.str("a;b;c;d");
    for (std::string line; std::getline(input2, line, ';'); )
        std::cout &lt;&lt; line &lt;&lt; '\n';
}
|p=true
|output=
你的名字是？John Q. Public
你好 John Q. Public，很高兴见到你。

总和是 28。

a
b
c
d
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=91|std=C++98|before={{tt|getline}} 没有表现为无格式输入函数|after=表现为有格式输入函数}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/io/basic_istream/dsc getline}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}