{{cpp/string/basic_string/title|insert_range}}
{{cpp/string/basic_string/navbar}}
{{ddcl|since=c++23|1=
template&lt; container-compatible-range&lt;CharT&gt; R &gt;
constexpr iterator insert_range( const_iterator pos, R&amp;&amp; rg );
}}

向 {{c|pos}} 所指向的元素（如果有）之前插入范围 {{c|rg}} 中的字符。

等价于
{{source|1=
return insert(pos - begin(),
    std::basic_string(
        std::from_range,
        std​::​forward&lt;R&gt;(rg),
        get_allocator())
);
}}

如果 {{c|pos}} 不是 {{c|*this}} 上的有效迭代器，则其行为未定义。

===参数===
{{par begin}}
{{par|pos|迭代器，将在它之前插入字符}}
{{par|rg|{{ls|cpp/ranges/to#容器兼容范围}}}}
{{par end}}

===返回值===
指代插入的第一个字符的迭代器，或者当 {{c|rg}} 为空而没有插入任何字符时为 {{c|pos}}。

===复杂度===
与 {{c|rg}} 的大小成线性。

===异常===
如果 {{c/core|std::allocator_traits&lt;Allocator&gt;::allocate}} 抛出了异常，则它会被重新抛出。

{{cpp/string/basic_string/length error note}}

{{cpp/strong exception safety guarantee}}

===注解===
{{feature test macro|__cpp_lib_containers_ranges|value=202202L|std=C++23|接受 {{ls|cpp/ranges/to#容器兼容范围}}的成员函数}}

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;

int main()
{
    const auto source = {'l', 'i', 'b', '_'};
    std::string target{"__cpp_containers_ranges"};
    //                        ^将在此位置前进行插入

    const auto pos = target.find("container");
    assert(pos != target.npos);
    auto iter = std::next(target.begin(), pos);

#ifdef __cpp_lib_containers_ranges
    target.insert_range(iter, source);
#else
    target.insert(iter, source.begin(), source.end());
#endif

    assert(target == "__cpp_lib_containers_ranges");
    //                      ^^^^
}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/string/basic_string/dsc insert}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pl|pt|ru}}