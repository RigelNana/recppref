{{cpp/string/basic_string/title|c_str}}
{{cpp/string/basic_string/navbar}}
{{ddcla|noexcept=c++11|constexpr=c++20|
const CharT* c_str() const;
}}

返回指向拥有数据等价于存储于字符串中的空终止字符数组的指针。

该指针满足范围 {{closed range|c_str()|c_str() + size()}} 有效，且其中的值对应存储于字符串的值，且在最后位置有个附加的空终止字符。

从 {{tt|c_str()}} 获得的指针可能因下列行为失效：
* 将该字符串的非 const 引用传递给任何标准库函数，或
* 在该字符串上调用非 const 成员函数{{rev inl|since=c++11|，不包括 {{lc|operator[]}}、{{lc|at()}}、{{lc|front()}}、{{lc|back()}}、{{lc|begin()}}、{{lc|rbegin()}}、{{lc|end()}} 及 {{lc|rend()}}}}。

通过 {{tt|c_str()}} 写入字符数组是未定义行为。

{{rrev|since=c++11|{{tt|c_str()}} 与 {{lc|data()}} 进行同一功能。}}

===参数===
（无）

===返回值===
指向底层字符存储的指针。

{{rrev multi|until1=c++11
|rev1=
对于 {{range|0|size()}} 中的每个 {{tt|i}} 有 {{c|1=c_str()[i] == operator[](i)}}。
|rev2=
对于 {{closed range|0|size()}} 中的每个 {{tt|i}} 有 {{c|1=c_str() + i == std::addressof(operator[](i))}}。
}}

===复杂度===
常数。

===注解===
从 {{tt|c_str()}} 获得的指针只能在字符串对象不含其他空字符时被当做指向空终止字符串的指针。

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;

extern "C" void c_func(const char* c_str)
{
    printf("以 '%s' 调用 c_func\n", c_str);
}

int main()
{
    std::string const s("Emplary");
    const char* p = s.c_str();
    assert(s.size() == std::strlen(p));
    assert(std::equal(s.begin(), s.end(), p));
    assert(std::equal(p, p + s.size(), s.begin()));
    assert('\0' == *(p + s.size()));

    c_func(s.c_str());
}
|output=
以 'Emplary' 调用 c_func
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/string/basic_string/dsc front}}
{{dsc inc|cpp/string/basic_string/dsc back}}
{{dsc inc|cpp/string/basic_string/dsc data}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pl|pt|ru}}