{{cpp/string/basic_string/title|basic_string}}
{{cpp/string/basic_string/navbar}}
{{dcl begin}}
{{dcl rev begin|num=1}}
{{dcla|since=c++11|until=c++17|
basic_string() : basic_string(Allocator()) {}
}}
{{dcla|since=c++17|constexpr=c++20|
basic_string() noexcept(noexcept(Allocator()))
    : basic_string(Allocator()) {}
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcla|until=c++11|1=
explicit basic_string( const Allocator&amp; alloc = Allocator() );
}}
{{dcla|noexcept=c++17|constexpr=c++20|
explicit basic_string( const Allocator&amp; alloc );
}}
{{dcl rev end}}
{{dcla|num=3|constexpr=c++20|1=
basic_string( size_type count, CharT ch,
              const Allocator&amp; alloc = Allocator() );
}}
{{dcla|num=4|constexpr=c++20|1=
template&lt; class InputIt &gt;
basic_string( InputIt first, InputIt last,
              const Allocator&amp; alloc = Allocator() );
}}
{{dcl|num=5|since=c++23|1=
template&lt; container-compatible-range&lt;CharT&gt; R &gt;
constexpr basic_string( std::from_range_t, R&amp;&amp; rg,
                        const Allocator&amp; = Allocator());
}}
{{dcla|num=6|constexpr=c++20|1=
basic_string( const CharT* s, size_type count,
              const Allocator&amp; alloc = Allocator() );
}}
{{dcla|num=7|constexpr=c++20|1=
basic_string( const CharT* s, const Allocator&amp; alloc = Allocator() );
}}
{{dcl|num=8|since=c++23|1=
basic_string( std::nullptr_t ) = delete;
}}
{{dcla|num=9|since=c++17|constexpr=c++20|1=
template&lt; class StringViewLike &gt;
explicit basic_string( const StringViewLike&amp; t,
                       const Allocator&amp; alloc = Allocator() );
}}
{{dcl|num=10|since=c++17|constexpr=c++20|1=
template&lt; class StringViewLike &gt;
basic_string( const StringViewLike&amp; t,
              size_type pos, size_type count,
              const Allocator&amp; alloc = Allocator() );
}}
{{dcla|num=11|constexpr=c++20|
basic_string( const basic_string&amp; other );
}}
{{dcla|num=12|since=c++11|constexpr=c++20|
basic_string( basic_string&amp;&amp; other ) noexcept;
}}
{{dcla|num=13|since=c++11|constexpr=c++20|
basic_string( const basic_string&amp; other, const Allocator&amp; alloc );
}}
{{dcla|num=14|since=c++11|constexpr=c++20|
basic_string( basic_string&amp;&amp; other, const Allocator&amp; alloc );
}}
{{dcla|num=15|constexpr=c++20|1=
basic_string( const basic_string&amp; other, size_type pos,
              const Allocator&amp; alloc = Allocator() );
}}
{{dcl|num=16|since=c++23|1=
constexpr basic_string( basic_string&amp;&amp; other, size_type pos,
                        const Allocator&amp; alloc = Allocator() );
}}
{{dcla|num=17|constexpr=c++20|1=
basic_string( const basic_string&amp; other,
              size_type pos, size_type count,
              const Allocator&amp; alloc = Allocator() );
}}
{{dcl|num=18|since=c++23|1=
constexpr basic_string( basic_string&amp;&amp; other,
                        size_type pos, size_type count,
                        const Allocator&amp; alloc = Allocator() );
}}
{{dcla|num=19|since=c++11|constexpr=c++20|1=
basic_string( std::initializer_list&lt;CharT&gt; ilist,
              const Allocator&amp; alloc = Allocator() );
}}
{{dcl end}}

从各种数据源构造新字符串，可以使用用户提供的分配器 {{c|alloc}}。

@1@ C++11 起的默认构造函数。构造拥有默认构造的分配器的空字符串。
@@ 如果 {{tt|Allocator}} 不{{named req|DefaultConstructible}}，那么行为未定义。

@2@ C++11 前的默认构造函数。构造拥有给定分配器 {{c|alloc}} 的空字符串。

@3@ 构造拥有 {{c|count}} 个字符 {{c|ch}} 的副本的字符串。
{{rev begin}}
{{rev|since=c++11|
如果 {{tt|CharT}} 不{{named req|CopyInsertable}}到 {{c/core|std::basic_string&lt;CharT&gt;}} 中，那么行为未定义。
}}
{{rev|since=c++17|
{{cpp/enable if| {{tt|Allocator}} 满足{{named req|Allocator}}}}。
}}
{{rev end}}

@4@ 以范围 {{range|first|last}} 的内容构造字符串。{{range|first|last}} 中的每个迭代器都只会解引用一次。
{{rev begin}}
{{rev|until=c++11|
如果 {{tt|InputIt}} 不满足{{named req|InputIterator}}，那么就会改为以实参 {{c|static_cast&lt;size_type&gt;(first)}}、{{c|last}} 和 {{c|alloc}} 调用重载 {{v|3}}。
}}
{{rev|since=c++11|
{{cpp/enable if| {{tt|InputIt}} 满足{{named req|InputIterator}}}}。

如果 {{tt|CharT}} 从 {{c|*first}} 不{{named req|EmplaceConstructible}}到 {{c/core|std::basic_string&lt;CharT&gt;}} 中，那么行为未定义。
}}
{{rev end}}

@5@ 以范围 {{c|rg}} 的内容构造字符串。{{c|rg}} 中的每个迭代器都只会解引用一次。
@@ 如果 {{tt|CharT}} 从 {{c|*ranges::begin(rg)}} 不{{named req|EmplaceConstructible}}到 {{c/core|std::basic_string&lt;CharT&gt;}} 中，那么行为未定义。

@6@ 以范围 {{range|s|s + count}} 的内容构造字符串。
@@ 如果 {{range|s|s + count}} 不是[[cpp/iterator#范围|有效范围]]，那么行为未定义。

@7@ 等价于 {{c|basic_string(s, Traits::length(s), alloc)}}。
{{rrev|since=c++17|
{{cpp/enable if| {{tt|Allocator}} 满足{{named req|Allocator}}}}。
}}

@8@ 不能从 {{c|nullptr}} 构造 {{tt|std::basic_string}}。

@9@ {{cpp/string/sv hack|如同以 {{c|basic_string(sv.data(), sv.size(), alloc)}} 构造字符串}}

@10@ {{cpp/string/sv hack|checkptr=no|如同以 {{c|basic_string(sv.substr(pos, count), alloc)}} 构造字符串}}

@11-18@ 以 {{c|other}} 的（部分）内容构造字符串。如果 {{c|other}} 的类型是 {{tt|basic_string&amp;&amp;}}，那么在构造完成时，{{c|other}} 会处于某个未指定的有效状态。

:@11@ 复制构造函数
{{rrev|since=c++11|
如同通过调用 {{c multi|std::allocator_traits&lt;Allocator&gt;::|    select_on_container_copy_construction|        (other.get_allocator())}} 获得分配器。
}}

:@12@ 移动构造函数。如同通过从 {{c|other.get_allocator()}} 移动构造获得分配器。

:@13@ 与构造函数相同，但是会将 {{c|alloc}} 用作分配器。
:@@ 如果 {{tt|CharT}} 不{{named req|CopyInsertable}} 到 {{c/core|std::basic_string&lt;CharT&gt;}} 中，那么行为未定义。

:@14@ 与移动函数相同，但是会将 {{c|alloc}} 用作分配器。
:@@ 如果 {{tt|CharT}} 不{{named req|MoveInsertable}} 到 {{c/core|std::basic_string&lt;CharT&gt;}} 中，那么行为未定义。

:@15,16@ 以范围 {{range|other.data() + pos|other.data() + other.size()}} 的内容构造字符串。

:@17,18@ 以范围 {{range|other.data() + pos|other.data() + (pos + std::min(count, other.size() - pos))}} 的内容构造字符串。

@19@ 等价于 {{c|basic_string(ilist.begin(), ilist.end())}}。

===参数===
{{par begin}}
{{par|alloc|用于此字符串所有内存分配的分配器}}
{{par|count|产生的字符串大小}}
{{par|ch|初始化字符串所用的值}}
{{par|first, last|复制字符的来源范围}}
{{par|rg|与容器兼容的范围}}
{{par|s|指向用作源初始化字符串的字符数组的指针}}
{{par|t|初始化字符串所用的对象（可转换到 {{lc|std::basic_string_view}}）}}
{{par|pos|要包含的首字符位置}}
{{par|other|用作源初始化字符串的另一字符串}}
{{par|ilist|初始化字符串所用的 {{lc|std::initializer_list}}}}
{{par end}}

===复杂度===
@1,2@ 常数。

@3-7@ 与字符串的大小成线性。

@9-11@ 与字符串的大小成线性。

@12@ 常数。

@13@ 与字符串的大小成线性。

@14@ 在 {{c|1=alloc != other.get_allocator()}} 是 {{c|true}} 时成线性，否则是常数。

@15-19@ 与字符串的大小成线性。

===异常===
@10@ 在 {{c|pos}} 在范围外时会抛出 {{lc|std::out_of_range}}。

@14@ 在 {{c|1=alloc == str.get_allocator()}} 是 {{c|true}} 时不会抛出。

@15-18@ 在 {{c|pos &gt; other.size()}} 是 {{c|true}} 时会抛出 {{lc|std::out_of_range}}。

如果构造的字符串长度会超出 {{lc|max_size()}}（例如对于 {{v|3}}，如果 {{c|count &gt; max_size()}}），那么就会抛出 {{lc|std::length_error}}。调用 {{tt|Allocator::allocate}} 可能会抛出。

{{cpp/strong exception safety guarantee|plural=yes}}

===注解===
以含内嵌 {{c|'\0'}} 字符的[[cpp/language/string literal|字符串字面量]]初始化字符串会使用重载 {{v|7}}，它会在首个空字符处停止。这可通过指定不同的构造函数，或通过使用 {{rlpt|operator""s}} 避免：
{{source|1=
std::string s1 = "ab\0\0cd";   // s1 含 "ab"
std::string s2{"ab\0\0cd", 6}; // s2 含 "ab\0\0cd"
std::string s3 = "ab\0\0cd"s;  // s3 含 "ab\0\0cd"
}}

{{feature test macro|__cpp_lib_containers_ranges|value=202202L|std=C++23|使用带标签的构造函数 {{v|5}} 从{{ls|cpp/ranges/to#容器兼容范围}}构造}}

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;

int main()
{
    std::cout &lt;&lt; "1)  string()；";
    std::string s1;
    assert(s1.empty() &amp;&amp; (s1.length() == 0) &amp;&amp; (s1.size() == 0));
    std::cout &lt;&lt; "s1.capacity()：" &lt;&lt; s1.capacity() &lt;&lt; '\n'; // 未指定
    
    std::cout &lt;&lt; "3)  string(size_type count, CharT ch)：";
    std::string s2(4, '=');
    std::cout &lt;&lt; std::quoted(s2) &lt;&lt; '\n'; // "===="
    
    std::cout &lt;&lt; "4)  string(InputIt first, InputIt last)：";
    char mutable_c_str[] = "another C-style string";
    std::string s4(std::begin(mutable_c_str) + 8, std::end(mutable_c_str) - 1);
    std::cout &lt;&lt; std::quoted(s4) &lt;&lt; '\n'; // "C-style string"
    
    std::cout &lt;&lt; "6)  string(CharT const* s, size_type count)：";
    std::string s6("C-style string", 7);
    std::cout &lt;&lt; std::quoted(s6) &lt;&lt; '\n'; // "C-style"，即 [0, 7)
    
    std::cout &lt;&lt; "7)  string(CharT const* s)：";
    std::string s7("C-style\0string");
    std::cout &lt;&lt; std::quoted(s7) &lt;&lt; '\n'; // "C-style"
    
    std::cout &lt;&lt; "11) string(string&amp;)：";
    std::string const other11("Exemplar");
    std::string s11(other11);
    std::cout &lt;&lt; std::quoted(s11) &lt;&lt; '\n'; // "Exemplar"
    
    std::cout &lt;&lt; "12) string(string&amp;&amp;)：";
    std::string s12(std::string("C++ by ") + std::string("example"));
    std::cout &lt;&lt; std::quoted(s12) &lt;&lt; '\n'; // "C++ by example"
    
    std::cout &lt;&lt; "15) string(const string&amp; other, size_type pos)：";
    std::string const other15("Mutatis Mutandis");
    std::string s15(other15, 8);
    std::cout &lt;&lt; std::quoted(s15) &lt;&lt; '\n'; // "Mutandis"，即 [8, 16)
    
    std::cout &lt;&lt; "17) string(const string&amp; other, size_type pos, size_type count)：";
    std::string const other17("Exemplary");
    std::string s17(other17, 0, other17.length() - 1);
    std::cout &lt;&lt; std::quoted(s17) &lt;&lt; '\n'; // "Exemplar"
    
    std::cout &lt;&lt; "19) string(std::initializer_list&lt;CharT&gt;)：";
    std::string s19({'C', '-', 's', 't', 'y', 'l', 'e'});
    std::cout &lt;&lt; std::quoted(s19) &lt;&lt; '\n'; // "C-style"
}
|p=true&lt;!-- 因为 .capacity() --&gt;
|output=
1)  string()；s1.capacity()：15
3)  string(size_type count, CharT ch)："===="
4)  string(InputIt first, InputIt last)："C-style string"
6)  string(CharT const* s, size_type count)："C-style"
7)  string(CharT const* s)："C-style"
11) string(string&amp;)："Exemplar"
12) string(string&amp;&amp;)："C++ by example"
15) string(const string&amp; other, size_type pos)："Mutandis"
17) string(const string&amp; other, size_type pos, size_type count)："Exemplar"
19) string(std::initializer_list&lt;CharT&gt;)："C-style"
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=301|std=C++98|before=重载 {{v|4}} 在 {{tt|InputIt}} 是整数类型时不会使用形参 {{c|alloc}}|after=使用该形参}}
{{dr list item|wg=lwg|dr=438|std=C++98|before=重载 {{v|4}} 只有在 {{tt|InputIt}} 是整数类型时才会调用重载 {{v|3}}|after=会在 {{tt|InputIt}} 不是&lt;br&gt;{{named req|InputIterator}}时调用}}
{{dr list item|wg=lwg|dr=847|std=C++98|before=没有异常安全保证|after=添加强异常安全保证}}
{{dr list item|wg=lwg|dr=2193|std=C++11|before=默认构造函数是显式的|after=改成非显式的}}
{{dr list item|wg=lwg|dr=2235|std=C++98|before={{c|s}} 可以是空指针值|after=此时行为未定义}}
{{dr list item|wg=lwg|dr=2250|std=C++98|before={{c|pos &gt; other.size()}} 是 {{c|true}} 时重载 {{v|17}} 的行为未定义|after=此时始终会抛出异常}}
{{dr list item|wg=lwg|dr=2583|std=C++98|before=无法为重载 {{v|17}} 提供分配器|after=添加重载 {{v|15}}}}
{{dr list item|wg=lwg|dr=2946|std=C++17|before=重载 {{v|9}} 在一些情况下会导致歧义|after=通过改成模板来避免}}
{{dr list item|wg=lwg|dr=3076|std=C++17|before=重载 {{v|3,7}} 可能会在类模板实参推导中导致歧义|after=添加约束}}
{{dr list item|wg=lwg|dr=3111|paper=P1148R0|std=C++98|before={{lwg|2235}} 的解决方案导致&lt;br&gt;{{c|basic_string(nullptr, 0)}} 的行为未定义|after=此时行为具有良好定义&lt;ref&gt;{{range|nullptr|nullptr + 0}} 是有效的空范围，因为给空指针值加上零也[[cpp/language/operator arithmetic#指针算术|具有良好定义]]（结果仍然是空指针值）。&lt;/ref&gt;}}
{{dr list end}}
&lt;references/&gt;

===参阅===
{{dsc begin}}
{{dsc inc|cpp/string/basic_string/dsc assign}}
{{dsc inc|cpp/string/basic_string/dsc operator{{=}}}}
{{dsc inc|cpp/string/basic_string/dsc to_string}}
{{dsc inc|cpp/string/basic_string/dsc to_wstring}}
{{dsc inc|cpp/string/basic_string_view/dsc constructor}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pl|pt|ru}}