{{cpp/title|operator+{{small|(std::basic_string)}}}}
{{cpp/string/basic_string/navbar}}
{{dcl begin}}
{{dcl header|string}}
{{dcla|num=1|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; lhs,
               const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; rhs );
}}
{{dcl|num=2|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; lhs,
               const CharT* rhs );
}}
{{dcl|num=3|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; lhs,
               CharT rhs );
}}
{{dcla|num=4|since=c++26|1=
template&lt; class CharT, class Traits, class Alloc &gt;
constexpr std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; lhs,
               std::type_identity_t&lt;std::basic_string_view&lt;CharT,Traits&gt;&gt; rhs );
}}
{{dcl|num=5|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( const CharT* lhs,
               const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; rhs );
}}
{{dcl|num=6|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( CharT lhs,
               const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; rhs );
}}
{{dcla|num=7|since=c++26|1=
template&lt; class CharT, class Traits, class Alloc &gt;
constexpr std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( std::type_identity_t&lt;std::basic_string_view&lt;CharT,Traits&gt;&gt; lhs,
               const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; rhs );
}}
{{dcla|num=8|since=c++11|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; lhs,
               std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; rhs );
}}
{{dcl|num=9|since=c++11|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; lhs,
               const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; rhs );
}}
{{dcl|num=10|since=c++11|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; lhs,
               const CharT* rhs );
}}
{{dcl|num=11|since=c++11|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; lhs,
               CharT rhs );
}}
{{dcla|num=12|since=c++26|1=
template&lt; class CharT, class Traits, class Alloc &gt;
constexpr std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; lhs,
               std::type_identity_t&lt;std::basic_string_view&lt;CharT,Traits&gt;&gt; rhs );
}}
{{dcl|num=13|since=c++11|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; lhs,
               std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; rhs );
}}
{{dcl|num=14|since=c++11|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( const CharT* lhs,
               std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; rhs );
}}
{{dcl|num=15|since=c++11|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( CharT lhs,
               std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; rhs );
}}
{{dcla|num=16|since=c++26|1=
template&lt; class CharT, class Traits, class Alloc &gt;
constexpr std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( std::type_identity_t&lt;std::basic_string_view&lt;CharT,Traits&gt;&gt; lhs,
               std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; rhs );
}}
{{dcl end}}

返回含有来自 {{c|lhs}} 的字符后随来自 {{c|rhs}} 的字符的字符串。等价于：

@1,2@ {{c|1=std::basic_string&lt;CharT, Traits, Allocator&gt; r = lhs; r.append(rhs); return r;}}
@3@ {{c|1=std::basic_string&lt;CharT, Traits, Allocator&gt; r = lhs; r.push_back(rhs); return r;}}
@4@ {{c|1=std::basic_string&lt;CharT, Traits, Allocator&gt; r = lhs; r.append(rhs); return r;}}
@5@ {{c|1=std::basic_string&lt;CharT, Traits, Allocator&gt; r = rhs; r.insert(0, lhs); return r;}}
@6@ {{c|1=std::basic_string&lt;CharT, Traits, Allocator&gt; r = rhs; r.insert(r.begin(), lhs); return r;}}
@7@ {{c|1=std::basic_string&lt;CharT, Traits, Allocator&gt; r = rhs; r.insert(0, lhs); return r;}}
@8@ {{c|1=lhs.append(rhs); return std::move(lhs);}}，但 {{c|lhs}} 和 {{c|rhs}} 都留在有效但未指明的状态。如果 {{c|lhs}} 和 {{c|rhs}} 有相等的分配器，则实现可以从任何一个移动。
@9,10@ {{c|1=lhs.append(rhs); return std::move(lhs);}}
@11@ {{c|1=lhs.push_back(rhs); return std::move(lhs);}}
@12@ {{c|1=lhs.append(rhs); return std::move(lhs);}}
@13,14@ {{c|1=rhs.insert(0, lhs); return std::move(rhs);}}
@15@ {{c|1=rhs.insert(rhs.begin(), lhs); return std::move(rhs);}}
@16@ {{c|1=rhs.insert(0, lhs); return std::move(rhs);}}


{{rrev|since=c++11|
结果所用的分配器为：
@1-4@ {{c|std::allocator_traits&lt;Alloc&gt;::select_on_container_copy_construction(lhs.get_allocator())
}}
@5-7@ {{c|std::allocator_traits&lt;Alloc&gt;::select_on_container_copy_construction(rhs.get_allocator())
}}
@8-12@ {{c|lhs.get_allocator()}}
@13-16@ {{c|rhs.get_allocator()}}

换言之：
* 若操作数之一是 {{tt|basic_string}} 右值，则使用其分配器。
* 否则在左值 {{tt|basic_string}} 操作数的分配上使用 {{tt|select_on_container_copy_construction}}。
每种情况下，当两者是拥有同一值类别的 {{tt|basic_string}} 时，偏向左操作数。

{{vl|8-16}} 将所有右值 {{tt|basic_string}} 操作数置于合法但未指定的状态。
}}

===参数===
{{par begin}}
{{par|lhs|字符串{{rev inl|since=c++26|、字符串视图}}、字符或指向空终止字符序列首字符的指针}}
{{par|rhs|字符串{{rev inl|since=c++26|、字符串视图}}、字符或指向空终止字符序列首字符的指针}}
{{par end}} 

===返回值===
含有来自 {{c|lhs}} 的字符后随来自 {{c|rhs}} 的字符的字符串{{rev inl|since=c++11|，使用如上确定的分配器}}。

{{rrev|since=c++11|1=
=== 注解 ===
涉及有状态分配器时{{rev inl|since=c++17|（例如用 {{lc|std::pmr::string}} 时）}}，应该谨慎使用 {{tt|operator+}}。在 {{wg21|P1165R1}} 前，确定结果所用的分配器是历史事故，它在不同重载间无显著理由地变换。另外，对于 {{v|1-5}}，分配器传播行为在主流标准库实现间各异，且异于标准所描述的行为。

{{tt|operator+}} 的结果所用的分配器对值类别敏感，故 {{tt|operator+}} 相对于分配器传播不满足结合律：

{{source|1=
using my_string = std::basic_string&lt;char, std::char_traits&lt;char&gt;, my_allocator&lt;char&gt;&gt;;
my_string cat();
const my_string&amp; dog();

my_string meow = /* ... */, woof = /* ... */;
meow + cat() + /*...*/; // 使用 meow 的分配器上的 select_on_container_copy_construction
woof + dog() + /*...*/; // 转而使用 dog() 的返回值的分配器

meow + woof + meow; // 使用 meow 的分配器上的 SOCCC
meow + (woof + meow); // 转而使用 woof 的分配器上的 select_on_container_copy_construction
}}

对于 {{tt|operator+}} 的调用链，可通过前置拥有所欲分配器的右值 {{tt|basic_string}} 来控制最终结果所用的分配器：

{{source|1=
// 令最终结果使用 my_favorite_allocator
my_string(my_favorite_allocator) + meow + woof + cat() + dog(); 
}}

为了更好且可移植地对分配器进行控制，应该在以所欲分配器构造的结果字符串上，使用 {{rlpf|append}}、{{rlpf|insert}} 及 {{rlpf|1=operator+=}} 之类的成员函数。
}}

{{rrev|since=c++26|1=
根据[[cpp/language/overload_resolution#调用重载运算符|重载决议]]规则&lt;!--[over.match.oper]--&gt;，使用 {{c/core|std::type_identity_t}} 作为重载 {{vl|4}}、{{vl|7}}、{{vl|12}} 和 {{vl|16}} 的形参，保证了 {{c/core|std::basic_string&lt;CharT, Traits, Allocator&gt;}} 类型的对象总是可以与能够隐式转换为 {{c/core|std::basic_string_view&lt;CharT, Traits&gt;}} 的 {{tt|T}} 类型的对象进行连接，反之亦然。

{{ftm begin}}
{{ftm|__cpp_lib_string_view|std=C++26|value=202403|连接字符串和字符串视图，重载 {{vl|4}}、{{vl|7}}、{{vl|12}}、{{vl|16}}}}
{{ftm end}}
}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;

int main()
{
    std::string s1 = "Hello";
    std::string s2 = "world";
    const char* end = "!\n";
    std::cout &lt;&lt; s1 + ' ' + s2 + end;

    std::string_view water{" Water"};
    #if __cpp_lib_string_view &gt;= 202403
    std::cout &lt;&lt; s1 + water + s2 &lt;&lt; end; // 重载 (4)，然后重载 (1)
    #else
    std::cout &lt;&lt; s1 + std::string(water) + s2 &lt;&lt; end; // OK，但较低效
    #endif
}
|output=
Hello world!
Hello Waterworld!
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|paper=P1165R1|std=C++11|before=分配器传播混乱且不一致|after=使之更为一致}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/string/basic_string/dsc operator+{{=}}}}
{{dsc inc|cpp/string/basic_string/dsc append}}
{{dsc inc|cpp/string/basic_string/dsc insert}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}