{{cpp/title|wcstok}}
{{cpp/string/wide/navbar}}
{{dcl begin}}
{{dcl header|cwchar}}
{{dcl|1=
wchar_t* wcstok( wchar_t* str, const wchar_t* delim, wchar_t ** ptr);
}}
{{dcl end}}

寻找 {{c|str}} 所指向的空终止宽字符串中的下个记号。以 {{c|delim}} 所指向的空终止宽字符串鉴别分隔符。

@@ 此函数被设计为调用多次以从同一字符串获得相继的记号。

:* 若 {{c|str !{{=}} nullptr}}，则调用被当做 {{tt|std::wcstok}} 首次对此具体宽字符的调用。函数搜索首个''不''含于 {{c|delim}} 的字符。
::* 若找不到这种宽字符，则 {{c|str}} 中完全无记号，而函数返回空指针。
::* 若找到这种宽字符，则它是''记号起始''。然后函数从该点搜索首个''含于'' {{c|delim}} 的宽字符。 
:::* 若找不到这种宽字符，则 {{c|str}} 只有一个记号，而对 {{tt|std::wcstok}} 的将来调用将返回空指针。
:::* 若找到这种宽字符，则以空宽字符 {{c|L'\0'}} ''替换''它，并存储分析状态（典型地为指向后一宽字符的指针）于用户提供的位置 {{c|*ptr}}。
::* 然后函数返回指向记号起始的指针
:* 若 {{c|str {{==}} NULL}}，则调用被当作对 {{tt|std::wcstok}} 的后继调用：函数从带同一 {{c|*ptr}} 的先前调用所留下的位置开始持续。行为与如同将指向后随上次检测的记号的宽字符的指针作为 {{c|str}} 传递相同。

===参数===
{{par begin}}
{{par|str|指向要记号化的空终止宽字符串的指针}}
{{par|delim|指向标识分隔符的空终止宽字符串的指针}}
{{par|ptr|指向 {{c|wchar_t*}} 类型对象的指针，{{tt|wcstok}} 以之存储分析器的内部状态}}
{{par end}}

===返回值===
返回指向下个记号起始的指针，或若无更多记号则为空指针。

===注解===
此函数是破坏性的：它向字符串 {{c|str}} 的元素中写入 {{c|L'\0'}} 字符。特别是，宽字符串字面量不能用作 {{tt|std::wcstok}} 的首个实参。

不同于 {{lc|std::strtok}}，此函数不更新静态存储：它存储分析状态于用户提供的位置。

不同于大多数其他记号化器，{{tt|std::wcstok}} 中的分隔符对于后继记号可以是不同的，且它甚至能依赖于先前记号的内容。

===示例===
{{example
|code=
#include &lt;cwchar&gt;
#include &lt;iostream&gt;

int main()
{
    wchar_t input[100] = L"A bird came down the walk";
    wchar_t* buffer;
    wchar_t* token = std::wcstok(input, L" ", &amp;buffer);
    while (token)
    {
        std::wcout &lt;&lt; token &lt;&lt; '\n';
        token = std::wcstok(nullptr, L" ", &amp;buffer);
    }
}
|output=
A
bird
came
down
the
walk
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/string/byte/dsc strtok}}
{{dsc see c|c/string/wide/wcstok}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}