{{cpp/title|wmemcmp}}
{{cpp/string/wide/navbar}}
{{ddcl|header=cwchar|
int wmemcmp( const wchar_t* lhs, const wchar_t* rhs, std::size_t count );
}}

比较 {{c|lhs}} 和 {{c|rhs}} 所指向的宽字符数组的前 {{c|count}} 个宽字符。按字典序比较。

结果的正负号是在被比较数组中首对相异的宽字符值的差的正负号。

若 {{c|count}} 为零，则不做任何事。

===参数===
{{par begin}}
{{par|lhs, rhs|指向要比较的宽字符数组的指针}}
{{par|count|要检验的宽字符数}}
{{par end}}

===返回值===
若 {{c|lhs}} 中首个相异的宽字符小于 {{c|rhs}} 中对应的宽字符则为负值：字典序中 {{c|lhs}} 先于 {{c|rhs}}。

若 {{c|lhs}} 和 {{c|rhs}} 的全部 {{c|count}} 个宽字符都相等则为 {{c|0}}。

若 {{c|lhs}} 中首个相异的宽字符大于 {{c|rhs}} 中对应的宽字符则为正值：字典序中 {{c|rhs}} 先于 {{c|lhs}}。

===注解===
此函数不考虑本地环境，且完全不关注其所检验的 {{c|wchar_t}} 对象的值：空字符和非法宽字符亦会被比较。

===示例===
{{example
|code=
#include &lt;clocale&gt;
#include &lt;cwchar&gt;
#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &lt;string&gt;

void demo(const wchar_t* lhs, const wchar_t* rhs, std::size_t sz)
{
    std::wcout &lt;&lt; std::wstring(lhs, sz) &lt;&lt; " 在字典序中\n";
    int rc = std::wmemcmp(lhs, rhs, sz);
    if(rc == 0)
        std::wcout &lt;&lt; "比较等于 ";
    else if(rc &lt; 0)
        std::wcout &lt;&lt; "前驱于 ";
    else if(rc &gt; 0)
        std::wcout &lt;&lt; "后继于 ";
    std::wcout &lt;&lt; std::wstring(rhs, sz);
}

int main()
{
    std::setlocale(LC_ALL, "en_US.utf8");
    std::wcout.imbue(std::locale("en_US.utf8"));

    wchar_t a1[] = {L'α',L'β',L'γ'};
    constexpr std::size_t sz = sizeof a1 / sizeof *a1;
    wchar_t a2[sz] = {L'α',L'β',L'δ'};

    demo(a1, a2, sz);
    demo(a2, a1, sz);
    demo(a1, a1, sz);
}
|p=true
|output=
αβγ 在字典序中前驱于 αβδ
αβδ 在字典序中后继于 αβγ
αβγ 在字典序中比较等于 αβγ
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/string/wide/dsc wcscmp}}
{{dsc inc|cpp/string/byte/dsc memcmp}}
{{dsc inc|cpp/string/wide/dsc wcsncmp}}
{{dsc see c|c/string/wide/wmemcmp}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}