{{cpp/thread/unique_lock/title|lock}}
{{cpp/thread/unique_lock/navbar}}
{{dcl begin}}
{{dcl|since=c++11|1=
void lock();
}}
{{dcl end}}

锁定关联互斥体（即获取其所有权）。相当于调用 {{c|mutex()-&gt;lock()}}。

===参数===
（无）

===返回值===
（无）

===异常===
* {{c|mutex()-&gt;lock()}} 所抛的任何异常。

* 若无关联互斥体，则为以 {{lc|std::errc::operation_not_permitted}} 为错误码的 {{lc|std::system_error}}。

* 若关联互斥体已为此 {{tt|unique_lock}} 所锁定（换言之，{{lc|owns_lock()}} 为 {{c|true}}），则为以 {{lc|std::errc::resource_deadlock_would_occur}} 为错误码的 {{lc|std::system_error}}。

===示例===
{{example
|下列示例用 {{tt|lock}} 重获得被解锁的互斥体。
|p=true
|code=
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

int main()
{
    int counter = 0;
    std::mutex counter_mutex;
    std::vector&lt;std::thread&gt; threads;
  
    auto worker_task = [&amp;](int id)
    {
        std::unique_lock&lt;std::mutex&gt; lock(counter_mutex);
        ++counter;
        std::cout &lt;&lt; id &lt;&lt; ", 内部计数器: " &lt;&lt; counter &lt;&lt; '\n';
        lock.unlock();

        // 我们模拟昂贵操作时不保有锁
        std::this_thread::sleep_for(std::chrono::seconds(1));

        lock.lock();
        ++counter;
        std::cout &lt;&lt; id &lt;&lt; ", 最终计数器: " &lt;&lt; counter &lt;&lt; '\n';
    };

    for (int i = 0; i &lt; 10; ++i)
        threads.emplace_back(worker_task, i);

    for (auto &amp;thread : threads)
        thread.join();
}
|output=
0, 内部计数器: 1
1, 内部计数器: 2
2, 内部计数器: 3
3, 内部计数器: 4
4, 内部计数器: 5
5, 内部计数器: 6
6, 内部计数器: 7
7, 内部计数器: 8
8, 内部计数器: 9
9, 内部计数器: 10
6, 最终计数器: 11
3, 最终计数器: 12
4, 最终计数器: 13
2, 最终计数器: 14
5, 最终计数器: 15
0, 最终计数器: 16
1, 最终计数器: 17
7, 最终计数器: 18
9, 最终计数器: 19
8, 最终计数器: 20
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/thread/unique_lock/dsc try_lock}}
{{dsc inc|cpp/thread/unique_lock/dsc unlock}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}