{{cpp/thread/scoped_lock/title|scoped_lock}}
{{cpp/thread/scoped_lock/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++17|
explicit scoped_lock( MutexTypes&amp;... m );
}}
{{dcl|num=2|since=c++17|
scoped_lock( std::adopt_lock_t, MutexTypes&amp;... m );
}}
{{dcl|num=3|since=c++17|1=
scoped_lock( const scoped_lock&amp; ) = delete;
}}
{{dcl end}}

取得各给定互斥体 {{c|m}} 的所有权。

@1@ 若 {{c|1=sizeof...(MutexTypes) == 0}} 则不做任何事。否则若 {{c|1=sizeof...(MutexTypes) == 1}}，则相当于调用 {{c|m.lock()}}。否则，相当于调用 {{c|std::lock(m...)}}。
@2@ 取得各互斥体 {{c|m...}} 的所有权而不尝试锁定任何互斥体。除非当前线程在 {{tt|m...}} 中的每个对象上保有一个非共享锁（即以 {{tt|lock}}、{{tt|try_lock}}、{{tt|try_lock_for}} 或 {{tt|try_lock_until}} 取得的锁），否则行为未定义。&lt;!-- P2160R1 --&gt;
@3@ 复制构造函数被弃置。

若 {{c|m}} 在 {{tt|scoped_lock}} 对象之前被销毁，则行为未定义。

===参数===
{{par begin}}
{{par|m|要获得所有权的各互斥体}}
{{par end}}

===异常===
@1@ 抛出 {{c|m.lock()}} 所抛的任何异常。
@2@ 不抛出。

===缺陷报告===
{{dr list begin}}
{{dr list item|paper=p0739r0|std=C++17|before={{tt|adopt_lock_t}} 参数在最后，妨碍类模板实参推导|after=移到最前}}
{{dr list end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}