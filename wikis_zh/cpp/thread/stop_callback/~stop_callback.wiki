{{cpp/thread/stop_callback/title|~stop_callback}}
{{cpp/thread/stop_callback/navbar}}
{{ddcl|since=c++20|
~stop_callback();
}}

销毁 {{tt|stop_callback}} 对象。

若 {{c|*this}} 拥有带关联停止状态的 {{tt|stop_token}}，则从它解除注册回调。

若同时在另一线程上调用回调函数，则析构函数直至回调函数调用完成为止都不会完成。若在调用析构函数的同一线程上正在调用回调函数，则析构函数会不等待回调调用完成就返回（见注解）。

===注解===
{{tt|stop_callback}} 析构函数被设计为阻止竞争条件与死锁。若另一线程同时调用回调，则析构函数不能返回直至它完成，否则函数对象能潜在地在执行时被销毁。不要求回调函数自身既不可复制亦不可移动————它在注册后就生存于 {{tt|stop_callback}} 对象自身中。

另一方面，若调用析构函数的当前线程是与调用回调相同的线程，则析构函数不能等待，否则会出现死锁。同一线程在调用 {{tt|stop_callback}} 的回调函数时析构它是可能且合法的，因为回调函数自身可能直接或间接销毁 {{tt|stop_callback}}。

{{langlinks|en|es|ja|ru}}