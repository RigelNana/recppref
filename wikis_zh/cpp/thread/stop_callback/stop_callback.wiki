{{cpp/thread/stop_callback/title|stop_callback}}
{{cpp/thread/stop_callback/navbar}}

{{dcl begin}}
{{dcl|since=c++20|num=1|
template&lt; class C &gt;
explicit stop_callback( const std::stop_token&amp; st, C&amp;&amp; cb ) noexcept(/* 见下文 */);
}}
{{dcl|since=c++20|num=2|
template&lt; class C &gt;
explicit stop_callback( std::stop_token&amp;&amp; st, C&amp;&amp; cb ) noexcept(/* 见下文 */);
}}
{{dcl|since=c++20|num=3|1=
stop_callback( const stop_callback&amp; ) = delete;
}}
{{dcl|since=c++20|num=4|1=
stop_callback( stop_callback&amp;&amp; ) = delete;
}}
{{dcl end}}

构造新的 {{tt|stop_callback}} 对象，保存并注册 {{c|cb}} 回调函数到给定的 {{ltt|cpp/thread/stop_token|std::stop_token}} 关联的停止状态中，以于之后在关联的 {{ltt|cpp/thread/stop_source|std::stop_source}} 的关联停止状态上请求停止时调用。

@1@ 对给定的 {{c|st}}，给定可调用回调函数 {{c|cb}} 构造（复制）{{tt|stop_callback}}。
@2@ 对给定的 {{c|st}}，给定可调用回调函数 {{c|cb}} 构造（移动）{{tt|stop_callback}}。
@3,4@ {{tt|stop_callback}} 既非{{named req|CopyConstructible}}亦非{{named req|MoveConstructible}}。

两个构造函数仅若 {{tt|Callback}} 与 {{tt|C}} 满足 {{c|std::constructible_from&lt;Callback, C&gt;}} 的 {{lconcept|constructible_from}} 才参与重载决议。若 {{tt|Callback}} 与 {{tt|C}} 满足概念但不满足其语义要求，则行为未定义。

===参数===
{{par begin}}
{{par|st|用于注册此 {{tt|stop_callback}} 对象的 {{ltt|cpp/thread/stop_token|std::stop_token}} 对象}}
{{par|cb|请求停止时调用的类型}}
{{par end}}

===异常===
@1,2@ {{noexcept|std::is_nothrow_constructible_v&lt;Callback, C&gt;}}
初始化给定的回调到 {{tt|stop_callback}} 对象中的构造函数所抛出的任何异常。

===注解===
若 {{c|1=st.stop_requested() == true}} 对传入的 {{ltt|cpp/thread/stop_token|std::stop_token}} 成立，则在构造函数返回前于当前线程调用回调函数。

{{langlinks|en|es|ja|ru}}