{{cpp/title|unique_lock}}
{{cpp/thread/unique_lock/navbar}}
{{ddcl|header=mutex|since=c++11|1=
template&lt; class Mutex &gt;
class unique_lock;
}}

类 {{tt|unique_lock}} 是一种通用互斥包装器，允许延迟锁定、有时限的锁定尝试、递归锁定、所有权转移和与条件变量一同使用。

类 {{tt|unique_lock}} 可移动，但不可复制——它满足{{named req|MoveConstructible}}和{{named req|MoveAssignable}}但不满足{{named req|CopyConstructible}}或{{named req|CopyAssignable}}。

类 {{tt|unique_lock}} 满足{{named req|BasicLockable}}的要求。如果 {{tt|Mutex}} 满足{{named req|Lockable}}的要求，那么 {{tt|unique_lock}} 也满足{{named req|Lockable}}的要求（例如：能用于 {{lc|std::lock}}）；如果 {{tt|Mutex}} 满足{{named req|TimedLockable}}的要求，那么 {{tt|unique_lock}} 也满足{{named req|TimedLockable}}的要求。

===模板形参===
{{par begin}}
{{par|Mutex|要锁定的互斥体类型。此类型必须满足{{named req|BasicLockable}}}}
{{par end}}

===嵌套类型===
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc|{{tt|mutex_type}}|{{tt|Mutex}}}}
{{dsc end}}

===成员函数===
{{dsc begin}}
{{dsc inc|cpp/thread/unique_lock/dsc constructor}}
{{dsc inc|cpp/thread/unique_lock/dsc destructor}}
{{dsc inc|cpp/thread/unique_lock/dsc operator{{=}}}}

{{dsc h2|锁定}}
{{dsc inc|cpp/thread/unique_lock/dsc lock}}
{{dsc inc|cpp/thread/unique_lock/dsc try_lock}}
{{dsc inc|cpp/thread/unique_lock/dsc try_lock_for}}
{{dsc inc|cpp/thread/unique_lock/dsc try_lock_until}}
{{dsc inc|cpp/thread/unique_lock/dsc unlock}}

{{dsc h2|修改器}}
{{dsc inc|cpp/thread/unique_lock/dsc swap}}
{{dsc inc|cpp/thread/unique_lock/dsc release}}

{{dsc h2|观察器}}
{{dsc inc|cpp/thread/unique_lock/dsc mutex}}
{{dsc inc|cpp/thread/unique_lock/dsc owns_lock}}
{{dsc inc|cpp/thread/unique_lock/dsc operator bool}}
{{dsc end}}

===非成员函数===
{{dsc begin}}
{{dsc inc|cpp/thread/unique_lock/dsc swap2}}
{{dsc end}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

struct Box
{
    explicit Box(int num) : num_things{num} {}
    
    int num_things;
    std::mutex m;
};

void transfer(Box &amp;from, Box &amp;to, int num)
{
    // 仍未实际取锁
    std::unique_lock lock1{from.m, std::defer_lock};
    std::unique_lock lock2{to.m, std::defer_lock};
    
    // 在不死锁的情况下锁定两个 unique_lock
    std::lock(lock1, lock2);
    
    from.num_things -= num;
    to.num_things += num;
    
    // 互斥体 “from.m” 和 “to.m” 会在 unique_lock 析构函数中解锁
}

int main()
{
    Box acc1(100);
    Box acc2(50);
    
    std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10);
    std::thread t2(transfer, std::ref(acc2), std::ref(acc1), 5);
    
    t1.join();
    t2.join();
    
    std::cout &lt;&lt; "acc1：" &lt;&lt; acc1.num_things &lt;&lt; "\n"
                 "acc2：" &lt;&lt; acc2.num_things &lt;&lt; '\n';
}
|output=
acc1：95
acc2：55
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2981|std=C++17|before=提供来自 {{tt|unique_lock&lt;Mutex&gt;}} 的冗余推导指引| after=已移除}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/thread/dsc lock}}
{{dsc inc|cpp/thread/dsc lock_guard}}
{{dsc inc|cpp/thread/dsc scoped_lock}}
{{dsc inc|cpp/thread/dsc mutex}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}