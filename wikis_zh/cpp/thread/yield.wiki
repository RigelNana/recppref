{{cpp/title|n=this_thread::|yield}}
{{cpp/thread/navbar}}
{{ddcl|header=thread|since=c++11|1=
void yield() noexcept;
}}

向实现提供一个提示，重新调度线程的执行以允许其他线程运行。

===参数===
（无）

===返回值===
（无）

===注解===
此函数的确切行为依赖于实现，特别是取决于使用中的 OS 调度器机制和系统状态。例如，先进先出实时调度器（Linux 的 {{tt|SCHED_FIFO}}）会挂起当前线程并将它放到准备运行的同优先级线程的队列尾，而若无其他线程在同优先级，则 {{tt|yield}} 无效果。

===示例===
{{example
|code=
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

// 建议其他线程运行一小段时间的“忙睡眠”
void little_sleep(std::chrono::microseconds us)
{
    auto start = std::chrono::high_resolution_clock::now();
    auto end = start + us;
    do
    {
        std::this_thread::yield();
    }
    while (std::chrono::high_resolution_clock::now() &lt; end);
}

int main()
{
    auto start = std::chrono::high_resolution_clock::now();

    little_sleep(std::chrono::microseconds(100));

    auto elapsed = std::chrono::high_resolution_clock::now() - start;
    std::cout &lt;&lt; "等待 "
              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(elapsed).count()
              &lt;&lt; " 微秒\n";
}
|p=true
|output=
等待 128 微秒
}}

===参阅===
{{dsc begin}}
{{dsc see c|c/thread/thrd_yield}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}