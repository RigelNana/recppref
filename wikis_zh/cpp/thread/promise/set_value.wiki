{{cpp/thread/promise/title|set_value}}
{{cpp/thread/promise/navbar}}
{{dcl begin}}
{{dcl h|主模板}}
{{dcl|num=1|since=c++11|
void set_value( const R&amp; value );
}}
{{dcl|num=2|since=c++11|
void set_value( R&amp;&amp; value );
}}
{{dcl h|{{c/core|std::promise&lt;R&amp;&gt;}} 特化}}
{{dcl|num=3|since=c++11|
void set_value( R&amp; value );
}}
{{dcl h|{{c/core|std::promise&lt;void&gt;}} 特化}}
{{dcl|num=4|since=c++11|
void set_value();
}}
{{dcl end}}

@1-3@ 原子地存储 {{c|value}} 到共享状态，并使状态就绪。
@4@ 使状态就绪。

{{lc|set_value}}、{{tt|set_exception}}、{{lc|set_value_at_thread_exit}} 和 {{lc|set_exception_at_thread_exit}} 的操作表现类似。在更新承诺体对象时获得与该承诺体对象关联的一个互斥体。

对此函数的调用和对 {{lc|get_future}} 的调用之间不会造成数据竞争（因此它们不需要彼此同步）。

===参数===
{{par begin}}
{{par|value|要在共享状态存储的值}}
{{par end}}

===返回值===
（无）

===异常===
遇到下列条件时抛出 {{lc|std::future_error}}：
* {{c|*this}} 无共享状态。设置错误码为 {{ltt|cpp/thread/future_errc|no_state}}。
* 共享状态已存储值或异常。设置错误码为 {{ltt|cpp/thread/future_errc|promise_already_satisfied}}。

另外还会抛出以下异常：
@1@ 被选中以复制 {{tt|R}} 类型的对象的构造函数抛出的任何异常。
@2@ 被选中以移动 {{tt|R}} 类型的对象的构造函数抛出的任何异常。

===示例===
{{example
|展示如何将 {{c/core|std::promise&lt;void&gt;}} 用于在线程间发信号。
|code=
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;sstream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

using namespace std::chrono_literals;

int main()
{
    std::istringstream iss_numbers{"3 4 1 42 23 -23 93 2 -289 93"};
    std::istringstream iss_letters{" a 23 b,e a2 k k?a;si,ksa c"};
    
    std::vector&lt;int&gt; numbers;
    std::vector&lt;char&gt; letters;
    std::promise&lt;void&gt; numbers_promise, letters_promise;
    
    auto numbers_ready = numbers_promise.get_future();
    auto letter_ready = letters_promise.get_future();
    
    std::thread value_reader([&amp;]
    {
        // 输入/输出操作
        std::copy(std::istream_iterator&lt;int&gt;{iss_numbers},
                  std::istream_iterator&lt;int&gt;{},
                  std::back_inserter(numbers));
        
        // 为数字发出通知
        numbers_promise.set_value();
        
        std::copy_if(std::istreambuf_iterator&lt;char&gt;{iss_letters},
                     std::istreambuf_iterator&lt;char&gt;{},
                     std::back_inserter(letters),
                     ::isalpha);
        
        // 为字母发出通知
        letters_promise.set_value();
    });
    
    
    numbers_ready.wait();
    
    std::sort(numbers.begin(), numbers.end());
    
    if (letter_ready.wait_for(1s) == std::future_status::timeout)
    {
        // 在获取字母的同时输出数字
        for (int num : numbers)
            std::cout &lt;&lt; num &lt;&lt; ' ';
        numbers.clear(); // 数字已打印完成
    }
    
    letter_ready.wait();
    std::sort(letters.begin(), letters.end());
    
    // 已打印数字的情况下什么也不做
    for (int num : numbers)
        std::cout &lt;&lt; num &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
    
    for (char let : letters)
        std::cout &lt;&lt; let &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
    
    value_reader.join();
}
|output=
-289 -23 1 2 3 4 23 42 93 93 
a a a a b c e i k k k s s 
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2098|std=C++11|before=重载 {{v|1,2}} 分别只能抛出由 {{tt|R}} 的&lt;br&gt;复制/移动构造函数抛出的异常|after=它们可以抛出复制/移动 {{tt|R}} 类型&lt;br&gt;对象选择的构造函数抛出的异常}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/thread/promise/dsc set_value_at_thread_exit}}
{{dsc inc|cpp/thread/promise/dsc set_exception}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}