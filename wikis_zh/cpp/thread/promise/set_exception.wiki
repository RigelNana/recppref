{{cpp/thread/promise/title|set_exception}}
{{cpp/thread/promise/navbar}}
{{ddcl|since=c++11|
void set_exception( std::exception_ptr p );
}}

自动存储异常指针 {{c|p}} 到共享状态中，并令状态就绪。

{{lc|set_value}}、{{tt|set_exception}}、{{lc|set_value_at_thread_exit}} 和 {{lc|set_exception_at_thread_exit}} 的操作表现类似。在更新承诺体对象时获得与该承诺体对象关联的一个互斥体。

若无共享状态，或共享状态已存储值或异常，则抛出异常。

对此函数的调用和对 {{lc|get_future}} 的调用之间不会造成数据竞争（因此它们不需要彼此同步）。

===参数===
{{par begin}}
{{par|p|要存储的异常指针。若 {{c|p}} 为空则行为未定义}}
{{par end}}

===返回值===
（无）

===异常===
遇到下列条件时为 {{lc|std::future_error}}：

* {{c|*this}} 无共享状态。设置错误码为 {{ltt|cpp/thread/future_errc|no_state}}。

* 共享状态已存储值或异常。设置错误码为 {{ltt|cpp/thread/future_errc|promise_already_satisfied}}。

===示例===
{{example
|code=
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

int main()
{
    std::promise&lt;int&gt; p;
    std::future&lt;int&gt; f = p.get_future();

    std::thread t([&amp;p]
    {
        try
        {
            // 可能抛出的代码
            throw std::runtime_error("Example");
        }
        catch (...)
        {
            try
            {
                // 将抛出的任何异常存储到承诺体中
                p.set_exception(std::current_exception());
                // 或代之以抛出一个自定义异常
                // p.set_exception(std::make_exception_ptr(MyException("mine")));
            }
            catch(...) {} // set_exception() 亦可能抛出
        }
    });

    try
    {
        std::cout &lt;&lt; f.get();
    }
    catch (const std::exception&amp; e)
    {
        std::cout &lt;&lt; "来自线程的异常: " &lt;&lt; e.what() &lt;&lt; '\n';
    }
    t.join();
}
|output=
来自线程的异常: Example
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/thread/promise/dsc set_exception_at_thread_exit}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}