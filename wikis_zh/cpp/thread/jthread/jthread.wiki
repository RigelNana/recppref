{{cpp/thread/jthread/title|jthread}}
{{cpp/thread/jthread/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++20|
jthread() noexcept;
}}
{{dcl|num=2|since=c++20|
jthread( jthread&amp;&amp; other ) noexcept;
}}
{{dcl|num=3|since=c++20|
template&lt; class F, class... Args &gt; 
explicit jthread( F&amp;&amp; f, Args&amp;&amp;... args );
}}
{{dcl|num=4|since=c++20|1=
jthread( const jthread&amp; ) = delete;
}}
{{dcl end}}

构造新的 {{tt|std::jthread}} 对象。

@1@ 构造不表示线程的新 {{tt|std::jthread}} 对象。

@2@ 移动构造函数。构造的 {{tt|std::jthread}} 对象表示之前由 {{c|other}} 表示的执行线程。此调用后 {{c|other}} 不再表示执行线程。

@3@ 创建与执行线程关联的新 {{tt|std::jthread}} 对象。新的执行线程开始执行：
{{rev begin}}
{{rev|until=c++23|{{box|{{c/core|std::invoke(}}{{lti|cpp/standard library/decay-copy}}{{c/core|(std::forward&lt;F&gt;(f)), get_stop_token(),}}&lt;br&gt;{{tt|{{nbsp|12}}}}{{lti|cpp/standard library/decay-copy}}{{c/core|(std::forward&lt;Args&gt;(args))...)}}}}
}}
{{rev|since=c++23|
{{c multi|std::invoke(auto(std::forward&lt;F&gt;(f)), get_stop_token(),|            auto(std::forward&lt;Args&gt;(args))...)}}
}}
{{rev end}}
如果以上表达式非良构，那么就会开始执行：
{{rev begin}}
{{rev|until=c++23|{{box|{{c/core|std::invoke(}}{{lti|cpp/standard library/decay-copy}}{{c/core|(std::forward&lt;F&gt;(f)),}}&lt;br&gt;{{tt|{{nbsp|12}}}}{{lti|cpp/standard library/decay-copy}}{{c/core|(std::forward&lt;Args&gt;(args))...)}}}}.
}}
{{rev|since=c++23|
{{c multi|std::invoke(auto(std::forward&lt;F&gt;(f)),|            auto(std::forward&lt;Args&gt;(args))...)}}.
}}
{{rev end}}

@@ {{rev inl|until=c++23|对 {{lti|cpp/standard library/decay-copy}} 的调用会在当前线程求值}}{{rev inl|since=c++23|{{c/core|auto}} 产生的值会在当前线程[[cpp/language/implicit conversion#临时量实质化|实质化]]}}，所以实参的求值和复制/移动中抛出的任何异常都会在当前线程抛出，而不会开始新线程。

@@ {{cpp/enable if|plural=yes| {{c/core|std::remove_cvref_t&lt;F&gt;}} 和 {{tt|std::jthread}} 不是同一类型}}。

@@ 如果以下任意值是 {{c|false}}，那么程序非良构：
* {{c|std::is_constructible_v&lt;std::decay_t&lt;F&gt;, F&gt;}}
* {{c|(std::is_constructible_v&lt;std::decay_t&lt;Args&gt;, Args&gt; &amp;&amp; ...)}}
* {{c multi|std::is_invocable_v&lt;std::decay_t&lt;F&gt;, std::decay_t&lt;Args&gt;...&gt; {{!!}}|std::is_invocable_v&lt;std::decay_t&lt;F&gt;, std::stop_token, std::decay_t&lt;Args&gt;...&gt;}}

@@ 构造函数的调用完成[[cpp/atomic/memory_order|同步于]]新的执行线程上 {{c|f}} 副本的调用开始。

@4@ 复制构造函数被弃置；线程不可复制。两个 {{tt|std::jthread}} 对象不能表示同一执行线程。

===参数===
{{par begin}}
{{par|other|用来构造此 {{tt|std::jthread}} 对象的另一 {{tt|std::jthread}} 对象}}
{{par|f|在新线程执行的{{named req|Callable}}对象}}
{{par|args|传递给函数的参数}}
{{par end}}

===后条件===
@1@ {{rlpf|get_id}} 等于 {{ltt|cpp/thread/thread/id|std::jthread::id()}}（即 {{rlpf|joinable}} 返回 {{c|false}}）而 {{c|get_stop_source().stop_possible()}} 是 {{c|false}}。
@2@ {{c|other.get_id()}} 等于 {{ltt|cpp/thread/thread/id|std::jthread::id()}} 而 {{rlpf|get_id}} 返回构造开始前 {{c|other.get_id()}} 的值。
@3@ {{rlpf|get_id}} 不等于 {{ltt|cpp/thread/thread/id|std::jthread::id()}}（即 {{rlpf|joinable}} 返回 {{c|true}}），且 {{c|get_stop_source().stop_possible()}} 是 {{c|true}}。

===异常===
@3@ 如果不能开始线程，那么就会抛出 {{lc|std::system_error}}。异常可能表示错误条件 {{tt|std::errc::resource_unavailable_try_again}} 或另一实现限定的错误条件。

===注解===
线程函数的实参是移动或按值复制的。如果需要传递引用实参给线程函数，那么必须包装它（例如用 {{lc|std::ref}} 或 {{lc|std::cref}}）。

忽略来自函数的任何返回值。如果函数抛出异常，那么就会调用 {{lc|std::terminate}}。需要将返回值或异常传递回调用方线程时可以使用 {{lc|std::promise}} 或 {{lc|std::async}}。

===示例===
{{example
|code=
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;utility&gt;

using namespace std::literals;

void f1(int n)
{
    for (int i = 0; i &lt; 5; ++i)
    {
        std::cout &lt;&lt; "正在执行线程 1\n";
        ++n;
        std::this_thread::sleep_for(10ms);
    }
}
 
void f2(int&amp; n)
{
    for (int i = 0; i &lt; 5; ++i)
    {
        std::cout &lt;&lt; "正在执行线程 2\n";
        ++n;
        std::this_thread::sleep_for(10ms);
    }
}
 
class foo
{
public:
    void bar()
    {
        for (int i = 0; i &lt; 5; ++i)
        {
            std::cout &lt;&lt; "正在执行线程 3\n";
            ++n;
            std::this_thread::sleep_for(10ms);
        }
    }
    int n = 0;
};

class baz
{
public:
    void operator()()
    {
        for (int i = 0; i &lt; 5; ++i)
        {
            std::cout &lt;&lt; "正在执行线程 4\n";
            ++n;
            std::this_thread::sleep_for(10ms);
        }
    }
    int n = 0;
};
 
int main()
{
    int n = 0;
    foo f;
    baz b;
    std::jthread t0; // t0 不是线程
    std::jthread t1(f1, n + 1); // 按值传递
    std::jthread t2a(f2, std::ref(n)); // 按引用传递
    std::jthread t2b(std::move(t2a)); // t2b 现在运行 f2()。t2a 不再是线程
    std::jthread t3(&amp;foo::bar, &amp;f); // t3 在对象 f 上运行 foo::bar()
    std::jthread t4(b); // t4 在对象 b 的副本上运行 baz::operator()
    t1.join();
    t2b.join();
    t3.join();
    std::cout &lt;&lt; "n 的最终值是 " &lt;&lt; n &lt;&lt; '\n';
    std::cout &lt;&lt; "f.n (foo::n) 的最终值是 " &lt;&lt; f.n &lt;&lt; '\n';
    std::cout &lt;&lt; "b.n (baz::n) 的最终值是 " &lt;&lt; b.n &lt;&lt; '\n';
    // t4 在析构时合并
}
|p=true
|output=
正在执行线程 2
正在执行线程 1
正在执行线程 4
正在执行线程 3
正在执行线程 3
正在执行线程 4
正在执行线程 2
正在执行线程 1
正在执行线程 3
正在执行线程 1
正在执行线程 4
正在执行线程 2
正在执行线程 3
正在执行线程 1
正在执行线程 4
正在执行线程 2
正在执行线程 3
正在执行线程 1
正在执行线程 4
正在执行线程 2
n 的最终值是 5
f.n (foo::n) 的最终值是 5
b.n (baz::n) 的最终值是 0
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3476|std=C++20|before=重载 {{v|3}} 直接要求 {{tt|F}} 和实参类型（在退化后）必须可移动构造|after=移除这些要求&lt;ref&gt;{{lc|std::is_constructible_v}} 已间接要求了可移动构造性。&lt;/ref&gt;}}
{{dr list end}}
&lt;references/&gt;

===参阅===
{{dsc begin}}
{{dsc inc|cpp/thread/thread/dsc constructor}}
{{dsc see c|c/thread/thrd_create}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}