{{title|{{tt|std::packaged_task}} 的推导指引}}
{{cpp/thread/packaged_task/navbar}}
{{dcl begin}}
{{dcl header|future}}
{{dcl|num=1|since=c++17|
template&lt; class R, class... Args &gt; 
packaged_task( R(*)(Args...) ) -&gt; packaged_task&lt;R(Args...)&gt;;
}}
{{dcl|num=2|since=c++17|
template&lt; class F &gt;
packaged_task( F ) -&gt; packaged_task&lt;/* 见下文 */&gt;;
}}
{{dcl|num=3|since=c++23|
template&lt; class F &gt;
packaged_task( F ) -&gt; packaged_task&lt;/* 见下文 */&gt;;
}}
{{dcl|num=4|since=c++23|
template&lt; class F &gt;
packaged_task( F ) -&gt; packaged_task&lt;/* 见下文 */&gt;;
}}
{{dcl end}}
@1@ 为 {{lc|std::packaged_task}} 提供此[[cpp/language/class template argument deduction|推导指引]]以允许从函数推导。
@2@ {{cpp/enable_if| {{c|&amp;F::operator()}} 在作为不求值操作数时为良构且 {{c|decltype(&amp;F::operator())}} 的形式为 {{c|R(G::*)(A...)}}（可选地有 cv 限定，可选地有 noexcept，可选地有左值引用限定）而 {{tt|G}} 为类类型}}。推导类型为 {{c|std::packaged_task&lt;R(A...)&gt;}}。
@3@ {{cpp/enable_if| {{c|&amp;F::operator()}} 在作为不求值操作数时为良构且 {{c|F::operator()}} 是具有形式为 {{c|R(G, A...)}} 或 {{c|R(G, A...) noexcept}} 的类型的[[cpp/language/member_functions#显式对象形参|显式对象形参函数]]}}。推导的类型为 {{c|std::packaged_task&lt;R(A...)&gt;}}。
@4@ {{cpp/enable_if| {{c|&amp;F::operator()}} 在作为不求值操作数时为良构且 {{c|F::operator()}} 是具有形式为 {{c|R(A...)}} 或 {{c|R(A...) noexcept}} 的类型的[[cpp/language/static#静态成员函数|静态成员函数]]}}。推导的类型为 {{c|std::packaged_task&lt;R(A...)&gt;}}。

===注解===
这些推导指引不允许从带[[cpp/language/variadic_arguments|省略号形参]]的函数推导，而类型中的 {{c|...}} 始终被当做[[cpp/language/parameter_pack#包展开|包展开]]。

===示例===
{{example
|code=
#include &lt;future&gt;

int func(double) { return 0; }

int main()
{
    std::packaged_task f{func}; // 推导出 packaged_task&lt;int(double)&gt;

    int i = 5;
    std::packaged_task g = [&amp;](double) { return i; }; // 推导出 packaged_task&lt;int(double)&gt;
}
}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}