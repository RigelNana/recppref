{{cpp/title|try_lock}}
{{cpp/thread/navbar}}
{{ddcl|header=mutex|since=c++11|
template&lt; class Lockable1, class Lockable2, class... LockableN &gt;
int try_lock( Lockable1&amp; lock1, Lockable2&amp; lock2, LockableN&amp;... lockn );
}}

尝试锁定每个给定的{{named req|Lockable}}对象 {{c|lock1}}、{{c|lock2}}、{{c|...}}、{{c|lockn}}，从头开始依次调用 {{tt|try_lock}}。

若调用 {{tt|try_lock}} 失败，则不再继续调用 {{tt|try_lock}}，并对任何已锁对象调用 {{tt|unlock}}，返回锁定失败对象的基于 {{c|0}} 的索引。

若调用 {{tt|try_lock}} 抛出异常，则在重抛前对任何已锁对象调用 {{tt|unlock}}。

===参数===
{{par begin}}
{{par|lock1, lock2, ... , lockn|要锁定的{{named req|Lockable}}对象}}
{{par end}}

===返回值===
成功时为 {{c|-1}}，否则为锁定失败对象的基于 {{c|0}} 的索引值。

===示例===
{{example
|下列示例用 {{tt|std::try_lock}} 周期地记录并重置运行于分离线程的计数器。
|p=true
|code=
#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

int main()
{
    int foo_count = 0;
    std::mutex foo_count_mutex;
    int bar_count = 0;
    std::mutex bar_count_mutex;
    int overall_count = 0;
    bool done = false;
    std::mutex done_mutex;

    auto increment = [](int&amp; counter, std::mutex&amp; m, const char* desc)
    {
        for (int i = 0; i &lt; 10; ++i)
        {
            std::unique_lock&lt;std::mutex&gt; lock(m);
            ++counter;
            std::cout &lt;&lt; desc &lt;&lt; ": " &lt;&lt; counter &lt;&lt; '\n';
            lock.unlock();
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    };

    std::thread increment_foo(increment, std::ref(foo_count), 
        std::ref(foo_count_mutex), "foo");
    std::thread increment_bar(increment, std::ref(bar_count), 
        std::ref(bar_count_mutex), "bar");

    std::thread update_overall([&amp;]()
    {
        done_mutex.lock();
        while (!done)
        {
            done_mutex.unlock();
            int result = std::try_lock(foo_count_mutex, bar_count_mutex);
            if (result == -1)
            {
                overall_count += foo_count + bar_count;
                foo_count = 0;
                bar_count = 0;
                std::cout &lt;&lt; "overall: " &lt;&lt; overall_count &lt;&lt; '\n';
                foo_count_mutex.unlock();
                bar_count_mutex.unlock();
            }
            std::this_thread::sleep_for(std::chrono::seconds(2));
            done_mutex.lock();
        }
        done_mutex.unlock();
    });

    increment_foo.join();
    increment_bar.join();
    done_mutex.lock();
    done = true;
    done_mutex.unlock();
    update_overall.join();

    std::cout &lt;&lt; "处理完成\n"
              &lt;&lt; "foo: " &lt;&lt; foo_count &lt;&lt; '\n'
              &lt;&lt; "bar: " &lt;&lt; bar_count &lt;&lt; '\n'
              &lt;&lt; "overall: " &lt;&lt; overall_count &lt;&lt; '\n';
}
|output=
bar: 1
foo: 1
foo: 2
bar: 2
foo: 3
overall: 5
bar: 1
foo: 1
bar: 2
foo: 2
bar: 3
overall: 10
bar: 1
foo: 1
bar: 2
foo: 2
overall: 14
bar: 1
foo: 1
bar: 2
overall: 17
foo: 1
bar: 1
foo: 2
overall: 20
处理完成
foo: 0
bar: 0
overall: 20
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/thread/dsc lock}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}