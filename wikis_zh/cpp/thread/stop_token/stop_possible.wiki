{{cpp/thread/stop_token/title|stop_possible}}
{{cpp/thread/stop_token/navbar}}
{{ddcl|since=c++20|
bool stop_possible() const noexcept;
}}

检查 {{tt|stop_token}} 对象是否拥有关联停止状态，而该状态已被请求停止或拥有关联的 {{lc|std::stop_source}} 对象。

默认构造的 {{c|stop_token}} 无关联停止状态，从而不能请求停止；若未作出停止请求，则不存在 {{lc|std::stop_source}} 对象的关联停止状态亦不能请求停止。

===参数===
（无）

===返回值===
若 {{tt|stop_token}} 对象无关联停止状态，或仍未收到停止请求且无关联的 {{lc|std::stop_source}} 对象则为 {{c|false}}；否则为 {{c|true}}。

===注解===
若 {{tt|stop_token}} 对象拥有关联停止状态且已作出停止请求，则此函数仍返回 {{c|true}}。

若 {{tt|stop_token}} 对象拥有来自 {{lc|std::jthread}} 的关联停止状态——例如 {{tt|stop_token}} 是通过在 {{lc|std::jthread}} 对象上调用 {{c|get_stop_token()}} 取得的——则此函数始终返回 {{c|true}}。{{lc|std::jthread}} 始终拥有内部的 {{lc|std::stop_source}} 对象，即使该线程的调用函数不检查它。

===示例===
{{example
|code=
#include &lt;chrono&gt;
#include &lt;condition_variable&gt;
#include &lt;format&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;string_view&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;

int main()
{
    std::cout &lt;&lt; std::boolalpha;
    auto print = [](std::string_view name, const std::stop_token&amp; token)
    {
        std::cout &lt;&lt; std::format("{}: stop_possible = {:s}, stop_requested = {:s}\n", 
            name, token.stop_possible(), token.stop_requested()
        );
    };

    // 将会监听停止请求的工作线程
    auto stop_worker = std::jthread([](std::stop_token stoken)
    {
        for (int i = 10; i; --i)
        {
            std::this_thread::sleep_for(300ms);
            if (stoken.stop_requested())
            {
                std::cout &lt;&lt; "  嗜睡工人已被请求停止\n";
                return;
            }
            std::cout &lt;&lt; "  嗜睡工人回去睡觉\n";
        }
    });

    // 完成后才停止的工作线程
    auto inf_worker = std::jthread([]()
    {
        for (int i = 5; i; --i)
        {
            std::this_thread::sleep_for(300ms);
            std::cout &lt;&lt; "  如愿持续运行\n";
        }
    });

    std::stop_token def_token;
    std::stop_token stop_token = stop_worker.get_stop_token();
    std::stop_token inf_token = inf_worker.get_stop_token();
    print("def_token ", def_token);
    print("stop_token", stop_token);
    print("inf_token ", inf_token);

    std::cout &lt;&lt; "\n请求并结合 stop_worker:\n";
    stop_worker.request_stop();
    stop_worker.join();

    std::cout &lt;&lt; "\n请求并结合 inf_worker:\n";
    inf_worker.request_stop();
    inf_worker.join();
    std::cout &lt;&lt; '\n';

    print("def_token ", def_token);
    print("stop_token", stop_token);
    print("inf_token ", inf_token);
}
|p=true
|output=
def_token : stop_possible = false, stop_requested = false
stop_token: stop_possible = true, stop_requested = false
inf_token : stop_possible = true, stop_requested = false

请求并结合 stop_worker:
  如愿持续运行
  嗜睡工人已被请求停止

请求并结合 inf_worker:
  如愿持续运行
  如愿持续运行
  如愿持续运行
  如愿持续运行

def_token : stop_possible = false, stop_requested = false
stop_token: stop_possible = true, stop_requested = true
inf_token : stop_possible = true, stop_requested = true
}}

{{langlinks|en|es|ja|ru}}