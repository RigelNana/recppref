{{cpp/io/basic_filebuf/title|setbuf}}
{{cpp/io/basic_filebuf/navbar}}
{{ddcl|
protected:
virtual std::basic_streambuf&lt;CharT, Traits&gt;* setbuf( char_type* s, std::streamsize n )
}}

如果 {{c|s}} 是空指针且 {{c|n}} 为零，那么 filebuf 对输出变成''无缓冲''，这表示 {{tt|pbase()}} 和 {{tt|pptr()}} 为空，而任何输出都被立即发送到文件。

否则，如同调用 {{tt|setbuf()}}，以用户提供的首元素是 {{c|s}} 指向的字符数组替换内部缓冲区（受控制字符序列），并允许此 {{lc|std::basic_filebuf}} 将该数组中的最多 {{c|n}} 个字节用于缓冲。

此函数是受保护虚函数，它只能通过 {{tt|pubsetbuf()}} 或从 {{tt|std::basic_filebuf}} 派生的用户定义类调用。

===参数===
{{par begin}}
{{par|s|指向用户提供缓冲区的首个 {{tt|CharT}} 的指针或空指针}}
{{par|n|用户提供缓冲区中的 {{tt|CharT}} 元素数或零}}
{{par end}}

===返回值===
{{c|this}}

===注解===
可以使用此函数时的条件，和使用提供的缓冲区的方式由实现定义。

* GCC 4.6 libstdc++
: {{tt|setbuf()}} 只能在 {{lc|std::basic_filebuf}} 没有和文件关联时调用（否则无效果）。拥有用户提供的缓冲区时，每次从文件读取 {{tt|n-1}} 字节。
* Clang++3.0 libc++
: {{tt|setbuf()}} 可以在打开文件后，但要在任何输入/输出前调用（否则可能会崩溃）。拥有用户提供缓冲区时，从文件读取适合缓冲区的 4096 最大倍数字节。
* Visual Studio 2010 
: {{tt|setbuf()}} 可以在任何时候调用，即使在某个输入/输出发生后。缓冲区的当前内容会丢失（如果存在）。

标准不定义此函数的任何行为，但要求在任何输入/输出发生前调用的 {{c|setbuf(0, 0)}} 应设置输出为无缓冲。

===示例===
{{example
|为读取提供 10k 缓冲区。在 Linux 上可以使用 strace 工具观察实际读取的字节数。
|code=
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    int cnt = 0;
    std::ifstream file;
    char buf[10241];
    
    file.rdbuf()-&gt;pubsetbuf(buf, sizeof buf);
    file.open("/usr/share/dict/words");
    
    for (std::string line; getline(file, line);)
        ++cnt;
    std::cout &lt;&lt; cnt &lt;&lt; '\n';
}
|output=
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=173|std=C++98|before={{c|n}} 的类型被误指定为 {{c|int}}|after=改成 {{lc|std::streamsize}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/io/basic_streambuf/dsc pubsetbuf|mem=std::basic_streambuf}}
{{dsc inc|cpp/io/c/dsc setvbuf}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}