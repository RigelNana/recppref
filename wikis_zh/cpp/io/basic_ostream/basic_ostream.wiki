{{cpp/io/basic_ostream/title|basic_ostream}}
{{cpp/io/basic_ostream/navbar}}
{{dcl begin}}
{{dcl|num=1|1=
explicit basic_ostream( std::basic_streambuf&lt;CharT, Traits&gt;* sb );
}}
{{dcl|num=2|since=c++11|1=
protected:
basic_ostream( const basic_ostream&amp; rhs ) = delete;
}}
{{dcl|num=3|since=c++11|1=
protected:
basic_ostream( basic_ostream&amp;&amp; rhs );
}}
{{dcl end}}

@1@ 构造 {{tt|basic_ostream}} 对象，通过调用 {{lc|std::basic_ios::init|basic_ios::init(sb)}} 赋初值给基类。

@2@ 复制构造函数受保护且被弃置。输出流不可复制。

@3@ 移动构造函数用 {{tt|basic_ios&lt;CharT, Traits&gt;::move(rhs)}} 从 {{c|rhs}} 移动除了 {{tt|rdbuf()}} 之外的所有 {{tt|basic_ios}} 成员到 {{c|*this}} 中。此移动构造函数受保护：它被可移动输出流类 {{lc|std::basic_ofstream}} 和 {{lc|std::basic_ostringstream}} 的移动构造函数所调用，它们知道如何正确地移动关联的流缓冲区。

===参数===
{{par begin}}
{{par | sb |用作输出序列的流缓冲区}}
{{par | rhs |初始化来源的 basic_ostream}}
{{par end}}

===注解===
因为当 {{c|sb}} 为空指针时 {{lc|std::basic_ios::init|basic_ios::init(sb)}} 会设置 {{tt|badbit}}，又因为当流已经处于故障状态时 {{l2tt|cpp/io/basic_ostream/sentry}} 什么也不做，向从空指针 {{c|sb}} 构造的流进行写入是空操作。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;utility&gt;

int main()
{
    // 错误：复制构造函数被删除
//  std::ostream myout(std::cout);

    // OK：与 cout 共享缓冲
    std::ostream myout(std::cout.rdbuf());

    // 错误：移动构造函数受保护
//  std::ostream s2(std::move(std::ostringstream() &lt;&lt; 7.1));    

    // OK：通过派生类调用移动构造函数
    std::ostringstream s2(std::ostringstream() &lt;&lt; 7.1);
    myout &lt;&lt; s2.str() &lt;&lt; '\n';

    std::ostream dev_null{nullptr}; // 见上文的注解
    dev_null &lt;&lt; "no-op";
}
|output=
7.1
}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}