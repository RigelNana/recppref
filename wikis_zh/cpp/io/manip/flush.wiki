{{cpp/title|flush}}
{{cpp/io/manip/navbar}}
{{ddcl|header=ostream|
template&lt; class CharT, class Traits &gt;
std::basic_ostream&lt;CharT, Traits&gt;&amp; flush( std::basic_ostream&lt;CharT, Traits&gt;&amp; os );
}}

如同以调用 {{c|os.flush()}} 冲洗输出序列 {{c|os}}。

这是仅输出的 I/O 操纵符，可以用如 {{c|out &lt;&lt; std::flush}} 的表达式对任何 {{lc|std::basic_ostream}} 类型的 {{tt|out}} 调用。

===注解===
此操纵符可用于立即产生输出的不完整行，例如从长时间运行的进程显示输出，记录多个线程的活动，或记录可能非预期地崩溃的程序活动。若产生的进程进行任何屏幕 I/O，则调用 {{lc|std::system}} 前亦需要 {{lc|std::cout}} 的显式冲洗（常见例子为 Windows 上的 {{c|std::system("pause")}}）。多数其他常见的交互 I/O 场景中，使用 {{lc|std::cout}} 时 {{lc|std::endl}} 是冗余的，因为任何来自 {{lc|std::cin}} 的输入、到 {{lc|std::cerr}} 的输出或程序终止都会强制调用 {{c|std::cout.flush()}}。

需要冲洗完整行时，可使用 {{lc|std::endl}} 操纵符。

每次输出操作都需要冲洗时，可使用 {{lc|std::unitbuf}} 操纵符。

===参数===
{{par begin}}
{{par|os|到输出流的引用}}
{{par end}}

===返回值===
{{c|os}}（到操纵后的流的引用）。

===示例===
{{example
|若没有 {{tt|std::flush}}，输出可能相同，但可能不实时出现。
|code=
#include &lt;chrono&gt;
#include &lt;iostream&gt;

template&lt;typename Diff&gt;
void log_progress(Diff d)
{
    std::cout &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(d) &lt;&lt; " ... "
              &lt;&lt; std::flush;
}

int main()
{
    volatile int sink = 0;

    auto t1 = std::chrono::high_resolution_clock::now();
    for (int j = 0; j &lt; 5; ++j)
    {
        for (int n = 0; n &lt; 10000; ++n)
            for (int m = 0; m &lt; 20000; ++m)
                sink += m * n; // 做一些工作
        auto now = std::chrono::high_resolution_clock::now();
        log_progress(now - t1);
    }
    std::cout &lt;&lt; '\n';
}
|p=true
|output=
567ms ... 1137ms ... 1707ms ... 2269ms ... 2842ms ...
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/io/manip/dsc unitbuf}}
{{dsc inc|cpp/io/manip/dsc endl}}
{{dsc inc|cpp/io/basic_ostream/dsc flush}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}