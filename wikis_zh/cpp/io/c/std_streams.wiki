{{title|stdin, stdout, stderr}}
{{cpp/io/c/navbar}}
{{dcl begin}}
{{dcl header|cstdio}}
{{dcl|num=1|
#define stdin  /* 由实现定义 */
}}
{{dcl|num=2|
#define stdout /* 由实现定义 */
}}
{{dcl|num=3|
#define stderr /* 由实现定义 */
}}
{{dcl end}}

预定义了三个文本流。这些流在程序启动时隐式打开，且为无取向。

@1@ 与''标准输入''流关联，用于读取约定的输入。程序启动时，当且仅当能确定流不代表交互式设备时该流为完全缓冲。
@2@ 与''标准输出''流关联，用于写入约定的输出。程序启动时，当且仅当能确定流不代表交互式设备时该流为完全缓冲。
@3@ 与''标准错误''流关联，用于写入诊断输出。程序启动时，该流不为完全缓冲。

何者组成交互式设备是实现定义的。

这些宏展开成 {{c|std::FILE*}} 类型的表达式。

===注解===
尽管 POSIX 不强制，但 UNIX 的约定是 {{tt|stdin}} 与 {{tt|stdout}} 若与终端关联则为行缓冲，而 {{tt|stderr}} 为无缓冲。

这些宏可能展开成可修改左值。若修改任何这些 {{c|std::FILE*}} 左值，则对应的流上的后续操作导致未指明或未定义行为。

===示例===
{{example
|此示例展示类似于 {{lc|std::printf}} 的函数。
|code=
#include &lt;concepts&gt;
#include &lt;cstdio&gt;
#include &lt;type_traits&gt;

template&lt;typename T&gt;
concept IsPrintable = std::integral&lt;T&gt; or std::floating_point&lt;T&gt; or std::is_pointer_v&lt;T&gt;;

int my_printf(char const* const format, IsPrintable auto const ... arguments)
{
    return std::fprintf(stdout, format, arguments...);
}

int main(int argv, char*[])
{
    my_printf("字符串和字符:\t%s %c\n", "hello", 'x');
    my_printf("舍入:\t\t%f %.0f %.32f\n", 1.5, 1.5, 1.3);
    my_printf("填充:\t\t%05.2f %.2f %5.2f\n", 1.5, 1.5, 1.5);
    my_printf("科学表示:\t%E %e\n", 1.5, 1.5);
    my_printf("十六进制:\t%a %A 0x%X\n", 1.5, 1.5, &amp;argv);
}
|p=true
|output=
字符串和字符:	hello x
舍入:		1.500000 2 1.30000000000000004440892098500626
填充:		01.50 1.50  1.50
科学表示:	1.500000E+00 1.500000e+00
十六进制:	0x1.8p+0 0X1.8P+0 0x2CFB41BC
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/io/dsc cin}}
{{dsc inc|cpp/io/dsc cout}}
{{dsc inc|cpp/io/dsc cerr}}
{{dsc inc|cpp/io/dsc clog}}
{{dsc inc|cpp/io/c/dsc fprintf}}
{{dsc inc|cpp/io/c/dsc FILE}}
{{dsc see c|c/io/std streams|stdin|stdout|stderr}}
{{dsc end}}

{{langlinks|en|es|ja}}