{{cpp/title|setbuf}}
{{cpp/io/c/navbar}}
{{ddcl|header=cstdio|
void setbuf( std::FILE* stream, char* buffer );
}}

为 C 流 {{c|stream}} 上进行的 I/O 操作设置内部缓冲区。

若 {{c|buffer}} 非空，则等价于 {{c|std::setvbuf(stream, buffer, _IOFBF, BUFSIZ)}}。

若 {{c|buffer}} 为空，则等价于 {{c|std::setvbuf(stream, NULL, _IONBF, 0)}}，这会关闭缓冲。

===参数===
{{par begin}}
{{par|stream|要设置缓冲区的文件流}}
{{par|buffer|指向文件流所用的缓冲区的指针。若提供空指针，则关闭缓冲。若它非空，则数组必须足以保有至少 {{tt|BUFSIZ}} 个字符}}
{{par end}}

===返回值===
（无）

===注解===
若 {{lc|BUFSIZ}} 不是适合的缓冲区大小，则能用 {{lc|std::setvbuf}} 更改它。

{{lc|std::setvbuf}} 亦应当用于检测错误，因为 {{tt|std::setbuf}} 不指示成功或失败。

此函数仅可在已将 {{c|stream}} 关联到打开的文件后，但要在任何其他操作（除了对 {{lc|std::setbuf}}/{{tt|std::setvbuf}} 的失败调用）前使用。

一个常见错误是把 {{lc|stdin}} 或 {{lc|stdout}} 的缓冲区设置为生存期在程序终止前结束的数组：
{{source|1=
int main() {
    char buf[BUFSIZ];
    std::setbuf(stdin, buf);
} // buf 的生存期结束，未定义行为
}}

===示例===
{{example
|{{tt|std::setbuf}} 可用于在要求立即输出的流上禁用缓冲。
|code=
#include &lt;chrono&gt;
#include &lt;cstdio&gt;
#include &lt;thread&gt;

int main()
{
    using namespace std::chrono_literals;

    std::setbuf(stdout, nullptr); // 无缓冲的 stdout
    std::putchar('a'); // 在无缓冲的流上立即显现
    std::this_thread::sleep_for(1s);
    std::putchar('b');
}
|output=
ab
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/io/c/dsc setvbuf}}
{{dsc see c|c/io/setbuf}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}