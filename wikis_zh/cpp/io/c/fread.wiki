{{cpp/title|fread}}
{{cpp/io/c/navbar}}
{{ddcl|header=cstdio|
std::size_t fread( void* buffer, std::size_t size, std::size_t count, std::FILE* stream );
}}

从给定输入流 {{c|stream}} 读取至多 {{c|count}} 个对象到数组 {{c|buffer}} 中，如同以对每个对象调用 {{c|size}} 次 {{lc|std::fgetc}}，并按顺序存储结果到判读为 {{c|unsigned char}} 数组的 {{c|buffer}} 中的相继位置。流的文件位置指示器前进读取的字符数。

若对象不{{named req|TriviallyCopyable}}，则行为未定义。

若出现错误，则流的文件位置指示器的结果值不确定。若不分读入某个元素，则元素值不确定。

===参数===
{{par begin}}
{{par|buffer|指向要读取的数组中首个对象的指针}}
{{par|size|每个对象的字节大小}}
{{par|count|要读取的对象数}}
{{par|stream|读取来源的输入文件流}}
{{par end}}

===返回值===
成功读取的对象数，若出现错误或文件尾条件，则可能小于 {{c|count}}。

若 {{c|size}} 或 {{c|count}} 为零，则 {{tt|fread}} 返回零且不进行其他动作。

{{tt|fread}} 并不区分文件尾和错误，调用方必须使用 {{lc|std::feof}} 和 {{lc|std::ferror}} 来确定发生了什么。

===示例===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;cstdio&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    // 准备文件
    std::ofstream("test.txt") &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; 2 &lt;&lt; '\n';
    std::FILE* f = std::fopen("test.txt", "r");

    std::vector&lt;char&gt; buf(4); // char 可平凡复制
    const std::size_t n = std::fread(&amp;buf[0], sizeof buf[0], buf.size(), f);

    std::cout &lt;&lt; "读取了 " &lt;&lt; n &lt;&lt; " 个对象: "
              &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; std::setfill('0');
    for (char n : buf)
        std::cout &lt;&lt; "0x" &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;short&gt;(n) &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    std::vector&lt;std::string&gt; buf2; // string 不可平凡复制
//  这会导致未定义行为
//  std::fread(&amp;buf2[0], sizeof buf2[0], buf2.size(), f);
}
|p=true
|output=
读取了 4 个对象: 0x31 0x20 0x32 0x0A
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/io/c/dsc fscanf}}
{{dsc inc|cpp/io/c/dsc fgets}}
{{dsc inc|cpp/io/c/dsc fwrite}}
{{dsc see c|c/io/fread}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}