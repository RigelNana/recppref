{{cpp/title|fwrite}}
{{cpp/io/c/navbar}}
{{ddcl|header=cstdio|
std::size_t fwrite( const void* buffer, std::size_t size, std::size_t count, std::FILE* stream );
}}

写 {{c|count}} 个来自给定数组 {{c|buffer}} 的对象到输出流 {{c|stream}}。如同将每个对象判读为 {{c|unsigned char}} 的数组，并对每个对象调用 {{c|size}} 次 {{lc|std::fputc}} 以将那些 {{c|unsigned char}} 按顺序写入 {{c|stream}} 一般写入。该流的文件位置指示器前进写入的字节数。

若对象不{{named req|TriviallyCopyable}}，则行为未定义。

若出现错误，则文件位置指示器的结果值不确定。

===参数===
{{par begin}}
{{par|buffer|指向数组中要被写入的首个对象的指针}}
{{par|size|每个对象的大小}}
{{par|count|要被写入的对象数}}
{{par|stream|要写入的输出文件流}}
{{par end}}

===返回值===
成功写入的对象数，若错误发生则可能小于 {{c|count}}。

若 {{c|size}} 或 {{c|count}} 为零，则 {{tt|fwrite}} 返回零并不进行其他行动。

===示例===
{{example
|code=
#include &lt;array&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;

int main ()
{
    // 写缓冲区到文件
    if (std::FILE* f1 = std::fopen("file.bin", "wb"))
    {
        std::array&lt;int, 3&gt; v = {42, -1, 7}; // std::array 的底层存储为数组
        std::fwrite(v.data(), sizeof v[0], v.size(), f1);
        std::fclose(f1);
    }

    // 读取同一数据并打印它到标准输出
    if (std::FILE* f2 = std::fopen("file.bin", "rb"))
    {
        std::vector&lt;int&gt; rbuf(10); // std::vector 的底层存储亦为数组
        std::size_t sz = std::fread(rbuf.data(), sizeof rbuf[0], rbuf.size(), f2);
        std::fclose(f2);
        for (std::size_t n = 0; n &lt; sz; ++n)
            std::printf("%d\n", rbuf[n]);
    }
}
|output=
42
-1
7
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/io/c/dsc fprintf}}
{{dsc inc|cpp/io/c/dsc fputs}}
{{dsc inc|cpp/io/c/dsc fread}}
{{dsc see c|c/io/fwrite}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}