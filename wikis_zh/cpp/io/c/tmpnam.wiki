{{cpp/title|tmpnam}}
{{cpp/io/c/navbar}}
{{ddcl|header=cstdio|
char* tmpnam( char* filename );
}}

创建不指名当前已存在文件的独有文件名，并将它存储于 {{c|filename}} 所指向的字符串。函数足以生成至多 {{lc|TMP_MAX}} 个独有的文件名，但其一些或全部可能已在使用中，从而不适合作为返回值。

{{lc|std::tmpnam}} 修改静态状态，而且不要求为线程安全。

===参数===
{{par begin}}
{{par|filename|指向足以保有至少 {{lc|L_tmpnam}} 个字节的字符数组的指针，用作结果缓冲区。若传递空指针，则返回指向内部静态缓冲区的指针。}}
{{par end}}

===返回值===
若 {{c|filename}} 不是空指针则为 {{c|filename}}。否则为指向内部静态缓冲区的指针。若无法生成适合的文件名，则返回空指针。

===注解===
尽管 {{lc|std::tmpnam}} 生成的文件名难以预测，但从 {{lc|std::tmpnam}} 返回到程序使用返回的文件名去真正创建一个文件之间，可能会有另一个进程抢用这个文件名去创建文件。标准库函数 {{lc|std::tmpfile}} 和 POSIX 函数 [https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html {{tt|mkstemp}}] 不会有这个问题（但仅使用 C 标准库创建独一的目录仍然会要求使用 {{tt|std::tmpnam}}）。

POSIX 系统额外定义了一个名字类似的函数 [https://pubs.opengroup.org/onlinepubs/9699919799/functions/tempnam.html {{tt|tempnam()}}]，它允许你选择返回文件名所在的目录（默认使用可选定义的宏 [https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdio.h.html {{tt|P_tmpdir}}]）。

===示例===
{{example
|code=
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::string name1 = std::tmpnam(nullptr);
    std::cout &lt;&lt; "临时文件名: " &lt;&lt; name1 &lt;&lt; '\n';

    char name2[L_tmpnam];
    if (std::tmpnam(name2))
        std::cout &lt;&lt; "临时文件名: " &lt;&lt; name2 &lt;&lt; '\n';
}
|p=true
|output=
临时文件名: /tmp/fileDjwifs
临时文件名: /tmp/fileEv2bfW
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/io/c/dsc tmpfile}}
{{dsc inc|cpp/filesystem/dsc temp_directory_path}}
{{dsc see c|c/io/tmpnam}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}