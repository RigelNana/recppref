{{cpp/io/basic_istream/title|sync}}
{{cpp/io/basic_istream/navbar}}
{{ddcl|
int sync();
}}

将输入缓冲区与关联数据源同步。

表现为{{named req|UnformattedInputFunction}}，但不影响 {{lc|gcount()}}。在构造并检查 sentry 对象后，

如果 {{lc|rdbuf()}} 是空指针，那么返回 {{c|-1}}。

否则调用 {{c|rdbuf()-&gt;pubsync()}}。如果该函数返回 {{c|-1}}，那么调用 {{c|setstate(badbit)}} 然后返回 {{c|-1}}。否则返回 {{c|0}}。

===参数===
（无）

===返回值===
成功时返回 {{c|0}}，失败时或若流不支持此操作（无缓冲）时返回 {{c|-1}}。

===注解===
与 {{lc|readsome()}} 类似，此函数是否对库提供的流做任何事由实现定义。目的一般是为了让下个读取操作拾取任何在流缓冲最后填充其获取区后，可能已对关联输入序列做出的更改。为达成它，{{tt|sync()}} 可以清空获取区，或重填充它，或不做任何事。值得注意的例外是 Visual Studio，其中此操作在以标准输入流调用时舍弃未处理的输出。

===示例===
{{example
|演示以文件输入使用输入流 {{tt|sync()}}。注意此处的输出是由实现定义的，由于为读取而对 {{ltt|cpp/io/basic_filebuf/sync|std::basic_filebuf::sync}} 的调用是由实现定义的。
|code=
#include &lt;fstream&gt;
#include &lt;iostream&gt;

void file_abc()
{
    std::ofstream f("test.txt");
    f &lt;&lt; "abc\n";
}

void file_123()
{
    std::ofstream f("test.txt");
    f &lt;&lt; "123\n";
}

int main()
{
    file_abc(); // 文件现在包含 "abc"
    std::ifstream f("test.txt");
    std::cout &lt;&lt; "从文件读取\n";
    char c;
    f &gt;&gt; c;
    std::cout &lt;&lt; c;
    file_123(); // 文件现在包含 "123"
    f &gt;&gt; c;
    std::cout &lt;&lt; c;
    f &gt;&gt; c;
    std::cout &lt;&lt; c &lt;&lt; '\n';
    f.close();

    file_abc(); // 文件现在包含 "abc"
    f.open("test.txt");
    std::cout &lt;&lt; "使用 sync() 的情况下从文件读取\n";
    f &gt;&gt; c;
    std::cout &lt;&lt; c;
    file_123(); // 文件现在包含 "123"
    f.sync();
    f &gt;&gt; c;
    std::cout &lt;&lt; c;
    f &gt;&gt; c;
    std::cout &lt;&lt; c &lt;&lt; '\n';
}
|p=true
|output= &lt;!-- 注意：输出见于 Sun 和 IBM ，但测试的 Linux/gcc 两次都打印 "abc" --&gt;
从文件读取
abc
使用 sync() 的情况下从文件读取
a23
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=62|std=C++98|before={{tt|sync()}} 在 {{c|rdbuf()-&gt;pubsync()}} 返回 {{c|-1}} 时返回 {{c|traits::eof()}}|after=此时返回 {{c|-1}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/io/basic_streambuf/dsc sync}}
{{dsc inc|cpp/io/basic_ostream/dsc flush}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}