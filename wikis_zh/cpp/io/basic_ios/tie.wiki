{{cpp/io/basic_ios/title|tie}}
{{cpp/io/basic_ios/navbar}}
{{dcl begin}}
{{dcl|num=1|
std::basic_ostream&lt;CharT, Traits&gt;* tie() const;
}}
{{dcl|num=2|
std::basic_ostream&lt;CharT, Traits&gt;* tie( std::basic_ostream&lt;CharT, Traits&gt;* str );
}}
{{dcl end}}

管理联系流。联系流是输出流，它与流缓冲（{{lc|rdbuf()}}）所控制的输出序列同步，即在任何 {{c|*this}} 上的输入/输出操作前，都会在联系流上调用 {{c|flush()}}。

@1@ 返回当前联系流。如果没有联系流，那么返回空指针。

@2@ 设置当前联系流为 {{c|str}}。返回操作前的联系流。如果没有联系流，那么返回空指针。如果 {{c|str}} 非空且 {{c|tie()}} 通过遍历从 {{c|str-&gt;tie()}} 开始的包含联系流对象的链表可及，那么行为未定义。

===参数===
{{par begin}}
{{par|str|要设为联系流的输出流}}
{{par end}}

===返回值===
返回联系流，或在没有联系流时返回空指针。

{{cpp/impldef exception}}

===注解===
默认情况下，联系标准流 {{lc|std::cin}} 和 {{lc|std::cerr}} 到 {{lc|std::cout}}。类似地，联系它们的宽对应版本 {{lc|std::wcin}} 和 {{lc|std::wcerr}} 到 {{lc|std::wcout}}。

===示例===
{{example|
|code=
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::ofstream os("test.txt");
    std::ifstream is("test.txt");
    std::string value("0");
    
    os &lt;&lt; "Hello";
    is &gt;&gt; value;
    
    std::cout &lt;&lt; "tie() 之前的结果：" &lt;&lt; std::quoted(value) &lt;&lt; "\n";
    is.clear();
    is.tie(&amp;os);
    
    is &gt;&gt; value;
    
    std::cout &lt;&lt; "tie() 之后的结果：" &lt;&lt; std::quoted(value) &lt;&lt; "\n";
}
|output=
tie() 之前的结果："0"
tie() 之后的结果："Hello"
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=835|std=C++98|before=两个流可以互相（直接或通过中间流间接）联系&lt;ref&gt;因为 {{l2tf std|cpp/io/basic_ostream/flush}} 是{{named req|UnformattedOutputFunction}}，所以它在调用时会创建 sentry 对象。在流对象上调用 {{tt|flush()}} 时，[[cpp/io/basic_ostream/sentry|sentry 对象的构造函数]]会调用联系流的 {{tt|flush()}}，而该 {{tt|flush()}} 又会构造新的 sentry 对象，并且它的构造函数还会调用那个联系流的联系流的 {{tt|flush()}}，以此类推。因此如果流 {{c|a}} 和 {{c|b}} 互相（直接或间接）联系，那么调用 {{c|a.flush()}} 最终会调用 {{c|b.flush()}}，而它最终又会调用 {{c|a.flush()}}，最后导致无限循环。&lt;/ref&gt;|after=此时行为未定义}}
{{dr list end}}
&lt;references/&gt;

{{langlinks|de|en|es|fr|it|ja|pt|ru}}