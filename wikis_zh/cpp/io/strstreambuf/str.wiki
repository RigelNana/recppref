{{cpp/io/strstreambuf/title|str}}
{{cpp/io/strstreambuf/navbar}}
{{ddcl|deprecated=c++98|removed=c++26|
char* str();
}}

调用 {{lc|freeze()}}，然后返回获取区的起始指针，{{lc|std::streambuf::eback()}}。

对于所有通过 {{lc|std::strstream}} 提供的接口构造的可写 {{tt|std::strstreambuf}} 对象，获取区的起始亦为放置区的起始。

===参数===
（无）

===返回值===
{{lc|eback()}} 的副本，可能为空指针。

===注解===
典型地通过 {{lc|std::strstream}} 接口调用此函数。

对 {{lc|freeze()}} 的调用保证返回指针直至下次对 {{box|{{lc|freeze}}{{c/core|(false)}}}} 的显式调用前保持合法：否则（在动态缓冲上）任何输出操作可能触发缓冲区重分配，而这会非法化指针。它亦导致 {{tt|std::strstreambuf}} 的析构函数中的内存泄漏，除非在销毁缓冲（或更常用地为管理它的 {{c|std::strstream}}）前调用 {{c|freeze(false)}}。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;strstream&gt;

int main()
{
    std::strstream dyn; // 动态分配的读/写缓冲区
    dyn &lt;&lt; "Test: " &lt;&lt; 1.23 &lt;&lt; std::ends;
    std::strstreambuf* buf = dyn.rdbuf();
    std::cout &lt;&lt; "R/W buffer holds [" &lt;&lt; buf-&gt;str() // 或 dyn.str()
              &lt;&lt; "]\n";
    dyn.freeze(false); // 在动态 strstream 上调用 .str() 后

    char arr[10];
    std::ostrstream user(arr, 10); // fixed-size write-only buffer
    buf = user.rdbuf();
    user &lt;&lt; 1.23 &lt;&lt; std::ends;
    std::cout &lt;&lt; "Write-only buffer holds [" &lt;&lt; buf-&gt;str() // 或 user.str()
              &lt;&lt; "]\n";

    std::istrstream lit("1 2 3"); // 固定大小只读缓冲区
    buf = lit.rdbuf();
    std::cout &lt;&lt; "Read-only buffer holds [" &lt;&lt; buf-&gt;str() // 或 lit.str()
              &lt;&lt; "\"\n";
}
|output=
R/W buffer holds [Test: 1.23]
Write-only buffer holds [1.23]
Read-only buffer holds [1 2 31 2 3]
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/io/strstream/dsc str|strstream}}
{{dsc inc|cpp/io/strstream/dsc str|ostrstream}}
{{dsc inc|cpp/io/strstream/dsc str|istrstream}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}