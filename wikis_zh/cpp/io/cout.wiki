{{cpp/title|cout|wcout}}
{{cpp/io/basic_ostream/navbar}}
{{dcl begin}}
{{dcl header|iostream}}
{{dcl|num=1|1=
extern std::ostream cout;
}}
{{dcl|num=2|1=
extern std::wostream wcout;
}}
{{dcl end}}

全局对象 {{tt|std::cout}} 和 {{tt|std::wcout}} 控制实现定义类型（派生于 {{lc|std::streambuf}}）流缓冲区的输出，它与标准 C 输出流 {{lc|stdout}} 关联。

保证这些对象在首次构造 {{lc|std::ios_base::Init}} 类型对象期间或之前初始化，并可以在拥有[[cpp/language/initialization#非局部变量|有序初始化]]的静态对象的构造函数和析构函数中使用（只要在定义对象前包含 {{tt|&lt;iostream&gt;}}）。

除非已发出 {{c|sync_with_stdio(false)}}，否则从多个线程为有格式和无格式输出同时访问这些对象是安全的。

根据 {{lc|std::cin}} 的规定，{{c|std::cin.tie()}} 返回 {{c|&amp;std::cout}}。这表示 {{lc|std::cin}} 上的任何输入操作均执行 {{c|std::cout.flush()}}（通过 {{lc|std::basic_istream::sentry}} 构造函数）。

根据 {{lc|std::cerr}} 的规定，{{c|std::cerr.tie()}} 返回 {{c|&amp;std::cout}}。这表示 {{lc|std::cerr}} 上的任何输入操作均执行 {{c|std::cout.flush()}}（通过 {{lc|std::basic_istream::sentry}} 构造函数）。{{mark since c++11}}

===注解===
名称中的 'c' 代表“字符”（[http://www.stroustrup.com/bs_faq2.html#cout stroustrup.com FAQ]）；{{tt|cout}} 表示“字符输出”而 {{tt|wcout}} 表示“宽字符输出”。

因为[[cpp/language/templates#模板化实体|模板化]]变量的[[cpp/language/initialization#动态初始化|动态初始化]]是无序的，所以这种变量的初始化开始之前，不保证 {{tt|std::cout}} 已被初始化为可用状态，除非已经构造了一个 {{lc|std::ios_base::Init}} 类型的对象。

===示例===
{{example
|code=
#include &lt;iostream&gt;

struct Foo
{
    int n;
    Foo()
    {
        std::cout &lt;&lt; "静态构造函数\n";
    }
    ~Foo()
    {
        std::cout &lt;&lt; "静态析构函数\n";
    }
};

Foo f; // 静态对象

int main()
{
    std::cout &lt;&lt; "主函数\n";
}
|output=
静态构造函数
主函数
静态析构函数
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/io/ios_base/dsc Init}}
{{dsc inc|cpp/io/dsc cerr}}
{{dsc inc|cpp/io/dsc clog}}
{{dsc inc|cpp/io/c/dsc std streams}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}