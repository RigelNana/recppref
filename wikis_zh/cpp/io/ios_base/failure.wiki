{{cpp/io/ios_base/title|failure}}
{{cpp/io/ios_base/navbar}}
{{ddcl|header=ios| 
class failure;
}}

类 {{tt|std::ios_base::failure}} 定义输入/输出库中的函数在失败时抛出的异常对象。

{{rrev|since=c++17|
{{tt|std::ios_base::failure}} 可以定义为 {{lc|std::ios_base}} 的成员类，或拥有等价功能的另一个类的同义词（typedef）。
}}

{{rrev multi|until1=c++11
|rev1=
{{inheritance diagram/std-ios_base-failure-2003}}
|rev2=
{{inheritance diagram/std-ios_base-failure}}
}}

===成员函数===
{{dsc begin}}
{{dsc mem ctor|nolink=true|构造拥有指定消息的新 {{tt|failure}} 对象}}
{{dsc mem fun|operator{{=}}|nolink=true|替换 {{tt|failure}} 对象}}
{{dsc mem fun|what|nolink=true|返回解释字符串}}
{{dsc end}}

{{member|{{small|std::ios_base::failure::}}failure|
{{dcl begin}}
{{dcl rev multi|num=1|until1=c++11
|dcl1=
explicit failure( const std::string&amp; message );
|dcl2=
explicit failure( const std::string&amp; message, 
                  const std::error_code&amp; ec = std::io_errc::stream );
}}
{{dcl|num=2|since=c++11|1=
explicit failure( const char* message,
                  const std::error_code&amp; ec = std::io_errc::stream );
}}
{{dcl rev multi|num=3|until1=c++11
|dcl1=
failure( const failure&amp; other );
|dcl2=
failure( const failure&amp; other ) noexcept;
}}
{{dcl end}}

@1,2@ 以 {{c|message}} 作为解释字符串构造异常对象，能在之后用 {{ltf|cpp/error/exception/what}} 取得解释字符串。{{rev inl|since=c++11|用 {{c|ec}} 鉴别特定的失败原因。}}
@3@ 复制构造函数。以 {{c|other}} 的内容初始化内容。{{rev inl|since=c++11|如果 {{c|*this}} 与 {{c|other}} 均拥有动态类型 {{tt|std::ios_base::failure}}，那么 {{c|1=std::strcmp(what(), other.what()) == 0}}。&lt;!-- LWG 471 --&gt;}}

===参数===
{{par begin}}
{{par|message|解释性字符串}}
{{par|ec|鉴别特定失败理由的错误码}}
{{par|other|要复制的另一 {{tt|failure}}}}
{{par end}}

===注解===
因为复制 {{tt|std::ios_base::failure}} 不能抛出异常，通常将此消息在内部存储为分离分配的引用计数字符串。这也是构造函数不接收 {{c/core|std::string&amp;&amp;}} 形参的理由：无论如何它都必须复制内容。
}}

{{cpp/error/exception/member assignment what|ios_base::failure}}

{{cpp/error/system_error/inherit}}
{{cpp/error/runtime_error/inherit}}
{{cpp/error/exception/inherit}}

===注解===
在解决 {{lwg|331}} 前，{{tt|std::ios_base::failure}} 有一个不带 {{c/core|throw()}} 的析构函数声明，但 {{ltt|cpp/error/exception/~exception|std::exception::~exception()}} 的声明却带有 {{c/core|throw()}}&lt;ref&gt;这种不抛出异常声明现在[[cpp/standard library#保证|从标准库全局应用]]，所以标准库类的析构函数的声明不会带有 {{c/core|throw()}} 或 {{c/core|noexcept}}。&lt;/ref&gt;。这就意味着 {{tt|std::ios_base::failure::~failure()}} 的异常声明更弱。解决方案是移除该声明，以保持不抛出的异常声明。

{{lwg|363}} 针对的是同样的缺陷。它的解决方案是给 {{tt|std::ios_base::failure::~failure()}} 的声明加上 {{c/core|throw()}}。该方案因为与前一个方案有冲突而没有被采纳。

&lt;references/&gt;

===示例===
{{example
|code=
#include &lt;fstream&gt;
#include &lt;iostream&gt;

int main()
{
    std::ifstream f("不存在");
    
    try
    {
        f.exceptions(f.failbit);
    }
    catch (const std::ios_base::failure&amp; e)
    {
        std::cout &lt;&lt; "捕获了 ios_base::failure。\n"
                  &lt;&lt; "解释字符串：" &lt;&lt; e.what() &lt;&lt; '\n'
                  &lt;&lt; "错误码：" &lt;&lt; e.code() &lt;&lt; '\n';
    }
}
|p=true
|output=
捕获了 ios_base::failure。
解释字符串：ios_base::clear: 未指定的 iostream_category 错误
错误码：iostream:1
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=48|std=C++98|before=构造函数重载 (1) 以 {{c|msg}} 初始化基类 {{lc|std::exception}}，但基类没有匹配的构造函数|after=删除相应描述}}
{{dr list item|wg=lwg|dr=331|std=C++98|before={{tt|std::ios_base::failure}} 有一个不带 {{c/core|throw()}} 的析构函数声明|after=移除该析构函数声明}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/io/dsc io_errc}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}