{{cpp/io/ios_base/title|sync_with_stdio}}
{{cpp/io/ios_base/navbar}}
{{ddcl|1=
static bool sync_with_stdio( bool sync = true );
}}

设置标准 C++ 流是否与标准 C 流在每次输入/输出操作后同步。

标准 C++ 流：{{lc|std::cin}}、{{lc|std::cout}}、{{lc|std::cerr}}、{{lc|std::clog}}、{{lc|std::wcin}}、{{lc|std::wcout}}、{{lc|std::wcerr}} 和 {{lc|std::wclog}}。

标准 C 流：{{lc|stdin}}、{{lc|stdout}} 和 {{lc|stderr}}。

对于与 C 流 {{c|f}} 同步的标准流 {{c|str}}，下列每对函数调用的效果都相同：
@1@ {{c|std::fputc(f, c)}} 和 {{c|str.rdbuf()-&gt;sputc(c)}}。
@2@ {{c|std::fgetc(f)}} 和 {{c|str.rdbuf()-&gt;sbumpc()}}。
@3@ {{c|std::ungetc(c, f)}} 和 {{c|str.rdbuf()-&gt;sputbackc(c)}}。

实践中，这表示同步的 C++ 流为无缓冲，而每次 C++ 流上的输入/输出都立即应用到对应 C 流的缓冲区。这使得可以自由混合 C++ 与 C 输入/输出。

另外，同步的 C++ 流保证是线程安全的（从多个线程输出的单独字符可能交错，但无数据竞争）。

如果关闭同步，那么允许 C++ 标准流独立地缓冲它的输入/输出，在某些情况下可能明显会更快。

所有八个标准 C++ 流均默认与它们相应的 C 流同步。

如果在标准流上已出现输入/输出后调用此函数，那么行为由实现定义：有的实现没有效果，有的实现销毁读取缓冲区。

===参数===
{{par begin}}
{{par|sync|新的同步设置}}
{{par end}}

===返回值===
调用函数前的同步状态。

===示例===
{{example
|code=
#include &lt;cstdio&gt;
#include &lt;iostream&gt;

int main()
{
    std::ios::sync_with_stdio(false);
    std::cout &lt;&lt; "a\n";
    std::printf("b\n");
    std::cout &lt;&lt; "c\n";
}
|p=true
|output=
b&lt;!-- bac、acb 及 abc 能以不同的编译器/库看到；此处用 bac，因为它演示实际缓冲 C++ 输入/输出流的实现 --&gt;
a
c
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=49|std=C++98|before=未指明 (1) 实际上返回的是哪个状态以及 (2) 标准 C 和 C++ 流之间“同步”是什么意思|after=均已指明}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/io/dsc cout}}
{{dsc inc|cpp/io/dsc cerr}}
{{dsc inc|cpp/io/dsc clog}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}