{{cpp/title|set_terminate}}
{{cpp/error/navbar}}
{{dcl begin}}
{{dcl header|exception}}
{{dcl rev multi|until1=c++11
|dcl1=
std::terminate_handler set_terminate( std::terminate_handler f ) throw();
|dcl2=
std::terminate_handler set_terminate( std::terminate_handler f ) noexcept;
}}
{{dcl end}}

令 {{tt|f}} 为新的全局终止处理器函数并返回先前安装的 {{lc|std::terminate_handler}}。{{c|f}} 应当终止程序的执行而不返回到调用方，否则其行为未定义。

{{rrev|since=c++11|
此函数是线程安全的。每次对 {{tt|std::set_terminate}} 的调用''同步于''（见 {{lc|std::memory_order}}）后继的 {{tt|std::set_terminate}} 与 {{lc|std::get_terminate}} 调用。
}}

===参数===
{{par begin}}
{{par|f|指向 {{lc|std::terminate_handler}} 类型函数的指针，或空指针}}
{{par end}}

===返回值===
之前安装的终止处理器，或若未安装则为空指针值。

===示例===
{{example
|code=
#include &lt;cstdlib&gt;
#include &lt;exception&gt;
#include &lt;iostream&gt;

int main()
{
    std::set_terminate([]()
    {
        std::cout &lt;&lt; "Unhandled exception\n" &lt;&lt; std::flush;
        std::abort();
    });
    throw 1;
}
|p=true
|output=
Unhandled exception
bash: line 7:  7743 Aborted                 (core dumped) ./a.out
}}

终止处理器函数也作用于启动的线程，因此，可以将它用作把线程函数包装到 {{c/core|try}}/{{c/core|catch}} 块中的另一种方式。以下示例中，由于异常未被处理，将会调用 {{lc|std::terminate}}。

{{example
|code=
#include &lt;iostream&gt;
#include &lt;thread&gt;

void run()
{
    throw std::runtime_error("线程失败");
}

int main()
{
    try
    {
        std::thread t{run};
        t.join();
        return EXIT_SUCCESS;
    }
    catch (const std::exception&amp; ex)
    {
        std::cerr &lt;&lt; "异常：" &lt;&lt; ex.what() &lt;&lt; '\n';
    }
    catch (...)
    {
        std::cerr &lt;&lt; "捕获到未知异常\n";
    }
    return EXIT_FAILURE;
}
|p=true
|output=
terminate called after throwing an instance of 'std::runtime_error'
  what():  线程失败
Aborted (core dumped)
}}

引入终止处理器后，从非主线程中抛出的异常都可以被分析，并且可以进行优雅的退出。

{{example
|code=
#include &lt;iostream&gt;
#include &lt;thread&gt;

class foo
{
public:
    foo() { std::cerr &lt;&lt; "foo::foo()\n"; }
    ~foo() { std::cerr &lt;&lt; "foo::~foo()\n"; }
};

// 静态对象，预期退出时执行析构函数
foo f;

void run()
{
    throw std::runtime_error("线程失败");
}

int main()
{
    std::set_terminate([]()
    {
        try
        {
            std::exception_ptr eptr{std::current_exception()};
            if (eptr)
            {
                std::rethrow_exception(eptr);
            }
            else
            {
                std::cerr &lt;&lt; "无异常退出\n";
            }
        }
        catch (const std::exception&amp; ex)
        {
            std::cerr &lt;&lt; "异常: " &lt;&lt; ex.what() &lt;&lt; '\n';
        }
        catch (...)
        {
            std::cerr &lt;&lt; "捕获到未知异常\n";
        }
        std::exit(EXIT_FAILURE);
    });

    std::thread t{run};
    t.join();
}
|output=
foo::foo()
异常：线程失败
foo::~foo()
}}

===参阅===
{{dsc begin}}
{{dsc inc | cpp/error/dsc terminate}}
{{dsc inc | cpp/error/dsc get_terminate}}
{{dsc inc | cpp/error/dsc terminate_handler}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}