{{cpp/title|throw_with_nested}}
{{cpp/error/navbar}}
{{ddcla|header=exception|since=c++11|constexpr=c++26|
template&lt; class T &gt;
[[noreturn]] void throw_with_nested( T&amp;&amp; t );
}}

若 {{c|std::decay&lt;T&gt;::type}} 是非 final、非联合体类型，且既非 {{lc|std::nested_exception}} 亦非从 {{lc|std::nested_exception}} 派生的类类型，则抛出一个从 {{lc|std::nested_exception}} 和 {{c|std::decay&lt;T&gt;::type}} 两者公开派生的未指定类型的异常，它从 {{c|std::forward&lt;T&gt;(t)}} 构造。 {{tt|nested_exception}} 基类的默认构造函数调用 {{lc|std::current_exception}}，以一个 {{lc|std::exception_ptr}} 捕获当前处理的异常对象，若它存在。

否则抛出 {{c|std::forward&lt;T&gt;(t)}}。

要求 {{c|std::decay&lt;T&gt;::type}} 为{{named req|CopyConstructible}}。

===参数===
{{par begin}}
{{par | t | 要抛出的异常对象}}
{{par end}}

===注解===
{{ftm begin}}
{{ftm|__cpp_lib_constexpr_exceptions|value=202411L|std=C++26|{{c/core|constexpr}} 的异常类型}}
{{ftm end}}

===示例===
{{include| cpp/error/example_nested_exception}}

===参阅===
{{dsc begin}}
{{dsc inc | cpp/error/dsc nested_exception}}
{{dsc inc | cpp/error/dsc rethrow_if_nested}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}