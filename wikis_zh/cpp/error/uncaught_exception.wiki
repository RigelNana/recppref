{{cpp/title|uncaught_exception|uncaught_exceptions}}
{{cpp/error/navbar}}
{{dcl begin}}
{{dcl header|exception}}
{{dcl rev begin|num=1}}
{{dcl|until=c++11|
bool uncaught_exception() throw();
}}
{{dcl|since=c++11|deprecated=c++17|removed=c++20|
bool uncaught_exception() noexcept;
}}
{{dcl rev end}}
{{dcla|num=2|since=c++17|constexpr=c++26|
int uncaught_exceptions() noexcept;
}}
{{dcl end}}

@1@ 检测当前线程是否有生存的异常对象，即被抛出或重抛出且未进入匹配的 catch 子句、{{lc|std::terminate}} 或 {{lc|std::unexpected}} 的异常。换言之，{{tt|std::uncaught_exception}} 检测当前是否在进行{{lsd|cpp/language/throw#栈回溯}}。
@2@ 检测当前线程已经抛出或重抛出且未进入其匹配 catch 子句的异常对象数。

有时即使当 {{rev inl|until=c++17|{{c|1=std::uncaught_exception() == true}}}} {{rev inl|since=c++17|{{c|1=std::uncaught_exceptions() &gt; 0}}}} 时，抛出异常也是安全的。例如，如果{{lsd|cpp/language/throw#栈回溯}}导致要析构某个对象，那么该对象的析构函数可以运行抛出异常的代码，只要在离开析构函数前由某个 catch 块捕获该异常即可。

===参数===
（无）

===返回值===
@1@ 此线程中当前正在进行栈回溯时返回 {{c|true}}，否则返回 {{c|false}}。
@2@ 当前线程中未捕获的异常对象的数量。

===注解===
返回 int 的 {{tt|uncaught_exceptions}} 的一个使用例子是 [http://www.boost.org/doc/libs/release/libs/log/doc/html/index.html boost.log] 库：表达式 {{c|BOOST_LOG(logger) &lt;&lt; foo();}} 首先创建保障对象并记录其构造函数中的未捕捉异常数。由保障对象的析构函数进行输出，除非 {{c|foo()}} 抛出了异常（此时析构函数中未捕获的异常的数量大于构造函数所观察到的）。

LFTS v3 中的 {{ltt|cpp/experimental/scope_fail|std::experimental::scope_fail}} 与 {{ltt|cpp/experimental/scope_success|std::experimental::scope_success}} 依赖 {{tt|uncaught_exceptions}} 的功能，因为它们的析构函数需要根据是否在栈回溯中被调用而做不同的事。

{{ftm begin|sort=yes}}
{{ftm|__cpp_lib_uncaught_exceptions|value=201411L|std=C++17|{{tt|std::uncaught_exceptions}}}}
{{ftm|__cpp_lib_constexpr_exceptions|value=202411L|std=C++26|{{c/core|constexpr}} 的异常类型}}
{{ftm end}}

===示例===
{{example
|code=
#include &lt;exception&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

struct Foo
{
    char id{'?'};
    int count = std::uncaught_exceptions();

    ~Foo()
    {
        count == std::uncaught_exceptions()
            ? std::cout &lt;&lt; "正常调用 " &lt;&lt; id &lt;&lt; "~Foo()\n"
            : std::cout &lt;&lt; "在栈回溯中调用 " &lt;&lt; id &lt;&lt; "~Foo()\n");
    }
};

int main()
{
    Foo f{'f'};

    try
    {
        Foo g{'g'};
        std::cout &lt;&lt; "抛出异常\n";
        throw std::runtime_error("测试异常");
    }
    catch (const std::exception&amp; e)
    {
        std::cout &lt;&lt; "捕获到异常：" &lt;&lt; e.what() &lt;&lt; '\n';
    }
}
|p=true
|output=
抛出异常
在栈回溯中调用 g.~Foo()
捕获到异常：测试异常
正常调用 f.~Foo()
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=70|std=C++98|before={{tt|uncaught_exception()}} 的异常说明缺失|after=补充说明 {{tt|throw()}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/error/dsc terminate}}
{{dsc inc|cpp/error/dsc exception_ptr}}
{{dsc inc|cpp/error/dsc current_exception}}
{{dsc end}}

===外部链接===
{{elink begin}}
{{elink|[http://www.gotw.ca/gotw/047.htm GOTW 问题 47 ：未捕捉异常]}}
{{elink|{{stddoc|n4152|{{lc|std::uncaught_exceptions}} 的基本原理}} (N4125)}}
{{elink end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}