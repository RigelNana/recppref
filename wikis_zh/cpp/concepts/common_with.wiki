{{cpp/title|common_with}}
{{cpp/concepts/navbar}}
{{ddcl|header=concepts|since=c++20|1=
template&lt; class T, class U &gt;
concept common_with =
    std::same_as&lt;std::common_type_t&lt;T, U&gt;, std::common_type_t&lt;U, T&gt;&gt; &amp;&amp;
    requires {
        static_cast&lt;std::common_type_t&lt;T, U&gt;&gt;(std::declval&lt;T&gt;());
        static_cast&lt;std::common_type_t&lt;T, U&gt;&gt;(std::declval&lt;U&gt;());
    } &amp;&amp;
    std::common_reference_with&lt;
        std::add_lvalue_reference_t&lt;const T&gt;,
        std::add_lvalue_reference_t&lt;const U&gt;&gt; &amp;&amp;
    std::common_reference_with&lt;
        std::add_lvalue_reference_t&lt;std::common_type_t&lt;T, U&gt;&gt;,
        std::common_reference_t&lt;
            std::add_lvalue_reference_t&lt;const T&gt;,
            std::add_lvalue_reference_t&lt;const U&gt;&gt;&gt;;
}}
概念 {{tt|common_with&lt;T, U&gt;}} 指定两个类型 {{tt|T}} 与 {{tt|U}} 共享一种二者均能转换到的''公共类型''（以 {{lc|std::common_type_t}} 计算）。

===语义要求===
T 与 U 实现 {{co|std::common_with&lt;T, U&gt;}}，仅当给定[[cpp/concepts#相等性保持|保持相等性]]的表达式 {{tt|t1}}、{{tt|t2}}、{{tt|u1}} 和 {{tt|u2}}，且它们满足 {{c|decltype((t1))}} 与 {{c|decltype((t2))}} 均为 {{tt|T}} 而 {{c|decltype((u1))}} 与 {{c|decltype((u2))}} 均为 {{tt|U}}，且满足以下条件
* 当且仅当 {{tt|t1}} 等于 {{tt|t2}} 时 {{c|std::common_type_t&lt;T, U&gt;(t1)}} 等于 {{c|std::common_type_t&lt;T, U&gt;(t2)}}；且
* 当且仅当 {{tt|u1}} 等于 {{tt|u2}} 时 {{c|std::common_type_t&lt;T, U&gt;(u1)}} 等于 {{c|std::common_type_t&lt;T, U&gt;(u2)}}。

换言之，到公共类型的转换必须[[cpp/concepts#相等性保持|保持相等性]]。

{{cpp/concepts/equality preservation|skip-requires=yes}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc common_type}}
{{dsc inc|cpp/types/dsc common_reference}}
{{dsc inc|cpp/concepts/dsc common_reference_with}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}