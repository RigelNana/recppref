{{cpp/title|derived_from}}
{{cpp/concepts/navbar}}
{{ddcl|header=concepts|since=c++20|1=
template&lt; class Derived, class Base &gt;
concept derived_from =
    std::is_base_of_v&lt;Base, Derived&gt; &amp;&amp;
    std::is_convertible_v&lt;const volatile Derived*, const volatile Base*&gt;;
}}

概念 {{c|derived_from&lt;Derived, Base&gt;}} 当且仅当忽略 cv 限定符后 {{tt|Base}} 是类类型，且它为 {{tt|Derived}} 或是 {{tt|Derived}} 的公开无歧义基类才得到满足。

注意当 {{tt|Base}} 是 {{tt|Derived}} 的私有或受保护基类时，此行为异于 {{tt|std::is_base_of}}。

===示例===
{{example
|code=
#include &lt;concepts&gt;

class A {};

class B : public A {};

class C : private A {};

// std::derived_from == true 仅对公有继承或完全相同的类（非基础类型）成立
static_assert(std::derived_from&lt;B, B&gt; == true);      // 相同的类: true
static_assert(std::derived_from&lt;int, int&gt; == false); // 相同的基础类型: false
static_assert(std::derived_from&lt;B, A&gt; == true);      // 公有继承: true
static_assert(std::derived_from&lt;C, A&gt; == false);     // 私有继承: false

// std::is_base_of == true 对私有继承也成立，但仍对完全相同的基础类型不成立
static_assert(std::is_base_of_v&lt;B, B&gt; == true);      // 相同的类: true
static_assert(std::is_base_of_v&lt;int, int&gt; == false); // 相同的基础类型: false
static_assert(std::is_base_of_v&lt;A, B&gt; == true);      // 公有继承: true
static_assert(std::is_base_of_v&lt;A, C&gt; == true);      // 私有继承: true

int main() {}
}}

===引用===
{{ref std c++23}}
{{ref std|section=18.4.3|title=Concept {{tt|derived_from}}|id=concept.derived}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=18.4.3|title=Concept {{tt|derived_from}}|id=concept.derived}}
{{ref std end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_base_of}}
{{dsc inc|cpp/types/dsc is_convertible}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}