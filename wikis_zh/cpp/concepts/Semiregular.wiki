{{cpp/title|semiregular}}
{{cpp/concepts/navbar}}
{{ddcl|header=concepts|since=c++20|1=
template &lt;class T&gt;
concept semiregular = std::copyable&lt;T&gt; &amp;&amp; std::default_initializable&lt;T&gt;;
}}

{{tt|semiregular}} 概念指定类型既为可复制亦为可默认构造。它将被表现类似如 {{c/core|int}} 这样的内建类型的类型所满足，但它们不需要支持以 {{tt|1===}} 进行的比较。

===示例===
{{example
|code=
#include &lt;concepts&gt;
#include &lt;iostream&gt;

template&lt;std::semiregular T&gt;
// 版权所有 Alexander Stepanov
// 概念是 T 上的要求
// T 上的要求：T 为半正则
// T a(b) 或 T a = b =&gt; 复制构造函数；T a =&gt; 默认构造函数；a = b =&gt; 赋值；
struct Single
{
    T value;
    // Single 的聚合初始化表现类似以下构造函数:
    // explicit Single(const T&amp; x) : value(x) {}

    // 隐式声明的特殊成员函数表现类似以下定义，除了它们可以拥有额外属性。
    // Single(const Single&amp; x) : value(x.value) {}
    // Single() {}
    // ~Single() {}
    // Single&amp; operator=(const Single&amp; x) { value = x.value; return *this; }
    // 未定义比较运算符；`semiregular` 概念并不要求它
    // bool operator==(Single const&amp; other) const = delete;
};

void print(std::semiregular auto x)
{
    std::cout &lt;&lt; x.value &lt;&lt; '\n';
}

int main()
{
    Single&lt;int&gt; myInt1{4};      // 聚合初始化: myInt1.value = 4
    Single&lt;int&gt; myInt2(myInt1); // 复制构造函数
    Single&lt;int&gt; myInt3;         // 默认构造函数
    myInt3 = myInt2;            // 复制赋值运算符
//  myInt1 == myInt2;           // 错误: operator== 未定义

    print(myInt1); // ok: Single&lt;int&gt; 是 `semiregular` 类型
    print(myInt2);
    print(myInt3);

}   // Single&lt;int&gt; 变量于此销毁
|output=
4
4
4
}}

===引用===
{{ref std c++23}}
{{ref std|section=18.6|title=Object concepts|id=concepts.object}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=18.6|title=Object concepts|id=concepts.object}}
{{ref std end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/concepts/dsc regular}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}