{{cpp/title|end|cend}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{cpp/iterator/range access headers}}
{{dcla|anchor=no|num=1|since=c++11|constexpr=c++17|
template&lt; class C &gt;
auto end( C&amp; c ) -&gt; decltype(c.end());
}}
{{dcla|anchor=no|num=2|since=c++11|constexpr=c++17|
template&lt; class C &gt;
auto end( const C&amp; c ) -&gt; decltype(c.end());
}}
{{dcla|anchor=no|num=3|since=c++11|constexpr=c++14|noexcept=c++14|
template&lt; class T, std::size_t N &gt;
T* end( T (&amp;array)[N] );
}}
{{dcl|num=4|since=c++14|
template&lt; class C &gt;
constexpr auto cend( const C&amp; c ) noexcept(/* 见下文 */)
    -&gt; decltype(std::end(c));
}}
{{dcl end}}

返回指向给定范围结尾（即最末元素的后一元素）的迭代器。

@1,2@ 返回 {{c|c.end()}}，通常是指向 {{c|c}} 所代表的序列末尾后一位置的迭代器。
:@1@ 如果 {{tt|C}} 是标准{{named req|Container}}，那么就会返回 {{tt|C::iterator}} 对象。
:@2@ 如果 {{tt|C}} 是标准{{named req|Container}}，那么就会返回 {{tt|C::const_iterator}} 对象。

@3@ 返回指向 {{tt|array}} 末尾的指针。

@4@ 返回 {{c|std::end(c)}}，这里 {{c|c}} 始终当做 const 限定。
@@ 如果 {{tt|C}} 是标准{{named req|Container}}，那么就会返回 {{tt|C::const_iterator}} 对象。

{{image|range-begin-end.svg}}

===参数===
{{par begin}}
{{par|c|拥有 {{tt|end}} 成员函数的容器或视图}}
{{par|array|任意类型的数组}}
{{par end}}

===返回值===
@1,2@ {{c|c.end()}}
@3@ {{c|array + N}}
@4@ {{c|c.end()}}

===异常===
@4@ {{noexcept|noexcept(std::end(c))}}

===重载===
可为不暴露适合的 {{tt|end()}} 成员函数的类或枚举提供 {{tt|end}} 的自定义重载。标准库已提供了下列重载：

{{dsc begin}}
{{dsc inc|cpp/utility/initializer_list/dsc end2}}
{{dsc inc|cpp/numeric/valarray/dsc end2}}
{{dsc inc|cpp/filesystem/directory_iterator/dsc begin}}
{{dsc inc|cpp/filesystem/recursive_directory_iterator/dsc begin}}
{{dsc end}}

类似 {{tt|swap}} 的用法（于{{named req|Swappable}}描述），{{tt|end}} 函数在泛型语境中的典型用法等价于 {{c|using std::end; end(arg);}}，这允许[[cpp/language/adl|实参依赖查找]]为用户定义类型所选择的重载，和标准库函数模板在同一重载集中出现。

{{source|1=
template&lt;typename Container, typename Function&gt;
void for_each(Container&amp;&amp; cont, Function f)
{
    using std::begin;
    auto it = begin(cont);
    using std::end;
    auto end_it = end(cont);
    
    for (; it != end_it; ++it)
        f(*it);
}
}}

{{rrev|since=c++20|
[[cpp/language/adl|实参依赖查找]]找到的 {{tt|end}} 重载能用于定制 {{lc|std::ranges::end}}、{{lc|std::ranges::cend}} 及其他依赖于 {{lc|std::ranges::end}} 的定制点对象的行为。
}}

===注解===
非数组重载准确地反映 {{c|C::end()}} 的行为。如果该成员函数的实现不合理，那么就会有意外的效果。

{{tt|std::cend}} 是为统一成员与非成员范围访问引入的。参阅 {{lwg|2128}}。

如果 {{tt|C}} 是浅 const 的视图，那么 {{tt|std::cend}} 可能返回可变的迭代器。某些用户不期待这种行为。参阅 {{wg21|P2276}} 与 {{wg21|P2278}}。

===示例===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; v = {3, 1, 4};
    if (std::find(std::begin(v), std::end(v), 5) != std::end(v))
        std::cout &lt;&lt; "在 vector v 中找到 5！\n";
    
    int w[] = {5, 10, 15};
    if (std::find(std::begin(w), std::end(w), 5) != std::end(w))
        std::cout &lt;&lt; "在数组 w 中找到 5！\n";
}
|output=
在数组 w 中找到 5！
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc begin}}
{{dsc inc|cpp/ranges/dsc end}}
{{dsc inc|cpp/ranges/dsc cend}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}