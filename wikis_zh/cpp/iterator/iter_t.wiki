{{cpp/title|iter_value_t|iter_reference_t|iter_const_reference_t|iter_difference_t|iter_rvalue_reference_t|iter_common_reference_t}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl|num=1|since=c++20|1=
template&lt; class T &gt;
using iter_value_t = /* 见下文 */;
}}
{{dcl|num=2|since=c++20|1=
template&lt; /*dereferenceable*/ T &gt;
using iter_reference_t = decltype(*std::declval&lt;T&amp;&gt;());
}}
{{dcl|num=3|since=c++23|1=
template&lt; std::indirectly_readable T &gt;
using iter_const_reference_t =
    std::common_reference_t&lt;const std::iter_value_t&lt;T&gt;&amp;&amp;,
                            std::iter_reference_t&lt;T&gt;&gt;;
}}
{{dcl|num=4|since=c++20|1=
template&lt; class T &gt;
using iter_difference_t = /* 见下文 */;
}}
{{dcl|num=5|since=c++20|1=
template&lt; /*dereferenceable*/ T&gt;
    requires /* 见下文 */
using iter_rvalue_reference_t =
    decltype(ranges::iter_move(std::declval&lt;T&amp;&gt;()));
}}
{{dcl|num=6|since=c++20|1=
template&lt; std::indirectly_readable T &gt;
using iter_common_reference_t =
    std::common_reference_t&lt;std::iter_reference_t&lt;T&gt;,
                            /*indirect-value-t*/&lt;T&gt;&gt;;
}}
{{dcl h|辅助模板}}
{{dcla|num=7|expos=yes|anchor=dereferenceable|1=
template&lt; class T &gt;
concept /*dereferenceable*/ = /* 见下文 */;
}}
{{dcla|num=8|expos=yes|anchor=indirect-value-t|1=
template&lt; std::indirectly_readable T &gt;
using /*indirect-value-t*/ = /* 见下文 */;
}}
{{dcl end}}

计算迭代器的关联类型。

@1@ 计算 {{tt|T}} 的{{rlp|/#类型与可写性|值类型}}。
* 如果 {{c/core|std::iterator_traits&lt;std::remove_cvref_t&lt;T&gt;&gt;}} 没有被特化，那么 {{c/core|std::iter_value_t&lt;T&gt;}} 是 {{c/core|std::indirectly_readable_traits&lt;std::remove_cvref_t&lt;T&gt;&gt;::value_type}}。
* 否则它是 {{c/core|std::iterator_traits&lt;std::remove_cvref_t&lt;T&gt;&gt;::value_type}}。

@2@ 计算 {{tt|T}} 的''引用类型''。

@3@ 计算 {{tt|T}} 的 ''const 引用类型''。

@4@ 计算 {{tt|T}} 的{{rlp|/#类型与可写性|差类型}}。
* 如果 {{c/core|std::iterator_traits&lt;std::remove_cvref_t&lt;T&gt;&gt;}} 没有被特化，那么 {{c/core|std::iter_difference_t&lt;T&gt;}} 是 {{c/core|std::incrementable_traits&lt;std::remove_cvref_t&lt;T&gt;&gt;::difference_type}}。
* 否则它是 {{c/core|std::iterator_traits&lt;std::remove_cvref_t&lt;T&gt;&gt;::difference_type}}。

@5@ 计算 {{tt|T}} 的''右值引用类型''。此别名模版的约束当且仅当表达式 {{c|ranges::iter_move(std::declval&lt;T&amp;&gt;())}} 合法且拥有可引用类型时才会得到满足。

@6@ 计算 {{tt|T}} 的''公共引用类型''。该类型是它的引用类型与到它的值类型的左值引用类型的公共引用类型。

@7@ 仅用于阐述的概念 {{tti|dereferenceable}} 当且仅当表达式 {{c|*std::declval&lt;T&amp;&gt;()}} 合法且拥有[[cpp/meta#定义|可引用类型]]时才会得到满足。
@8@ 仅用于阐述的别名模板 {{tti|indirect-value-t}}：
* 当 {{tt|T}} 等同于对于某个类型 {{tt|I}} 和 {{tt|Proj}} 的 {{c/core|std::projected&lt;I, Proj&gt;}} 时，代表 {{c/core|std::invoke_result_t&lt;Proj&amp;, /*indirect-value-t*/&lt;I&gt;&gt;}}。
* 否则，代表 {{c/core|std::iter_value_t&lt;T&gt;&amp;}}。

===缺陷报告===
{{dr list begin}}
{{dr list item|paper=P2609R3|std=C++20|before={{tt|std::iter_common_reference_t}} 是基于&lt;br&gt;{{c|std::iter_value_t&lt;T&gt;&amp;}} 定义的，但它无法正确&lt;br&gt;处理投影为右值引用类型的 {{lc|std::projected}} 类型|after=基于 {{c|/*indirect-value-t*/&lt;T&gt;}}&lt;br&gt;定义以处理这种情况}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc indirectly_readable}}
{{dsc inc|cpp/iterator/dsc weakly_incrementable}}
{{dsc inc|cpp/iterator/dsc indirectly_readable_traits}}
{{dsc inc|cpp/iterator/dsc incrementable_traits}}
{{dsc inc|cpp/iterator/dsc iterator_traits}}
{{dsc inc|cpp/ranges/dsc iterator_t}}
{{dsc inc|cpp/ranges/dsc range_size_t}}
{{dsc inc|cpp/ranges/dsc range_reference_t}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}