{{cpp/title|next}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl rev multi
|since1=c++11|dcl1=
template&lt; class InputIt &gt;
InputIt next( InputIt it, typename std::iterator_traits&lt;InputIt&gt;::difference_type n = 1 );
|since2=c++17|dcl2=
template&lt; class InputIt &gt;
constexpr
InputIt next( InputIt it, typename std::iterator_traits&lt;InputIt&gt;::difference_type n = 1 );
}}
{{dcl end}}

返回迭代器 {{c|it}} 的第 {{c|n}} 个后继（或当 {{c|n}} 是负数时为其第 {{c|n}} 个前驱）。

===参数===
{{par begin}}
{{par|it|迭代器}}
{{par|n|要前进的元素数}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par end}}

===返回值===
{{tt|InputIt}} 类型的迭代器，持有迭代器 {{c|it}} 的第 {{c|n}} 个后继（或当 {{c|n}} 是负数时为第 {{c|n}} 个前驱）。

===复杂度===
线性。

然而，如果 {{tt|InputIt}} 还满足{{named req|RandomAccessIterator}}，则复杂度为常数。

===可能的实现===
{{eq fun|1=
template&lt;class InputIt&gt;
constexpr // C++17 起
InputIt next(InputIt it, typename std::iterator_traits&lt;InputIt&gt;::difference_type n = 1)
{
    std::advance(it, n);
    return it;
}
}}

===注解===
尽管表达式 {{c|++c.begin()}} 通常能编译，然而不保证会这么做：{{c|c.begin()}} 是右值表达式，并无指定了“保证可进行右值的自增”的{{named req|InputIterator}}。尤其是当迭代器以指针实现或其 {{tt|operator++}} 带有左值引用限定时，{{c|++c.begin()}} 不能编译，而 {{c|std::next(c.begin())}} 可以。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; v{4, 5, 6};

    auto it = v.begin();
    auto nx = std::next(it, 2);
    std::cout &lt;&lt; *it &lt;&lt; ' ' &lt;&lt; *nx &lt;&lt; '\n';

    it = v.end();
    nx = std::next(it, -2);
    std::cout &lt;&lt; ' ' &lt;&lt; *nx &lt;&lt; '\n';
}
|output=
4 6
 5
}}

===缺陷报告===
{{dr list begin}}
{{dr list item |wg=lwg|dr=2353|std=C++11|before={{tt|next}} 要求{{named req|ForwardIterator}}|after=允许{{named req|InputIterator}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc prev}}
{{dsc inc|cpp/iterator/dsc advance}}
{{dsc inc|cpp/iterator/dsc distance}}
{{dsc inc|cpp/iterator/ranges/dsc next}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}