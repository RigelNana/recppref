{{cpp/title|indirectly_movable_storable}}
{{cpp/iterator/navbar}}
{{ddcl|header=iterator|since=c++20|1=
template&lt; class In, class Out &gt;
concept indirectly_movable_storable =
    std::indirectly_movable&lt;In, Out&gt; &amp;&amp;
    std::indirectly_writable&lt;Out, std::iter_value_t&lt;In&gt;&gt; &amp;&amp;
    std::movable&lt;std::iter_value_t&lt;In&gt;&gt; &amp;&amp;
    std::constructible_from&lt;std::iter_value_t&lt;In&gt;, std::iter_rvalue_reference_t&lt;In&gt;&gt; &amp;&amp;
    std::assignable_from&lt;std::iter_value_t&lt;In&gt;&amp;, std::iter_rvalue_reference_t&lt;In&gt;&gt;;
}}

{{tt|indirectly_movable_storable}} 概念指定 {{lconcept|indirectly_readable}} 与 {{lconcept|indirectly_writable}} 类型间的关系。在 {{lconcept|indirectly_movable}} 之外，此概念还指定可以通过中间对象进行从 {{tt|indirectly_readable}} 类型的移动。

===语义要求===
给定 {{tt|In}} 类型的可解引用值 {{tt|i}}，仅当满足以下条件，{{tt|In}} 与 {{tt|Out}} 实现 {{c|std::indirectly_movable_storable&lt;In, Out&gt;}}：
* 在定义 {{c|std::iter_value_t&lt;In&gt; obj(ranges::iter_move(i));}} 后，{{tt|obj}} 等于 {{c|*i}} 先前代表的值，而
* 若 {{c|std::iter_rvalue_reference_t&lt;In&gt;}} 是右值引用类型，则 {{c|*i}} 在 {{tt|obj}} 的初始化后被置于合法但未指定的状态。

{{cpp/concepts/equality preservation}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc indirectly_movable}}
{{dsc inc|cpp/iterator/dsc indirectly_copyable_storable}}
{{dsc end}}

{{langlinks|en|es|ja}}