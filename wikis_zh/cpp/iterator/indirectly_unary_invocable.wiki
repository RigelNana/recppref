{{cpp/title|indirectly_unary_invocable|indirectly_regular_unary_invocable}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl h|{{tt|std::indirectly_unary_invocable}}}}
{{dcl|since=c++20|1=
template&lt; class F, class I &gt;
    concept indirectly_unary_invocable =
        std::indirectly_readable&lt;I&gt; &amp;&amp;
        std::copy_constructible&lt;F&gt; &amp;&amp;
        std::invocable&lt;F&amp;, /*indirect-value-t*/&lt;I&gt;&gt; &amp;&amp;
        std::invocable&lt;F&amp;, std::iter_reference_t&lt;I&gt;&gt; &amp;&amp;
        std::common_reference_with&lt;
            std::invoke_result_t&lt;F&amp;, /*indirect-value-t*/&lt;I&gt;&gt;,
            std::invoke_result_t&lt;F&amp;, std::iter_reference_t&lt;I&gt;&gt;&gt;;
}}
{{dcl h|{{tt|std::indirectly_regular_unary_invocable}}}}
{{dcl|since=c++20|1=
template&lt; class F, class I &gt;
    concept indirectly_regular_unary_invocable =
        std::indirectly_readable&lt;I&gt; &amp;&amp;
        std::copy_constructible&lt;F&gt; &amp;&amp;
        std::regular_invocable&lt;F&amp;, /*indirect-value-t*/&lt;I&gt;&gt; &amp;&amp;
        std::regular_invocable&lt;F&amp;, std::iter_reference_t&lt;I&gt;&gt; &amp;&amp;
        std::common_reference_with&lt;
            std::invoke_result_t&lt;F&amp;, /*indirect-value-t*/&lt;I&gt;&gt;,
            std::invoke_result_t&lt;F&amp;, std::iter_reference_t&lt;I&gt;&gt;&gt;;
}}
{{dcl end}}

概念 {{tt|indirectly_unary_invocable}} 和 {{tt|indirectly_regular_unary_invocable}} 指定对于“调用作为各自实参的（正则）一元可调用对象的算法”的要求。这些概念与 {{lc|std::invocable}} 间的关键差异是它们应用到 {{tt|I}} 所引用的类型，而非 {{tt|I}} 自身。

===注解===
{{tt|indirectly_unary_invocable}} 与 {{tt|indirectly_regular_unary_invocable}} 间的区别是纯语义的。

===示例===
{{example|code=
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;print&gt;
#include &lt;ranges&gt;

struct IntWrapper
{
    int i;

    explicit IntWrapper(int i) : i(i) {}
    IntWrapper(IntWrapper&amp;&amp;) = default;
    IntWrapper&amp; operator=(IntWrapper&amp;&amp;) = default;
};

int main()
{
    auto ints  = std::views::iota(1, 10);
    auto print = [] (IntWrapper w) { std::print("{} ", w.i); };
    auto wrap  = [] (int i) { return IntWrapper{i}; };

    using Proj = std::projected&lt;decltype(ints.begin()), decltype(wrap)&gt;;

    // P2609R3 前为错误（求值为 false）：
    // 这是因为 'std::iter_value_t&lt;Proj&gt; &amp;' 与 'IntWrapper&amp;' 相同
    // 而它不能转换为 'IntWrapper'（隐式弃置了复制构造函数）
    static_assert(std::indirectly_unary_invocable&lt;decltype(print), Proj&gt;);

    // 如果上面的编译时检查求值为 true，那么以下是良构的：
    std::ranges::for_each(ints, print, wrap);
}

|output=
1 2 3 4 5 6 7 8 9 
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|paper=P2609R3|std=C++20|before=一些要求是基于 {{c|std::iter_value_t&lt;I&gt;&amp;}} 定义的&lt;br&gt;但它未能正确处理一些投影而导致与可调用的 {{c|F&amp;}} 不兼容|after=基于 {{c|/*indirect-value-t*/&lt;I&gt;}} 定义以正确处理这些投影}}
{{dr list item|paper=P2997R1|std=C++20|before=对应的概念分别要求 {{c|F&amp;}} 满足 {{lconcept|invocable}} 和&lt;br&gt;{{lconcept|regular_invocable}} 以及 {{c|std::iter_common_reference_t&lt;I&gt;}}|after=不作此要求}}
{{dr list end}}

{{langlinks|en|es|ja}}