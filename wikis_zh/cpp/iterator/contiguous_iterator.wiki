{{cpp/title|contiguous_iterator}}
{{cpp/iterator/navbar}}
{{ddcl|header=iterator|since=c++20|1=
template&lt; class I &gt;
    concept contiguous_iterator =
        std::random_access_iterator&lt;I&gt; &amp;&amp;
        std::derived_from&lt;/*ITER_CONCEPT*/&lt;I&gt;, std::contiguous_iterator_tag&gt; &amp;&amp;
        std::is_lvalue_reference_v&lt;std::iter_reference_t&lt;I&gt;&gt; &amp;&amp;
        std::same_as&lt;std::iter_value_t&lt;I&gt;,
                     std::remove_cvref_t&lt;std::iter_reference_t&lt;I&gt;&gt;&gt; &amp;&amp;
        requires(const I&amp; i) {
            { std::to_address(i) } -&gt;
              std::same_as&lt;std::add_pointer_t&lt;std::iter_reference_t&lt;I&gt;&gt;&gt;;
        };
}}

{{tt|contiguous_iterator}} 概念精化了 {{lconcept|random_access_iterator}}，提供它代表的元素在内存中连续存储的保证。

{{rrev|since=c++26|
给定具有某个实现了 {{tt|contiguous_iterator}} 的类型的迭代器 {{c|i}}，哨位 {{c|s}} 和非负整数 {{c|n}}：
* 对于任何{{rlps|/#范围}} {{range|i|s}}，标准库函数都能将它替换成 {{range|std::to_address(i)|std::to_address(i + ranges::distance(i, s))}}。
* 对于任何范围 {{counted range|i|n}}，标准库函数都能将它替换成 {{counted range|std::to_address(i)|std::to_address(i + n)}}。

这意味着程序不能依赖任何解引用或增减连续迭代器 {{c|i}} 的副作用，因为标准库函数可能会操作通过 {{c|std::to_address(i)}} 获取到的指针，而不是直接操作 {{c|i}}。
}}

{{cpp/iterator/iter concept}}

===语义要求===
设 {{c|a}} 和 {{c|b}} 为 {{tt|I}} 类型的{{rlp|/#可解性与有效性|可解引用}}迭代器，{{c|c}} 为 {{tt|I}} 类型的不可解引用迭代器，使得 {{c|b}} 从 {{c|a}} {{rlp|/#范围|可及}}且 {{c|c}} 从 {{c|b}} 可及。类型 {{tt|I}} 只有在实现了 {{tt|contiguous_iterator}} 所蕴含的所有概念并满足以下所有条件时才会实现 {{tt|contiguous_iterator}}：
* {{c|1=std::to_address(a) == std::addressof(*a)}}。
* {{c|1=std::to_address(b) == std::to_address(a) + std::iter_difference_t&lt;I&gt;(b - a)}}。
* {{c|1=std::to_address(c) == std::to_address(a) + std::iter_difference_t&lt;I&gt;(c - a)}}。
* {{c|std::to_address(I{})}} 具有良好定义。
* {{c|ranges::iter_move(a)}} 与 {{c|std::move(*a)}} 具有相同的类型、值类别和效果。
* 如果 {{c|ranges::iter_swap(a, b)}} 良构，那么它的效果等价于 {{c|ranges::swap(*a, *b)}}。

{{cpp/concepts/equality preservation}}
{{cpp/concepts/implicit expression variations}}

===注解===
每个指向完整对象类型的指针类型都实现了 {{tt|contiguous_iterator}}。

在 C++17 中需要满足{{named req|ContiguousIterator}}的要求的标准库迭代器类型在 C++20 中同样需要实现 {{tt|contiguous_iterator}}。

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3607|std=C++20|before={{tt|contiguous_iterator}} 可以有自定义的 {{lc|ranges::iter_move}} 和 {{lc|ranges::iter_swap}} 行为|after=已禁止}}
{{dr list item|wg=lwg|dr=4170|std=C++20|before=一对值初始化的 {{tt|contiguous_iterator}} 不一定可以表示空范围|after=保证可以}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc random_access_iterator}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}