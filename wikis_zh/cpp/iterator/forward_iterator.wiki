{{cpp/title|forward_iterator}}
{{cpp/iterator/navbar}}
{{ddcl|header=iterator|since=c++20|1=
template&lt; class I &gt;
    concept forward_iterator =
        std::input_iterator&lt;I&gt; &amp;&amp;
        std::derived_from&lt;/*ITER_CONCEPT*/&lt;I&gt;, std::forward_iterator_tag&gt; &amp;&amp;
        std::incrementable&lt;I&gt; &amp;&amp;
        std::sentinel_for&lt;I, I&gt;;
}}

此概念精化 {{lc|std::input_iterator}}，它要求 {{tt|I}} 亦实现 {{tt|std::incrementable}}（从而使之适合多趟算法），并保证指向同一范围的两个迭代器可相互比较。

{{cpp/iterator/iter_concept}}

===语义要求===
当且仅当 {{tt|I}} 实现 {{tt|std::forward_iterator}} 所纳入的所有概念，并且给定 {{tt|I}} 类型的对象 {{c|i}} 与 {{c|j}}，满足以下条件时，{{tt|I}} 实现此概念：

* 若符合下列条件，则迭代器 {{c|i}} 与 {{c|j}} 间的比较拥有定义的结果：
:* {{c|i}} 与 {{c|j}} 为指向同一底层序列的迭代器，或
:* {{c|i}} 与 {{c|j}} 均被值初始化，该情况下它们比较相等。
* 从指向范围中的向前迭代器获得的指针与引用在该范围存在时保持合法。
* 若 {{c|i}} 与 {{c|j}} 可解引用，则它们提供''多趟保证''，即：
:* {{c|1=i == j}} 蕴含 {{c|1=++i == ++j}}，且
:* {{c|((void)[](auto x){ ++x; }(i), *i)}} 等价于 {{c|*i}}。

===注解===
不同于{{named req|ForwardIterator}}要求，{{tt|forward_iterator}} 概念不要求其解引用返回左值。

===示例===
最小化的向前迭代器。

{{source|1=
#include &lt;cstddef&gt;
#include &lt;iterator&gt;

struct SimpleForwardIterator
{
    using difference_type = std::ptrdiff_t;
    using value_type = int;

    int operator*() const;

    SimpleForwardIterator&amp; operator++();

    SimpleForwardIterator operator++(int)
    {
        auto tmp = *this;
        ++*this;
        return tmp;
    }

    bool operator==(const SimpleForwardIterator&amp;) const;
};

static_assert(std::forward_iterator&lt;SimpleForwardIterator&gt;);
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc input_iterator}}
{{dsc inc|cpp/iterator/dsc bidirectional_iterator}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}