{{cpp/title|prev}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl rev multi
|since1=c++11|dcl1=
template&lt; class BidirIt &gt;
BidirIt prev( BidirIt it, typename std::iterator_traits&lt;BidirIt&gt;::difference_type n = 1 );
|since2=c++17|dcl2=
template&lt; class BidirIt &gt;
constexpr
BidirIt prev( BidirIt it, typename std::iterator_traits&lt;BidirIt&gt;::difference_type n = 1 );
}}
{{dcl end}}

返回迭代器 {{c|it}} 的第 {{c|n}} 个前驱（或当 {{c|n}} 是负数时为第 {{c|n}} 个后继）。

===参数===
{{par begin}}
{{par|it|迭代器}}
{{par|n|{{c|it}} 要被减少的元素个数}}
{{par hreq}}
{{par req named|BidirIt|BidirectionalIterator}}
{{par end}}

===返回值===
{{tt|BidirIt}} 类型的迭代器，持有迭代器 {{c|it}} 的第 {{c|n}} 个前驱（或当 {{c|n}} 是负数时为第 {{c|n}} 个后继）。

===复杂度===
线性。

然而，若 {{tt|BidirIt}} 还满足{{named req|RandomAccessIterator}}，则复杂度为常数。

===可能的实现===
{{eq fun|1=
template&lt;class BidirIt&gt;
constexpr // since C++17
BidirIt prev(BidirIt it, typename std::iterator_traits&lt;BidirIt&gt;::difference_type n = 1)
{
    std::advance(it, -n);
    return it;
}
}}

===注解===
尽管表达式 {{c|--c.end()}} 通常能编译，然而不保证会这么做：{{c|c.end()}} 是右值表达式，并无指定了“保证可进行右值的自减”的迭代器要求。尤其是当迭代器实现为指针或其 {{tt|operator--}} 带有左值引用限定时，{{c|--c.end()}} 不能编译，而 {{c|std::prev(c.end())}} 可以。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; v{3, 1, 4};

    auto it = v.end();
    auto pv = std::prev(it, 2);
    std::cout &lt;&lt; *pv &lt;&lt; '\n';

    it = v.begin();
    pv = std::prev(it, -2);
    std::cout &lt;&lt; *pv &lt;&lt; '\n';
}
|output=
1
4
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc next}}
{{dsc inc|cpp/iterator/dsc advance}}
{{dsc inc|cpp/iterator/dsc distance}}
{{dsc inc|cpp/iterator/ranges/dsc prev}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}