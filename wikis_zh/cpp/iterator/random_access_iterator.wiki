{{cpp/title|random_access_iterator}}
{{cpp/iterator/navbar}}
{{ddcl|header=iterator|since=c++20|1=
template&lt; class I &gt;
    concept random_access_iterator =
        std::bidirectional_iterator&lt;I&gt; &amp;&amp;
        std::derived_from&lt;/*ITER_CONCEPT*/&lt;I&gt;, std::random_access_iterator_tag&gt; &amp;&amp;
        std::totally_ordered&lt;I&gt; &amp;&amp;
        std::sized_sentinel_for&lt;I, I&gt; &amp;&amp;
        requires(I i, const I j, const std::iter_difference_t&lt;I&gt; n) {
            { i += n } -&gt; std::same_as&lt;I&amp;&gt;;
            { j +  n } -&gt; std::same_as&lt;I&gt;;
            { n +  j } -&gt; std::same_as&lt;I&gt;;
            { i -= n } -&gt; std::same_as&lt;I&amp;&gt;;
            { j -  n } -&gt; std::same_as&lt;I&gt;;
            {  j[n]  } -&gt; std::same_as&lt;std::iter_reference_t&lt;I&gt;&gt;;
        };
}}

概念 {{tt|random_access_iterator}} 精化 {{lconcept|bidirectional_iterator}}，添加了用 {{ttb|1=+=}}、{{ttb|1=-=}}、{{ttb|+}} 和 {{ttb|-}} 运算符进行常数时间的前进，用 {{ttb|-}} 进行常数时间的距离计算，及带下标 {{ttb|[]}} 的数组记法支持。

{{cpp/iterator/iter concept}}

===语义要求===
令 {{c|a}} 与 {{c|b}} 为 {{tt|I}} 类型的合法迭代器，使得从 {{c|a}} 可及 {{c|b}}，并令 {{c|n}} 为等于 {{c|b - a}} 的 {{c|std::iter_difference_t&lt;I&gt;}} 类型的值。{{co|random_access_iterator&lt;I&gt;}} 仅若其所蕴含的概念均被实现并且符合下列条件才得到实现：

* {{c|1=(a += n)}} 等于 {{c|b}}。
* {{c|1=std::addressof(a += n)}} 等于 {{c|std::addressof(a)}}。[[#addressof 注解|{{sup|[1]}}]]
* {{c|(a + n)}} 等于 {{c|1=(a += n)}}。
* {{c|(a + n)}} 等于 {{c|(n + a)}}。
* 对于任何两个正整数 {{tt|x}} 与 {{tt|y}}，若 {{c|a + (x + y)}} 合法，则 {{c|a + (x + y)}} 等于 {{c|(a + x) + y}}。
* {{c|a + 0}} 等于 {{c|a}}。
* 若 {{c|(a + (n - 1))}} 合法，则 {{c|--b}} 等于 {{c|(a + (n - 1))}}。
* {{c|1=(b += -n)}} 与 {{c|1=(b -= n)}} 都等于 {{c|a}}。
* {{c|1=std::addressof(b -= n)}} 等于 {{c|std::addressof(b)}}。[[#addressof 注解|{{sup|[1]}}]]
* {{c|(b - n)}} 等于 {{c|1=(b -= n)}}。
* 若 {{c|b}} 可解引用，则 {{c|a[n]}} 合法并等于 {{c|*b}}。
* {{c|1=bool(a &lt;= b)}} 为 {{c|true}}。
* 每个要求的操作均拥有常数时间复杂度。
{{anchor|addressof 注解}}
{{petty|注意，{{lc|std::addressof}} 返回迭代器对象的地址，而非迭代器所指向对象的地址。即 {{tt|1=operator+=}} 和 {{tt|1=operator-=}} 必须返回到 {{c|*this}} 的引用。}}

{{cpp/concepts/equality preservation}}
{{cpp/concepts/implicit expression variations}}

===注解===
不同于{{named req|RandomAccessIterator}} 要求，{{tt|random_access_iterator}} 概念不要求解引用返回左值。

===示例===
{{example
|演示一种 {{lc|std::distance}} 的通过 C++20 概念的可能实现。
|code=
#include &lt;iterator&gt;

namespace cxx20
{
    template&lt;std::input_or_output_iterator Iter&gt;
    constexpr std::iter_difference_t&lt;Iter&gt; distance(Iter first, Iter last)
    {
        if constexpr(std::random_access_iterator&lt;Iter&gt;)
            return last - first;
        else
        {
            std::iter_difference_t&lt;Iter&gt; result{};
            for (; first != last; ++first)
                ++result;
            return result;
        }
    }
}

int main()
{
    static constexpr auto il = {3, 1, 4};

    static_assert(std::random_access_iterator&lt;decltype(il.begin())&gt; &amp;&amp;
                  cxx20::distance(il.begin(), il.end()) == 3 &amp;&amp;
                  cxx20::distance(il.end(), il.begin()) == -3);
}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc bidirectional_iterator}}
{{dsc inc|cpp/iterator/dsc contiguous_iterator}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}