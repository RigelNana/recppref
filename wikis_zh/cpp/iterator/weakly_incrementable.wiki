{{cpp/title|weakly_incrementable}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator|since=c++20}}
{{dcl|since=c++20|1=
template&lt; class I &gt;
    concept weakly_incrementable =
        std::movable&lt;I&gt; &amp;&amp;
        requires(I i) {
            typename std::iter_difference_t&lt;I&gt;;
            requires /*is-signed-integer-like*/&lt;std::iter_difference_t&lt;I&gt;&gt;;
            { ++i } -&gt; std::same_as&lt;I&amp;&gt;; // 不要求保持相等性
            i++;                         // 不要求保持相等性
        };
}}
{{dcl end}}

{{c/core|/*is-signed-integer-like*/}} 的定义见 {{rlpi|is-integer-like}}。

此概念指定“能以前后自增运算符自增的类型”上的要求，不过这些自增运算不要求保持相等性，而且不要求类型自身为 {{lc|std::equality_comparable}}。

对于 {{tt|std::weakly_incrementable}} 类型，{{c|1=a == b}} 不蕴含 {{c|1=++a == ++b}}。弱可自增类型上的算法必须是单趟算法。这些算法能通过 {{lc|std::istream_iterator}} 用于作为输入数据源的 {{tt|istream}}。

===语义要求===
对于 {{tt|I}} 类型的对象 {{c|i}}，只有在满足以下所有条件时 {{tt|I}} 才会实现 {{tt|std::weakly_incrementable}}：
* 表达式 {{c|++i}} 与 {{c|i++}} 拥有相同定义域。
* 如果 {{c|i}} 可自增，那么 {{c|++i}} 与 {{c|i++}} 都会增加 {{c|i}}。
* 如果 {{c|i}} 可自增，那么 {{c|1=std::addressof(++i) == std::addressof(i)}}。

===缺陷报告===
{{dr list begin}}
{{dr list item|paper=P2325R3|std=C++20|before=要求 {{lconcept|default_initializable}}|after=不要求}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc incrementable}}
{{dsc end}}

{{langlinks|de|en|es|ja|ru}}