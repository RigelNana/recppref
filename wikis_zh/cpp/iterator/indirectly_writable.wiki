{{cpp/title|indirectly_writable}}
{{cpp/iterator/navbar}}
{{ddcl|header=iterator|since=c++20|1=
template&lt; class Out, class T &gt;
    concept indirectly_writable =
        requires(Out&amp;&amp; o, T&amp;&amp; t) {
            *o = std::forward&lt;T&gt;(t);
            *std::forward&lt;Out&gt;(o) = std::forward&lt;T&gt;(t);
            const_cast&lt;const std::iter_reference_t&lt;Out&gt;&amp;&amp;&gt;(*o) = std::forward&lt;T&gt;(t);
            const_cast&lt;const std::iter_reference_t&lt;Out&gt;&amp;&amp;&gt;(*std::forward&lt;Out&gt;(o)) =
                std::forward&lt;T&gt;(t);
        };
        // 上述四个表达式都不要求保持相等性
}}

概念 {{tt|indirectly_writable&lt;Out, T&gt;}} 指定对于“将 {{tt|T}} 编码其类型和值类别的值写入到迭代器 {{tt|Out}} 所引用对象”的要求。

===语义要求===
令 {{tt|e}} 为满足 {{c|decltype((e))}} 为 {{tt|T}} 的表达式，而 {{tt|o}} 为 {{tt|Out}} 类型的可解引用对象，则 {{tt|indirectly_writable&lt;Out, T&gt;}} 仅若符合下列条件才被实现：
* 若 {{c|std::indirectly_readable&lt;Out&gt;}} 得到实现且 {{c|std::iter_value_t&lt;Out&gt;}} 与 {{c|std::decay_t&lt;T&gt;}} 为同一类型，则在任何上述赋值后 {{c|*o}} 等于 {{tt|e}} 在赋值前的值。

不要求 {{tt|o}} 在求值任何上述赋值表达式后可解引用。若 {{tt|e}} 为亡值，则其代表的对象的结果状态合法但未指定。

{{cpp/concepts/equality preservation|skip-requires=yes}}

===注解===
{{c|operator*}} 仅有的合法用法是在赋值表达式左侧。通过间接可写类型的相同值进行的赋值只可以发生一次。

带 {{tt|const_cast}} 的要求表达式防止了具有纯右值 {{tt|reference}} 类型的 {{lconcept|indirectly_readable}} 对象意外满足 {{tt|indirectly_writable}} 的语法要求，同时容许代理引用继续工作，只要其常性是浅的。见[https://github.com/ericniebler/stl2/issues/381 范围 TS 问题 381]。

{{langlinks|en|es|ja}}