{{cpp/ranges/title|iter_move}}
{{cpp/iterator/navbar}}

{{dcl begin}}
{{dcl header|iterator}}
{{dcl|notes={{mark custpt}}|since=c++20|1=
inline namespace /* 未指定 */ {
    inline constexpr /* 未指定 */ iter_move = /* 未指定 */;
}
}}
{{dcl h|调用签名}}
{{dcl|since=c++20|1=
template&lt; class T &gt;
    requires /* 见下文 */
constexpr decltype(auto) iter_move( T&amp;&amp; t ) noexcept(/* 见下文 */);
}}
{{dcl end}}

从给定的迭代器获得右值引用或纯右值临时对象。

{{c|ranges::iter_move(t)}} [[cpp/language/expressions#表达式等价|表达式等价]]于：
# {{c|iter_move(t)}}，如果 {{c|t}} 具有类或枚举类型且该表达式作为[[cpp/language/expressions#潜在求值表达式|不求值操作数]]良构，其中只会以[[cpp/language/adl|实参依赖查找]]所找到的候选进行 {{tt|iter_move}} 的[[cpp/language/overload resolution|重载决议]]。
# 否则，如果 {{c|*t}} 良构且它是左值，则为 {{c|std::move(*t)}}。
# 否则，如果 {{c|*t}} 良构且它是右值，则为 {{c|*t}}。

所有其他情况下，对 {{tt|ranges::iter_move}} 的调用非良构，这能在 {{c|ranges::iter_move(e)}} 出现于模板实例化的立即语境时导致[[cpp/language/sfinae|替换失败]]。

如果 {{c|ranges::iter_move(e)}} 不等于 {{c|*e}}，那么程序非良构，不要求诊断。

{{cpp/ranges/cpo}}

===示例===
{{example}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/iterator/adaptor/dsc iter_move|reverse_iterator}}
{{dsc inc|cpp/iterator/adaptor/dsc iter_move|move_iterator}}
{{dsc end}}

{{langlinks|en|es|ja}}