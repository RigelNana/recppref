{{cpp/ranges/title| distance}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl h|调用签名}}
{{dcl|num=1|since=c++20|
template&lt; class I, std::sentinel_for&lt;I&gt; S &gt;
    requires (!std::sized_sentinel_for&lt;S, I&gt;)
constexpr std::iter_difference_t&lt;I&gt;
    distance( I first, S last );
}}
{{dcl|num=2|since=c++20|
template&lt; class I, std::sized_sentinel_for&lt;std::decay_t&lt;I&gt;&gt; S &gt;
constexpr std::iter_difference_t&lt;std::decay_t&lt;I&gt;&gt;
    distance( I&amp;&amp; first, S last );
}}
{{dcl|num=3|since=c++20|
template&lt; ranges::range R &gt;
constexpr ranges::range_difference_t&lt;R&gt;
    distance( R&amp;&amp; r );
}}
{{dcl end}}

@1,2@ 返回从 {{c|first}} 到 {{c|last}} 的自增次数。
@3@ 以有符号整数返回 {{c|r}} 的大小。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par|first|指向首元素的迭代器}}
{{par|last|哨位，代表 {{c|first}} 作为迭代器所指向的范围的结尾}}
{{par|r|要计算距离的范围}}
{{par end}}

===返回值===
@1@ 需要从 {{c|first}} 到 {{c|last}} 的自增次数。
@2@ {{c|last - static_cast&lt;const std::decay_t&lt;I&gt;&amp;&gt;(first)}}。
@3@ 若 {{tt|R}} 实现 {{l2tt|cpp/ranges/sized_range}} 则返回 {{c|ranges::size(r)}}，否则返回 {{c|ranges::distance(ranges::begin(r), ranges::end(r))}}。

===复杂度===
@1@ 线性。
@2@ 常数。
@3@ 在 {{tt|R}} 实现 {{l2tt|cpp/ranges/sized_range}} 时，或者在 {{c|std::sized_sentinel_for&lt;ranges::sentinel_t&lt;R&gt;, ranges::iterator_t&lt;R&gt;&gt;}} 得到实现时是常数，否则是线性。

===可能的实现===
{{eq fun|1=
struct distance_fn
{
    template&lt;class I, std::sentinel_for&lt;I&gt; S&gt;
        requires (!std::sized_sentinel_for&lt;S, I&gt;)
    constexpr std::iter_difference_t&lt;I&gt; operator()(I first, S last) const
    {
        std::iter_difference_t&lt;I&gt; result = 0;
        while (first != last)
        {
            ++first;
            ++result;
        }
        return result;
    }
    
    template&lt;class I, std::sized_sentinel_for&lt;std::decay&lt;I&gt;&gt; S&gt;
    constexpr std::iter_difference_t&lt;I&gt; operator()(const I&amp; first, S last) const
    {
        return last - first;
    }
    
    template&lt;ranges::range R&gt;
    constexpr ranges::range_difference_t&lt;R&gt; operator()(R&amp;&amp; r) const
    {
        if constexpr (ranges::sized_range&lt;std::remove_cvref_t&lt;R&gt;&gt;)
            return static_cast&lt;ranges::range_difference_t&lt;R&gt;&gt;(ranges::size(r));
        else
            return (*this)(ranges::begin(r), ranges::end(r));
    }
};

inline constexpr auto distance = distance_fn{};
}}

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;forward_list&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

int main() 
{
    std::vector&lt;int&gt; v{3, 1, 4};
    assert(std::ranges::distance(v.begin(), v.end()) == 3);
    assert(std::ranges::distance(v.end(), v.begin()) == -3);
    assert(std::ranges::distance(v) == 3);

    std::forward_list&lt;int&gt; l{2, 7, 1};
    // auto size = std::ranges::size(l); // 错误：不是有大小的范围
    auto size = std::ranges::distance(l); // OK，但要当心其复杂度为 O(N)
    assert(size == 3);
}
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3392|std=C++20|before=重载 {{v|1}} 按值接收迭代器，从而拒绝拥有具大小哨位的仅移动迭代器左值|after=添加重载 {{v|2}}}}
{{dr list item|wg=lwg|dr=3664|std=C++20|before={{lwg|3392}} 的解决方案导致 {{tt|ranges::distance}} 拒绝数组实参|after=接受数组实参}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/iterator/ranges/dsc advance}}
{{dsc inc|cpp/algorithm/ranges/dsc count}}
{{dsc inc|cpp/iterator/dsc distance}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}