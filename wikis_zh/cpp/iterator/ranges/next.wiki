{{cpp/ranges/title| next}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl h|调用签名}}
{{dcl|num=1|since=c++20|1=
template&lt; std::input_or_output_iterator I &gt;
constexpr I next( I i );
}}
{{dcl|num=2|since=c++20|1=
template&lt; std::input_or_output_iterator I &gt;
constexpr I next( I i, std::iter_difference_t&lt;I&gt; n );
}}
{{dcl|num=3|since=c++20|1=
template&lt; std::input_or_output_iterator I, std::sentinel_for&lt;I&gt; S &gt;
constexpr I next( I i, S bound );
}}
{{dcl|num=4|since=c++20|1=
template&lt; std::input_or_output_iterator I, std::sentinel_for&lt;I&gt; S &gt;
constexpr I next( I i, std::iter_difference_t&lt;I&gt; n, S bound );
}}
{{dcl end}}

返回迭代器 {{c|i}} 的第 {{c|n}} 个后继。

{{cpp/ranges/niebloid}}

===参数===
{{par begin}}
{{par|i|迭代器}}
{{par|n|要自增的次数}}
{{par|bound|哨位，代表 {{c|i}} 所指向的范围的结尾}}
{{par end}}

===返回值===
@1@ 迭代器 {{c|i}} 的后继
@2@ 迭代器 {{c|i}} 的第 {{c|n}} 个后继
@3@ 首个等于 {{c|bound}} 的迭代器 
@4@ 迭代器 {{c|i}} 的第 {{c|n}} 个后继，或首个等于 {{c|bound}} 的迭代器，取决于何者先达成。

===复杂度===
@1@ 常数。
@2@ 若 {{tt|I}} 实现 {{lc|std::random_access_iterator}} 则为常数；否则为线性。
@3@ 若 {{tt|I}} 与 {{tt|S}} 实现 {{c|std::random_access_iterator&lt;I&gt;}} 和 {{c|std::sized_sentinel_for&lt;S, I&gt;}}，或 {{tt|I}} 与 {{tt|S}} 实现 {{c|std::assignable_from&lt;I&amp;, S&gt;}} 则为常数；否则为线性。
@4@ 若 {{tt|I}} 与 {{tt|S}} 实现 {{c|std::random_access_iterator&lt;I&gt;}} 和 {{c|std::sized_sentinel_for&lt;S, I&gt;}} 则为常数；否则为线性。

===可能的实现===
{{eq fun|1=
struct next_fn
{
    template&lt;std::input_or_output_iterator I&gt;
    constexpr I operator()(I i) const
    {
        ++i;
        return i;
    }

    template&lt;std::input_or_output_iterator I&gt;
    constexpr I operator()(I i, std::iter_difference_t&lt;I&gt; n) const
    {
        ranges::advance(i, n);
        return i;
    }

    template&lt;std::input_or_output_iterator I, std::sentinel_for&lt;I&gt; S&gt;
    constexpr I operator()(I i, S bound) const
    {
        ranges::advance(i, bound);
        return i;
    }

    template&lt;std::input_or_output_iterator I, std::sentinel_for&lt;I&gt; S&gt;
    constexpr I operator()(I i, std::iter_difference_t&lt;I&gt; n, S bound) const
    {
        ranges::advance(i, n, bound);
        return i;
    }
};

inline constexpr auto next = next_fn();
}}

===注解===
尽管表达式 {{c|++x.begin()}} 经常能编译，但不保证如此：{{c|x.begin()}} 是右值表达式，而没有“指定右值的自增保证能工作”的要求。尤其是迭代器实现为指针或其 {{tt|operator++}} 带有左值引用限定时，{{c|++x.begin()}} 不能编译，而 {{c|ranges::next(x.begin())}} 能。

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iterator&gt;

int main() 
{
    auto v = {3, 1, 4};
    {
        auto n = std::ranges::next(v.begin());
        assert(*n == 1);
    }
    {
        auto n = std::ranges::next(v.begin(), 2);
        assert(*n == 4);
    }
    {
        auto n = std::ranges::next(v.begin(), v.end());
        assert(n == v.end());
    }
    {
        auto n = std::ranges::next(v.begin(), 42, v.end());
        assert(n == v.end());
    }
}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/iterator/ranges/dsc prev}}
{{dsc inc|cpp/iterator/ranges/dsc advance}}
{{dsc inc|cpp/iterator/dsc next}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}