{{cpp/regex/regex_traits/title|isctype}}
{{cpp/regex/regex_traits/navbar}}
{{ddcl|
bool isctype( CharT c, char_class_type f ) const;
}}

确定字符 {{c|c}} 是否属于 {{c|f}} 所标识的字符类，即 {{lc|lookup_classname()}} 所返回的值或几个这种值的逐位或的结果。

{{lc|std::regex_traits}} 的标准库特化中提供的此函数版本进行下列操作：

@1@ 首先将 {{c|f}} 转换成 {{lc|std::ctype_base::mask}} 类型的值 {{c|m}}。
@@ 对于 {{lc|lookup_classname()}} 页面中表格列出的每个 {{lc|std::ctype}} 分类，如果 {{c|f}} 中设置了该分类对应的位，那么 {{c|m}} 也会设置对应位。

@2@ 然后尝试通过调用 {{c|std::use_facet&lt;std::ctype&lt;CharT&gt;&gt;(getloc()).is(m, c)}} 在浸染的本地环境中分类字符。
* 如果调用返回 {{c|true}}，那么 {{tt|isctype()}} 也返回 {{c|true}}。
* 否则，如果 {{c|c}} 等于 {{c|'_'}}，并且 {{c|f}} 包含对字符类 {{tt|[:w:]}} 调用 {{lc|lookup_classname()}} 的结果，那么就会返回 {{c|true}}，否则返回 {{c|false}}。

===参数===
{{par begin}}
{{par|c|要分类的字符}}
{{par|f|从一或多次调用 {{lc|lookup_classname()}} 获得的位掩码}}
{{par end}}

===返回值===
如果 {{c|c}} 以 {{c|f}} 分类就会返回 {{c|true}}，否则返回 {{c|false}}。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;regex&gt;

int main()
{
    std::regex_traits&lt;char&gt; t;
    std::string str_alnum = "alnum";
    auto a = t.lookup_classname(str_alnum.begin(), str_alnum.end());
    std::string str_w = "w"; // [:w:] 是 [:alnum:] 加上 '_'
    auto w = t.lookup_classname(str_w.begin(), str_w.end());
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; t.isctype('A', w) &lt;&lt; ' ' &lt;&lt; t.isctype('A', a) &lt;&lt; '\n'
              &lt;&lt; t.isctype('_', w) &lt;&lt; ' ' &lt;&lt; t.isctype('_', a) &lt;&lt; '\n'
              &lt;&lt; t.isctype(' ', w) &lt;&lt; ' ' &lt;&lt; t.isctype(' ', a) &lt;&lt; '\n';
}
|output=
true true
true false
false false
}}

{{cpp/regex/isctype example}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2018|std=C++11|before=未指定 {{c|m}} 的值|after=与 {{lc|lookup_classname()}} 的最低限度支持相匹配}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/regex/regex_traits/dsc lookup_classname}}
{{dsc inc|cpp/locale/ctype/dsc do_is}}
{{dsc inc|cpp/string/wide/dsc iswctype}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}