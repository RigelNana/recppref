{{cpp/regex/basic_regex/title|basic_regex}}
{{cpp/regex/basic_regex/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++11|1=
basic_regex();
}}
{{dcl|num=2|since=c++11|1=
explicit basic_regex( const CharT* s,
                      flag_type f = std::regex_constants::ECMAScript );
}}
{{dcl|num=3|since=c++11|1=
basic_regex( const CharT* s, std::size_t count,
             flag_type f = std::regex_constants::ECMAScript );
}}
{{dcl|num=4|since=c++11|1=
basic_regex( const basic_regex&amp; other );
}}
{{dcl|num=5|since=c++11|1=
basic_regex( basic_regex&amp;&amp; other ) noexcept;
}}
{{dcl|num=6|since=c++11|1=
template&lt; class ST, class SA &gt;
explicit basic_regex( const std::basic_string&lt;CharT,ST,SA&gt;&amp; str,
                      flag_type f = std::regex_constants::ECMAScript );
}}
{{dcl|num=7|since=c++11|1=
template&lt; class ForwardIt &gt;
basic_regex( ForwardIt first, ForwardIt last,
             flag_type f = std::regex_constants::ECMAScript );
}}
{{dcl|num=8|since=c++11|1=
basic_regex( std::initializer_list&lt;CharT&gt; init,
             flag_type f = std::regex_constants::ECMAScript );
}}
{{dcl end}}

从按照标志 {{c|f}} 进行解释的字符序列构造新的正则表达式。

@1@ 默认构造函数。构造不匹配任何内容的空正则表达式。

@2@ 从空终止字符串 {{c|s}} 构造正则表达式。

@3@ 从 {{c|s}} 所指向的 {{c|count}} 个的字符序列构造正则表达式。

@4@ 复制构造函数。通过复制 {{c|other}} 构造正则表达式。

@5@ 移动构造函数。用移动语义构造拥有 {{c|other}} 内容的正则表达式。

@6@ 从字符串 {{c|str}} 构造正则表达式。

@7@ 范围构造函数。构造拥有范围 {{range|first|last}} 内容的正则表达式。

@8@ 初始化式列表构造函数。构造拥有初始化式列表 {{c|init}} 内容的正则表达式。

===参数===
{{par begin}}
{{par|s|指向空终止字符串的指针}}
{{par|count|用于初始化正则表达式的字符序列长度}}
{{par|first, last|用于初始化正则表达式的字符序列范围}}
{{par|str|用作源初始化正则表达式的 {{tt|basic_string}}}}
{{par|other|用作源初始化正则表达式的另一正则表达式}}
{{par|init|用于初始化正则表达式的初始化式列表}}
{{par|f|用于指引转译字符序列为正则表达式的标志}}
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par end}}

===异常===
@1@ {{cpp/impldef exception item}}

@2,3@ 若提供的正则表达式非法则为 {{lc|std::regex_error}}。

@4@ {{cpp/impldef exception item}}

@6-8@ 若提供的正则表达式非法则为 {{lc|std::regex_error}}。

===示例===
{{example
|code=
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

void match_and_print(const std::string&amp; text, const std::regex&amp; pattern)
{
    std::sregex_iterator it(text.begin(), text.end(), pattern), it_end;
    int count = 0;
    for (; it != it_end; ++it)
    {
        const std::smatch&amp; match = *it;
        std::cout &lt;&lt; ++count &lt;&lt; ". " &lt;&lt; std::quoted(match.str()) &lt;&lt; '\n';
    }
    std::cout &lt;&lt; (count ? "\n" : "未找到匹配\n\n");
}

int main()
{
    const std::string text = "Hello, World! 12345";

    // 匹配一个或更多数字
    std::string pattern_text = "\\d+";
    std::cout &lt;&lt; "数字 (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    auto pattern = std::regex(pattern_text);
    match_and_print(text, pattern);

    // 匹配按空白分隔的一个或更多字符
    pattern_text = "[^\\s]+";
    std::cout &lt;&lt; "单词 (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    pattern = std::regex(pattern_text);
    match_and_print(text, pattern);

    // 匹配按空白分隔的一个或更多字符
    pattern_text = "[a-zA-Z]+";
    std::cout &lt;&lt; "不带符号和数字的单词 (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    pattern = std::regex(pattern_text);
    match_and_print(text, pattern);

    // 匹配一个非数字、非字母字符
    pattern_text = "[^0-9A-Za-z]";
    std::cout &lt;&lt; "符号 (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    pattern = std::regex(pattern_text);
    match_and_print(text, pattern);

    // 匹配一个或多个小写字母
    pattern_text = "[a-z]+";
    std::cout &lt;&lt; "小写 (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    pattern = std::regex(pattern_text);
    match_and_print(text, pattern);

    // 匹配一个或多个小写字母，带有 std::regex::icase 标志
    pattern_text = "[a-z]+";
    std::cout &lt;&lt; "小写并带有忽略大小写标志 (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    pattern = std::regex(pattern_text, std::regex::icase);
    match_and_print(text, pattern);

    // 匹配基本 POSIX 正则表达式 
    pattern_text = "[[:digit:]]+";
    std::cout &lt;&lt; "基本 POSIX 正则表达式 (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    pattern = std::regex(pattern_text, std::regex::basic);
    match_and_print(text, pattern);

    // 匹配扩展 POSIX 正则表达式
    pattern_text = "[[:digit:]]+";
    std::cout &lt;&lt; "扩展 POSIX 正则表达式 (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    pattern = std::regex(pattern_text, std::regex::extended);
    match_and_print(text, pattern);
}
|output=
数字 (\d+):
1. "12345"

单词 ([^\s]+):
1. "Hello,"
2. "World!"
3. "12345"

不带符号和数字的单词 ([a-zA-Z]+):
1. "Hello"
2. "World"

符号 ([^0-9A-Za-z]):
1. ","
2. " "
3. "!"
4. " "

小写 ([a-z]+):
1. "ello"
2. "orld"

小写并带有忽略大小写标志 ([a-z]+):
1. "Hello"
2. "World"

基本 POSIX 正则表达式 ([[:digit:]]+):
未找到匹配

扩展 POSIX 正则表达式 ([[:digit:]]+):
1. "12345"
}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}