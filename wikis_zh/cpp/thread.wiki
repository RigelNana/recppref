{{title|并发支持库 {{mark since c++11}}}}
{{cpp/thread/navbar}}

C++ 包含线程、原子操作、互斥、条件变量和 future 的内建支持。

===线程===
线程使得程序能在数个处理器核心同时执行。

{{dsc begin}}
{{dsc header|thread}}
{{dsc inc|cpp/thread/dsc thread}}
{{dsc inc|cpp/thread/dsc jthread}}
{{dsc h2|管理当前线程的函数}}
{{dsc namespace|this_thread}}
{{dsc inc|cpp/thread/dsc yield}}
{{dsc inc|cpp/thread/dsc get_id}}
{{dsc inc|cpp/thread/dsc sleep_for}}
{{dsc inc|cpp/thread/dsc sleep_until}}
{{dsc end}}

{{anchor|协作式取消}}
===协作式取消 {{mark since c++20}}===
''停止源''、''停止令牌''{{sep}}和''停止回调''{{sep}}等组件可用于提出异步请求，使操作适时停止执行。通常这样做是由于不再需要其结果。这种请求被称为''停止请求''。

这些组件指定了对于某个''停止状态''{{sep}}的共享访问。实现这些组件的，指代相同停止状态的各个对象，分别为其关联停止源、停止令牌和停止回调。

{{rrev|since=c++26|
概念 {{lconcept|stoppable-source}}、{{lconcept|stoppable_token}} 和 {{lconcept|stoppable-callback-for}} 分别指定了停止源、停止令牌和停止回调所需的语法和需要实现的语义。
}}

它们的设计目标为：
* 用于对诸如 {{tt|std::jthread}} 进行协作式取消执行，
* 中断 {{lc|std::condition_variable_any}} 的等待函数，
{{rrev|since=c++26|* 实施 {{lc|execution::connect}} 创建的异步操作的停止完成，}} 
* 用于自定义的线程管理实现。

实际上它们甚至不需要用于“停止”任何操作，例如可以用作线程安全的一次性函数调用触发器。

{{dsc begin}}
{{dsc header|stop_token}}
{{dsc h2|停止令牌类型}}
{{dsc inc|cpp/thread/dsc stop_token}}
{{dsc inc|cpp/thread/dsc never_stop_token}}
{{dsc inc|cpp/thread/dsc inplace_stop_token}}
{{dsc h2|停止源类型}}
{{dsc inc|cpp/thread/dsc stop_source}}&lt;!--包括作为辅助的 nostopstate_t--&gt;
{{dsc inc|cpp/thread/dsc inplace_stop_source}}
{{dsc h2|停止回调类型}}
{{dsc inc|cpp/thread/dsc stop_callback}}
{{dsc inc|cpp/thread/dsc inplace_stop_callback}}
{{dsc inc|cpp/thread/dsc stop_callback_for_t}}
{{anchor|概念}}
{{dsc h2|概念 {{mark since c++26}}}}
{{dsc inc|cpp/thread/dsc stoppable_token}}
{{dsc inc|cpp/thread/dsc unstoppable_token}}
{{dsc inc|cpp/thread/dsc stoppable_source}}
{{dsc inc|cpp/thread/dsc stoppable_callback_for}}
{{dsc end}}

{{anchor|缓存大小访问}}
===缓存大小访问 {{mark since c++17}}===
{{dsc begin}}
{{dsc header|new}}
{{dsc inc|cpp/thread/dsc hardware_destructive_interference_size}}
{{dsc end}}

===原子操作===
这些组件为细粒度的原子操作而提供，允许无锁并发编程。涉及同一对象的每个原子操作，相对于任何其他原子操作是不可分的。原子对象[[cpp/language/memory_model#线程与数据竞争|不存在数据竞争]]。

{{dsc begin}}
{{dsc header|atomic}}
{{dsc h2|原子类型}}
{{dsc inc|cpp/atomic/dsc atomic}}
{{dsc inc|cpp/atomic/dsc atomic_ref}}
{{dsc h2|原子类型上的操作}}
{{dsc inc|cpp/atomic/dsc atomic_is_lock_free}}
{{dsc inc|cpp/atomic/dsc atomic_store}}
{{dsc inc|cpp/atomic/dsc atomic_load}}
{{dsc inc|cpp/atomic/dsc atomic_exchange}}
{{dsc inc|cpp/atomic/dsc atomic_compare_exchange}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_add}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_sub}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_and}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_or}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_xor}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_max}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_min}}
{{dsc inc|cpp/atomic/dsc atomic_wait}}
{{dsc inc|cpp/atomic/dsc atomic_notify_one}}
{{dsc inc|cpp/atomic/dsc atomic_notify_all}}
{{dsc h2|标志类型及操作}}
{{dsc inc|cpp/atomic/dsc atomic_flag}}
{{dsc inc|cpp/atomic/dsc atomic_flag_test_and_set}}
{{dsc inc|cpp/atomic/dsc atomic_flag_clear}}
{{dsc inc|cpp/atomic/dsc atomic_flag_test}}
{{dsc inc|cpp/atomic/dsc atomic_flag_wait}}
{{dsc inc|cpp/atomic/dsc atomic_flag_notify_one}}
{{dsc inc|cpp/atomic/dsc atomic_flag_notify_all}}
{{dsc h2|初始化}}
{{dsc inc|cpp/atomic/dsc atomic_init}}
{{dsc inc|cpp/atomic/dsc ATOMIC_VAR_INIT}}
{{dsc inc|cpp/atomic/dsc ATOMIC_FLAG_INIT}}
{{dsc h2|内存同步定序}}
{{dsc inc|cpp/atomic/dsc memory_order}}
{{dsc inc|cpp/atomic/dsc kill_dependency}}
{{dsc inc|cpp/atomic/dsc atomic_thread_fence}}
{{dsc inc|cpp/atomic/dsc atomic_signal_fence}}
{{dsc header|stdatomic.h}}
{{anchor|C 兼容宏}}
{{dsc h2|C 兼容宏 {{mark since c++23}}}}
{{dsc inc|cpp/atomic/dsc _Atomic}}
{{dsc end}}

{{tt|&lt;stdatomic.h&gt;}} 以外的 C++ 标准库标头不提供 {{tt|_Atomic}} 宏或任何非宏的全局命名空间声明。

===互斥===
互斥算法避免多个线程同时访问共享资源。这会避免数据竞争，并提供线程间的同步支持。

{{dsc begin}}
{{dsc header|mutex}}
{{dsc inc|cpp/thread/dsc mutex}}
{{dsc inc|cpp/thread/dsc timed_mutex}}
{{dsc inc|cpp/thread/dsc recursive_mutex}}
{{dsc inc|cpp/thread/dsc recursive_timed_mutex}}
{{dsc header|shared_mutex}}
{{dsc inc|cpp/thread/dsc shared_mutex}}
{{dsc inc|cpp/thread/dsc shared_timed_mutex}}

{{dsc h2|通用互斥体管理}}
{{dsc header|mutex}}
{{dsc inc|cpp/thread/dsc lock_guard}}
{{dsc inc|cpp/thread/dsc scoped_lock}}
{{dsc inc|cpp/thread/dsc unique_lock}}
{{dsc inc|cpp/thread/dsc shared_lock}}
{{dsc inc|cpp/thread/dsc lock_tag}}

{{dsc h2|通用锁定算法}}
{{dsc inc|cpp/thread/dsc try_lock}}
{{dsc inc|cpp/thread/dsc lock}}

{{dsc h2|单次调用}}
{{dsc inc|cpp/thread/dsc once_flag}}
{{dsc inc|cpp/thread/dsc call_once}}
{{dsc end}}

===条件变量===
条件变量是允许多个线程相互交流的同步原语。它允许一定量的线程等待（可以定时）另一线程的提醒，然后再继续。条件变量始终关联到一个互斥体。

{{dsc begin}}
{{dsc header|condition_variable}}
{{dsc inc|cpp/thread/dsc condition_variable}}
{{dsc inc|cpp/thread/dsc condition_variable_any}}
{{dsc inc|cpp/thread/dsc notify_all_at_thread_exit}}
{{dsc inc|cpp/thread/dsc cv_status}}
{{dsc end}}

{{anchor|信号量}}
===信号量 {{mark since c++20}}===
信号量 (semaphore) 是一种轻量的同步原语，用于制约对共享资源的并发访问。在可以使用两者时，信号量能比条件变量更有效率。
{{dsc begin}}
{{dsc header|semaphore}}
{{dsc inc|cpp/thread/dsc counting_semaphore}}
{{dsc inc|cpp/thread/dsc binary_semaphore}}
{{dsc end}}

{{anchor|闩与屏障}}
===闩与屏障 {{mark since c++20}}===
闩 (latch) 与屏障 (barrier) 是线程协调机制，允许任何数量的线程阻塞直至期待数量的线程到达。闩不能重复使用，而屏障则可以。
{{dsc begin}}
{{dsc header|latch}}
{{dsc inc|cpp/thread/dsc latch}}
{{dsc header|barrier}}
{{dsc inc|cpp/thread/dsc barrier}}
{{dsc end}}

{{anchor|future}}
===未来体===
标准库提供了一些工具来获取异步任务（即在单独的线程中启动的函数）的返回值，并捕捉其所抛出的异常。这些值在''共享状态''中传递，其中异步任务可以写入其返回值或存储异常，而且可以由持有该引用该共享态的 {{lc|std::future}} 或 {{lc|std::shared_future}} 实例的线程检验、等待或是操作这个状态。

{{dsc begin}}
{{dsc header|future}}
{{dsc inc|cpp/thread/dsc promise}}
{{dsc inc|cpp/thread/dsc packaged_task}}
{{dsc inc|cpp/thread/dsc future}}
{{dsc inc|cpp/thread/dsc shared_future}}
{{dsc inc|cpp/thread/dsc async}}
{{dsc inc|cpp/thread/dsc launch}}
{{dsc inc|cpp/thread/dsc future_status}}

{{dsc h2|未来体错误}}
{{dsc inc|cpp/thread/dsc future_error}}
{{dsc inc|cpp/thread/dsc future_category}}
{{dsc inc|cpp/thread/dsc future_errc}}
{{dsc end}}

{{anchor|安全回收}}
===安全回收 {{mark since c++26}}===
安全回收技术最常用于直接解决访问-删除竞争。

{{dsc begin}}
{{dsc h2|读-复制-更新机制}}
{{dsc header|rcu}}
{{dsc inc|cpp/thread/dsc rcu_obj_base}}
{{dsc inc|cpp/thread/dsc rcu_domain}}
{{dsc inc|cpp/thread/dsc rcu_default_domain}}
{{dsc inc|cpp/thread/dsc rcu_synchronize}}
{{dsc inc|cpp/thread/dsc rcu_barrier}}
{{dsc inc|cpp/thread/dsc rcu_retire}}

{{dsc h2|风险指针}}
{{dsc header|hazard_pointer}}
{{dsc inc|cpp/thread/dsc hazard_pointer_obj_base}}
{{dsc inc|cpp/thread/dsc hazard_pointer}}
{{dsc inc|cpp/thread/dsc make_hazard_pointer}}
{{dsc end}}

===参阅===
{{dsc begin}}
{{dsc see c|c/thread|并发支持库|nomono=true}}
{{dsc end}}

{{langlinks|ar|de|en|es|fr|it|ja|pt|ru}}