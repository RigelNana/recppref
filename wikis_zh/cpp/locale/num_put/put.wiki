{{cpp/locale/num_put/title|put|do_put}}
{{cpp/locale/num_put/navbar}}
{{dcl begin}}
{{dcl header|locale}}
{{dcl rev begin|num=1}}
{{dcl|
public:
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, bool val ) const;
}}
{{dcl|
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, long val ) const;
}}
{{dcl|since=c++11|
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, long long val ) const;
}}
{{dcl|
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, unsigned long val ) const;
}}
{{dcl|since=c++11|
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, unsigned long long val ) const;
}}
{{dcl|
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, double val ) const;
}}
{{dcl|
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, long double val ) const;
}}
{{dcl|
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, const void* val ) const;
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|
protected:
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, bool val ) const;
}}
{{dcl|
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, long val ) const;
}}
{{dcl|since=c++11|
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, long long val ) const;
}}
{{dcl|
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, unsigned long val ) const;
}}
{{dcl|since=c++11|
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, unsigned long long val ) const;
}}
{{dcl|
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, double val ) const;
}}
{{dcl|
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, long double val ) const;
}}
{{dcl|
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, const void* val ) const;
}}
{{dcl rev end}}
{{dcl end}}

@1@ 公开成员函数，调用最终派生类的受保护虚成员函数 {{tt|do_put}}。

@2@ 写字符到输出序列 {{c|out}}，这些字符表示 {{c|val}} 的值，按格式标志 {{c|str.flags()}} 和流 {{c|str}} 中浸染的本地环境的 {{lc|std::numpunct}} 和 {{lc|std::ctype}} 刻面所要求者格式化。此函数会被所有有格式输出流运算符，如 {{c|std::cout &lt;&lt; n;}} 调用。

转换分为四个阶段进行：

====阶段 1：选择转换说明符====
* 获得输入/输出格式标志，如同以
: {{c|1=fmtflags basefield = (str.flags() &amp; std::ios_base::basefield);}}
: {{c|1=fmtflags uppercase = (str.flags() &amp; std::ios_base::uppercase);}}
: {{c|1=fmtflags floatfield = (str.flags() &amp; std::ios_base::floatfield);}}
: {{c|1=fmtflags showpos = (str.flags() &amp; std::ios_base::showpos);}}
: {{c|1=fmtflags showbase = (str.flags() &amp; std::ios_base::showbase);}}
: {{c|1=fmtflags showpoint = (str.flags() &amp; std::ios_base::showpoint);}}
* 如果 {{c|val}} 的类型是 {{c/core|bool}}：
** 如果 {{c|1=boolalpha == 0}}，那么将 {{c|val}} 转换到 {{c/core|int}} 类型并进行整数输出。
** 如果 {{c|1=boolalpha != 0}}，那么在 {{c|1=val == true}} 时获得{{c|std::use_facet&lt;std::numpunct&lt;charT&gt;&gt;(str.getloc()).truename()}}，或者在 {{c|1=v == false}} 时获得 {{c|std::use_facet&lt;std::numpunct&lt;charT&gt;&gt;(str.getloc()).falsename()}}，并以 {{c|1=*out++ = c}} 输出该字符串的每个相继字符 {{c|c}} 到 {{c|out}}。此时不进行进一步的操作，函数返回 {{c|out}}。
* 如果 {{c|val}} 的类型是整数类型，那么选择下列首个可应用选项：
** 如果 {{c|1=basefield == oct}}，那么会使用转换说明符 {{c|%o}}。
** 如果 {{c|1=basefield == hex &amp;&amp; !uppercase}}，那么会使用转换说明符 {{c|%x}}。
** 如果 {{c|1=basefield == hex}}，那么会使用转换说明符 {{c|%X}}。
** 如果 {{c|val}} 的类型有符号，那么会使用转换说明符 {{c|%d}}。
** 如果 {{c|val}} 的类型无符号，那么会使用转换说明符 {{c|%u}}。
* 对于整数类型，在有需要时添加长度修饰符到转换说明：对于 {{c/core|long}} 和 {{c/core|unsigned long}} 是 {{c|l}}{{rev inl|since=c++11|，对于 {{c/core|long long}} 和 {{c/core|unsigned long long}} 是 {{c|ll}}}}。
* 如果 {{c|val}} 是浮点数类型，那么选择下列首个可应用选项：
{{rev begin}}
{{rev|until=c++11|
:* 如果 {{c|1=floatfield == std::ios_base::fixed}}，那么会使用转换说明符 {{c|%f}}。
}}
{{rev|since=c++11|
:* 如果 {{c|1=floatfield == std::ios_base::fixed &amp;&amp; !uppercase}}，那么会使用转换说明符 {{c|%f}}。
:* 如果 {{c|1=floatfield == std::ios_base::fixed}}，那么会使用转换说明符 {{c|%F}}。
}}
{{rev end}}
:* 如果 {{c|1=floatfield == std::ios_base::scientific &amp;&amp; !uppercase}}，那么会使用转换说明符 {{c|%e}}。
:* 如果 {{c|1=floatfield == std::ios_base::scientific}}，那么会使用转换说明符 {{c|%E}}。
{{rrev|since=c++11|
:* 如果 {{c|1=floatfield == (std::ios_base::fixed {{!}} std::ios_base::scientific) &amp;&amp; !uppercase}}，那么会使用转换说明符 {{c|%a}}。
:* 如果 {{c|1=floatfield == (std::ios_base::fixed {{!}} std::ios_base::scientific)}}，那么会使用转换说明符 {{c|%A}}。
}}
:* 如果 {{c|1=!uppercase}}，那么会使用转换说明符 {{c|%g}}。
:* 否则就会使用转换说明符 {{c|%G}}。
: 并且：
:* 如果 {{c|val}} 的类型是 {{c/core|long double}}，那么会添加长度修饰符 {{c|L}} 到转换说明符。
:* 如果 {{c|val}} 是浮点数类型{{rev inl|since=c++11|且 {{c|1=floatfield != (ios_base::fixed {{!}} ios_base::scientific)}}}}，那么添加设为 {{c|str.precision()}} 的精度说明符。否则不指定精度。
* 对于整数和浮点数类型，如果设置了 {{c|showpos}}，那么会前附修饰符 {{c|+}}。
* 对于整数类型，如果设置了 {{c|showbase}}，那么会前附修饰符 {{c|#}}。
* 对于浮点数类型，如果设置了 {{c|showpoint}}，那么会前附修饰符 {{c|#}}。
* 如果 {{c|val}} 的类型是 {{c/core|void*}}，那么会使用格式说明符 {{c|%p}}。
* 如同以在 "C" 本地环境中调用 {{c|std::printf(spec, val)}} 创建窄字符串，其中 {{c|spec}} 是所选的格式说明符。

====阶段 2：本地环境限定转换====
* 调用 {{c|std::use_facet&lt;std::ctype&lt;CharT&gt;&gt;(str.getloc()).widen(c)}}，将阶段 1 中获得的每个小数点 {{c|'.'}} 以外的字符 {{c|c}} 转换到 {{tt|CharT}}。
* 对于算术类型，按照 {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).grouping()}} 提供的分组规则，插入从 {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).thousands_sep()}} 获得的千位分隔字符到序列中。
* 以 {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).decimal_point()}} 替换小数点字符（{{c|'.'}}）。
====阶段 3：填充====
* 如同以 {{c|1=std::fmtflags adjustfield = (flags &amp; (std::ios_base::adjustfield))}} 获得调整标志，并以如下方式检验它以鉴别填充位置：
** 如果 {{c|1=adjustfield == std::ios_base::left}}，那么会在后方填充。
** 如果 {{c|1=adjustfield == std::ios_base::right}}，那么会在前方填充。
** 如果 {{c|1=adjustfield == std::ios_base::internal}} 且表示中出现符号字符，那么会在符号后填充。
** 如果 {{c|1=adjustfield == std::ios_base::internal}} 而阶段 1 表示以 0x 或 0X 开始，那么会在 x 或 X 后填充。
** 否则就会在前方填充。
* 如果 {{c|str.width()}} 非零（例如刚使用了 {{lc|std::setw}} ）且阶段 2 后的 {{tt|CharT}} 数小于 {{c|str.width()}}，那么会在填充所指示的位置插入 {{c|fill}} 字符的副本，使得序列长度达到 {{c|str.width()}}。
任何情况下都会调用 {{c|str.width(0)}} 以取消 {{lc|std::setw}} 的效果。

====阶段 4：输出====
如同用 {{c|1=*out++ = c}} 输出来自阶段 3 的 {{tt|CharT}} 序列的每个相继字符 {{c|c}}。

===参数===
{{par begin}}
{{par|out|指向首个要写入字符的迭代器}}
{{par|str|取得格式化信息来源的流}}
{{par|fill|需要填充结果到域宽时使用的填充字符}}
{{par|val|转换为字符串并输出的值}}
{{par end}}

===返回值===
{{c|out}}

===注解===
转换说明 {{c|#o}}（例如产生自 {{lc|std::showbase}} 和 {{lc|std::oct}} 的组合）不计为填充字符。
{{rrev|since=c++11|1=
格式化浮点数是 hexfloat 时（即 {{c|1=floatfield == (std::ios_base::fixed {{!}} std::ios_base::scientific)}} 时），不使用流的精度；而是始终以足以准确表示值的精度打印该数。
}}

===示例===
{{example
|用平面直接输出数，并演示用户定义的刻面：
|code=
#include &lt;iostream&gt;
#include &lt;locale&gt;

// 此定制 num_put 平面输出所有整数类型的平方（除了 long long）
struct squaring_num_put : std::num_put&lt;char&gt;
{
    iter_type do_put(iter_type out, std::ios_base&amp; str,
                     char_type fill, long val) const
    {
        return std::num_put&lt;char&gt;::do_put(out, str, fill, val * val);
    }
    
    iter_type do_put(iter_type out, std::ios_base&amp; str,
                     char_type fill, unsigned long val) const
    {
        return std::num_put&lt;char&gt;::do_put(out, str, fill, val * val);
    }
};

int main()
{
    auto&amp; facet = std::use_facet&lt;std::num_put&lt;char&gt;&gt;(std::locale());
    facet.put(std::cout, std::cout, '0', 2.71);
    std::cout &lt;&lt; '\n';
    
    std::cout.imbue(std::locale(std::cout.getloc(), new squaring_num_put));
    std::cout &lt;&lt; 6 &lt;&lt; ' ' &lt;&lt; -12 &lt;&lt; '\n';
} 
|output=
2.71
36 144
}}

{{example|用户定义类型的 {{lc|operator&lt;&lt;}} 的实现。
|code=
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;locale&gt;

struct base { long x = 10; };

template&lt;class CharT, class Traits&gt;
std::basic_ostream&lt;CharT, Traits&gt;&amp;
    operator&lt;&lt;(std::basic_ostream&lt;CharT, Traits&gt;&amp; os, const base&amp; b)
{
    try
    {
        typename std::basic_ostream&lt;CharT, Traits&gt;::sentry s(os);
        
        if (s)
        {
            std::ostreambuf_iterator&lt;CharT, Traits&gt; it(os);
            std::use_facet&lt;std::num_put&lt;CharT&gt;&gt;(os.getloc())
                .put(it, os, os.fill(), b.x);
        }
    }
    catch (...)
    {
        // 设置 os 上的 badbit，而且在需要时重新抛出
    }
    
    return os;
}

int main()
{
    base b;
    std::cout &lt;&lt; b;
}
|output=
10
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=34|std=C++98|before={{c/core|bool}} 重载使用了 {{lc|std::ctype}} 的不存在的成员 {{c|truename}} 和 {{c|falsename}}|after=使用 {{lc|std::numpunct}} 的这些成员}}
{{dr list item|wg=lwg|dr=231|std=C++98|before=只有在 {{c|1=(flags &amp; fixed) != 0}} 或&lt;br&gt;{{c|1=str.precision() &gt; 0}} 时才会添加精度说明符|after=移除这些条件}}
{{dr list item|wg=lwg|dr=282|std=C++98|before=阶段 2 中只会对整数类型插入千位分隔符|after=对浮点数类型也会}}
{{dr list item|wg=lwg|dr=4084|std=C++11|before=无法打印 {{c|"NAN"}} 和 {{c|"INF"}}|after=可以打印}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/io/basic_ostream/dsc operator_ltlt}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}