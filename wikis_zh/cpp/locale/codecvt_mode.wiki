{{cpp/title|codecvt_mode}}
{{cpp/locale/navbar}}
{{ddcl|since=c++11|deprecated=c++17|removed=c++26|header=codecvt|1=
enum codecvt_mode {
    consume_header = 4,
    generate_header = 2,
    little_endian = 1
};
}}

刻面 {{lc|std::codecvt_utf8}}、{{lc|std::codecvt_utf16}} 和 {{lc|std::codecvt_utf8_utf16}} 接受可选的 {{tt|std::codecvt_mode}} 类型的值为模板实参，这会指定 Unicode 字符串转换的可选特性。

===常量===
{{dsc begin}}
{{dsc header|locale}}
{{dsc hitem|枚举项|含义}}
{{dsc|{{tt|little_endian}}|假设输入是小端序（仅应用于 UTF-16 输入，默认为大端序）}}
{{dsc|{{tt|consume_header}}|消耗可能在输入序列的开始存在的字节序标记，而且（在 UTF-16 的情况下）依赖于为解码剩下输入而指定的字节序}}
{{dsc|{{tt|generate_header}}|在输出序列的开始输出字节序标记}}
{{dsc end}}

可以辨认的字节序标记有：
{{dsc begin}}
{{dsc|{{tt|0xfe 0xff}}|UTF-16 大端}}
{{dsc|{{tt|0xff 0xfe}}|UTF-16 小端}}
{{dsc|{{tt|0xef 0xbb 0xbf}}|UTF-8（端序无影响）}}
{{dsc end}}

如果在读以字节序标记开始的文件时未指定 {{tt|std::consume_header}}，那么将 Unicode 字符 U+FEFF（零宽无中断空格）读作字符串内容的首字符。

===示例===
{{example
|下列示例演示消耗 UTF-8 字节序标记：
|code=
#include &lt;codecvt&gt;
#include &lt;cwchar&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &lt;string&gt;

int main()
{
    // 带字节序标记的 UTF-8 数据
    std::ofstream{"text.txt"} &lt;&lt; "\ufeffz\u6c34\U0001d10b";
    
    // 读 UTF-8 文件，跳过字节序标记
    std::wifstream fin("text.txt");
    fin.imbue(std::locale(fin.getloc(),
                          new std::codecvt_utf8&lt;wchar_t, 0x10ffff, std::consume_header&gt;));
    
    for (wchar_t c; fin.get(c);)
        std::cout &lt;&lt; std::hex &lt;&lt; std::showbase &lt;&lt; c &lt;&lt; '\n';
}
|output=
0x7a
0x6c34
0x1d10b
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/locale/dsc codecvt}}
{{dsc inc|cpp/locale/dsc codecvt_utf8}}
{{dsc inc|cpp/locale/dsc codecvt_utf16}}
{{dsc inc|cpp/locale/dsc codecvt_utf8_utf16}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}