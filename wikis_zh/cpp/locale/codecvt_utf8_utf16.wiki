{{cpp/title|codecvt_utf8_utf16}}
{{cpp/locale/navbar}}
{{ddcl|header=codecvt|since=c++11|deprecated=c++17|removed=c++26|1=
template&lt;
    class Elem,
    unsigned long Maxcode = 0x10ffff,
    std::codecvt_mode Mode = (std::codecvt_mode)0 &gt;
class codecvt_utf8_utf16
    : public std::codecvt&lt;Elem, char, std::mbstate_t&gt;;
}}

{{tt|std::codecvt_utf8_utf16}} 是一个 {{lc|std::codecvt}} 刻面，封装 UTF-8 编码字节串和 UTF-16 编码字符串间的转换。如果 {{tt|Elem}} 是 32 位类型，那么输出序列的每个 32 位字符中将存储一个 UTF-16 编码单元。

这是 N:M 转换刻面，而且不能用于 {{lc|std::basic_filebuf}}（它只容许内部和外部编码间的 1:N 转换，例如 UTF-32/UTF-8）。此刻面可以用于 {{lc|std::wstring_convert}}。

===模板形参===
{{par begin}}
{{par|Elem|{{c/core|char16_t}}、{{c/core|char32_t}} 或 {{c/core|wchar_t}} 之一}}
{{par|Maxcode|此刻面将读或写而不出错的 {{tt|Elem}} 最大值}}
{{par|Mode|{{lc|std::codecvt_mode}} 类型的常量}}
{{par end}} 

===成员函数===
{{dsc begin}}
{{dsc mem ctor|cpp/locale/codecvt_utf8_utf16|inlinemem=true|构造新的 {{tt|codecvt_utf8_utf16}} 刻面}}
{{dsc mem dtor|cpp/locale/codecvt_utf8_utf16|inlinemem=true|销毁 {{tt|codecvt_utf8_utf16}} 刻面}}
{{dsc end}}

{{member|{{small|std::codecvt_utf8_utf16::}}codecvt_utf8_utf16|
{{dcl begin}}
{{dcl|1=
explicit codecvt_utf8_utf16( std::size_t refs = 0 );
}}
{{dcl end}}

构造新的 {{tt|std::codecvt_utf8_utf16}} 刻面，传递初始引用计数 {{c|refs}} 给基类。

===参数===
{{par begin}}
{{par|refs|链接到此刻面的引用数}}
{{par end}}
}}

{{member|{{small|std::codecvt_utf8_utf16::}}~codecvt_utf8_utf16|
{{dcl begin}}
{{dcl|1=
~codecvt_utf8_utf16();
}}
{{dcl end}}

销毁刻面。与本地环境管理的刻面不同，此刻面的析构函数是公开的。
}}

{{cpp/locale/codecvt/inherit}}
{{cpp/locale/codecvt_base/inherit}}

===示例===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;codecvt&gt;
#include &lt;cstdint&gt;
#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &lt;string&gt;

int main()
{
    std::string u8 = "z\u00df\u6c34\U0001f34c";
    std::u16string u16 = u"z\u00df\u6c34\U0001f34c";
    
    // UTF-8 到 UTF-16/char16_t
    std::u16string u16_conv = std::wstring_convert&lt;
        std::codecvt_utf8_utf16&lt;char16_t&gt;, char16_t&gt;{}.from_bytes(u8);
    assert(u16 == u16_conv);
    std::cout &lt;&lt; "UTF-8 到 UTF-16 的转换产生了 " &lt;&lt; u16_conv.size()
              &lt;&lt; " 个代码单元：\n" &lt;&lt; std::showbase &lt;&lt; std::hex;
    for (char16_t c : u16_conv)
        std::cout &lt;&lt; static_cast&lt;std::uint16_t&gt;(c) &lt;&lt; ' ';
    
    // UTF-16/char16_t 到 UTF-8
    std::string u8_conv = std::wstring_convert&lt;
        std::codecvt_utf8_utf16&lt;char16_t&gt;, char16_t&gt;{}.to_bytes(u16);
    assert(u8 == u8_conv);
    std::cout &lt;&lt; "\nUTF-16 到 UTF-8 的转换产生了 "
              &lt;&lt; std::dec &lt;&lt; u8_conv.size() &lt;&lt; " 个字节：\n" &lt;&lt; std::hex;
    for (char c : u8_conv)
        std::cout &lt;&lt; static_cast&lt;unsigned char&gt;(c) &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
UTF-8 到 UTF-16 的转换产生了 5 个代码单元：
0x7a 0xdf 0x6c34 0xd83c 0xdf4c 
UTF-16 到 UTF-8 的转换产生了 10 个字节：
0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c 
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2229|std=C++98|before=未指定构造函数和析构函数|after=指定它们}}
{{dr list end}}

===参阅===
{{cpp/locale/unicode string conversions}}
{{dsc begin}}
{{dsc inc|cpp/locale/dsc codecvt}}
{{dsc inc|cpp/locale/dsc codecvt_mode}}
{{dsc inc|cpp/locale/dsc codecvt_utf8}}
{{dsc inc|cpp/locale/dsc codecvt_utf16}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}