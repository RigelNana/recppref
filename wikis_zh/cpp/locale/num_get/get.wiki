{{cpp/locale/num_get/title|get|do_get}}
{{cpp/locale/num_get/navbar}}
{{dcl begin}}
{{dcl rev begin|num=1}}
{{dcl|
public:
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, bool&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, long&amp; v ) const;
}}
{{dcl|since=c++11|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, long long&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, unsigned short&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, unsigned int&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, unsigned long&amp; v ) const;
}}
{{dcl|since=c++11|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, unsigned long long&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, float&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, double&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, long double&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, void*&amp; v ) const;
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|
protected:
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, bool&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, long&amp; v ) const;
}}
{{dcl|since=c++11|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, long long&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, unsigned short&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, unsigned int&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, unsigned long&amp; v ) const;
}}
{{dcl|since=c++11|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err,
                          unsigned long long&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, float&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, double&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, long double&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, void*&amp; v ) const;
}}
{{dcl rev end}}
{{dcl end}}

@1@ 公开成员函数，调用最终派生类的成员函数 {{tt|do_get}}。

@2@ 从输入迭代器 {{c|in}} 读取字符，并生成 {{c|v}} 的类型的值，考虑来自输入/输出流 {{tt|str.flags()}} 的格式化标志，来自 {{c|std::use_facet&lt;std::ctype&lt;CharT&gt;&gt;(str.getloc())}} 的字符分类规则，和来自 {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc())}} 的数值标点字符。此函数为所有有格式输入流运算符，如 {{c|std::cin &gt;&gt; n;}} 所调用。

转换分为三个阶段进行：

====阶段 1：选择转换说明符==== 
* 获得输入/输出格式标志，如同以
: {{c|1=fmtflags basefield = (str.flags() &amp; std::ios_base::basefield);}}
: {{c|1=fmtflags boolalpha = (str.flags() &amp; std::ios_base::boolalpha);}}
* 如果 {{c|v}} 的类型是整数类型，那么从以下五个选项选择首个可以应用的选项：
: 如果 {{c|1=basefield == oct}}，那么使用转换说明符 {{c|%o}}
: 如果 {{c|1=basefield == hex}}，那么使用转换说明符 {{c|%X}}
: 如果 {{c|1=basefield == 0}}，那么使用转换说明符 {{c|%i}}
: 如果 {{c|v}} 的类型有符号，那么使用转换说明符 {{c|%d}}
: 如果 {{c|v}} 的类型无符号，那么使用转换说明符 {{c|%u}}
* 对于整数类型，在需要时添加长度说明符到转换说明：对于 {{c/core|short}} 和 {{c/core|unsigned short}} 是 {{c|h}}，对于 {{c/core|long}} 和 {{c/core|unsigned long}} 是 {{c|l}}{{rev inl|since=c++11|，对于 {{c/core|long long}} 和 {{c/core|unsigned long long}} 是 {{c|ll}}}}
* 如果 {{c|v}} 的类型是 {{c/core|float}}，那么使用转换说明符 {{c|%g}}
* 如果 {{c|v}} 的类型是 {{c/core|double}}，那么使用转换说明符 {{c|%lg}}
* 如果 {{c|v}} 的类型是 {{c/core|long double}}，那么使用转换说明符 {{c|%Lg}}
* 如果 {{c|v}} 的类型是 {{c/core|void*}}，那么使用转换说明符 {{c|%p}}
* 如果 {{c|v}} 的类型是 {{c/core|bool}} 且 {{c|1=boolalpha == 0}}，那么如同将 {{c|v}} 的类型作为 {{c/core|long}} 一般处理，除了在阶段 3 存储到 {{c|v}} 的值。
* 如果 {{c|v}} 的类型是 {{c/core|bool}} 且 {{c|1=boolalpha != 0}}，那么以下列规则替换阶段 2 和 3：
** 从输入迭代器 {{c|in}} 获得匹配获得自 {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).falsename()}} 和 {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt; &gt;(str.getloc()).truename()}} 的相继字符，而且只按需要匹配鉴别唯一匹配。只有在需要获得字符时才会将输入迭代器 {{c|in}} 与 {{c|end}} 比较。
** 如果目标序列是唯一匹配，那么设置 {{c|v}} 为对应的 {{c/core|bool}} 值。否则将 {{c|false}} 存储到 {{c|v}} 并将 {{lc|std::ios_base::failbit}} 赋给 {{c|err}}。如果在输入结束（{{c|1=in == end}}）前无法找到唯一匹配，那么执行 {{c|1=err {{!}}= std::ios_base::eofbit}}。

====阶段 2：字符提取==== 
* 如果 {{c|1=in == end}}，那么立即终止阶段 2 并不再提取更多字符。
* 如同以 {{c|1=char_type ct = *in;}} 从 {{c|in}} 提取下个字符：
** 如果字符匹配如同用 {{c|std::use_facet&lt;std::ctype&lt;CharT&gt;&gt;(str.getloc()).widen()}} 加宽到本地环境的 {{tt|char_type}} 的 {{rev inl|until=c++11|{{c|"0123456789abcdefxABCDEFX+-"}}}}{{rev inl|since=c++11|{{c|"0123456789abcdepfxABCDEFPX+-"}}}} 字符之一，那么将它转换到对应的 {{c/core|char}}。
** 如果字符匹配小数点（{{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).decimal_point())}}），那么以 {{c|'.'}} 替换它。
** 如果字符匹配千分隔符（{{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).thousands_sep()}}）且在所有 {{c|1=std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).grouping().length() != 0}} 中使用千分隔，那么在尚未积累小数点 {{c|'.'}} 的情况下记忆该字符的位置，但在其他情况下忽略该字符。如果已经积累了小数点，那么舍弃该字符并终止阶段 2。
** 在任何情况下，检查从前一步骤获得的 {{c/core|char}} 是否可以用在会为 {{lc|std::scanf}} 给定阶段 1 中选择的转换指定符的输入域中。如果可以，那么将它积累到临时缓冲区并重复阶段 2。如果不可以，那么阶段 2 终止。

====阶段 3：转换与存储====
* 将阶段 2 中积累的 {{c/core|char}} 序列转换成数值：
{{rev begin}}
{{rev|until=c++11|
: 根据 {{lc|std::scanf}} 的规则解析输入。
}}
{{rev|since=c++11|
: 如同以
:* 对有符号整数 {{c|v}} 的 {{lc|std::strtoll}}、
:* 对无符号整数 {{c|v}} 的 {{lc|std::strtoull}}、
:* 对 {{c/core|float}} {{c|v}} 的 {{lc|std::strtof}}、
:* 对 {{c/core|double}} {{c|v}} 的 {{lc|std::strtod}} 或
:* 对 {{c/core|long double}} {{c|v}} 的 {{lc|std::strtold}}
: 解析输入。
}}
{{rev end}}
* 如果转换函数无法转换整个域，那么将 {{c|0}} 存储到 {{c|v}}。
* 如果 {{c|v}} 具有有符号整数类型而且转换函数产生的正值或负值因为过大或过小而无法适合该类型，那么分别将可表示的最正值或最负值存储到 {{c|v}}。
* 如果 {{c|v}} 具有无符号整数类型而且转换函数产生的值无法适合该类型，那么将可表示的最正值存储到 {{c|v}}。
* 任何情况下，如果转换函数失败，那么将 {{lc|std::ios_base::failbit}} 赋给 {{c|err}}。
* 否则，将转换的数值结果存储到 {{c|v}}。
** 如果 {{c|v}} 的类型是 {{c/core|bool}} 且没有设置 {{tt|boolalpha}}，那么在要存储的值是 {{c|0}} 时存储 {{c|false}}，在要存储的值是 {{c|1}} 时存储 {{c|true}}，对于任何其他值，将 {{lc|std::ios_base::failbit}} 赋给 {{c|err}} 并存储 {{c|true}}。
* 之后，检查数位分组。如果在阶段 2 中舍弃的任何千分隔符的位置不匹配 {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).grouping()}} 所提供的分组，那么将{{lc|std::ios_base::failbit}} 赋给 {{c|err}}。
* 如果因为测试 {{c|1=in == end}} 而终止阶段 2，那么执行 {{c|1=err {{!}}= std::ios_base::eofbit}} 设置 eof 位。

===返回值===
{{c|in}}

===注解===
在修复 {{lwg|23}} 和 {{lwg|696}} 前，出现错误时保留 {{c|v}} 不会更改。

在修复 {{lwg|221}} 前，因为阶段 2 会过滤掉 {{c|'X'}} 和 {{c|'x'}}，所以 {{tt|do_get(int)}} 会拒绝表示十六进制整数的字符串（例如 {{c|"0xA0"}}），即使它们是对 {{ltt|cpp/string/byte/strtol}} 的合法输入。

在修复 {{lwg|1169}} 前，转换负整数字符串到无符号整数时，某些实现会产生零（因为字符串所表示的值小于目标类型所能表示的值）。

{{rrev|since=c++11|
在修复 {{lwg|2381}} 前，因为阶段 2 会过滤掉 {{c|'P'}} 和 {{c|'p'}}，所以 {{tt|do_get(double)}} 会拒绝表示带指数部分的十六进制浮点数的字符串（例如 {{c|"0x1.23p-10"}}），即使它们是对 {{ltt|cpp/string/byte/strtof|strtod}} 的合法输入。

因为阶段 2 会过滤掉 {{c|'N'}} 和 {{c|'i'}} 这类字符，所以 {{tt|do_get(double)}} 会拒绝表示无限或非数的字符串（例如 {{c|"NaN"}} 和 {{c|"inf"}}），即使它们是对 {{tt|strtod}} 的合法输入。
}}

===示例===
{{example
|用户定义类型的 {{lc|operator&gt;&gt;}} 实现。
|code=
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;locale&gt;
 
struct base { long x; };
 
template &lt;class CharT, class Traits&gt;
std::basic_istream&lt;CharT, Traits&gt;&amp;
    operator &gt;&gt;(std::basic_istream&lt;CharT, Traits&gt;&amp; is, base&amp; b)
{
    std::ios_base::iostate err = std::ios_base::goodbit;
    
    try // 设置 err 可能会抛出异常
    {
        typename std::basic_istream&lt;CharT, Traits&gt;::sentry s(is);
        
        if (s) // 如果流已经输入就绪
            std::use_facet&lt;std::num_get&lt;CharT&gt;&gt;(is.getloc()).get(is, {}, is, err, b.x);
    }
    catch(std::ios_base::failure&amp; error)
    {
        // 处理异常
    }
    
    return is;
}

int main()
{
    base b;
    std::cin &gt;&gt; b;
}
|output=
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=17|std=C++98|before=文本布尔值的解析流程有误|after=已改正}}
{{dr list item|wg=lwg|dr=18|std=C++98|before=缺失了接受 {{c/core|bool&amp;}} 值的 {{tt|get}} 重载|after=已添加}}
{{dr list item|wg=lwg|dr=23|std=C++98|before=溢出的输入导致未定义行为|after=处理溢出}}
{{dr list item|wg=lwg|dr=154|std=C++98|before={{c/core|double}} 对应的转换说明符是 {{c|%g}}（和 {{c/core|float}} 一样）|after=改成 {{c|%lg}}}}
{{dr list item|wg=lwg|dr=221|std=C++98|before={{tt|do_get}} 不会解析 {{c|'x'}} 和 {{c|'X'}} 而 {{ltt|cpp/string/byte/strtol}} 会解析它们|after=解析 {{c|'x'}} 和 {{c|'X'}}}}
{{dr list item|wg=lwg|dr=275|std=C++98|before={{tt|get}} 有接受 {{c/core|short&amp;}} 值而不是 {{c/core|float&amp;}} 值的重载|after=已改正}}
{{dr list item|wg=lwg|dr=358|std=C++98|before=小数点后的千位分隔符会被忽略|after=碰到它们时终止阶段 2}}
{{dr list item|wg=lwg|dr=696|std=C++98|before=转换失败时不更改结果|after=设为零}}
{{dr list item|wg=lwg|dr=1169|std=C++98|before=溢出处理在不同浮点类型间不一致|after=使得与 {{tt|strtof}}/{{tt|strtod}} 一致}}
{{dr list item|wg=lwg|dr=2381|std=C++11|before={{tt|do_get}} 不会解析 {{c|'p'}} 和 {{c|'P'}} 而 {{ltt|cpp/string/byte/strtof|strtod}} 会解析它们|after=解析 {{c|'p'}} 和 {{c|'P'}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/io/basic_istream/dsc operator_gtgt}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}