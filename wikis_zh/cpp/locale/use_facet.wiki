{{cpp/title|use_facet}}
{{cpp/locale/navbar}}

{{ddcl|header=locale|
template&lt; class Facet &gt;
const Facet&amp; use_facet( const std::locale&amp; loc );
}}

获得到 {{c|loc}} 实装的刻面的引用。

如果 {{tt|Facet}} 不是定义中包含公开静态成员 {{ttb|id}} 的{{rlp|locale/facet#刻面类|刻面}}或者是有 volatile 限定的刻面，那么程序非良构。

===参数===
{{par begin}}
{{par|loc|要查询的本地环境对象}}
{{par end}}

===返回值===
返回到刻面的引用。此函数返回的引用在有引用该刻面的 {{lc|std::locale}} 对象存在的期间保持合法。

===异常===
在 {{c|1=std::has_facet&lt;Facet&gt;(loc) == false}} 的情况下抛出 {{lc|std::bad_cast}}。

===注解===
如果由 {{tt|use_facet}} 获得的到 {{tt|Facet}} 对象的引用在语句结束后有所使用，则 {{lc|std::locale}} 对象不能是临时量：
{{source|1=
// 不好：
auto&amp; f = std::use_facet&lt;std::moneypunct&lt;char, true&gt;&gt;(std::locale{"no_NO.UTF-8"});
foo(f.curr_symbol()); // 错误：f 内部使用了到已不再存在的 std::locale 对象的悬垂引用。
// 好：
auto loc = std::locale{"is_IS.UTF-8"}; // OK：非临时对象
auto&amp; f = std::use_facet&lt;std::moneypunct&lt;char, true&gt;&gt;(loc);
foo(f.curr_symbol()); // OK：f 内部使用了到仍存在的 locale 对象的引用。
}}

===示例===
{{example
|显示用户偏好的本地环境所用的 3 位字母金额名：
|code=
#include &lt;iostream&gt;
#include &lt;locale&gt;

int main()
{
    for (const char* name: {"en_US.UTF-8", "de_DE.UTF-8", "en_GB.UTF-8"})
        std::cout &lt;&lt; "你的金额字符串是 "
                  &lt;&lt; std::use_facet&lt;std::moneypunct&lt;char, true&gt;&gt;(std::locale{name}).
                     curr_symbol() &lt;&lt; '\n';
}
|output=
你的金额字符串是 USD
你的金额字符串是 EUR
你的金额字符串是 GBP
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=31|std=C++98|before=返回的引用在该本地环境值存在的期间保持合法|after=返回的引用在有引用该平面的本地环境对象存在的期间保持合法}}
{{dr list item|wg=lwg|dr=38|std=C++98|before={{tt|Facet}} 不需要有直接成员 {{ttb|id}}|after=需要}}
{{dr list item|wg=lwg|dr=436|std=C++98|before=不明确 {{tt|Facet}} 是否可以有 cv 限定|after=可以有 const 限定，但不能有 volatile 限定}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/locale/dsc locale}}
{{dsc inc|cpp/locale/dsc has_facet}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}