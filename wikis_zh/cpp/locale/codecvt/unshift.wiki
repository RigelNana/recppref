{{cpp/locale/codecvt/title|unshift, do_unshift}}
{{cpp/locale/codecvt/navbar}}
{{dcl begin}}
{{dcl header|locale}}
{{dcl|num=1|1=
public:
result unshift( StateT&amp; state, ExternT* to, ExternT* to_end,
                ExternT*&amp; to_next ) const;
}}
{{dcl|num=2|1=
protected:
virtual result do_unshift( StateT&amp; state, ExternT* to, ExternT* to_end,
                           ExternT*&amp; to_next ) const;
}}
{{dcl end}}

@1@ 公开成员函数，调用最终派生类的成员函数 {{tt|do_unshift}}。

@2@ 如果此 {{tt|codecvt}} 刻面表示的编码依赖状态，并且 {{c|state}} 表示的转换状态不是初始迁移状态，那么写入返回初始迁移状态所需的字符。字符被写入首元素为 {{c|to}} 所指向的字符数组。不写入多于 {{c|to_end - to}} 个字符。更新参数 {{c|to_next}} 以指向最后写入字符的后一位置。

===返回值===
{{lc|std::codecvt_base::result}} 类型的值，指示成功状况如下：
{{dsc begin}}
{{dsc|{{tt|ok}}|已写入所有所需字符。{{c|state}} 现在表示初始迁移状态}}
{{dsc|{{tt|partial}}|输出缓冲区中空间不足。{{c|1=to_next == to_end}}}}
{{dsc|{{tt|error}}|发生了一个未指明的错误}}
{{dsc|{{tt|noconv}}|编码不依赖状态，不需要终止序列}}
{{dsc end}}

===注解===
{{lc|std::basic_filebuf::close()}} 会调用此函数，在终止化依赖状态的多字节序列的情形中也会调用此函数。

===示例===
{{example
|
|code=
|output=
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=305|std=C++98|before={{c/core|std::codecvt&lt;wchar_t, char, std::mbstate_t&gt;::do_unshift}} 要求不写入任何字符|after=不再要求}}
{{dr list item|wg=lwg|dr=380|std=C++98|before=返回 {{c|partial}} 的含义是“需要提供更多字符以完成终止”，但是没有提供任何字符|after=改成表示缓冲区空间不足}}
{{dr list item|wg=lwg|dr=381|std=C++98|before={{c|state}} 不需要合法，在 {{c|state}} 不合法时返回 {{c|error}}|after={{c|state}} 需要合法，返回&lt;br&gt;{{c|error}} 表示有错误发生}}
{{dr list item|wg=lwg|dr=664|std=C++98|before={{c/core|std::codecvt&lt;char, char, std::mbstate_t&gt;::do_unshift}} 要求不写入任何字符|after=不再要求}}
{{dr list item|wg=lwg|dr=665|std=C++98|before={{c/core|std::codecvt&lt;char, char, std::mbstate_t&gt;::do_unshift}} 要求返回 {{c|noconv}}|after=不再要求}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/string/multibyte/dsc wcrtomb}}
{{dsc inc|cpp/locale/codecvt/dsc do_out}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}