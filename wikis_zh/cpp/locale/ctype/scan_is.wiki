{{cpp/locale/ctype/title|scan_is|do_scan_is}}
{{cpp/locale/ctype/navbar}}
{{dcl begin}}
{{dcl header|locale}}
{{dcl|num=1|1=
public:
const CharT* scan_is( mask m, const CharT* beg, const CharT* end ) const;
}}
{{dcl|num=2|1=
protected:
virtual const CharT* do_scan_is( mask m, const CharT* beg, const CharT* end) const;
}}
{{dcl end}}

@1@ 公开成员函数，调用最终派生类的受保护虚成员函数 {{tt|do_scan_is}。
@2@ 定位字符数组 {{range|beg|end}} 中满足分类掩码 {{c|m}} 的首个字符，即首个使得 {{c|is(m, c)}} 会返回 {{c|true}} 的字符 {{c|c}}。

===参数===
{{par begin}}
{{par|m|要搜索的掩码}}
{{par|beg|指向要搜索的数组中首字符的指针}}
{{par|end|指向要搜索的数组尾后一位置的指针}}
{{par end}}

===返回值===
指向 {{range|beg|end}} 中首个满足掩码的字符的指针，如果找不到这种字符就返回 {{c|end}}。

===示例===
{{example
|code=
#include &lt;clocale&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;locale&gt;

int main()
{
    std::setlocale(LC_ALL, "en_US.utf8");
    std::wcout.imbue(std::locale("en_US.utf8"));
    auto&amp; f = std::use_facet&lt;std::ctype&lt;wchar_t&gt;&gt;(std::wcout.getloc());
    
    // 跳过首个字母之前
    wchar_t s1[] = L"      \t\t\n  Кошка";
    const wchar_t* p1 = f.scan_is(std::ctype_base::alpha, std::begin(s1), std::end(s1));
    std::wcout &lt;&lt; "'" &lt;&lt; p1 &lt;&lt; "'\n";
    
    // 跳过首个字母之前
    wchar_t s2[] = L"123456789ネプネプ";
    const wchar_t* p2 = f.scan_is(std::ctype_base::alpha, std::begin(s2), std::end(s2));
    std::wcout &lt;&lt; "'" &lt;&lt; p2 &lt;&lt; "'\n";
}
|output=
'Кошка'
'ネプネプ'
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=152|std=C++98|before={{tt|do_scan_is}} 的效果提到了 {{c|is(m)}}，但 {{ltt|cpp/locale/ctype/is}} 没有这样的重载|after=改成 {{c|is(m, c)}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/locale/ctype_char/dsc scan_is}}
{{dsc inc|cpp/locale/ctype/dsc do_scan_not}}
{{dsc end}}

{{langlinks|en|ja}}