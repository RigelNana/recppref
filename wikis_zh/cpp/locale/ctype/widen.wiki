{{cpp/locale/ctype/title|widen, do_widen}}
{{cpp/locale/ctype/navbar}}
{{dcl begin}}
{{dcl header|locale}}
{{dcl|num=1|1=
public:
CharT widen( char c ) const;
}}
{{dcl|num=2|1=
public:
const char* widen( const char* beg, const char* end, CharT* dst ) const;
}}
{{dcl|num=3|1=
protected:
virtual CharT do_widen( char c ) const;
}}
{{dcl|num=4|1=
protected:
virtual const char* do_widen( const char* beg, const char* end, CharT* dst ) const;
}}
{{dcl end}}

@1,2@ 公开成员函数，调用最终派生类的受保护虚成员函数 {{tt|do_widen}} 的对应重载。重载 (1) 会调用 {{c|do_widen(c)}}，重载 (2) 会调用 {{c|do_widen(beg, end, dst)}}。
@3@ 用最简单的合理变换将单字节字符 {{c|c}} 转换到对应的宽字符。这典型地仅应用于多字节编码为单字节的字符（例如 UTF-8 中的 U+0000-U+007F）。
@4@ 对字符数组 {{range|beg|end}} 中每个字符，写入对应的加宽字符到 {{c|dst}} 所指向的字符数组中的相继位置。

加宽始终返回宽字符，但只保证来自{{rev inl|until=c++23|[[cpp/language/charset#基本源字符集|基本源字符集]]}}{{rev inl|since=c++23|[[cpp/language/charset#基本字符集|基本字符集]]}}的字符拥有唯一良好定义的加宽变换，它也保证是可逆的（通过 {{lc|narrow()}}）。实践中，所有多字节表示为单字节的字符通常都被加宽为其宽字符对应，而剩下的可能单字节值通常被映射为同一占位值，典型地为 {{c|CharT(-1)}}。

如果加宽有意义，那么保持 {{lc|is()}} 所知的所有字符分类类别。

===参数===
{{par begin}}
{{par|c|要转换的字符}}
{{par|dflt|转换失败时产生的默认值}}
{{par|beg|指向要转换的字符数组中首字符的指针}}
{{par|end|指向要转换的字符数组的尾后一位置的指针}}
{{par|dst|指向要填充的字符数组首元素的指针}}
{{par end}}

===返回值===
@1,3@ 加宽的字符
@2,4@ {{c|end}}

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;locale&gt;

void try_widen(const std::ctype&lt;wchar_t&gt;&amp; f, char c)
{
    wchar_t w = f.widen(c);
    std::cout &lt;&lt; "单字节字符 " &lt;&lt; +(unsigned char)c
              &lt;&lt; " 加宽为 " &lt;&lt; +w &lt;&lt; '\n';
}
 
int main()
{
    std::locale::global(std::locale("cs_CZ.iso88592"));
    auto&amp; f = std::use_facet&lt;std::ctype&lt;wchar_t&gt;&gt;(std::locale());
    std::cout &lt;&lt; std::hex &lt;&lt; std::showbase &lt;&lt; "在捷克语 ISO-8859-2 本地环境下：\n";
    try_widen(f, 'a');
    try_widen(f, '\xdf'); // ISO-8859-2 中的德文字母 ß (U+00df)
    try_widen(f, '\xec'); // ISO-8859-2 中的捷克文字母 ě (U+011b)
 
    std::locale::global(std::locale("cs_CZ.utf8"));
    auto&amp; f2 = std::use_facet&lt;std::ctype&lt;wchar_t&gt;&gt;(std::locale());
    std::cout &lt;&lt; "在捷克语 UTF-8 本地环境下：\n";
    try_widen(f2, 'a');
    try_widen(f2, '\xdf'); 
    try_widen(f2, '\xec'); 
}
|output=
在捷克语 ISO-8859-2 本地环境下：
单字节字符 0x61 加宽为 to 0x61
单字节字符 0xdf 加宽为 to 0xdf
单字节字符 0xec 加宽为 to 0x11b
在捷克语 UTF-8 本地环境下：
单字节字符 0x61 加宽为 to 0x61
单字节字符 0xdf 加宽为 to 0xffffffff
单字节字符 0xec 加宽为 to 0xffffffff
}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=153|std=C++98|before={{tt|widen}} 只会调用重载 (4)|after=会调用对应重载}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/locale/ctype/dsc narrow}}
{{dsc inc|cpp/io/basic_ios/dsc widen}}
{{dsc inc|cpp/string/multibyte/dsc btowc}}
{{dsc end}}

{{langlinks|en|ja}}