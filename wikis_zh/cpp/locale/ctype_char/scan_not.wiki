{{cpp/locale/ctype_char/title|scan_not}}
{{cpp/locale/ctype/navbar}}
{{dcl begin}}
{{dcl header|locale}}
{{dcl|1=
const char* scan_not( mask m, const char* beg, const char* end ) const;
}}
{{dcl end}}

在字符数组 {{range|beg|end}} 中定位不满足分类掩码 {{c|m}} 的首个字符，即满足 {{c|table()[(unsigned char) c] &amp; m}} 会返回 {{c|false}} 的首个 {{tt|c}}。

若 {{c|(unsigned char)c &gt;{{=}} std::ctype&lt;char&gt;::table_size}}，则以实现定义值取代 {{c|table()[(unsigned char)c]}}，对于 {{c|c}} 的不同值可能有所不同。

===参数===
{{par begin}}
{{par|m|要搜索的掩码}}
{{par|beg|指向要搜索的字符数组中首字符的指针}}
{{par|end|要搜索的字符数组的尾后一位置指针}}
{{par end}}

===返回值===
指向 {{range|beg|end}} 中首个不满足掩码的字符的指针，或若找不到这种字符则为 {{c|end}}。

===注解===
不同于主模板 {{c|std::ctype}}，此特化在分类字符时不进行虚函数调用。为定制其行为，派生类可向基类构造函数提供非默认的分类表。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;locale&gt;

int main()
{
    auto&amp; f = std::use_facet&lt;std::ctype&lt;char&gt;&gt;(std::locale());

    // 跳过前导空白符
    char s1[] = "      \t\t\n  Test";
    const char* p1 = f.scan_not(std::ctype_base::space, std::begin(s1), std::end(s1));
    std::cout &lt;&lt; "'" &lt;&lt; p1 &lt;&lt; "'\n";

    // 跳过前导数位
    char s2[] = "123456789abcd";
    const char* p2 = f.scan_not(std::ctype_base::digit, std::begin(s2), std::end(s2));
    std::cout &lt;&lt; "'" &lt;&lt; p2 &lt;&lt; "'\n";
}
|output=
'Test'
'abcd'
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/locale/ctype/dsc do_scan_not}}
{{dsc inc|cpp/locale/ctype_char/dsc scan_is}}
{{dsc end}}

{{langlinks|en|ja}}