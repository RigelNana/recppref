{{cpp/named req/title|Predicate}}
{{cpp/named req/navbar}}

{{named req|Predicate}}要求描述了返回{{named req|BooleanTestable}}值的{{named req|Callable}}类型。

{{named req|Predicate}}常与接收输入数据（单个对象/容器）和谓词的算法一起使用，它会针对输入数据进行调用以决定进一步的动作。C++ 标准库中的一些使用谓词的例子有：

* {{lc|std::all_of}}、{{lc|std::any_of}}、{{lc|std::none_of}}  接收一组元素和一个谓词为其输入。在每个输入元素上调用谓词，并且当谓词分别对全部/任一/无元素返回 true 时返回 true。

* {{lc|std::find_if}}  接受元素的序列和一个谓词。返回序列中首个谓词对其返回 {{c|true}} 的元素。

{{small|上面给出的算法设施描述是简陋的，并且有意地简要解释{{named req|Predicate}}。对于详细信息可查阅各自的页面。}}

换言之，若算法接收一个{{named req/core|Predicate}} {{tt|pred}} 和一个迭代器 {{tt|first}}，则它应该有能力经由类似 {{c|if(pred(*first)) { /*...*/ }&lt;!----&gt;}} 的语言构造，对迭代器 {{tt|first}} 所指向类型的对象进行测试。

函数对象 {{tt|pred}} 不应当通过解引用的迭代器运用任何非 const 函数，且必须接受一个 {{tt|const}} 实参，无论实参是 {{tt|const}} 还是非 {{tt|const}} 都具有相同的行为。此函数对象可以是函数指针，或者拥有适合的函数调用运算符的类型的对象。

===要求===
* {{named req|FunctionObject}}

{{todo|更好地描述实际要求}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3031|std=C++98|before=const 值上的要求不充分|after=加强要求}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/concepts/dsc predicate}}
{{dsc end}}

{{langlinks|en|es|ja}}