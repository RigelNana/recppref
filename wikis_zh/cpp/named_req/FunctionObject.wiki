{{cpp/named req/title|FunctionObject}}
{{cpp/named req/navbar}}

{{named req|FunctionObject}}类型是可用在函数调用运算符左侧的对象的类型。

===要求===

若满足下列条件，则类型 {{tt|T}} 满足{{named req/core|FunctionObject}}

* 类型 {{tt|T}} 满足 {{lc|std::is_object}}，且

给定
* {{tt|T}} 或 {{tt|const T}} 类型的值 {{tt|f}}
* {{tt|args}}，为适合的实参列表，可以为空

则下列表达式必须合法：

{|table class=wikitable
|-
!表达式||要求
|-
| {{c|1=f(args)}}
| 进行函数调用
|}

===注解===
函数和到函数的引用不是函数对象类型，但因为函数到指针[[cpp/language/implicit_conversion|隐式转换]]，它们能用在期待函数对象类型的地方。

===标准库===
* 所有[[cpp/language/pointer#函数指针|函数指针]]都满足此要求。
* 所有定义于 {{header|functional}} 的函数对象。
* 某些 {{header|functional}} 的函数的返回类型。

===示例===
{{example
|展示不同类型的函数对象。
|code=
#include &lt;functional&gt;
#include &lt;iostream&gt;

void foo(int x) { std::cout &lt;&lt; "foo(" &lt;&lt; x &lt;&lt; ")\n"; }
void bar(int x) { std::cout &lt;&lt; "bar(" &lt;&lt; x &lt;&lt; ")\n"; }

int main()
{
    void(*fp)(int) = foo;
    fp(1); // 使用函数指针调用 foo

    std::invoke(fp, 2); // 所有 FunctionObject 类型都 Callable

    auto fn = std::function(foo); // 另见 &lt;functional&gt; 的其余部分
    fn(3);
    fn.operator()(3); // 与 fn(3) 效果相同

    struct S
    {
        void operator()(int x) const { std::cout &lt;&lt; "S::operator(" &lt;&lt; x &lt;&lt; ")\n"; }
    } s;
    s(4); // 调用 s.operator()
    s.operator()(4); // 与 s(4) 相同

    auto lam = [](int x) { std::cout &lt;&lt; "lambda(" &lt;&lt; x &lt;&lt; ")\n"; };
    lam(5); // 调用 lambda
    lam.operator()(5); // 与 lam(5) 相同

    struct T
    {
        using FP = void (*)(int);
        operator FP() const { return bar; }
    } t;
    t(6); // t 可转换为函数指针
    static_cast&lt;void (*)(int)&gt;(t)(6); // 与 t(6) 相同
    t.operator T::FP()(6); // 与 t(6) 相同&lt;!-- operator FP() might be allowed by the standard but not all compilers accept it. See: p1787r6 --&gt;
}
|output=
foo(1)
foo(2)
foo(3)
foo(3)
S::operator(4)
S::operator(4)
lambda(5)
lambda(5)
bar(6)
bar(6)
bar(6)
}}

===参阅===
{{dsc begin}}
{{dsc named req|cpp/named req/Callable|定义了调用操作的类型}}
{{dsc end}}

{{langlinks|en|es|ja|ru}}