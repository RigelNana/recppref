{{cpp/named req/title|Container}}
{{cpp/named req/navbar}}

{{named req|Container}}是用于存储其他对象并负责管理那些对象使用的内存的对象。

===要求===
给定以下类型和值：
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc|{{tt|T}}|对象类型}}
{{dsc|{{tt|C}}|包含 {{tt|T}} 类型对象的容器类}}
{{dsc hitem|值|定义}}
{{dsc|{{c|u}}, {{c|v}}|{{tt|C}} 或 {{c/core|const C}} 类型的值}}
{{dsc|{{c|mv}}|{{tt|C}} 类型的值}}
{{dsc|{{c|cv}}|{{c/core|const C}} 类型的值}}
{{dsc|{{c|lhs}}，{{c|rhs}}|{{tt|C}} 类型的左值}}
{{dsc|{{c|i}}，{{c|j}}|{{tt|C::iterator}} 或 {{c/core|const C::iterator}} 类型的值}}
{{dsc end}}

{{tt|C}} 在以下类型，语句和表达式都良构并具有指定的语义时满足{{named req/core|Container}}：

====类型====
{|class="wikitable"
!类型
!定义
!要求
|-
|{{c/core|typename C::value_type}}
|{{tt|T}}
|{{tt|T}} {{rev inl|until=c++11|{{named req|CopyConstructible}}}}{{rev inl|since=c++11|从 {{tt|C}} {{named req|Erasable}}}}。
|-
|{{c/core|typename C::reference}}
|{{tt|T&amp;}}
|rowspan=2 {{n/a|无显式要求}}
|-
|{{c/core|typename C::const_reference}}
|{{c/core|const T&amp;}}
|-
|{{c/core|typename C::iterator}}
|迭代器类型
|
* {{tt|C::iterator}} 是{{named req|ForwardIterator}}，并且它的[[cpp/iterator#类型与可写性|值类型]] 是 {{tt|T}}。
* {{tt|C::iterator}} 可以转换到 {{tt|C::const_iterator}}。
|-
|{{c/core|typename C::const_iterator}}
|常迭代器类型
|{{tt|C::const_iterator}} 是{{named req|ForwardIterator}}，并且它的[[cpp/iterator#类型与可写性|值类型]] 是 {{tt|T}}。
|-
|{{c/core|typename C::difference_type}}
|style="word-break: keep-all;"|有符号整数类型{{nbsp}}
|{{tt|C::difference_type}} 与 {{tt|C::iterator}} 和 {{tt|C::const_iterator}} 的[[cpp/iterator#类型与可写性|差类型]]相同。
|-
|{{c/core|typename C::size_type}}
|无符号整数类型
|{{tt|C::size_type}} 足以表示 {{tt|C::difference_type}} 的所有非负值。
|}

====语句====
{|class="wikitable"
!语句
!colspan=2|语义
!style="word-break: keep-all;"|{{nbsp}}复杂度{{nbsp}}
|-
|{{c|C c;}}

{{c|1=C c = C();}}
|style="word-break: keep-all;"|后条件{{nbsp}}
|{{c|c.empty()}} 是 {{c|true}}。
|常数
|-
|rowspan=2|{{c|C c(v);}}

{{c|1=C c = C(v);}}
|前条件
|{{rrev|since=c++11|如果 {{c|v}} 不是 {{tt|C}} 类型右值，那么 {{tt|T}} {{named req|CopyInsertable}}到 {{tt|C}} 中。}}
|rowspan=2|线性&lt;ref&gt;如果 {{c|v}} 是 {{tt|C}} 类型右值，并且 {{tt|C}} 不是 {{lc|std::array}} 或 {{ltt std|cpp/container/inplace_vector}} 的特化，那么复杂度是常数。&lt;/ref&gt;
|-
|后条件
|
* 如果 {{c|v}} 是左值，那么 {{c|1=c == v}} 是 {{c|true}}.
* 如果 {{c|v}} 是右值{{rev inl|since=c++11|，并且 {{c|c}} 和 {{c|v}} 表示不同对象}}，那么 {{c|c}} 等于 {{c|v}} 在本次构造之前的值。
|-
!colspan=4|注解
|-
|colspan=4|&lt;references/&gt;
|}

====表达式====
{|class="wikitable"
!表达式
!类型
!colspan=2|语义
!style="word-break: keep-all;"|{{nbsp}}复杂度{{nbsp}}
|-
|{{c|C()}}
|{{tt|C}}
|style="word-break: keep-all;"|后条件{{nbsp}}
|{{c|C().empty()}} 是 {{c|true}}。
|常数
|-
|rowspan=2|{{c|C(v)}}
|rowspan=2|{{tt|C}}
|前条件
|{{rrev|since=c++11|如果 {{c|v}} 不是 {{tt|C}} 类型右值，那么 {{tt|T}} {{named req|CopyInsertable}}到 {{tt|C}} 中。}}
|rowspan=2|常数&lt;ref&gt;如果 {{c|v}} 是 {{tt|C}} 类型右值，并且 {{tt|C}} 是 {{lc|std::array}} 或 {{ltt std|cpp/container/inplace_vector}} 的特化，那么复杂度是线性。&lt;/ref&gt;
|-
|后条件
|
* 如果 {{c|v}} 是左值，那么 {{c|1=C(v) == v}} 是 {{c|true}}。
* 如果 {{c|v}} 是右值{{rev inl|since=c++11|，并且 {{c|C(v)}} 和 {{c|v}} 表示不同对象}}，那么 {{c|C(v)}} 等于 {{c|v}} 在本次构造之前的值。
|-
|{{c|1=lhs = v}}
|{{tt|C&amp;}}
|后条件
|
* 如果 {{c|v}} 是左值，那么 {{c|1=lhs == v}} 是 {{c|true}}。
* 如果 {{c|v}} 是右值{{rev inl|since=c++11|，并且 {{c|lv}} 和 {{c|v}} 表示不同对象}}，那么 {{c|lhs}} 等于 {{c|v}} 在本次赋值之前的值。
|线性
|-
|{{c|v.~C()}}
|{{c/core|void}}
|效果
|销毁 {{c|v}} 的所有元素并解分配所有获取到的内存。
|线性
|-
|{{c|mv.begin()}}
|{{tt|C::iterator}}
|效果
|返回指向 {{c|mv}} 的首元素的迭代器。
|常数
|-
|{{c|cv.begin()}}
|{{tt|C::const_iterator}}
|效果
|返回指向 {{c|cv}} 的首元素的迭代器。
|常数
|-
|{{c|mv.end()}}
|{{tt|C::iterator}}
|效果
|返回 {{c|mv}} 的尾后迭代器。
|常数
|-
|{{c|cv.end()}}
|{{tt|C::const_iterator}}
|效果
|返回 {{c|cv}} 的尾后迭代器。
|常数
|-
|{{c|v.cbegin()}}&lt;br&gt;{{mark since c++11}}
|{{tt|C::const_iterator}}
|效果
|返回 {{c|const_cast&lt;const C&amp;&gt;(v).begin()}}，
|常数
|-
|{{c|v.cend()}}&lt;br&gt;{{mark since c++11}}
|{{tt|C::const_iterator}}
|效果
|返回 {{c|const_cast&lt;const C&amp;&gt;(v).end()}}，
|常数
|-
|{{c|1=i &lt;=&gt; j}}&lt;br&gt;{{mark since c++20}}
|{{ltt std|cpp/utility/compare/strong_ordering}}{{nbsp|4}}
|约束
|此表达式只要求在 {{tt|C::iterator}} 满足随机访问迭代器时良构。
|常数
|-
|{{c|1=u == v}}
|{{c/core|bool}}
|效果
|返回 {{rev begin}}
{{rev|until=c++14|{{c multi|u.size() {{==}} v.size() &amp;&amp;|    std::equal(u.begin(),|         u.end(), v.begin())}}}}
{{rev|since=c++14|{{c multi|std::equal(u.begin(), u.end(),|           v.begin(), v.end())}}}}
{{rev end}}。
|线性&lt;ref&gt;如果 {{c|1=u.size() != v.size()}} 是 {{c|true}}，那么复杂度是常数。&lt;/ref&gt;
|-
|{{c|1=u != v}}
|
|效果
|等价于 {{c|1=!(u == v)}}。
|-
|{{c|lhs.swap(rhs)}}

{{c|swap(lhs, rhs)}}
|{{c/core|void}}
|效果
|交换 {{c|lhs}} 与 {{c|rhs}} 的内容。
|常数&lt;ref&gt;如果 {{tt|C}} 是 {{lc|std::array}} 或 {{ltt std|cpp/container/inplace_vector}} 的特化，那么复杂度是线性。&lt;/ref&gt;
|-
|{{c|v.size()}}
|{{tt|C::size_type}}
|效果
|返回 {{c|v}} 的元素数量。&lt;ref&gt;元素数量由构造函数，插入和擦除的规则定义。它等于 {{c|std::distance(v.begin(), v.end())}} 的值。&lt;/ref&gt;
|常数
|-
|{{c|v.max_size()}}
|{{tt|C::size_type}}
|效果
|返回可能存在的最大 {{tt|C}} 类型容器的元素数量。
|常数
|-
|{{c|v.empty()}}
|{{c/core|bool}}
|效果
|返回 {{c|1=v.begin() == v.end()}}。
|常数
|-
!colspan=5|可选容器要求{{anchor|可选容器要求}}&lt;br&gt;{{normal|{{small|（仅对某些类型的容器提供）}}}}
|-
|rowspan=2|{{c|1=u &lt;=&gt; v}}&lt;br&gt;{{mark since c++20}}
|rowspan=2|{{lti|cpp/standard library/synth-three-way|synth-three-way-result}}&lt;br&gt;{{nbspt|4}}{{c/core|&lt;C::value_type&gt;}}
|前条件
|要么 {{tt|T}} 实现 {{lconcept|three_way_comparable}}，要么 {{c/core|operator&lt;}} 是一种对 {{tt|T}} 和 {{c/core|const T}} 类型的值定义的全序关系。
|rowspan=2|线性
|-
|效果
|返回 {{box|{{c/core|std::lexicographical_compare_three_way}}&lt;br&gt;{{nbspt|4}}{{c/core|(u.begin(), u.end(),}}&lt;br&gt;{{nbspt|5}}{{c/core|v.begin(), v.end(),}}&lt;br&gt;{{nbspt|5}}{{lti|cpp/standard library/synth-three-way}}{{sep}}{{c/core|)}}}}&lt;ref&gt;如果传递给 {{lc|std::lexicographical_compare_three_way}} 的迭代器是{{named req|ConstexprIterator}}，那么操作会由 {{c/core|constexpr}} 函数实现。&lt;/ref&gt;。
|-
!colspan=5|注解
|-
|colspan=5|&lt;references/&gt;
|}

在表达式 {{c|1=i == j}}、{{c|1=i != j}}、{{c|i &lt; j}}、{{c|1=i &lt;= j}}、{{c|1=i &gt;= j}}、{{c|i &gt; j}} 和 {{c|i - j}} 中，如果 {{c|i}} 和/或 {{c|j}} 分别被替换为指向相同元素的 {{tt|C::const_iterator}} 类型迭代器，那么语义保持不变。

===容器数据竞争===
见[[cpp/container#线程安全|容器线程安全]]。

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=179|std=C++98|before={{tt|iterator}} 与 {{tt|const_iterator}} 类型可能不可比较|after=要求可比较}}
{{dr list item|wg=lwg|dr=276|std=C++98|before={{tt|T}} 要求 {{named req|CopyAssignable}}|after={{tt|T}} 要求 {{named req|CopyConstructible}}}}
{{dr list item|wg=lwg|dr=322|std=C++98|before=未指定 {{tt|iterator}} 与 {{tt|const_iterator}} 的值类型|after=指定为 {{tt|T}}}}
{{dr list item|wg=lwg|dr=774|std=C++98|before=对 {{c|swap(a, b)}} 没有要求|after=已补充}}
{{dr list item|wg=lwg|dr=883|std=C++98|before={{c|a.swap(b)}} 被定义为 {{c|swap(a, b)}}，导致循环定义|after=定义为交换 {{c|a}} 和 {{c|b}} 的值}}
{{dr list item|wg=lwg|dr=1319|std=C++98|before={{tt|iterator}} 和 {{tt|const_iterator}} 不一定有多趟保证|after=它们需要满足&lt;br&gt;{{named req|ForwardIterator}}}}
{{dr list item|wg=lwg|dr=2114|paper=P2167R3|std=C++98|before=曾允许某些函数的非 {{c/core|bool}} 返回类型|after=已禁止}}
{{dr list item|wg=lwg|dr=2182|std=C++98|before={{tt|reference}} 和 {{tt|const_reference}} 表示的类型未被良好指定|after=改进用词}}
{{dr list item|wg=lwg|dr=2257|std=C++98|before=两个容器即使大小不同也需要线性时间比较相等|after=此时只需要常数时间}}
{{dr list item|wg=lwg|dr=2263|std=C++11|before={{lwg|179}} 的解决方案在 C++11 中被意外丢弃|after=已恢复}}
{{dr list item|wg=lwg|dr=2839|std=C++11|before=不允许标准容器的自移动赋值|after=容许但结果未指定}}
{{dr list item|paper=N3346|std=C++11|before={{tt|C::value_type}} 要求{{named req|Destructible}}|after=要求从 {{tt|C}} {{named req|Erasable}}}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc see cpp|cpp/container|容器库|nomono=true}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}