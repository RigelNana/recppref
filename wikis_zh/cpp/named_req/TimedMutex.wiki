{{cpp/named req/title|TimedMutex|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}

{{named req|TimedMutex}}要求扩展了{{named req|TimedLockable}}要求，以包含线程间同步。

===要求===

* {{named req|TimedLockable}}
* {{named req|Mutex}}

另外，对于{{named req/core|TimedMutex}}类型的对象 {{ttb|m}}。
* 表达式 {{c|m.try_lock_for(duration)}} 拥有下列性质
:* 表现为原子操作。
:* 尝试在 {{tt|duration}} 所指定的时长内获得互斥体的排他所有权。若 {{tt|duration}} 小于或等于 {{tt|duration.zero()}}，则尝试获得所有权而不阻塞（如同用 {{tt|try_lock()}}）。否则，此函数将阻塞直至得到互斥体，或直至经过 {{tt|duration}} 所指定的时长。它仅若成功才在 {{tt|duration}} 内返回，但允许获得互斥体失败，即使在 {{tt|duration}} 期间的某点，互斥体不为另一线程所占有也可能如此。任何情况下，若得到互斥体则返回 {{c|true}}，否则返回 {{c|false}}。
:* 若 {{tt|try_lock_for(duration)}} 成功，则同一对象上先前的 {{tt|unlock()}} 操作''同步于''此操作（等价于释放-获得 {{lc|std::memory_order}}）。
:* 若调用方线程已占有互斥体，则行为未定义（除非 {{tt|m}} 是 {{lc|std::recursive_timed_mutex}}）。
:* 执行期间时钟、时间点或时长可能抛出异常（标准库提供的时钟、时间点及时长决不抛出）。
* 表达式 {{c|m.try_lock_until(time_point)}} 拥有下列性质
:* 表现为原子操作。
:* 尝试在到 {{tt|time_point}} 为止的剩余时间内获得互斥体的排他所有权。若已经过 {{tt|time_point}}，则尝试获得所有权而不阻塞（如同用 {{tt|try_lock()}}）。否则，此函数将阻塞直至得到互斥体，或直至经过 {{tt|time_point}} 所指定的时间点。它仅若成功才在 {{tt|time_point}} 前返回，但允许获得互斥体失败，即使在 {{tt|time_point}} 前的某点，互斥体不为另一线程所占有也可能如此。任何情况下，若得到互斥体则返回 {{c|true}}，否则返回 {{c|false}}。
:* 若 {{tt|try_lock_until(time_point)}} 成功，则同一对象上先前的 {{tt|unlock()}} 操作''同步于''此操作（等价于释放-获得 {{lc|std::memory_order}}）。
:* 若调用方线程已占有互斥体，则行为未定义（除非 {{tt|m}} 是 {{lc|std::recursive_timed_mutex}}）。
:* 执行期间时钟、时间点或时长可能抛出异常（标准库提供的时钟、时间点及时长决不抛出）。

===标准库===
下列标准库类型满足{{named req/core|TimedMutex}}：
{{dsc begin}}
{{dsc inc|cpp/thread/dsc recursive_timed_mutex}}
{{dsc inc|cpp/thread/dsc shared_timed_mutex}}
{{dsc inc|cpp/thread/dsc timed_mutex}}
{{dsc end}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2093|std=C++11|before=规范中缺失超时相关异常|after=已提及}}
{{dr list end}}

===参阅===
* [[cpp/thread|线程支持库]]
* {{named req|TimedLockable}}
* {{named req|Mutex}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}