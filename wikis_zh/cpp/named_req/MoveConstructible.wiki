{{cpp/named req/title|MoveConstructible|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}

指定该类型的实例可以从一个[[cpp/language/value_category|右值]]实参构造。

===要求===
以下情况下，类型 {{tt|T}} 满足{{named req/core|MoveConstructible}}：

给定
* {{tt|T}} 类型的[[cpp/language/value_category|右值表达式]] {{tt|rv}}
* 任意标识符 {{tt|u}}

下列表达式必须合法且拥有其指定的效果。

{|table class=wikitable
|-
!表达式||后条件
|-
| {{c|1=T u = rv;}}
|{{tt|u}} 的值等于 {{tt|rv}} 在初始化前的值。{{tt|rv}} 的新值未指明。
|-
| {{c|T(rv)}}
|{{tt|T(rv)}} 的值等于 {{tt|rv}} 在初始化前的值。{{tt|rv}} 的新值未指明。
|}

===注解===
类不必为满足此要求而实现[[cpp/language/move constructor|移动构造函数]]：接收 {{tt|const T&amp;}} 实参的[[cpp/language/copy constructor|复制构造函数]]也能绑定右值表达式。

若{{named req/core|MoveConstructible}}类实现了移动构造函数，则它亦可实现[[cpp/utility/move|移动语义]]，以从“构造后 {{tt|rv}} 的值未指明”的事实中获利。

{{cot}}

作为{{named req/core|MoveConstructible}}的类蕴含 {{lc|std::is_move_constructible}}，但反之不然，因为 {{lc|std::is_move_constructible}} 仅检查以正确实参调用构造函数的能力，而不检查后条件的值。

{{example
|code=
#include &lt;iostream&gt;

struct S
{
    int n;
    S(int in) : n{in} {}
    S(S&amp;&amp; other) { n = other.n + 1; }
};
static_assert(std::is_move_constructible_v&lt;S&gt;);

int main()
{
    S v{1};
    std::cout &lt;&lt; "v.n = " &lt;&lt; v.n &lt;&lt; '\n';
    S u = std::move(v);

    // 类 `S` 并不满足可移动构造（MoveConstructible）的要求
    // `u` 的值*并不*等价于 `v` 在初始化 `u` 之前的值
    std::cout &lt;&lt; "u.n = " &lt;&lt; u.n &lt;&lt; '\n';
}
|output=
v.n = 1
u.n = 2
}}
{{cob}}

===引用===
{{cot}}
{{ref std c++23}}
{{ref std|section=16.4.4.2|title=Template argument requirements|id=utility.arg.requirements}}
{{ref std end}}
{{cob}}

===参阅===
{{dsc begin}}
{{dsc inc | cpp/types/dsc is_move_constructible}}
{{dsc inc | cpp/concepts/dsc move_constructible}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}