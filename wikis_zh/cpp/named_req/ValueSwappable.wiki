{{cpp/named req/title|ValueSwappable|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}
此类型的两个对象可以解引用，且在 {{lc|std::swap}} 和用户定义的 {{c|swap()}} 均可见的语境中，其结果值可以用无限定的函数调用 {{c|swap()}} 进行交换。

===要求===
以下情况下，类型 T 为{{named req/core|ValueSwappable}}:

# 类型 {{tt|T}} 满足{{named req|Iterator}}。
# 对 {{tt|T}} 类型的任何可解引用对象 {{tt|x}}（即并非尾迭代器的值），{{tt|*x}} 满足{{named req|Swappable}}。

许多标准库函数均期待其实参满足{{named req/core|ValueSwappable}}，这意味着凡在标准库进行交换时，都使用 {{c|using std::swap; swap(*iter1, *iter2);}} 的等价物。

===示例===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;vector&gt;

class IntVector
{
    std::vector&lt;int&gt; v;
//  IntVector&amp; operator=(IntVector); // 不可赋值（C++98 的方式）
public:
    IntVector&amp; operator=(IntVector) = delete; // 不可赋值
    void swap(IntVector&amp; other)
    {
        v.swap(other.v);
    }
};

void swap(IntVector&amp; v1, IntVector&amp; v2)
{
    v1.swap(v2);
}

int main()
{
    IntVector v1, v2;    // IntVector 为可交换 (Swappable)，但非可移动赋值 (MoveAssignable)
    IntVector* p1 = &amp;v1;
    IntVector* p2 = &amp;v2; // IntVector* 为值可交换 (ValueSwappable)
    std::iter_swap(p1, p2); // OK：iter_swap 要求值可交换 (ValueSwappable)
//  std::swap(v1, v2); // 编译器错误！std::swap 要求可移动赋值 (MoveAssignable)
}
}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc indirectly_swappable}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}