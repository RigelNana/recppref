{{cpp/named req/title|MoveInsertable|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}

指定该类型的对象能以给定的分配器，从一个该类型的右值构造到未初始化存储之中。

===要求===
给定以下类型、值和表达式：
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc|{{tt|T}}|对象类型}}
{{dsc|{{tt|A}}|分配器类型}}
{{dsc|{{tt|X}}|满足以下所有条件的容器类型：
* {{tt|X::value_type}} 与 {{tt|T}} 相同。
* {{tt|X::allocator_type}} 与 {{c/core|std::allocator_traits&lt;A&gt;::rebind_alloc&lt;T&gt;}} 相同。
}}
{{dsc hitem|值|定义}}
{{dsc|{{c|m}}|{{tt|A}} 类型左值}}
{{dsc|{{c|p}}|{{tt|T*}} 类型指针}}
{{dsc hitem|表达式|定义}}
{{dsc|{{c|rv}}|表示 {{tt|T}} 类型右值的表达式}}
{{dsc|{{c|expr}}|{{c|std::allocator_traits&lt;A&gt;::construct(m, p, rv)}}}}
{{dsc end}}

如果满足以下所有条件，那么 {{tt|T}} {{named req|CopyInsertable}}到 {{tt|X}} 中：
* {{c|expr}} 良构。
* 在对 {{c|expr}} 求值完成时，{{c|*p}} 的值等价于 {{c|rv}} 在这次求值前的值。

===注解===
如果 {{tt|A}} 是 {{c/core|std::allocator&lt;T&gt;}}，那么就会如同用 {{rev inl|until=c++20|{{c|::new((void*)p) T(rv)}}}}{{rev inl|since=c++20|{{c|std::construct_at(p, rv)}}}} 调用布置 {{c/core|new}}。这相当于要求 {{tt|T}} 可移动构造。

如果使用了 {{c/core|std::allocator&lt;T&gt;}} 或类似的分配器，那么该类不必为满足此类型要求而实现[[cpp/language/move constructor|移动构造函数]]：接收 {{c/core|const T&amp;}} 实参的[[cpp/language/copy constructor|复制构造函数]]能绑定右值表达式。如果{{named req/core|MoveInsertable}}的类实现了移动构造函数，那么它可能亦实现[[cpp/utility/move|移动语义]]以利用“构造后 {{c|rv}} 的值未指明”的事实。

尽管 C++23 前要求在构造 {{lc|std::basic_string}} 的元素时使用定制的 {{tt|construct}}，但所有实现都使用默认机制。{{wg21|P1072R10}} 更正了该要求以匹配既存实践。

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2177|std=C++11|before=对 {{c|expr}} 进行求值没有任何后条件|after=添加后条件}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc|{{named req|CopyInsertable}}}}
{{dsc end}}

{{langlinks|de|es|en|ja|ru}}