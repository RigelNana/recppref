{{cpp/named req/title|EmplaceConstructible|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}

指定该类型的对象能以给定的分配器从给定的一组实参构造到未初始化存储之中。

===要求===
以下情况下，类型 {{ttb|T}} 为从实参 {{ttb|args}} {{named req|EmplaceConstructible}}进{{named req|Container|容器}} {{ttb|X}}（其 {{tt|value_type}} 等同于 {{tt|T}}）：给定
{{dsc begin}}
{{dsc | {{ttb|A}} |具分配器类型}}
{{dsc | {{ttb|m}} |{{ttb|A}} 类型的左值}}
{{dsc | {{ttb|p}} |容器所准备的 {{ttb|T*}} 类型的指针}}
{{dsc | {{ttb|args}} |零或更多实参}}
{{dsc end}}

其中 {{ttb|X::allocator_type}} 等同于 {{c|std::allocator_traits&lt;A&gt;::rebind_alloc&lt;T&gt;}}，

下列表达式良构：

{{source|
std::allocator_traits&lt;A&gt;::construct(m, p, args);
}}

若 {{ttb|X}} 非知分配器或为 {{lc|std::basic_string}} 特化，则如同 {{ttb|A}} 就是 {{lc|std::allocator&lt;T&gt;}} 一样进行定义，但并不需要创建分配器对象，且不会实例化用户定义的 {{lc|std::allocator}} 的特化。

===注解===
尽管 C++23 前要求在构造 {{lc|std::basic_string}} 的元素时使用定制的 {{tt|construct}}，所有实现都使用默认机制。{{wg21|P1072R10}} 更正了该要求以匹配既存实现。

===参阅===
{{dsc begin}}
{{dsc | {{named req|CopyInsertable}} }}
{{dsc | {{named req|MoveInsertable}} }}
{{dsc end}}

{{langlinks|de|es|en|ja|ru}}