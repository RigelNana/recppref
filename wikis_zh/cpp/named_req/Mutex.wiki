{{cpp/named req/title|Mutex|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}

{{named req|Mutex}}要求扩展了{{named req|Lockable}}要求以包含线程间同步。

===要求===

* {{named req|Lockable}}
* {{named req|DefaultConstructible}}
* {{named req|Destructible}}
* 不可复制
* 不可移动

对于{{named req/core|Mutex}}类型的对象 {{ttb|m}}：
* 表达式 {{c|m.lock()}} 具有下列性质
:* 表现为原子操作。
:* 阻塞调用方线程，直到能获得互斥体的排他性所有权为止。
:* 同一互斥体上先前的 {{c|m.unlock()}} 操作''同步于''此锁定操作（等价于释放-获得 {{lc|std::memory_order}} ）。
:* 若调用方线程已占有互斥体，则行为未定义（除非 m 是 {{lc|std::recursive_mutex}} 或 {{lc|std::recursive_timed_mutex}}）。
:* 错误时可能抛出 {{lc|std::system_error}} 类型的异常，拥有下例错误码：
::* 若调用方线程无要求的权限，则为 {{lc|std::errc::operation_not_permitted}}
::* 若实现检测出此线程将导致死锁，则为 {{lc|std::errc::resource_deadlock_would_occur}}
* 表达式 {{c|m.try_lock()}} 具有下列性质
:* 表现为原子操作。
:* 试图为调用方线程获得互斥体的排他性所有权，而不阻塞。若未获得所有权则立即返回。允许此函数虚假地失败并返回，即使互斥当前未被另一线程所占有。
:* 若 {{tt|try_lock()}} 成功，则同一对象上先前的 {{tt|unlock()}} 操作''同步于''此操作（等价于释放-获得 {{lc|std::memory_order}}）。{{tt|lock()}} 不与失败的 {{tt|try_lock()}} 同步。
:* 不抛异常。
* 表达式 {{c|m.unlock()}} 具有下列性质
:* 表现为原子操作。
:* 释放调用方线程对互斥体的所有权，并''同步于''同一对象上的后继的成功锁定操作。
:* 若调用方线程不占有互斥体，则行为未定义。
:* 不抛异常。
* 单个互斥体上的所有锁定和解锁操作在一个单独全序中发生，并能被视为一个原子变量的[[cpp/atomic/memory_order#修改顺序|修改顺序]]：此顺序特定于此单独互斥体。

===标准库===
下列标准库类型满足{{named req/core|Mutex}}：
{{dsc begin}}
{{dsc inc|cpp/thread/dsc mutex}}
{{dsc inc|cpp/thread/dsc recursive_mutex}}
{{dsc inc|cpp/thread/dsc recursive_timed_mutex}}
{{dsc inc|cpp/thread/dsc shared_mutex}}
{{dsc inc|cpp/thread/dsc shared_timed_mutex}}
{{dsc inc|cpp/thread/dsc timed_mutex}}
{{dsc end}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2309|std=C++11|before={{tt|lock}} 可以抛出错误码为 {{lc|std::errc::device_or_resource_busy}} 的 {{lc|std::system_error}}|after=不允许}}
{{dr list end}}

===参阅===
* [[cpp/thread|线程支持库]]
* {{named req|Lockable}}
* {{named req|TimedMutex}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}