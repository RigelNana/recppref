{{cpp/named req/title|SequenceContainer}}
{{cpp/named req/navbar}}

{{named req|SequenceContainer}}是在线性排列中存储相同类型对象的{{named req|Container}}。

===要求===
给定以下类型和值：
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc|{{tt|C}}|序列容器类}}
{{dsc|{{tt|T}}|{{tt|C}} 的元素类型}}
{{dsc|{{tt|A}}|{{tt|C}} 的分配器类型：
* 在 {{tt|C::allocator_type}} 存在时是该类型，
* 否则是 {{c/core|std::allocator&lt;T&gt;}}}}
{{dsc|{{tt|R}} {{mark since c++23}}|实现了 {{lti|cpp/ranges/to#container compatible range|container-compatible-range}}{{sep}}{{tt|&lt;T&gt;}} 的类型}}
{{dsc|{{tt|Args}} {{mark since c++11}}|模板形参包}}
{{dsc|{{tt|Ref}}|{{tt|C::reference}}}}
{{dsc|{{tt|CRef}}|{{tt|C::const_reference}}}}
{{dsc hitem|值|定义}}
{{dsc|{{c|v}}|{{tt|C}} 类型的值}}
{{dsc|{{c|cv}}|{{c/core|const C}} 类型的值}}
{{dsc|{{c|i}}，{{c|j}}|{{named req|InputIterator}}，{{range|i|j}} 是[[cpp/iterator#范围|有效范围]]，并且这些迭代器所指代的元素可隐式转换到 {{tt|C::value_type}}}}
{{dsc|{{c|rg}} {{mark since c++23}}|{{tt|R}} 类型的值}}
{{dsc|{{c|il}} {{mark since c++11}}|{{c/core|std::initializer_list&lt;value_type&gt;}} 类型的值}}
{{dsc|{{c|n}}|{{tt|C::size_type}} 类型的值}}
{{dsc|{{c|p}}|到 {{c|v}} 中的有效[[cpp/iterator|常量迭代器]]}}
{{dsc|{{c|q}}|到 {{c|v}} 中的[[cpp/iterator#可解引用性与有效性|有效可解引用]]常量迭代器}}
{{dsc|{{c|q1}}，{{c|q2}}|到 {{c|v}} 中的两个常量迭代器，使得 {{range|q1|q2}} 是有效范围}}
{{dsc|{{c|t}}|{{tt|C::value_type}} 类型的{{rev inl|until=c++11|值}}{{rev inl|since=c++11|[[cpp/language/value category|左值]]或 const 右值}}}}
{{dsc|{{c|rv}} {{mark since c++11}}|{{tt|C::value_type}} 类型的非 const 右值}}
{{dsc|{{c|args}} {{mark since c++11}}|模式为 {{tt|Args&amp;&amp;}} 的函数形参包}}
{{dsc end}}

在满足以下所有条件时，{{tt|C}} 是{{named req/core|SequenceContainer}}：
* 类型 {{tt|C}} 满足{{named req|Container}}的要求。
* 以下语句和表达式都良构并具有指定的语义：

&lt;div style="max-width: 100%; max-height: 80vh; overflow-y: scroll; margin: 1em 0;"&gt;
{|class=wikitable style="margin: 0;"
|-style="position: sticky; top: 0;"
!colspan=4 style="font-size: 16px; line-height: 16px;"|基本要求&lt;br&gt;{{normal|{{small|（{{rev inl|since=c++11|除 {{lc|std::array}} 之外的}}所有[[#标准库|标准库]]序列容器都需要满足）}}}}

|-
!colspan=2|语句
!colspan=2|{{nbsp|4}}语义&lt;ref&gt;对于效果等价于其他操作的表达式，在表格中列出的条件的基础上也会继承那些操作中的表达式的条件。&lt;/ref&gt;

|-
|rowspan=3 colspan=2|{{c|C c(n, t);}}
|效果
|构造保有 {{c|n}} 个 {{c|t}} 的副本的序列容器。
|-
|style="word-break: keep-all;"|前条件{{nbsp}}
|
{{rrev|since=c++11|
{{tt|T}} {{named req|CopyInsertable}}到 {{tt|C}} 中。
}}
|-
|后条件
|{{c|std::distance(c.begin(), c.end())}} 是 {{c|n}}。

|-
|rowspan=3 colspan=2|{{c|C c(i, j);}}
|效果
|构造与范围 {{range|i|j}} 逐元素相等的序列容器。
* 范围 {{range|i|j}} 中的每个迭代器都只会恰好解引用一次。
|-
|前条件
|
{{rrev|since=c++11|
{{tt|T}} 从 {{c|*i}} {{named req|EmplaceConstructible}}到 {{tt|C}} 中。
}}
|-
|后条件
|{{c|std::distance(c.begin(), c.end())}} 是 {{c|std::distance(i, j)}}。

|-
!表达式
!style="word-break: keep-all;"|{{nbsp}}类型{{nbsp}}
!colspan=2|语义

|-
|rowspan=3|{{small|{{c|C(std::from_range, rg)}}}}&lt;br&gt;{{mark since c++23}}
|rowspan=3|{{tt|C}}
|效果
|构造与范围 {{c|rg}} 逐元素相等的序列容器。
* 范围 {{c|rg}} 中的每个迭代器都只会恰好解引用一次。
|-
|前条件
|{{tt|T}} 从 {{c|*ranges::begin(rg)}} {{named req|EmplaceConstructible}}到 {{tt|C}} 中。
|-
|后条件
|{{c|std::distance(begin(), end())}} 是 {{c|ranges::distance(rg)}}。
|-
|{{c|C(il)}}&lt;br&gt;{{mark since c++11}}
|{{tt|C}}
|colspan=2|等价于 {{c|C(il.begin(), il.end())}}。

|-
|rowspan=4|{{c|1=v = il}}&lt;br&gt;{{mark since c++11}}
|rowspan=4|{{tt|C&amp;}}
|效果
|将 {{c|il}} 所表示的范围赋值到 {{c|a}} 中。&lt;ref&gt;{{lc|std::array}} 支持从[[cpp/language/initialization|花括号包围的初始化器列表]]赋值，但不支持从 {{lc|std::initializer_list}} 赋值。&lt;/ref&gt;
|-
|返回值
|{{c|*this}}
|-
|前条件
|{{tt|T}} {{named req|CopyInsertable}}到 {{tt|C}} 中，并且{{named req|CopyAssignable}}。
|-
|后条件
|{{c|v}} 的既存元素要么被销毁，要么被赋值。

|-
|rowspan=3|{{c|v.emplace(p, args)}}&lt;br&gt;{{mark since c++11}}
|rowspan=3|{{tt|Iter}}{{nbsp}}
|效果
|在 {{c|p}} 前插入以 {{c|std::forward&lt;Args&gt;(args)...}} 构造的 {{tt|T}} 类型对象。
|-
|返回值
|指向由 {{c|args}} 构造到 {{c|v}} 中的元素的迭代器。
|-
|前条件
|{{tt|T}} 从 {{c|args}} {{named req|EmplaceConstructible}}到 {{tt|C}} 中。

|-
|rowspan=3|{{c|v.insert(p, t)}}
|rowspan=3|{{tt|Iter}}
|效果
|在 {{c|p}} 前插入 {{c|t}} 的副本。
|-
|返回值
|指向插入到 {{c|v}} 中的 {{c|t}} 的副本的迭代器。
|-
|前条件
|
{{rrev|since=c++11|
{{tt|T}} {{named req|CopyInsertable}}到 {{tt|C}} 中。
}}

|-
|rowspan=3|{{c|v.insert(p, rv)}}&lt;br&gt;{{mark since c++11}}
|rowspan=3|{{tt|Iter}}
|效果
|在 {{c|p}} 前插入 {{c|rv}} 的副本，可能使用移动语义。
|-
|返回值
|指向插入到 {{c|a}} 中的 {{c|rv}} 的副本的迭代器。
|-
|前条件
|{{tt|T}} {{named req|MoveInsertable}}到 {{tt|C}} 中。

|-
|rowspan=3|{{c|v.insert(p, n, t)}}
|rowspan=3|{{tt|Iter}}
|效果
|在 {{c|p}} 前插入 {{c|n}} 个 {{c|t}} 的副本。
|-
|返回值
|指向插入到 {{c|v}} 中的首元素的副本的迭代器（在 {{c|n}} 是 {{c|0}} 时返回 {{c|p}}）。
|-
|前条件
|
{{rrev|since=c++11|
{{tt|T}} {{named req|CopyInsertable}}到 {{tt|C}} 中，并且{{named req|CopyAssignable}}。
}}

|-
|rowspan=3|{{c|v.insert(p, i, j)}}
|rowspan=3|{{tt|Iter}}
|效果
|在 {{c|p}} 前插入 {{range|i|j}} 中元素的副本。
* 范围 {{range|i|j}} 中的每个迭代器都只会恰好解引用一次。
|-
|返回值
|指向插入到 {{c|v}} 中的首元素的副本的迭代器（在 {{c|1=i == j}} 是 {{c|true}} 时返回 {{c|p}}）。
|-
|前条件
|
{{rrev|since=c++11|
* {{tt|T}} 从 {{c|*i}} {{named req|EmplaceConstructible}}到 {{tt|C}} 中。
}}
* {{c|i}} 和 {{c|j}} 都不在 {{c|v}} 中。

|-
|rowspan=3|{{small|{{c|v.insert_range(p, rg)}}}}&lt;br&gt;{{mark since c++23}}
|rowspan=3|{{tt|Iter}}
|效果
|在 {{c|p}} 前插入 {{c|rg}} 中元素的副本。
* 范围 {{c|rg}} 中的每个迭代器都只会恰好解引用一次。
|-
|返回值
|指向插入到 {{c|v}} 中的首元素的副本的迭代器（在 {{c|rg}} 为空时返回 {{c|p}}）。
|-
|前条件
|
* {{tt|T}} 从 {{c|*ranges::begin(rg)}} {{named req|EmplaceConstructible}}到 {{tt|C}} 中。
* {{c|rg}} 和 {{c|v}} 不重叠。

|-
|{{c|v.insert(p, il)}}&lt;br&gt;{{mark since c++11}}
|{{tt|Iter}}
|colspan=2|等价于 {{c|v.insert(p, il.begin(), il.end())}}。

|-
|rowspan=2|{{c|v.erase(q)}}
|rowspan=2|{{tt|Iter}}
|效果
|擦除 {{c|q}} 指向的元素。
|-
|返回值
|指向擦除前紧跟 {{c|q}} 之后的元素的迭代器（在此类元素不存在时返回 {{c|v.end()}}）。

|-
|rowspan=2|{{c|v.erase(q1, q2)}}
|rowspan=2|{{tt|Iter}}
|效果
|擦除 {{range|q1|q2}} 中的元素。
|-
|返回值
|指向在任何元素被擦除前 {{c|q2}} 曾指向的元素（在此类元素不存在时返回 {{c|v.end()}}）。

|-
|rowspan=3|{{c|v.clear()}}
|rowspan=3|{{c/core|void}}
|效果
|销毁 {{c|v}} 中的所有元素。
* 指代 {{c|v}} 中的元素的所有引用、指针和迭代器都会失效，尾后迭代器也可能会失效。
|-
|后条件
|{{c|v.empty()}} 是 {{c|true}}。
|-
|复杂度
|线性。

|-
|rowspan=2|{{c|v.assign(i, j)}}
|rowspan=2|{{c/core|void}}
|效果
|以 {{range|i|j}} 的副本替换 {{c|v}} 中的元素。
* 指代 {{c|v}} 中的元素的所有引用、指针和迭代器都会失效。
* 范围 {{range|i|j}} 中的每个迭代器都只会恰好解引用一次。
|-
|前条件
|
{{rrev|since=c++11|
* {{tt|T}} 从 {{c|*i}} {{named req|EmplaceConstructible}}到 {{tt|C}} 中。
* {{tt|T}} 可从 {{c|*i}} 赋值。
}}
* {{c|i}} 和 {{c|j}} 都不在 {{c|v}} 中。

|-
|rowspan=2|{{c|v.assign_range(rg)}}&lt;br&gt;{{mark since c++23}}
|rowspan=2|{{c/core|void}}
|效果
|以 {{c|rg}} 中每个元素的副本替换 {{c|v}} 中的元素。
* 如果 {{box|{{co|std::assignable_from}}&lt;br&gt;{{nbspt|4}}{{co|&lt;T&amp;, ranges::range_reference_t&lt;R&gt;&gt;}}}} 没有得到实现，那么程序非良构。
* 指代 {{c|v}} 中的元素的所有引用、指针和迭代器都会失效。
* 范围 {{c|rg}} 中的每个迭代器都只会恰好解引用一次。
|-
|前条件
|
* {{tt|T}} 从 {{c|*ranges::begin(rg)}} {{named req|EmplaceConstructible}}到 {{tt|C}} 中。
* {{c|rg}} 和 {{c|v}} 不重叠。

|-
|{{c|v.assign(il)}}&lt;br&gt;{{mark since c++11}}
|{{c/core|void}}
|colspan=2|等价于 {{c|v.assign(il.begin(), il.end())}}。

|-
|rowspan=2|{{c|v.assign(n, t)}}
|rowspan=2|{{c/core|void}}
|效果
|用 {{c|t}} 的 {{c|n}} 个副本替换 {{c|v}} 中的元素。
|-
|前条件
|
{{rrev|since=c++11|
{{tt|T}} {{named req|CopyInsertable}}到 {{tt|C}} 中，并且{{named req|CopyAssignable}}。
}}

|-style="position: sticky; top: 0;"
!colspan=4 style="font-size: 16px; line-height: 16px;"|{{nbsp|4}}额外操作&lt;ref&gt;{{rev inl|since=c++23|除 {{tt|prepend_range}} 和 {{tt|append_range}} 的}}以下所有操作都会在均摊常数时间内完成。&lt;/ref&gt;&lt;br&gt;{{normal|{{small|（只有指定的容器需要满足，省略 {{tt|std::}}）}}}}

|-
!表达式
!{{nbsp}}类型{{nbsp}}
!colspan=2|语义

|-
|rowspan=2|{{c|v.front()}}
|rowspan=2|{{tt|Ref}}
|容器
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}, {{lt|cpp/container/forward_list}}}}
|-
|返回值
|{{c|*v.begin()}}

|-
|rowspan=2|{{c|cv.front()}}
|rowspan=2|{{tt|CRef}}
|容器
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}, {{lt|cpp/container/forward_list}}}}
|-
|返回值
|{{c|*cv.begin()}}

|-
|rowspan=2|{{c|v.back()}}
|rowspan=2|{{tt|Ref}}
|容器
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}}}
|-
|colspan=2|等价于 {{c|1=auto tmp = v.end(); --tmp; return *tmp;}}&lt;ref&gt;在 C++98 中，{{c|tmp}} 被声明为具有 {{tt|C::iterator}} 类型。&lt;/ref&gt;。

|-
|rowspan=2|{{c|cv.back()}}
|rowspan=2|{{tt|CRef}}
|容器
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}}}
|-
|colspan=2|等价于 {{c|1=auto tmp = cv.end(); --tmp; return *tmp;}}&lt;ref&gt;在 C++98 中，{{c|tmp}} 被声明为具有 {{tt|C::const_iterator}} 类型。&lt;/ref&gt;。

|-
|rowspan=4|{{c|v.emplace_front(args)}}&lt;br&gt;{{mark since c++11}}
|rowspan=4|{{c/core|void}}
|容器
|{{tt|{{lt|cpp/container/deque}}, {{lt|cpp/container/list}}, {{lt|cpp/container/forward_list}}}}
|-
|效果
|前附一个以 {{c|std::forward&lt;Args&gt;(args)...}} 构造的 {{tt|T}} 类型对象。
|-
|返回值
|{{c|v.front()}}
|-
|前条件
|{{tt|T}} 从 {{c|args}} {{named req|EmplaceConstructible}} 到 {{tt|C}} 中。

|-
|rowspan=4|{{c|v.emplace_back(args)}}&lt;br&gt;{{mark since c++11}}
|rowspan=4|{{c/core|void}}
|容器
|{{tt|{{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}}}
|-
|效果
|后附一个以 {{c|std::forward&lt;Args&gt;(args)...}} 构造的 {{tt|T}} 类型对象。
|-
|返回值
|{{c|v.back()}}
|-
|前条件
|{{tt|T}} 从 {{c|args}} {{named req|EmplaceConstructible}} 到 {{tt|C}} 中。

|-
|rowspan=3|{{c|v.push_front(t)}}
|rowspan=3|{{c/core|void}}
|容器
|{{tt|{{lt|cpp/container/deque}}, {{lt|cpp/container/list}}, {{lt|cpp/container/forward_list}}}}
|-
|效果
|前附 {{c|t}} 的一个副本。
|-
|前条件
|
{{rrev|since=c++11|
{{tt|T}} {{named req|CopyInsertable}}到 {{tt|C}} 中。
}}

|-
|rowspan=3|{{c|v.push_front(rv)}}&lt;br&gt;{{mark since c++11}}
|rowspan=3|{{c/core|void}}
|容器
|{{tt|{{lt|cpp/container/deque}}, {{lt|cpp/container/list}}, {{lt|cpp/container/forward_list}}}}
|-
|效果
|前附 {{c|rv}} 的一个副本，可能用移动语义。
|-
|前条件
|{{tt|T}} {{named req|MoveInsertable}}到 {{tt|C}} 中。

|-
|rowspan=3|{{c|v.prepend_range(rg)}}&lt;br&gt;{{mark since c++23}}
|rowspan=3|{{c/core|void}}
|容器
|{{tt|{{lt|cpp/container/deque}}, {{lt|cpp/container/list}}, {{lt|cpp/container/forward_list}}}}
|-
|效果
|在 {{c|v.begin()}} 前插入&lt;ref name="range"&gt;插入顺序就是 {{c|rg}} 中元素的顺序，不是逆序。&lt;/ref&gt; {{c|rg}} 中的元素的副本。
* 范围 {{c|rg}} 中的每个迭代器都只会恰好解引用一次。
|-
|前条件
|{{tt|T}} 从 {{c|*ranges::begin(rg)}} 可{{named req|EmplaceConstructible}}到 {{tt|C}} 中。

|-
|rowspan=3|{{c|v.push_back(t)}}
|rowspan=3|{{c/core|void}}
|容器
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}}}
|-
|效果
|后附 {{c|t}} 的一个副本。
|-
|前条件
|
{{rrev|since=c++11|
{{tt|T}} {{named req|CopyInsertable}}到 {{tt|C}} 中。
}}

|-
|rowspan=3|{{c|v.push_back(rv)}}&lt;br&gt;{{mark since c++11}}
|rowspan=3|{{c/core|void}}
|容器
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}}}
|-
|效果
|后附 {{c|rv}} 的一个副本，可能用移动语义。
|-
|前条件
|{{tt|T}} {{named req|MoveInsertable}}到 {{tt|C}} 中。

|-
|rowspan=3|{{c|v.append_range(rg)}}&lt;br&gt;{{mark since c++23}}
|rowspan=3|{{c/core|void}}
|容器
|{{tt|{{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}}}
|-
|效果
|在 {{c|v.begin()}} 前插入&lt;ref name="range"/&gt; {{c|rg}} 中的元素的副本。
* 范围 {{c|rg}} 中的每个迭代器都只会恰好解引用一次。
|-
|前条件
|{{tt|T}} 从 {{c|*ranges::begin(rg)}} 可{{named req|EmplaceConstructible}}到 {{tt|C}} 中。

|-
|rowspan=3|{{c|v.pop_front()}}
|rowspan=3|{{c/core|void}}
|容器
|{{tt|{{lt|cpp/container/deque}}, {{lt|cpp/container/list}}, {{lt|cpp/container/forward_list}}}}
|-
|效果
|销毁首元素。
|-
|前条件
|{{c|a.empty()}} 是 {{c|false}}。

|-
|rowspan=3|{{c|v.pop_back()}}
|rowspan=3|{{c/core|void}}
|容器
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}}}
|-
|效果
|销毁最末元素。
|-
|前条件
|{{c|a.empty()}} 是 {{c|false}}。

|-
|rowspan=2|{{c|v[n]}}
|rowspan=2|{{tt|Ref}}
|容器
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}}}
|-
|colspan=2|等价于 {{c|return *(v.begin() + n);}}。

|-
|rowspan=2|{{c|cv[n]}}
|rowspan=2|{{tt|CRef}}
|容器
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}}}
|-
|colspan=2|等价于 {{c|return *(cv.begin() + n);}}。

|-
|rowspan=3|{{c|v.at(n)}}
|rowspan=3|{{tt|Ref}}
|容器
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}}}
|-
|返回值
|{{c|*(v.begin() + n)}}
|-
|异常
|在 {{c|1=n &gt;= v.size()}} 是 {{c|true}} 时抛出 {{lc|std::out_of_range}}。

|-
|rowspan=3|{{c|cv.at(n)}}
|rowspan=3|{{tt|CRef}}
|容器
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}}}
|-
|返回值
|{{c|*(cv.begin() + n)}}
|-
|异常
|在 {{c|1=n &gt;= v.size()}} 是 {{c|true}} 时抛出 {{lc|std::out_of_range}}。

|-
!colspan=4|注解
|-
|colspan=4|&lt;references/&gt;
|}
&lt;/div&gt;

{{todo|Add bits from {{stddoc|P2846}} for (sequence) [containers]}}

另外，对于每个序列容器：
* 对于接收两个输入迭代器的构造函数模板，以及成员函数 {{tt|insert()}}、{{tt|append()}}、{{tt|assign()}}、{{tt|replace()}} 的接受两个输入迭代器的模板重载，如果相应的模板实参不是{{named req|InputIterator}}，那么它们不会参与重载决议。
{{rrev|since=c++17|
* 对于拥有 {{named req|InputIterator}} 或 {{tt|Allocator}} 模板形参的推导指引，如果该形参推导出的类型（分别）不是输入迭代器或分配器，那么它们不会参与重载决议。
}}

===标准库===
下列标准库字符串类型和容器均满足{{named req/core|SequenceContainer}}：
{{dsc begin}}
{{dsc inc|cpp/string/dsc basic_string}}
{{dsc inc|cpp/container/dsc array}}
{{dsc inc|cpp/container/dsc vector}}
{{dsc inc|cpp/container/dsc inplace_vector}}
{{dsc inc|cpp/container/dsc deque}}
{{dsc inc|cpp/container/dsc forward_list}}
{{dsc inc|cpp/container/dsc list}}
{{dsc end}}

====使用备注====
{|class="wikitable" style="text-align: center;"
!容器
!优点
!缺点
|-
|{{lc|std::vector}}
|快速访问，连续存储
|大多情况的插入/删除低效
|-
|{{lc|std::inplace_vector}}
|快速访问，原位连续存储
|容量固定且大多情况的插入/删除低效
|-
|{{lc|std::array}}
|快速访问，原位连续存储
|元素数量固定且不支持插入/删除
|-
|{{lc|std::deque}}
|快速访问，可在序列首/尾高效地插入/删除
|序列中部的插入/删除低效
|-
|{{lc|std::list}}&lt;br&gt;{{lc|std::forward_list}}
|在序列中部可高效地插入/删除
|访问效率大多为线性时间
|}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=139|std=C++98|before=在指定的容器上也不需要实现可选操作|after=需要以均摊常数时间实现}}
{{dr list item|wg=lwg|dr=149|std=C++98|before={{c|v.insert(p, t)}} 返回 {{tt|Iter}}，但
{{c|v.insert(p, n, t)}} 和 {{c|v.insert(p, n, t)}} 返回 {{c/core|void}}|after=都返回 {{tt|Iter}}}}
{{dr list item|wg=lwg|dr=151|std=C++98|before=要求 {{c|q1}} 可解引用&lt;ref&gt;它是缺陷的原因是它会导致在空容器 {{c|v}} 上调用 {{c|v.erase(v.begin(), v.end())}} 的行为未定义。&lt;/ref&gt;|after=它不需要可解引用}}
{{dr list item|wg=lwg|dr=355|std=C++98|before=调用 {{c|v.back()}} 或 {{c|v.pop_back()}} 会执行危险&lt;ref&gt;如果 {{c|v.end()}} 具有基础类型，那么 {{c|--v.end()}} 非良构。当 {{c|v}} 时模板化类型的时候这个操作就变成了危险操作，它会在 {{c|v}} 的类型从非基础类型变成基础类型的时候导致编译失败，并且难以排查。&lt;/ref&gt;的操作 {{c|--v.end()}}|after=改成自减 {{c|v.end()}} 的副本}}
{{dr list item|wg=lwg|dr=589|std=C++98|before={{c|i}} 和 {{c|j}} 指代的对象不一定可转换到 {{tt|C::value_type}}|after=这些对象可以隐式转换到&lt;br&gt;{{tt|C::value_type}}}}
{{dr list item|wg=lwg|dr=2194|std=C++11|before={{lc|std::queue}}、{{lc|std::priority_queue}} 和&lt;br&gt;{{lc|std::stack}} 也是{{named req/core|SequenceContainer}}&lt;ref&gt;它们在 C++98 中没有被记载为{{named req/core|SequenceContainer}}。&lt;/ref&gt;|after=它们不是&lt;br&gt;{{named req/core|SequenceContainer}}}}
{{dr list item|wg=lwg|dr=2231|std=C++11|before=C++11 中错误地省略了 {{c|v.clear()}} 的复杂度要求|after=重申复杂度为线性}}
{{dr list item|wg=lwg|dr=3927|std=C++98|before={{c/core|operator[]}} 没有隐式要求|after=添加隐式要求}}
{{dr list end}}
&lt;references/&gt;

{{langlinks|de|en|es|fr|it|ja|pt|ru}}