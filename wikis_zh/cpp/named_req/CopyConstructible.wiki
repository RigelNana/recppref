{{cpp/named req/title|CopyConstructible}}
{{cpp/named req/navbar}}

指定该类型的实例可以从[[cpp/language/value_category|左值表达式]]进行复制构造。

===要求===
以下情况下，类型 {{tt|T}} 满足{{named req/core|CopyConstructible}}：

* 类型 {{tt|T}} 满足{{named req|MoveConstructible}}，且

给定
* {{c|v}}，{{tt|T}} 或 {{c/core|const T}} 类型的[[cpp/language/value category#左值|左值]]表达式或 {{c/core|const T}} 类型的[[cpp/language/value category#右值|右值]]表达式
* 任意标识符 {{c|u}}

下列表达式必须合法且拥有指定的效果：
{|table class=wikitable
|-
!表达式||后条件
|-
| {{c|1=T u = v;}}
|{{c|u}} 的值等价于 {{c|v}} 的值。不更改 {{c|v}} 的值。
|-
| {{c|T(v)}}
|{{c|T(v)}} 的值等价于 {{c|v}} 的值。不更改 {{c|v}} 的值。
|}

{{rrev|until=c++11|
表达式 {{c|v.~T()}} 也必须合法，且对于左值 {{c|v}}，表达式 {{c|&amp;v}} 必须具有 {{tt|T*}} 或 {{c/core|const T*}} 类型，且必须求值为 {{c|v}} 的地址。
}}

===注解===
C++11 前，重载了 {{c/core|operator&amp;}} 的类不满足{{named req/core|CopyConstructible}}，从而不可用于标准库容器。这是 C++98 的设计决定（而不是缺陷，见 {{lwg|390}}）。

C++11 开始，标准库在凡是需要对象地址时都会使用 {{lc|std::addressof}}。

{{cot}}

作为{{named req/core|CopyConstructible}}类模板蕴含 {{lc|std::is_copy_constructible}}，但反之不然，因为 {{lc|std::is_copy_constructible}} 仅检查以正确实参调用构造函数的能力，而非诸如{{named req|MoveConstructible}}的要求。

{{example
|code=
#include &lt;type_traits&gt;
#include &lt;utility&gt;

struct S
{
    S() = default;
    S(S&amp;&amp;) = delete;
    S(const S&amp;) = default;
};
static_assert(std::is_copy_constructible_v&lt;S&gt;);

int main()
{
    S s1;

    // 类 `S` 并不满足可移动构造（MoveConstructible）的要求，
    // 因而并不满足可复制构造（CopyConstructible）的要求
    [[maybe_unused]] S s2{std::move(s1)}; // 非良构，使用了弃置的函数
}
}}
{{cob}}

===引用===
{{cot}}
{{ref std c++23}}
{{ref std|section=16.4.4.2|title=Template argument requirements|id=utility.arg.requirements}}
{{ref std end}}
{{cob}}

===参阅===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_copy_constructible}}
{{dsc inc|cpp/concepts/dsc copy_constructible}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}