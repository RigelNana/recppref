{{cpp/named req/title|RangeAdaptorClosureObject|notes={{mark since c++20}}}}
{{cpp/named req/navbar}}

''范围适配器闭包对象'' 是可以通过管道运算符调用的{{named req|FunctionObject}}：若 {{c|C}} 是范围适配器闭包对象且 {{c|R}} 是一种 {{lconcept|range}}，则下列两个表达式[[cpp/language/expressions#表达式等价|等价]]：
{{source|1=
C(R)
R {{!}} C
}}

两个范围适配器闭包对象可以用 {{c|operator{{!}}}} 连接起来以产生另一个范围适配器闭包对象：若 {{c|C}} 与 {{c|D}} 为范围适配器闭包对象，则 {{c|C {{!}} D}} 产生范围适配器闭包对象 {{c|E}} 并具有如下性质：

* {{c|E}} 存储 {{c|C}} 和 {{c|D}} 的副本，分别按照 {{c|std::forward&lt;decltype((C))&gt;(C)}} 和 {{c|std::forward&lt;decltype((D))&gt;(D)}} 直接非列表初始化而来。如果这样的初始化非法，则 {{c|C {{!}} D}} 亦非法。
* 令 {{c|c}} 和 {{c|d}} 为存储的副本（具有同 {{c|E}} 一样的常量性和值类别），且令 {{c|R}} 是 {{lconcept|range}} 对象，则如下表达式是[[cpp/language/expressions#表达式等价|等价]]的：
{{source|1=
d(c(R))
R {{!}} c {{!}} d
E(R)
R {{!}} E // R {{!}} (C {{!}} D)
}}

注意：范围适配器闭包类型的 volatile 限定或 const-volatile 限定版本不支持 {{c|operator()}}。

和如下之一对象类型一致（忽略 cv-限定）的对象是范围适配器闭包对象：
* 一元范围适配器对象，
{{rrev|since=c++23|
* 具有满足[[cpp/ranges/range_adaptor_closure|实现范围适配器闭包对象的要求]]的用户自定义类型的对象，
}}
* 通过范围适配器对象绑定尾随实参的结果，以及
* 使用 {{c|operator{{!}}}} 串联的两个范围适配器闭包对象的结果。

===参阅===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc range_adaptor_closure}}
{{dsc end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}