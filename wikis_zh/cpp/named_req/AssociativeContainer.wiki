{{cpp/named req/title|AssociativeContainer}}
{{cpp/named req/navbar}}

{{named req|AssociativeContainer}}是提供基于键的快速对象查找的{{named req|Container}}。

对于每个键都只能包含最多一个元素的关联容器支持''唯一键''，其他关联容器支持''等价键''。

===要求===
{{dsc begin}}
{{dsc h2|Legend}}
{{dsc|{{tt|X}}|一种关联容器类}}
{{dsc|{{tt|T}}|{{tt|X}} 的元素类型}}
{{dsc|{{tt|A}}|{{tt|X}} 的分配器类型：若存在则为 {{tt|X::allocator_type}}，否则为 {{c/core|std::allocator&lt;X::value_type&gt;}}}}
{{dsc|{{c|a}}|{{tt|X}} 类型的值}}
{{dsc|{{c|a2}}|{{tt|Y}} 类型（其[[cpp/container/node handle|节点句柄]]与{{tt|X}} 兼容）的值}}
{{dsc|{{c|b}}|{{tt|X}} 或 {{c/core|const X}} 类型的值}}
{{dsc|{{c|u}}|所要声明的变量名字}}
{{dsc|{{c|a_uniq}}|{{tt|X}} 类型的值（{{tt|X}} 支持唯一键）}}
{{dsc|{{c|a_eq}}|{{tt|X}} 类型的值（{{tt|X}} 支持等价键）}}
{{dsc|{{c|a_tran}}|{{tt|X}} 或 {{c/core|const X}} 类型的值（当存在类型 {{tt|X::key_compare::is_transparent}} 时）}}
{{dsc|{{c|i}}, {{c|j}}|指代可以隐式转换到 {{tt|X::value_type}} 的元素的{{named req|InputIterator}}}}
{{dsc|{{range|i|j}}|有效范围}}
{{dsc|{{c|rg}}&lt;br&gt;{{mark since c++23}}|{{tt|R}} 类型（实现 {{lti|cpp/ranges/to#容器兼容范围|container-compatible-range}}{{tt|&lt;value_type&gt;}}）的值}}
{{dsc|{{c|p}}|到 {{c|a}} 的有效常量迭代器}}
{{dsc|{{c|q}}|到 {{c|a}} 的有效可解引用常量迭代器}}
{{dsc|{{c|r}}|到 {{c|a}} 的有效可解引用迭代器}}
{{dsc|{{c|q1}}, {{c|q2}}|表示 {{c|a}} 中的有效范围的常量迭代器}}
{{dsc|{{c|il}}|{{c/core|std::initializer_list&lt;X::value_type&gt;}} 类型的对象}}
{{dsc|{{c|t}}|{{tt|X::value_type}} 类型的值}}
{{dsc|{{c|k}}|{{tt|X::key_type}} 类型的值}}
{{dsc|{{c|c}}|{{tt|X::key_compare}} 或 {{c/core|const X::key_compare}} 类型的值}}
{{dsc|{{c|kl}}|使得 {{c|a}} 以 {{c|c(x, kl)}} 划分的值，其中 {{c|x}} 是 {{c|a}} 中的元素 {{c|e}} 的键}}
{{dsc|{{c|ku}}|使得 {{c|a}} 以 {{c|!c(ku, x)}} 划分的值，其中 {{c|x}} 是 {{c|a}} 中的元素 {{c|e}} 的键}}
{{dsc|{{c|ku}}|使得 {{c|a}} 以 {{c|c(x, ke)}} 和 {{c|!c(ke, x)}} 划分的值，其中 {{c|c(x, ke)}} 意味着 {{c|!c(ke, x)}}，并且 {{c|x}} 是 {{c|a}} 中的元素 {{c|e}} 的键}}
{{dsc|{{c|kx}}&lt;br&gt;{{mark since c++23}}|满足以下条件的值：
* {{c|a}} 以 {{c|c(x, kx)}} 和 {{c|!c(kx, x)}} 划分，其中 {{c|c(x, kx)}} 意味着 {{c|!c(kx, x)}}，并且 {{c|x}} 是 {{c|a}} 中的元素 {{c|e}} 的键
* {{c|kx}} 不可转换到 {{tt|X::iterator}} 或 {{tt|X::const_iterator}}}}
{{dsc|{{c|m}}|具有可转换到 {{tt|A}} 的类型的分配器}}
{{dsc|{{c|nh}}|{{tt|X::node_type}} 类型的非 const 右值}}&lt;!--NB: 'nh' is used in the table below (see N4950, e.g., § 24.2.7.1-84, p.893); it was accidentally dropped out of N4950 (C++23 final draft), but present in IS-C++20 text and should be restored in IS-C++23!--&gt;
{{dsc end}}

满足以下条件的类型 {{tt|X}} 满足{{named req/core|AssociativeContainer}}：
* 类型 {{tt|X}} 满足{{rev inl|until=c++11|{{named req|Container}}}}{{rev inl|since=c++11|{{named req|AllocatorAwareContainer}}}},
* 它以类型 {{tt|Key}} 和在 {{tt|Key}} 类型的元素上引入{{rlp|Compare|严格弱序}}的排序关系的 {{tt|Compare}} 参数化
** 另外，{{lc|std::map}} 和 {{lc|std::multimap}} 会将一个任意''映射类型'' {{tt|T}} 关联到 {{tt|Key}}。
** {{tt|Compare}} 类型的对象被称为 {{tt|X}} 类型的容器的''比较对象''。
* 下列表达式必须对所有关联容器有效并具有所指定的效果：

====类型====
{|class=wikitable
!名称||类型||要求
|-
|{{tt|key_type}}
|{{tt|Key}}
|
|-
|{{tt|mapped_type}}
|{{tt|T}}（仅限 {{lc|std::map}} 和 {{lc|std::multimap}}）
|
|-
|{{tt|value_type}}
|
*{{tt|Key}}（仅限 {{lc|std::set}} 和 {{lc|std::multiset}}）
* {{c/core|std::pair&lt;const Key, T&gt;}}（仅限 {{lc|std::map}} 和 {{lc|std::multimap}}）
|从 {{tt|X}} {{named req|Erasable}}
|-
|{{tt|key_compare}}
|{{tt|Compare}}
|{{named req|CopyConstructible}}
|-
|{{tt|value_compare}}
|
* 与 {{tt|key_compare}} 相同（仅限 {{lc|std::set}} 和 {{lc|std::multiset}}）
* 在对上的基于第一项（即 {{tt|Key}}）的排序关系（仅限 {{lc|std::map}} 和 {{lc|std::multimap}}）
|{{named req|BinaryPredicate}}
|-
|{{tt|node_type}}
|使得公开嵌套类型与 {{tt|X}} 中对应类型相同的[[cpp/container/node handle|节点句柄类模板]]特化
|
|}

====成员函数与运算符====
&lt;div style="max-width: 100%; max-height: 90vh; overflow: scroll;"&gt;
{|class=wikitable style="font-size:0.9em"
!表达式||结果||前条件||效果||返回||复杂度
|-
|{{c|X(c)}}
|
|
|构造空容器。以 {{c|c}} 的副本作为比较对象
|
|常数
|-
|{{c|1=X u = X();}}&lt;br&gt;{{c|X u;}}
|
|{{tt|X::key_compare}} 满足{{named req|DefaultConstructible}}的规定
|构造空容器。以 {{c|Compare()}} 作为比较对象
|
|常数
|-
|{{c|X(i, j, c)}}
|
|{{tt|X::value_type}} 从 {{c|*i}} {{named req|EmplaceConstructible}}到 {{tt|X}}
|构造空容器并向其中插入范围 {{range|i|j}} 中的元素；以 {{c|c}} 作为比较对象
|
|rowspan="2"|通常是 {{c|N·log(N)}}，其中 {{tt|N}} 的值为 {{c|std::distance(i, j)}}；或者在 {{range|i|j}} 根据 {{c|value_comp()}} 有序时成线性
|-
|{{c|X(i, j)}}
|
|{{tt|X::key_compare}} 满足{{named req|DefaultConstructible}}的规定。{{tt|X::value_type}} 从 {{c|*i}} {{named req|EmplaceConstructible}}到 {{tt|X}}
|构造空容器并向其中插入范围 {{range|i|j}} 中的元素；以 {{c|Compare()}} 作为比较对象
|
&lt;!--|通常是 {{tt|N&amp;middot;log N}}，或者在 {{range|i|j}} 已按 {{c|value_comp()}} 排序时是 {{tt|N}}（其中 {{tt|N}} 是 {{c|std::distance(i, j)}}）--&gt;
|-
|{{c|X(from_range, rg, c)}}&lt;br&gt;{{mark since c++23}}
|
|{{tt|value_type}} 从 {{c|*ranges::begin(rg)}} {{named req|EmplaceConstructible}}到 {{tt|X}}
|构造空容器并向其中插入 {{c|rg}} 中的每个元素；以 {{c|c}} 作为比较对象
|
|rowspan="2"|通常是 {{c|N·log(N)}}，其中 {{tt|N}} 的值为 {{c|ranges::distance(rg)}}；或者在 {{c|rg}} 根据 {{c|value_comp()}} 有序时成线性
|-
|{{c|X(from_range, rg)}}&lt;br&gt;{{mark since c++23}}
|
|{{tt|key_compare}} 满足{{named req|DefaultConstructible}}的规定。{{tt|value_type}} 从 {{c|*ranges::begin(rg)}} {{named req|EmplaceConstructible}}到 {{tt|X}}
|构造空容器并向其中插入 {{c|rg}} 中的每个元素；以 {{c|Compare()}} 作为比较对象
|
&lt;!--|Same as {{c|X(std::from_range, rg, c)}}--&gt;
|-
|{{c|X(il, c)}}
|
|
|{{c|X(il.begin(), il.end(), c)}}
|
|
|-
|{{c|X(il)}}
|
|
|{{c|X(il.begin(), il.end())}}
|
|
|-
|{{c|1=a = il}}
|{{c|X&amp;}}
|{{tt|value_type}} {{named req|CopyInsertable}}到 {{tt|X}} 且{{named req|CopyAssignable}}
|将范围 {{range|il.begin()|il.end()}} 赋给 {{c|a}}。{{c|a}} 的所有现存元素要么被赋值要么被销毁
|
|通常是 {{c|N·log(N)}}，其中 {{tt|N}} 的值为 {{c|il.size() + a.size()}}；或者在 {{range|il.begin()|il.end()}} 根据 {{c|value_comp()}} 有序时成线性
|-
|{{c|b.key_comp()}}
|{{tt|X::key_compare}}
|
|
|构造 {{c|a}} 时提供的比较对象
|常数
|-
|{{c|b.value_comp()}}
|{{tt|X::value_compare}}
|
|
|从比较对象构造出的 {{tt|value_compare}} 类型的对象
|常数
|-
|{{c|a_uniq.emplace(args)}}
|{{c multi
|std::pair&lt;
|  iterator,
|  bool&gt;
}}
|{{tt|value_type}} 以 {{c|args}} {{named req|EmplaceConstructible}}到 {{tt|X}}
|当且仅当容器中不存在元素带有与 {{c|t}} 的键等价的键时，插入一个以 {{c|std::forward&lt;Args&gt;(args)...}} 构造的 {{tt|value_type}} 对象 {{c|t}}
|当且仅当发生插入时，所返回对偶的 {{c/core|bool}} 组分为 {{c|true}}，而对偶的迭代器组分指向带有与 {{c|t}} 的键等价的键的元素
|对数
|-
|{{c|a_eq.emplace(args)}}
|{{tt|iterator}}
|{{tt|value_type}} 以 {{c|args}} {{named req|EmplaceConstructible}}到 {{tt|X}}
|插入一个以 {{c|std::forward&lt;Args&gt;(args)...}} 构造的 {{tt|value_type}} 对象 {{c|t}}。如果 {{c|a_eq}} 中存在包含等价于 {{c|t}} 的元素范围，则 {{c|t}} 被插入到这个范围末尾
|指向新插入元素的迭代器
|对数
|-
|{{c|a.emplace_hint(p, args)}}
|{{tt|iterator}}
|
|等价于
{{c multi
|a.emplace(
|  std::forward&lt;Args&gt;(args)...)
}}，
但在尽可能靠近紧接 {{c|p}} 之前的位置插入元素
|指向带有与新插入元素等价的键的元素的迭代器
|通常是对数，但当于紧接 {{c|p}} 之前插入元素时是均摊常数
|-
|{{c|a_uniq.insert(t)}}
|{{c multi
|std::pair&lt;
|  iterator,
|  bool&gt;
}}
|如果 {{c|t}} 是非 const 右值，则 {{tt|value_type}} {{named req|MoveInsertable}}到 {{tt|X}}；否则 {{tt|value_type}} {{named req|CopyInsertable}}到 {{tt|X}}
|当且仅当容器中不存在带有与 {{c|t}} 的键等价的键的元素时，插入 {{c|t}}
|当且仅当发生插入时，所返回对偶的 {{c/core|bool}} 组分为 {{c|true}}，而对偶的 {{tt|iterator}} 组分指向带有与 {{c|t}} 的键等价的键的元素
|对数
|-
|{{c|a_eq.insert(t)}}
|{{tt|iterator}}
|如果 {{c|t}} 是非 const 右值，则 {{tt|value_type}} {{named req|MoveInsertable}}到 {{tt|X}}；否则 {{tt|value_type}} {{named req|CopyInsertable}}到 {{tt|X}}
|插入 {{c|t}} 并返回指向新插入元素的迭代器。如果 {{c|a_eq}} 中存在包含等价于 {{c|t}} 的元素的范围，则 {{c|t}} 被插入到这个范围末尾
|
|对数
|-
|{{c|a.insert(p, t)}}
|{{tt|iterator}}
|如果 {{c|t}} 是非 const 右值，则 {{tt|value_type}} {{named req|MoveInsertable}}到 {{tt|X}}；否则 {{tt|value_type}} {{named req|CopyInsertable}}到 {{tt|X}}
|当且仅当带有唯一键的容器中不存在带有与 {{c|t}} 的键等价的键的元素时，插入 {{c|t}}；带有等价键的容器总是插入 {{c|t}}。{{c|t}} 被插入到尽可能靠近紧接 {{c|p}} 之前的位置
|指向带有与 {{c|t}} 的键等价的键的元素的迭代器
|通常是对数，但当于紧接 {{c|p}} 之前插入 {{c|t}} 时是均摊常数
|-
|{{c|a.insert(i, j)}}
|{{c/core|void}}
|{{tt|value_type}} 以 {{c|*i}} {{named req|EmplaceConstructible}}到 {{tt|X}}。{{c|i}} 和 {{c|j}} 都不是 {{c|a}} 中的迭代器
|对于范围 {{range|i|j}} 中的各个元素，当且仅当带有唯一键的容器中不存在带有与此元素的键等价的键的元素时插入该元素；带有等价键的容器总是插入该元素
|
|{{c|N·log(a.size() + N)}}，其中 {{tt|N}} 的值为 {{c|std::distance(i, j)}}
|-
|{{c|a.insert_range(rg)}}&lt;br&gt;{{mark since c++23}}
|{{c/core|void}}
|{{tt|value_type}} 以 {{c|*ranges::begin(rg)}} {{named req|EmplaceConstructible}}到 {{tt|X}}。{{c|rg}} 和 {{c|a}} 不重叠
|对于 {{c|rg}} 中的各个元素，当且仅当带有唯一键的容器中不存在带有与此元素的键等价的键的元素时插入该元素；带有等价键的容器总是插入该元素
|
|{{c|N·log(a.size() + N)}}, 其中 {{tt|N}} 的值为 {{c|ranges::distance(rg)}}
|-
|{{c|a.insert(il)}}
|
|
|{{c|a.insert(il.begin(), il.end())}}
|
|
|-
|{{c|a_uniq.insert(nh)}}
|{{tt|insert_return_type}}
|{{c|nh}} 为空，或者
{{c multi
|a_uniq.get_allocator()
|{{==}}
|nh.get_allocator()
}}
为 {{c|true}}
|{{c|nh}} 为空时无效果。否则，当且仅当容器中不存在具有与 {{c|nh.key()}} 等价的键的元素时，插入 {{c|nh}} 拥有的元素
|{{c|nh}} 为空时，{{tt|inserted}} 为 {{c|false}}，{{tt|position}} 为 {{c|end()}}，且 {{tt|node}} 为空。否则当发生插入时，{{tt|inserted}} 为 {{c|true}}，{{tt|position}} 指向插入的元素，且 {{tt|node}} 为空；如果插入失败，则 {{tt|inserted}} 为 {{c|false}}，{{tt|node}} 具有 {{c|nh}} 之前的值，而 {{tt|position}} 指向具有与 {{c|nh.key()}} 等价的键的元素
|对数
|-
|{{c|a_eq.insert(nh)}}
|{{tt|iterator}}
|{{c|nh}} 为空，或者
{{c multi
|a_eq.get_allocator()
|{{==}}
|nh.get_allocator()
}}
为 {{c|true}}
|{{c|nh}} 为空时无效果并返回 {{c|a_eq.end()}}。否则，插入 {{c|nh}} 拥有的元素并返回指向新插入元素的迭代器。如果 {{c|a_eq}} 中存在包含具有等价于 {{c|nh.key()}} 的键的元素的范围，则在这个范围末尾插入元素。保证：{{c|nh}} 为空
|
|对数
|-
|{{c|a.insert(p, nh)}}
|{{tt|iterator}}
|{{c|nh}} 为空，或者
{{c multi
|a.get_allocator()
|{{==}}
|nh.get_allocator()
}}
为 {{c|true}}
|{{c|nh}} 为空时无效果并返回 {{c|a.end()}}。否则，当且仅当具有唯一键的容器中不存在具有与 {{c|nh.key()}} 等价的键的元素时，插入 {{c|nh}} 拥有的元素；具有等价键的容器总是插入 {{c|nh}} 拥有的元素。在尽可能靠近紧接 {{c|p}} 之前的位置插入元素。保证：{{c|nh}} 当插入成功时为空，当插入失败时不改变
|指向带有与 {{c|nh.key()}} 等价的键的元素的迭代器
|通常是对数，但当于紧接 {{c|p}} 之前插入元素时是均摊常数
|-
|{{c|a.extract(k)}}
|{{tt|node_type}}
|
|移除容器中第一个带有与 {{c|k}} 等价的键的元素
|若找到则为拥有该元素的 {{tt|node_type}}，否则为空 {{tt|node_type}}
|{{c|log(a.size())}}
|-
|{{c|a_tran.extract(kx)}}&lt;br&gt;{{mark since c++23}}
|{{tt|node_type}}
|
|移除容器中第一个带有键 {{c|r}} 使得 {{c|!c(r, kx) &amp;&amp; !c(kx, r)}} 为 {{c|true}} 的元素
|若找到则为拥有该元素的 {{tt|node_type}}，否则为空 {{tt|node_type}}
|{{c|log(a_tran.size())}}
|-
|{{c|a.extract(q)}}
|{{tt|node_type}}
|
|移除 {{c|q}} 所指向的元素
|拥有该元素的 {{tt|node_type}}
|均摊常数
|-
|{{c|a.merge(a2)}}
|{{c/core|void}}
|{{c multi
|a.get_allocator()
|{{==}}
|a2.get_allocator()
}}
|尝试提取 {{c|a2}} 中的各个元素，并使用 {{c|a}} 的比较对象将其插入 {{c|a}}。在具有唯一键的容器中，如果 {{c|a}} 中存在某个元素带有与 {{c|a2}} 中某个元素的键等价的键，则不从 {{c|a2}} 提取这个元素。保证：指向被转移的 {{c|a2}} 元素的指针和引用，指代已作为 {{c|a}} 成员的相同元素。指代被转移元素的迭代器继续指代它们的元素，但它们现在表现为 {{c|a}} 而非 {{c|a2}} 中的迭代器。抛出：除非比较对象抛出异常，否则无抛出
|
|{{c|N·log(a.size() + N)}}，其中 {{tt|N}} 的值为 {{c|a2.size()}}
|-
|{{c|a.erase(k)}}
|{{tt|size_type}}
|
|擦除容器中所有带有等价于 {{c|k}} 的键的元素
|被擦除的元素数量
|{{c multi
|log(a.size())
|+ a.count(k)
}}
|-
|{{c|a_tran.erase(kx)}}&lt;br&gt;{{mark since c++23}}
|{{tt|size_type}}
|
|擦除容器中所有带有键 {{c|r}} 使得 {{c|!c(r, kx) &amp;&amp; !c(kx, r)}} 为 {{c|true}} 的元素
|被擦除的元素数量
|{{c multi
|log(a_tran.size())
|+ a_tran.count(kx)
}}
|-
|{{c|a.erase(q)}}
|{{tt|iterator}}
|
|擦除 {{c|q}} 指向的元素
|指向元素被擦除前紧跟 {{c|q}} 之后的元素的迭代器。若不存在这种元素则返回 {{c|a.end()}}
|均摊常数
|-
|{{c|a.erase(r)}}
|{{tt|iterator}}
|
|擦除 {{c|r}} 指向的元素
|指向元素被擦除前紧跟 {{c|r}} 之后的元素的迭代器。若不存在这种元素则返回 {{c|a.end()}}
|均摊常数
|-
|{{c|a.erase(q1, q2)}}
|{{tt|iterator}}
|
|擦除范围 {{range|q1|q2}} 中的所有元素
|指向擦除任何元素之前 {{c|q2}} 所指向的元素的迭代器。若不存在这种元素则返回 {{c|a.end()}}
|{{c|log(a.size()) + N}}，其中 {{tt|N}} 的值为 {{c|std::distance(q1, q2)}}
|-
|{{c|a.clear()}}
|
|
|{{c|a.erase(a.begin(), a.end())}}。保证：{{c|a.empty()}} 为 {{c|true}}
|
|与 {{c|a.size()}} 成线性
|-
|{{c|b.find(k)}}
|{{tt|iterator}}; 对常量 {{c|b}} 为 {{tt|const_iterator}}
|
|
|指向带有等价于 {{c|k}} 的键的元素的迭代器，或未找到这种元素时为 {{c|b.end()}}
|对数
|-
|{{c|a_tran.find(ke)}}
|{{tt|iterator}}; 对常量 {{c|a_tran}} 为 {{tt|const_iterator}}
|
|
|指向带有键 {{c|r}} 使得
{{c multi|
!c(r, ke) &amp;&amp;|
!c(ke, r)}}
为 {{c|true}} 的元素的迭代器，或未找到这种元素时为 {{c|a_tran.end()}}
|对数
|-
|{{c|b.count(k)}}
|{{tt|size_type}}
|
|
|带有等价于 {{c|k}} 的键的元素数量
|{{c multi
|log(b.size())
|+ b.count(k)
}}
|-
|{{c|a_tran.count(ke)}}
|{{tt|size_type}}
|
|
|带有键 {{c|r}} 使得
{{c multi|
!c(r, ke) &amp;&amp;|
!c(ke, r)}} 的元素数量
|{{c multi
|log(a_tran.size())
|+ a_tran.count(ke)
}}
|-
|{{c|b.contains(k)}}
|{{c/core|bool}}
|
|{{c|1=return b.find(k) != b.end();}}
|
|&lt;!--TODO: absent in 4950, present in IS C++20 Logarithmic--&gt;
|-
|{{c|a_tran.contains(ke)}}
|{{c/core|bool}}
|
|
{{c multi
|return
|  a_tran.find(ke) !{{=}}
|  a_tran.end();
}}
|
|&lt;!--TODO: absent in 4950, present in IS C++20 Logarithmic--&gt;
|-
|{{c|b.lower_bound(k)}}
|{{tt|iterator}}; 对于常量 {{c|b}} 为 {{tt|const_iterator}}
|
|
|指向第一个带有不小于 {{c|k}} 的键的元素的迭代器，或未找到这种元素时为 {{c|b.end()}}
|对数
|-
|{{c|a_tran.lower_bound(kl)}}
|{{tt|iterator}}; 对于常量 {{c|a_tran}} 为 {{tt|const_iterator}}
|
|
|指向第一个带有键 {{c|r}} 使得 {{c|!c(r, kl)}} 的元素的迭代器，或未找到这种元素时为 {{c|a_tran.end()}}
|对数
|-
|{{c|b.upper_bound(k)}}
|{{tt|iterator}}; 对于常量 {{c|b}} 为 {{tt|const_iterator}}
|
|
|指向第一个带有大于 {{c|k}} 的键的元素的迭代器，或未找到这种元素时为 {{c|b.end()}}
|对数
|-
|{{c|a_tran.upper_bound(ku)}}
|{{tt|iterator}}; 对于常量 {{c|a_tran}} 为 {{tt|const_iterator}}
|
|
|指向第一个带有键 {{c|r}} 使得 {{c|c(ku, r)}} 的元素的迭代器，或未找到这种元素时为 {{c|a_tran.end()}}
|对数
|-
|{{c|b.equal_range(k)}}
|{{c multi
|std::pair&lt;
|  iterator,
|  iterator&gt;
}};
对于常量 {{c|b}} 为
{{c multi
|std::pair&lt;
|  const_iterator,
|  const_iterator&gt;
}}
|
|等价于：
{{c multi
|return
|  std::make_pair(
|    b.lower_bound(k),
|    b.upper_bound(k));
}}
|
|对数
|-
|{{c|a_tran.equal_range(ke)}}
|{{c multi
|std::pair&lt;
|  iterator,
|  iterator&gt;
}};
对于常量 {{c|a_tran}} 为
{{c multi
|std::pair&lt;
|  const_iterator,
|  const_iterator&gt;
}}
|
|等价于：
{{c multi
|return
|  std::make_pair(
|    a_tran.lower_bound(ke),
|    a_tran.upper_bound(ke));
}}
|
|对数
|-
|}
&lt;/div&gt;

====迭代器====
关联容器的迭代器满足{{named req|BidirectionalIterator}}的要求。

对于 {{tt|value_type}} 与 {{tt|key_type}} 相同的关联容器，{{tt|iterator}} 和 {{tt|const_iterator}} 都是常量迭代器。未指明 {{tt|iterator}} 和 {{tt|const_iterator}} 是否是相同类型。

关联容器的迭代器以键的非降序对容器进行迭代，其中的非降序由用于构造该容器的比较所定义。就是说，给定
* {{c|a}}，关联容器
* {{c|i}} 和 {{c|j}}，{{c|a}} 中的可解引用迭代器。
如果从 {{c|i}} 到 {{c|j}} 的距离为正，则 {{c|1=a.value_comp()(*j, *i) == false}}。而且，如果 {{c|a}} 是具有唯一键的关联容器，那么更强的条件 {{c|1=a.value_comp()(*i, *j) != false}} 也成立。

{{todo|Finish requirements.}}

===标准库===
下列标准库容器均满足{{named req/core|AssociativeContainer}}：
{{dsc begin}}
{{dsc inc|cpp/container/dsc set}}
{{dsc inc|cpp/container/dsc multiset}}
{{dsc inc|cpp/container/dsc map}}
{{dsc inc|cpp/container/dsc multimap}}
{{dsc end}}

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=354|std=C++98|before={{tt|lower_bound}} 和 {{tt|upper_bound}} 在没找到元素时不会返回尾迭代器|after=此时它们会返回尾迭代器}}
{{dr list item|wg=lwg|dr=589|std=C++98|before={{c|i}} 和 {{c|j}} 指代的元素具有 {{tt|X::value_type}} 类型|after=那些元素可以隐式转换到 {{tt|X::value_type}}}}
{{dr list end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}