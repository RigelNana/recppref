{{cpp/named req/title|CopyInsertable|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}

指定该类型的对象能以给定分配器原位复制构造。

===要求===
给定以下类型、值和表达式：
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc|{{tt|T}}|对象类型}}
{{dsc|{{tt|A}}|分配器类型}}
{{dsc|{{tt|X}}|满足以下所有条件的容器类型：
* {{tt|X::value_type}} 与 {{tt|T}} 相同。
* {{tt|X::allocator_type}} 与 {{c/core|std::allocator_traits&lt;A&gt;::rebind_alloc&lt;T&gt;}} 相同。
}}
{{dsc hitem|值|定义}}
{{dsc|{{c|m}}|{{tt|A}} 类型左值}}
{{dsc|{{c|p}}|{{tt|T*}} 类型指针}}
{{dsc hitem|表达式|定义}}
{{dsc|{{c|v}}|表示 {{tt|T}} / {{c/core|const T}} 类型左值或 {{c/core|const T}} 类型右值的表达式}}
{{dsc|{{c|expr}}|{{c|std::allocator_traits&lt;A&gt;::construct(m, p, v)}}}}
{{dsc end}}

如果满足以下所有条件，那么 {{tt|T}} {{named req/core|CopyInsertable}}到 {{tt|X}} 中：
* {{tt|T}} {{named req|MoveInsertable}}到 {{tt|X}} 中。
* {{c|expr}} 良构。
* 对 {{c|expr}} 进行求值不会改变 {{c|v}} 的值。
* 在对 {{c|expr}} 求值完成时，{{c|v}} 的值等价于 {{c|*p}}。

===注解===
如果 {{tt|A}} 是 {{c/core|std::allocator&lt;T&gt;}}，那么就会如同用 {{rev inl|until=c++20|{{c|::new((void*)p) T(v)}}}}{{rev inl|since=c++20|{{c|std::construct_at(p, v)}}}} 调用布置 {{c/core|new}}。

尽管 C++23 前要求在构造 {{lc|std::basic_string}} 的元素时使用定制的 {{tt|construct}}，但所有实现都使用默认机制。{{wg21|P1072R10}} 更正了该要求以匹配既存实践。

===缺陷报告===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2177|std=C++11|before=对 {{c|expr}} 进行求值没有任何后条件|after=添加后条件}}
{{dr list item|wg=lwg|dr=3957|std=C++11|before={{c|v}} 可以表示 {{tt|T}} 类型右值|after=已排除}}
{{dr list end}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}