{{cpp/named req/title|DefaultInsertable|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}

指定该类型的对象能以给定的分配器原位默认构造。

===要求===
给定以下类型、值和表达式：
{{dsc begin}}
{{dsc hitem|类型|定义}}
{{dsc|{{tt|T}}|对象类型}}
{{dsc|{{tt|A}}|分配器类型}}
{{dsc|{{tt|X}}|满足以下所有条件的容器类型：
* {{tt|X::value_type}} 与 {{tt|T}} 相同。
* {{tt|X::allocator_type}} 与 {{c/core|std::allocator_traits&lt;A&gt;::rebind_alloc&lt;T&gt;}} 相同。
}}
{{dsc hitem|值|定义}}
{{dsc|{{c|m}}|{{tt|A}} 类型左值}}
{{dsc|{{c|p}}|{{tt|T*}} 类型指针}}
{{dsc end}}

如果表达式 {{c|std::allocator_traits&lt;A&gt;::construct(m, p)}} 良构，那么 {{tt|T}} {{named req/core|DefaultInsertable}}到 {{tt|X}} 中。

===注解===
默认情况下，这会[[cpp/language/value initialization|值初始化]]对象，如同使用 {{rev inl|until=c++20|{{c|::new((void*)p) T()}}}}{{rev inl|since=c++20|{{c|std::construct_at(p)}}}} 一样。

如果不想要值初始化，例如当对象是非类类型且不需要清零时，那么可通过提供[http://stackoverflow.com/a/21028912/273767 定制的 {{tt|Allocator::construct}}] 避免。

尽管 C++23 前要求在构造 {{lc|std::basic_string}} 的元素时使用定制的 {{tt|construct}}，所有实现都使用默认机制。{{wg21|P1072R10}} 更正了该要求以匹配既存实践。

===缺陷报告===
{{dr list begin}}
{{dr list item|paper=N3346|std=C++11|before={{named req|CopyInsertable}}和{{named req|MoveInsertable}}&lt;br&gt;这两个要求已经存在，但还缺少{{named req/core|DefaultInsertable}}|after=添加该要求}}
{{dr list end}}

===参阅===
{{dsc begin}}
{{dsc|{{named req|DefaultConstructible}}}}
{{dsc|{{named req|CopyInsertable}}}}
{{dsc|{{named req|MoveInsertable}}}}
{{dsc|{{named req|EmplaceConstructible}}}}
{{dsc|{{named req|Erasable}}}}
{{dsc end}}

{{langlinks|de|es|en|ja|ru}}