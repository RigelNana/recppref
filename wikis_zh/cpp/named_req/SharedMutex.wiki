{{cpp/named req/title|SharedMutex|notes={{mark since c++17}}}}
{{cpp/named req/navbar}}

{{named req|SharedMutex}}要求扩展了{{named req|Mutex}}要求，以包括共享的锁所有权模式。

===要求===
* {{named req|Mutex}}

另外，{{named req/core|SharedMutex}}类型的对象 {{ttb|m}} 支持另一所有权模式：共享。多个线程（或更通用地，执行代理）能同时以共享模式占有此互斥体，但若有线程以排他模式占有，则无线程可获得共享所有权，而若有线程以共享模式占有，则无线程可获得排他所有权。若多于实现定义数量（不少于 10000）的线程数保有一个共享锁，则另一次尝试获得共享锁会阻塞直至共享所有者的数量跌到该阈值以下。

* 表达式 {{c|m.lock_shared()}} 拥有下列性质
:* 表现为原子操作。
:* 阻塞调用方线程，直到能获得互斥体的共享所有权。
:* 同一互斥体上的先前 {{c|m.unlock()}} 操作''同步于''此操作（等价于释放-获得 {{lc|std::memory_order}}）。
:* 若调用方线程已以任何模式占有互斥体，则行为未定义。
:* 若抛出异常，则不获得共享锁。

* 表达式 {{c|m.try_lock_shared()}} 拥有下列性质
:* 表现为原子操作。
:* 试图为调用方线程获得互斥体的共享所有权，而不阻塞。若未得到所有权，则立即返回。允许此函数虚假地失败并返回，即使互斥体当前未为任何线程以任何模式占有。
:* 若 {{tt|try_lock_shared()}} 成功，则同一对象上的先前 {{tt|unlock()}} 操作''同步于''此操作（等价于释放获得 {{lc|std::memory_order}}）。
:* 若调用方线程已以任何模式占有互斥体，则行为未定义。

* 表达式 {{c|m.unlock_shared()}} 拥有下列性质
:* 表现为原子操作。
:* 释放调用方线程的互斥体所有权，且''同步于''同一对象上后继的成功锁定操作。
:* 若调用方线程不占有互斥体，则行为未定义。

* 单个互斥体上的所有锁定和解锁操作以单独全序出现。

===标准库===
下列标准库类型满足{{named req/core|SharedMutex}}：
{{dsc begin}}
{{dsc inc|cpp/thread/dsc shared_mutex}}
{{dsc inc|cpp/thread/dsc shared_timed_mutex}}
{{dsc end}}

===参阅===
* [[cpp/thread|线程支持库]]
* {{named req|Mutex}}
* {{named req|TimedMutex}}
* {{named req|SharedTimedMutex}}

{{langlinks|de|en|es|fr|it|ja|pt|ru}}