{{cpp/title|atomic_is_lock_free, ATOMIC_xxx_LOCK_FREE}}
{{cpp/thread/navbar}}
{{dcl begin}}
{{dcl header|atomic}}
{{dcl|num=1|since=c++11|
template&lt; class T &gt;
bool atomic_is_lock_free( const volatile std::atomic&lt;T&gt;* obj ) noexcept;
}}
{{dcl|num=2|since=c++11|
template&lt; class T &gt;
bool atomic_is_lock_free( const std::atomic&lt;T&gt;* obj ) noexcept;
}}
{{dcl|num=3|since=c++11|
#define ATOMIC_BOOL_LOCK_FREE     /* unspecified */
#define ATOMIC_CHAR_LOCK_FREE     /* unspecified */
#define ATOMIC_CHAR16_T_LOCK_FREE /* unspecified */
#define ATOMIC_CHAR32_T_LOCK_FREE /* unspecified */
#define ATOMIC_WCHAR_T_LOCK_FREE  /* unspecified */
#define ATOMIC_SHORT_LOCK_FREE    /* unspecified */
#define ATOMIC_INT_LOCK_FREE      /* unspecified */
#define ATOMIC_LONG_LOCK_FREE     /* unspecified */
#define ATOMIC_LLONG_LOCK_FREE    /* unspecified */
#define ATOMIC_POINTER_LOCK_FREE  /* unspecified */
}}
{{dcl|num=4|since=c++20|
#define ATOMIC_CHAR8_T_LOCK_FREE  /* unspecified */
}}
{{dcl end}}

@1,2@ Determines if the atomic object pointed to by {{c|obj}} is implemented lock-free, as if by calling {{c|obj-&gt;is_lock_free()}}. In any given program execution, the result of the lock-free query is the same for all atomic objects of the same type.

@3,4@ Expands to an integer constant expression with value
* {{c|0}} for the built-in atomic types that are never lock-free,
* {{c|1}} for the built-in atomic types that are ''sometimes'' lock-free,
* {{c|2}} for the built-in atomic types that are always lock-free.

===Parameters===
{{par begin}}
{{par|obj|pointer to the atomic object to examine}}
{{par end}} 

===Return value===
{{c|true}} if {{c|*obj}} is a lock-free atomic, {{c|false}} otherwise.

===Notes===
All atomic types except for {{lc|std::atomic_flag}} may be implemented using mutexes or other locking operations, rather than using the lock-free atomic CPU instructions. Atomic types are also allowed to be ''sometimes'' lock-free: for example, if only some subarchitectures support lock-free atomic access for a given type (such as the CMPXCHG16B instruction on x86-64), whether atomics are lock-free may not be known until runtime.

The C++ standard recommends (but does not require) that lock-free atomic operations are also address-free, that is, suitable for communication between processes using shared memory.

===Example===
{{example|code=
#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;

struct A { int a[100]; };
struct B { int x, y; };

int main()
{
    std::atomic&lt;A&gt; a;
    std::atomic&lt;B&gt; b;
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; "std::atomic&lt;A&gt; is lock free? "
              &lt;&lt; std::atomic_is_lock_free(&amp;a) &lt;&lt; '\n'
              &lt;&lt; "std::atomic&lt;B&gt; is lock free? "
              &lt;&lt; std::atomic_is_lock_free(&amp;b) &lt;&lt; '\n';
}
|p=true
|output=
std::atomic&lt;A&gt; is lock free? false
std::atomic&lt;B&gt; is lock free? true
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3249|std=C++11|before={{tt|atomic_is_lock_free}} was specified via pointers, which&lt;br&gt;was ambiguous and might accept invalid pointer values|after=specified via&lt;br&gt;atomic objects}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/atomic/atomic/dsc is_lock_free}}
{{dsc inc|cpp/atomic/dsc atomic_flag}}
{{dsc inc|cpp/atomic/atomic/dsc is_always_lock_free}}
{{dsc break}}
{{dsc tfun|cpp/memory/shared_ptr/atomic|notes={{mark life|deprecated=c++20|removed=c++26|br=yes}}|title=std::atomic_is_lock_free{{dsc small|(std::shared_ptr)}}|specializes atomic operations for {{lc|std::shared_ptr}}}}
{{dsc see c|c/atomic/atomic_is_lock_free}}
{{dsc see c|c/atomic/ATOMIC_LOCK_FREE_consts|ATOMIC_*_LOCK_FREE}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}