{{cpp/atomic/atomic_ref/title|atomic_ref}}
{{cpp/atomic/atomic_ref/navbar}}
{{dcl begin}}
{{dcla|num=1|constexpr=c++26|
explicit atomic_ref( T&amp; obj );
}}
{{dcla|num=2|constexpr=c++26|
atomic_ref( const atomic_ref&amp; ref ) noexcept;
}}
{{dcl end}}

Constructs a new {{tt|atomic_ref}} object.

@1@ Constructs an {{tt|atomic_ref}} object referencing the object {{c|obj}}.
@@ If {{c|obj}} is not aligned to {{rlpt|required_alignment}}, the behavior is undefined.

@2@ Constructs an {{tt|atomic_ref}} object referencing the object referenced by {{c|ref}}.

===Parameters===
{{par begin}}
{{par|obj|object to reference}}
{{par|ref|another {{tt|atomic_ref}} object to copy from}}
{{par end}}

===Example===
{{example
|The program increments the values in a container using several threads. Then the final sum is printed. Non-atomic access may "loss" the results of some operations due to data-races.
|code=
#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

int main()
{
    using Data = std::vector&lt;char&gt;;
    
    auto inc_atomically = [](Data&amp; data)
    {
        for (Data::value_type&amp; x : data)
        {
            auto xx = std::atomic_ref&lt;Data::value_type&gt;(x);
            ++xx; // atomic read-modify-write
        }
    };
    
    auto inc_directly = [](Data&amp; data)
    {
        for (Data::value_type&amp; x : data)
            ++x;
    };
    
    auto test_run = [](const auto Fun)
    {
        Data data(10'000'000);
        {
            std::jthread j1{Fun, std::ref(data)};
            std::jthread j2{Fun, std::ref(data)};
            std::jthread j3{Fun, std::ref(data)};
            std::jthread j4{Fun, std::ref(data)};
        }
        std::cout &lt;&lt; "sum = " &lt;&lt; std::accumulate(cbegin(data), cend(data), 0) &lt;&lt; '\n';
    };
    
    test_run(inc_atomically);
    test_run(inc_directly);
}
|p=true
|output=
sum = 40000000
sum = 39994973
}}

{{langlinks|de|es|ja|ru|zh}}