{{cpp/atomic/atomic_ref/title|fetch_max}}
{{cpp/atomic/atomic_ref/navbar}}
{{dcl begin}}
{{dcl h|Provided only when {{tt|T}} is an integral type other than ''cv'' {{c/core|bool}} or a pointer-to-object type}}
{{dcl|since=c++26|1=
value_type fetch_max( value_type arg,
                      std::memory_order order =
                          std::memory_order_seq_cst ) const noexcept;
}}
{{dcl end}}

Atomically replaces the current value of the referenced object with the result of {{lc|std::max}} of the value and {{c|arg}}. That is, it performs atomic maximum operation. The operation is a read-modify-write operation. Memory is affected according to the value of {{c|order}}.

If {{tt|T}} is a pointer type and the pointers point to different complete objects (or subobjects thereof), [[cpp/language/operator comparison#Built-in pointer relational comparison|pointer comparison]] does not establish a {{enwiki|strict weak ordering}}.

{{cpp/enable if|{{c/core|std::is_const_v&lt;T&gt;}} is {{c|false}}}}.

===Parameters===
{{par begin}}
{{par|arg|the other argument of {{lc|std::max}}}}
{{par|order|memory order constraints to enforce}}
{{par end}}

===Return value===
The value immediately preceding the effects of this function in the {{lsd|cpp/atomic/memory order#Modification order}} of {{c|*this}}.

===Notes===
{{feature test macro|__cpp_lib_atomic_min_max|Atomic minimum/maximum|value=202403L|std=C++26}}

===Example===
{{example}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}