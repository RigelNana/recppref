{{cpp/atomic/atomic_ref/title|compare_exchange_weak|compare_exchange_strong}}
{{cpp/atomic/atomic_ref/navbar}}

{{dcl begin}}
{{dcla|num=1|constexpr=c++26|&lt;!-- value_type is the same as T until C++26 --&gt;
bool compare_exchange_weak
    ( value_type&amp; expected, value_type desired,
      std::memory_order success, 
      std::memory_order failure ) const noexcept;
}}
{{dcla|num=2|constexpr=c++26|1=
bool compare_exchange_weak
    ( value_type&amp; expected, value_type desired,
      std::memory_order order =
          std::memory_order_seq_cst ) const noexcept;
}}
{{dcla|num=3|constexpr=c++26|1=
bool compare_exchange_strong
    ( value_type&amp; expected, value_type desired,
      std::memory_order success,
      std::memory_order failure ) const noexcept;
}}
{{dcla|num=4|constexpr=c++26|1=
bool compare_exchange_strong
    ( value_type&amp; expected, value_type desired,
      std::memory_order order =
          std::memory_order_seq_cst ) const noexcept;
}}
{{dcl end}}

Atomically compares the [[cpp/language/object|value representation]] of the referenced object with that of {{c|expected}}, and if those are bitwise-equal, replaces the former with {{c|desired}} (performs a read-modify-write operation). Otherwise, loads the actual value stored in the referenced object into {{c|expected}} (performs a load operation).

@1,3@ The memory models for the read-modify-write and load operations are {{c|success}} and {{c|failure}} respectively.

@2,4@ {{c|order}} is used for both read-modify-write and load operations, except that {{c|std::memory_order_acquire}} and {{c|std::memory_order_relaxed}} are used for the load operation if {{c|order}} is {{c|std::memory_order_acq_rel}} or {{c|std::memory_order_release}} respectively.

{{cpp/enable if|plural=yes|{{c|std::is_const_v&lt;T&gt;}} is {{c|false}}}}.

If {{c|failure}} is not {{c|std::memory_order_relaxed}}, {{c|std::memory_order_consume}}, {{c|std::memory_order_acquire}} or {{c|std::memory_order_seq_cst}}, the behavior is undefined.

===Parameters===
{{par begin}}
{{par|expected|reference to the value expected to be found in the object referenced by the {{tt|atomic_ref}} object}}
{{par|desired|the value to store in the referenced object if it is as expected}}
{{par|success|the memory synchronization ordering for the read-modify-write operation if the comparison succeeds}}
{{par|failure|the memory synchronization ordering for the load operation if the comparison fails}}
{{par|order|the memory synchronization ordering for both operations}}
{{par end}}

===Return value===
{{c|true}} if the referenced object was successfully changed, {{c|false}} otherwise.

===Notes===
The comparison and copying are bitwise (similar to {{lc|std::memcmp}} and {{lc|std::memcpy}}); no constructor, assignment operator, or comparison operator are used.

The weak forms {{v|1,2}} of the functions are allowed to fail spuriously, that is, act as if {{c|1=*this != expected}} even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms.

When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable unless the object representation of {{tt|value_type}} may include trap bits, or offers multiple object representations for the same value (e.g. floating-point NaN). In those cases, weak compare-and-exchange typically works because it quickly converges on some stable object representation.

For a union with bits that participate in the value representations of some members but not the others, compare-and-exchange might always fail because such padding bits have indeterminate values when they do not participate in the value representation of the active member.

Padding bits that never participate in an object's value representation are ignored.

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3508|paper=P3323R1|std=C++20|before={{tt|compare_exchange_weak}} and {{tt|compare_exchange_strong}}&lt;br&gt;were meaningless for {{c/core|const T}}|after=constrained to accept only non-const {{tt|T}}}}
{{dr list end}}

===Example===
{{example}}

{{langlinks|es|ja|zh}}