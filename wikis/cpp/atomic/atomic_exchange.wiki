{{cpp/title|atomic_exchange|atomic_exchange_explicit}}
{{cpp/thread/navbar}}
{{dcl begin}}
{{dcl header|atomic}}
{{dcl|num=1|since=c++11|
template&lt; class T &gt;
T atomic_exchange( std::atomic&lt;T&gt;* obj,
                   typename std::atomic&lt;T&gt;::value_type desired ) noexcept;
}}
{{dcl|num=2|since=c++11|
template&lt; class T &gt;
T atomic_exchange( volatile std::atomic&lt;T&gt;* obj,
                   typename std::atomic&lt;T&gt;::value_type desired ) noexcept;
}}
{{dcl|num=3|since=c++11|
template&lt; class T &gt;
T atomic_exchange_explicit( std::atomic&lt;T&gt;* obj,
                            typename std::atomic&lt;T&gt;::value_type desired, 
                            std::memory_order order ) noexcept;
}}
{{dcl|num=4|since=c++11|
template&lt; class T &gt;
T atomic_exchange_explicit( volatile std::atomic&lt;T&gt;* obj,
                            typename std::atomic&lt;T&gt;::value_type desired, 
                            std::memory_order order ) noexcept;
}}
{{dcl end}}

@1,2@ Atomically replaces the value pointed to by {{c|obj}} with the value of {{c|desired}} and returns the value {{c|obj}} held previously, as if by {{c|obj-&gt;exchange(desired)}}.

@3,4@ Atomically replaces the value pointed to by {{c|obj}} with the value of {{c|desired}} and returns the value {{c|obj}} held previously, as if by {{c|obj-&gt;exchange(desired, order)}}.

===Parameters===
{{par begin}}
{{par|obj|pointer to the atomic object to modify}}
{{par|desired|the value to store in the atomic object}}
{{par|order|the memory synchronization ordering}}
{{par end}} 

===Return value===
The value held previously by the atomic object pointed to by {{c|obj}}.

===Example===
{{example
|A spinlock mutex can be implemented in userspace using an atomic exchange operation, similar to {{c|std::atomic_flag_test_and_set}}:
|code=
#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

std::atomic&lt;bool&gt; lock(false); // holds true when locked
                               // holds false when unlocked

int new_line{1}; // the access is synchronized via atomic lock variable

void f(int n)
{
    for (int cnt = 0; cnt &lt; 100; ++cnt)
    {
        while (std::atomic_exchange_explicit(&amp;lock, true, std::memory_order_acquire))
            ; // spin until acquired
        std::cout &lt;&lt; n &lt;&lt; (new_line++ % 80 ? "" : "\n");
        std::atomic_store_explicit(&amp;lock, false, std::memory_order_release);
    }
}

int main()
{
    std::vector&lt;std::thread&gt; v;
    for (int n = 0; n &lt; 8; ++n)
        v.emplace_back(f, n);
    for (auto&amp; t : v)
        t.join();
}
|p=true
|output=
02222222222222222222222002222222222222222222222222222222222222222222222222222222
22222222200022222222202222211111111111110000011111111100000000000000110001111111
00011111000001111110000011111100000111000000001111111111111110000010000001001111
11011111111011111011000000000000111100000000000001111000011133333333333333333333
33333333333333333333333333333333333333333333333333333333333333333333333333333333
44444444444444444444444444444444444444444444444444444444444444444444444444444444
44444444444444444444555555555555555555555555555555555555555555555555555555555555
55555555555555555555555555555555555555556666666666666666666666666666666666666666
66666666666666666666666666666666666666666666666666666666666677777777777777777777
77777777777777777777777777777777777777777777777777777777777777777777777777777777
}}

===Defect reports===
{{dr list begin}}
{{dr list item|std=C++11|paper=P0558R1|before=exact type match was required because&lt;br&gt;{{tt|T}} was deduced from multiple arguments|after={{tt|T}} is only deduced&lt;br&gt;from {{c|obj}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/atomic/atomic/dsc exchange|mem=std::atomic&lt;T&gt;}}
{{dsc inc|cpp/atomic/dsc atomic_compare_exchange}}
{{dsc break}}
{{dsc tfun|cpp/memory/shared_ptr/atomic|notes={{mark life|deprecated=c++20|removed=c++26|br=yes}}|title=std::atomic_exchange{{dsc small|(std::shared_ptr)}}
&lt;br&gt;std::atomic_exchange_explicit{{dsc small|(std::shared_ptr)}}|specializes atomic operations for {{lc|std::shared_ptr}}}}
{{dsc see c|c/atomic/atomic_exchange|atomic_exchange|atomic_exchange_explicit}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}