{{cpp/title|atomic_wait|atomic_wait_explicit}}
{{cpp/thread/navbar}}
{{dcl begin}}
{{dcl header|atomic}}
{{dcl|num=1|since=c++20|
template&lt; class T &gt;
void atomic_wait( const std::atomic&lt;T&gt;* object,
                  typename std::atomic&lt;T&gt;::value_type old );
}}
{{dcl|num=2|since=c++20|
template&lt; class T &gt;
void atomic_wait( const volatile std::atomic&lt;T&gt;* object,
                  typename std::atomic&lt;T&gt;::value_type old );
}}
{{dcl|num=3|since=c++20|
template&lt; class T &gt;
void atomic_wait_explicit( const std::atomic&lt;T&gt;* object, 
                           typename std::atomic&lt;T&gt;::value_type old, 
                           std::memory_order order );
}}
{{dcl|num=4|since=c++20|
template&lt; class T &gt;
void atomic_wait_explicit( const volatile std::atomic&lt;T&gt;* object,
                           typename std::atomic&lt;T&gt;::value_type old, 
                           std::memory_order order );
}}
{{dcl end}}

Performs atomic waiting operations. Behaves as if it repeatedly performs the following steps: 
* Compare the [[cpp/language/object|value representation]] of {{c|object-&gt;load()}} (for overloads {{v|1,2}}) or {{c|object-&gt;load(order)}} (for overloads {{v|3,4}}) with that of {{c|old}}.
** If those are bitwise equal, then blocks until {{c|*object}} is notified by {{lc|std::atomic::notify_one()}} or {{lc|std::atomic::notify_all()}}, or the thread is unblocked spuriously.
** Otherwise, returns.

These functions are guaranteed to return only if value has changed, even if the underlying implementation unblocks spuriously.
@1,2@ Equivalent to {{c|object-&gt;wait(old)}}.
@3,4@ Equivalent to {{c|object-&gt;wait(old, order)}}.
@@ If {{c|order}} is one of {{c|std::memory_order::release}} and {{c|std::memory_order::acq_rel}}, the behavior is undefined.

===Parameters===
{{par begin}}
{{par|object|pointer to the atomic object to check and wait on}}
{{par|old|the value to check the atomic object no longer contains}}
{{par|order|the memory synchronization ordering}}
{{par end}} 

===Return value===
(none)

===Notes===
This form of change-detection is often more efficient than simple polling or pure spinlocks.

Due to the {{enwiki|ABA problem}}, transient changes from {{c|old}} to another value and back to {{c|old}} might be missed, and not unblock.

The comparison is bitwise (similar to {{lc|std::memcmp}}); no comparison operator is used. Padding bits that never participate in an object's value representation are ignored.

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/atomic/atomic/dsc wait|atomic}}
{{dsc inc|cpp/atomic/atomic/dsc notify_one|atomic}}
{{dsc inc|cpp/atomic/atomic/dsc notify_all|atomic}}
{{dsc inc|cpp/atomic/dsc atomic_notify_one}}
{{dsc inc|cpp/atomic/dsc atomic_notify_all}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}