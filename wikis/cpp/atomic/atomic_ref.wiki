{{cpp/title|atomic_ref}}
{{cpp/atomic/atomic_ref/navbar}}
{{dcl begin}}
{{dcl header|atomic}}
{{dcl|since=c++20|
template&lt; class T &gt;
struct atomic_ref;
}}
{{dcl end}}

The {{tt|std::atomic_ref}} class template applies atomic operations to the object it references.

For the lifetime of the {{tt|std::atomic_ref}} object, the object it references is considered an atomic object. If one thread writes to an atomic object while another thread reads from it, the behavior is well-defined (see {{lt|cpp/language/memory model}} for details on data races). In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by {{lc|std::memory_order}}.

The lifetime of an object must exceed the lifetime of all {{tt|std::atomic_ref}}s that references the object. While any {{tt|std::atomic_ref}} instance referencing an object exists, the object must be exclusively accessed through these {{tt|std::atomic_ref}} instances. No subobject of an object referenced by an {{tt|std::atomic_ref}} object may be concurrently referenced by any other {{tt|std::atomic_ref}} object.

Atomic operations applied to an object through an {{tt|std::atomic_ref}} are atomic with respect to atomic operations applied through any other {{tt|std::atomic_ref}} referencing the same object.

Like {{lt|cpp/language/reference}}s in the core language, constness is shallow for {{tt|std::atomic_ref}} - it is possible to modify the referenced value through a {{c/core|const}} {{tt|std::atomic_ref}} object.

If any of the following conditions are satisfied, the program is ill-formed:
* {{c|std::is_trivially_copyable_v&lt;T&gt;}} is {{c|false}}.
* {{rlt|is_always_lock_free}} is {{c|false}} and {{c|std::is_volatile_v&lt;T&gt;}} is {{c|true}}.

{{tt|std::atomic_ref}} is {{named req|CopyConstructible}}.

===Nested types===
{{dsc begin}}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|value_type}}|{{c/core|std::remove_cv_t&lt;T&gt;}}}}
{{dsc|{{tt|difference_type}}|
* {{tt|value_type}}, if {{tt|T}} is an arithmetic type other than ''cv'' {{c/core|bool}}.
* Otherwise, {{lc|std::ptrdiff_t}}, if {{tt|T}} is a pointer-to-object type.
* Otherwise, not defined.
}}
{{dsc end}}

===Data members===
{{dsc begin}}
{{dsc hitem|Member|Description}}
{{dsc expos mem obj|spec={{c/core|T*}}|ptr|id=ptr|the pointer to the referenced object}}
{{dsc inc|cpp/atomic/atomic_ref/dsc is_always_lock_free}}
{{dsc inc|cpp/atomic/atomic_ref/dsc required_alignment}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/atomic/atomic_ref/dsc constructor}}
{{dsc inc|cpp/atomic/atomic_ref/dsc operator{{=}}}}
{{dsc inc|cpp/atomic/atomic_ref/dsc is_lock_free}}
{{dsc inc|cpp/atomic/atomic_ref/dsc store}}
{{dsc inc|cpp/atomic/atomic_ref/dsc load}}
{{dsc inc|cpp/atomic/atomic_ref/dsc operator_T}}
{{dsc inc|cpp/atomic/atomic_ref/dsc exchange}}
{{dsc inc|cpp/atomic/atomic_ref/dsc compare_exchange}}
{{dsc inc|cpp/atomic/atomic/dsc wait|atomic_ref}}
{{dsc inc|cpp/atomic/atomic/dsc notify_one|atomic_ref}}
{{dsc inc|cpp/atomic/atomic/dsc notify_all|atomic_ref}}
{{dsc inc|cpp/atomic/atomic/dsc address|atomic_ref}}
{{dsc h2|Provided only when {{tt|T}} is an arithmetic type other than ''cv'' {{c/core|bool}} or a pointer-to-object type}}
{{dsc inc|cpp/atomic/atomic_ref/dsc fetch_add}}
{{dsc inc|cpp/atomic/atomic_ref/dsc fetch_sub}}
{{dsc inc|cpp/atomic/atomic_ref/dsc operator arith2}}
{{dsc h2|Provided only when {{tt|T}} is an integral type other than ''cv'' {{c/core|bool}} or a pointer-to-object type}}
{{dsc inc|cpp/atomic/atomic_ref/dsc fetch_max}}
{{dsc inc|cpp/atomic/atomic_ref/dsc fetch_min}}
{{dsc inc|cpp/atomic/atomic_ref/dsc operator arith}}
{{dsc h2|Provided only when {{tt|T}} is an integral type other than ''cv'' {{c/core|bool}}}}
{{dsc inc|cpp/atomic/atomic_ref/dsc fetch_and}}
{{dsc inc|cpp/atomic/atomic_ref/dsc fetch_or}}
{{dsc inc|cpp/atomic/atomic_ref/dsc fetch_xor}}
{{dsc inc|cpp/atomic/atomic_ref/dsc operator arith3}}
{{dsc end}}

===Specializations===
The standard specifies that {{tt|std::atomic_ref}} has following specializations:

{{dcl begin}}
{{dcl|num=1|since=c++20|
template&lt;&gt;
struct atomic_ref&lt;/*integral-type*/&gt;;
}}
{{dcl|num=2|since=c++20|
template&lt;&gt;
struct atomic_ref&lt;/*floating-point-type*/&gt;;
}}
{{dcl|num=3|since=c++20|
template&lt; class /*pointer-type*/ &gt;
    requires /* see below */
struct atomic_ref&lt;/*pointer-type*/&gt;;
}}
{{dcl end}}

@1@ {{c/core|/*integral-type*/}} denotes a possibly cv-qualified integral type other than ''cv'' {{c/core|bool}}.
@2@ {{c/core|/*floating-point-type*/}} denotes a possibly cv-qualified floating-point type.
@3@ The partial specialization is provided for {{c/core|/*pointer-type*/}} types that are possibly cv-qualified pointer-to-object types.

===Notes===
Implementations may merge the specified specializations. E.g. MSVC STL merges all of them into the primary template.

When {{tt|T}} is ''cv'' {{c/core|void}} or a function type, {{c/core|std::atomic_ref&lt;T*&gt;}} (i.e. {{c/core|std::atomic_ref&lt;void*&gt;}}, {{c/core|std::atomic_ref&lt;int(*)()&gt;}} etc.) does not have {{tt|difference_type}} or any operation requiring pointer arithmetic{{rev inl|since=c++26| or relational comparison}}.

{{ftm begin|sort=1}}
{{ftm|__cpp_lib_atomic_ref|{{tt|std::atomic_ref}}|value=201806L|std=C++20}}
{{ftm|__cpp_lib_constexpr_atomic|{{c/core|constexpr}} {{lc|std::atomic}} and {{tt|std::atomic_ref}}|value=202411L|std=C++26}}
{{ftm end}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3508|paper=P3323R1|std=C++20|before={{c/core|atomic_ref&lt;T&gt;}} had unimplementable operations&lt;br&gt;if {{tt|T}} is a {{c/core|const}} type or pointer-to-non-object type|after=these operations are either constained&lt;br&gt;or not provided for unsuitable {{tt|T}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/atomic/dsc atomic}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}