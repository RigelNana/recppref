{{cpp/atomic/atomic/title|is_lock_free}}
{{cpp/atomic/atomic/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++11|
bool is_lock_free() const noexcept;
}}
{{dcl|num=2|since=c++11|
bool is_lock_free() const volatile noexcept;
}}
{{dcl end}}

Checks whether the atomic operations on all objects of this type are lock-free.

===Parameters===
(none)

===Return value===
{{c|true}} if the atomic operations on the objects of this type are lock-free, {{c|false}} otherwise.

===Notes===
All atomic types except for {{lc|std::atomic_flag}} may be implemented using mutexes or other locking operations, rather than using the lock-free atomic CPU instructions. Atomic types are also allowed to be ''sometimes'' lock-free, e.g. if only aligned memory accesses are naturally atomic on a given architecture, misaligned objects of the same type have to use locks.

The C++ standard recommends (but does not require) that lock-free atomic operations are also address-free, that is, suitable for communication between processes using shared memory.

===Example===
{{example|code=
#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;

struct A { int a[100]; };
struct B { int x, y; };

int main()
{
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; "std::atomic&lt;A&gt; is lock free? "
              &lt;&lt; std::atomic&lt;A&gt;{}.is_lock_free() &lt;&lt; '\n'
              &lt;&lt; "std::atomic&lt;B&gt; is lock free? "
              &lt;&lt; std::atomic&lt;B&gt;{}.is_lock_free() &lt;&lt; '\n';
}
|p=true
|output=
std::atomic&lt;A&gt; is lock free? false
std::atomic&lt;B&gt; is lock free? true
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/atomic/dsc atomic_is_lock_free}}
{{dsc tfun|cpp/memory/shared_ptr/atomic|title=atomic_is_lock_free{{dsc small|(std::shared_ptr)}}|specializes atomic operations for {{lc|std::shared_ptr}}}}
{{dsc inc|cpp/atomic/atomic/dsc is_always_lock_free}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}