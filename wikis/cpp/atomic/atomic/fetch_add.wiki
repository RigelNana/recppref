{{cpp/atomic/atomic/title|fetch_add}}
{{cpp/atomic/atomic/navbar}}
{{dcl begin}}
{{dcl h|member only of {{tt|atomic&lt;''Integral''}}{{sep}}{{tt|&gt;}} specializations&lt;br&gt;{{rev inl|since=c++20|and {{tt|atomic&lt;''Floating''}}{{sep}}{{tt|&gt;}} specializations}}}}
{{dcl|num=1|since=c++11|1=
T fetch_add( T arg, std::memory_order order =
                        std::memory_order_seq_cst ) noexcept;
}}
{{dcl|num=2|since=c++11|1=
T fetch_add( T arg, std::memory_order order =
                        std::memory_order_seq_cst ) volatile noexcept;
}}
{{dcl h|member only of {{tt|atomic&lt;T*&gt;}} partial specialization}}
{{dcl|num=3|since=c++11|1=
T* fetch_add( std::ptrdiff_t arg, 
              std::memory_order order =
                  std::memory_order_seq_cst ) noexcept;
}}
{{dcl|num=4|since=c++11|1=
T* fetch_add( std::ptrdiff_t arg, 
              std::memory_order order =
                  std::memory_order_seq_cst ) volatile noexcept;
}}
{{dcl end}}

Atomically replaces the current value with the result of arithmetic addition of the value and {{c|arg}}. That is, it performs atomic post-increment. The operation is a read-modify-write operation. Memory is affected according to the value of {{c|order}}.

@1,2@ For signed integral types, arithmetic is defined to use twoâ€™s complement representation. There are no undefined results.
{{rrev|since=c++20|
For floating-point types, the [[cpp/numeric/fenv|floating-point environment]] in effect may be different from the calling thread's floating-point environment. The operation need not conform to the corresponding {{lc|std::numeric_limits}} traits but is encouraged to do so. If the result is not a representable value for its type, the result is unspecified but the operation otherwise has no undefined behavior.
}}

@3,4@ The result may be an undefined address, but the operation otherwise has no undefined behavior.
@@ If {{tt|T}} is not a complete object type, the program is ill-formed.


{{rrev|since=c++20|
It is deprecated if {{c|std::atomic&lt;T&gt;::is_always_lock_free}} is {{c|false}} and overload {{v|2}} or {{v|4}} participates in overload resolution.
}}

===Parameters===
{{par begin}}
{{par|arg|the other argument of arithmetic addition}}
{{par|order|memory order constraints to enforce}}
{{par end}}

===Return value===
The value immediately preceding the effects of this function in the {{lsd|cpp/atomic/memory order#Modification order}} of {{c|*this}}.

===Example===
{{example
|code=
#include &lt;array&gt;
#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

std::atomic&lt;long long&gt; data{10};
std::array&lt;long long, 5&gt; return_values{};

void do_work(int thread_num)
{
    long long val = data.fetch_add(1, std::memory_order_relaxed);
    return_values[thread_num] = val;
}

int main()
{
    {
        std::jthread th0{do_work, 0};
        std::jthread th1{do_work, 1};
        std::jthread th2{do_work, 2};
        std::jthread th3{do_work, 3};
        std::jthread th4{do_work, 4};
    }
    
    std::cout &lt;&lt; "Result : " &lt;&lt; data &lt;&lt; '\n';
    
    for (long long val : return_values)
        std::cout &lt;&lt; "Seen return value : " &lt;&lt; val &lt;&lt; std::endl;
}
|p=true
|output=
Result : 15
Seen return value : 11
Seen return value : 10
Seen return value : 14
Seen return value : 12
Seen return value : 13
}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P0558R1|std=C++11|before=arithmetic permitted on pointers to (possibly cv-qualified) {{c/core|void}} or function|after=made ill-formed}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_add}}
{{dsc inc|cpp/atomic/atomic/dsc operator arith}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}