{{cpp/title|atomic_fetch_add|atomic_fetch_add_explicit}}
{{cpp/thread/navbar}}
{{dcl begin}}
{{dcl header|atomic}}
{{dcl|num=1|since=c++11|
template&lt; class T &gt;
T atomic_fetch_add( std::atomic&lt;T&gt;* obj,
                    typename std::atomic&lt;T&gt;::difference_type arg ) noexcept;
}}
{{dcl|num=2|since=c++11|
template&lt; class T &gt;
T atomic_fetch_add( volatile std::atomic&lt;T&gt;* obj,
                    typename std::atomic&lt;T&gt;::difference_type arg ) noexcept;
}}
{{dcl|num=3|since=c++11|
template&lt; class T &gt;
T atomic_fetch_add_explicit( std::atomic&lt;T&gt;* obj,
                             typename std::atomic&lt;T&gt;::difference_type arg,
                             std::memory_order order ) noexcept;
}}
{{dcl|num=4|since=c++11|
template&lt; class T &gt;
T atomic_fetch_add_explicit( volatile std::atomic&lt;T&gt;* obj,
                             typename std::atomic&lt;T&gt;::difference_type arg,
                             std::memory_order order ) noexcept;
}}
{{dcl end}}

Performs atomic addition. Atomically adds {{c|arg}} to the value pointed to by {{c|obj}} and returns the value {{c|obj}} held previously. The operation is performed as if the following was executed:
@1,2@ {{c|obj-&gt;fetch_add(arg)}}
@3,4@ {{c|obj-&gt;fetch_add(arg, order)}}

If {{tt|std::atomic&lt;T&gt;}} has no {{tt|fetch_add}} member (this member is only provided for {{rlp|atomic#Specializations for integral types|integral}}{{rev inl|since=c++20|, {{rlp|atomic#Specializations for floating-point types|floating-point}}}} and {{rlp|atomic#Partial specializations|pointer}} types except {{c/core|bool}}), the program is ill-formed.

===Parameters===
{{par begin}}
{{par|obj|pointer to the atomic object to modify}}
{{par|arg|the value to add to the value stored in the atomic object}}
{{par|order|the memory synchronization ordering}}
{{par end}}

===Return value===
The value immediately preceding the effects of this function in the {{lsd|cpp/atomic/memory order#Modification order}} of {{c|*obj}}.

===Example===
{{example
|Single-writer/multiple-reader lock can be made with {{tt|std::atomic_fetch_add}}. Note that this simplistic implementation is not lockout-free.
|code=
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

using namespace std::chrono_literals;

// meaning of cnt:
//  5: readers and writer are in race. There are no active readers or writers.
//  4...0: there are 1...5 active readers, The writer is blocked.
// -1: writer won the race and readers are blocked.

const int N = 5; // four concurrent readers are allowed
std::atomic&lt;int&gt; cnt(N);

std::vector&lt;int&gt; data;

void reader(int id)
{
    for (;;)
    {
        // lock
        while (std::atomic_fetch_sub(&amp;cnt, 1) &lt;= 0)
            std::atomic_fetch_add(&amp;cnt, 1);
        
        // read
        if (!data.empty())
            std::cout &lt;&lt; ("reader " + std::to_string(id) +
                          " sees " + std::to_string(*data.rbegin()) + '\n');
        if (data.size() == 25)
            break;
        
        // unlock
        std::atomic_fetch_add(&amp;cnt, 1);
        
        // pause
        std::this_thread::sleep_for(1ms);
    }
}

void writer()
{
    for (int n = 0; n &lt; 25; ++n)
    {
        // lock
        while (std::atomic_fetch_sub(&amp;cnt, N + 1) != N)
            std::atomic_fetch_add(&amp;cnt, N + 1);
        
        // write
        data.push_back(n);
        std::cout &lt;&lt; "writer pushed back " &lt;&lt; n &lt;&lt; '\n';
        
        // unlock
        std::atomic_fetch_add(&amp;cnt, N + 1);
        
        // pause
        std::this_thread::sleep_for(1ms);
    }
}
 
int main()
{
    std::vector&lt;std::thread&gt; v;
    for (int n = 0; n &lt; N; ++n)
        v.emplace_back(reader, n);
    v.emplace_back(writer);
    
    for (auto&amp; t : v)
        t.join();
}
|output=
writer pushed back 0
reader 2 sees 0
reader 3 sees 0
reader 1 sees 0
&lt;...&gt;
reader 2 sees 24
reader 4 sees 24
reader 1 sees 24
}}

===Defect reports===
{{dr list begin}}
{{dr list item|std=C++11|paper=P0558R1|before=exact type match was required because&lt;br&gt;{{tt|T}} was deduced from multiple arguments|after={{tt|T}} is only deduced&lt;br&gt;from {{c|obj}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/atomic/atomic/dsc fetch_add}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_sub}}
{{dsc see c|c/atomic/atomic_fetch_add|atomic_fetch_add|atomic_fetch_add_explicit}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}