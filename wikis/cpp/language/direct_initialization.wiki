{{title|Direct-initialization}}
{{cpp/language/initialization/navbar}}
Initializes an object from explicit set of constructor arguments.

===Syntax===
{{sdsc begin}}
{{sdsc|num=1|{{spar|T}} {{spar|object}} {{ttb|(}} {{spar|arg}} {{ttb|);}}
{{spar|T}} {{spar|object}} {{ttb|(}} {{spar|arg1, arg2, ...}} {{ttb|);}}
}}
{{sdsc|num=2|{{spar|T}} {{spar| object}} {{ttb|{}} {{spar|arg}} {{ttb|};}}
|notes={{mark since c++11}}}}
{{sdsc|num=3|{{spar|T}} {{ttb|(}} {{spar|other}} {{ttb|)}}
{{spar|T}} {{ttb|(}} {{spar|arg1, arg2, ...}} {{ttb|)}}}}
{{sdsc|num=4|{{ttb|static_cast&lt;}} {{spar|T}} {{ttb|&gt;(}} {{spar|other}} {{ttb|)}}}}
{{sdsc|num=5|{{ttb|new}} {{spar|T}}{{ttb|(}} {{spar|args, ...}} {{ttb|)}}}}
{{sdsc|num=6|{{spar|Class}}{{ttb|::}}{{spar|Class}}{{ttb|()}} {{ttb|:}} {{spar|member}}{{ttb|(}} {{spar|args, ...}} {{ttb|)}} {{ttb|{}} {{spar|...}} {{ttb|}&lt;!-- --&gt;}}}}
{{sdsc|num=7|{{ttb|[}}{{spar|arg}}{{ttb|]() {}} {{spar|...}} {{ttb|}&lt;!-- --&gt;}}|notes={{mark since c++11}}}}
{{sdsc end}}

===Explanation===
Direct-initialization is performed in the following situations:
@1@ Initialization with a nonempty parenthesized list of expressions {{rev inl|since=c++11|or braced-init-lists}}.
@2@ Initialization of an object of non-class type with a single brace-enclosed initializer {{rev inl|since=c++11|(note: for class types and other uses of braced-init-list, see {{rlp|list initialization|list-initialization}})}}.
@3@ Initialization of {{rev inl|until=c++17|a prvalue temporary}}{{rev inl|since=c++17|the result object of a prvalue}} by {{rlp|explicit cast|function-style cast}} or with a parenthesized expression list.
@4@ Initialization of {{rev inl|until=c++17|a prvalue temporary}}{{rev inl|since=c++17|the result object of a prvalue}} by a {{rlp|static_cast}} expression.
@5@ Initialization of an object with dynamic storage duration by a new-expression with an initializer.
@6@ Initialization of a base or a non-static member by constructor {{rlp|initializer list}}.
@7@ Initialization of closure object members from the variables caught by copy in a lambda-expression.

The effects of direct-initialization are:

* If {{tt|T}} is an array type,
{{rev begin}}
{{rev|until=c++20|
:* the program is ill-formed.
}}
{{rev|since=c++20|
:* the array is initialized as in {{rlp|aggregate initialization}}, except that narrowing conversions are allowed and any elements without an initializer are {{rlp|value initialization|value-initialized}}.
{{source|1=
struct A
{
    explicit A(int i = 0) {}
};

A a[2](A(1)); // OK: initializes a[0] with A(1) and a[1] with A()
A b[2]{A(1)}; // error: implicit copy-list-initialization of b[1]
              //        from {} selected explicit constructor
}}
}}
{{rev end}}

* If {{tt|T}} is a class type, 

{{rev begin}}
{{rev|since=c++17|
:* if the initializer is a {{rlp|value category|prvalue}} expression whose type is the same class as {{tt|T}} (ignoring cv-qualification), the initializer expression itself, rather than a temporary materialized from it, is used to initialize the destination object.&lt;br&gt;(Before C++17, the compiler may elide the construction from the prvalue temporary in this case, but the appropriate constructor must still be accessible: see {{rlp|copy elision}})
}}
{{rev end}}
:* the constructors of {{tt|T}} are examined and the best match is selected by overload resolution. The constructor is then called to initialize the object.
{{rrev|since=c++20|
:* otherwise, if the destination type is a (possibly cv-qualified) aggregate class, it is initialized as described in {{rlp|aggregate initialization}} except that narrowing conversions are permitted, designated initializers are not allowed, a temporary bound to a reference does not have its lifetime extended, there is no brace elision, and any elements without an initializer are {{rlp|value initialization|value-initialized}}.
{{source|1=&lt;!--example from p0960r3--&gt;
struct B
{
    int a;
    int&amp;&amp; r;
};

int f();
int n = 10;

B b1{1, f()};            // OK, lifetime is extended
B b2(1, f());            // well-formed, but dangling reference
B b3{1.0, 1};            // error: narrowing conversion
B b4(1.0, 1);            // well-formed, but dangling reference
B b5(1.0, std::move(n)); // OK
}}
}}
* Otherwise, if {{tt|T}} is a non-class type but the source type is a class type, the conversion functions of the source type and its base classes, if any, are examined and the best match is selected by overload resolution. The selected user-defined conversion is then used to convert the initializer expression into the object being initialized.
* Otherwise, if {{tt|T}} is {{c|bool}} and the source type is {{lc|std::nullptr_t}}, the value of the initialized object is {{c|false}}. &lt;!--- CWG 1781 ---&gt;
* Otherwise, {{rlp|implicit cast|standard conversions}} are used, if necessary, to convert the value of {{spar|other}} to the cv-unqualified version of {{tt|T}}, and the initial value of the object being initialized is the (possibly converted) value.

===Notes===
Direct-initialization is more permissive than copy-initialization: copy-initialization only considers non-{{rlp|explicit}} constructors and non-explicit user-defined {{rlp|cast operator|conversion functions}}, while direct-initialization considers all constructors and all user-defined conversion functions.

In case of ambiguity between a variable declaration using the direct-initialization syntax {{v|1}} (with round parentheses) and a {{rlp|function|function declaration}}, the compiler always chooses function declaration. This disambiguation rule is sometimes counter-intuitive and has been called the {{enwiki|most vexing parse}}.
{{example|code=
#include &lt;fstream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;

int main()
{
    std::ifstream file("data.txt");

    // The following is a function declaration:
    std::string foo1(std::istreambuf_iterator&lt;char&gt;(file),
                     std::istreambuf_iterator&lt;char&gt;());
    // It declares a function called foo1, whose return type is std::string,
    // first parameter has type std::istreambuf_iterator&lt;char&gt; and the name "file",
    // second parameter has no name and has type std::istreambuf_iterator&lt;char&gt;(),
    // which is rewritten to function pointer type std::istreambuf_iterator&lt;char&gt;(*)()
    
    // Pre-C++11 fix (to declare a variable) - add extra parentheses around one
    // of the arguments:
    std::string str1((std::istreambuf_iterator&lt;char&gt;(file)),
                      std::istreambuf_iterator&lt;char&gt;());
    
    // Post-C++11 fix (to declare a variable) - use list-initialization for any
    // of the arguments:
    std::string str2(std::istreambuf_iterator&lt;char&gt;{file}, {});
}
}}

===Example===
{{example
|
|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

struct Foo
{
    int mem;
    explicit Foo(int n) : mem(n) {}
};

int main()
{
    std::string s1("test"); // constructor from const char*
    std::string s2(10, 'a');

    std::unique_ptr&lt;int&gt; p(new int(1));  // OK: explicit constructors allowed
//  std::unique_ptr&lt;int&gt; p = new int(1); // error: constructor is explicit

    Foo f(2); // f is direct-initialized:
              // constructor parameter n is copy-initialized from the rvalue 2
              // f.mem is direct-initialized from the parameter n
//  Foo f2 = 2; // error: constructor is explicit

    std::cout &lt;&lt; s1 &lt;&lt; ' ' &lt;&lt; s2 &lt;&lt; ' ' &lt;&lt; *p &lt;&lt; ' ' &lt;&lt; f.mem  &lt;&lt; '\n';
}
|output=
test aaaaaaaaaa 1 2
}}

===See also===
* {{rlp|copy elision}}
* {{rlp|converting constructor}}
* {{rlp|copy assignment}}
* {{rlp|copy constructor}}
* {{rlp|default constructor}}
* {{rlp|destructor}}
* {{rlpt|explicit}}
* {{rlp|initialization}}
** {{rlp|aggregate initialization}}
** {{rlp|constant initialization}}
** {{rlp|copy initialization}}
** {{rlp|default initialization}}
** {{rlp|initializer list}}
** {{rlp|list initialization}}
** {{rlp|reference initialization}}
** {{rlp|value initialization}}
** {{rlp|zero initialization}}
* {{rlp|move assignment}}
* {{rlp|move constructor}}
* {{rlpt|new}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}