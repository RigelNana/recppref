{{title|Arithmetic operators}}
{{cpp/language/expressions/navbar}}
Returns the result of specific arithmetic operation.

{|class="wikitable"&lt;!--style="font-size:85%;"--&gt;
|-
!rowspan="2"|Operator name
!rowspan="2"|Syntax
!colspan="2"|Prototype examples (for {{c/core|class T}})
|-
!Inside class definition
!Outside class definition
|-
|Unary plus
|{{co|+a}}
|{{c|T T::operator+() const;}}
|{{c|T operator+(const T&amp; a);}}
|-
|Unary minus
|{{co|-a}}
|{{c|T T::operator-() const;}}
|{{c|T operator-(const T&amp; a);}}
|-
|Addition
|{{co|a + b}}
|{{c|T T::operator+(const T2&amp; b) const;}}
|{{c|T operator+(const T&amp; a, const T2&amp; b);}}
|-
|Subtraction
|{{co|a - b}}
|{{c|T T::operator-(const T2&amp; b) const;}}
|{{c|T operator-(const T&amp; a, const T2&amp; b);}}
|-
|Multiplication
|{{co|a * b}}
|{{c|T T::operator*(const T2&amp; b) const;}}
|{{c|T operator*(const T&amp; a, const T2&amp; b);}}
|-
|Division
|{{co|a / b}}
|{{c|T T::operator/(const T2&amp; b) const;}}
|{{c|T operator/(const T&amp; a, const T2&amp; b);}}
|-
|Remainder
|{{co|a % b}}
|{{c|T T::operator%(const T2&amp; b) const;}}
|{{c|T operator%(const T&amp; a, const T2&amp; b);}}
|-
|Bitwise NOT
|{{co|~a}}
|{{c|T T::operator~() const;}}
|{{c|T operator~(const T&amp; a);}}
|-
|Bitwise AND
|{{co|a &amp; b}}
|{{c|T T::operator&amp;(const T2&amp; b) const;}}
|{{c|T operator&amp;(const T&amp; a, const T2&amp; b);}}
|-
|Bitwise OR
|{{co|a {{!}} b}}
|{{c|T T::operator{{!}}(const T2&amp; b) const;}}
|{{c|T operator{{!}}(const T&amp; a, const T2&amp; b);}}
|-
|Bitwise XOR
|{{co|a ^ b}}
|{{c|T T::operator^(const T2&amp; b) const;}}
|{{c|T operator^(const T&amp; a, const T2&amp; b);}}
|-
|Bitwise left shift
|{{co|a &lt;&lt; b}}
|{{c|T T::operator&lt;&lt;(const T2&amp; b) const;}}
|{{c|T operator&lt;&lt;(const T&amp; a, const T2&amp; b);}}
|-
|Bitwise right shift
|{{co|a &gt;&gt; b}}
|{{c|T T::operator&gt;&gt;(const T2&amp; b) const;}}
|{{c|T operator&gt;&gt;(const T&amp; a, const T2&amp; b);}}
|-
|colspan="5"|
:'''Notes'''&lt;br&gt;
* All operators in this table are {{rlp|operators|overloadable}}.
* All built-in operators return values, and most {{rlp|operators|user-defined overloads}} also return values so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including {{c/core|void}}). In particular, stream insertion and stream extraction overloads of {{c/core|operator&lt;&lt;}} and {{c/core|operator&gt;&gt;}} return {{tt|T&amp;}}.
* {{tt|T2}} can be any type including {{tt|T}}.
|}

===General explanation===
All built-in arithmetic operators compute the result of specific arithmetic operation and returns its result. The arguments are not modified.

====Conversions====
If the operand passed to a built-in arithmetic operator is integral or unscoped enumeration type, then before any other action (but after lvalue-to-rvalue conversion, if applicable), the operand undergoes {{rlpsd|implicit conversion#Integral promotion}}. If an operand has array or function type, {{rlp|implicit conversion#Array-to-pointer conversion|array-to-pointer}} and {{rlpsd|implicit conversion#Function-to-pointer}} conversions are applied.

For the binary operators (except shifts), if the promoted operands have different types, {{rlp|usual arithmetic conversions}} are applied.

====Overflows====
Unsigned integer arithmetic is always performed {{math|modulo 2{{su|p=n}}}} where n is the number of bits in that particular integer. E.g. for {{c/core|unsigned int}}, adding one to {{lc|UINT_MAX}} gives {{c|0}}, and subtracting one from {{c|0}} gives {{lc|UINT_MAX}}.

When signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined, — the possible manifestations of such an operation include:
* it wraps around according to the rules of the representation (typically {{rlp|types#Range of values|two's complement}}),
* it traps — on some platforms or due to compiler options (e.g. {{tt|-ftrapv}} in GCC and Clang),
* it saturates to minimal or maximal value (on many DSPs),
* it is completely [https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html optimized out by the compiler].

====Floating-point environment====
If {{ltt|cpp/preprocessor/impl|#pragma STDC FENV_ACCESS}} is supported and set to {{tt|ON}}, all floating-point arithmetic operators obey the current floating-point [[cpp/numeric/fenv/FE_round|rounding direction]] and report floating-point arithmetic errors as specified in {{ltt|cpp/numeric/math/math_errhandling}} unless part of a {{rlp|initialization#Non-local variables|static initializer}} (in which case floating-point exceptions are not raised and the rounding mode is to nearest).

====Floating-point contraction====
Unless {{ltt|cpp/preprocessor/impl|#pragma STDC FP_CONTRACT}} is supported and set to {{tt|OFF}}, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is, optimizations that omit rounding errors and floating-point exceptions are allowed. For example, C++ allows the implementation of {{c|(x * y) + z}} with a single fused multiply-add CPU instruction or optimization of {{c|1=a = x * x * x * x;}} as {{c|1=tmp = x * x; a = tmp * tmp}}. {{mark unreviewed dr|LWG}}&lt;!--confirmed in 2016 by LWG 238--&gt;

Unrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see {{lc|FLT_EVAL_METHOD}}.

Formally, the C++ standard makes no guarantee on the accuracy of floating-point operations.

===Unary arithmetic operators===
The unary arithmetic operator expressions have the form

{{sdsc begin}}
{{sdsc|num=1|{{ttb|+}} {{spar|expression}}}}
{{sdsc|num=2|{{ttb|-}} {{spar|expression}}}}
{{sdsc end}}
@1@ Unary plus (promotion).
@2@ Unary minus (negation).

Unary {{tt|+}} and {{tt|-}} operators have higher {{rlp|operator precedence|precedence}} than all binary arithmetic operators, so {{spar|expression}} cannot contain top-level binary arithmetic operators. These operators associate from right to left:
{{source|
+a - b; // equivalent to (+a) - b, NOT +(a - b)
-c + d; // equivalent to (-c) + d, NOT -(c + d)

+-e; // equivalent to +(-e), the unary + is a no-op if “e” is a built-in type
     // because any possible promotion is performed during negation already
}}

====Built-in unary arithmetic operators====
@1@ For the built-in unary plus operator, {{spar|expression}} must be a prvalue of arithmetic, unscoped enumeration, or pointer type. Integral promotion is performed on {{spar|expression}} if it has integral or unscoped enumeration type. The type of the result is the (possibly promoted) type of {{spar|expression}}.
@@ The result of the built-in promotion is the value of {{spar|expression}}. The built-in unary operation is no-op if the operand is a prvalue of a promoted integral type or a pointer type. Otherwise, the type or value category of the operand is changed by integral promotion or lvalue-to-rvalue, array-to-pointer, function-to-pointer, or user-defined conversion. For example, {{c/core|char}} is converted to {{c/core|int}} {{rev inl|since=c++11|, and non-generic captureless {{rlp|lambda|lambda expression}} is converted to function pointer}} in unary plus expressions.

@2@ For the built-in unary minus operator, {{spar|expression}} must be a prvalue of arithmetic or unscoped enumeration type. Integral promotion is performed on {{spar|expression}}. The type of the result is the type of the promoted type of {{spar|expression}}.
@@ The result of the built-in negation is the negative of the promoted {{spar|expression}}. For unsigned {{c|a}}, the value of {{c|-a}} is {{mathjax-or|\({\small 2^N-a}\)|2{{su|p=N}}-a}}, where {{c|N}} is the number of bits after promotion.
* In other words, the result is the two’s complement of the operand (where operand and result are considered as unsigned).

{{anchor|Overloads of unary arithmetic operators}}

====Overloads====
In {{rlp|overload resolution#Call to an overloaded operator|overload resolution against user-defined operators}}, for every cv-unqualified promoted arithmetic type {{tt|A}} and for every type {{tt|T}}, the following function signatures participate in overload resolution:
{{dcl begin}}
{{dcl|A operator+(A)}}
{{dcl|T* operator+(T*)}}
{{dcl|A operator-(A)}}
{{dcl end}}

{{example
|code=
#include &lt;iostream&gt;

int main()
{
    char c = 0x6a;
    int n1 = 1;
    unsigned char n2 = 1;
    unsigned int n3 = 1;
    std::cout &lt;&lt; "char: " &lt;&lt; c &lt;&lt; " int: " &lt;&lt; +c &lt;&lt; "\n"
                 "-1, where 1 is signed: " &lt;&lt; -n1 &lt;&lt; "\n"
                 "-1, where 1 is unsigned char: " &lt;&lt; -n2 &lt;&lt; "\n"
                 "-1, where 1 is unsigned int: " &lt;&lt; -n3 &lt;&lt; '\n';
    char a[3];
    std::cout &lt;&lt; "size of array: " &lt;&lt; sizeof a &lt;&lt; "\n"
                 "size of pointer: " &lt;&lt; sizeof +a &lt;&lt; '\n';
}
|p=true
|output=
char: j int: 106
-1, where 1 is signed: -1
-1, where 1 is unsigned char: -1
-1, where 1 is unsigned int: 4294967295
size of array: 3
size of pointer: 8
}}

===Additive operators===
The additive operator expressions have the form

{{sdsc begin}}
{{sdsc|num=1|{{spar|lhs}} {{ttb|+}} {{spar|rhs}}}}
{{sdsc|num=2|{{spar|lhs}} {{ttb|-}} {{spar|rhs}}}}
{{sdsc end}}
@1@ Binary plus (addition).
@2@ Binary minus (subtraction).

Binary {{tt|+}} and {{tt|-}} operators have higher {{rlp|operator precedence|precedence}} than all other binary arithmetic operators except {{tt|*}}, {{tt|/}} and {{tt|%}}. These operators associate from left to right:
{{source|
a + b * c;  // equivalent to a + (b * c),  NOT (a + b) * c
d / e - f;  // equivalent to (d / e) - f,  NOT d / (e - f)
g + h &gt;&gt; i; // equivalent to (g + h) &gt;&gt; i, NOT g + (h &gt;&gt; i)

j - k + l - m; // equivalent to ((j - k) + l) - m
}}

====Built-in additive operators====
For built-in binary plus and binary minus operators, both of {{spar|lhs}} and {{spar|rhs}} must be prvalues, and one of the following conditions must be satisfied:
* Both operands have arithmetic or unscoped enumeration type. In this case, {{rlp|usual arithmetic conversions}} are performed on both operands.
* Exactly one operand has integral or unscoped enumeration type. In this case, integral promotion is applied to that operand.

In the remaining description in this section, "operand(s)", {{spar|lhs}} and {{spar|rhs}} refer to the converted or promoted operand(s).

@1@ For built-in addition, one of the following conditions must be satisfied:
* Both operands have arithmetic type. In this case, the result is the sum of the operands.
* One operand is a pointer to a completely-defined object type, and the other operand has integral type. In this case, the integral value is added to the pointer (see {{lsd|#Pointer arithmetic}}).
@2@ For built-in subtraction, one of the following conditions must be satisfied:
* Both operands have arithmetic type. In this case, the result is the difference resulting from the subtraction of {{spar|rhs}} from {{spar|lhs}}.
* {{spar|lhs}} is a pointer to a completely-defined object type, and {{spar|rhs}} has integral type. In this case, the integral value is subtracted from the pointer (see {{lsd|#Pointer arithmetic}}).
* Both operands are pointers to cv-qualified or cv-unqualified versions of the same completely-defined object type. In this case {{spar|rhs}} is subtracted from {{spar|lhs}} (see {{lsd|#Pointer arithmetic}}).

If both operands have a floating-point type, and the type supports IEEE floating-point arithmetic (see {{lc|std::numeric_limits::is_iec559}}):
* If one operand is NaN, the result is NaN.
* Infinity minus infinity is NaN, and {{lc|FE_INVALID}} is raised.
* Infinity plus the negative infinity is NaN, and {{lc|FE_INVALID}} is raised.

====Pointer arithmetic====
When an expression {{c|J}} that has integral type is added to or subtracted from an expression {{c|P}} of pointer type, the result has the type of {{c|P}}.
* If {{c|P}} evaluates to a {{rlp|pointer#Null pointers|null pointer value}} and {{c|J}} evaluates to {{c|0}}, the result is a null pointer value.
* Otherwise, if {{c|P}} points to the {{tt|i}}th element of an array object {{c|x}} with {{c|n}} elements, given the value of {{c|J}} as {{c|j}}, {{c|P}} is added or subtracted as follows:
:* The expressions {{c|P + J}} and {{c|J + P}}
::* point to the {{tt|i+j}}th element of {{c|x}} if {{c|i + j}} is in {{range|0|n}}, and
::* are pointers past the end of the last element of {{c|x}} if {{c|i + j}} is {{c|n}}.
:* The expression {{c|P - J}}
::* points to the {{tt|i-j}}th element of {{c|x}} if {{c|i - j}} is in {{range|0|n}}, and
::* is a pointer past the end of the last element of {{c|x}} if {{c|i - j}} is {{c|n}}.
:* Other {{c|j}} values result in undefined behavior.
* Otherwise, if {{c|P}} points to a complete object, a base class subobject or a member subobject {{c|y}}, given the value of {{c|J}} as {{c|j}}, {{c|P}} is added or subtracted as follows:
:* The expressions {{c|P + J}} and {{c|J + P}}
::* point to {{c|y}} if {{c|j}} is {{c|0}}, and
::* are pointers past the end of {{c|y}} if {{c|j}} is {{c|1}}.
:* The expression {{c|P - J}}
::* points to {{c|y}} if {{c|j}} is {{c|0}}, and
::* is a pointer past the end of {{c|y}} if {{c|j}} is {{c|-1}}.
:* Other {{c|j}} values result in undefined behavior.
* Otherwise, if {{c|P}} is a pointer past the end of an object {{c|z}}, given the value of {{c|J}} as {{c|j}}:
:* If {{c|z}} is an array object with {{c|n}} elements, {{c|P}} is added or subtracted as follows:
::* The expressions {{c|P + J}} and {{c|J + P}}
:::* point to the {{tt|n+j}}th element of {{c|z}} if {{c|n + j}} is in {{range|0|n}}, and
:::* are pointers past the end of the last element of {{c|z}} if {{c|j}} is {{c|0}}.
::* The expression {{c|P - J}}
:::* points to the {{tt|n-j}}th element of {{c|z}} if {{c|n - j}} is in {{range|0|n}}, and
:::* is a pointer past the end of the last element of {{c|z}} if {{c|j}} is {{c|0}}.
::* Other {{c|j}} values result in undefined behavior.
:* Otherwise, {{c|P}} is added or subtracted as follows:
::* The expressions {{c|P + J}} and {{c|J + P}}
:::* point to {{c|z}} if {{c|j}} is {{c|-1}}, and
:::* are pointers past the end of {{c|z}} if {{c|j}} is {{c|0}}.
::* The expression {{c|P - J}}
:::* points to {{c|z}} if {{c|j}} is {{c|1}}, and
:::* is a pointer past the end of {{c|z}} if {{c|j}} is {{c|0}}.
::* Other {{c|j}} values result in undefined behavior.
* Otherwise, the behavior is undefined.

When two pointer expressions {{c|P}} and {{c|Q}} are subtracted, the type of the result is  {{lc|std::ptrdiff_t}}.
* If {{c|P}} and {{c|Q}} both evaluate to {{rlp|pointer#Null pointers|null pointer values}}, the result is {{c|0}}.
* Otherwise, if {{c|P}} and {{c|Q}} point to, respectively, the {{tt|i}}th and {{tt|j}}th array elements of the same array object {{c|x}}, the expression {{c|P - Q}} has the value {{c|i − j}}.
:* If {{c|i − j}} is not representable by {{lc|std::ptrdiff_t}}, the behavior is undefined.
* Otherwise, if {{c|P}} and {{c|Q}} point to the same complete object, base class subobject or member subobject, the result is {{c|0}}.
* Otherwise, the behavior is undefined.

These pointer arithmetic operators allow pointers to satisfy the {{named req|RandomAccessIterator}} requirements.

For addition and subtraction, if {{c|P}} or {{c|Q}} have type “pointer to (possibly cv-qualified) {{tt|T}}”, where {{tt|T}} and the array element type are not {{rlp|implicit conversion#Similar types|similar}}, the behavior is undefined:
{{source|1=
int arr[5] = {1, 2, 3, 4, 5};
unsigned int *p = reinterpret_cast&lt;unsigned int*&gt;(arr + 1);
unsigned int k = *p; // OK, the value of “k” is 2
unsigned int *q = p + 1; // undefined behavior: “p” points to int, not unsigned int
}}

{{anchor|Overloads of additive operators}}
====Overloads====
In {{rlp|overload resolution#Call to an overloaded operator|overload resolution against user-defined operators}}, for every pair of promoted arithmetic types {{tt|L}} and {{tt|R}} and for every object type {{tt|T}}, the following function signatures participate in overload resolution:
{{dcl begin}}
{{dcl|LR operator+(L, R)}}
{{dcl|LR operator-(L, R)}}
{{dcl|T* operator+(T*, std::ptrdiff_t)}}
{{dcl|T* operator+(std::ptrdiff_t, T*)}}
{{dcl|T* operator-(T*, std::ptrdiff_t)}}
{{dcl|std::ptrdiff_t operator-(T*, T*)}}
{{dcl end}}
where {{tt|LR}} is the result of {{rlp|usual arithmetic conversions}} on {{tt|L}} and {{tt|R}}.

{{example
|code=
#include &lt;iostream&gt;

int main()
{
    char c = 2;
    unsigned int un = 2;
    int n = -10;
    std::cout &lt;&lt; " 2 + (-10), where 2 is a char    = " &lt;&lt; c + n &lt;&lt; "\n"
                 " 2 + (-10), where 2 is unsigned  = " &lt;&lt; un + n &lt;&lt; "\n"
                 " -10 - 2.12  = " &lt;&lt; n - 2.12 &lt;&lt; '\n';

    char a[4] = {'a', 'b', 'c', 'd'};
    char* p = &amp;a[1];
    std::cout &lt;&lt; "Pointer addition examples: " &lt;&lt; *p &lt;&lt; *(p + 2)
              &lt;&lt; *(2 + p) &lt;&lt; *(p - 1) &lt;&lt; '\n';
    char* p2 = &amp;a[4];
    std::cout &lt;&lt; "Pointer difference: " &lt;&lt; p2 - p &lt;&lt; '\n';
}
|output=&lt;nowiki/&gt;
 2 + (-10), where 2 is a char    = -8
 2 + (-10), where 2 is unsigned  = 4294967288
 -10 - 2.12  = -12.12
Pointer addition examples: bdda
Pointer difference: 3
}}

====Multiplicative operators====
The multiplicative operator expressions have the form

{{sdsc begin}}
{{sdsc|num=1|{{spar|lhs}} {{ttb|*}} {{spar|rhs}}}}
{{sdsc|num=2|{{spar|lhs}} {{ttb|/}} {{spar|rhs}}}}
{{sdsc|num=3|{{spar|lhs}} {{ttb|%}} {{spar|rhs}}}}
{{sdsc end}}
@1@ Multiplication.
@2@ Division.
@3@ Remainder.

Multiplicative operators have higher {{rlp|operator precedence|precedence}} than all other binary arithmetic operators. These operators associate from left to right:
{{source|
a + b * c;  // equivalent to a + (b * c),  NOT (a + b) * c
d / e - f;  // equivalent to (d / e) - f,  NOT d / (e - f)
g % h &gt;&gt; i; // equivalent to (g % h) &gt;&gt; i, NOT g % (h &gt;&gt; i)

j * k / l % m; // equivalent to ((j * k) / l) % m
}}

====Built-in multiplicative operators====
For built-in multiplication and division operators, both operands must have arithmetic or unscoped enumeration type. For the built-in remainder operator, both operands must have integral or unscoped enumeration type. {{rlp|usual arithmetic conversions|Usual arithmetic conversions}} are performed on both operands.

In the remaining description in this section, "operand(s)", {{spar|lhs}} and {{spar|rhs}} refer to the converted operand(s).

@1@ The result of built-in multiplication is the product of the operands.
@@ If both operands have a floating-point type, and the type supports IEEE floating-point arithmetic (see {{lc|std::numeric_limits::is_iec559}}):
* Multiplication of a NaN by any number gives NaN.
* Multiplication of infinity by zero gives NaN and {{lc|FE_INVALID}} is raised.

@2@ The result of built-in division is {{spar|lhs}} divided by {{spar|rhs}}. If {{spar|rhs}} is zero, the behavior is undefined.
@@ If both operands have an integral type, the result is the algebraic quotient (performs integer division): the quotient is truncated towards zero (fractional part is discarded).
@@ If both operands have a floating-point type, and the type supports IEEE floating-point arithmetic (see {{lc|std::numeric_limits::is_iec559}}):
* If one operand is NaN, the result is NaN.
* Dividing a non-zero number by ±0.0 gives the correctly-signed infinity and {{lc|FE_DIVBYZERO}} is raised.
* Dividing 0.0 by 0.0 gives NaN and {{lc|FE_INVALID}} is raised.

@3@ The result of built-in remainder is the remainder of the integer division of {{spar|lhs}} by {{spar|rhs}}. If {{spar|rhs}} is zero, the behavior is undefined.
@@ If {{c|a / b}} is representable in the result type, {{c|1=(a / b) * b + a % b == a}}.
@@ If {{c|a / b}} is not representable in the result type, the behavior of both {{c|a / b}} and {{c|a % b}} is undefined (that means {{c|INT_MIN % -1}} is undefined on two's complement systems).

Note: Until {{cwg|614}} was resolved ({{stddoc|n2757}}), if one or both operands to binary operator % were negative, the sign of the remainder was implementation-defined, as it depends on the rounding direction of integer division. The function {{lc|std::div}} provided well-defined behavior in that case.

Note: for floating-point remainder, see {{lc|std::remainder}} and {{lc|std::fmod}}.

{{anchor|Overloads of multiplicative operators}}
====Overloads====
In {{rlp|overload resolution#Call to an overloaded operator|overload resolution against user-defined operators}}, for every pair of promoted arithmetic types {{tt|LA}} and {{tt|RA}} and for every pair of promoted integral types {{tt|LI}} and {{tt|RI}} the following function signatures participate in overload resolution:
{{dcl begin}}
{{dcl|LRA operator*(LA, RA)}}
{{dcl|LRA operator/(LA, RA)}}
{{dcl|LRI operator%(LI, RI)}}
{{dcl end}}
where {{tt|LRx}} is the result of {{rlp|usual arithmetic conversions}} on {{tt|Lx}} and {{tt|Rx}}.

{{example
|code=
#include &lt;iostream&gt;

int main()
{
    char c = 2;
    unsigned int un = 2;
    int  n = -10;
    std::cout &lt;&lt; "2 * (-10), where 2 is a char    = " &lt;&lt; c * n &lt;&lt; "\n"
                 "2 * (-10), where 2 is unsigned  = " &lt;&lt; un * n &lt;&lt; "\n"
                 "-10 / 2.12  = " &lt;&lt; n / 2.12 &lt;&lt; "\n"
                 "-10 / 21  = " &lt;&lt; n / 21 &lt;&lt; "\n"
                 "-10 % 21  = " &lt;&lt; n % 21 &lt;&lt; '\n';
}
|output=
2 * (-10), where 2 is a char    = -20
2 * (-10), where 2 is unsigned  = 4294967276
-10 / 2.12  = -4.71698
-10 / 21  = 0
-10 % 21  = -10
}}

===Bitwise logic operators===
The bitwise logic operator expressions have the form

{{sdsc begin}}
{{sdsc|num=1|{{ttb|~}} {{spar|rhs}}}}
{{sdsc|num=2|{{spar|lhs}} {{ttb|&amp;}} {{spar|rhs}}}}
{{sdsc|num=3|{{spar|lhs}} {{ttb|{{!}}}} {{spar|rhs}}}}
{{sdsc|num=4|{{spar|lhs}} {{ttb|^}} {{spar|rhs}}}}
{{sdsc end}}
@1@ Bitwise NOT.
@2@ Bitwise AND.
@3@ Bitwise OR.
@4@ Bitwise XOR.

The bitwise NOT operator has higher {{rlp|operator precedence|precedence}} than all binary arithmetic operators. It associates from right to left:
{{source|
~a - b; // equivalent to (~a) - b, NOT ~(a - b)
~c * d; // equivalent to (~c) * d, NOT ~(c * d)

~-e; // equivalent to ~(-e)
}}

There is an ambiguity in the grammar when {{c|~}} is followed by a {{rlp|type#type naming|type name}}{{rev inl|since=c++11| or {{rlpt|decltype}} specifier}}: it can either be operator~ or start a {{rlp|destructor}} identifier). The ambiguity is resolved by treating {{c|~}} as operator~. {{c|~}} can start a destructor identifier only in places where forming an operator~ is syntactically invalid.

All other bitwise logic operators have lower {{rlp|operator precedence|precedence}} than all other binary arithmetic operators. Bitwise AND has higher precedence than bitwise XOR, which has higher precedence than bitwise OR. They associate from left to right:
{{source|
a &amp; b * c;  // equivalent to a &amp; (b * c),  NOT (a &amp; b) * c
d / e ^ f;  // equivalent to (d / e) ^ f,  NOT d / (e ^ f)
g &lt;&lt; h {{!}} i; // equivalent to (g &lt;&lt; h) {{!}} i, NOT g &lt;&lt; (h {{!}} i)

j &amp; k &amp; l; // equivalent to (j &amp; k) &amp; l
m {{!}} n ^ o  // equivalent to m {{!}} (n ^ o)
}}

====Built-in bitwise logic operators====
For the built-in bitwise NOT operator, {{spar|rhs}} must be a prvalue of integral or unscoped enumeration type, and integral promotion is performed on {{spar|rhs}}. For other built-in bitwise logic operators, both operands must have integral or unscoped enumeration type, and {{rlp|usual arithmetic conversions}} are performed on both operands.

In the remaining description in this section, "operand(s)", {{spar|lhs}} and {{spar|rhs}} refer to the converted or promoted operand(s).

@1@ Given the operand as {{c|x}} and the result of the built-in bitwise NOT operation as {{c|r}}. For each coefficient {{c|x_i}} of the base-2 representation of {{c|x}}, the corresponding coefficient {{c|r_i}} of the base-2 representation of {{c|r}} is {{c|1}} if {{c|x_i}} is {{c|0}}, and {{c|0}} otherwise.
* In other words, the result is the one’s complement of the operand (where operand and result are considered as unsigned).
@@ The type of the result {{c|r}} is the type of the operand {{c|x}}.

@2-4@ Given the operands as {{c|x}} and {{c|y}} respectively and the result of the built-in binary bitwise logic operations as {{c|r}}. For each pair of coefficients {{c|x_i}} and {{c|y_i}} of the base-2 representations of {{c|x}} and {{c|y}} respectively, the corresponding coefficient {{c|r_i}} of the base-2 representation of {{c|r}} is
:@2@ {{c|1}} if both {{c|x_i}} and {{c|y_i}} are {{c|1}}, and {{c|0}} otherwise.
:@3@ {{c|1}} if at least one of {{c|x_i}} and {{c|y_i}} is {{c|1}}, and {{c|0}} otherwise.
:@4@ {{c|1}} if either (but not both) of {{c|x_i}} and {{c|y_i}} is {{c|1}}, and {{c|0}} otherwise.
@@ The type of the result {{c|r}} is the type of the operands {{c|x}} and {{c|y}}.

{{anchor|Overloads of bitwise logic operators}}
====Overloads====
In {{rlp|overload resolution#Call to an overloaded operator|overload resolution against user-defined operators}}, for every pair of promoted integral types {{tt|L}} and {{tt|R}} the following function signatures participate in overload resolution:
{{dcl begin}}
{{dcl|R operator~(R)}}
{{dcl|LR operator&amp;(L, R)}}
{{dcl|LR operator^(L, R)}}
{{dcl|LR operator{{!}}(L, R)}}
{{dcl end}}
where {{tt|LR}} is the result of {{rlp|usual arithmetic conversions}} on {{tt|L}} and {{tt|R}}.

{{example
|code=
#include &lt;bitset&gt;
#include &lt;cstdint&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;

int main()
{
    std::uint16_t mask = 0x00f0;
    std::uint32_t x0 = 0x12345678;
    std::uint32_t x1 = x0 {{!}} mask;
    std::uint32_t x2 = x0 &amp; ~mask;
    std::uint32_t x3 = x0 &amp; mask;
    std::uint32_t x4 = x0 ^ mask;
    std::uint32_t x5 = ~x0;
    using bin16 = std::bitset&lt;16&gt;;
    using bin32 = std::bitset&lt;32&gt;;
    std::cout &lt;&lt; std::hex &lt;&lt; std::showbase
              &lt;&lt; "Mask: " &lt;&lt; mask &lt;&lt; std::setw(49) &lt;&lt; bin16(mask) &lt;&lt; "\n"
                 "Value: " &lt;&lt; x0 &lt;&lt; std::setw(42) &lt;&lt; bin32(x0) &lt;&lt; "\n"
                 "Setting bits: " &lt;&lt; x1 &lt;&lt; std::setw(35) &lt;&lt; bin32(x1) &lt;&lt; "\n"
                 "Clearing bits: " &lt;&lt; x2 &lt;&lt; std::setw(34) &lt;&lt; bin32(x2) &lt;&lt; "\n"
                 "Selecting bits: " &lt;&lt; x3 &lt;&lt; std::setw(39) &lt;&lt; bin32(x3) &lt;&lt; "\n"
                 "XOR-ing bits: " &lt;&lt; x4 &lt;&lt; std::setw(35) &lt;&lt; bin32(x4) &lt;&lt; "\n"
                 "Inverting bits: " &lt;&lt; x5 &lt;&lt; std::setw(33) &lt;&lt; bin32(x5) &lt;&lt; '\n';
}
|output=
Mask: 0xf0                                 0000000011110000
Value: 0x12345678          00010010001101000101011001111000
Setting bits: 0x123456f8   00010010001101000101011011111000
Clearing bits: 0x12345608  00010010001101000101011000001000
Selecting bits: 0x70       00000000000000000000000001110000
XOR-ing bits: 0x12345688   00010010001101000101011010001000
Inverting bits: 0xedcba987 11101101110010111010100110000111
}}

===Bitwise shift operators===
The bitwise shift operator expressions have the form

{{sdsc begin}}
{{sdsc|num=1|{{spar|lhs}} {{ttb|&lt;&lt;}} {{spar|rhs}}}}
{{sdsc|num=2|{{spar|lhs}} {{ttb|&gt;&gt;}} {{spar|rhs}}}}
{{sdsc end}}
@1@ Bitwise left-shift.
@2@ Bitwise right-shift.

Bitwise shift operators have higher {{rlp|operator precedence|precedence}} than bitwise logic operators, but have lower precedence than additive and multiplicative operators. These operators associate from left to right:
{{source|
a &gt;&gt; b * c;  // equivalent to a &gt;&gt; (b * c),  NOT (a &gt;&gt; b) * c
d &lt;&lt; e &amp; f;  // equivalent to (d &lt;&lt; e) &amp; f,  NOT d &lt;&lt; (e &amp; f)

g &lt;&lt; h &gt;&gt; i; // equivalent to (g &lt;&lt; h) &gt;&gt; i, NOT g &lt;&lt; (h &gt;&gt; i)
}}

====Built-in bitwise shift operators====
For the built-in bitwise shift operators, both operands must be prvalues of integral or unscoped enumeration type. Integral promotions are performed on both operands.

In the remaining description in this section, "operand(s)", {{c|a}}, {{c|b}}, {{spar|lhs}} and {{spar|rhs}} refer to the converted or promoted operand(s).

If the value of {{spar|rhs}} is negative or is not less than the number of bits in {{spar|lhs}}, the behavior is undefined.

{{rrev multi|until1=c++20|rev1=
For unsigned {{c|a}}, the value of {{c|a &lt;&lt; b}} is the value of {{math|a * 2{{su|p=b}}}}, reduced modulo {{math|2{{su|p=N}}}} where N is the number of bits in the return type (that is, bitwise left shift is performed and the bits that get shifted out of the destination type are discarded).

For signed and non-negative {{c|a}}, if {{math|a * 2{{su|p=b}}}} is representable in the unsigned version of the return type, then that value, {{rlp|implicit conversion#Integral conversions|converted}} to signed, is the value of {{c|a &lt;&lt; b}} (this makes it legal to create {{lc|INT_MIN}} as {{c|1 &lt;&lt; 31}}); otherwise the behavior is undefined.

For negative {{c|a}}, the behavior of {{c|a &lt;&lt; b}} is undefined.

For unsigned {{c|a}} and for signed and non-negative {{c|a}}, the value of {{c|a &gt;&gt; b}} is the integer part of {{math|a/2{{su|p=b}}}}.

For negative {{c|a}}, the value of {{c|a &gt;&gt; b}} is implementation-defined (in most implementations, this performs arithmetic right shift, so that the result remains negative).
|rev2=
The value of {{c|a &lt;&lt; b}} is the unique value congruent to {{math|a * 2{{su|p=b}}}} modulo {{math|2{{su|p=N}}}} where N is the number of bits in the return type (that is, bitwise left shift is performed and the bits that get shifted out of the destination type are discarded).

The value of {{c|a &gt;&gt; b}} is {{math|a/2{{su|p=b}}}}, rounded towards negative infinity (in other words, right shift on signed {{c|a}} is arithmetic right shift).
}}

The type of the result is that of {{spar|lhs}}.

{{anchor|Overloads of bitwise shift operators}}
====Overloads====
In {{rlp|overload resolution#Call to an overloaded operator|overload resolution against user-defined operators}}, for every pair of promoted integral types {{tt|L}} and {{tt|R}}, the following function signatures participate in overload resolution:
{{dcl begin}}
{{dcl|L operator&lt;&lt;(L, R)}}
{{dcl|L operator&gt;&gt;(L, R)}}
{{dcl end}}

{{example
|code=
#include &lt;iostream&gt;

enum { ONE = 1, TWO = 2 };

int main()
{
    std::cout &lt;&lt; std::hex &lt;&lt; std::showbase;
    char c = 0x10;
    unsigned long long ull = 0x123;
    std::cout &lt;&lt; "0x123 &lt;&lt; 1 = " &lt;&lt; (ull &lt;&lt; 1) &lt;&lt; "\n"
                 "0x123 &lt;&lt; 63 = " &lt;&lt; (ull &lt;&lt; 63) &lt;&lt; "\n" // overflow in unsigned
                 "0x10 &lt;&lt; 10 = " &lt;&lt; (c &lt;&lt; 10) &lt;&lt; '\n';   // char is promoted to int
    long long ll = -1000;
    std::cout &lt;&lt; std::dec &lt;&lt; "-1000 &gt;&gt; 1 = " &lt;&lt; (ll &gt;&gt; ONE) &lt;&lt; '\n';
}
|output=
0x123 &lt;&lt; 1 = 0x246
0x123 &lt;&lt; 63 = 0x8000000000000000
0x10 &lt;&lt; 10 = 0x4000
-1000 &gt;&gt; 1 = -500
}}

===Standard library===
Arithmetic operators are overloaded for many standard library types.

====Unary arithmetic operators====
{{dsc begin}}
{{dsc inc|cpp/chrono/duration/dsc operator arith}}
{{dsc inc|cpp/numeric/complex/dsc operator arith2}}
{{dsc inc|cpp/numeric/valarray/dsc operator arith}}
{{dsc end}}

====Additive operators====
{{dsc begin}}
{{dsc inc|cpp/chrono/time_point/dsc operator arith2}}
{{dsc inc|cpp/chrono/duration/dsc operator arith4}}
{{dsc inc|cpp/chrono/year_month_day/dsc operator arith 2}}
{{dsc inc|cpp/string/basic_string/dsc operator+}}
{{dsc mem fun|cpp/iterator/reverse_iterator/operator arith|title=operator+&lt;br&gt;operator-|advances or decrements the iterator}}
{{dsc mem fun|cpp/iterator/move_iterator/operator arith|title=operator+&lt;br&gt;operator-|advances or decrements the iterator}}
{{dsc inc|cpp/numeric/complex/dsc operator arith3}}
{{dsc inc|cpp/numeric/valarray/dsc operator arith3}}
{{dsc end}}

====Multiplicative operators====
{{dsc begin}}
{{dsc inc|cpp/chrono/duration/dsc operator arith4}}
{{dsc inc|cpp/numeric/complex/dsc operator arith3}}
{{dsc inc|cpp/numeric/valarray/dsc operator arith3}}
{{dsc end}}

====Bitwise logic operators====
{{dsc begin}}
{{dsc inc|cpp/utility/bitset/dsc operator logic}}
{{dsc inc|cpp/utility/bitset/dsc operator logic2}}
{{dsc mem fun|cpp/numeric/valarray/operator arith|title=operator~|applies a unary arithmetic operator to each element of the valarray}}
{{dsc tfun|cpp/numeric/valarray/operator arith3|title=operator^&lt;br&gt;operator&amp;&lt;br&gt;operator{{!}}|applies binary operators to each element of two valarrays, or a valarray and a value}}
{{dsc end}}

====Bitwise shift operators====
{{dsc begin}}
{{dsc tfun|cpp/numeric/valarray/operator arith3|title=operator&lt;&lt;&lt;br&gt;operator&gt;&gt;|applies binary operators to each element of two valarrays, or a valarray and a value}}
{{dsc mem fun|cpp/utility/bitset/operator ltltgtgt|title=operator&lt;&lt;&lt;br&gt;operator&gt;&gt;|performs binary shift left and shift right}}
{{dsc end}}

====Stream insertion/extraction operators====
Throughout the standard library, bitwise shift operators are commonly overloaded with I/O stream ({{c/core|std::ios_base&amp;}} or one of the classes derived from it) as both the left operand and return type. Such operators are known as ''stream insertion'' and ''stream extraction'' operators:

{{dsc begin}}
{{dsc inc|cpp/io/basic_istream/dsc operator gtgt}}
{{dsc inc|cpp/io/basic_istream/dsc operator gtgt2}}
{{dsc inc|cpp/io/basic_ostream/dsc operator ltlt}}
{{dsc inc|cpp/io/basic_ostream/dsc operator ltlt2}}
{{dsc inc|cpp/numeric/complex/dsc operator ltltgtgt}}
{{dsc inc|cpp/utility/bitset/dsc operator ltltgtgt2}}
{{dsc inc|cpp/string/basic_string/dsc operator ltltgtgt}}
{{dsc inc|cpp/numeric/random/engine/dsc operator ltltgtgt|linear_congruential_engine}}
{{dsc inc|cpp/numeric/random/distribution/dsc operator ltltgtgt|uniform_int_distribution}}
{{dsc end}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=614|std=C++98|before=the algebraic quotient of integer division was&lt;br&gt;rounded in implementation-defined direction|after=the algebraic quotient of integer&lt;br&gt;division is truncated towards zero&lt;br&gt;(fractional part is discarded)}}
{{dr list item|wg=cwg|dr=1450|std=C++98|before=the result of {{c|a / b}} was unspecified if&lt;br&gt;it is not representable in the result type|after=the behavior of both {{c|a / b}} and&lt;br&gt;{{c|a % b}} is undefined in this case}}
{{dr list item|wg=cwg|dr=1457|std=C++98|before=the behavior of shifting the leftmost {{tt|1}} bit of a&lt;br&gt;positive signed value into the sign bit was undefined|after=made well-defined}}
{{dr list item|wg=cwg|dr=1504|std=C++98|before=a pointer to a base class subobject of an array&lt;br&gt;element could be used in pointer arithmetic|after=the behavior is&lt;br&gt;undefined in this case}}
{{dr list item|wg=cwg|dr=1515|std=C++98|before=only unsigned integers which declared {{c/core|unsigned}} &lt;br&gt;should obey the laws of arithmetic {{math|modulo 2{{su|p=n}}}}|after=applies to all unsigned integers}}
{{dr list item|wg=cwg|dr=1642|std=C++98|before=arithmetic operators allow their operands to be lvalues|after=some operands must be rvalues}}
{{dr list item|wg=cwg|dr=1865|std=C++98|before=the resolution of {{cwg|1504}} made the behaviors&lt;br&gt;of pointer arithmetic involving pointers to array element&lt;br&gt;undefined if the pointed-to type and the array element&lt;br&gt;type have different cv-qualifications in non-top levels|after=made well-defined}}
{{dr list item|wg=cwg|dr=1971|std=C++98|before=it was unclear whether the rule resolving the&lt;br&gt;ambiguity of {{c|~}} applies to cases such as {{c|~X(0)}}|after=the rule applies to such cases}}
{{dr list item|wg=cwg|dr=2419|std=C++98|before=a pointer to non-array object was only treated as a&lt;br&gt;pointer to the first element of an array with size 1&lt;br&gt;in pointer arithmetic if the pointer is obtained by {{c|&amp;}}|after=applies to all pointers&lt;br&gt;to non-array objects}}
{{dr list item|wg=cwg|dr=2626|std=C++98|before=the result of built-in {{tt|operator~}} was simply&lt;br&gt;'one's complement' without proper definition|after=the result is phrased in terms&lt;br&gt;of the base-2 representation}}
{{dr list item|wg=cwg|dr=2724|std=C++20|before=the rounding direction of arithmetic right shift was unclear|after=made clear}}
{{dr list item|wg=cwg|dr=2853|std=C++98|before=a pointer past the end of an object could&lt;br&gt;not be added or subtracted with an integer|after=it can}}
{{dr list end}}

===See also===
{{rlp|operator precedence|Operator precedence}}

{{rlp|operators|Operator overloading}}

{{cpp/language/operators}}
{{dsc begin}}
{{dsc see c|c/language/operator arithmetic|Arithmetic operators|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}