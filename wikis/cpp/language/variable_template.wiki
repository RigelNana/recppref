{{title|Variable template {{mark since c++14}}}}
{{cpp/language/declarations/expressions/templates/navbar}}

A variable template defines a family of variables or static data members.

===Syntax===
{{sdsc begin}}
{{sdsc|num=1|{{ttb|template}} {{ttb|&lt;}} {{spar|parameter-list}} {{ttb|&gt;}} {{spar|variable-declaration}}}}
{{sdsc|num=2|notes={{mark since c++20}}|{{ttb|template}} {{ttb|&lt;}} {{spar|parameter-list}} {{ttb|&gt;}} {{ttb|requires}} {{spar|constraint}} {{spar|variable-declaration}}}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|variable-declaration}}|a {{rlp|declarations|declaration}} of a variable. The declared variable name becomes a template name.}}
{{par|{{spar|parameter-list}}|a non-empty comma-separated list of the {{rlp|template parameters}}, each of which is either {{rlp|template parameters#Non-type template parameter|non-type parameter}}, a {{rlp|template parameters#Type template parameter|type parameter}}, a {{rlp|template parameters#Template template parameter|template parameter}}, or a {{rlp|parameter pack}} of any of those.}}
{{par|{{spar|constraint}}|a {{rlp|constraints|constraint expression}} which restricts the template parameters accepted by this variable template}}
{{par end}}

===Explanation===
A variable instantiated from a variable template is called an ''instantiated variable''. A static data member instantiated from a static data member template is called an ''instantiated static data member''.

A variable template may be introduced by a template declaration at namespace scope, where {{spar|variable-declaration}} declares a variable.

{{source|1=
template&lt;class T&gt;
constexpr T pi = T(3.1415926535897932385L); // variable template

template&lt;class T&gt;
T circular_area(T r) // function template
{
    return pi&lt;T&gt; * r * r; // pi&lt;T&gt; is a variable template instantiation
}
}}

When used at class scope, variable template declares a static data member template.

{{source|1=
using namespace std::literals;
struct matrix_constants
{
    template&lt;class T&gt;
    using pauli = hermitian_matrix&lt;T, 2&gt;; // alias template

    template&lt;class T&gt; // static data member template
    static constexpr pauli&lt;T&gt; sigmaX = {&lt;!----&gt;{0, 1}, {1, 0}&lt;!----&gt;};

    template&lt;class T&gt;
    static constexpr pauli&lt;T&gt; sigmaY = {&lt;!----&gt;{0, -1i}, {1i, 0}&lt;!----&gt;};

    template&lt;class T&gt;
    static constexpr pauli&lt;T&gt; sigmaZ = {&lt;!----&gt;{1, 0}, {0, -1}&lt;!----&gt;};
};
}}

As with other {{rlp|static|static members}}, a definition of a static data member template may be required. Such definition is provided outside the class definition. A template declaration of a static data member at namespace scope may also be a definition of a non-template {{rlp|member template|data member of a class template}}:

{{source|1=
struct limits
{
    template&lt;typename T&gt;
    static const T min; // declaration of a static data member template
};

template&lt;typename T&gt;
const T limits::min = { }; // definition of a static data member template

template&lt;class T&gt;
class X
{
    static T s; // declaration of a non-template static data member of a class template
};

template&lt;class T&gt;
T X&lt;T&gt;::s = 0; // definition of a non-template data member of a class template
}}

Unless a variable template was {{rlp|template specialization|explicitly specialized}} or explicitly instantiated, it is implicitly instantiated when a specialization of the variable template is referenced in a context that requires {{rlp|definition#ODR-use|a variable definition to exist}} &lt;!-- P0859R0 --&gt;or if the existence of the definition affects the semantics of the program, i.e. if the variable is {{rlp|constant expression#Functions and variables needed for constant evaluation|needed for constant evaluation}} by an expression (the definition may be not used).

The existence of a definition of a variable is considered to affect the semantics of the program if the variable is needed for constant evaluation by an expression, even if constant evaluation of the expression is not required or if constant expression evaluation does not use the definition.

===Notes===
Until variable templates were introduced in C++14, parametrized variables were typically implemented as either static data members of class templates or as constexpr function templates returning the desired values.

Variable templates cannot be used as {{rlpsd|template parameters#Template template arguments}}.
{{feature test macro|__cpp_variable_templates|Variable templates|value=201304L|std=C++14}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=2255|std=C++14|before=it was unclear whether a specialization of a static&lt;br&gt;data member template is a static data member|after=it is}}
{{dr list end}}

{{langlinks|es|ja|ru|zh}}