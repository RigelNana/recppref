{{title|Multi-threaded executions and data races {{mark since c++11}}}}
{{cpp/language/basics/navbar}}

A ''thread of execution'' is a flow of control within a program that begins with the invocation of a specific top-level function (by {{lc|std::thread}}, {{lc|std::async}}{{rev inl|since=c++20|, {{lc|std::jthread}}}} or other means), and recursively including every function invocation subsequently executed by the thread.
* When one thread creates another, the initial call to the top-level function of the new thread is executed by the new thread, not by the creating thread.

Any thread can potentially access any object and function in the program:
* Objects with automatic and thread-local {{rlp|storage duration}} may still be accessed by another thread through a pointer or by reference.
* Under a [[cpp/freestanding|hosted implementation]], a C++ program can have more than one thread running concurrently. The execution of each thread proceeds as defined by the rest of this page. The execution of the entire program consists of an execution of all of its threads.
* Under a [[cpp/freestanding|freestanding implementation]], it is implementation-defined whether a program can have more than one thread of execution.

For a {{lsd|cpp/utility/program/signal#Signal handler}} that is not executed as a result of a call to {{lc|std::raise}}, it is unspecified which thread of execution contains the signal handler invocation.

===Data races===
Different threads of execution are always allowed to access (read and modify) different {{rlpsd|memory model#Memory location}}s concurrently, with no interference and no synchronization requirements.

Two expression {{rlp|eval order|evaluations}} ''conflict'' if one of them modifies a memory location or starts/ends the lifetime of an object in a memory location, and the other one reads or modifies the same memory location or starts/ends the lifetime of an object occupying storage that overlaps with the memory location.

A program that has two conflicting evaluations has a ''data race'' unless
* both evaluations execute on the same thread or in the same {{lsd|cpp/utility/program/signal#Signal handler}}, or
* both conflicting evaluations are atomic operations (see {{lc|std::atomic}}), or
* one of the conflicting evaluations ''happens-before'' another (see {{lc|std::memory_order}}).

If a data race occurs, the behavior of the program is undefined.

(In particular, release of a {{lc|std::mutex}} is ''synchronized-with'', and therefore, ''happens-before'' acquisition of the same mutex by another thread, which makes it possible to use mutex locks to guard against data races.)

{{source|1=
int cnt = 0;
auto f = [&amp;] { cnt++; };
std::thread t1{f}, t2{f}, t3{f}; // undefined behavior
}}
{{source|1=
std::atomic&lt;int&gt; cnt{0};
auto f = [&amp;] { cnt++; };
std::thread t1{f}, t2{f}, t3{f}; // OK
}}

====Container data races====
All [[cpp/container|containers]] in the standard library except [[cpp/container/vector bool|{{tt|std}}{{c/core|::vector&lt;bool&gt;}}]] guarantee that concurrent modifications on contents of the contained object in different elements in the same container will never result in data races.

{{source|1=
std::vector&lt;int&gt; vec = {1, 2, 3, 4};
auto f = [&amp;](int index) { vec[index] = 5; };
std::thread t1{f, 0}, t2{f, 1}; // OK
std::thread t3{f, 2}, t4{f, 2}; // undefined behavior
}}
{{source|1=
std::vector&lt;bool&gt; vec = {false, false};
auto f = [&amp;](int index) { vec[index] = true; };
std::thread t1{f, 0}, t2{f, 1}; // undefined behavior
}}

===Memory order===
When a thread reads a value from a memory location, it may see the initial value, the value written in the same thread, or the value written in another thread. See {{lc|std::memory_order}} for details on the order in which writes made from threads become visible to other threads.

===Forward progress===
====Obstruction freedom====
When only one thread that is not blocked in a standard library function executes an [[cpp/thread#Atomic operations|atomic function]] that is lock-free, that execution is guaranteed to complete (all standard library lock-free operations are {{enwiki|Non-blocking algorithm#Obstruction-freedom|obstruction-free}}).

====Lock freedom====
When one or more lock-free atomic functions run concurrently, at least one of them is guaranteed to complete (all standard library lock-free operations are {{enwiki|Non-blocking algorithm#Lock-freedom|lock-free}} — it is the job of the implementation to ensure they cannot be live-locked indefinitely by other threads, such as by continuously stealing the cache line).

====Progress guarantee====
In a valid C++ program, every thread eventually does one of the following:
* Terminates.
* Invokes {{lc|std::this_thread::yield}}.
* Makes a call to an library I/O function.
* Performs an access through a {{rlp|cv|volatile}} glvalue.
* Performs an atomic operation or a synchronization operation.
* Continues execution of a trivial infinite loop (see below).

A thread is said to ''make progress'' if it performs one of the execution steps above, blocks in a standard library function, or calls an atomic lock-free function that does not complete because of a non-blocked concurrent thread.

This allows the compilers to remove, merge and reorder all loops that have no observable behavior, without having to prove that they would eventually terminate because it can assume that no thread of execution can execute forever without performing any of these observable behaviors. An affordance is made for trivial infinite loops, which cannot be removed nor reordered.

====Trivial infinite loops====
A ''trivially empty iteration statement'' is an iteration statement matching one of the following forms:

{{sdsc begin}}
{{sdsc|num=1|
{{ttb|while (}} {{spar|condition}} {{ttb|) ;}}
}}
{{sdsc|num=2|
{{ttb|while (}} {{spar|condition}} {{ttb|) { }&lt;!----&gt;}}
}}
{{sdsc|num=3|
{{ttb|do ; while (}} {{spar|condition}} {{ttb|) ;}} 
}}
{{sdsc|num=4|
{{ttb|do { } while (}} {{spar|condition}} {{ttb|) ;}} 
}}
{{sdsc|num=5|
{{ttb|for (}} {{spar optional|init-statement condition}} {{ttb|; ) ;}}
}}
{{sdsc|num=6|
{{ttb|for (}} {{spar optional|init-statement condition}} {{ttb|; ) { }&lt;!----&gt;}}
}}
{{sdsc end}}

@1@ A {{rlp|while|{{c/core|while}} statement}} whose loop body is an empty simple statement.

@2@ A {{rlp|while|{{c/core|while}} statement}} whose loop body is an empty compound statement.

@3@ A {{rlp|do|{{c/core|do}}-{{c/core|while}} statement}} whose loop body is an empty simple statement.

@4@ A {{rlp|do|{{c/core|do}}-{{c/core|while}} statement}} whose loop body is an empty compound statement.

@5@ A {{rlp|for|{{c/core|for}} statement}} whose loop body is an empty simple statement, the {{c/core|for}} statement does not have an {{spar|iteration-expression}}.

@6@ A {{rlp|for|{{c/core|for}} statement}} whose loop body is an empty compound statement, the {{c/core|for}} statement does not have an {{spar|iteration-expression}}.

The ''controlling expression'' of a trivially empty iteration statement is:
@1-4@ {{spar|condition}}.
@5,6@ {{spar|condition}} if present, otherwise {{c|true}}.

A ''trivial infinite loop'' is a trivially empty iteration statement for which the converted controlling expression is a {{rlp|constant expression}}, when {{rlp|constant expression#Manifestly constant-evaluated expressions|manifestly constant-evaluated}}, and evaluates to {{c|true}}.

The loop body of a trivial infinite loop is replaced with a call to the function {{lc|std::this_thread::yield}}. It is implementation-defined whether this replacement occurs on [[cpp/freestanding|freestanding implementations]].

{{source|1=
for (;;); // trivial infinite loop, well defined as of P2809
for (;;) { int x; } // undefined behavior
}}

{{rrev|since=c++17|
====Concurrent forward progress====
If a thread offers ''concurrent forward progress guarantee'', it will ''make progress'' (as defined above) in finite amount of time, for as long as it has not terminated, regardless of whether other threads (if any) are making progress.

The standard encourages, but doesn't require that the main thread and the threads started by {{lc|std::thread}} {{rev inl|since=c++20|and {{lc|std::jthread}}}} offer concurrent forward progress guarantee.

====Parallel forward progress====
If a thread offers ''parallel forward progress guarantee'', the implementation is not required
to ensure that the thread will eventually make progress if it has not yet executed any execution step (I/O, volatile, atomic, or synchronization), but once this thread has executed a step, it provides ''concurrent forward progress'' guarantees (this rule describes a thread in a thread pool that executes tasks in arbitrary order).

====Weakly parallel forward progress====
If a thread offers ''weakly parallel forward progress guarantee'', it does not guarantee to eventually make progress, regardless of whether other threads make progress or not.

Such threads can still be guaranteed to make progress by blocking with forward progress guarantee delegation: if a thread {{tt|P}} blocks in this manner on the completion of a set of threads {{tt|S}}, then at least one thread in {{tt|S}} will offer a forward progress guarantee that is same or stronger than {{tt|P}}. Once that thread completes, another thread in {{tt|S}} will be similarly strengthened. Once the set is empty, {{tt|P}} will unblock.

The [[cpp/algorithm|parallel algorithms]] from the C++ standard library block with forward progress delegation on the completion of an unspecified set of library-managed threads.
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1953|std=C++11|before=two expression evaluations that start/end the lifetimes&lt;br&gt;of objects with overlapping storages did not conflict|after=they conflict}}
{{dr list item|wg=lwg|dr=2200|std=C++11|before=it was unclear whether the container data race&lt;br&gt;requirement only applies to sequence containers|after=applies to all containers}}
{{dr list item|paper=P2809R3|std=C++11|before=the behavior of executing “trivial”&lt;ref&gt;“Trivial” here means executing the infinite loop never makes any progress.&lt;/ref&gt;&lt;br&gt;infinite loops was undefined|after=properly defines “trivial infinite loops”&lt;br&gt;and made the behavior well-defined}}
{{dr list end}}

&lt;references/&gt;

{{langlinks|es|ja|ru|zh}}