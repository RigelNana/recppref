{{title|Comparison operators}}
{{cpp/language/expressions/navbar}}
Compares the arguments.

{|class="wikitable" style="font-size: 85%;"
|-
!rowspan="2"|Operator name
!rowspan="2"|{{nbsp}}Syntax{{nbsp}}
!rowspan="2"|{{rlp|operators|Over{{br}}load{{br}}able}}
!colspan="2"|Prototype examples (for {{c/core|class T}})
|-
!Inside class definition
!Outside class definition
|-
|Equal to
|{{tt|1=a == b}}
|{{yes}}
|{{c|1=bool T::operator==(const U&amp; b) const;}}
|{{c|1=bool operator==(const T&amp; a, const U&amp; b);}}
|-
|Not equal to
|{{tt|1=a != b}}
|{{yes}}
|{{c|1=bool T::operator!=(const U&amp; b) const;}}
|{{c|1=bool operator!=(const T&amp; a, const U&amp; b);}}
|-
|Less than
|{{tt|1=a &lt; b}}
|{{yes}}
|{{c|1=bool T::operator&lt;(const U&amp; b) const;}}
|{{c|1=bool operator&lt;(const T&amp; a, const U&amp; b);}}
|-
|Greater than
|{{tt|1=a &gt; b}}
|{{yes}}
|{{c|1=bool T::operator&gt;(const U&amp; b) const;}}
|{{c|1=bool operator&gt;(const T&amp; a, const U&amp; b);}}
|-
|Less than or equal to
|{{tt|1=a &lt;= b}}
|{{yes}}
|{{c|1=bool T::operator&lt;=(const U&amp; b) const;}}
|{{c|1=bool operator&lt;=(const T&amp; a, const U&amp; b);}}
|-
|Greater than or equal to
|{{tt|1=a &gt;= b}}
|{{yes}}
|{{c|1=bool T::operator&gt;=(const U&amp; b) const;}}
|{{c|1=bool operator&gt;=(const T&amp; a, const U&amp; b);}}
|-
|Three-way comparison {{mark c++20}}
|{{tt|1=a{{nbsp}}&lt;=&gt;{{nbsp}}b}}
|{{yes}}
|{{box|{{tti|R{{nbsp}}}}{{c/core|1=T::operator&lt;=&gt;(const U&amp; b) const;}}}}&lt;ref name="R"&gt;{{tti|R}} is the return type of {{tt|1=operator&lt;=&gt;}} ([[#Three-way comparison|see below]])&lt;/ref&gt;
|{{box|{{tti|R{{nbsp}}}}{{c/core|1=operator&lt;=&gt;(const T&amp; a, const U&amp; b);}}}}&lt;ref name="R"/&gt;
|-
|colspan="5" |
:'''Notes'''&lt;br&gt;
* Where built-in operators return {{c/core|bool}}, most {{rlp|operators|user-defined overloads}} also return {{c/core|bool}} so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including {{c/core|void}}).
* {{tt|U}} can be any type including {{tt|T}}.
&lt;references/&gt;
|}

===Two-way comparison===
The two-way comparison operator expressions have the form 

=====Relational operators=====
{{sdsc begin}}
{{sdsc|num=1|{{spar|lhs}} {{ttb|&lt;}} {{spar|rhs}}}}
{{sdsc|num=2|{{spar|lhs}} {{ttb|&gt;}} {{spar|rhs}}}}
{{sdsc|num=3|{{spar|lhs}} {{ttb|1=&lt;=}} {{spar|rhs}}}}
{{sdsc|num=4|{{spar|lhs}} {{ttb|1=&gt;=}} {{spar|rhs}}}}
{{sdsc end}}
=====Equality operators=====
{{sdsc begin}}
{{sdsc|num=5|{{spar|lhs}} {{ttb|1===}} {{spar|rhs}}}}
{{sdsc|num=6|{{spar|lhs}} {{ttb|1=!=}} {{spar|rhs}}}}
{{sdsc end}}
@1@ Returns {{c|true}} if {{spar|lhs}} is less than {{spar|rhs}}, {{c|false}} otherwise.
@2@ Returns {{c|true}} if {{spar|lhs}} is greater than {{spar|rhs}}, {{c|false}} otherwise.
@3@ Returns {{c|true}} if {{spar|lhs}} is less than or equal to {{spar|rhs}}, {{c|false}} otherwise.
@4@ Returns {{c|true}} if {{spar|lhs}} is greater than or equal to {{spar|rhs}}, {{c|false}} otherwise.
@5@ Returns {{c|true}} if {{spar|lhs}} is equal to {{spar|rhs}}, {{c|false}} otherwise.
@6@ Returns {{c|true}} if {{spar|lhs}} is not equal to {{spar|rhs}}, {{c|false}} otherwise.

====Built-in two-way comparison operators====
For built-in two-way comparison operators, {{rlpsd|implicit conversion#Lvalue-to-rvalue conversion}}s{{rev inl|until=c++26|, {{rlpsd|implicit conversion#Array-to-pointer conversion}}s}} and {{rlpsd|implicit conversion#Function-to-pointer conversion}}s are applied to {{spar|lhs}} and {{spar sep|rhs}}.

{{rev begin}}
{{rev|since=c++20|until=c++26|
The comparison is deprecated if both {{spar|lhs}} and {{spar|rhs}} have array type prior to the application of these conversions.
}}
{{rev|since=c++26|
For built-in relational operators, if one of the operands is a pointer, the {{rlpsd|implicit conversion#Array-to-pointer conversion}} is performed on the other operand.

For built-in equality operators, if one of the operands is a pointer or a {{rlp|pointer#Null pointers|null pointer constant}}, the array-to-pointer conversion is performed on the other operand.
}}
{{rev end}}

For built-in two-way comparison operators, the result is a {{c/core|bool}} prvalue.

====Built-in arithmetic comparison====
If the converted operands both have arithmetic or enumeration type (scoped or unscoped), {{rlp|usual arithmetic conversions}} are performed on both operands. The values are compared after conversions:

{{example
|code=
#include &lt;iostream&gt;

int main()
{
    static_assert(sizeof(unsigned char) &lt; sizeof(int),
                  "Cannot compare signed and smaller unsigned properly");
    int a = -1;
    int b = 1;
    unsigned int c = 1;
    unsigned char d = 1;

    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; "Comparing two signed values:\n"
                 " -1 == 1 ? " &lt;&lt; (a == b) &lt;&lt; "\n"
                 " -1 &lt;  1 ? " &lt;&lt; (a &lt;  b) &lt;&lt; "\n"
                 " -1 &gt;  1 ? " &lt;&lt; (a &gt;  b) &lt;&lt; "\n"
                 "Comparing signed and unsigned:\n"
                 // may issue different-signedness warning:
                 " -1 == 1 ? " &lt;&lt; (a == c) &lt;&lt; "\n"
                 // may issue different-signedness warning:
                 " -1 &lt;  1 ? " &lt;&lt; (a &lt;  c) &lt;&lt; "\n"
                 // may issue different-signedness warning:
                 " -1 &gt;  1 ? " &lt;&lt; (a &gt;  c) &lt;&lt; "\n"
                 "Comparing signed and smaller unsigned:\n"
                 " -1 == 1 ? " &lt;&lt; (a == d) &lt;&lt; "\n"
                 " -1 &lt;  1 ? " &lt;&lt; (a &lt;  d) &lt;&lt; "\n"
                 " -1 &gt;  1 ? " &lt;&lt; (a &gt;  d) &lt;&lt; '\n';
}
|output=
Comparing two signed values:
 -1 == 1 ? false
 -1 &lt;  1 ? true
 -1 &gt;  1 ? false
Comparing signed and unsigned:
 -1 == 1 ? false
 -1 &lt;  1 ? false
 -1 &gt;  1 ? true
Comparing signed and smaller unsigned:
 -1 == 1 ? false
 -1 &lt;  1 ? true
 -1 &gt;  1 ? false
}}

====Built-in pointer equality comparison====
The converted operands of equality operators {{tt|1===}} and {{tt|1=!=}} can also have{{rev inl|since=c++11| the type {{lc|std::nullptr_t}},}} pointer type or pointer-to-member type.

Built-in pointer equality comparison has three possible results: equal, unequal and unspecified. The values yielded by equality operators for built-in pointer equality comparison is listed below:

{|class="wikitable" style="text-align: center;"
|-
!rowspan=2|{{nbsp}}Comparison result{{nbsp}}&lt;br&gt;of {{c|p}} and {{c|q}}
!colspan=2|Value yielded by
|-
!{{c|1=p == q}}
!{{c|1=p != q}}
|-
|equal
|{{c|true}}
|{{c|false}}
|-
|unequal
|{{c|false}}
|{{c|true}}
|-
|unspecified
|colspan=2|{{nbsp}}unspecified {{c/core|bool}} value{{nbsp}}
|}

If at least one of converted {{spar|lhs}} and {{spar|rhs}} is a pointer, {{rlpsd|implicit conversion#Pointer conversions}}{{rev inl|since=c++17|, {{rlpsd|implicit conversion#Function pointer conversions}}}} and {{rlpsd|implicit conversion#Qualification conversions}} are performed on both converted operands to bring them to their {{rlpsd|pointer#Composite pointer type}}. The two pointers of the composite pointer type are compared as follows:
* If one pointer {{rlp|pointer#Pointers|represents the address}} of a complete object, and another pointer
:* represents the address past the end of a different complete non-array object, or
:* represents the address one past the last element of a different complete array object,
: the result of the comparison is unspecified.
* Otherwise, if the pointers are both null, both point to the same function, or both represent the same address (i.e., they point to or are past the end of the same object), they compare equal.
* Otherwise, the pointers compare unequal.

If at least one of converted {{spar|lhs}} and {{spar|rhs}} is a pointer to member, {{rlpsd|implicit conversion#Pointer-to-member conversions}}{{rev inl|since=c++17|, {{rlpsd|implicit conversion#Function pointer conversions}}}} and {{rlpsd|implicit conversion#Qualification conversions}} are performed on both converted operands to bring them to their {{rlpsd|pointer#Composite pointer type}}. The two pointers to members of the composite pointer type are compared as follows:
* If two pointers to members are both the null member pointer value, they compare equal.
* If only one of two pointers to members is the null member pointer value, they compare unequal.
* If either is a pointer to a {{rlp|virtual|virtual member function}}, the result is unspecified.
* If one refers to a member of class {{tt|C1}} and the other refers to a member of a different class {{tt|C2}}, where neither is a base class of the other, the result is unspecified.
* If both refer to (possibly different) members of the same {{rlp|union}}, they compare equal.
* Otherwise, two pointers to members compare equal if they would refer to the same member of the same {{rlp|object#Subobjects|most derived object}} or the same subobject if indirection with a hypothetical object of the associated class type were performed, otherwise they compare unequal.
{{source|1=
struct P {};
struct Q : P { int x; };
struct R : P { int x; };

int P::*bx = (int(P::*)) &amp;Q::x;
int P::*cx = (int(P::*)) &amp;R::x;

bool b1 = (bx == cx); // unspecified

struct B
{
    int f();
};
struct L : B {};
struct R : B {};
struct D : L, R {};

int (B::*pb)() = &amp;B::f;
int (L::*pl)() = pb;
int (R::*pr)() = pb;
int (D::*pdl)() = pl;
int (D::*pdr)() = pr;

bool x = (pdl == pdr); // false
bool y = (pb == pl);   // true
}}

{{rrev|since=c++11|
Two operands of type {{lc|std::nullptr_t}} or one operand of type {{lc|std::nullptr_t}} and the other a null pointer constant compare equal.
}}

====Built-in pointer relational comparison====
The converted operands of relational operators {{tt|&gt;}}, {{tt|&lt;}}, {{tt|1=&gt;=}} and {{tt|1=&lt;=}} can also have pointer type.

Built-in pointer relational comparison on unequal pointers {{c|p}} and {{c|q}} has three possible results: {{c|p}} is greater, {{c|q}} is greater and unspecified. The values yielded by relational operators for built-in pointer relational comparison is listed below:

{|class="wikitable" style="text-align: center;"
|-
!rowspan=2|{{nbsp}}Comparison result{{nbsp}}&lt;br&gt;of {{c|p}} and {{c|q}}
!colspan=4|Value yielded by
|-
!{{nbsp}}{{c|p &gt; q}}{{nbsp}}
!{{nbsp}}{{c|p &lt; q}}{{nbsp}}
!{{nbsp}}{{c|1=p &gt;= q}}{{nbsp}}
!{{nbsp}}{{c|1=p &lt;= q}}{{nbsp}}
|-
|equal
|{{c|false}}
|{{c|false}}
|{{c|true}}
|{{c|true}}
|-
|{{c|p}} is greater
|{{c|true}}
|{{c|false}}
|{{c|true}}
|{{c|false}}
|-
|{{c|q}} is greater
|{{c|false}}
|{{c|true}}
|{{c|false}}
|{{c|true}}
|-
|unspecified
|colspan=4|unspecified {{c/core|bool}} value
|}

If converted {{spar|lhs}} and {{spar|rhs}} are both pointers, {{rlpsd|implicit conversion#Pointer conversions}}{{rev inl|since=c++17|, {{rlpsd|implicit conversion#Function pointer conversions}}}} and {{rlpsd|implicit conversion#Qualification conversions}} are performed on both converted operands to bring them to their {{rlpsd|pointer#Composite pointer type}}. The two pointers of the composite pointer type are compared as follows:
* If the pointers compare equal or the equality comparison result is unspecified, the relational comparison result falls into the same category.
* Otherwise (the pointers compare unequal), if any of the pointers is not a pointer to object, the result is unspecified.
* Otherwise (both pointers point to objects), the result is defined in terms of a partial order consistent with the following rules:
:* Given two different elements {{c|high}} and {{c|low}} of an array such than {{c|high}} has higher subscript than {{c|low}}, if one pointer points to {{c|high}} (or a subobject of {{c|high}}) and the other pointer points to {{c|low}} (or a subobject of {{c|low}}), the former compares greater than the latter.
:* If one pointer points to an element {{c|elem}} (or to a subobject of {{c|elem}}) of an array, and the other pointer is past the end of the same array, the past-the-end pointer compares greater than the other pointer.
:* If one pointer points to a complete object, a base class subobject or a member subobject {{c|obj}} (or to a subobject of {{c|obj}}), and the other pointer is past the end of {{c|obj}}, the past-the-end pointer compares greater than the other pointer.
{{anchor|Member layout}}
:* If the pointers point to different{{rev inl|since=c++20| {{rlp|attributes/no_unique_address|non-zero-sized}}}} non-static data members{{rev inl|until=c++23| with the same {{rlp|access|member access}}}} of the same object of a non-union class type, or to subobjects of such members, recursively, the pointer to the later declared member compares greater than the other pointer.
:* Otherwise, the result is unspecified.

====Pointer total order====
There exists an ''implementation-defined strict total order over pointers'' in each program. The strict total order is consistent with the partial order described above: unspecified results become implementation-defined, while other results stay the same.

Pointer comparison with the strict total order is applied in the following cases:
* Calling the {{c/core|operator()}} of the pointer type specializations of {{lc|std::less}}, {{lc|std::greater}}, {{lc|std::less_equal}}, and {{lc|std::greater_equal}}.
{{rev begin}}
{{rev|since=c++14|
* Calling built-in operators comparing pointers from the {{c/core|operator()}} of specializations {{ltt|cpp/utility/functional/less_void|std::less&lt;void&gt;}}, {{ltt|cpp/utility/functional/greater_void|std::greater&lt;void&gt;}}, {{ltt|cpp/utility/functional/less_equal_void|std::less_equal&lt;void&gt;}}, and {{ltt|cpp/utility/functional/greater_equal_void|std::greater_equal&lt;void&gt;}}.
}}
{{rev|since=c++20|
* Calling built-in {{c/core|1=operator&lt;=&gt;}} comparing pointers from the {{c/core|operator()}} of {{lc|std::compare_three_way}}.
* Calling built-in {{c/core|1=operator==}} comparing pointers from the {{c/core|operator()}} of {{ltt|cpp/utility/functional/ranges/equal_to|std::ranges::equal_to}} and {{ltt|cpp/utility/functional/ranges/not_equal_to|std::ranges::not_equal_to}}.
* Calling built-in {{c/core|operator&lt;}} comparing pointers from the {{c/core|operator()}} of {{ltt|cpp/utility/functional/ranges/less|std::ranges::less}}, {{ltt|cpp/utility/functional/ranges/greater|std::ranges::greater}}, {{ltt|cpp/utility/functional/ranges/less_equal|std::ranges::less_equal}}, and {{ltt|cpp/utility/functional/ranges/greater_equal|std::ranges::greater_equal}}.
}}
{{rev end}}

{{anchor|Overloads of two-way comparison operators}}
====Overloads====
In {{rlp|overload resolution#Call to an overloaded operator|overload resolution against user-defined operators}}, for every pair of promoted arithmetic types {{tt|L}} and {{tt|R}}, including enumeration types, the following function signatures participate in overload resolution:
{{dcl begin}}
{{dcl|bool operator&lt;(L, R);}}
{{dcl|bool operator&gt;(L, R);}}
{{dcl|1=bool operator&lt;=(L, R);}}
{{dcl|1=bool operator&gt;=(L, R);}}
{{dcl|1=bool operator==(L, R);}}
{{dcl|1=bool operator!=(L, R);}}
{{dcl end}}

For every type {{tt|P}} which is either pointer to object or pointer to function, the following function signatures participate in overload resolution:
{{dcl begin}}
{{dcl|bool operator&lt;(P, P);}}
{{dcl|bool operator&gt;(P, P);}}
{{dcl|1=bool operator&lt;=(P, P);}}
{{dcl|1=bool operator&gt;=(P, P);}}
{{dcl|1=bool operator==(P, P);}}
{{dcl|1=bool operator!=(P, P);}}
{{dcl end}}

For every type {{tt|MP}} that is a pointer to member object or pointer to member function{{rev inl|since=c++11| or {{lc|std::nullptr_t}}}}, the following function signatures participate in overload resolution:
{{dcl begin}}
{{dcl|1=bool operator==(MP, MP);}}
{{dcl|1=bool operator!=(MP, MP);}}
{{dcl end}}

{{example
|code=
#include &lt;iostream&gt;

struct Foo
{
    int n1;
    int n2;
};

union Union
{
    int n;
    double d;
};

int main()
{
    std::cout &lt;&lt; std::boolalpha;
    
    char a[4] = "abc";
    char* p1 = &amp;a[1];
    char* p2 = &amp;a[2];
    std::cout &lt;&lt; "Pointers to array elements:\n"
              &lt;&lt; "p1 == p2? " &lt;&lt; (p1 == p2) &lt;&lt; '\n'
              &lt;&lt; "p1 &lt;  p2? " &lt;&lt; (p1 &lt;  p2) &lt;&lt; '\n';
    
    Foo f;
    int* p3 = &amp;f.n1;
    int* p4 = &amp;f.n2;
    std::cout &lt;&lt; "Pointers to members of a class:\n"
              &lt;&lt; "p3 == p4? " &lt;&lt; (p3 == p4) &lt;&lt; '\n'
              &lt;&lt; "p3 &lt;  p4? " &lt;&lt; (p3 &lt;  p4) &lt;&lt; '\n';
    
    Union u;
    int* p5 = &amp;u.n;
    double* p6 = &amp;u.d;
    std::cout &lt;&lt; "Pointers to members of a union:\n"
              &lt;&lt; "p5 == (void*)p6? " &lt;&lt; (p5 == (void*)p6) &lt;&lt; '\n'
              &lt;&lt; "p5 &lt;  (void*)p6? " &lt;&lt; (p5 &lt;  (void*)p6) &lt;&lt; '\n';
}
|output=
Pointers to array elements:
p1 == p2? false
p1 &lt;  p2? true
Pointers to members of a class:
p3 == p4? false
p3 &lt;  p4? true
Pointers to members of a union:
p5 == (void*)p6? true
p5 &lt;  (void*)p6? false
}}

{{rrev|since=c++20|
===Three-way comparison===
The three-way comparison operator expressions have the form 

{{sdsc begin}}
{{sdsc|{{spar|a}} {{ttb|1=&lt;=&gt;}} {{spar|b}}}}
{{sdsc end}}

The expression returns an object such that
* {{c|1=(a &lt;=&gt; b) &lt; 0}} if {{c|a &lt; b}},
* {{c|1=(a &lt;=&gt; b) &gt; 0}} if {{c|a &gt; b}},
* {{c|1=(a &lt;=&gt; b) == 0}} if {{c|a}} and {{c|b}} are equal/equivalent.

If one of the operands is of type {{c/core|bool}} and the other is not, the program is ill-formed.

If both operands have arithmetic types, or if one operand has unscoped enumeration type and the other has integral type, the usual arithmetic conversions are applied to the operands, and then

* If a narrowing conversion is required, other than from an integral type to a floating point type, the program is ill-formed.
* Otherwise, if the operands have integral type, the operator yields a prvalue of type {{ltt std|cpp/utility/compare/strong_ordering}}:
:* {{lc|std::strong_ordering::equal}} if both operands are arithmetically equal,
:* {{lc|std::strong_ordering::less}} if the first operand is arithmetically less than the second,
:* {{lc|std::strong_ordering::greater}} otherwise.
* Otherwise, the operands have floating-point type, and the operator yields a prvalue of type {{ltt std|cpp/utility/compare/partial_ordering}}. The expression {{c|1=a &lt;=&gt; b}} yields 
:* {{lc|std::partial_ordering::less}} if {{c|a}} is less than {{c|b}},
:* {{lc|std::partial_ordering::greater}} if {{c|a}} is greater than {{c|b}},
:* {{lc|std::partial_ordering::equivalent}} if {{c|a}} is equivalent to {{c|b}} ({{c|1=-0 &lt;=&gt; +0}} is equivalent),
:* {{lc|std::partial_ordering::unordered}} ({{c|1=NaN &lt;=&gt; anything}} is unordered).

If both operands have the same enumeration type {{tt|E}}, the operator yields the result of converting the operands to the underlying type of E and applying {{c|1=&lt;=&gt;}} to the converted operands.

If at least one of the operands is a pointer to object or pointer to member, {{rlp|implicit conversion#Array-to-pointer conversion|array-to-pointer conversions}}, {{rlpsd|implicit conversion#Pointer conversions}} and {{rlpsd|implicit conversion#Qualification conversions}} are applied to both operands to bring them to their {{rlpsd|pointer#Composite pointer type}}.

For converted pointer operands {{c|p}} and {{c|q}}, {{c|1=p &lt;=&gt; q}} returns a prvalue of type {{ltt|cpp/utility/compare/strong_ordering|std::strong_ordering}}:
* {{lc|std::strong_ordering::equal}} if they [[#Built-in pointer equality comparison|compare equal]],
* {{lc|std::strong_ordering::less}} if {{c|q}} [[#Built-in pointer relational comparison|compares greater than]] {{c|p}},
* {{lc|std::strong_ordering::greater}} if {{c|p}} compares greater than {{c|q}},
* unspecified result if the two-way comparison result is unspecified.

Otherwise, the program is ill-formed.

{{anchor|Overloads of three-way comparison operators}}
====Overloads====
In {{rlp|overload resolution#Call to an overloaded operator|overload resolution against user-defined operators}}, for pointer or enumeration type {{tt|T}}, the following function signature participates in overload resolution:
{{dcl begin}}
{{dcl|1= R operator&lt;=&gt;(T, T);}}
{{dcl end}}
Where {{tt|R}} is the ordering category type defined above.

{{example
|code=
#include &lt;compare&gt;
#include &lt;iostream&gt;

int main()
{
    double foo = -0.0;
    double bar = 0.0;
    
    auto res = foo &lt;=&gt; bar;
    
    if (res &lt; 0)
        std::cout &lt;&lt; "-0 is less than 0";
    else if (res &gt; 0)
        std::cout &lt;&lt; "-0 is greater than 0";
    else if (res == 0)
        std::cout &lt;&lt; "-0 and 0 are equal";
    else
        std::cout &lt;&lt; "-0 and 0 are unordered";
}
|output=
-0 and 0 are equal
}}
}}

===Notes===
Because comparison operators group left-to-right, the expression {{c|a &lt; b &lt; c}} is parsed {{c|(a &lt; b) &lt; c}}, and not {{c|a &lt; (b &lt; c)}} or {{c|(a &lt; b) &amp;&amp; (b &lt; c)}}.
{{example
|code=
#include &lt;iostream&gt;

int main()
{
    int a = 3, b = 2, c = 1;
    
    std::cout &lt;&lt; std::boolalpha
        &lt;&lt; (a &lt; b &lt; c) &lt;&lt; '\n' // true; maybe warning
        &lt;&lt; ((a &lt; b) &lt; c) &lt;&lt; '\n' // true
        &lt;&lt; (a &lt; (b &lt; c)) &lt;&lt; '\n' // false
        &lt;&lt; ((a &lt; b) &amp;&amp; (b &lt; c)) &lt;&lt; '\n'; // false
}
}}

A common requirement for {{rlp|operators#Comparison operators|user-defined operator&lt;}} is {{enwiki|Strict weak ordering|strict weak ordering}}. In particular, this is required by the standard algorithms and containers that work with {{named req|Compare}} types: {{lc|std::sort}}, {{lc|std::max_element}}, {{lc|std::map}}, etc.

The [[#Member layout|comparison result]] of pointers to different non-static data members of the same class implies that non-static data members{{rev inl|until=c++23| in each of the three {{rlp|access|member access modes}}}} are positioned in memory in order of declaration.

Although the results of comparing pointers of random origin (e.g. not all pointing to members of the same array) is unspecified, many implementations provide {{enwiki|Total order#Strict total order|strict total ordering}} of pointers, e.g. if they are implemented as addresses within continuous virtual address space. Those implementations that do not (e.g. where not all bits of the pointer are part of a memory address and have to be ignored for comparison, or an additional calculation is required or otherwise pointer and integer is not a 1 to 1 relationship), provide a specialization of {{lc|std::less}} for pointers that has that guarantee. This makes it possible to use all pointers of random origin as keys in standard associative containers such as {{lc|std::set}} or {{lc|std::map}}.

For the types that are both {{named req|EqualityComparable}} and {{named req|LessThanComparable}}, the C++ standard library makes a distinction between ''equality'', which is the value of the expression {{c|1=a == b}} and ''equivalence'', which is the value of the expression {{c|!(a &lt; b) &amp;&amp; !(b &lt; a)}}.

Comparison between pointers and null pointer constants was removed by the resolution of {{cwg|583}} included in {{stddoc|N3624}}:
{{example|code=
void f(char* p)
{
    if (p &gt; 0) { /*...*/ } // Error with N3624, compiled before N3624
    if (p &gt; nullptr) { /*...*/ } // Error with N3624, compiled before N3624
}

int main() {}
}}

Three-way comparison can be automatically generated for class types, see {{rlp|default comparisons}}.

If both of the operands are arrays, three-way comparison is ill-formed.

{{source|1=
unsigned int i = 1;
auto r = -1 &lt; i;    // existing pitfall: returns ‘false’
auto r2 = -1 &lt;=&gt; i; // Error: narrowing conversion required
}}

{{ftm begin|std=1|comment=1}}
{{ftm|std=C++20|value=201907L|__cpp_impl_three_way_comparison|Three-way comparison (compiler support)}}
{{ftm|std=C++20|value=201907L|__cpp_lib_three_way_comparison|Three-way comparison (library support); adding three-way comparison to the library}}
{{ftm end}}

===Standard library===
Comparison operators are overloaded for many classes in the standard library.

{{dsc begin}}
{{dsc inc|cpp/types/type_info/dsc operator cmp}}
{{dsc inc|cpp/error/error_code/dsc operator cmp}}
{{dsc inc|cpp/error/error_condition/dsc operator cmp}}
{{dsc inc|cpp/utility/pair/dsc operator cmp}}
{{dsc inc|cpp/utility/tuple/dsc operator cmp}}
{{dsc inc|cpp/utility/bitset/dsc operator cmp}}
{{dsc inc|cpp/memory/allocator/dsc operator cmp}}
{{dsc inc|cpp/memory/unique_ptr/dsc operator cmp}}
{{dsc inc|cpp/memory/shared_ptr/dsc operator cmp}}
{{dsc inc|cpp/utility/functional/function/dsc operator cmp}}
{{dsc inc|cpp/chrono/duration/dsc operator cmp}}
{{dsc inc|cpp/chrono/time_point/dsc operator cmp}}
{{dsc inc|cpp/memory/scoped_allocator_adaptor/dsc operator cmp}}
{{dsc inc|cpp/types/type_index/dsc operator cmp}}
{{dsc inc|cpp/string/basic_string/dsc operator cmp}}
{{dsc inc|cpp/locale/locale/dsc operator cmp}}
{{dsc inc|cpp/container/dsc operator cmp|array}}
{{dsc inc|cpp/container/dsc operator cmp|deque}}
{{dsc inc|cpp/container/dsc operator cmp|forward_list}}
{{dsc inc|cpp/container/dsc operator cmp|list}}
{{dsc inc|cpp/container/dsc operator cmp|vector}}
{{dsc inc|cpp/container/dsc operator cmp|map}}
{{dsc inc|cpp/container/dsc operator cmp|multimap}}
{{dsc inc|cpp/container/dsc operator cmp|set}}
{{dsc inc|cpp/container/dsc operator cmp|multiset}}
{{dsc inc|cpp/container/dsc operator cmp_unord|unordered_map}}
{{dsc inc|cpp/container/dsc operator cmp_unord|unordered_multimap}}
{{dsc inc|cpp/container/dsc operator cmp_unord|unordered_set}}
{{dsc inc|cpp/container/dsc operator cmp_unord|unordered_multiset}}
{{dsc inc|cpp/container/dsc operator cmp|queue}}
{{dsc inc|cpp/container/dsc operator cmp|stack}}
{{dsc inc|cpp/iterator/adaptor/dsc operator cmp|reverse_iterator}}
{{dsc inc|cpp/iterator/adaptor/dsc operator cmp|move_iterator}}
{{dsc inc|cpp/iterator/istream_iterator/dsc operator cmp}}
{{dsc inc|cpp/iterator/istreambuf_iterator/dsc operator cmp}}
{{dsc inc|cpp/numeric/complex/dsc operator cmp}}
{{dsc inc|cpp/numeric/valarray/dsc operator cmp}}
{{dsc inc|cpp/numeric/random/engine/dsc operator cmp|linear_congruential_engine}}
{{dsc inc|cpp/numeric/random/distribution/dsc operator cmp|poisson_distribution}}
{{dsc inc|cpp/regex/sub_match/dsc operator cmp}}
{{dsc inc|cpp/regex/match_results/dsc operator cmp}}
{{dsc inc|cpp/regex/regex_iterator/dsc operator cmp}}
{{dsc inc|cpp/regex/regex_token_iterator/dsc operator cmp}}
{{dsc inc|cpp/thread/thread/id/dsc operator cmp}}
{{dsc end}}

The namespace {{ltt|cpp/utility/rel_ops/operator cmp|std::rel_ops}} provides generic operators {{c|1=!=}}, {{c|&gt;}}, {{c|1=&lt;=}}, and {{c|1=&gt;=}}:
{{dsc begin}}
{{dsc header|utility}}
{{dsc namespace|std::rel_ops}}
{{dsc inc|cpp/utility/rel_ops/dsc operator cmp}}
{{dsc end}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=583|paper=N3624|std=C++98|before=all six comparison operators could be used to&lt;br&gt;compare a pointer with a null pointer constant|after=only equality operators&lt;br&gt;are allowed}}
{{dr list item|wg=cwg|dr=661|std=C++98|before=the actual semantics of arithmetic comparisons (e.g.&lt;br&gt;whether {{c|1 &lt; 2}} yields {{c|true}} or {{c|false}}) were unspecified|after=specification added}}
{{dr list item|wg=cwg|dr=879|std=C++98|before=pointers to function types and pointers&lt;br&gt;to {{c/core|void}} did not have built-in comparisons|after=added comparison&lt;br&gt;specification for these pointers}}
{{dr list item|wg=cwg|dr=1596|std=C++98|before=non-array objects were considered to belong to arrays with&lt;br&gt;one element only for the purpose of pointer arithmetic|after=the rule is also&lt;br&gt;applied to comparison}}
{{dr list item|wg=cwg|dr=1598|std=C++98|before=two pointers to members of classes that are different and&lt;br&gt;neither is the base class of the other did not compare equal&lt;br&gt;even if the offsets of the pointed members can be the same|after=the result is&lt;br&gt;unspecified&lt;br&gt;in this case}}
{{dr list item|wg=cwg|dr=1858|std=C++98|before=it was not clear whether two pointers to members&lt;br&gt;that refer to different members of the same union&lt;br&gt;compare equal as if they refer to the same member|after=they compare&lt;br&gt;equal in this case}}
{{dr list item|wg=cwg|dr=2419|std=C++98|before=a pointer to non-array object was only treated as a&lt;br&gt;pointer to the first element of an array with size 1&lt;br&gt;in pointer comparison if the pointer is obtained by {{tt|&amp;}}|after=applies to all pointers&lt;br&gt;to non-array objects}}
{{dr list item|wg=cwg|dr=2526|std=C++98|before=the definition of relational comparison ({{tt|&gt;}}, {{tt|1=&gt;=}}, {{tt|&lt;}} and {{tt|1=&lt;=}}) of&lt;br&gt;pointers to {{c/core|void}} and function pointers were removed by {{stddoc|N3624}}|after=restored}}
{{dr list item|wg=cwg|dr=2796|std=C++17|before=function pointer conversions were not performed on the converted&lt;br&gt;pointer operands during built-in pointer relational comparisons|after=performs these&lt;br&gt;conversions in this case}}
{{dr list end}}

===See also===
* {{rlp|operator precedence|Operator precedence}}
* {{rlp|operators|Operator overloading}}
* {{named req|Compare}} (named requirements)

{{cpp/language/operators}}

{{dsc begin}}
{{dsc see c|c/language/operator comparison|Comparison operators|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}