{{title|Classes}}
{{cpp/language/classes/navbar}}
A class is a user-defined type.

A class type is defined by class-specifier, which appears in {{spar|decl-specifier-seq}} of the {{rlp|declarations|declaration}} syntax. See {{rlp|class|class declaration}} for the syntax of the class specifier.

A class can have the following kinds of members:
@1@ data members:
:@a@ {{rlp|data members|non-static data members}}, including {{rlp|bit field|bit-fields}}.
:@b@ {{rlp|static#Static data members|static data members}}
@2@ member functions:
:@a@ {{rlp|member functions|non-static member functions}}
:@b@ {{rlp|static#Static member functions|static member functions}}
@3@ nested types:
:@a@ {{rlp|nested classes}} and {{rlp|enum|enumerations}} defined within the class definition
:@b@ aliases of existing types, defined with {{rlpt|typedef}} {{rev inl|since=c++11|or {{rlp|type alias}} }}declarations
:@c@ the name of the class within its own definition acts as a public member type alias of itself for the purpose of {{rlp|unqualified lookup#Injected class name|lookup}} (except when used to name a {{rlp|constructor}}): this is known as ''{{rlp|injected-class-name}}''
@4@ {{rlp|enum|enumerators}} from all unscoped enumerations defined within the class{{rev inl|since=c++20|, or introduced by {{rlp|using declaration|using-declaration}}s or {{rlp|enum#Using-enum-declaration|using-enum-declaration}}s}}
@5@ {{rlp|member template}}s ({{rev inl|since=c++14|variable templates, }}class templates or function templates) may appear in the body of any non-local class/struct/union.

All members are defined at once in the class definition, they cannot be added to an already-defined class (unlike the members of namespaces)

A member of a class {{tt|T}} cannot use {{tt|T}} as its name if the member is
* a static data member,
* a member function,
* a member type,
* a member template,
* an enumerator of an enumeration {{rev inl|since=c++11|(unless the enumeration is scoped)}}, or
* a member of a member anonymous union.
However, a non-static data member may use the name {{tt|T}} as long as there are no user-declared constructors.

A class with at least one declared or inherited {{rlp|virtual}} member function is ''polymorphic''. Objects of this type are {{rlp|object#Polymorphic objects|polymorphic objects}} and have runtime type information stored as part of the object representation, which may be queried with {{rlpt|dynamic_cast}} and {{rlpt|typeid}}. Virtual member functions participate in dynamic binding.

A class with at least one declared or inherited pure virtual member function is an {{rlp|abstract class}}. Objects of this type cannot be created.

{{rrev|since=c++11|
A class with a {{rlp|constexpr}} constructor is a {{named req|LiteralType}}: objects of this type can be manipulated by {{rlp|constexpr}} functions at compile time.
}}

===Properties of classes===
{{rrev|since=c++11|1=
====Trivially copyable class====
A ''trivially copyable class'' is a class that
* has at least one eligible {{rlp|copy constructor#Eligible copy constructor|copy constructor}}, {{rlp|move constructor#Eligible move constructor|move constructor}}, {{rlp|copy assignment#Eligible copy assignment operator|copy assignment operator}}, or {{rlp|move assignment#Eligible move assignment operator|move assignment operator}},
* each eligible copy constructor is {{rlp|copy constructor#Trivial copy constructor|trivial}}
* each eligible move constructor is {{rlp|move constructor#Trivial move constructor|trivial}}
* each eligible copy assignment operator is {{rlp|copy assignment#Trivial copy assignment operator|trivial}}
* each eligible move assignment operator is {{rlp|move assignment#Trivial move assignment operator|trivial}}, and
* has a non-deleted {{rlp|destructor#Trivial destructor|trivial destructor}}.

{{rev begin}}
&lt;tr class="t-rev"&gt;
&lt;td&gt;
====Trivial class====
A ''trivial class'' is a class that
* is trivially copyable, and
* has one or more {{rlp|default constructor#Eligible default constructor|eligible default constructors}} such that each is {{rlp|default constructor#Trivial default constructor|trivial}}.
&lt;/td&gt;
&lt;td&gt;{{mark deprecated c++26}}&lt;/td&gt;
&lt;/tr&gt;
{{rev end}}

====Standard-layout class====
A ''standard-layout class'' is a class that
* has no {{rlp|data members|non-static data members}} of type non-standard-layout class (or array of such types) or reference,
* has no {{rlp|virtual|virtual functions}} and no {{rlp|derived class#Virtual base classes|virtual base classes}},
* has the same {{rlp|access|access control}} for all non-static data members,
* has no non-standard-layout base classes,
* only one class in the hierarchy has non-static data members, and
&lt;!-- the rules below displayed on the page was copied from the standard, it may be substituted by the following contents taken from cpp/named_req/StandardLayoutType page if needed:
* None of the base class subobjects has the same type as
:* for non-union types, as the first non-static data member (see {{rlp|ebo|empty base optimization}}), and, recursively, the first non-static data member of that data member if it has non-union class type, or all non-static data members of that data member if it has union type, or an element of that data member if it has array type, etc.
:* for union types, as any non-static data members, and, recursively, the first non-static data member of every member of non-union class type, and all non-static data members of all members of union type, and element type of all non-static data members of array type, etc.
:* for array types, as the type of the array element, and, recursively, the first non-static data member of the array element if it has non-union class type, or as any non-static data member of the array element if it has union type, or as the element type of the array element if it has array type, etc.
--&gt;
* Informally, none of the base classes has the same type as the first non-static data member. Or, formally: given the class as S, has no element of the set M(S) of types as a base class, where M(X) for a type X is defined as:
:* If X is a non-union class type with no (possibly inherited) non-static data members, the set M(X) is empty.
:* If X is a non-union class type whose first non-static data member has type X0 (where said member may be an anonymous union), the set M(X) consists of X0 and the elements of M(X0).
:* If X is a union type, the set M(X) is the union of all M(Ui) and the set containing all Ui, where each Ui is the type of the ith non-static data member of X.
:* If X is an array type with element type Xe, the set M(X) consists of Xe and the elements of M(Xe).
:* If X is a non-class, non-array type, the set M(X) is empty.

A ''standard-layout struct'' is a standard-layout class defined with the class keyword {{ltt|cpp/keyword/struct}} or the class keyword {{ltt|cpp/keyword/class}}. A ''standard-layout union'' is a standard-layout class defined with the class keyword {{ltt|cpp/keyword/union}}.
}}

====Implicit-lifetime class====
An ''implicit-lifetime class'' is a class that
* is an {{rlp|aggregate initialization|aggregate}} whose destructor is not {{rev inl|until=c++11|user-declared}}{{rev inl|since=c++11|{{rlp|function#User-provided functions|user-provided}}}}, or
* has at least one trivial eligible constructor and a trivial, non-deleted destructor.

Notes: the implicit-lifetime property is clarified by defect report {{wg21|P0593R6}}.

{{rev begin}}
&lt;tr class="t-rev"&gt;
&lt;td&gt;
====POD class====
A ''POD class'' is a class that
{{rrev multi|rev1=
* is an {{rlp|aggregate initialization|aggregate}},
* has no user-declared copy assignment operator,
* has no user-declared destructor, and
* has no non-static data members of type non-POD class (or array of such types) or reference.
|since2=c++11|rev2=
* is a trivial class,
* is a standard-layout class, and
* has no non-static data members of type non-POD class (or array of such types).
}}

A ''POD struct'' is a non-union POD class. A ''POD union'' is a union that is a POD class.
&lt;/td&gt;
&lt;td&gt;{{mark deprecated c++20}}&lt;/td&gt;
&lt;/tr&gt;
{{rev end}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=148|std=C++98|before=POD classes could not contain pointers to member,&lt;br&gt;which are themselves POD (scalar) types|after=restriction removed}}
{{dr list item|wg=cwg|dr=383|std=C++98|before=copy assignment operators or destructors could be&lt;br&gt;user-declared in POD classes if they are not defined|after=not allowed}}
{{dr list item|wg=cwg|dr=1363|std=C++11|before=a class that has both trivial default constructors and non-trivial&lt;br&gt; default constructors at the same time could be trivial|after=it is non-trivial}}
{{dr list item|wg=cwg|dr=1496|std=C++11|before=a class that only has constructors that&lt;br&gt;are all defined as deleted could be trivial|after=it is non-trivial}}
{{dr list item|wg=cwg|dr=1672|std=C++11|before=a class could be a standard-layout class&lt;br&gt;if it has multiple empty base classes|after=it is not a standard-layout class}}
{{dr list item|wg=cwg|dr=1734|std=C++11|before=a trivially copyable class could not have non-trivial&lt;br&gt;deleted copy/move constructors/assignment operators|after=can be trivial if deleted}}
{{dr list item|wg=cwg|dr=1813|std=C++11|before=a class was never a standard-layout class if it has a&lt;br&gt;base class that inherits a non-static data member|after=it can be a standard-layout class}}
{{dr list item|wg=cwg|dr=1881|std=C++11|before=for a standard-layout class and its base classes,&lt;br&gt;unnamed bit-fields might be declared in a&lt;br&gt;different class declaring the data members|after=all non-static data members&lt;br&gt;and bit-fields need to be first&lt;br&gt;declared in the same class}}
{{dr list item|wg=cwg|dr=1909|std=C++98|before=a member template could have the same name as its class|after=prohibited}}
{{dr list item|wg=cwg|dr=2120|std=C++11|before=the definition of M(X) in determining a standard-&lt;br&gt;layout class did not consider the case of&lt;br&gt;a class whose first member is an array|after=addressed this case in&lt;br&gt;the definition of M(X)}}
{{dr list item|wg=cwg|dr=2605|std=C++98|before=an implicit-lifetime class could have a user-provided destructor|after=prohibited}}
{{dr list end}}

{{langlinks|es|ja|ko|pt|ru|zh}}