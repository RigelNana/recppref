{{title|{{tt|noexcept}} operator {{mark since c++11}}}}
{{cpp/language/expressions/exceptions/navbar}}

The {{c/core|noexcept}} operator performs a compile-time check that returns {{c|true}} if an expression is declared to not throw any exceptions.

It can be used within a function template's {{rlp|noexcept spec|{{c/core|noexcept}} specifier}} to declare that the function will throw exceptions for some types but not others.

===Syntax===
{{sdsc begin}}
{{sdsc|{{ttb|noexcept(}} {{spar|expression}} {{ttb|)}}}}
{{sdsc end}}

Returns a {{rlpsd|value category#prvalue}} of type {{c/core|bool}}. The result is {{c|true}} if {{rev inl|until=c++17|the set of {{rlp|except spec|potential exceptions}} of the {{spar|expression}} is empty}}{{rev inl|since=c++17|{{spar|expression}} is specified to be {{rlp|noexcept spec|non-throwing}}}}, and {{c|false}} otherwise.

{{spar|expression}} is an {{rlp|expressions#Potentially-evaluated expressions|unevaluated operand}}.

{{rrev|since=c++17|
If {{spar|expression}} is a prvalue, {{rlpsd|implicit conversion#Temporary materialization}} is applied.
}}

===Notes===
Even if {{c|noexcept(expr)}} is {{c|true}}, an evaluation of {{c|expr}} may still throw as the result of encountering undefined behavior.

{{rrev|since=c++17|
If {{spar|expression}} is of a class type or (possibly multidimensional) array thereof, temporary materialization requires the destructor be non-deleted and accessible.
}}

===Keywords===
{{ltt|cpp/keyword/noexcept}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

void may_throw();
void no_throw() noexcept;
auto lmay_throw = []{};
auto lno_throw = []() noexcept {};

class T
{
public:
    ~T(){} // dtor prevents move ctor
           // copy ctor is noexcept
};

class U
{
public:
    ~U(){} // dtor prevents move ctor
           // copy ctor is noexcept(false)
    std::vector&lt;int&gt; v;
};

class V
{
public:
    std::vector&lt;int&gt; v;
};

int main()
{
    T t;
    U u;
    V v;
    
    std::cout &lt;&lt; std::boolalpha &lt;&lt;
        "may_throw() is noexcept(" &lt;&lt; noexcept(may_throw()) &lt;&lt; ")\n"
        "no_throw() is noexcept(" &lt;&lt; noexcept(no_throw()) &lt;&lt; ")\n"
        "lmay_throw() is noexcept(" &lt;&lt; noexcept(lmay_throw()) &lt;&lt; ")\n"
        "lno_throw() is noexcept(" &lt;&lt; noexcept(lno_throw()) &lt;&lt; ")\n"
        "~T() is noexcept(" &lt;&lt; noexcept(std::declval&lt;T&gt;().~T()) &lt;&lt; ")\n"
        // note: the following tests also require that ~T() is noexcept because
        // the expression within noexcept constructs and destroys a temporary
        "T(rvalue T) is noexcept(" &lt;&lt; noexcept(T(std::declval&lt;T&gt;())) &lt;&lt; ")\n"
        "T(lvalue T) is noexcept(" &lt;&lt; noexcept(T(t)) &lt;&lt; ")\n"
        "U(rvalue U) is noexcept(" &lt;&lt; noexcept(U(std::declval&lt;U&gt;())) &lt;&lt; ")\n"
        "U(lvalue U) is noexcept(" &lt;&lt; noexcept(U(u)) &lt;&lt; ")\n"
        "V(rvalue V) is noexcept(" &lt;&lt; noexcept(V(std::declval&lt;V&gt;())) &lt;&lt; ")\n"
        "V(lvalue V) is noexcept(" &lt;&lt; noexcept(V(v)) &lt;&lt; ")\n";
}
|output=
may_throw() is noexcept(false)
no_throw() is noexcept(true)
lmay_throw() is noexcept(false)
lno_throw() is noexcept(true)
~T() is noexcept(true)
T(rvalue T) is noexcept(true)
T(lvalue T) is noexcept(true)
U(rvalue U) is noexcept(false)
U(lvalue U) is noexcept(false)
V(rvalue V) is noexcept(true)
V(lvalue V) is noexcept(false)
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=2722|std=C++17|before=it was unclear whether temporary materialization&lt;br&gt;is applied if {{spar|expression}} is a prvalue|after=it is applied&lt;br&gt;in this case}}
{{dr list item|wg=cwg|dr=2792|std=C++11|before=the {{c/core|noexcept}} operator was required to determine whether exceptions&lt;br&gt;may be thrown in the case of encountering undefined behavior|after=not required}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc noexcept spec}}
{{dsc inc|cpp/language/dsc except spec}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}