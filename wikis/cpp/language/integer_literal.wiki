{{title|Integer literal}}
{{cpp/language/expressions/navbar}}
Allows values of integer type to be used in expressions directly.

===Syntax===
An integer literal has the form
{{sdsc begin}}
{{sdsc|num=1|{{spar|decimal-literal}} {{spar optional|integer-suffix}}}}
{{sdsc|num=2|{{spar|octal-literal}} {{spar optional|integer-suffix}}}}
{{sdsc|num=3|{{spar|hex-literal}} {{spar optional|integer-suffix}}}}
{{sdsc|num=4|notes={{mark since c++14}}|{{spar|binary-literal}} {{spar optional|integer-suffix}}}}
{{sdsc end}}
where
* {{spar|decimal-literal}} is a non-zero decimal digit ({{tt|1}}, {{tt|2}}, {{tt|3}}, {{tt|4}}, {{tt|5}}, {{tt|6}}, {{tt|7}}, {{tt|8}}, {{tt|9}}), followed by zero or more decimal digits ({{tt|0}}, {{tt|1}}, {{tt|2}}, {{tt|3}}, {{tt|4}}, {{tt|5}}, {{tt|6}}, {{tt|7}}, {{tt|8}}, {{tt|9}})
* {{spar|octal-literal}} is the digit zero ({{tt|0}}) followed by zero or more octal digits ({{tt|0}}, {{tt|1}}, {{tt|2}}, {{tt|3}}, {{tt|4}}, {{tt|5}}, {{tt|6}}, {{tt|7}})
* {{spar|hex-literal}} is the character sequence {{tt|0x}} or the character sequence {{tt|0X}} followed by one or more hexadecimal digits ({{tt|0}}, {{tt|1}}, {{tt|2}}, {{tt|3}}, {{tt|4}}, {{tt|5}}, {{tt|6}}, {{tt|7}}, {{tt|8}}, {{tt|9}}, {{tt|a}}, {{tt|A}}, {{tt|b}}, {{tt|B}}, {{tt|c}}, {{tt|C}}, {{tt|d}}, {{tt|D}}, {{tt|e}}, {{tt|E}}, {{tt|f}}, {{tt|F}})
* {{spar|binary-literal}} is the character sequence {{tt|0b}} or the character sequence {{tt|0B}} followed by one or more binary digits ({{tt|0}}, {{tt|1}})
* {{spar|integer-suffix}}, if provided, may contain one or both of the following (if both are provided, they may appear in any order:
:* {{spar|unsigned-suffix}} (the character {{tt|u}} or the character {{tt|U}})
:* one of
::* {{spar|long-suffix}} (the character {{tt|l}} or the character {{tt|L}})
{{rrev|since=c++11|
::* {{spar|long-long-suffix}} (the character sequence {{tt|ll}} or the character sequence {{tt|LL}})
}}
{{rrev|since=c++23|
::* {{spar|size-suffix}} (the character {{tt|z}} or the character {{tt|Z}})
}}
{{anchor|Single quote}}
{{rrev|since=c++14|
Optional single quotes ({{c/core|'}}) may be inserted between the digits as a separator; they are ignored when determining the value of the literal.
}}
An integer literal (as any literal) is a {{rlp|expressions#Primary expressions|primary expression}}.

===Explanation===
@1@ Decimal integer literal (base 10).
@2@ Octal integer literal (base 8).
@3@ Hexadecimal integer literal (base 16, the letters {{c/core|'a'}} through {{c/core|'f'}} represent values (decimal) 10 through 15).
@4@ Binary integer literal (base 2).

The first digit of an integer literal is the most significant.

Example. The following variables are initialized to the same value:
{{source|1=
int d = 42;
int o = 052;
int x = 0x2a;
int X = 0X2A;
int b = 0b101010; // C++14
}}

Example. The following variables are also initialized to the same value:
{{source|1=
unsigned long long l1 = 18446744073709550592ull;       // C++11
unsigned long long l2 = 18'446'744'073'709'550'592llu; // C++14
unsigned long long l3 = 1844'6744'0737'0955'0592uLL;   // C++14
unsigned long long l4 = 184467'440737'0'95505'92LLU;   // C++14
}}

===The type of the literal===
The type of the integer literal is the first type in which the value can fit, from the list of types which depends on which numeric base and which {{spar|integer-suffix}} was used:

{|class="wikitable"
|-style="text-align:center"
!Suffix
!Decimal bases
!Binary, octal, or hexadecimal bases
|-style="text-align:left"
|(no suffix)
|
* {{c/core|int}}
* {{c/core|long int}}
* {{c/core|long long int}} {{mark since c++11}}
|
* {{c/core|int}}
* {{c/core|unsigned int}}
* {{c/core|long int}}
* {{c/core|unsigned long int}}
* {{c/core|long long int}} {{mark since c++11}}
* {{c/core|unsigned long long int}} {{mark since c++11}}
|-
|{{tt|u}} or {{tt|U}}
|
* {{c/core|unsigned int}}
* {{c/core|unsigned long int}}
* {{c/core|unsigned long long int}} {{mark since c++11}}
|
* {{c/core|unsigned int}}
* {{c/core|unsigned long int}}
* {{c/core|unsigned long long int}} {{mark since c++11}}
|-
|{{tt|l}} or {{tt|L}}
|
* {{c/core|long int}}
* {{c/core|unsigned long int}} {{mark until c++11}}
* {{c/core|long long int}} {{mark since c++11}}
|
* {{c/core|long int}}
* {{c/core|unsigned long int}}
* {{c/core|long long int}} {{mark since c++11}}
* {{c/core|unsigned long long int}} {{mark since c++11}}
|-
|both {{tt|l}}/{{tt|L}}&lt;br&gt;and {{tt|u}}/{{tt|U}}
|
* {{c/core|unsigned long int}}
* {{c/core|unsigned long long int}} {{mark since c++11}}
|
* {{c/core|unsigned long int}}
* {{c/core|unsigned long long int}} {{mark since c++11}}
|-
|{{tt|ll}} or {{tt|LL}}
|
* {{c/core|long long int}} {{mark since c++11}}
|
* {{c/core|long long int}} {{mark since c++11}}
* {{c/core|unsigned long long int}} {{mark since c++11}}
|-
|both {{tt|ll}}/{{tt|LL}}&lt;br&gt;and {{tt|u}}/{{tt|U}}
|
* {{c/core|unsigned long long int}} {{mark since c++11}}
|
* {{c/core|unsigned long long int}} {{mark since c++11}}
|-
|{{tt|z}} or {{tt|Z}}
|
* the signed version of {{lc|std::size_t}} {{mark since c++23}}
|
* the signed version of {{lc|std::size_t}} {{mark since c++23}}
* {{lc|std::size_t}} {{mark since c++23}}
|-
|both {{tt|z}}/{{tt|Z}}&lt;br&gt;and {{tt|u}}/{{tt|U}}
|
* {{lc|std::size_t}} {{mark since c++23}}
|
* {{lc|std::size_t}} {{mark since c++23}}
|}

If the value of the integer literal {{rev inl|since=c++23|that does not have {{spar|size-suffix}}}} is too big to fit in any of the types allowed by suffix/base combination and the compiler supports an extended integer type (such as {{c|__int128}}) which can represent the value of the literal, the literal may be given that extended integer type â€” otherwise the program is ill-formed.

===Notes===
Letters in the integer literals are case-insensitive: {{tt|0xDeAdBeEfU}} and {{tt|0XdeadBEEFu}} represent the same number {{rev inl|since=c++11|(one exception is the {{spar|long-long-suffix}}, which is either {{tt|ll}} or {{tt|LL}}, never {{tt|lL}} or {{tt|Ll}})}}.

There are no negative integer literals. Expressions such as {{c|-1}} apply the {{rlp|operator_arithmetic|unary minus operator}} to the value represented by the literal, which may involve implicit type conversions.

In C prior to C99 (but not in C++), unsuffixed decimal values that do not fit in {{c/core|long int}} are allowed to have the type {{c/core|unsigned long int}}.

{{rrev|since=c++11|
When used in a controlling expression of {{ltt|cpp/preprocessor/conditional|#if}} or {{ltt|cpp/preprocessor/conditional|#elif}}, all signed integer constants act as if they have type {{lc|std::intmax_t}} and all unsigned integer constants act as if they have type {{lc|std::uintmax_t}}.
}}

Due to {{rlp|translation_phases#maximal munch|maximal munch}}, hexadecimal integer literals ending in {{ttb|e}} and {{ttb|E}}, when followed by the operators {{ttb|+}} or {{ttb|-}}, must be separated from the operator with whitespace or parentheses in the source:

{{source|1=
auto x = 0xE+2.0;   // error
auto y = 0xa+2.0;   // OK
auto z = 0xE +2.0;  // OK
auto q = (0xE)+2.0; // OK
}}

Otherwise, a single invalid preprocessing number token is formed, which causes further analysis to fail.

{{ftm begin|std=1|comment=1}}
{{ftm|value=201304L|std=C++14|__cpp_binary_literals|[[#Syntax|Binary literals]]}}
{{ftm|value=202011L|std=C++23|__cpp_size_t_suffix|Literal suffixes for {{lc|std::size_t}} and its signed version}}
{{ftm end}}

===Example===
{{example|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;

int main()
{
    std::cout &lt;&lt; 123 &lt;&lt; '\n'
              &lt;&lt; 0123 &lt;&lt; '\n'
              &lt;&lt; 0x123 &lt;&lt; '\n'
              &lt;&lt; 0b10 &lt;&lt; '\n'
              &lt;&lt; 12345678901234567890ull &lt;&lt; '\n'
              &lt;&lt; 12345678901234567890u &lt;&lt; '\n'; // the type is unsigned long long
                                                // even without a long long suffix

//  std::cout &lt;&lt; -9223372036854775808 &lt;&lt; '\n'; // error: the value
               // 9223372036854775808 cannot fit in signed long long, which is the
               // biggest type allowed for unsuffixed decimal integer literal
    std::cout &lt;&lt; -9223372036854775808u &lt;&lt; '\n'; // unary minus applied to unsigned
               // value subtracts it from 2^64, this gives 9223372036854775808
    std::cout &lt;&lt; -9223372036854775807 - 1 &lt;&lt; '\n'; // correct way to calculate
                                                   // the value -9223372036854775808

#if __cpp_size_t_suffix &gt;= 202011L // C++23
    static_assert(std::is_same_v&lt;decltype(0UZ), std::size_t&gt;);
    static_assert(std::is_same_v&lt;decltype(0Z), std::make_signed_t&lt;std::size_t&gt;&gt;);
#endif
}
|output=
123
83
291
2
12345678901234567890
12345678901234567890
9223372036854775808
-9223372036854775808
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=2698|std=C++23|before=an integer literal with {{spar|size-suffix}} could have an extended integer type|after=ill-formed if too large}}
{{dr list end}}

===References===
{{ref std c++23}}
{{ref std|section=5.13.2|title=Integer literals|id=lex.icon}}
&lt;!--{{ref std|section = 7.5.1|title= Literals|id =expr.prim.literal}}
This is the source for the claim "An integer literal (as any literal) is a primary expression. "
It could be added here, but it should probably be added to the expressions page instead--&gt;
{{ref std end}}
{{ref std c++20}}
{{ref std|section=5.13.2|title=Integer literals|id=lex.icon}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=5.13.2|title=Integer literals|id=lex.icon}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=2.14.2|title=Integer literals|id=lex.icon}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=2.14.2|title=Integer literals|id=lex.icon}}
{{ref std end}}
&lt;!--{{ref std c++03}}
{{ref std|section=2.13.1|title=Integer literals|id=lex.icon}}
{{ref std end}}--&gt;
{{ref std c++98}}
{{ref std|section=2.13.1|title=Integer literals|id=lex.icon}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc user literal}}
{{dsc see c|c/language/integer constant|integer constant|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}