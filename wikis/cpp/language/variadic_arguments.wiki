{{title|Variadic arguments}}
{{cpp/language/functions/navbar}}

Allows a function to accept any number of extra arguments.

A function is a variadic if the last parameter of its {{rlpsd|function#Parameter list}} is an ellipsis ({{c|...}}).

{{rev begin}}
&lt;tr class="t-rev"&gt;
&lt;td&gt;The comma preceding the ellipsis can be omitted.&lt;/td&gt;
&lt;td&gt;{{mark deprecated c++26}}&lt;/td&gt;
&lt;/tr&gt;
{{rev end}}

{{source|1=
// the function declared as follows
int printx(const char* fmt, ...);
int printx(const char* fmt...); // same as above, but deprecated since C++26

// may be called with one or more arguments:
printx("hello world");
printx("a=%d b=%d", a, b);

int printy(..., const char* fmt); // error: ... can only be the last parameter
int printz(...); // valid, but the arguments cannot be accessed portably &lt;!-- before C++26 per P2537 --&gt;
}}

{{rrev|since=c++11|
This is different from a function {{rlp|parameter pack}} expansion, which is indicated by an ellipsis that is a part of a parameter declarator, rather than an ellipsis being a parameter alone. Both parameter pack expansion and the “variadic” ellipsis may appear in the declaration of a function template, as in the case of {{lc|std::is_function}}.
}}

===Default argument promotions===
When a variadic function is called, after lvalue-to-rvalue, array-to-pointer, and function-to-pointer {{rlp|implicit conversion#Value transformations|conversions}}, each argument that is a part of the variable argument list undergoes additional conversions known as ''default argument promotions'':

{{rrev|since=c++11|
* {{lc|std::nullptr_t}} is converted to {{c/core|void*}}.
}}
* {{c/core|float}} arguments are converted to {{c/core|double}} as in {{rlpsd|implicit conversion#Floating-point promotion}}.
* {{c/core|bool}}, {{c/core|char}}, {{c/core|short}}, and unscoped enumerations are converted to {{c/core|int}} or wider integer types as in {{rlpsd|implicit conversion#Integral promotion}}.

{{rev inl|until=c++11|Non-POD class types}}{{rev inl|since=c++11|Scoped enumerations and class types with an eligible non-trivial copy constructor, an eligible non-trivial move constructor, or a non-trivial destructor}} are conditionally-supported in potentially-evaluated calls with implementation-defined semantics (these types are always supported in {{rlp|expressions#Potentially-evaluated expressions|unevaluated calls}}).

Because variadic parameters have the lowest rank for the purpose of {{rlp|overload resolution}}, they are commonly used as the catch-all fallbacks in {{rlp|sfinae|SFINAE}}.

Within the body of a function that uses variadic arguments, the values of these arguments may be accessed using the [[cpp/utility/variadic|{{tt|&lt;cstdarg&gt;}} library facilities]]:
{{dsc begin}}
{{dsc header|cstdarg}}
{{dsc inc|cpp/utility/variadic/dsc va_start}}
{{dsc inc|cpp/utility/variadic/dsc va_arg}}
{{dsc inc|cpp/utility/variadic/dsc va_copy}}
{{dsc inc|cpp/utility/variadic/dsc va_end}}
{{dsc inc|cpp/utility/variadic/dsc va_list}}
{{dsc end}}

The behavior of the {{lc|va_start}} macro is undefined if the last parameter before the ellipsis has reference type, or has type that is not {{lt|c/language/type#Compatible types|compatible}} with the type that results from default argument promotions.

{{rrev|since=c++11|
If the a {{rlpsd|parameter pack#Pack expansion}} or an entity resulting from a {{rlpsd|lambda#Lambda capture}} is used as the last parameter in {{lc|va_start}}, the program is ill-formed, no diagnostic required.
}}

===Alternatives===
{{rrev|since=c++11|
* {{rlp|parameter pack|Variadic templates}} can also be used to create functions that take variable number of arguments.  They are often the better choice because they do not impose restrictions on the types of the arguments, do not perform integral and floating-point promotions, and are type safe.
* If all variable arguments share a common type, a {{lc|std::initializer_list}} provides a convenient mechanism (albeit with a different syntax) for accessing variable arguments. In this case however the arguments cannot be modified since {{lc|std::initializer_list}} can only provide a const pointer to its elements.
}}

===Notes===
In the C programming language until C23, at least one named parameter must appear before the ellipsis parameter, so {{c|R printz(...);}} is not valid until C23. In C++, this form is allowed even though the arguments passed to such function are not accessible, and is commonly used as the fallback overload in {{rlp|sfinae|SFINAE}}, exploiting the lowest priority of the ellipsis conversion in {{rlp|overload resolution}}.

This syntax for variadic arguments was introduced in 1983 C++ without the comma before the ellipsis. When C89 adopted function prototypes from C++, it replaced the syntax with one requiring the comma. For compatibility, C++98 accepts both C++-style {{c|f(int n...)}} and C-style {{c|f(int n, ...)}}. The original C++-style grammar is deprecated since C++26.

{{rrev|since=c++20|
The comma can be used in abbreviated function templates to make the ellipsis signify a variadic function instead of a variadic template:

{{c multi
|void f1(auto...);   // same as template&lt;class... Ts&gt; void f3(Ts...)
|void f2(auto, ...); // same as template&lt;class T&gt; void f3(T, ...)
}}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=506|std=C++98|before=passing non-POD class arguments to an&lt;br&gt;ellipsis resulted in undefined behavior|after=passing such arguments is&lt;br&gt;conditionally-supported with&lt;br&gt;implementation-defined semantics}}
{{dr list item|wg=cwg|dr=634|std=C++98|before=conditionally-supported class types&lt;br&gt;made some SFINAE idioms not work|after=always supported if unevaluated}}
{{dr list item|wg=cwg|dr=2247|std=C++11|before=no restriction on passing parameter&lt;br&gt;pack or lambda capture to {{tt|va_start}}|after=made ill-formed,&lt;br&gt;no diagnostic required}}
{{dr list item|wg=cwg|dr=2347|std=C++11|before=it was unclear whether scoped enumerations passed to&lt;br&gt;an ellipsis are subject to default argument promotions|after=passing scoped enumerations&lt;br&gt;is conditionally-supported with&lt;br&gt;implementation-defined semantics}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc see c|c/language/variadic|Variadic arguments|nomono=true}}
{{dsc see c|c/language/conversion|Implicit conversions|nomono=true}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}