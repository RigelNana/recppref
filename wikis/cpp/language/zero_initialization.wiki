{{title|Zero-initialization}}
{{cpp/language/initialization/navbar}}
Sets the initial value of an object to zero.

===Syntax===
Note that this is not the syntax for zero-initialization, which does not have a dedicated syntax in the language. These are examples of other types of initializations, which might perform zero-initialization.

{{sdsc begin}}
{{sdsc|num=1|{{ttb|static}} {{spar|T}} {{spar|object}} {{ttb|;}}}}
{{sdsc|num=2|
{{spar|T}} {{ttb|()}} {{ttb|;}}

{{spar|T}} {{spar|t}} {{ttb|{{=}}}} {{ttb|{}&lt;!-- --&gt;}} {{ttb|;}}

{{spar|T}} {{ttb|{}&lt;!-- --&gt;}} {{ttb|;}} {{mark since c++11}}
}}
{{sdsc|num=3|{{spar|CharT}} {{spar|array}} {{ttb|[}} {{spar|n}} {{ttb|]}} {{ttb|{{=}}}} {{ttb|"}} {{spar|short-sequence}} {{ttb|";}}}}
{{sdsc end}}

===Explanation===
Zero-initialization is performed in the following situations:
@1@ For every named variable with static{{rev inl|since=c++11| or thread-local}} {{rlp|storage duration}} that is not subject to {{rlp|constant initialization}}, before any other initialization.
@2@ As part of {{rlp|value initialization|value-initialization}} sequence for non-class types and for members of value-initialized class types that have no constructors, including value initialization of elements of {{rlp|aggregate initialization|aggregates}} for which no initializers are provided.
@3@ When an array of any {{rlp|types#Character types|character type}} is {{rlp|aggregate initialization#Character arrays|initialized with a string literal}} that is too short, the remainder of the array is zero-initialized.

The effects of zero-initialization are:
* If {{tt|T}} is a [[cpp/named req/ScalarType|scalar type]], the object is initialized to the value obtained by {{rlp|explicit cast|explicitly converting}} the integer literal {{c|0}} (zero) to {{tt|T}}. 
* If {{tt|T}} is a non-union class type:
:* all {{rlp|object#Object representation and value representation|padding bits}} are initialized to zero bits,
:* each non-static {{rlp|data members|data member}} is zero-initialized,
:* each non-virtual base class {{rlp|object#Subobjects|subobject}} is zero-initialized, and
:* if the object is not a base class subobject, each {{rlp|derived class#Virtual base classes|virtual base class}} subobject is zero-initialized.
* If {{tt|T}} is a union type:
:* all padding bits are initialized to zero bits, and
:* the objectâ€™s first non-static named data member is zero-initialized.
* If {{tt|T}} is array type, each element is zero-initialized.
* If {{tt|T}} is reference type, nothing is done.

===Notes===
As described in {{rlp|initialization#Non-local variables|non-local initialization}}, static{{rev inl|since=c++11| and thread-local}} variables that aren't constant-initialized are zero-initialized before any other initialization takes place. If the definition of a non-class non-local variable has no initializer, then default initialization does nothing, leaving the result of the earlier zero-initialization unmodified.

A zero-initialized pointer is the null pointer value of its type, even if the value of the null pointer is not integral zero.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;

struct A
{
    int a, b, c;
};

double f[3];   // zero-initialized to three 0.0's

int* p;        // zero-initialized to null pointer value
               // (even if the value is not integral 0)

std::string s; // zero-initialized to indeterminate value, then
               // default-initialized to "" by the std::string default constructor

int main(int argc, char*[])
{
    delete p; // safe to delete a null pointer
    
    static int n = argc; // zero-initialized to 0 then copy-initialized to argc
    std::cout &lt;&lt; "n = " &lt;&lt; n &lt;&lt; '\n';
    
    A a = A(); // the effect is same as: A a{}; or A a = {};
    std::cout &lt;&lt; "a = {" &lt;&lt; a.a &lt;&lt; ' ' &lt;&lt; a.b &lt;&lt; ' ' &lt;&lt; a.c &lt;&lt; "}\n";
}
|p=true &lt;!-- argc --&gt;
|output=
n = 1
a = {0 0 0}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=277|std=C++98|before=pointers might be initialized with a non-constant&lt;br&gt;expression of value 0, which is not a null pointer constant|after=must initialize with an integral&lt;br&gt;constant expression of value 0}}
{{dr list item|wg=cwg|dr=694|std=C++98|before=zero-initialization for class types ignored padding|after=padding is initialized to zero bits}}
{{dr list item|wg=cwg|dr=903|std=C++98|before=zero-initialization for scalar types set the initial value to the value&lt;br&gt;converted from an integral constant expression with value 0|after=the object is initialized to the value&lt;br&gt;converted from the integer literal {{c|0}}}}
{{dr list item|wg=cwg|dr=2026|std=C++98|before=zero-initialization was specified to always&lt;br&gt;occur first, even before constant initialization|after=no zero-initialization if&lt;br&gt;constant initialization applies}}
{{dr list item|wg=cwg|dr=2196|std=C++98|before=zero-initialization for class types ignored base class subobjects|after=they are also zero-initialized}}
{{dr list item|wg=cwg|dr=2253|std=C++98|before=it was unclear whether zero-initialization&lt;br&gt;applies to unnamed bit-fields|after=it applies (all padding bits&lt;br&gt;are initialized to zero bits)}}
{{dr list end}}

===See also===
* {{rlp|constructor}}
* {{rlp|copy assignment}}
* {{rlp|default constructor}}
* {{rlp|initialization}}
** {{rlp|aggregate initialization}}
** {{rlp|constant initialization}}
** {{rlp|copy initialization}}
** {{rlp|default initialization}}
** {{rlp|direct initialization}}
** {{rlp|list initialization}}
** {{rlp|value initialization}}
* {{rlp|move assignment}}
* {{rlpt|new}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}