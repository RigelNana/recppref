{{title|C++ Operator Precedence}}
{{cpp/language/expressions/navbar}}
The following table lists the precedence and associativity of C++ operators. Operators are listed top to bottom, in descending precedence. {{c|a}}, {{c|b}} and {{c|c}} are operands.

{|class="wikitable"
|-
!style="text-align: left"|Precedence
!style="text-align: left"|Operator
!style="text-align: left"|Description
!style="text-align: left"|Associativity
|-
!1&lt;!-- Numbering should start from the highest precedence. See also the discussion page. --&gt;
|{{c|a::b}}
|{{rlp|identifiers#Qualified identifiers|Scope resolution}}
|style="vertical-align: top" rowspan="6"|Left-to-right &amp;#8594;
|-
!rowspan=5|2
|style="border-bottom-style: none"|{{c|a++}}{{nbsp}}{{c|a--}}
|style="border-bottom-style: none"|Suffix/postfix {{rlp|operator incdec|increment and decrement}}
|-
|style="border-bottom-style: none; border-top-style: none"|{{box|{{tt|''type''}}{{c/core|(a)}}}}{{nbsp}}{{box|{{tt|''type''}}{{c/core|{a}&lt;!----&gt;}}}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|explicit cast|Functional cast}}
|-
|style="border-bottom-style: none; border-top-style: none"|{{c|a()}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|operator other#Built-in function call operator|Function call}}
|-
|style="border-bottom-style: none; border-top-style: none"|{{c|a[]}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|operator member access#Built-in subscript operator|Subscript}}
|-
|style="border-bottom-style: none; border-top-style: none"|{{c|a.b}}{{nbsp}}{{c|a-&gt;b}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|operator member access#Built-in member access operators|Member access}}
|-
!rowspan=10|3
|style="border-bottom-style: none"|{{c|++a}}{{nbsp}}{{c|--a}}
|style="border-bottom-style: none"|Prefix {{rlp|operator incdec|increment and decrement}}
|style="vertical-align: top" rowspan="10"|Right-to-left &amp;#8592;
|-
|style="border-bottom-style: none; border-top-style: none"|{{c|+a}}{{nbsp}}{{c|-a}}
|style="border-bottom-style: none; border-top-style: none"|Unary {{rlp|operator arithmetic#Unary arithmetic operators|plus and minus}}
|-
|style="border-bottom-style: none; border-top-style: none"|{{c|!a}}{{nbsp}}{{c|~a}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|operator logical|Logical NOT}} and {{rlp|operator arithmetic#Bitwise logic operators|bitwise NOT}}
|-
|style="border-bottom-style: none; border-top-style: none"|{{box|{{c/core|(}}{{tt|''type''}}{{c/core|)a}}}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|explicit cast|C-style cast}}
|-
|style="border-bottom-style: none; border-top-style: none"|{{c|*a}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|operator member access#Built-in indirection operator|Indirection}} (dereference)
|-
|style="border-bottom-style: none; border-top-style: none"|{{c|&amp;a}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|operator member access#Built-in address-of operator|Address-of}}
|-
|style="border-bottom-style: none; border-top-style: none"|{{rlpt|sizeof}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|sizeof|Size-of}}&lt;ref group="note"&gt;The operand of {{c/core|sizeof}} cannot be a C-style type cast: the expression {{c|sizeof (int) * p}} is unambiguously interpreted as {{c|(sizeof(int)) * p}}, but not {{c|sizeof((int)*p)}}.&lt;/ref&gt;
|-
|style="border-bottom-style: none; border-top-style: none"|{{ltt|cpp/keyword/co_await}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|coroutines|await-expression}} {{mark c++20}}
|-
|style="border-bottom-style: none; border-top-style: none"|{{rlpt|new}}{{nbsp}}&amp;ndash;{{nbsp}}{{rlpt|new|new[]}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|new|Dynamic memory allocation}}
|-
|style="border-top-style: none"|{{rlpt|delete}}{{nbsp}}&amp;ndash;{{nbsp}}{{rlpt|delete|delete[]}}
|style="border-top-style: none"|{{rlp|delete|Dynamic memory deallocation}}
|-
!4
|{{c|a.*b}}{{nbsp}}{{c|a-&gt;*b}}
|{{rlp|operator member access#Built-in pointer-to-member access operators|Pointer-to-member}}
|style="vertical-align: top" rowspan="12"|Left-to-right &amp;#8594;
|-
!5
|{{c|a * b}}{{nbsp}}{{c|a / b}}{{nbsp}}{{c|a % b}}
|{{rlp|operator arithmetic#Multiplicative operators|Multiplication, division, and remainder}}
|-
!6
|{{c|a + b}}{{nbsp}}{{c|a - b}}
|{{rlp|operator arithmetic#Additive operators|Addition and subtraction}}
|-
!7
|{{c|a &lt;&lt; b}}{{nbsp}}{{c|a &gt;&gt; b}}
|Bitwise {{rlp|operator arithmetic#Bitwise shift operators|left shift and right shift}}
|-
!8
|{{c|1=a &lt;=&gt; b}}
|[[cpp/language/operator comparison#Three-way comparison|Three-way comparison operator]] {{mark since c++20}}
|-
!9
|{{c|a &lt; b}}{{nbsp}}{{c|1=a &lt;= b}}{{nbsp}}{{c|a &gt; b}}{{nbsp}}{{c|1=a &gt;= b}}
|For {{rlp|operator comparison|relational operators}} {{ttb|&lt;}} and {{ttb|1=&lt;=}} and {{ttb|1=&gt;}} and {{ttb|1=&gt;=}} respectively
|-
!10
|{{c|1=a == b}}{{nbsp}}{{c|1=a != b}}
|For {{rlp|operator comparison|equality operators}} {{ttb|1==}} and {{ttb|1=!=}} respectively
|-
!11
|{{c|a &amp; b}}
|{{rlp|operator arithmetic#Bitwise logic operators|Bitwise AND}}
|-
!12
|{{c|a ^ b}}
|{{rlp|operator arithmetic#Bitwise logic operators|Bitwise XOR}} (exclusive or)
|-
!13
|{{c|a {{!}} b}}
|{{rlp|operator arithmetic#Bitwise logic operators|Bitwise OR}} (inclusive or)
|-
!14
|{{c|a &amp;&amp; b}}
|{{rlp|operator logical|Logical AND}}
|-
!15
|{{c|a {{!!}} b}}
|{{rlp|operator logical|Logical OR}}
|-
!rowspan=8|16
|style="border-bottom-style: none"|{{c|a ? b : c}}
|style="border-bottom-style: none"|{{rlp|operator other#Conditional operator|Ternary conditional}}&lt;ref group="note"&gt;The expression in the middle of the conditional operator (between {{ttb|?}} and {{ttb|:}}) is parsed as if parenthesized: its precedence relative to {{ttb|?:}} is ignored.&lt;/ref&gt;
|style="vertical-align: top" rowspan="8"|Right-to-left &amp;#8592;
|-
|style="border-bottom-style: none; border-top-style: none"|{{rlpt|throw}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|throw|throw operator}}
|-
|style="border-bottom-style: none; border-top-style: none"|{{ltt|cpp/keyword/co_yield}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|coroutines|yield-expression}} {{mark c++20}}
|-
|style="border-bottom-style: none; border-top-style: none"|{{c|1=a = b}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|operator assignment#Builtin direct assignment|Direct assignment}} (provided by default for C++ classes)
|-
|style="border-bottom-style: none; border-top-style: none"|{{c|1=a += b}}{{nbsp}}{{c|1=a -= b}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|operator assignment#Builtin compound assignment|Compound assignment}} by sum and difference
|-
|style="border-bottom-style: none; border-top-style: none"|{{c|1=a *= b}}{{nbsp}}{{c|1=a /= b}}{{nbsp}}{{c|1=a %= b}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|operator assignment#Builtin compound assignment|Compound assignment}} by product, quotient, and remainder
|-
|style="border-bottom-style: none; border-top-style: none"|{{c|1=a &lt;&lt;= b}}{{nbsp}}{{c|1=a &gt;&gt;= b}}
|style="border-bottom-style: none; border-top-style: none"|{{rlp|operator assignment#Builtin compound assignment|Compound assignment}} by bitwise left shift and right shift
|-
|style="border-top-style: none"|{{c|1=a &amp;= b}}{{nbsp}}{{c|1=a ^= b}}{{nbsp}}{{c|1=a {{!}}= b}}
|style="border-top-style: none"|{{rlp|operator assignment#Builtin compound assignment|Compound assignment}} by bitwise AND, XOR, and OR
|-
!17
|{{c|a, b}}
|{{rlp|operator other#Built-in comma operator|Comma}}
|Left-to-right &amp;#8594;
|}
&lt;references group="note" /&gt;

When parsing an expression, an operator which is listed on some row of the table above with a precedence will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it with a lower precedence. For example, the expressions {{c|std::cout &lt;&lt; a &amp; b}} and  {{c|*p++}} are parsed as {{c|(std::cout &lt;&lt; a) &amp; b}} and {{c|*(p++)}}, and not as {{c|std::cout &lt;&lt; (a &amp; b)}} or {{c|(*p)++}}.

Operators that have the same precedence are bound to their arguments in the direction of their associativity. For example, the expression {{c|1=a = b = c}} is parsed as {{c|1=a = (b = c)}}, and not as {{c|1=(a = b) = c}} because of right-to-left associativity of assignment, but {{c|a + b - c}} is parsed {{c|(a + b) - c}} and not {{c|a + (b - c)}} because of left-to-right associativity of addition and subtraction.

Associativity specification is redundant for unary operators and is only shown for completeness: unary prefix operators always associate right-to-left ({{c|delete ++*p}} is {{c|delete(++(*p))}}) and unary postfix operators always associate left-to-right ({{c|a[1][2]++}} is {{c|((a[1])[2])++}}). Note that the associativity is meaningful for member access operators, even though they are grouped with unary postfix operators: {{c|a.b++}} is parsed {{c|(a.b)++}} and not {{c|a.(b++)}}.

Operator precedence is unaffected by {{rlp|operators|operator overloading}}. For example, {{c|std::cout &lt;&lt; a ? b : c;}} parses as {{c|(std::cout &lt;&lt; a) ? b : c;}} because the precedence of arithmetic left shift is higher than the conditional operator.

===Notes===
Precedence and associativity are compile-time concepts and are independent from {{rlp|eval order|order of evaluation}}, which is a runtime concept.

The standard itself doesn't specify precedence levels. They are derived from the grammar.

{{rlpt|const_cast}}, {{rlpt|static_cast}}, {{rlpt|dynamic_cast}}, {{rlpt|reinterpret_cast}}, {{rlpt|typeid}}, {{rlpt|sizeof...}}, {{rlpt|noexcept}} and {{rlpt|alignof}} are not included since they are never ambiguous.

Some of the operators have {{rlp|operator alternative|alternate spellings}} (e.g., {{c/core|and}} for {{c/core|&amp;&amp;}}, {{c/core|or}} for {{c/core|{{!!}}}}, {{c/core|not}} for {{c/core|!}}, etc.).

In C, the ternary conditional operator has higher precedence than assignment operators. Therefore, the expression {{c|1=e = a &lt; d ? a++ : a = d}}, which is parsed in C++ as {{c|1=e = ((a &lt; d) ? (a++) : (a = d))}}, will fail to compile in C due to grammatical or semantic constraints in C. See the corresponding C page for details.

===See also===
{{cpp/language/operators}}
{{dsc begin}}
{{dsc see c|c/language/operator precedence|C operator precedence|nomono=true}}
{{dsc end}}

{{langlinks|ar|cs|de|es|fr|it|ja|ko|pt|ru|tr|zh}}