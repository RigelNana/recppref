{{title|Assignment operators}}
{{cpp/language/expressions/navbar}}
Assignment operators modify the value of the object. 

{|class="wikitable" style="font-size:85%;"
|-
!rowspan="2"|Operator name
!rowspan="2"|&amp;nbsp;Syntax&amp;nbsp;
!rowspan="2"|{{rlp|operators|Over&amp;#8203;load&amp;#8203;able}}
!colspan="2"|Prototype examples (for {{c/core|class T}})
|-
!Inside class definition
!Outside class definition
|-
|simple assignment 
|{{tt|1=a = b}} 
|{{yes}}
|{{c|1=T&amp; T::operator =(const T2&amp; b);}} 
|{{n/a}}
|-
|addition assignment 
|{{tt|1=a += b}}
|{{yes}}
|{{c|1=T&amp; T::operator +=(const T2&amp; b);}}
|{{c|1=T&amp; operator +=(T&amp; a, const T2&amp; b);}}
|-
|subtraction assignment 
|{{tt|1=a -= b}}
|{{yes}}
|{{c|1=T&amp; T::operator -=(const T2&amp; b);}}
|{{c|1=T&amp; operator -=(T&amp; a, const T2&amp; b);}}
|-
|multiplication assignment 
|{{tt|1=a *= b}}
|{{yes}}
|{{c|1=T&amp; T::operator *=(const T2&amp; b);}}
|{{c|1=T&amp; operator *=(T&amp; a, const T2&amp; b);}}
|-
|division assignment 
|{{tt|1=a /= b}}
|{{yes}}
|{{c|1=T&amp; T::operator /=(const T2&amp; b);}}
|{{c|1=T&amp; operator /=(T&amp; a, const T2&amp; b);}}
|-
|remainder assignment 
|{{tt|1=a %= b}}
|{{yes}}
|{{c|1=T&amp; T::operator %=(const T2&amp; b);}}
|{{c|1=T&amp; operator %=(T&amp; a, const T2&amp; b);}}
|-
|bitwise AND assignment 
|{{tt|1=a &amp;= b}}
|{{yes}}
|{{c|1=T&amp; T::operator &amp;=(const T2&amp; b);}}
|{{c|1=T&amp; operator &amp;=(T&amp; a, const T2&amp; b);}}
|-
|bitwise OR assignment 
|{{tt|1=a &amp;#124;= b}}
|{{yes}}
|{{c|1=T&amp; T::operator {{!}}=(const T2&amp; b);}}
|{{c|1=T&amp; operator {{!}}=(T&amp; a, const T2&amp; b);}}
|-
|bitwise XOR assignment 
|{{tt|1=a ^= b}}
|{{yes}}
|{{c|1=T&amp; T::operator ^=(const T2&amp; b);}}
|{{c|1=T&amp; operator ^=(T&amp; a, const T2&amp; b);}}
|-
|bitwise left shift assignment 
|{{tt|1=a &lt;&lt;= b}}
|{{yes}}
|{{c|1=T&amp; T::operator &lt;&lt;=(const T2&amp; b);}}
|{{c|1=T&amp; operator &lt;&lt;=(T&amp; a, const T2&amp; b);}}
|-
|bitwise right shift assignment 
|{{tt|1=a &gt;&gt;= b}}
|{{yes}}
|{{c|1=T&amp; T::operator &gt;&gt;=(const T2&amp; b);}}
|{{c|1=T&amp; operator &gt;&gt;=(T&amp; a, const T2&amp; b);}}
|-
|colspan="5"|
:'''Notes'''&lt;br&gt;
* All built-in assignment operators return {{c|*this}}, and most {{rlp|operators|user-defined overloads}} also return {{c|*this}} so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including {{c/core|void}}).
* {{tt|T2}} can be any type including {{tt|T}}.
|}

===Definitions===
''Copy assignment'' replaces the contents of the object {{c|a}} with a copy of the contents of {{c|b}} ({{c|b}} is not modified). For class types, this is performed in a special member function, described in {{rlp|copy assignment|copy assignment operator}}.

{{rrev|since=c++11|1=
''Move assignment'' replaces the contents of the object {{c|a}} with the contents of {{c|b}}, avoiding copying if possible ({{c|b}} may be modified). For class types, this is performed in a special member function, described in {{rlp|move assignment|move assignment operator}}.
}}

For non-class types, copy and move assignment are indistinguishable and are referred to as ''direct assignment''.

''Compound assignment'' replace the contents of the object {{c|a}} with the result of a binary operation between the previous value of {{c|a}} and the value of {{c|b}}.

===Assignment operator syntax===
The assignment expressions have the form 

{{sdsc begin}}
{{sdsc|num=1|{{spar|target-expr}} {{ttb|1==}} {{spar|new-value}}}}
{{sdsc|num=2|{{spar|target-expr op new-value}}}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|target-expr}}|the expression&lt;ref&gt;{{spar|target-expr}} must have higher {{rlp|operator precedence|precedence}} than an assignment expression.&lt;/ref&gt; to be assigned to}}
{{par|{{spar|op}}|one of {{c|*{{=}}}}, {{c|/{{=}}}} {{c|%{{=}}}}, {{c|+{{=}}}} {{c|-{{=}}}},  {{c|&lt;&lt;{{=}}}}, {{c|&gt;&gt;{{=}}}}, {{c|&amp;{{=}}}}, {{c|^{{=}}}}, {{c|1={{!}}=}}}}
{{par|{{spar|new-value}}|the {{rev inl|until=c++11|expression&lt;ref&gt;{{spar|new-value}} cannot be a comma expression, because its {{rlp|operator precedence|precedence}} is lower.&lt;/ref&gt;}}{{rev inl|since=c++11|{{rlp|initialization#Initializer|initializer clause}}}} to assign to the target}}
{{par end}}
&lt;references/&gt;

@1@ Simple assignment expression.
@2@ Compound assignment expression.

{{rrev|since=c++11|If {{spar|new-value}} is not an expression, the assignment expression will never match an overloaded compound assignment operator.}}

===Built-in simple assignment operator===
For the built-in simple assignment, {{spar|target-expr}} must be a modifiable lvalue.

The object referred to by {{spar|target-expr}} is modified by replacing its value with the result of {{spar|new-value}}. If the object referred is of an integer type {{tt|T}}, and the result of {{spar|new-value}} is of the corresponding signed/unsigned integer type, the value of the object is replaced with the value of type {{tt|T}} with the same value representation of the result of {{spar|new-value}}.

The result of a built-in simple assignment is an lvalue of the type of {{spar|target-expr}}, referring to {{spar|target-expr}}. If {{spar|target-expr}} is a {{rlp|bit field|bit-field}}, the result is also a bit-field.

====Assignment from an expression====
If {{spar|new-value}} is an expression, it is {{rlp|implicit conversion|implicitly converted}} to
the cv-unqualified type of {{spar|target-expr}}. When {{spar|target-expr}} is a bit-field that cannot represent the value of the expression, the resulting value of the bit-field is implementation-defined.

If {{spar|target-expr}} and {{spar|new-value}} identify overlapping objects, the behavior is undefined (unless the overlap is exact and the type is the same).

{{rrev|since=c++20|
If the type of {{spar|target-expr}} is volatile-qualified, the assignment is deprecated, unless the (possibly parenthesized) assignment expression is a {{rlp|expressions#Discarded-value expressions|discarded-value expression}} or an {{rlp|expressions#Potentially-evaluated expressions|unevaluated operand}}.
}}


{{rrev|since=c++11|
====Assignment from a non-expression initializer clause====
{{spar|new-value}} is only allowed not to be an expression in following situations:
* {{spar|target-expr}} is of a [[cpp/named req/ScalarType|scalar type]] {{tt|T}}, and {{spar|new-value}} is empty or has only one element. In this case, given an invented variable {{c|t}} declared and initialized as {{box|{{c/core|1=T t =}}{{nbspt}}{{spar sep|new-value}}}}, the meaning of {{box|{{c/core|1=x =}}{{nbspt}}{{spar sep|new-value}}}} is {{c|1=x = t}}.
* {{spar|target-expr}} is of class type. In this case, {{spar|new-value}} is passed as the argument to the assignment operator function selected by {{rlp|overload resolution}}.

{{source|1=
#include &lt;complex&gt;

std::complex&lt;double&gt; z;
z = {1, 2};  // meaning z.operator=({1, 2})
z += {1, 2}; // meaning z.operator+=({1, 2})

int a, b;
a = b = {1}; // meaning a = b = 1;
a = {1} = b; // syntax error
}}
}}

In {{rlp|overload resolution#Call to an overloaded operator|overload resolution against user-defined operators}}, for every type {{tt|T}}, the following function signatures participate in overload resolution:
{{dcl begin}}
{{dcl|T*&amp; operator{{=}}(T*&amp;, T*);}}
{{dcl|T*volatile &amp; operator{{=}}(T*volatile &amp;, T*);}}
{{dcl end}}

For every enumeration or pointer to member type {{tt|T}}, optionally volatile-qualified, the following function signature participates in overload resolution:
{{dcl begin}}
{{dcl|T&amp; operator{{=}}(T&amp;, T);}}
{{dcl end}}

For every pair {{tt|A1}} and {{tt|A2}}, where {{tt|A1}} is an arithmetic type (optionally volatile-qualified) and {{tt|A2}} is a promoted arithmetic type, the following function signature participates in overload resolution:
{{dcl begin}}
{{dcl|A1&amp; operator{{=}}(A1&amp;, A2);}}
{{dcl end}}

===Built-in compound assignment operator===
The behavior of every built-in compound-assignment expression {{box|{{spar|target-expr}}{{nbspt}}{{tti|op}}{{sep}}{{c/core|1==}}{{nbspt}}{{spar|new-value}}}} is exactly the same as the behavior of the expression {{box|{{spar|target-expr}}{{nbspt}}{{c/core|1==}}{{nbspt}}{{spar|target-expr}}{{nbspt}}{{tti|op}}{{nbspt}}{{spar|new-value}}}}, except that {{spar|target-expr}} is evaluated only once.

The requirements on {{spar|target-expr}} and {{spar|new-value}} of built-in simple assignment operators also apply. Furthermore:
* For {{c|1=+=}} and {{c|1=-=}}, the type of {{spar|target-expr}} must be an {{rlp|type|arithmetic type}} or a pointer to a (possibly cv-qualified) completely-defined {{rlp|type|object type}}.
* For all other compound assignment operators, the type of {{spar|target-expr}} must be an arithmetic type.

In {{rlp|overload resolution#Call to an overloaded operator|overload resolution against user-defined operators}}, for every pair {{tt|A1}} and {{tt|A2}}, where {{tt|A1}} is an arithmetic type (optionally volatile-qualified) and {{tt|A2}} is a promoted arithmetic type, the following function signatures participate in overload resolution:
{{dcl begin}}
{{dcl|A1&amp; operator*{{=}}(A1&amp;, A2);}}
{{dcl|A1&amp; operator/{{=}}(A1&amp;, A2);}}
{{dcl|A1&amp; operator+{{=}}(A1&amp;, A2);}}
{{dcl|A1&amp; operator-{{=}}(A1&amp;, A2);}}
{{dcl end}}

For every pair {{tt|I1}} and {{tt|I2}}, where {{tt|I1}} is an integral type (optionally volatile-qualified) and {{tt|I2}} is a promoted integral type, the following function signatures participate in overload resolution:
{{dcl begin}}
{{dcl|I1&amp; operator%{{=}}(I1&amp;, I2);}}
{{dcl|I1&amp; operator&lt;&lt;{{=}}(I1&amp;, I2);}}
{{dcl|I1&amp; operator&gt;&gt;{{=}}(I1&amp;, I2);}}
{{dcl|I1&amp; operator&amp;{{=}}(I1&amp;, I2);}}
{{dcl|I1&amp; operator^{{=}}(I1&amp;, I2);}}
{{dcl|I1&amp; operator{{!}}{{=}}(I1&amp;, I2);}}
{{dcl end}}

For every optionally cv-qualified object type {{tt|T}}, the following function signatures participate in overload resolution:
{{dcl begin}}
{{dcl|T*&amp; operator+{{=}}(T*&amp;, std::ptrdiff_t);}}
{{dcl|T*&amp; operator-{{=}}(T*&amp;, std::ptrdiff_t);}}
{{dcl|T*volatile &amp; operator+{{=}}(T*volatile &amp;, std::ptrdiff_t);}}
{{dcl|T*volatile &amp; operator-{{=}}(T*volatile &amp;, std::ptrdiff_t);}}
{{dcl end}}

===Example===
{{example
|code=
#include &lt;iostream&gt;

int main()
{
    int n = 0;        // not an assignment
    
    n = 1;            // direct assignment
    std::cout &lt;&lt; n &lt;&lt; ' ';
    
    n = {};           // zero-initialization, then assignment
    std::cout &lt;&lt; n &lt;&lt; ' ';
    
    n = 'a';          // integral promotion, then assignment
    std::cout &lt;&lt; n &lt;&lt; ' ';
    
    n = {'b'};        // explicit cast, then assignment
    std::cout &lt;&lt; n &lt;&lt; ' ';
    
    n = 1.0;          // floating-point conversion, then assignment
    std::cout &lt;&lt; n &lt;&lt; ' ';
    
//  n = {1.0};        // compiler error (narrowing conversion)
    
    int&amp; r = n;       // not an assignment
    r = 2;            // assignment through reference
    std::cout &lt;&lt; n &lt;&lt; ' ';
    
    int* p;
    p = &amp;n;           // direct assignment
    p = nullptr;      // null-pointer conversion, then assignment
    std::cout &lt;&lt; p &lt;&lt; ' ';
    
    struct { int a; std::string s; } obj;
    obj = {1, "abc"}; // assignment from a braced-init-list
    std::cout &lt;&lt; obj.a &lt;&lt; ':' &lt;&lt; obj.s &lt;&lt; '\n';
}
|p=true
|output=
1 0 97 98 1 2 (nil) 1:abc
}}

===Defect reports===
{{dr list begin}}
&lt;!-- the resolution of CWG 324 changed the semantics of operations having bit-field operands, it is noted in the 'bit-field' page --&gt;
{{dr list item|wg=cwg|dr=1527|std=C++11|before=for assignments to class type objects, the right operand&lt;br&gt;could be an initializer list only when the assignment&lt;br&gt;is defined by a user-defined assignment operator|after=removed user-defined&lt;br&gt;assignment constraint}}
{{dr list item|wg=cwg|dr=1538|std=C++11|before={{c|1=E1 = {E2}&lt;!----&gt;}} was equivalent to {{c|1=E1 = T(E2)}}&lt;br&gt;({{tt|T}} is the type of {{tt|E1}}), this introduced a C-style cast|after=it is equivalent&lt;br&gt;to {{c|1=E1 = T{E2}&lt;!-- --&gt;}}}}
{{dr list item|wg=cwg|dr=2654|std=C++20|before=compound assignment operators for volatile&lt;br&gt;-qualified types were inconsistently deprecated|after=none of them&lt;br&gt;is deprecated}}
{{dr list item|wg=cwg|dr=2768|std=C++11|before=an assignment from a non-expression initializer clause&lt;br&gt;to a scalar value would perform direct-list-initialization|after=performs copy-list-&lt;br&gt;initialization instead}}
{{dr list item|wg=cwg|dr=2901|std=C++98|before=the value assigned to an {{c/core|unsigned int}}&lt;br&gt;object through an {{c/core|int}} lvalue is unclear|after=made clear}}
{{dr list item|paper=P2327R1|std=C++20|before=bitwise compound assignment operators for volatile types&lt;br&gt;were deprecated while being useful for some platforms|after=they are not&lt;br&gt;deprecated}}
{{dr list end}}

===See also===
{{rlp|operator precedence|Operator precedence}}

{{rlp|operators|Operator overloading}}

{{cpp/language/operators}}

{{dsc begin}}
{{dsc see c|c/language/operator assignment|Assignment operators|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}