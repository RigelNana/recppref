{{title|Expressions}}
{{cpp/language/expressions/navbar}}
An expression is a sequence of ''operators'' and their ''operands'', that specifies a computation.

Expression evaluation may produce a result (e.g., evaluation of {{c|2 + 2}} produces the result {{c|4}}) and may generate side-effects (e.g. evaluation of {{c|std::printf("%d", 4)}} prints the character {{c|'4'}} on the standard output).

Each C++ expression is characterized by two independent properties: A type and a value category.

====General====
* {{rlp|value category|value categories}} (lvalue, rvalue{{rev inl|since=c++11|, glvalue, prvalue, xvalue}}) classify expressions by their values
* {{rlp|eval order|order of evaluation}} of arguments and subexpressions specify the order in which intermediate results are obtained

===Operators===
{{cpp/language/operators}}

* {{rlp|operator precedence}} defines the order in which operators are bound to their arguments
* {{rlp|operator alternative|alternative representations}} are alternative spellings for some operators 
* {{rlp|operators|operator overloading}} makes it possible to specify the behavior of the operators with user-defined classes.

====Conversions====
* {{rlp|implicit conversion|standard conversions}} implicit conversions from one type to another
* {{rlp|const_cast|{{tt|const_cast}} conversion}}
* {{rlp|static_cast|{{tt|static_cast}} conversion}}
* {{rlp|dynamic_cast|{{tt|dynamic_cast}} conversion}}
* {{rlp|reinterpret_cast|{{tt|reinterpret_cast}} conversion}}
* {{rlp|explicit cast}} conversion using C-style cast notation and function-style notation
* {{rlp|cast operator|user-defined conversion}} makes it possible to specify conversion from user-defined classes

====Memory allocation====
* {{rlp|new|new expression}} allocates memory dynamically
* {{rlp|delete|delete expression}} deallocates memory dynamically

====Other====
* {{rlp|constant expression}}s can be evaluated at compile time and used in compile-time context (template arguments, array sizes, etc)
* {{rlpt|sizeof}}
* {{rlpt|alignof}}
* {{rlpt|typeid}}
* {{rlp|throw|throw-expression}}

===Primary expressions===
The operands of any operator may be other expressions or primary expressions (e.g. in {{c|1 + 2 * 3}}, the operands of operator+ are the [[#Full-expressions|subexpression]] {{c|2 * 3}} and the primary expression {{c|1}}).

Primary expressions are any of the following:
* {{rlpt|this}}
* literals (e.g. {{c|2}} or {{c|"Hello, world"}})
* identifier expressions, including
** suitably declared {{rlpsd|identifiers#Unqualified identifiers}} (e.g. {{c|n}} or {{c|cout}}),
** suitably declared {{rlpsd|identifiers#Qualified identifiers}} (e.g. {{lc|std::string::npos}}), and
** identifiers to be declared in {{rlpsd|declarations#Declarators}}
{{rrev|since=c++26|
:* {{rlpsd|pack indexing#Pack indexing expression}}
}}
{{rev begin}}
{{rev|since=c++11|
* {{rlp|lambda|lambda expressions}}
}}
{{rev|since=c++17|
* {{rlp|fold|fold expressions}}
}}
{{rev|since=c++20|
* {{rlp|requires|requires expressions}}
}}
{{rev end}}

Any expression in parentheses is also classified as a primary expression: this guarantees that the parentheses have higher precedence than any operator. Parentheses preserve value, type, and value category.

====Literals====
Literals are the tokens of a C++ program that represent constant values embedded in the source code.

* {{rlp|integer literal}}s are decimal, octal, hexadecimal or binary numbers of integer type.
* {{rlp|character literal}}s are individual characters of type 
:* {{c/core|char}} or {{c/core|wchar_t}}
{{rev begin}}
{{rev|since=c++11|
:* {{c/core|char16_t}} or {{c/core|char32_t}}
}}
{{rev|since=c++20|
:* {{c/core|char8_t}}
}}
{{rev end}}
* {{rlp|floating literal|floating-point literals}} are values of type {{c/core|float}}, {{c/core|double}}, or {{c/core|long double}}
* {{rlp|string literal}}s are sequences of characters of type
:* {{c/core|const char[]}} or {{c/core|const wchar_t[]}}
{{rev begin}}
{{rev|since=c++11|
:* {{c/core|const char16_t[]}} or {{c/core|const char32_t[]}}
}}
{{rev|since=c++20|
:* {{c/core|const char8_t[]}}
}}
{{rev end}}
* {{rlp|bool literal|boolean literals}} are values of type {{c/core|bool}}, that is {{c|true}} and {{c|false}}
{{rrev|since=c++11|
* {{rlpt|nullptr}} is the pointer literal which specifies a null pointer value
* {{rlp|user literal|user-defined literals}} are constant values of user-specified type
}}

===Full-expressions===
A ''constituent expression'' is defined as follows:
* The constituent expression of an expression is that expression.
* The constituent expressions of a {{spar|braced-init-list}} or of a (possibly parenthesized) expression list are the constituent expressions of the elements of the respective list.
* The constituent expressions of a {{spar|brace-or-equal-initializer}} of the form {{ttb|{{=}}}} {{spar|initializer-clause}} are the constituent expressions of the {{spar|initializer-clause}}.
{{source|1=
int num1 = 0;
num1 += 1; // Case 1: the constituent expression of `num += 1` is `num += 1`

int arr2[2] = {2, 22} // Case 2: the constituent expressions
                      //         of `{2, 22}` are `2` and `22`
                      // Case 3: the constituent expressions of ` = {2, 22}`
                      //         are the constituent expressions of `{2, 22}`
                      //         (i.e. also `2` and `22`)
}}

The ''immediate subexpressions'' of an expression {{c|E}} are
* the constituent expressions of {{c|E}}â€™s operands,
{{rrev|since=c++14|
* if {{c|E}} creates an {{rlp|aggregate initialization#Definitions|aggregate}} object, the constituent expressions of each {{rlp|data members#Member initialization|default member initializer}} used in the initialization,
}}
{{rrev|since=c++11|
* if {{c|E}} is a {{rlp|lambda|lambda expression}}, the initialization of the entities captured by copy and the constituent expressions of the initializer of the captures,
}}
* any function call that {{c|E}} implicitly invokes, or
* if {{c|E}} is a function call or implicitly invokes a function, the constituent expressions of each {{rlp|default arguments|default argument}} used in the call.

A ''subexpression'' of an expression {{c|E}} is an immediate subexpression of {{c|E}} or a subexpression of an immediate subexpression of {{c|E}}. {{rev inl|since=c++11|Note that expressions appearing in the 'function body' of lambda expressions are not subexpressions of the lambda expression.}}

A ''full-expression'' is
* an [[#Potentially-evaluated expressions|unevaluated operand]],
* a {{rlp|constant expression}},
{{rrev|since=c++20|
* an {{rlp|consteval|immediate invocation}},
}}
* a declarator of a {{rlpsd|declarations#Simple declaration}} or a {{rlp|constructor|member initializer}}, including the constituent expressions of the initializer,
* an invocation of a {{rlp|destructor}} generated at the end of the {{rlp|lifetime}} of an object other than a temporary object whose lifetime has not been extended, or
* an expression that is not a subexpression of another expression and that is not otherwise part of a full-expression.

If a language construct is defined to produce an implicit call of a function, a use of the language construct is considered to be an expression for the purposes of this definition. Conversions applied to the result of an expression in order to satisfy the requirements of the language construct in which the expression appears are also considered to be part of the full-expression.

For an initializer, performing the initialization of the entity {{rev inl|since=c++14|(including evaluating default member initializers of an aggregate)}} is also considered part of the full-expression.

===Potentially-evaluated expressions===
{{rev begin}}
{{rev|until=c++11|
An expression is ''potentially evaluated'' unless
* it is the operand of the {{rlpt|sizeof}} operator, or
* it is the operand of the {{rlpt|typeid}} operator and does not designate an lvalue of {{rlp|object#Polymorphic objects|polymorphic}} class type.
}} 
{{rev|since=c++11|
The following operands are ''unevaluated operands'' , they are not evaluated:
* expressions which the {{rlpt|typeid}} operator applies to, except glvalues of {{rlp|object#Polymorphic objects|polymorphic}} class types
* expressions which are operands of the {{rlpt|sizeof}} operator
* operands of the {{rlpt|noexcept}} operator
* operands of the {{rlpt|decltype}} specifier
{{rrev|since=c++20|
* {{spar|constraint-expression}} of {{rlp|constraints#Concepts|concept}} definitions
* expressions following the {{c/core|requires}} keyword of {{rlp|constraints#Requires clauses|requires-clauses}}
* expressions appearing in {{spar|requirement-seq}} of {{rlp|requires|requires-expressions}}
}}

An expression is ''potentially evaluated'' unless
* it is an unevaluated operand, or
* it is a subexpression of an unevaluated operand.
}}
{{rev end}}

Potentially-evaluated expressions are {{rlps|definition#ODR-use}}.

{{todo|example of unevaluated operands}}

===Discarded-value expressions===
A ''discarded-value expression'' is an expression that is used for its side-effects only. The value calculated from such expression is discarded. Such expressions include the full-expression of any {{rlp|statements#Expression statements|expression statement}}, the left-hand operand of the built-in comma operator, or the operand of a cast-expression that casts to the type {{c/core|void}}.

Array-to-pointer and function-to-pointer conversions are never applied to the value calculated by a discarded-value expression. The lvalue-to-rvalue conversion is applied if and only if the expression is a {{rlp|cv|volatile-qualified}} glvalue and has one of the following forms (built-in meaning required, possibly parenthesized):
* id-expression,
* array subscript expression,
* class member access expression,
* indirection,
* pointer-to-member operation,
* conditional expression where both the second and the third operands are one of these expressions,
* comma expression where the right operand is one of these expressions.

In addition, if the lvalue is of volatile-qualified class type, a volatile copy constructor is required to initialize the resulting rvalue temporary.

{{rrev|since=c++17|
If the expression is a non-void prvalue (after any lvalue-to-rvalue conversion that might have taken place), {{rlpsd|implicit conversion#Temporary materialization}} occurs.

Compilers may issue warnings when an expression other than cast to {{c/core|void}} discards a value declared {{attr|nodiscard}}.
}}&lt;br&gt;

{{rrev|since=c++20|
===Expression-equivalence===
A number of expressions {{c|e1}}, {{c|e2}}, ..., {{c|eN}} are ''expression-equivalent'' if all following conditions are satisfied:
# They have the same effects.
# Either they are all {{rlpsd|constant expression#Constant subexpression}}s or neither is.
# Either they are all {{rlp|noexcept spec|noexcept}} or else neither is.

{{c|e1}} is ''expression-equivalent to'' {{c|e2}} if and only if {{c|e1}} and {{c|e2}} are expression-equivalent (which means {{c|e2}} is also expression-equivalent to {{c|e1}}).
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1054|std=C++98|before=assigning a value to a volatile variable might&lt;br&gt;result in an unnecessary read due to the lvalue-to-&lt;br&gt;rvalue conversion applied to the assignment result|after=introduce discarded-value expressions&lt;br&gt;and exclude this case from the list&lt;br&gt;of cases that require the conversion}}
{{dr list item|wg=cwg|dr=1343&lt;!-- see P0507R0 --&gt;|std=C++98|before=sequencing of destructor calls in&lt;br&gt;aggregate initialization was underspecified|after=full-expressions in aggregate initialization&lt;br&gt;are well-specified}}
{{dr list item|wg=cwg|dr=1383|std=C++98|before=the list of expressions where lvalue-to-rvalue&lt;br&gt;conversion is applied to discarded-value&lt;br&gt;expressions also covered overloaded operators|after=only cover operators&lt;br&gt;with built-in meaning}}
{{dr list item|wg=cwg|dr=1576|std=C++11|before=lvalue-to-rvalue conversions were not applied&lt;br&gt;to discarded-value volatile xvalue expressions|after=apply the conversion&lt;br&gt;in this case}}
{{dr list item|wg=cwg|dr=2249|std=C++98|before=identifiers to be declared in declarators&lt;br&gt;were not id-expressions|after=they are}}
{{dr list item|wg=cwg|dr=2431|std=C++11|before=the invocations of the destructors of temporaries that&lt;br&gt;are bound to references were not full-expressions|after=they are}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc see c|c/language/expressions|Expressions|nomono=true}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}