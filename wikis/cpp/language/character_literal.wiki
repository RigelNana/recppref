{{title|Character literal}}
{{cpp/language/expressions/navbar}}

===Syntax===
{{sdsc begin}}
{{sdsc|num=1|{{ttb|'}}{{spar sep|c-char}}{{ttb|'}}}}
{{sdsc|num=2|notes={{mark since c++17}}|{{ttb|u8'}}{{spar sep|c-char}}{{ttb|'}}}}
{{sdsc|num=3|notes={{mark since c++11}}|{{ttb|u'}}{{spar sep|c-char}}{{ttb|'}}}}
{{sdsc|num=4|notes={{mark since c++11}}|{{ttb|U'}}{{spar sep|c-char}}{{ttb|'}}}}
{{sdsc|num=5|{{ttb|L'}}{{spar sep|c-char}}{{ttb|'}}}}
{{sdsc|num=6|{{ttb|'}}{{spar sep|c-char-sequence}}{{ttb|'}}}}
{{sdsc|num=7|notes={{mark until c++23}}|{{ttb|L'}}{{spar sep|c-char-sequence}}{{ttb|'}}}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|c-char}}|either
* a {{spar|basic-c-char}}, 
* an escape sequence, as defined in {{rlp|escape|escape sequences}}
* a universal character name, as defined in {{rlp|escape|escape sequences}}}}
{{par|{{spar|basic-c-char}}|A character from the {{rev inl|until=c++23|{{rlp|charset#Basic source character set|basic source character set}}}}{{rev inl|since=c++23|{{rlp|charset#Translation character set|translation character set}}}}, except the single-quote {{c|'}}, backslash {{c|\}}, or new-line character}}
{{par|{{spar|c-char-sequence}}|two or more {{spar|c-char}}s}}
{{par end}}

===Explanation===
@1@ Ordinary character literal, e.g. {{c|'a'}} or {{c|'\n'}} or {{c|'\13'}}. Such literal has type {{c/core|char}} and the value equal to {{rev inl|until=c++23|the representation of {{spar|c-char}} in the {{rlp|charset#Execution character set (Old definition)|execution character set}}}}{{rev inl|since=c++23|the corresponding code point from {{rlp|charset#Code unit and literal encoding|ordinary literal encoding}}}}.

@2@ UTF-8 character literal, e.g. {{c|u8'a'}}. Such literal has type {{rev inl|until=c++20|{{c/core|char}}}}{{rev inl|since=c++20|{{c/core|char8_t}}}} and the value equal to [https://www.iso.org/standard/76835.html ISO/IEC 10646] code point value of {{spar|c-char}}, provided that the code point value is representable with a single UTF-8 code unit (that is, {{spar|c-char}} is in the range 0x0-0x7F, inclusive).

@3@ UTF-16 character literal, e.g. {{c|u'çŒ«'}}, but not {{c|u'ğŸŒ'}} ({{c|u'\U0001f34c'}}). Such literal has type {{c/core|char16_t}} and the value equal to [https://www.iso.org/standard/76835.html ISO/IEC 10646] code point value of {{spar|c-char}}, provided that the code point value is representable with a single UTF-16 code unit (that is, {{spar|c-char}} is in the range 0x0-0xFFFF, inclusive).

@4@ UTF-32 character literal, e.g. {{c|U'çŒ«'}} or {{c|U'ğŸŒ'}}. Such literal has type {{c/core|char32_t}} and the value equal to [https://www.iso.org/standard/76835.html ISO/IEC 10646] code point value of {{spar|c-char}}.

@5@ Wide character literal, e.g. {{c|L'Î²'}} or {{c|L'çŒ«'}}. Such literal has type {{c/core|wchar_t}} and the value equal to {{rev inl|until=c++23|the value of {{spar|c-char}} in the execution wide character set}}{{rev inl|since=c++23|the corresponding code point from wide literal encoding}}.

@6@ {{rev inl|until=c++23|Ordinary multicharacter literal}}{{rev inl|since=c++23|Multicharacter literal}}, e.g. {{c|'AB'}}, is conditionally-supported, has type {{c/core|int}} and implementation-defined value.

@7@ Wide multicharacter literal, e.g. {{c|L'AB'}}, is conditionally-supported, has type {{c/core|wchar_t}} and implementation-defined value.

====Non-encodable characters====
@1-5@ Given that {{spar|c-char}} is not a numeric escape sequence (see below), if {{spar|c-char}} is not representable in the literalâ€™s associated character encoding or cannot be encoded as a single code unit in that encoding (e.g. a non-BMP value on Windows where {{c/core|wchar_t}} is 16-bit), the program is ill-formed.

@6@ If any {{spar|c-char}} in {{spar|c-char-sequence}} cannot be encoded as a single code unit in {{rlp|charset#Code unit and literal encoding|ordinary literal encoding}}, the program is ill-formed.

&lt;!-- The following part never appears in the standard, it just describes the semantic of wide multicharacter literals regarding non-encodable characters in pre-C++23 modes. --&gt;
{{rrev|until=c++23|
@7@ If any {{spar|c-char}} in {{spar|c-char-sequence}} cannot be encoded as a single code unit in {{rlp|charset#Code unit and literal encoding|wide literal encoding}}, the program is ill-formed.
}}

====Numeric escape sequences====
Numeric (octal and hexadecimal) escape sequences can be used for specifying the value of the character.

{{rrev|since=c++23|
If the character literal contains only one numeric escape sequence, and the value specified by the escape sequence is representable by the unsigned version of its type, the character literal has the same value as the specified value (possibly after conversion to the character type).

A UTF-''N'' character literal can have any value representable by its type. If the value does not correspond to a valid Unicode code point, or if the its corresponding code point is not representable as single code unit in UTF-''N'', it can still be specified by a numeric escape sequence with the value. E.g. {{c|u8'\xff'}} is well-formed and equal to {{c|char8_t(0xFF)}}.
}}
&lt;br&gt;
{{rrev multi
|rev1=
If the value specified by a numeric escape sequence used in an ordinary or wide character literal is not representable by {{c/core|char}} or {{c/core|wchar_t}} respectively, the value of the character literal is implementation-defined.
|since2=c++23|rev2=
If the value specified by a numeric escape sequence used in an ordinary or wide character literal with one {{spar|c-char}} is representable by the unsigned version of the underlying type of {{c/core|char}} or {{c/core|wchar_t}} respectively, the value of the literal is the integer value of that unsigned integer type and the specified value converted to the type of the literal. Otherwise, the program is ill-formed.
}}
&lt;br&gt;
{{rrev|since=c++11|
If the value specified by a numeric escape sequence used in a UTF-''N'' character literal is not representable by the corresponding {{tt|char''N''_t}}, {{rev inl|until=c++17|the value of the character literal is implementation-defined}}{{rev inl|since=c++17|the program is ill-formed}}.
}}

===Notes===
{{cpp/language/multichar-literal-note|cpp}}

In C, character constants such as {{c|'a'}} or {{c|'\n'}} have type {{c/core|int}}, rather than {{c/core|char}}.

===Example===
{{example|code=
#include &lt;cstdint&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;

template&lt;typename CharT&gt;
void dump(std::string_view s, const CharT c)
{
    const uint8_t* data{reinterpret_cast&lt;const uint8_t*&gt;(&amp;c)};
    
    std::cout &lt;&lt; s &lt;&lt; " \t" &lt;&lt; std::hex
              &lt;&lt; std::uppercase &lt;&lt; std::setfill('0');
    
    for (auto i{0U}; i != sizeof(CharT); ++i)
        std::cout &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;unsigned&gt;(data[i]) &lt;&lt; ' ';
    
    std::cout &lt;&lt; '\n';
}

void print(std::string_view str = "") { std::cout &lt;&lt; str &lt;&lt; '\n'; }

int main()
{
    print("Ordinary character literals:");
    char c1 = 'a'; dump("'a'", c1);
    char c2 = '\x2a'; dump("'*'", c2);

    print("\n" "Ordinary multi-character literals:");
    int mc1 = 'ab'; dump("'ab'", mc1);       // implementation-defined
    int mc2 = 'abc'; dump("'abc'", mc2);     // implementation-defined

    print("\n" "UTF-8 character literals:");
    char8_t C1 = u8'a'; dump("u8'a'", C1);
//  char8_t C2 = u8'Â¢'; dump("u8'Â¢'", C2);   // error: Â¢ maps to two UTF-8 code units
//  char8_t C3 = u8'çŒ«'; dump("u8'çŒ«'", C3); // error: çŒ« maps to three UTF-8 code units
//  char8_t C4 = u8'ğŸŒ'; dump("u8'ğŸŒ'", C4); // error: ğŸŒ maps to four UTF-8 code units

    print("\n" "UTF-16 character literals:");
    char16_t uc1 = u'a'; dump("u'a'", uc1);
    char16_t uc2 = u'Â¢'; dump("u'Â¢'", uc2);
    char16_t uc3 = u'çŒ«'; dump("u'çŒ«'", uc3);
//  char16_t uc4 = u'ğŸŒ'; dump("u'ğŸŒ'", uc4); // error: ğŸŒ maps to two UTF-16 code units

    print("\n" "UTF-32 character literals:");
    char32_t Uc1 = U'a'; dump("U'a'", Uc1);
    char32_t Uc2 = U'Â¢'; dump("U'Â¢'", Uc2);
    char32_t Uc3 = U'çŒ«'; dump("U'çŒ«'", Uc3);
    char32_t Uc4 = U'ğŸŒ'; dump("U'ğŸŒ'", Uc4);

    print("\n" "Wide character literals:");
    wchar_t wc1 = L'a'; dump("L'a'", wc1);
    wchar_t wc2 = L'Â¢'; dump("L'Â¢'", wc2);
    wchar_t wc3 = L'çŒ«'; dump("L'çŒ«'", wc3);
    wchar_t wc4 = L'ğŸŒ'; dump("L'ğŸŒ'", wc4);  // unsupported on Windows since C++23
}
|p=true
|output=
Ordinary character literals:
'a' 	61 
'*' 	2A 

Ordinary multi-character literals:
'ab' 	62 61 00 00 
'abc' 	63 62 61 00 

UTF-8 character literals:
u8'a' 	61 

UTF-16 character literals:
u'a' 	61 00 
u'Â¢' 	A2 00 
u'çŒ«' 	2B 73 

UTF-32 character literals:
U'a' 	61 00 00 00 
U'Â¢' 	A2 00 00 00 
U'çŒ«' 	2B 73 00 00 
U'ğŸŒ' 	4C F3 01 00 

Wide character literals:
L'a' 	61 00 00 00 
L'Â¢' 	A2 00 00 00 
L'çŒ«' 	2B 73 00 00 
L'ğŸŒ' 	4C F3 01 00 
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=912|std=C++98|before=non-encodable ordinary character literal was unspecified|after=specified as conditionally-supported}}
{{dr list item|wg=cwg|dr=1024|std=C++98|before=multicharacter literal was required to be supported|after=made conditionally-supported}}
{{dr list item|wg=cwg|dr=1656|std=C++98|before=the meaning of numeric escape sequence&lt;br&gt;in a character literal was unclear|after=specified}}
{{dr list item|paper=P1854R4|std=C++98|before=non-encodable character literals were conditionally-supported|after=the program is ill-formed}} 
{{dr list end}}

===References===
{{ref std c++23}}
{{ref std| section=5.13.3|title=Character literals|id=lex.ccon}}
{{ref std end}}
{{ref std c++20}}
{{ref std| section=5.13.3|title=Character literals|id=lex.ccon}}
{{ref std end}}
{{ref std c++17}}
{{ref std| section=5.13.3|title=Character literals|id=lex.ccon}}
{{ref std end}}
{{ref std c++14}}
{{ref std| section=2.14.3|title=Character literals|id=lex.ccon}}
{{ref std end}}
{{ref std c++11}}
{{ref std| section=2.14.3|title=Character literals|id=lex.ccon}}
{{ref std end}}
{{ref std c++03}}
{{ref std| section=2.13.2|title=Character literals|id=lex.ccon}}
{{ref std end}}
{{ref std c++98}}
{{ref std| section=2.13.2|title=Character literals|id=lex.ccon}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc user literal}}
{{dsc see c|c/language/character constant|Character constant|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}