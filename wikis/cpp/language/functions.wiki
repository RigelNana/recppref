{{title|Functions}}
{{cpp/language/functions/navbar}}

Functions are C++ entities that associate a sequence of {{rlp|statements}} (a ''function body'') with a ''name'' and a list of zero or more ''function parameters''.

{{source|
// function name: "isodd"
// parameter list has one parameter, with name "n" and type int
// the return type is bool
bool isodd(int n)
{                 // the body of the function begins
    return n % 2;
}                 // the body of the function ends
}}

When a function is invoked, e.g. in a {{rlp|operator other#Built-in function call operator|function-call expression}}, the parameters are initialized from the arguments (either provided at the place of call or {{rlp|default arguments|defaulted}}) and the statements in the function body are executed. If the {{rlp|function#Parameter list|parameter list}} ends with {{c|...}}, extra arguments can be supplied to the function, such a function is called {{rlp|variadic arguments|variadic function}}.

{{source|
int main()
{
    for (int arg : {-3, -2, -1, 0, 1, 2, 3})
        std::cout &lt;&lt; isodd(arg) &lt;&lt; ' '; // isodd called 7 times, each
                                        // time n is copy-initialized from arg
}
}}

{{rlp|unqualified lookup|Unqualified}} function names in function-call expressions are looked up with an extra set of rules called {{rlp|adl|"argument-dependent lookup" (ADL)}}.

A function can terminate by {{rlp|return|returning}} or by {{rlp|throw|throwing}} an {{rlp|exceptions|exception}}.

{{rrev|since=c++20|
A function may be a {{rlp|coroutines|coroutine}}, in which case it can suspend execution to be resumed later.
}}

A {{rlp|function|function declaration}} may appear in any scope, but a {{rlp|function|function definition}} may only appear in namespace scope or, for {{rlp|member functions|member}} and {{rlp|friend}} functions, in class scope. A function that is declared in a class body without a friend specifier is a class member function. Such functions have many additional properties, see {{rlp|member functions}} for details.

Functions are not objects: there are no arrays of functions and functions cannot be passed by value or returned from other functions. Pointers and references to functions (except for {{rlp|main function|the main function}}{{rev inl|since=c++20| and {{rlp|extending std#Addressing restriction|most standard library functions}}}}) are allowed, and may be used where these functions themselves cannot. Therefore we say these functions are "addressable".

Each function has a type, which consists of the function's return type, the types of all parameters (after array-to-pointer and function-to-pointer transformations, see {{rlp|function#Parameter list|parameter list}}) {{rev inl|since=c++17|, whether the function is {{rlpt|noexcept spec|noexcept}} or not}}, and, for non-static member functions, cv-qualification{{rev inl|since=c++11| and ref-qualification}}. Function types also have {{rlp|language linkage}}. There are no cv-qualified function types (not to be confused with the types of {{rlp|member functions|cv-qualified functions}} such as {{c|int f() const;}} or functions returning {{rlp|cv|cv-qualified types}}, such as {{c|std::string const f();}}). Any cv-qualifier is ignored if it is added to an alias for a function type.&lt;!--CWG295--&gt;

Multiple functions in the same scope may have the same name, as long as their parameter lists and, for non-static member functions, cv{{rev inl|since=c++11|/ref}}-qualifications are different. This is known as {{rlp|overload resolution|function overloading}}. Function declarations that differ only in the return type {{rev inl|since=c++17|and the noexcept specification}} cannot be overloaded. The {{rlp|overloaded address|address of an overloaded function}} is determined differently.

{{rrev|since=c++11|
C++ implements {{enwiki|anonymous function}}s using {{rlp|lambda|lambda-expressions}}.
}}

===Function objects===
Besides function lvalues, the function call expression supports pointers to functions, and any value of class type that overloads the function-call operator or is convertible to function pointer{{rev inl|since=c++11| (including {{rlp|lambda|lambda-expressions}})}}. Together, these types are known as {{named req|FunctionObject}}s, and they are used ubiquitously through the C++ standard library, see for example, usages of {{named req|BinaryPredicate}} and {{named req|Compare}}.

The standard library also provides a number of predefined [[cpp/utility/functional|function object templates]] as well as the methods to compose new ones (including {{lc|std::less}}{{rev inl|since=c++11|, {{lc|std::mem_fn}}, {{lc|std::bind}}, {{lc|std::function}}}}{{rev inl|since=c++17|, {{lc|std::not_fn}}}}{{rev inl|since=c++20|, {{lc|std::bind_front}}}}{{rev inl|since=c++23|, {{lc|std::bind_back}}, {{lc|std::move_only_function}}}}{{rev inl|since=c++26|, {{lc|std::copyable_function}}, and {{lc|std::function_ref}}}}).

{{langlinks|es|ja|ru|zh}}