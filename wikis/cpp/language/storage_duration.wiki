{{title|Storage class specifiers}}
{{cpp/language/declarations/navbar}}

The storage class specifiers are a part of the {{spar|decl-specifier-seq}} of a name's {{rlp|declarations|declaration syntax}}. Together with the {{rlp|scope}} of the name, they control two independent properties of the name: its ''storage duration'' and its ''linkage''.

===Storage duration===
The ''storage duration'' is the property of an {{rlp|object}} that defines the minimum potential lifetime of the storage containing the object. The storage duration is determined by the construct used to create the object and is one of the following:
* static storage duration
{{rrev|since=c++11|
* thread storage duration
}}
* automatic storage duration
* dynamic storage duration

Static{{rev inl|since=c++11|, thread,}} and automatic storage durations are associated with objects introduced by {{rlp|declarations}} and with {{rlp|lifetime#Temporary object lifetime|temporary objects}}. The dynamic storage duration is associated with objects created by a {{rlp|new|{{c/core|new}} expression}} or with {{rlp|object#Object creation|implicitly created objects}}.

The storage duration categories apply to references as well.

The storage duration of {{rlpsd|object#Subobjects}} and reference members is that of their complete object.

====Specifiers====
The following keywords are ''storage class specifiers''{{sep}}:
{{rev begin}}
{{rev|until=c++11|
* {{c/core|auto}}
}}
{{rev|until=c++17|
* {{c/core|register}}
}}
{{rev end}}
* {{c/core|static}}
{{rrev|since=c++11|
* {{c/core|thread_local}}
}}
* {{c/core|extern}}
* {{c/core|mutable}}

In a {{spar|decl-specifier-seq}}, there can be at most one storage class specifier{{rev inl|since=c++11|, except that {{c/core|thread_local}} may appear with {{c/core|static}} or {{c/core|extern}}}}.

{{c/core|mutable}} has no effect on storage duration. For its usage, see {{rlp|cv|const/volatile}}.

Other storage class specifiers can appear in the {{spar sep|decl-specifier-seq}}s of the following declarations:
{|class="wikitable" style="text-align: center;"
!rowspan=4|Specifier
!colspan=9|Can appear in the {{spar sep|decl-specifier-seq}}s of
|-
!colspan=4|Variable declarations
!colspan=3|Function declarations
!rowspan=3|Structured binding declarations&lt;br&gt;{{mark since c++17}}
|-
!colspan=2|Non-member
!colspan=2|Member
!rowspan=2|Non-member
!colspan=2|Member
|-
!Non-parameter
!Function parameter
!Non-static
!{{nbsp}}Static{{nbsp}}
!Non-static
!{{nbsp}}Static{{nbsp}}
|-
|{{c/core|auto}}
|{{maybe|Block scope only}}||{{yes}}||{{no}}||{{no}}
|{{no}}||{{no}}||{{no}}||{{n/a}}
|-
|{{c/core|register}}
|{{maybe|Block scope only}}||{{yes}}||{{no}}||{{no}}
|{{no}}||{{no}}||{{no}}||{{n/a}}
|-
|{{c/core|static}}
|{{yes}}||{{no}}||colspan=2 {{yes|Declares static}}
|{{maybe|Namespace scope only}}||colspan=2 {{yes|Declares static}}||{{yes}}
|-
|{{nbsp}}{{c/core|thread_local}}{{nbsp}}
|{{yes}}||{{no}}||{{no}}||{{yes}}
|{{no}}||{{no}}||{{no}}||{{yes}}
|-
|{{c/core|extern}}
|{{yes}}||{{no}}||{{no}}||{{no}}
|{{yes}}||{{no}}||{{no}}||{{no}}
|}

{{rlps|union#Anonymous unions}} can also be declared with {{c/core|static}}.

{{rrev|until=c++17|
{{c/core|register}} is a hint that the variable so declared will be heavily used, so that its value can be stored in a CPU register. The hint can be ignored, and in most implementations it will be ignored if the address of the variable is taken. This use is deprecated.
}}

====Static storage duration====
A variable satisfying all following conditions has ''static storage duration''{{sep}}:
* It belongs to a {{rlpsd|scope#Namespace scope}} or are first declared with {{c/core|static}} or {{c/core|extern}}.
{{rrev|since=c++11|
* It does not have thread storage duration.
}}

The storage for these entities lasts for the duration of the program.

{{rrev|since=c++11|
====Thread storage duration====
All variables declared with {{c/core|thread_local}} have ''thread storage duration''.

The storage for these entities lasts for the duration of the thread in which they are created. There is a distinct object or reference per thread, and use of the declared name refers to the entity associated with the current thread.
}}

====Automatic storage duration====
The following variables have ''automatic storage duration''{{sep}}:
* Variables that belong to a {{rlpsd|scope#Block scope}} and are not explicitly declared {{c/core|static}}{{rev inl|since=c++11|, {{c/core|thread_local}},}} or {{c/core|extern}}&lt;!-- no need to mention “auto” and “register” here --&gt;. The storage for such variables lasts until the block in which they are created exits.
* Variables that belong to a parameter scope (i.e. function parameters). The storage for a function parameter lasts until immediately after its {{rlp|operator other#Built-in function call operator|destruction}}.

====Dynamic storage duration====
Objects created by the following methods during program execution have ''dynamic storage duration''{{sep}}:
* {{rlp|new|{{c/core|new}} expressions}}. The storage for such objects is allocated by [[cpp/memory/new/operator new|allocation functions]] and deallocated by [[cpp/memory/new/operator delete|deallocation functions]].
* {{rlp|object#Object creation|Implicitly creation}} by other means. The storage for such objects overlaps with some existing storage.
* {{rlps|throw#Exception object}}s. The storage for such objects is allocated and deallocated in an unspecified way.

===Linkage===
A name can have ''external linkage''{{sep}}{{rev inl|since=c++20|, ''module linkage''}}, ''internal linkage'', or ''no linkage'':
* An entity whose name has external linkage can be {{rlp|conflicting declarations#Multiple declarations of the same entity|redeclared}} in another {{rlp|translation phases|translation unit}}{{rev inl|since=c++20|, and the redeclaration can be {{rlp|modules#Module ownership|attached to a different module}}}}.
{{rrev|since=c++20|
* An entity whose name has module linkage can be redeclared in another translation unit, as long as the redeclaration is attached to the same module.
}}
* An entity whose name has internal linkage can be redeclared in another scope in the same translation unit.
* An entity whose name has no linkage can only be redeclared in the same scope.

The following linkages are recognized:

====No linkage====
Any of the following names declared at block scope have no linkage:
* variables that are not explicitly declared {{c/core|extern}} (regardless of the {{c/core|static}} modifier);
* {{rlpsd|class#Local classes}} and their member functions;
* other names declared at block scope such as typedefs, enumerations, and enumerators.

Names not specified with external{{rev inl|since=c++20|, module,}} or internal linkage also have no linkage, regardless of which scope they are declared in.

====Internal linkage====
Any of the following names declared at namespace scope have internal linkage:
* variables{{rev inl|since=c++14|, variable templates}}, functions, or function templates declared {{c/core|static}};
* {{rev inl|since=c++14|non-template }}variables of non-volatile const-qualified type, unless
{{rev begin}}
{{rev|since=c++17|
:* they are inline,
}}
{{rev|since=c++20|
:* they are declared in the purview of a {{rlp|modules#Module declarations|module interface unit}} (outside the {{rlpsd|modules#Private module fragment}}, if any) or {{rlp|modules#Module partitions|module partition}},
}}
{{rev end}}
:* they are explicitly declared {{c/core|extern}}, or
:* they were previously declared and the prior declaration did not have internal linkage;
* data members of {{rlp|union|anonymous unions}}.

{{rrev|since=c++11|
In addition, all names declared in {{rlpsd|namespace#Unnamed namespaces}} or a namespace within an unnamed namespace, even ones explicitly declared {{c/core|extern}}, have internal linkage.
}}

====External linkage====
Variables and functions with external linkage also have {{rlp|language linkage}}, which makes it possible to link translation units written in different programming languages.

Any of the following names declared at namespace scope have external linkage, unless they are declared in an unnamed namespace{{rev inl|since=c++20| or their declarations are attached to a named module and are not exported}}:
* variables and functions not listed above (that is, functions not declared {{c/core|static}}, non-const variables not declared {{c/core|static}}, and any variables declared {{c/core|extern}});
* enumerations;
* names of classes, their member functions, static data members (const or not), nested classes and enumerations, and functions first introduced with {{rlp|friend}} declarations inside class bodies;
* names of all templates not listed above (that is, not function templates declared {{c/core|static}}).

Any of the following names first declared at block scope have external linkage:
* names of variables declared {{c/core|extern}};
* names of functions.

{{rrev|since=c++20|
====Module linkage====
Names declared at namespace scope have module linkage if their declarations are attached to a named module and are not exported, and do not have internal linkage.
}}

{{todo|add the description of the behavior when an entity is declared with different linkages in the same translation unit (6.6 paragraph 6), note the difference between C++20 (ill-formed) and the current draft (well-formed)}}

===Static block variables===
Block variables with static{{rev inl|since=c++11| or thread}} storage duration are initialized the first time control passes through their declaration (unless their initialization is {{rlp|zero initialization|zero-}} or {{rlp|constant initialization|constant-initialization}}, which can be performed before the block is first entered). On all further calls, the declaration is skipped.
* If the initialization {{rlp|throw|throws an exception}}, the variable is not considered to be initialized, and initialization will be attempted again the next time control passes through the declaration.
* If the initialization recursively enters the block in which the variable is being initialized, the behavior is undefined.
{{rrev|since=c++11|
* If multiple threads attempt to initialize the same static local variable concurrently, the initialization occurs exactly once (similar behavior can be obtained for arbitrary functions with {{lc|std::call_once}}).
:* Usual implementations of this feature use variants of the double-checked locking pattern, which reduces runtime overhead for already-initialized local statics to a single non-atomic boolean comparison.
}}

The destructor for a block variable with static storage duration [[cpp/utility/program/exit|is called at program exit]], but only if the initialization took place successfully.

Variables with static storage duration in all definitions of the same {{rlp|inline|inline function}} (which may be implicitly inline) all refer to the same object defined in one translation unit, as long as the function has external linkage.

===Translation-unit-local entities===
The concept of translation-unit-local entities is standardized in C++20, see {{rlp|tu local|this page}} for more details.

An entity is ''translation-unit-local'' (or ''TU-local'' for short) if

* it has a name with internal linkage, or
* it does not have a name with linkage and is introduced within the definition of a TU-local entity, or
* it is a template or template specialization whose template argument or template declaration uses a TU-local entity.

Bad things (usually violation of {{rlp|definition|ODR}}) can happen if the type of a non-TU-local entity depends on a TU-local entity, or if a declaration of{{rev inl|since=c++17|, or a {{rlp|ctad|deduction guide}} for,}} a non-TU-local entity names a TU-local entity outside its

* function-body for a non-inline function or function template
* initializer for a variable or variable template
* friend declarations in a class definition
* use of value of a variable, if the variable is {{rlpsd|constant expression#Usable in constant expressions}}

{{rrev|since=c++20|
Such uses are disallowed in a {{rlp|modules|module interface unit}} (outside its private-module-fragment, if any) or a module partition, and are deprecated in any other context.

A declaration that appears in one translation unit cannot name a TU-local entity declared in another translation unit that is not a header unit. A declaration instantiated for a {{rlp|templates|template}} appears at the point of instantiation of the specialization.
}}

===Notes===
Names at the top-level namespace scope (file scope in C) that are {{c/core|const}} and not {{c/core|extern}} have external linkage in C, but internal linkage in C++.

Since C++11, {{c/core|auto}} is no longer a storage class specifier; it is used to indicate type deduction. 

{{rrev multi|until1=c++17
|rev1=
In C, the address of a {{c/core|register}} variable cannot be taken, but in C++, a variable declared {{c/core|register}} is semantically indistinguishable from a variable declared without any storage class specifiers.
|rev2=
In C++, unlike C, variables cannot be declared {{c/core|register}}.
}}

Names of {{c/core|thread_local}} variables with internal or external linkage referred from different scopes may refer to the same or to different instances depending on whether the code is executing in the same or in different threads.

The {{c/core|extern}} keyword can also be used to specify {{rlp|language linkage}} and {{rlp|class template|explicit template instantiation declarations}}, but it's not a storage class specifier in those cases (except when a declaration is directly contained in a language linkage specification, in which case the declaration is treated as if it contains the {{c/core|extern}} specifier).

Storage class specifiers, except for {{c/core|thread_local}}, are not allowed on {{rlp|template specialization|explicit specializations}} and {{rlpsd|class template#Explicit instantiation}}s:
{{source|1=
template&lt;class T&gt;
struct S
{
    thread_local static int tlm;
};

template&lt;&gt;
thread_local int S&lt;float&gt;::tlm = 0; // "static" does not appear here
}}

{{rev begin}}
{{rev|since=c++14|
A {{c/core|const}} (may be implied by {{c/core|constexpr}}) variable template used to have internal linkage by default, which was inconsistent with other templated entities. Defect report {{wg21|CWG2387}} corrected this.
}}
{{rev|since=c++17|1=
{{rlpt|inline}} acts as a workaround for {{wg21|CWG2387}} by giving external linkage by default. This is why the {{c/core|inline}} was [https://wg21.link/p0607r0 added] to many variable templates and then [https://github.com/cplusplus/draft/pull/4625 removed] after having CWG2387 accepted. Standard library implementations also need to use {{c/core|inline}} as long as a supported compiler has not get CWG2387 implemented. See [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=109126 GCC Bugzilla #109126] and [https://github.com/microsoft/STL/pull/4546 MSVC STL PR #4546].
}}
{{rev end}}

{{feature test macro|__cpp_threadsafe_static_init|[[#Static local variables|Dynamic initialization and destruction with concurrency]]|value=200806L|std=C++11}}

===Keywords===
{{ltt|cpp/keyword/auto}},
{{ltt|cpp/keyword/register}},
{{ltt|cpp/keyword/static}},
{{ltt|cpp/keyword/extern}},
{{ltt|cpp/keyword/thread_local}},
{{ltt|cpp/keyword/mutable}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;thread&gt;

thread_local unsigned int rage = 1;
std::mutex cout_mutex;

void increase_rage(const std::string&amp; thread_name)
{
    ++rage; // modifying outside a lock is okay; this is a thread-local variable
    std::lock_guard&lt;std::mutex&gt; lock(cout_mutex);
    std::cout &lt;&lt; "Rage counter for " &lt;&lt; thread_name &lt;&lt; ": " &lt;&lt; rage &lt;&lt; '\n';
}

int main()
{
    std::thread a(increase_rage, "a"), b(increase_rage, "b");
    
    {
        std::lock_guard&lt;std::mutex&gt; lock(cout_mutex);
        std::cout &lt;&lt; "Rage counter for main: " &lt;&lt; rage &lt;&lt; '\n';
    }
    
    a.join();
    b.join();
}
|p=true
|output=
Rage counter for a: 2
Rage counter for main: 1
Rage counter for b: 2
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=216|std=C++98|before=unnamed class and enumeration in class scope have&lt;br&gt;different linkage from those in namespace scope|after=they all have external&lt;br&gt;linkage in these scopes}}
{{dr list item|wg=cwg|dr=389|std=C++98|before=a name with no linkage should not be&lt;br&gt;used to declare an entity with linkage|after=a type without linkage shall not be used&lt;br&gt;as the type of a variable or function&lt;br&gt;with linkage, unless the variable&lt;br&gt;or function has C language linkage}}
{{dr list item|wg=cwg|dr=426|std=C++98|before=an entity could be declared with both internal&lt;br&gt;and external linkage in the same translation unit|after=the program is ill-formed in this case}}
{{dr list item|wg=cwg|dr=527|std=C++98|before=the type restriction introduced by the resolution of CWG&lt;br&gt;389 was also applied to variables and functions that&lt;br&gt;cannot be named outside their own translation units|after=the restriction is lifted for these&lt;br&gt;variables and functions (i.e. with no&lt;br&gt;linkage or internal linkage, or declared&lt;br&gt;within unnamed namespaces)}}
{{dr list item|wg=cwg|dr=809|std=C++98|before={{c/core|register}} served very little function|after=deprecated}}
{{dr list item|wg=cwg|dr=1648|std=C++11|before={{c/core|static}} was implied even if&lt;br&gt;{{c/core|thread_local}} is combined with {{c/core|extern}}|after=implied only if no other storage&lt;br&gt;class specifier is present}}
{{dr list item|wg=cwg|dr=1686|std=C++98&lt;br&gt;C++11|before=the name of a non-static variable declared in namespace&lt;br&gt;scope had internal linkage only if it is explicitly&lt;br&gt;declared {{c/core|const}} (C++98) or {{c/core|constexpr}} (C++11)|after=only required the type&lt;br&gt;to be const-qualified}}
{{dr list item|wg=cwg|dr=2019|std=C++98|before=the storage duration of reference&lt;br&gt;members were unspecified|after=same as their complete object}}
{{dr list item|wg=cwg|dr=2387|std=C++14|before=unclear whether const-qualified variable&lt;br&gt;template have internal linkage by default|after=const qualifier does not affect&lt;br&gt;the linkage of variable&lt;br&gt;templates or their instances}}
{{dr list item|wg=cwg|dr=2533|std=C++98|before=the storage duration of implicitly-&lt;br&gt;created objects were unclear|after=made clear}}
{{dr list item|wg=cwg|dr=2850|std=C++98|before=it was unclear when the storage for&lt;br&gt;function parameters are deallocated|after=made clear}}
{{dr list item|wg=cwg|dr=2872|std=C++98|before=the meaning of “can be referred to” was unclear|after=improved wording}}
{{dr list item|paper=P2788R0|std=C++20|before=declaring a const-qualified variable in a namespace&lt;br&gt;gave it internal linkage even in a module unit|after=internal linkage is not given}}
{{dr list end}}

===References===
{{ref std c++23}}
{{ref std|section=6.7.5|title=Storage duration|id=basic.stc}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=6.7.5|title=Storage duration|id=basic.stc}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=6.7|title=Storage duration|id=basic.stc}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=3.7|title=Storage duration|id=basic.stc}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=3.7|title=Storage duration|id=basic.stc}}
{{ref std end}}
{{ref std c++03}}
{{ref std|section=3.7|title=Storage duration|id=basic.stc}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=3.7|title=Storage duration|id=basic.stc}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc see c|c/language/storage duration|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}