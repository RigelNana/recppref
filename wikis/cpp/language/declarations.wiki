{{title|Declarations}}
{{cpp/language/declarations/navbar}}
''Declarations'' are how names are introduced (or re-introduced) into the C++ program. Not all declarations actually declare anything, and each kind of entity is declared differently. {{rlp|definition|Definitions}} are declarations that are sufficient to use the entity identified by the name. 

A declaration is one of the following:

* {{rlp|function#Function definition|Function definition}}
* {{rlp|templates|Template declaration}} (including {{rlp|partial specialization|Partial template specialization}})
* {{rlp|class template#Explicit instantiation|Explicit template instantiation}}
* {{rlp|template specialization|Explicit template specialization}}
* {{rlp|namespace|Namespace definition}}
* {{rlp|language linkage|Linkage specification}}
{{rrev|since=c++11|
* Attribute declaration ({{spar|{{rlp|attributes|attr}}}} {{ttb|;}})
}}
* Empty declaration ({{ttb|;}})
* A function declaration without a {{spar sep|decl-specifier-seq}}:
{{sdsc begin}}
{{sdsc begin}}
{{sdsc|1=
{{spar optional|attr}} {{spar|declarator}} {{ttb|;}}
}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|attr}}|{{mark since c++11}} sequence of any number of {{rlp|attributes|attributes}}}}
{{par|{{spar|declarator}}|a function declarator}}
{{par end}}
: This declaration must declare a constructor, destructor, or user-defined type {{rlp|cast operator|conversion function}}. It can only be used as part of a {{rlp|templates|template declaration}}, {{rlp|template specialization|explicit specialization}}, or explicit instantiation.
* {{spar|block-declaration}} (a declaration that can appear inside a {{rlp|statements#Compound statement|block}}), which, in turn, can be one of the following:
:*{{rlp|asm|asm declaration}}
{{rrev|since=c++11|
:*{{rlp|type alias|type alias declaration}}
}}
:*{{rlp|namespace alias|namespace alias definition}}
:*{{rlp|using declaration|using-declaration}}
:*{{rlp|namespace#Using-directives|using directive}}
{{rev begin}}
{{rev|since=c++20|
:*{{rlp|enum#Using-enum-declaration|using-enum-declaration}}
}}
{{rev|since=c++11|
:*{{rlpt|static_assert}} declaration
:*{{rlp|enum|opaque enum declaration}}
}}
{{rev end}}
:*simple declaration

===Simple declaration===
A simple declaration is a statement that introduces, creates, and optionally initializes one or several identifiers, typically variables.

{{sdsc begin}}
{{sdsc|num=1|1=
{{spar|decl-specifier-seq}} {{spar optional|init-declarator-list}} {{ttb|;}}
}}
{{sdsc|num=2|1=
{{spar|attr}} {{spar|decl-specifier-seq}} {{spar|init-declarator-list}}{{ttb|;}}
}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|attr}}|{{mark since c++11}} sequence of any number of {{rlp|attributes|attributes}}}}
{{par|{{spar|decl-specifier-seq}}|sequence of ''specifiers'' (see below)}}
{{par|{{spar|init-declarator-list}}|comma-separated list of ''declarators'' with optional {{rlpsd|initialization#Initializers}}. {{spar|init-declarator-list}} is optional when declaring a named class/struct/union or a named enumeration}}
{{par end}}

{{rev inl|since=c++17|A {{rlp|structured binding|structured binding declaration}} is also a simple declaration.}}

===Specifiers===
'''Declaration specifiers''' ({{spar|decl-specifier-seq}}) is a sequence of the following whitespace-separated specifiers, in any order:

* the {{rlpt|typedef}} specifier. If present, the entire declaration is a {{rlp|typedef|typedef declaration}} and each declarator introduces a new type name, not an object or a function.
* function specifiers ({{rlpt|inline}}, {{rlpt|virtual}}, {{rlpt|explicit}}), only allowed in {{rlp|function|function declarations}}.
{{rrev|since=c++17|
* the {{rlpt|inline}} specifier is also allowed on variable declarations.
}}
* the {{rlpt|friend}} specifier, allowed in class and function declarations.
{{rev begin}}
{{rev|since=c++11|
* the {{rlpt|constexpr}} specifier, only allowed in variable definitions, function and function template declarations, and the declaration of static data members of literal type.
}}
{{rev|since=c++20|
* the {{rlpt|consteval}} specifier, only allowed in function and function template declarations.
* the {{rlpt|constinit}} specifier, only allowed in declaration of a variable with static or thread storage duration. At most one of the {{c/core|constexpr}}, {{c/core|consteval}}, and {{c/core|constinit}} specifiers is allowed to appear in a {{spar|decl-specifier-seq}}.
}}
{{rev end}}
* {{rlp|storage duration|storage class specifier}} ({{rev inl|until=c++17|{{ltt|cpp/keyword/register}}, }} {{ltt|cpp/keyword/static}}, {{rev inl|since=c++11|{{ltt|cpp/keyword/thread_local}}, }} {{ltt|cpp/keyword/extern}}, {{ltt|cpp/keyword/mutable}}). Only one storage class specifier is allowed{{rev inl|since=c++11|, except that {{c/core|thread_local}} may appear together with {{c/core|extern}} or {{c/core|static}}}}.
* '''Type specifiers''' ({{spar|type-specifier-seq}}), a sequence of specifiers that names a type. The type of every entity introduced by the declaration is this type, optionally modified by the declarator (see below). This sequence of specifiers is also used by {{rlp|type#Type naming|type-id}}. Only the following specifiers are part of {{spar|type-specifier-seq}}, in any order:
:* {{rlp|class|class specifier}}
:* {{rlp|enum|enum specifier}}
:* simple type specifier
::*{{ltt|cpp/keyword/char}}, {{rev inl|since=c++20|{{ltt|cpp/keyword/char8_t}}, }} {{rev inl|since=c++11|{{ltt|cpp/keyword/char16_t}}, {{ltt|cpp/keyword/char32_t}}, }} {{ltt|cpp/keyword/wchar_t}}, {{ltt|cpp/keyword/bool}}, {{ltt|cpp/keyword/short}}, {{ltt|cpp/keyword/int}}, {{ltt|cpp/keyword/long}}, {{ltt|cpp/keyword/signed}}, {{ltt|cpp/keyword/unsigned}}, {{ltt|cpp/keyword/float}}, {{ltt|cpp/keyword/double}}, {{ltt|cpp/keyword/void}}
{{rev begin}}
{{rev|since=c++11|
::*{{rlpt|auto}}
::*{{rlp|decltype|decltype specifier}}
}}
{{rev|since=c++26|
::*{{rlp|pack indexing|pack indexing specifier}}
}}
{{rev end}}
::* previously declared class name (optionally {{rlp|identifiers#Qualified identifiers|qualified}})
::* previously declared enum name (optionally {{rlp|identifiers#Qualified identifiers|qualified}})
::* previously declared {{rlp|typedef|typedef-name}}{{rev inl|since=c++11| or {{rlp|type alias}}}} (optionally {{rlp|identifiers#Qualified identifiers|qualified}})
::* template name with template arguments (optionally {{rlp|identifiers#Qualified identifiers|qualified}}, optionally using {{rlp|dependent name|template disambiguator}})
{{rev begin}}
{{rev|since=c++17|
::*template name without template arguments (optionally {{rlp|identifiers#Qualified identifiers|qualified}}): see {{rlp|class template argument deduction}}
}}{{rev end}}
:* {{rlp|elaborated type specifier}}
::* the keyword {{ltt|cpp/keyword/class}}, {{ltt|cpp/keyword/struct}}, or {{ltt|cpp/keyword/union}}, followed by the identifier (optionally {{rlp|identifiers#Qualified identifiers|qualified}}), previously defined as the name of a class.
::* the keyword {{ltt|cpp/keyword/class}}, {{ltt|cpp/keyword/struct}}, or {{ltt|cpp/keyword/union}}, followed by template name with template arguments (optionally {{rlp|identifiers#Qualified identifiers|qualified}}, optionally using {{rlp|dependent name|template disambiguator}}), previously defined as the name of a class template.
::* the keyword {{ltt|cpp/keyword/enum}} followed by the identifier (optionally {{rlp|identifiers#Qualified identifiers|qualified}}), previously declared as the name of an enumeration.
:* {{rlp|dependent name|typename specifier}}
:* {{rlp|cv|cv qualifier}}
:only one type specifier is allowed in a decl-specifier-seq, with the following exceptions:
:* {{c/core|const}} can be combined with any type specifier except itself.
:* {{c/core|volatile}} can be combined with any type specifier except itself.
:* {{c/core|signed}} or {{c/core|unsigned}} can be combined with {{c/core|char}}, {{c/core|long}}, {{c/core|short}}, or {{c/core|int}}.
:* {{c/core|short}} or {{c/core|long}} can be combined with {{c/core|int}}.
:* {{c/core|long}} can be combined with {{c/core|double}}.
{{rrev|since=c++11|
:* {{c/core|long}} can be combined with {{c/core|long}}.
}}

{{rlp|attributes|Attributes}} may appear in {{spar|decl-specifier-seq}}, in which case they apply to the type determined by the preceding specifiers.

Repetitions of any specifier in a {{spar|decl-specifier-seq}}, such as {{c/core|const static const}}, or {{c/core|virtual inline virtual}} are errors{{rev inl|since=c++11|, except that {{c/core|long}} is allowed to appear twice}}.

===Declarators===
{{spar|init-declarator-list}} is a comma-separated sequence of one or more {{spar|init-declarators}}, which have the following syntax:

{{sdsc begin}}
{{sdsc|num=1|1=
{{spar|declarator}} {{spar optional|initializer}}
}}
{{sdsc|num=2|notes={{mark since c++20}}|1=
{{spar|declarator}} {{spar|requires-clause}}
}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|declarator}}|the declarator}}
{{par|{{spar|initializer}}|optional initializer (except where required, such as when initializing references or const objects). See {{rlp|initialization|Initialization}} for details.}}
{{par|{{spar|requires-clause}}|{{rlp|constraints#Requires clauses|a requires-clause}}, which adds a {{rlp|constraints|constraint}} to a {{rlp|function|function declaration}}}}
{{par end}}

Each {{spar|init-declarator}} in an init-declarator sequence {{c|S D1, D2, D3;}} is processed as if it were a standalone declaration with the same specifiers: {{c|S D1; S D2; S D3;}}.

Each declarator introduces exactly one object, reference, function, or (for typedef declarations) type alias, whose type is provided by {{spar|decl-specifier-seq}} and optionally modified by operators such as {{c|&amp;}} (reference to) or {{c|[]}} (array of) or {{c|()}} (function returning) in the declarator. These operators can be applied recursively, as shown below.

A {{spar|declarator}} is one of the following:
{{sdsc begin}}
{{sdsc|num=1|1=
{{spar|unqualified-id}} {{spar optional|attr}}
}}
{{sdsc|num=2|1=
{{spar|qualified-id}} {{spar optional|attr}}
}}
{{sdsc|num=3|notes={{mark since c++11}}|1=
{{ttb|...}} {{spar|identifier}} {{spar optional|attr}}
}}
{{sdsc|num=4|1=
{{ttb|*}} {{spar optional|attr}} {{spar optional|cv}} {{spar|declarator}}
}}
{{sdsc|num=5|1=
{{spar|nested-name-specifier}} {{ttb|*}} {{spar optional|attr}} {{spar optional|cv}} {{spar|declarator}}
}}
{{sdsc|num=6|1=
{{ttb|&amp;}} {{spar optional|attr}} {{spar|declarator}}
}}
{{sdsc|num=7|notes={{mark since c++11}}|1=
{{ttb|&amp;&amp;}} {{spar optional|attr}} {{spar|declarator}}
}}
{{sdsc|num=8|1=
{{spar|noptr-declarator}} {{ttb|[}} {{spar optional|constexpr}} {{ttb|]}} {{spar optional|attr}}
}}
{{sdsc|num=9|1=
{{spar|noptr-declarator}} {{ttb|(}} {{spar|parameter-list}} {{ttb|)}} {{spar optional|cv}} {{spar optional|ref}} {{spar optional|except}} {{spar optional|attr}}
}}
{{sdsc end}}

@1@ The {{rlp|name}} that is declared.
@2@ A declarator that uses a {{rlp|identifiers#Qualified identifiers|qualified identifier}} ({{spar|qualified-id}}) defines or redeclares a previously declared {{rlp|namespace#Namespaces|namespace member}} or {{rlp|classes|class member}}.
@3@ {{rlp|parameter pack|Parameter pack}}, only appears in {{rlp|function#Parameter list|parameter declarations}}.
@4@ {{rlp|pointer|Pointer declarator}}: the declaration {{c|S * D;}} declares {{tt|D}} as a pointer to the type determined by {{spar|decl-specifier-seq}} {{tt|S}}.
@5@ {{rlp|pointer|Pointer to member declaration}}: the declaration {{c|S C::* D;}} declares {{tt|D}} as a pointer to member of {{tt|C}} of type determined by {{spar|decl-specifier-seq}} {{tt|S}}. {{spar|nested-name-specifier}} is a {{rlp|identifiers#Qualified identifiers|sequence of names and scope resolution operators {{ttb|::}}}}
@6@ {{rlp|reference|Lvalue reference declarator}}: the declaration {{c|S &amp; D;}} declares {{tt|D}} as an lvalue reference to the type determined by {{spar|decl-specifier-seq}} {{tt|S}}.
@7@ {{rlp|reference|Rvalue reference declarator}}: the declaration {{c|S &amp;&amp; D;}} declares {{tt|D}} as an rvalue reference to the type determined by {{spar|decl-specifier-seq}} {{tt|S}}.
@8@ {{rlp|array|Array declarator}}. {{spar|noptr-declarator}} any valid declarator, but if it begins with *, &amp;, or &amp;&amp;, it has to be surrounded by parentheses.
@9@ {{rlp|function|Function declarator}}. {{spar|noptr-declarator}} any valid declarator, but if it begins with *, &amp;, or &amp;&amp;, it has to be surrounded by parentheses. {{rev inl|since=c++11|It may end with the optional trailing return type.}}

{{rrev|since=c++11|
In all cases, {{spar|attr}} is an optional sequence of {{rlp|attributes}}. When appearing immediately after the identifier, it applies to the object being declared.
}}

{{spar|cv}} is a sequence of {{rlp|cv|const and volatile}} qualifiers, where either qualifier may appear at most once in the sequence.

{{todo|explain declaration name hiding rules; how a variable/function declaration hides a class (but not a typedef) with the same name}}

===Notes===
When a {{spar|block-declaration}} appears {{rlp|statements#Compound statements|inside a block}}, and an identifier introduced by a declaration was previously declared in an outer block, the {{rlp|scope|outer declaration is hidden}} for the remainder of the block. 

If a declaration introduces a variable with automatic storage duration, it is initialized when its declaration statement is executed. All automatic variables declared in a block are destroyed on exit from the block (regardless how the block is exited: via {{rlp|exceptions|exception}}, {{rlp|goto}}, or by reaching its end), in order opposite to their order of initialization.

===Example===
{{example|
Note: this example demonstrates how some complex declarations are parsed in terms of the language grammar. Other popular mnemonics are: [https://c-faq.com/decl/spiral.anderson.html the spiral rule], reading [https://stackoverflow.com/a/34560439/273767 inside-out], and [https://stackoverflow.com/a/34552915/273767 declaration mirrors use]. There is also an automated parser at https://cdecl.org.
|code=
#include &lt;type_traits&gt;

struct S
{
    int member;
    // decl-specifier-seq is "int"
    // declarator is "member"
} obj, *pObj(&amp;obj);
// decl-specifier-seq is "struct S { int member; }"
// declarator "obj" declares an object of type S
// declarator "*pObj" declares a pointer to S,
//     and initializer "(&amp;obj)" initializes it

int i = 1, *p = nullptr, f(), (*pf)(double);
// decl-specifier-seq is "int"
// declarator "i" declares a variable of type int,
//     and initializer "= 1" initializes it
// declarator "*p" declares a variable of type int*,
//     and initializer "= nullptr" initializes it
// declarator "f()" declares (but doesn't define)
//     a function taking no arguments and returning int
// declarator "(*pf)(double)" declares a pointer to function
//     taking double and returning int

int (*(*var1)(double))[3] = nullptr;
// decl-specifier-seq is "int"
// declarator is "(*(*var1)(double))[3]"
// initializer is "= nullptr"

// 1. declarator "(*(*var1)(double))[3]" is an array declarator:
//    Type declared is: "(*(*var1)(double))" array of 3 elements
// 2. declarator "(*(*var1)(double))" is a pointer declarator:
//    Type declared is: "(*var1)(double)" pointer to array of 3 elements
// 3. declarator "(*var1)(double)" is a function declarator:
//    Type declared is: "(*var1)" function taking "(double)",
//    returning pointer to array of 3 elements.
// 4. declarator "(*var1)" is a pointer declarator:
//    Type declared is: "var1" pointer to function taking "(double)",
//    returning pointer to array of 3 elements.
// 5. declarator "var1" is an identifier.
// This declaration declares the object var1 of type "pointer to function
// taking double and returning pointer to array of 3 elements of type int"
// The initializer "= nullptr" provides the initial value of this pointer.

// C++11 alternative syntax:
auto (*var2)(double) -&gt; int (*)[3] = nullptr;
// decl-specifier-seq is "auto"
// declarator is "(*var2)(double) -&gt; int (*)[3]"
// initializer is "= nullptr"

// 1. declarator "(*var2)(double) -&gt; int (*)[3]" is a function declarator:
//    Type declared is: "(*var2)" function taking "(double)", returning "int (*)[3]"
// ...

int main()
{
    static_assert(std::is_same_v&lt;decltype(var1), decltype(var2)&gt;);
}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=482|std=C++98|before=the declarators of redeclarations could not be qualified|after=qualified declarators allowed}}
{{dr list item|wg=cwg|dr=569|std=C++98|before=a single standalone semicolon was not a valid declaration|after=it is an empty declaration,&lt;br&gt;which has no effect}}
{{dr list item|wg=cwg|dr=1830|std=C++98|before=repetition of a function specifier in a {{spar|decl-specifier-seq}} was allowed|after=repetition is forbidden}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc see c|c/language/declarations|Declarations|nomono=true}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}