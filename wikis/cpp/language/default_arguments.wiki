{{title|Default arguments}}
{{cpp/language/functions/navbar}}

Allows a function to be called without providing one or more trailing arguments.

Indicated by using the following syntax for a parameter in the {{spar|parameter-list}} of a {{rlp|function|function declaration}}.

{{sdsc begin}}
{{sdsc|num=1|1=
{{spar optional|attr}} {{spar|decl-specifier-seq}} {{spar|declarator}} {{ttb|1==}} {{spar|initializer}}
}}
{{sdsc|num=2|1=
{{spar optional|attr}} {{spar|decl-specifier-seq}} {{spar optional|abstract-declarator}} {{ttb|1==}} {{spar|initializer}}
}}
{{sdsc end}}

Default arguments are used in place of the missing trailing arguments in a function call:
{{source|1=
void point(int x = 3, int y = 4);

point(1, 2); // calls point(1, 2)
point(1);    // calls point(1, 4)
point();     // calls point(3, 4)
}}

In a function declaration, after a parameter with a default argument, all subsequent parameters must:
* have a default argument supplied in this or a previous declaration from the same scope:
{{source|1=
int x(int = 1, int); // Error: only the trailing parameters can have default arguments
                     // (assuming there's no previous declaration of x)

void f(int n, int k = 1);
void f(int n = 0, int k); // OK: the default argument of `k` is provided by
                          // the previous declaration in the same scope

void g(int, int = 7);

void h()
{
    void g(int = 1, int); // Error: not the same scope
}
}}
{{rrev|since=c++11|
:* ...unless the parameter was expanded from a parameter pack:
{{source|1=
template&lt;class... T&gt;
struct C { void f(int n = 0, T...); };

C&lt;int&gt; c;  // OK; instantiates declaration void C::f(int n = 0, int)
}}
* or be a function parameter pack:
{{source|1=
template&lt;class... T&gt;
void h(int i = 0, T... args); // OK
}}
}}

The ellipsis is not a parameter, and so can follow a parameter with a default argument:
{{source|1=
int g(int n = 0, ...); // OK
}}

Default arguments are only allowed in the parameter lists of {{rlp|function|function declarations}}{{rev inl|since=c++11| and {{rlp|lambda|lambda-expressions}},}} and are not allowed in the declarations of pointers to functions, references to functions, or in {{rlp|typedef}} declarations. Template parameter lists use similar syntax for their {{rlpsd|template parameters#Default template arguments}}.

For non-template functions, default arguments can be added to a function that was already declared if the function is redeclared in the same scope. At the point of a function call, the default arguments are a union of the default arguments provided in all visible declarations for the function. A redeclaration cannot introduce a default argument for a parameter for which a default argument is already visible (even if the value is the same). A re-declaration in an inner scope does not acquire the default arguments from outer scopes.
{{source|1=
void f(int, int);     // #1
void f(int, int = 7); // #2 OK: adds a default argument

void h()
{
    f(3); // #1 and #2 are in scope; makes a call to f(3,7)
    void f(int = 1, int); // Error: the default argument of the second
                          // parameter is not acquired from outer scopes
}

void m()
{ // new scope begins
    void f(int, int); // inner scope declaration; has no default argument.
    f(4); // Error: not enough arguments to call f(int, int)
    void f(int, int = 6);
    f(4); // OK: calls f(4, 6);
    void f(int, int = 6); // Error: the second parameter already has a
                          // default argument (even if the values are the same)
}

void f(int = 1, int); // #3 OK, adds a default argument to #2

void n()
{ // new scope begins
    f(); // #1, #2, and #3 are in scope: calls f(1, 7);
}
}}

If an {{rlp|inline}} function is declared in different translation units, the accumulated sets of default arguments must be the same at the end of each translation unit.

{{rrev|since=c++20|
If a non-inline function is declared in the same namespace scope in different translation units, the corresponding default arguments must be the same if present (but some default arguments can be absent in some TU).
}}

If a {{rlp|friend}} declaration specifies a default argument, it must be a friend function definition, and no other declarations of this function are allowed in the translation unit.

The {{rlpsd|namespace#Using-declarations}} carries over the set of known default arguments, and if more default arguments are added later to the function's namespace, those default arguments are also visible anywhere the using-declaration is visible:
{{source|1=
namespace N
{
    void f(int, int = 1);
}

using N::f;

void g()
{
    f(7); // calls f(7, 1);
    f();  // error
}

namespace N
{
    void f(int = 2, int);
}

void h()
{
    f();  // calls f(2, 1);
}
}}

The names used in the default arguments are looked up, checked for {{rlp|access|accessibility}}, and bound at the point of declaration, but are executed at the point of the function call:
{{source|1=
int a = 1;

int f(int);

int g(int x = f(a)); // lookup for f finds ::f, lookup for a finds ::a
                     // the value of ::a, which is 1 at this point, is not used

void h()
{
    a = 2; // changes the value of ::a
    {
        int a = 3;
        g(); // calls f(2), then calls g() with the result
    }
}
}}

For a {{rlp|member functions|member function}} of a non-{{rlp|templates#Templated entity|templated}} class, the default arguments are allowed on the out-of-class definition, and are combined with the default arguments provided by the declaration inside the class body. If these out-of-class default arguments would turn a member function into a default constructor or copy{{rev inl|since=c++11|/move}} constructor/assignment operator (which makes the call ambiguous), the program is ill-formed. For member functions of templated classes, all default arguments must be provided in the initial declaration of the member function.
{{source|1=
class C
{
    void f(int i = 3);
    void g(int i, int j = 99);
    C(int arg); // non-default constructor
};

void C::f(int i = 3) {}         // error: default argument already
                                // specified in class scope

void C::g(int i = 88, int j) {} // OK: in this translation unit,
                                // C::g can be called with no argument

C::C(int arg = 1) {}            // Error: turns this into a default constructor
}}

The overriders of {{rlp|virtual}} functions do not acquire the default arguments from the base class declarations, and when the virtual function call is made, the default arguments are decided based on the static type of the object (note: this can be avoided with [http://www.gotw.ca/publications/mill18.htm non-virtual interface] pattern).
{{source|1=
struct Base
{
    virtual void f(int a = 7);
};

struct Derived : Base
{
    void f(int a) override;
};

void m()
{
    Derived d;
    Base&amp; b = d;
    b.f(); // OK: calls Derived::f(7)
    d.f(); // Error: no default argument
}
}}

Local variables are not allowed in default arguments unless they are {{rlp|expressions#Potentially-evaluated expressions|not evaluated}}:
{{source|1=
void f()
{
    int n = 1;
    extern void g(int x = n); // error: local variable cannot be a default argument
    extern void h(int x = sizeof n); // OK as of CWG 2082
}
}}

The {{rlp|this}} pointer is not allowed in default arguments:
{{source|1=
class A
{
    void f(A* p = this) {} // error: this is not allowed
};
}}

Non-static class members are not allowed in default arguments (even if they are not evaluated), except when used to form a pointer-to-member or in a member access expression:
{{source|1=
int b;

class X
{
    int a;
    int mem1(int i = a); // error: non-static member cannot be used
    int mem2(int i = b); // OK: lookup finds X::b, the static member
    int mem3(int X::* i = &amp;X::a); // OK: non-static member can be used
    int mem4(int i = x.a); // OK: in a member access expression
    
    static X x;
    static int b;
};
}}

A default argument is evaluated each time the function is called with no argument for the corresponding parameter. Function parameters are not allowed in default arguments except if they are {{rlp|expressions#Potentially-evaluated expressions|not evaluated}}. Note that parameters that appear earlier in the parameter list are in {{rlp|scope}}:
{{source|1=
int a;

int f(int a, int b = a); // Error: the parameter a used in a default argument

int g(int a, int b = sizeof a); // Error until resolving CWG 2082
                                // OK after resolution: use in unevaluated context is OK
}}

The default arguments are not part of the function type:
{{source|1=
int f(int = 0);

void h()
{
    int j = f(1);
    int k = f(); // calls f(0);
}

int (*p1)(int) = &amp;f;
int (*p2)()    = &amp;f; // Error: the type of f is int(int)
}}

Operator functions cannot have default arguments, except for the function call operator:
{{source|1=
class C
{
    int operator[](int i = 0); // ill-formed
    int operator()(int x = 0); // OK
};
}}

{{rrev|since=c++23|
{{rlps|member functions#Explicit object parameter}}s cannot have default arguments:
{{source|1=
struct S { void f(this const S&amp; = S{}); }; // ill-formed
}}
}}

===Note===
Spaces may be necessary to avoid a compound assignment token if the parameter name is absent.
{{source|1=
void f1(int*=0);         // Error, '*=' is unexpected here
void g1(const int&amp;=0);   // Error, '&amp;=' is unexpected here
void f2(int* = 0);       // OK
void g2(const int&amp; = 0); // OK
void h(int&amp;&amp;=0);         // OK even without spaces, '&amp;&amp;' is a token here
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=217|std=C++98|before=a default argument could be added to a non-&lt;br&gt;template member function of a class template|after=prohibited}}
{{dr list item|wg=cwg|dr=1344|std=C++98|before=default arguments added in the out-of-class definition of a&lt;br&gt;member function could change it to a special member function|after=prohibited}}
{{dr list item|wg=cwg|dr=1716|std=C++98|before=default arguments were evaluated each time the function&lt;br&gt;is called, even if the caller provided the arguments|after= evaluated only if no&lt;br&gt;argument is provided for the&lt;br&gt;corresponding parameter}}
{{dr list item|wg=cwg|dr=2082|std=C++98|before=default arguments were forbidden to use local variables&lt;br&gt;and preceding parameters in unevaluated context|after=unevaluated context&lt;br&gt;use allowed}}
{{dr list item|wg=cwg|dr=2233|std=C++11|before=parameters expanded from parameter packs could&lt;br&gt;not appear after parameters with default arguments|after=allowed}}
{{dr list item|wg=cwg|dr=2683|std=C++98|before=out-of-class definitions of the member functions of class&lt;br&gt;templates' nested classes could have default arguments|after=prohibited}}
{{dr list end}}

{{langlinks|es|ja|ru|zh}}