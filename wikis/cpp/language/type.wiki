{{title|Type}}
{{cpp/language/basics/navbar}}
{{rlp|object|Objects}}, {{rlp|reference}}s, {{rlp|functions}} including {{rlp|template specialization|function template specializations}}, and {{rlp|expressions}} have a property called ''type'', which both restricts the operations that are permitted for those entities and provides semantic meaning to the otherwise generic sequences of bits.

===Type classification===
The C++ type system consists of the following types:
* {{rlp|types|fundamental types}} (see also {{lc|std::is_fundamental}}):
:* the type {{c/core|void}} (see also {{lc|std::is_void}});
{{rrev|since=c++11|
:* the type {{lc|std::nullptr_t}} (see also {{lc|std::is_null_pointer}});
}}
:* arithmetic types (see also {{lc|std::is_arithmetic}}):
::* integral types (including {{rlp|cv|cv-qualified versions}}, see also {{lc|std::is_integral}}, a synonym for integral type is integer type):
:::* the type {{c/core|bool}};
:::* character types:
::::* narrow character types:
:::::* ordinary character types: {{c/core|char}}, {{c/core|signed char}}, {{c/core|unsigned char}}&lt;ref&gt;{{c/core|signed char}} and {{c/core|unsigned char}} are narrow character types, but they are not character types. In other words, the set of narrow character types is not a subset of the set of character types.&lt;/ref&gt;
{{rrev|since=c++20|
:::::* the type {{c/core|char8_t}}
}}
::::* wide character types: {{rev inl|since=c++11|{{c/core|char16_t}}, {{c/core|char32_t}}, }}{{c/core|wchar_t}};
:::* signed integer types:
::::* standard signed integer types: {{c/core|signed char}}, {{c/core|short}}, {{c/core|int}}, {{c/core|long}}, {{c/core|long long}};
{{rrev|since=c++11|
::::* extended signed integer types (implementation-defined);
}}
:::* unsigned integer types:
::::* standard unsigned integer types: {{c/core|unsigned char}}, {{c/core|unsigned short}}, {{c/core|unsigned}}, {{c/core|unsigned long}}, {{c/core|unsigned long long}};
{{rrev|since=c++11|
::::* extended unsigned integer types (each corresponds to an extended signed integer type, and vice versa);
}}
::* floating-point types (see also {{lc|std::is_floating_point}}):
:::* standard floating-point types: {{c/core|float}}, {{c/core|double}}, {{c/core|long double}} and their {{rlp|cv|cv-qualified versions}};
{{rrev|since=c++23|
:::* extended floating-point types (including {{rlp|cv|cv-qualified versions}}):
::::* [[cpp/types/floating-point|fixed width floating-point types]];
::::* other implementation-defined extended floating-point types;
}}
* compound types (see also {{lc|std::is_compound}}):
:* {{rlp|reference|reference types}} (see also {{lc|std::is_reference}}):
::* {{rlp|reference#Lvalue references|lvalue reference types}} (see also {{lc|std::is_lvalue_reference}}):
:::* lvalue reference to object types;
:::* lvalue reference to function types;
{{rrev|since=c++11|
::* {{rlp|reference#Rvalue references|rvalue reference types}} (see also {{lc|std::is_rvalue_reference}}):
:::* rvalue reference to object types;
:::* rvalue reference to function types;
}}
:* {{rlp|pointer#Pointers|pointer types}} (see also {{lc|std::is_pointer}}):
::* {{rlp|pointer#Pointers to objects|pointer-to-object types}};
::* {{rlp|pointer#Pointers to functions|pointer-to-function types}};
:* {{rlp|pointer#Pointers to members|pointer-to-member types}} (see also {{lc|std::is_member_pointer}}):
::* {{rlp|pointer#Pointers to data members|pointer-to-data-member}} types (see also {{lc|std::is_member_object_pointer}});
::* {{rlp|pointer#Pointers to member functions|pointer-to-member-function}} types (see also {{lc|std::is_member_function_pointer}});
:* {{rlp|array|array types}} (see also {{lc|std::is_array}});
:* {{rlp|function|function types}} (see also {{lc|std::is_function}});
:* {{rlp|enum|enumeration types}} (see also {{lc|std::is_enum}});
::* {{rlp|enum#Unscoped enumerations|unscoped enumeration types}};
{{rrev|since=c++11|
::* {{rlp|enum#Scoped enumerations|scoped enumeration types}} (see also {{ltt std|cpp/types/is_scoped_enum}});
}}
:* {{rlp|class|class types}}:
::* non-union types (see also {{lc|std::is_class}});
::* {{rlp|union|union types}} (see also {{lc|std::is_union}}).

&lt;references/&gt;

For every non-cv-qualified type other than reference and function, the type system supports three additional {{rlp|cv|cv-qualified versions}} of that type ({{c/core|const}}, {{c/core|volatile}}, and {{c/core|const volatile}}).

{{anchor|Object type|Scalar type|Implicit-lifetime type|Trivially copyable type}}
===Other categories===
An ''object type'' (see also {{lc|std::is_object}}) is a (possibly cv-qualified) type that is not a function type, not a reference type, and not (possibly cv-qualified) {{c/core|void}}.

The following types are collectively called ''scalar types'' (see also {{lc|std::is_scalar}}):
* arithmetic types
* [[cpp/language/enum|enumeration types]]
* [[cpp/language/pointer|pointer types]]
* [[cpp/language/pointer#Pointers to members|pointer-to-member types]]
{{rrev|since=c++11|
* {{lc|std::nullptr_t}}
}}
* cv-qualified versions of these types

The following types are collectively called ''implicit-lifetime types'':
* scalar types
* [[cpp/language/classes#Implicit-lifetime class|implicit-lifetime class types]]
* array types
* cv-qualified versions of these types

{{rrev|since=c++11|
The following types are collectively called ''trivially copyable types'':
* scalar types
* [[cpp/language/classes#Trivially copyable class|trivially copyable class types]]
* arrays of such types
* cv-qualified versions of these types

The following types are collectively called ''standard-layout types'':
* scalar types
* [[cpp/language/classes#Standard-layout class|standard-layout class types]]
* arrays of such types
* cv-qualified versions of these types
}}

{{anchor|POD type|Trivial type}}

{{cot|Type traits hierarchy diagram}}
&lt;div style="overflow-x: scroll;"&gt;
[[File:cpp_types_v3.svg]]
&lt;/div&gt;
''Note: Elements of SVG image are clickable, but you must open the diagram in a new browser tab first''
{{cob}}

====Deprecated categories====
{{rev begin}}
&lt;tr class="t-rev"&gt;
&lt;td&gt;
The following types are collectively called ''POD types'' (see also {{lc|std::is_pod}}):
* scalar types
* [[cpp/language/classes#POD class|POD classes]]
* arrays of such types
* cv-qualified versions of these types
&lt;/td&gt;
&lt;td&gt;{{mark deprecated c++20}}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr class="t-rev"&gt;
&lt;td&gt;
The following types are collectively called ''trivial types'' (see also {{lc|std::is_trivial}}):
* scalar types
* [[cpp/language/classes#Trivial class|trivial class types]]
* arrays of such types
* cv-qualified versions of these types
&lt;/td&gt;
&lt;td&gt;{{mark since c++11}}&lt;br&gt;{{mark deprecated c++26}}&lt;/td&gt;
&lt;/tr&gt;
{{rev end}}

===Program-defined type===
A ''program-defined specialization'' is an {{rlp|template specialization|explicit specialization}} or {{rlp|partial specialization}} that is not part of the C++ {{lt|cpp/standard library}} and not defined by the implementation.

A ''program-defined type'' is one of the following types:
* A{{rev inl|since=c++11| non-{{rlp|lambda|closure}}}} {{rlp|class|class type}} or {{rlp|enum|enumeration type}} that is not part of the C++ standard library and not defined by the implementation.
{{rrev|since=c++11|
* A closure type of a non-implementation-provided {{rlp|lambda|lambda expression}}.
}}
* An {{rlp|templates|instantiation}} of a program-defined specialization.

===Type naming===
A {{rlp|name}} can be declared to refer to a type by means of:
* {{rlp|class}} declaration;
* {{rlp|union}} declaration;
* {{rlp|enum}} declaration;
* {{rlp|typedef}} declaration;
* {{rlp|type alias}} declaration.

Types that do not have names often need to be referred to in C++ programs; the syntax for that is known as {{spar|type-id}}. The syntax of the type-id that names type {{tt|T}} is exactly the syntax of a {{rlp|declarations|declaration}} of a variable or function of type {{tt|T}}, with the identifier omitted, except that {{spar|decl-specifier-seq}} of the declaration grammar is constrained to {{spar|type-specifier-seq}}, and that new types may be defined only if the type-id appears on the right-hand side of a non-template type alias declaration.
{{source|1=
int* p;               // declaration of a pointer to int
static_cast&lt;int*&gt;(p); // type-id is "int*"

int a[3];   // declaration of an array of 3 int
new int[3]; // type-id is "int[3]" (called new-type-id)

int (*(*x[2])())[3];      // declaration of an array of 2 pointers to functions
                          // returning pointer to array of 3 int
new (int (*(*[2])())[3]); // type-id is "int (*(*[2])())[3]"

void f(int);                    // declaration of a function taking int and returning void
std::function&lt;void(int)&gt; x = f; // type template parameter is a type-id "void(int)"
std::function&lt;auto(int) -&gt; void&gt; y = f; // same

std::vector&lt;int&gt; v;       // declaration of a vector of int
sizeof(std::vector&lt;int&gt;); // type-id is "std::vector&lt;int&gt;"

struct { int x; } b;         // creates a new type and declares an object b of that type
sizeof(struct { int x; });   // error: cannot define new types in a sizeof expression
using t = struct { int x; }; // creates a new type and declares t as an alias of that type

sizeof(static int); // error: storage class specifiers not part of type-specifier-seq
std::function&lt;inline void(int)&gt; f; // error: neither are function specifiers
}}
The {{spar|declarator}} part of the declaration grammar with the name removed is referred to as {{spar|abstract-declarator}}.

Type-id may be used in the following situations:
* to specify the target type in {{rlp|expressions#Conversions|cast expressions}};
* as arguments to {{rlpt|sizeof}}, {{rlpt|alignof}}, {{rlpt|alignas}}, {{rlpt|new}}, and {{rlpt|typeid}};
* on the right-hand side of a {{rlp|type alias}} declaration;
* as the trailing return type of a {{rlp|function}} declaration;
* as the default argument of a {{rlp|template parameters#Type template parameter|template type parameter}};
* as the template argument for a {{rlp|template parameters#Template type arguments|template type parameter}};
{{rrev|until=c++17|
* in {{rlp|except spec|dynamic exception specification}}.
}}

Type-id can be used with some modifications in the following situations:
* in the parameter list of a {{rlp|function#Parameter list|function}} (when the parameter name is omitted), type-id uses {{spar|decl-specifier-seq}} instead of {{spar|type-specifier-seq}} (in particular, some storage class specifiers are allowed);
* in the name of a {{rlp|cast operator|user-defined conversion function}}, the abstract declarator cannot include function or array operators.

{{todo|8.2[dcl.ambig.res] if it can be compactly summarized}}
{{todo|mention and link to decltype and auto}}

===Elaborated type specifier===
Elaborated type specifiers may be used to refer to a previously-declared class name (class, struct, or union) or to a previously-declared enum name even if the name was {{rlp|lookup|hidden by a non-type declaration}}. They may also be used to declare new class names.

See {{rlp|elaborated type specifier}} for details.

===Static type===
The type of an expression that results from the compile-time analysis of the program is known as the ''static type'' of the expression. The static type does not change while the program is executing.

===Dynamic type===
If some {{rlp|value category|glvalue expression}} refers to a {{rlp|object|polymorphic object}}, the type of its most derived object is known as the dynamic type.
{{source|1=
// given
struct B { virtual ~B() {} }; // polymorphic type
struct D : B {};               // polymorphic type

D d; // most-derived object
B* ptr = &amp;d;

// the static type of (*ptr) is B
// the dynamic type of (*ptr) is D
}}

For prvalue expressions, the dynamic type is always the same as the static type.

===Incomplete type===
The following types are ''incomplete types'':
* the type {{c/core|void}} (possibly {{rlp|cv}}-qualified);
* ''incompletely-defined object types'':
** class type that has been declared (e.g. by {{rlpsd|class#Forward declaration}}) but not defined;
** {{rlp|array#Arrays of unknown bound|array of unknown bound}};
** array of elements of incomplete type;
** {{rlp|enum|enumeration type}} from the point of declaration until its underlying type is determined.
All other types are complete.

Any of the following contexts requires type {{tt|T}} to be complete:
* {{rlp|function|definition}} of or call to a function with return type {{tt|T}} or argument type {{tt|T}}&lt;!-- there are exceptions, e.g., when the function call is the operand of decltype --&gt;;
* {{rlp|definition}} of an object of type {{tt|T}};
* declaration of a {{rlp|data members|non-static class data member}} of type {{tt|T}};
* {{rlp|new|{{tt|new}} expression}} for an object of type {{tt|T}} or an array whose element type is {{tt|T}};
* {{rlp|implicit cast#Lvalue to rvalue conversion|lvalue-to-rvalue conversion}} applied to a glvalue of type {{tt|T}};
* an {{rlp|implicit cast|implicit}} or {{rlp|explicit cast|explicit}} conversion to type {{tt|T}};
* a {{rlp|implicit cast|standard conversion}}, {{rlpt|dynamic_cast}}, or {{rlpt|static_cast}} to type {{c/core|T*}} or {{c/core|T&amp;}}, except when converting from the {{rlp|pointer#Null pointers|null pointer constant}} or from a {{rlp|pointer#Pointers to void|pointer to possibly cv-qualified void}};
* {{rlp|operator member access|class member access operator}} applied to an expression of type {{tt|T}};
* {{rlpt|typeid}}, {{rlpt|sizeof}}, or {{rlpt|alignof}} operator applied to type {{tt|T}};
* {{rlp|operator arithmetic|arithmetic operator}} applied to a pointer to {{tt|T}};
* definition of a class with base class {{tt|T}};
* assignment to an lvalue of type {{tt|T}};
* a {{rlp|catch|handler}} of type {{tt|T}}, {{c/core|T&amp;}}, or {{c/core|T*}}.
(In general, when the size and layout of {{tt|T}} must be known.)

If any of these situations occur in a translation unit, the definition of the type must appear in the same translation unit. Otherwise, it is not required.

An incompletely-defined object type can be completed:
* A class type (such as {{c/core|class X}}) might be regarded as incomplete at one point in a translation unit and regarded as complete later on; the type {{c/core|class X}} is the same type at both points:
{{source|1=
struct X;            // declaration of X, no definition provided yet
extern X* xp;        // xp is a pointer to an incomplete type:
                     // the definition of X is not reachable

void foo()
{
    xp++;            // ill-formed: X is incomplete
}

struct X { int i; }; // definition of X
X x;                 // OK: the definition of X is reachable

void bar()
{
    xp = &amp;x;         // OK: type is “pointer to X”
    xp++;            // OK: X is complete
}
}}

* The declared type of an array object might be an array of incomplete class type and therefore incomplete; if the class type is completed later on in the translation unit, the array type becomes complete; the array type at those two points is the same type.
* The declared type of an array object might be an array of unknown bound and therefore be incomplete at one point in a translation unit and complete later on; the array types at those two points ("array of unknown bound of {{tt|T}}" and "array of {{c|N}} {{tt|T}}") are different types.

The type of a pointer or reference to array of unknown bound permanently points to or refers to an incomplete type. An array of unknown bound named by a {{rlpt|typedef}} declaration permanently refers to an incomplete type. In either case, the array type cannot be completed:
{{source|1=
extern int arr[];   // the type of arr is incomplete
typedef int UNKA[]; // UNKA is an incomplete type

UNKA* arrp;         // arrp is a pointer to an incomplete type
UNKA** arrpp;

void foo()
{
    arrp++;         // error: UNKA is an incomplete type
    arrpp++;        // OK: sizeof UNKA* is known
}

int arr[10];        // now the type of arr is complete

void bar()
{
    arrp = &amp;arr;    // OK: qualification conversion (since C++20)
    arrp++;         // error: UNKA cannot be completed
}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=328|std=C++98|before=class members of incomplete type were not prohibited&lt;br&gt;if an object of the class type was never created|after=non-static class data members&lt;br&gt;need to be complete}}
{{dr list item|wg=cwg|dr=977|std=C++98|before=the point when an enumeration type becomes&lt;br&gt;complete in its definition was unclear|after=the type is complete once the&lt;br&gt;underlying type is determined}}
{{dr list item|wg=cwg|dr=1362|std=C++98|before=user-defined conversions to type {{tt|T*}} or {{tt|T&amp;}} required {{tt|T}} to be complete|after=not required}}
&lt;!-- the issue raised by DR 1482 targets the same problem of enum completeness as DR 977, hence it is not noted here --&gt;
{{dr list item|wg=cwg|dr=2006|std=C++98|before=cv-qualified {{c/core|void}} types were object type and complete type|after=excluded from both categories}}
{{dr list item|wg=cwg|dr=2448|std=C++98|before=only cv-unqualified types could be integral and floating-point types|after=allows cv-qualified types}}
{{dr list item|wg=cwg|dr=2630|std=C++98|before=it was unclear whether a class is considered complete outside&lt;br&gt;the translation unit where the definition of the class appears|after=the class is complete&lt;br&gt;if its definition is&lt;br&gt;reachable in this case}}
{{dr list item|wg=cwg|dr=2643|std=C++98|before=the type of a pointer to array of unknown bound&lt;br&gt;could not be completed (but it is already complete)|after=the pointed-to array type&lt;br&gt;cannot be completed}}
{{dr list item|wg=lwg|dr=2139|std=C++98|before=the meaning of “user-defined type” was unclear|after=defines and uses “program-&lt;br&gt;defined type” instead}}
{{dr list item|wg=lwg|dr=3119|std=C++11|before=it was unclear whether closure types are program-defined types|after=made clear}}
{{dr list end}}

===References===
{{ref std c++23}}
{{ref std|section=6.8.2|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=6.8.2|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=6.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=3.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=3.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=3.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc|'''{{ls|cpp/meta#Type traits}}'''|A compile-time template-based interfaces to query the properties of types}}
{{dsc see c|c/language/type|Type|nomono=true}}
{{dsc end}}

===External links===
{{elink begin}}
{{elink|[https://howardhinnant.github.io/TypeHiearchy.pdf Howard Hinnant's C++0x type tree]}}
{{elink end}}

{{langlinks|es|ja|ru|zh}}