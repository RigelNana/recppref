{{title|Templates}}
{{cpp/language/templates/navbar}}
A template is a C++ entity that defines one of the following:
* a family of classes ({{rlp|class template}}), which may be {{rlp|member template|nested classes}}
* a family of functions ({{rlp|function template}}), which may be {{rlp|member template|member functions}}
{{rrev|since=c++11|
* an alias to a family of types ({{rlp|type alias|alias template}})
}}
{{rrev|since=c++14|
* a family of variables ({{rlp|variable template}})
}}
{{rrev|since=c++20|
* a concept ({{rlp|constraints|constraints and concepts}})
}}

Templates are parameterized by one or more {{rlp|template parameters}}, of three kinds: type template parameters, non-type template parameters, and template template parameters.

When template arguments are provided, or, for {{rlp|function template#Template argument deduction|function}} {{rev inl|since=c++17| and {{rlp|class template argument deduction|class}}}} templates only, deduced, they are substituted for the template parameters to obtain a ''specialization'' of the template, that is, a specific type or a specific function lvalue.

Specializations may also be provided explicitly: {{rlp|template specialization|full specializations}} are allowed for class{{rev inl|since=c++14|, variable}} and function templates, {{rlp|partial specialization}}s are only allowed for class templates{{rev inl|since=c++14| and variable templates}}.

When a class template specialization is referenced in context that requires a complete object type, or when a function template specialization is referenced in context that requires a function definition to exist, the template is ''instantiated'' (the code for it is actually compiled), unless the template was already explicitly specialized or explicitly instantiated. Instantiation of a class template does not instantiate any of its member functions unless they are also used. At link time, identical instantiations generated by different translation units are merged.

The definition of a class template must be visible at the point of implicit instantiation, which is why template libraries typically provide all template definitions in the headers (e.g. [https://www.boost.org/doc/libs/release/more/getting_started/unix-variants.html#header-only-libraries most boost libraries are header-only]).

===Syntax===
{{sdsc begin}}
{{sdsc|num=1|{{ttb|template &lt;}}{{spar sep|parameter-list}}{{ttb|&gt;}} {{spar optional|requires-clause}} {{spar|declaration}}}}
{{sdsc|num=2|{{ttb|export template &lt;}}{{spar sep|parameter-list}}{{ttb|&gt;}} {{spar|declaration}}|notes={{mark until c++11}}}}
{{sdsc|num=3|{{ttb|template &lt;}}{{spar sep|parameter-list}}{{ttb|&gt; concept}} {{spar|concept-name}} {{ttb|1==}} {{spar sep|constraint-expression}}{{ttb|;}}|notes={{mark since c++20}}}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|parameter-list}}|a non-empty comma-separated list of the {{rlp|template parameters}}, each of which is either {{rlp|template parameters#Non-type template parameter|non-type parameter}}, a {{rlp|template parameters#Type template parameter|type parameter}}, a {{rlp|template parameters#Template template parameter|template parameter}}{{rev inl|since=c++11|, or a {{rlp|parameter pack}} of any of those}}.}}
{{par|{{spar|requires-clause}}|{{mark since c++20}} a {{rlp|constraints#requires clauses|requires-clause}} that specifies the {{rlp|constraints}} on the template arguments.}}
{{par|{{spar|declaration}}|declaration of a {{rlp|class template|class (including struct and union)}}, a {{rlp|member template|member class or member enumeration type}}, a {{rlp|function template|function}} or {{rlp|member template|member function}}, a static data member at namespace scope{{rev inl|since=c++14|{{rlp|variable template|, a variable or static data member at class scope}}}}{{rev inl|since=c++11|, or an {{rlp|type alias|alias template}}}}. It may also define a {{rlp|template specialization}}.}}
{{par|{{spar|concept-name}}&lt;br&gt;{{spar|constraint-expression}}|see {{rlp|constraints|constraints and concepts}}}}
{{par end}}

{{rrev|until=c++11|
{{c/core|export}} was an optional modifier which declared the template as ''exported'' (when used with a class template, it declared all of its members exported as well). Files that instantiated exported templates did not need to include their definitions: the declaration was sufficient. Implementations of {{c/core|export}} were rare and disagreed with each other on details.
}}

{{todo|core syntax, template parameters, and instantiations, take content common between class_template and function_template}}

{{anchor|template-id}}
===Template identifiers===
A template identifier has one of the following syntaxes:
{{sdsc begin}}
{{sdsc|num=1|{{spar sep|template-name}}{{ttb|&lt;}}{{spar optional|template-argument-list}}{{ttb|&gt;}}}}
{{sdsc|num=2|{{ttb|operator}}{{spar sep|op}}{{ttb|&lt;}}{{spar optional|template-argument-list}}{{ttb|&gt;}}}}
{{sdsc|num=3|{{ttb|operator ""}} {{spar|identifier}} {{ttb|&lt;}}{{spar optional|template-argument-list}}{{ttb|&gt;}}|notes={{mark since c++11}}&lt;br&gt;{{mark deprecated}}}}
{{sdsc|num=4|{{ttb|operator}} {{spar|user-defined-string-literal}} {{ttb|&lt;}}{{spar optional|template-argument-list}}{{ttb|&gt;}}|notes={{mark since c++11}}}}
{{sdsc end}}

@1@ A ''simple template identifier''.

@2@ An operator function template identifier.

@3,4@ A {{rlp|user literal#Literal operators|literal operator}} function template identifier.

{{par begin}}
{{par|{{spar|template-name}}|an {{rlp|identifiers|identifier}} that names a template}}
{{par|{{spar|op}}|an {{rlp|operators|overloadable operator}}}}
{{par|{{spar|identifier}}|an identifier}}
{{par|{{spar|user-defined-string-literal}}|{{c|""}} followed by an identifier}}
{{par end}}


A simple template identifier that names a class template specialization names a class.

A template identifier that names an alias template specialization names a type.

A template identifier that names a function template specialization names a function.

If all following conditions are satisfied, a template identifier is ''valid''{{sep}}:
* There are at most as many arguments as there are parameters{{rev inl|since=c++11| or a parameter is a template {{rlp|parameter pack}}}}.
* There is an argument for each non-deducible{{rev inl|since=c++11| non-pack}} parameter that does not have a default template argument.
* Each template argument matches the corresponding template parameter.
* Substitution of each template argument into the following template parameters (if any) succeeds.
{{rrev|since=c++20|
* If the template identifier is {{rlp|dependent name|non-dependent}}, the associated constraints are satisfied as specified below.
}}

An invalid simple template id is a compile-time error, unless it names a function template specialization (in which case {{rlp|sfinae|SFINAE}} may apply).
{{source|1=
template&lt;class T, T::type n = 0&gt;
class X;

struct S
{
    using type = int;
};

using T1 = X&lt;S, int, int&gt;; // error: too many arguments
using T2 = X&lt;&gt;;            // error: no default argument for first template parameter
using T3 = X&lt;1&gt;;           // error: value 1 does not match type-parameter
using T4 = X&lt;int&gt;;         // error: substitution failure for second template parameter
using T5 = X&lt;S&gt;;           // OK
}}

{{rrev|since=c++20|
When the {{spar|template-name}} of a simple template id names a constrained non-function template or a constrained template template parameter, but not a member template that is a member of an unknown specialization, and all template arguments in the simple template id are non-dependent, the associated constraints of the constrained template must be satisfied:
{{source|1=
template&lt;typename T&gt;
concept C1 = sizeof(T) != sizeof(int);

template&lt;C1 T&gt;
struct S1 {};

template&lt;C1 T&gt;
using Ptr = T*;

S1&lt;int&gt;* p;                      // error: constraints not satisfied
Ptr&lt;int&gt; p;                      // error: constraints not satisfied

template&lt;typename T&gt;
struct S2 { Ptr&lt;int&gt; x; };       // error, no diagnostic required

template&lt;typename T&gt;
struct S3 { Ptr&lt;T&gt; x; };         // OK, satisfaction is not required

S3&lt;int&gt; x;                       // error: constraints not satisfied

template&lt;template&lt;C1 T&gt; class X&gt;
struct S4
{
    X&lt;int&gt; x;                    // error, no diagnostic required
};

template&lt;typename T&gt;
concept C2 = sizeof(T) == 1;

template&lt;C2 T&gt; struct S {};

template struct S&lt;char[2]&gt;;      // error: constraints not satisfied
template&lt;&gt; struct S&lt;char[2]&gt; {}; // error: constraints not satisfied
}}
}}

If all following conditions are satisfied, two template identifiers are ''same''{{sep}}:
* Their {{spar sep|template-name}}s or operators refer to the same template.
* Their corresponding type template arguments are the same type.
* The template parameter values determined by their corresponding non-type template arguments are {{rlp|template parameters#Template argument equivalence|template-argument-equivalent}}.
* Their corresponding template template arguments refer to the same template.

Two template identifier that are the same refer to the same{{rev inl|since=c++14| variable,}} class, or function.

===Templated entity===
A ''templated entity'' (or, in some sources, "temploid") is any entity that is defined{{rev inl|since=c++11| (or, for a {{rlp|lambda|lambda expression}}, created)}} within a template definition. All of the following are templated entities:
* a class/function{{rev inl|since=c++14|/variable}} template
{{rrev|since=c++20|
* a {{rlp|constraints|concept}}
}}
* a member of a templated entity (such as a non-template member function of a class template)
* an enumerator of an enumeration that is a templated entity
* any entity defined or created within a templated entity: a local class, a local variable, a friend function, etc
{{rrev|since=c++11|
* the closure type of a lambda expression that appears in the declaration of a templated entity
}}

For example, in
{{source|1=
template&lt;typename T&gt;
struct A
{
    void f() {}
};
}}
the function {{tt|A::f}} is not a function template, but is still considered to be templated.


A ''templated function'' is a function template or a function that is templated.

A ''templated class'' is a class template or a class that is templated.

{{rrev|since=c++14|
A ''templated variable'' is a variable template or a variable that is templated.
}}

===Keywords===
{{ltt|cpp/keyword/template}},
{{ltt|cpp/keyword/export}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=2293|std=C++98|before=the rules of determining whether a template&lt;br&gt;identifier is valid were not provided|after=provided}}
{{dr list item|wg=cwg|dr=2682|std=C++98&lt;br&gt;C++14|before=the definitions of templated function/template class&lt;br&gt;(C++98)/templated variable (C++14) were missing|after=added}}
{{dr list item|paper=P2308R1|std=C++98|before=two template identifiers were different if their&lt;br&gt;corresponding non-type template arguments&lt;br&gt;are not template-argument-equivalent|after=they are different if their corresponding&lt;br&gt;non-type template parameter values&lt;br&gt;are not template-argument-equivalent}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc see c|c/language/generic|Generic selection|nomono=true}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}