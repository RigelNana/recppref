{{title|Logical operators}}
{{cpp/language/expressions/navbar}}
Returns the result of a boolean operation.

{|class="wikitable" style="font-size:85%;"
|-
!rowspan="2"|Operator name
!rowspan="2"|Syntax
!rowspan="2"|{{rlp|operators|Over&amp;#8203;load&amp;#8203;able}}
!colspan="2"|Prototype examples (for {{c|class T}})
|-
!Inside class definition
!Outside class definition
|-
|negation
|{{c|not a}}
{{c|1=!a}}
|{{yes}}
|{{c|bool T::operator!() const;}}
|{{c|bool operator!(const T &amp;a);}}
|-
|AND
|{{c|a and b}}
{{c|a &amp;&amp; b}}
|{{yes}}
|{{c|bool T::operator&amp;&amp;(const T2 &amp;b) const;}}
|{{c|bool operator&amp;&amp;(const T &amp;a, const T2 &amp;b);}}
|-
|inclusive OR
|{{c|a or b}}
{{c|1=a {{!!}} b}}
|{{yes}}
|{{c|bool T::operator{{!!}}(const T2 &amp;b) const;}}
|{{c|bool operator{{!!}}(const T &amp;a, const T2 &amp;b);}}
|-
|colspan="5" |
:'''Notes'''&lt;br&gt;
* The keyword-like forms ({{c|and}},{{c|or}},{{c|not}}) and the symbol-like forms ({{c|&amp;&amp;}},{{c|{{!!}}}},{{c|!}}) can be used interchangeably (see {{rlp|operator_alternative|alternative representations}}).
* All built-in operators return {{c|bool}}, and most {{rlp|operators|user-defined overloads}} also return {{c|bool}} so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including {{c|void}}).
* Builtin operators {{ttb|&amp;&amp;}} and {{ttb|{{!!}}}} perform short-circuit evaluation (do not evaluate the second operand if the result is known after evaluating the first), but overloaded operators behave like regular function calls and always evaluate both operands.
|}

===Explanation===
The logic operator expressions have the form 

{{sdsc begin}}
{{sdsc|num=1|{{ttb|!}} {{spar|rhs}}}}
{{sdsc|num=2|{{spar|lhs}} {{ttb|&amp;&amp;}} {{spar|rhs}}}}
{{sdsc|num=3|{{spar|lhs}} {{ttb|&lt;nowiki&gt;||&lt;/nowiki&gt;}} {{spar|rhs}}}}
{{sdsc end}}
@1@ Logical NOT
@2@ Logical AND
@3@ Logical inclusive OR

If the operand is not {{c|bool}}, it is converted to {{c|bool}} using {{rlp|implicit_conversion|contextual conversion to bool}}: it is only well-formed if the declaration {{tt|bool t(arg)}} is well-formed, for some invented temporary {{tt|t}}.

The result is a {{c|bool}} prvalue.

For the built-in logical NOT operator, the result is {{c|true}} if the operand is {{c|false}}. Otherwise, the result is {{c|false}}.

For the built-in logical AND operator, the result is {{c|true}} if both operands are {{c|true}}. Otherwise, the result is {{c|false}}. This operator is {{enwiki|Short-circuit_evaluation|short-circuiting}}: if the first operand is {{c|false}}, the second operand is not evaluated.

For the built-in logical OR operator, the result is {{c|true}} if either the first or the second operand (or both) is {{c|true}}. This operator is short-circuiting: if the first operand is {{c|true}}, the second operand is not evaluated.

Note that {{rlp|operator_arithmetic|bitwise logic operators}} do not perform short-circuiting.

===Results===
{|table class=wikitable
!{{c|a}}
|{{c|true}}
|{{c|false}}
|-
!{{c|!a}}
|{{c|false}}
|{{c|true}}
|}
{|table class=wikitable
!colspan=2 rowspan=2|{{c|and}}
!colspan=2|{{c|a}}
|-
|{{c|true}} &lt;!--a--&gt;
|{{c|false}} &lt;!--a--&gt;
|-
!rowspan=2|{{c|b}}
|{{c|true}} &lt;!--b--&gt;
|{{c|true}} &lt;!--true&amp;&amp;true--&gt;
|{{c|false}}&lt;!--true&amp;&amp;false--&gt;
|-
|{{c|false}}&lt;!--b--&gt;
|{{c|false}}&lt;!--true&amp;&amp;false--&gt;
|{{c|false}}&lt;!--false&amp;&amp;false--&gt;
|}
{|table class=wikitable
!colspan=2 rowspan=2|{{c|or}}
!colspan=2|{{c|a}}
|-
|{{c|true}} &lt;!--a--&gt;
|{{c|false}}&lt;!--a--&gt;
|-
!rowspan=2|{{c|b}}
|{{c|true}}&lt;!--b--&gt;
|{{c|true}}&lt;!--true||true--&gt;
|{{c|true}}&lt;!--true||false--&gt;
|-
|{{c|false}}&lt;!--b--&gt;
|{{c|true}}&lt;!--false||true--&gt;
|{{c|false}}&lt;!--false||false--&gt;
|}

In {{rlp|overload_resolution#Call_to_an_overloaded_operator|overload resolution against user-defined operators}}, the following built-in function signatures participate in overload resolution:
{{dcl begin}}
{{dcl|bool operator!(bool)}}
{{dcl|bool operator&amp;&amp;(bool, bool)}}
{{dcl|bool operator{{!!}}(bool, bool)}}
{{dcl end}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

int main()
{
    int n = 2;
    int* p = &amp;n;
    // pointers are convertible to bool
    if (    p &amp;&amp; *p == 2  // "*p" is safe to use after "p &amp;&amp;"
        {{!!}} !p &amp;&amp;  n != 2) // {{!!}} has lower precedence than &amp;&amp;
        std::cout &lt;&lt; "true\n";

    // streams are also convertible to bool
    std::stringstream cin;
    cin &lt;&lt; "3...\n" &lt;&lt; "2...\n" &lt;&lt; "1...\n" &lt;&lt; "quit";
    std::cout &lt;&lt; "Enter 'quit' to quit.\n";
    for (std::string line;    std::cout &lt;&lt; "&gt; "
                           &amp;&amp; std::getline(cin, line)
                           &amp;&amp; line != "quit";)
        std::cout &lt;&lt; line &lt;&lt; '\n';
}
|output=
true
Enter 'quit' to quit.
&gt; 3...
&gt; 2...
&gt; 1...
&gt;
}}

===Standard library===
Because the short-circuiting properties of {{tt|operator&amp;&amp;}} and {{tt|operator{{!!}}}} do not apply to overloads, and because types with boolean semantics are uncommon, only two standard library classes overload these operators:

{{dsc begin}}
{{dsc mem fun|cpp/numeric/valarray/operator_arith|title=operator!|applies a unary arithmetic operator to each element of the valarray}}
{{dsc tfun|cpp/numeric/valarray/operator_arith3|title=operator&amp;&amp;&lt;br&gt;operator&lt;nowiki&gt;||&lt;/nowiki&gt;|applies binary operators to each element of two valarrays, or a valarray and a value}}
{{dsc inc|cpp/io/basic_ios/dsc operator!}}
{{dsc end}}

===See also===
{{rlp|operator precedence|Operator precedence}}

{{rlp|operators|Operator overloading}}

{{dsc begin}}
{{dsc inc | cpp/utility/functional/dsc logical_and}}
{{dsc inc | cpp/utility/functional/dsc logical_or}}
{{dsc inc | cpp/utility/functional/dsc logical_not}}
{{dsc end}}

{{cpp/language/operators}}
{{dsc begin}}
{{dsc see c|c/language/operator logical|Logical operators|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}