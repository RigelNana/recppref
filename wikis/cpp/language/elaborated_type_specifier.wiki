{{title|Elaborated type specifier}}
{{cpp/language/declarations/navbar}}

Elaborated type specifiers may be used to refer to a previously-declared class name (class, struct, or union) or to a previously-declared enum name even if the name was {{rlp|lookup|hidden by a non-type declaration}}. They may also be used to declare new class names. 

===Syntax===
{{sdsc begin}}
{{sdsc|num=1|
{{spar|class-key}} {{spar|class-name}}
}}
{{sdsc|num=2|
{{ttb|enum}} {{spar|enum-name}}
}}
{{sdsc|num=3|
{{spar|class-key}} {{spar optional|attr}} {{spar|identifier}} {{ttb|;}}
}}
{{sdsc end}}
{{par begin}}
{{par|{{spar|class-key}}|one of {{lt|cpp/keyword/class}}, {{lt|cpp/keyword/struct}}, {{lt|cpp/keyword/union}}}}
{{par|{{spar|class-name}}|the name of a previously-declared class type, optionally [[cpp/language/identifiers#Qualified identifiers|qualified]], or an identifier not previously declared as a type name}}
{{par|{{spar|enum-name}}|the name of a previously-declared enumeration type, optionally [[cpp/language/identifiers#Qualified identifiers|qualified]]}}
{{par|{{spar|attr}}|{{mark since c++11}} any number of {{rlp|attributes}}}}
{{par end}}

@1@ Elaborated type specifier for a class type.
@2@ Elaborated type specifier for an enumeration type.
@3@ A declaration that consists solely of an elaborated type specifier always declares a class type named by {{spar|identifier}} in the {{rlp|scope}} that contains the declaration.

{{rlp|enum|Opaque enum declaration}} resembles form {{v|3}}, but the enum type is a complete type after an opaque enum declaration.

===Explanation===
Form {{v|3}} is a special case of elaborated type specifier, usually referred to as ''forward declaration'' of classes, for the description of form {{v|3}}, see {{ls|cpp/language/class#Forward declaration}}. The following only apply to form {{v|1}} and {{v|2}}.

The {{spar|class-name}} or {{spar|enum-name}} in the elaborated type specifier may either be a simple identifier or be a {{rlp|identifiers#Qualified identifiers|qualified-id}}. The name is looked up using {{rlp|unqualified lookup|unqualified name lookup}} or {{rlp|qualified lookup|qualified name lookup}}, depending on their appearance. But in either case, non-type names are not considered.
{{source|1=
class T
{
public:
    class U;
private:
    int U;
};

int main()
{
    int T;
    T t; // error: the local variable T is found
    class T t; // OK: finds ::T, the local variable T is ignored
    T::U* u; // error: lookup of T::U finds the private data member
    class T::U* u; // OK: the data member is ignored
}
}}

If the name lookup does not find a previously declared type name, the elaborated-type-specifier is introduced by {{ttb|class}}, {{ttb|struct}}, or {{ttb|union}} (i.e. not by {{ttb|enum}}), and {{spar|class-name}} is an unqualified identifier, then the elaborated-type-specifier is a class declaration of the class-name.
{{source|1=
template&lt;typename T&gt;
struct Node
{
    struct Node* Next; // OK: lookup of Node finds the injected-class-name
    struct Data* Data; // OK: declares type Data at global scope
                       // and also declares the data member Data
    friend class ::List; // error: cannot introduce a qualified name
    enum Kind* kind; // error: cannot introduce an enum
};

Data* p; // OK: struct Data has been declared
}}

If the name refers to a {{rlp|typedef|typedef name}}, a {{rlp|type alias}}, a {{rlp|template parameters#Type template parameter|template type parameter}}, or an {{rlp|type alias|alias template specialization}}, the program is ill-formed, otherwise the elaborated type specifier introduces the name into the declaration the same way a {{rlp|declarations#Specifiers|simple type specifier}} introduces its type-name.
{{source|1=
template&lt;typename T&gt;
class Node
{
    friend class T; // error: type parameter cannot appear in an elaborated type specifier;
                    // note that similar declaration `friend T;` is OK.
};

class A {};
enum b { f, t };

int main()
{
    class A a; // OK: equivalent to 'A a;'
    enum b flag; // OK: equivalent to 'b flag;'
}
}}

The {{spar|class-key}} or {{ttb|enum}} keyword present in the elaborated-type-specifier must agree in kind with the declaration to which the name in the elaborated-type-specifier refers.
* the {{ttb|enum}} keyword must be used to refer to an {{rlp|enum|enumeration type}} (whether scoped or unscoped)
* the {{ttb|union}} {{spar|class-key}} must be used to refer to a {{rlp|union}}
* either the {{ttb|class}} or {{ttb|struct}} {{spar|class-key}} must be used to refer to a non-union class type (the keywords {{ttb|class}} and {{ttb|struct}} are interchangeable here).
{{source|1=
enum class E { a, b };
enum E x = E::a; // OK
enum class E y = E::b; // error: 'enum class' cannot introduce an elaborated type specifier

struct A {};
class A a; // OK
}}

When used as a {{rlp|template parameters#Template arguments|template argument}}, {{c|class T}} is a type template parameter named {{tt|T}}, not an unnamed non-type parameter whose type {{tt|T}} is introduced by elaborated type specifier. {{mark unreviewed dr|CWG|1874}}

===Keywords===
{{ltt|cpp/keyword/class}},
{{ltt|cpp/keyword/struct}},
{{ltt|cpp/keyword/union}},
{{ltt|cpp/keyword/enum}}

===References===
{{ref std c++23}}
{{ref std|section=6.5.6|title=Elaborated type specifiers|id=basic.lookup.elab}}
{{ref std|section=9.2.9.4|title=Elaborated type specifiers|id=dcl.type.elab}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=6.5.4|title=Elaborated type specifiers|id=basic.lookup.elab}}
{{ref std|section=9.2.8.3|title=Elaborated type specifiers|id=dcl.type.elab}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=6.4.4|title=Elaborated type specifiers|id=basic.lookup.elab}}
{{ref std|section=10.1.7.3|title=Elaborated type specifiers|id=dcl.type.elab}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=3.4.4|title=Elaborated type specifiers|id=basic.lookup.elab}}
{{ref std|section=7.1.6.3|title=Elaborated type specifiers|id=dcl.type.elab}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=3.4.4|title=Elaborated type specifiers|id=basic.lookup.elab}}
{{ref std|section=7.1.6.3|title=Elaborated type specifiers|id=dcl.type.elab}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=3.4.4|title=Elaborated type specifiers|id=basic.lookup.elab}}
{{ref std|section=7.1.5.3|title=Elaborated type specifiers|id=dcl.type.elab}}
{{ref std end}}

{{todo|probably pull most of 9.1[class.name]/2-3 out of cpp/language/class}}

{{langlinks|es|ja|zh}}