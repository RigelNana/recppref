{{title|String literal}}
{{cpp/language/expressions/navbar}}
===Syntax===
{{sdsc begin}}
{{sdsc|num=1|{{ttb|"}}{{spar optional|s-char-seq}}{{ttb|"}}}}
{{sdsc|num=2|{{ttb|R"}}{{spar optional|d-char-seq}}{{ttb|(}}{{spar optional|r-char-seq}}{{ttb|)}}{{spar optional|d-char-seq}}{{ttb|"}}|notes={{mark since c++11}}}}
{{sdsc|num=3|{{ttb|L"}}{{spar optional|s-char-seq}}{{ttb|"}}}}
{{sdsc|num=4|{{ttb|LR"}}{{spar optional|d-char-seq}}{{ttb|(}}{{spar optional|r-char-seq}}{{ttb|)}}{{spar optional|d-char-seq}}{{ttb|"}}|notes={{mark since c++11}}}}
{{sdsc|num=5|{{ttb|u8"}}{{spar optional|s-char-seq}}{{ttb|"}}|notes={{mark since c++11}}}}
{{sdsc|num=6|{{ttb|u8R"}}{{spar optional|d-char-seq}}{{ttb|(}}{{spar optional|r-char-seq}}{{ttb|)}}{{spar optional|d-char-seq}}{{ttb|"}}|notes={{mark since c++11}}}}
{{sdsc|num=7|{{ttb|u"}}{{spar optional|s-char-seq}}{{ttb|"}}|notes={{mark since c++11}}}}
{{sdsc|num=8|{{ttb|uR"}}{{spar optional|d-char-seq}}{{ttb|(}}{{spar optional|r-char-seq}}{{ttb|)}}{{spar optional|d-char-seq}}{{ttb|"}}|notes={{mark since c++11}}}}
{{sdsc|num=9|{{ttb|U"}}{{spar optional|s-char-seq}}{{ttb|"}}|notes={{mark since c++11}}}}
{{sdsc|num=10|{{ttb|UR"}}{{spar optional|d-char-seq}}{{ttb|(}}{{spar optional|r-char-seq}}{{ttb|)}}{{spar optional|d-char-seq}}{{ttb|"}}|notes={{mark since c++11}}}}
{{sdsc end}}

===Explanation===
{{par begin}}
{{par|{{spar|s-char-seq}}|A sequence of one or more {{spar sep|s-char}}s}}
{{par|{{spar|s-char}}|One of
* a {{spar|basic-s-char}}
* an escape sequence, as defined in {{rlp|escape|escape sequences}}
* a universal character name, as defined in {{rlp|escape|escape sequences}}}}
{{par|{{spar|basic-s-char}}|A character from the {{rlp|charset#Translation character set|translation character set}}, except the double-quote {{c|"}}, backslash {{c|\}}, or new-line character}}
{{par|{{spar|d-char-seq}}|A sequence of one or more {{spar sep|d-char}}s, at most 16 characters long}}
{{par|{{spar|d-char}}|A character from the {{rlp|charset#Basic character set|basic character set}}, except parentheses, backslash and [[cpp/string/byte/isspace|spaces]]}}
{{par|{{spar|r-char-seq}}|A sequence of one or more {{spar sep|r-char}}s, except that it must not contain the closing sequence {{box|{{ttb|)}}{{spar|d-char-seq}}{{ttb|"}}}}}}
{{par|{{spar|r-char}}|A character from the {{rlp|charset#Translation character set|translation character set}}}}
{{par end}}

{{anchor|Info table}}
{|class="wikitable" style="text-align: center;"
!{{nbsp}}Syntax{{nbsp}}
!Kind
!Type
!Encoding
|-
|{{v|1,2}}
|{{nbsp}}ordinary string literal{{nbsp}}
|{{c/core|const char[N]}}
|{{rlp|charset#Code unit and literal encoding|ordinary literal encoding}}
|-
|{{v|3,4}}
|wide string literal
|{{c/core|const wchar_t[N]}}
|{{rlp|charset#Code unit and literal encoding|wide literal encoding}}
|-
|{{v|5,6}}
|UTF-8 string literal
|{{rrev multi|until1=c++20|rev1={{c/core|const char[N]}}|rev2={{c/core|const char8_t[N]}}}}
|UTF-8
|-
|{{v|7,8}}
|UTF-16 string literal
|{{c/core|const char16_t[N]}}
|UTF-16
|-
|{{v|9,10}}
|UTF-32 string literal
|{{c/core|const char32_t[N]}}
|UTF-32
|}

In the types listed in the table above, {{c|N}} is the number of encoded code units, which is determined [[#Initialization|below]].

Ordinary{{rev inl|since=c++11| and UTF-8}} string literals are collectively referred to as narrow string literals.

Evaluating a string literal results in a string literal object with static {{rlp|storage duration}}. Whether all string literals are stored in {{rlp|object#Subobjects|nonoverlapping objects}} and whether successive evaluations of a string literal yield the same or a different object is unspecified.

The effect of attempting to modify a string literal object is undefined.

{{source|1=
bool b = "bar" == 3 + "foobar"; // can be true or false, unspecified

const char* pc = "Hello";
char* p = const_cast&lt;char*&gt;(pc);
p[0] = 'M'; // undefined behavior
}}

{{rrev|since=c++11|
===Raw string literals===
Raw string literals are string literals with a prefix containing {{box|{{ttb|R}}}} (syntaxes {{v|2,4,6,8,10}}). They do not escape any character, which means anything between the delimiters {{box|{{spar sep|d-char-seq}}{{ttb|(}}}} and {{box|{{ttb|)}}{{spar|d-char-seq}}}} becomes part of the string. The terminating {{spar|d-char-seq}} is the same sequence of characters as the initial {{spar|d-char-seq}}.

{{source|1=
// OK: contains one backslash,
// equivalent to "\\"
R"(\)";

// OK: contains four \n pairs,
// equivalent to "\\n\\n\\n\\n"
R"(\n\n\n\n)";

// OK: contains one close-parenthesis, two double-quotes and one open-parenthesis,
// equivalent to ")\"\"("
R"-()""()-";

// OK: equivalent to "\n)\\\na\"\"\n"
R"a(
)\
a""
)a";

// OK: equivalent to "x = \"\"\\y\"\""
R"(x = ""\y"")";

// R"&lt;&lt;(-_-)&gt;&gt;"; // Error: begin and end delimiters do not match
// R"-()-"-()-"; // Error: )-" appears in the middle and terminates the literal
}}
}}

===Initialization===
String literal objects are initialized with the sequence of code unit values corresponding to the string literal’s sequence of {{spar sep|s-char}}s{{rev inl|since=c++11| and {{spar sep|r-char}}s}}, plus a terminating null character (U+0000), in order as follows:

@1@ For each contiguous sequence of {{spar sep|basic-s-char}}s,{{rev inl|since=c++11| {{spar sep|r-char}}s,}} {{rlp|escape|simple escape sequences}} and {{rlp|escape|universal character names}}, the sequence of character it denotes is encoded to a code unit sequence using the string literal’s associated character encoding. If a character lacks representation in the associated character encoding, then the program is ill-formed.
@@ If the associated character encoding is stateful, the first such sequence is encoded beginning with the initial encoding state and each subsequent sequence is encoded beginning with the final
encoding state of the prior sequence.

@2@ For each {{rlp|escape|numeric escape sequence}}, given {{c|v}} as the integer value represented by the octal or hexadecimal number comprising the sequence of digits in the escape sequence, and {{tt|T}} as the string literal’s array element type (see the table [[#Info table|above]]):
* If {{c|v}} does not exceed the range of representable values of {{tt|T}}, then the escape sequence contributes a single code unit with value {{c|v}}.
* Otherwise, if{{rev inl|since=c++11| the string literal is of syntax {{v|1}} or {{v|3}}, and}} {{c|v}} does not exceed the range of representable values of the corresponding unsigned type for the underlying type of {{tt|T}}, then the escape sequence contributes a single code unit with a unique value of type {{tt|T}}, that is congruent to {{math|v mod 2{{su|p=S}}}}, where {{c|S}} is the width of {{tt|T}}.
* Otherwise, the program is ill-formed.
@@ If the associated character encoding is stateful, all such sequences have no effect on encoding state.

@3@ Each {{rlp|escape|conditional escape sequence}} contributes an implementation-defined code unit sequence.
@@ If the associated character encoding is stateful, it is implementation-defined what effect these sequences have on encoding state.

===Concatenation===
Adjacent string literals are concatenated at {{rlp|translation phases#Phase 6|translation phase 6}} (after preprocessing):

* If the two string literals are of the same [[#Explanation|kind]], the concatenated string literal is also of that kind.

{{rev begin}}
{{rev|until=c++11|
* If an ordinary string literal is adjacent to a wide string literal, the behavior is undefined.
}}
{{rev|since=c++11|
* If an ordinary string literal is adjacent to a non-ordinary string literal, the concatenated string literal is of the kind of the latter.
* If a UTF-8 string literal is adjacent to a wide string literal, the program is ill-formed.
{{rev begin}}
{{rev|until=c++23|
* Any other combination is conditionally supported with implementation-defined semantics.&lt;ref&gt;No known implementation supports such concatenation.&lt;/ref&gt;
}}
{{rev|since=c++23|
* Any other combination is ill-formed.
}}
{{rev end}}
}}
{{rev end}}

{{source|1=
"Hello, " " world!" // at phase 6, the 2 string literals form "Hello, world!"

L"Δx = %" PRId16    // at phase 4, PRId16 expands to "d"
                    // at phase 6, L"Δx = %" and "d" form L"Δx = %d"
}}

&lt;references/&gt;

===Unevaluated strings===
The following contexts expect a string literal, but do not evaluate it:
* {{rlp|language linkage}} specification
{{rev begin}}
{{rev|since=c++11|
* {{rlpt|static_assert}}
* {{rlp|user literal#Literal operators|literal operator}} name
}}
{{rev|since=c++14|
* {{attr|deprecated}}
}}
{{rev|since=c++20|
* {{attr|nodiscard}}
}}
{{rev|since=c++26|
* {{rlp|function#Deleted functions|deleted function body}}
}}
{{rev end}}


{{rev begin}}
{{rev|until=c++26|
It is unspecified whether non-ordinary string literals are allowed in these contexts{{rev inl|since=c++11|, except that a literal operator name must use an ordinary string literal}}.
}}
{{rev|since=c++26|
Only ordinary string literals are allowed in these contexts.

Each {{rlp|escape|universal character name}} and each {{rlp|escape|simple escape sequence}} in an unevaluated string is replaced by the member of the {{rlp|charset|translation character set}} it denotes. An unevaluated string that contains a numeric escape sequence or a conditional escape sequence is ill-formed.
}}
{{rev end}}

===Notes===
String literals can be used to {{rlp|aggregate initialization|initialize character arrays}}. If an array is initialized like {{c|1=char str[] = "foo";}}, {{c|str}} will contain a copy of the string {{c|"foo"}}.

{{rev begin}}
{{rev|until=c++11|
String literals are convertible and assignable to non-const {{c/core|char*}} or {{c/core|wchar_t*}} in order to be compatible with C, where string literals are of types {{c/core|char[N]}} and {{c/core|wchar_t[N]}}. Such implicit conversion is deprecated.
}}
{{rev|since=c++11|
String literals are not convertible or assignable to non-const {{tt|CharT*}}. An explicit cast (e.g. {{rlpt|const_cast}}) must be used if such conversion is wanted.
}}
{{rev end}}

A string literal is not necessarily a null-terminated character sequence: if a string literal has embedded null characters, it represents an array which contains more than one string.
{{source|1=
const char* p = "abc\0def"; // std::strlen(p) == 3, but the array has size 8
}}

If a valid hexadecimal digit follows a hexadecimal escape sequence in a string literal, it would fail to compile as an invalid escape sequence. String concatenation can be used as a workaround:
{{source|1=
//const char* p = "\xfff"; // error: hexadecimal escape sequence out of range
const char* p = "\xff""f"; // OK: the literal is const char[3] holding {'\xff','f','\0'}
}}

{{ftm begin|sort=yes}}
{{ftm|__cpp_char8_t|std=C++23|dr=20|value=202207L|{{c/core|char8_t}} compatibility and portability fix (allow {{rlp|aggregate initialization#Character arrays|initialization of ({{c/core|unsigned}}) {{c/core|char}} arrays}} from UTF-8 string literals)}}
{{ftm|__cpp_raw_strings|std=C++11|value=200710L|Raw string literals}}
{{ftm|__cpp_unicode_literals|std=C++11|value=200710L|Unicode string literals}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;iostream&gt;

// array1 and array2 contains the same values:
char array1[] = "Foo" "bar";
char array2[] = {'F', 'o', 'o', 'b', 'a', 'r', '\0'};

const char* s1 = R"foo(
Hello
  World
)foo";
// same as
const char* s2 = "\nHello\n  World\n";
// same as
const char* s3 = "\n"
                 "Hello\n"
                 "  World\n";

const wchar_t* s4 = L"ABC" L"DEF"; // OK, same as
const wchar_t* s5 = L"ABCDEF";
const char32_t* s6 = U"GHI" "JKL"; // OK, same as
const char32_t* s7 = U"GHIJKL";
const char16_t* s9 = "MN" u"OP" "QR"; // OK, same as
const char16_t* sA = u"MNOPQR";

// const auto* sB = u"Mixed" U"Types";
        // before C++23 may or may not be supported by
        // the implementation; ill-formed since C++23

const wchar_t* sC = LR"--(STUV)--"; // OK, raw string literal

int main()
{
    std::cout &lt;&lt; array1 &lt;&lt; ' ' &lt;&lt; array2 &lt;&lt; '\n'
              &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; s3 &lt;&lt; std::endl;
    std::wcout &lt;&lt; s4 &lt;&lt; ' ' &lt;&lt; s5 &lt;&lt; ' ' &lt;&lt; sC
               &lt;&lt; std::endl;
}
|output=
Foobar Foobar

Hello
  World

Hello
  World

Hello
  World

ABCDEF ABCDEF STUV
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=411|paper=P2029R4|std=C++98|before=escape sequences in string literals were&lt;br&gt;not allowed to map to multiple code units|after=allowed}}
{{dr list item|wg=cwg|dr=1656|paper=P2029R4|std=C++98|before=the characters denoted by numeric escape&lt;br&gt;sequences in string literals were unclear|after=made clear}}
{{dr list item|wg=cwg|dr=1759|std=C++11|before=a UTF-8 string literal might have code&lt;br&gt;units that are not representable in {{c/core|char}}|after={{c/core|char}} can represent all UTF-8 code units}}
{{dr list item|wg=cwg|dr=1823|std=C++98|before=whether string literals are distinct&lt;br&gt;was implementation-defined|after=distinctness is unspecified, and same&lt;br&gt;string literal can yield different object}}
{{dr list item|wg=cwg|dr=2333|paper=P2029R4|std=C++11|before=it was unclear whether numeric escape sequences&lt;br&gt;were allowed in UTF-8/16/32 string literals|after=made clear}}
{{dr list item|wg=cwg|dr=2870|std=C++11&lt;!-- the C++98 wording is “In translation phase 6, adjacent narrow string literals are concatenated and adjacent wide string literals
are concatenated.”, implying that concatenating ordinary string literals results in an ordinary string literal --&gt;|before=the concatenation result of two&lt;br&gt;ordinary string literals was unclear|after=made clear}}
{{dr list item|paper=P1854R4|std=C++98|before=ordinary and wide string literals with non-encodable&lt;br&gt;characters were conditionally-supported|after=programs with such literals are ill-formed}}
{{dr list item||paper=P2029R4|std=C++98|before=1. it was unclear whether string literals&lt;br&gt;{{nbsp|4}}could contain non-encodable characters&lt;br&gt;2. it was unclear whether string literals could&lt;br&gt;{{nbsp|4}}contain numeric escape sequences such&lt;br&gt;{{nbsp|4}}that the code units they represent are not&lt;br&gt;{{nbsp|4}}representable in the literals' array element type|after=1. made conditionally-supported for&lt;br&gt;{{nbsp|4}}ordinary and wide string literals&lt;ref&gt;P1854R4 was accepted as a DR later, overriding this resolution.&lt;/ref&gt;&lt;br&gt;2. ill-formed if the code units are&lt;br&gt;{{nbsp|4}}neither representable in the&lt;br&gt;{{nbsp|4}}unsigned integer type corresponding&lt;br&gt;{{nbsp|4}}to the underlying type}}
{{dr list end}}
&lt;references/&gt;

===References===
{{ref std c++23}}
{{ref std|section=5.13.5|title=String literals|id=lex.string}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=5.13.5|title=String literals|id=lex.string}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=5.13.5|title=String literals|id=lex.string}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=2.14.5|title=String literals|id=lex.string}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=2.14.5|title=String literals|id=lex.string}}
{{ref std end}}
{{ref std c++03}}
{{ref std|section=2.13.4|title=String literals|id=lex.string}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=2.13.4|title=String literals|id=lex.string}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc user literal}}
{{dsc see c|c/language/string literal|String literals|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}