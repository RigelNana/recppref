{{title|Class template}}
{{cpp/language/declarations/expressions/templates/navbar}}

A class template defines a family of classes.

===Syntax===
{{sdsc begin}}
{{sdsc|num=1|{{ttb|template}} {{ttb|&lt;}} {{spar|parameter-list}} {{ttb|&gt;}} {{spar|class-declaration}}}}
{{sdsc|num=2|notes={{mark since c++20}}|{{ttb|template}} {{ttb|&lt;}} {{spar|parameter-list}} {{ttb|&gt;}} {{ttb|requires}} {{spar|constraint}} {{spar|class-declaration}}}}
{{sdsc|num=3|{{ttb|export}} {{ttb|template}} {{ttb|&lt;}} {{spar|parameter-list}} {{ttb|&gt;}} {{spar|class-declaration}}|notes={{mark until c++11|removed=yes}}}}
{{sdsc end}}

===Explanation===
{{par begin}}
{{par|{{spar|class-declaration}}|a {{rlp|class|class declaration}}. The class name declared becomes a template name.}}
{{par|{{spar|parameter-list}}|a non-empty comma-separated list of the {{rlp|template parameters}}, each of which is either a [[cpp/language/template parameters#Non-type template parameter|non-type parameter]], a [[cpp/language/template parameters#Type template parameter|type parameter]], a [[cpp/language/template parameters#Template template parameter|template parameter]], or a [[cpp/language/parameter pack|parameter pack]] of any of those.}}
{{par|{{spar|constraint}}|a {{rlp|constraints|constraint expression}} which restricts the template parameters accepted by this class template}}
{{par end}}

{{rev begin}}
{{rev|until=c++11|{{tt|export}} was an optional modifier which declared the template as ''exported'' (when used with a class template, it declared all of its members exported as well). Files that instantiated exported templates did not need to include their definitions: the declaration was sufficient. Implementations of {{tt|export}} were rare and disagreed with each other on details.
}}
{{rev end}}

===Class template instantiation===
A class template by itself is not a type, or an object, or any other entity. No code is generated from a source file that contains only template definitions. In order for any code to appear, a template must be instantiated: the template arguments must be provided so that the compiler can generate an actual class (or function, from a function template).
====Explicit instantiation====
{{sdsc begin}}
{{sdsc|num=1|{{ttb|template}} {{spar|class-key}} {{spar|template-name}} {{ttb|&lt;}} {{spar|argument-list}} {{ttb|&gt;}} {{ttb|;}}}}
{{sdsc|num=2|{{ttb|extern}} {{ttb|template}} {{spar|class-key}} {{spar|template-name}} {{ttb|&lt;}} {{spar|argument-list}} {{ttb|&gt;}} {{ttb|;}}|notes={{mark since c++11}}}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|class-key}}|{{ttb|class}}, {{ttb|struct}} or {{ttb|union}}}}
{{par end}}

@1@ Explicit instantiation definition
@2@ Explicit instantiation declaration

An explicit instantiation definition forces instantiation of the class, struct, or union they refer to. It may appear in the program anywhere after the template definition, and for a given {{spar|argument-list}}, is only allowed to appear once in the entire program, no diagnostic required.

{{rrev|since=c++11|
An explicit instantiation declaration (an extern template) skips implicit instantiation step: the code that would otherwise cause an implicit instantiation instead uses the explicit instantiation definition provided elsewhere (resulting in link errors if no such instantiation exists). This can be used to reduce compilation times by explicitly declaring a template instantiation in all but one of the source files using it, and explicitly defining it in the remaining file.
}}

Classes, functions{{rev inl|since=c++14|, variables}}, and member template specializations can be explicitly instantiated from their templates. Member functions, member classes, and static data members of class templates can be explicitly instantiated from their member definitions.

Explicit instantiation can only appear in the enclosing namespace of the template, unless it uses qualified-id:
{{source|1=
namespace N
{
    template&lt;class T&gt;
    class Y // template definition
    {
        void mf() {}
    };
}

// template class Y&lt;int&gt;; // error: class template Y not visible in the global namespace
using N::Y;
// template class Y&lt;int&gt;; // error: explicit instantiation outside
                          // of the namespace of the template
template class N::Y&lt;char*&gt;;       // OK: explicit instantiation
template void N::Y&lt;double&gt;::mf(); // OK: explicit instantiation
}}

Explicit instantiation has no effect if an {{rlp|template specialization|explicit specialization}} appeared before for the same set of template arguments.

Only the declaration is required to be visible when explicitly instantiating a function template{{rev inl|since=c++14|, a variable template}}, a member function or static data member of a class template,
or a member function template. The complete definition must appear before the explicit instantiation of a class template, a member class of a class template, or a member class
template, unless an explicit specialization with the same template arguments appeared before.

If a function template{{rev inl|since=c++14|, variable template}}, member function template, or member function or static data member of a class template is explicitly instantiated with an explicit instantiation definition, the template definition must be present in the same translation unit.

When an explicit instantiation names a class template specialization, it serves as an explicit instantiation of the same kind (declaration or definition) of each of its non-inherited non-template members that has not been previously explicitly specialized in the translation unit. If this explicit instantiation is a definition, it is also an explicit instantiation definition only for the members that have been defined at this point.

Explicit instantiation definitions ignore member access specifiers: parameter types and return types may be private.

====Implicit instantiation====
When code refers to a template in context that requires a completely defined type, or when the completeness of the type affects the code, and this particular type has not been explicitly instantiated, implicit instantiation occurs. For example, when an object of this type is constructed, but not when a pointer to this type is constructed.

This applies to the members of the class template: unless the member is used in the program, it is not instantiated, and does not require a definition.

{{source|1=
template&lt;class T&gt;
struct Z // template definition
{
    void f() {}
    void g(); // never defined
};

template struct Z&lt;double&gt;; // explicit instantiation of Z&lt;double&gt;
Z&lt;int&gt; a;                  // implicit instantiation of Z&lt;int&gt;
Z&lt;char&gt;* p;                // nothing is instantiated here

p-&gt;f(); // implicit instantiation of Z&lt;char&gt; and Z&lt;char&gt;::f() occurs here.
        // Z&lt;char&gt;::g() is never needed and never instantiated:
        // it does not have to be defined
}}

If a class template has been declared, but not defined, at the point of instantiation, the instantiation yields an incomplete class type:
{{source|1=
template&lt;class T&gt;
class X;    // declaration, not definition

X&lt;char&gt; ch; // error: incomplete type X&lt;char&gt;
}}

{{rev begin}}
{{rev|since=c++17|
{{rlps|class#Local classes}} and any templates used in their members are instantiated as part of the instantiation of the entity within which the local class or enumeration is declared.}}
{{rev end}}

===Keywords===
{{rev inl|until=c++11|{{ltt|cpp/keyword/export}}}}{{rev inl|since=c++11|{{ltt|cpp/keyword/extern}}}}

===See also===
* {{rlp|template_parameters|template parameters and arguments}} allow templates to be parameterized
* {{rlp|function_template|function template declaration}} declares a function template
* {{rlp|template_specialization|template specialization}} defines an existing template for a specific type
* {{rlp|parameter_pack|parameter packs}} allows the use of lists of types in templates {{mark since c++11}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}