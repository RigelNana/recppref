{{title|Constant initialization}}
{{cpp/language/initialization/navbar}}
Sets the initial values of the {{rlp|storage duration|static}} variables to a compile-time constant.

===Explanation===
''Constant initialization'' is performed in the following cases:
{{rev begin}}
{{rev|until=c++11|
* Initializing a reference with {{rlpsd|storage duration#Static storage duration}} with a {{rlp|constant expression}}.

* Initializing an object of {{rlps|type#POD type}} with static storage duration with a constant expression.
}}

{{rev|since=c++11|until=c++17|
* Initializing a reference with {{rlp|storage duration#Static storage duration|static}} or {{rlp|storage duration#Thread storage duration|thread}} storage duration, where all following conditions are satisfied:
:* Each {{rlp|expressions#Full-expressions|full-expression}} (including implicit conversions) that appears in the initializer is a {{rlp|constant expression}}.
:* The reference is bound to one of the following entities:
::* an lvalue designating an object with static storage duration
::* a temporary object
::* a {{rlp|object#Subobjects|subobject}} of a temporary object&lt;!-- LWG 1834 --&gt;
::* a function

* Initializing an object with static or thread storage duration, and one of the following conditions is satisfied:
:* If the object is initialized by a constructor call, where the initialization full-expression is a constant expression, except that it may also invoke {{rlp|constexpr#constexpr constructor|{{c/core|constexpr}} constructors}} for the object and its subobjects (even if those objects are of non-{{rlp|constant expression#Literal types|literal}} class types).
:* Otherwise, either the object is {{rlp|value initialization|value-initialized}} or every full-expression that appears in its initializer is a constant expression.
}}

{{rev|since=c++17|until=c++20|
* Initializing a variable or temporary object with {{rlp|storage duration#Static storage duration|static}} or {{rlp|storage duration#Thread storage duration|thread}} storage duration by  an initializer whose {{rlp|expressions#Full-expressions|full-expression}} is a {{rlp|constant expression}}, except that if the entity being intialized is an object, such an initializer may also invoke {{rlp|constexpr#constexpr constructor|{{c/core|constexpr}} constructors}} for the object and its {{rlpsd|object#Subobjects}} (even if those objects are of non-{{rlp|constant expression#Literal types|literal}} class types).
}}

{{rev|since=c++20|
* A variable{{rev inl|until=c++26| or temporary object}} with {{rlp|storage duration#Static storage duration|static}} or {{rlp|storage duration#Thread storage duration|thread}} storage duration is {{rlp|constant expression#Constant-initialized entities|constant-initialized}}.
}}
{{rev end}}

The effects of constant initialization are the same as the effects of the corresponding initialization, except that it is guaranteed that it is complete before any other initialization of a static{{rev inl|since=c++11| or thread-local}} object begins.

===Notes===
The compiler is permitted to initialize other static{{rev inl|since=c++11| and thread-local}} objects using constant initialization, if it can guarantee that the value would be the same as if the standard order of initialization was followed.

Constant initialization usually happens when the program loads into memory, as part of initializing the program's runtime environment.

===Example===
{{example
|
|code=
#include &lt;iostream&gt;
#include &lt;array&gt;

struct S
{
    static const int c;
};

const int d = 10 * S::c; // not a constant expression: S::c has no preceding
                         // initializer, this initialization happens after const
const int S::c = 5;      // constant initialization, guaranteed to happen first

int main()
{
    std::cout &lt;&lt; "d = " &lt;&lt; d &lt;&lt; '\n';
    std::array&lt;int, S::c&gt; a1; // OK: S::c is a constant expression
//  std::array&lt;int, d&gt; a2;    // error: d is not a constant expression
}
|output=
d = 50
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=441|std=C++98|before=references could not be constant initialized|after=made constant initializable}}
{{dr list item|wg=cwg|dr=1489|std=C++11|before=it was unclear whether value-initializing&lt;br&gt;an object can be a constant initialization|after=it can}}
{{dr list item|wg=cwg|dr=1747|std=C++11|before=binding a reference to a function could not be constant initialization|after=it can}}
{{dr list item|wg=cwg|dr=1834|std=C++11|before=binding a reference to an xvalue could not be constant initialization|after=it can}}
{{dr list end}}

===See also===
* {{rlpt|constinit}}
* {{rlpt|constexpr}}
* {{rlp|constructor}}
* {{rlp|converting constructor}}
* {{rlp|copy constructor}}
* {{rlp|default constructor}}
* {{rlpt|explicit}}
* {{rlp|initialization}}
** {{rlp|aggregate initialization}}
** {{rlp|copy initialization}}
** {{rlp|default initialization}}
** {{rlp|direct initialization}}
** {{rlp|list initialization}}
** {{rlp|reference initialization}}
** {{rlp|value initialization}}
** {{rlp|zero initialization}}
* {{rlp|move constructor}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}