{{title|Explicit type conversion}}
{{cpp/language/expressions/navbar}}
Converts between types using a combination of explicit and implicit conversions.

===Syntax===
{{sdsc begin}}
{{sdsc|num=1|{{ttb|(}} {{spar|type-id}} {{ttb|)}} {{spar|unary-expression}}}} 
{{sdsc|num=2|{{spar|simple-type-specifier}} {{ttb|(}} {{spar optional|expression-list}} {{ttb|)}}&lt;br&gt;{{spar|simple-type-specifier}} {{ttb|(}} {{spar optional|initializer-list}} {{ttb|)}}|notes={{mark until c++11}}&lt;br&gt;{{mark since c++11}}}} 
{{sdsc|num=3|{{spar|simple-type-specifier}} {{ttb|{}} {{spar optional|initializer-list}} {{ttb|}&lt;!----&gt;}}|notes={{mark since c++11}}}}
{{sdsc|num=4|{{spar|simple-type-specifier}} {{ttb|{}} {{spar|designated-initializer-list}} {{ttb|}&lt;!----&gt;}}|notes={{mark since c++20}}}}
{{sdsc|num=5|{{ttb|typename}} {{spar|identifier}} {{ttb|(}} {{spar optional|initializer-list}} {{ttb|)}}|notes={{mark since c++11}}}}
{{sdsc|num=6|{{ttb|typename}} {{spar|identifier}} {{ttb|{}} {{spar optional|initializer-list}} {{ttb|}&lt;!----&gt;}}|notes={{mark since c++11}}}}
{{sdsc|num=7|{{ttb|typename}} {{spar|identifier}} {{ttb|{}} {{spar|designated-initializer-list}} {{ttb|}&lt;!----&gt;}}|notes={{mark since c++20}}}}
{{sdsc end}}

Explicitly converts any number of values to a value of the target type.
@1@ Explicit type conversion (cast notation), also called ''C-style cast''.
@2-7@ Explicit type conversion (functional notation), also called ''function-style cast''.

{{par begin}}
{{par|{{spar|type-id}}|a {{rlp|type#Type naming|type-id}}}}
{{par|{{spar|unary-expression}}|an unary expression (whose top-level operator does not have a {{rlp|operator precedence|precedence}} higher than that of C-style cast)}}
{{par|{{spar|simple-type-specifier}}|a {{rlp|declarations#Specifiers|simple type specifier}}}}
{{par|{{spar|expression-list}}|a comma-separated list of expressions (except unparenthesized {{rlp|operator other#Built-in comma operator|comma expressions}})}}
{{par|{{spar|initializer-list}}|a comma-separated list of {{rlp|initialization|initializer clauses}}}}
{{par|{{spar|designated-initializer-list}}|a comma-separated list of {{rlp|aggregate initialization#Designated initializers|designated initializer clauses}}}}
{{par|{{spar|identifier}}|a (possibly qualified) identifier (including {{rlpsd|templates#Template identifiers}})}}
{{par end}}

===Explanation===
@1@ When the C-style cast is encountered, the compiler attempts to interpret it as the following cast expressions, in this order:
:@a@ {{box|{{rlpt|const_cast}}{{c/core|&lt;}}{{spar sep|type-id}}{{c/core|&gt;(}}{{spar sep|unary-expression}}{{c/core|)}}}};
:@b@ {{box|{{rlpt|static_cast}}{{c/core|&lt;}}{{spar sep|type-id}}{{c/core|&gt;(}}{{spar sep|unary-expression}}{{c/core|)}}}}, with extensions: pointer or reference to a {{rlp|derived class}} is additionally allowed to be cast to pointer or reference to unambiguous base class (and vice versa) even if the base class is {{rlp|access|inaccessible}} (that is, this cast ignores the private inheritance specifier). Same applies to casting {{rlp|pointer|pointer to member}} to pointer to member of unambiguous non-virtual base;
:@c@ a {{c/core|static_cast}} (with extensions) followed by {{c/core|const_cast}};
:@d@ {{box|{{rlpt|reinterpret_cast}}{{c/core|&lt;}}{{spar sep|type-id}}{{c/core|&gt;(}}{{spar sep|unary-expression}}{{c/core|)}}}};
:@e@ a {{c/core|reinterpret_cast}} followed by {{c/core|const_cast}}.
@@ The first choice that satisfies the requirements of the respective cast operator is selected, even if it is ill-formed (see example). If a {{c/core|static_cast}} followed by a {{c/core|const_cast}} is used and the conversion can be interpreted in more than one way as such, the conversion is ill-formed.
@@ In addition, C-style casts can cast from, to, and between pointers to incomplete class type. If both {{spar|type-id}} and the type of {{spar|unary-expression}} are pointers to incomplete class types, it is unspecified whether {{c/core|static_cast}} or {{c/core|reinterpret_cast}} gets selected.

@2-7@ A function-style cast specifies a '''type''' ({{spar sep|simple-type-specifier}}{{rev inl|since=c++11| or {{spar sep|identifier}}}}) and an '''initializer''' (the remaining parts), it constructs a value of the target type {{tt|T}}, which is determined from the specified type{{rev inl|since=c++17| and initializer}}:
{{rev begin}}
{{rev|until=c++17|
{{tt|T}} is the specified type.
}}
{{rev|since=c++17|
{{tt|T}} is determined as follows:
* If the specified type is a placeholder for a deduced class type, {{tt|T}} is the return type of the function selected by overload resolution for {{rlp|class template argument deduction|class template deduction}}.
{{rrev|since=c++23|
* Otherwise, if the specified type contains a {{rlp|auto|placeholder type}}, {{tt|T}} is the deduced type.
}}
* Otherwise, {{tt|T}} is the specified type.
}}
{{rev end}}

@@ The conversion result is determined as follows:
* If the function-style cast is of syntax {{v|2}}, and there is exactly one expression in parentheses, this cast is equivalent to the corresponding C-style cast.
* Otherwise, if {{tt|T}} is (possibly cv-qualified) {{c/core|void}}, the result is {{rev inl|until=c++11|an rvalue}}{{rev inl|since=c++11|a prvalue}} of type {{c/core|void}} that performs no initialization.
{{rev begin}}
{{rev|until=c++11|
:* If the initializer is not {{c|()}}, the program is ill-formed.
}}
{{rev|since=c++11|
:* If the initializer is not {{c|()}} or {{c|{}&lt;!----&gt;}} after {{rlp|pack|pack expansion}} (if any), the program is ill-formed.
}}
{{rev end}}
* Otherwise, if {{tt|T}} is a reference type, the function-style cast has the same effect as {{rlp|direct initialization|direct-initializing}} an invented variable {{c|t}} of type {{tt|T}} from the specified initializer, and the result is the initialized {{c|t}}.
{{rev begin}}
{{rev|until=c++11|
:* The result is an lvalue.
}}
{{rev|since=c++11|
:* If {{tt|T}} is an lvalue reference type or an rvalue reference to function type, the result is an lvalue.
:* Otherwise, the result is an xvalue.
}}
{{rev end}}
* Otherwise, the result is {{rev inl|until=c++11|an rvalue}}{{rev inl|since=c++11|a prvalue}} of of type {{tt|T}} {{rev inl|until=c++17|designating a temporary}}{{rev inl|since=c++17|whose result object is}} {{rlp|direct initialization|direct-initialized}} with the specified initializer.

===Ambiguity Resolution===
====Ambiguous declaration statement====
In the case of an ambiguity between an expression statement with a function-style cast expression as its leftmost subexpression and a declaration statement, the ambiguity is resolved by treating it as a declaration. This disambiguation is purely syntactic: it does not consider the meaning of names occurring in the statement other than whether they are type names:
{{source|
struct M {};
struct L { L(M&amp;); };
 
M n;
void f()
{
    M(m);    // declaration, equivalent to M m;
    L(n);    // ill-formed declaration, equivalent to L n;
    L(l)(m); // still a declaration, equivalent to L l((m));
}
}}

{{rrev|since=c++11|
However, if the outermost declarator in the ambiguous declaration statement has a {{rlp|function|trailing return type}}, the statement will only be treated as a declaration statement if the trailing return type starts with {{c/core|auto}}:
{{source|
struct M;

struct S
{
    S* operator()();
    int N;
    int M;
    
    void mem(S s)
    {
        auto(s)()-&gt;M; // expression (S::M hides ::M), invalid before C++23
    }
};

void f(S s)
{
    {
        auto(s)()-&gt;N; // expression, invalid before C++23
        auto(s)()-&gt;M; // function declaration, equivalent to M s();
    }
    {
        S(s)()-&gt;N;    // expression
        S(s)()-&gt;M;    // expression
    }
}
}}
}}

====Ambiguous function parameter====
The ambiguity above can also occur in the context of a declaration. In that context, the choice is between an object declaration with a function-style cast as the initializer and a declaration involving a function declarator with a redundant set of parentheses around a parameter name. The resolution is also to consider any construct, such as the potential parameter declaration, that could possibly be a declaration to be a declaration:
{{source|1=
struct S
{
    S(int);
};

void foo(double a)
{
    S w(int(a)); // function declaration: has a parameter `a` of type int
    S x(int());  // function declaration: has an unnamed parameter of type int(*)() 
                 // that is adjusted from int()
    
    // Ways to avoid ambiguity:
    S y((int(a))); // object declaration: extra pair of parentheses
    S y((int)a);   // object declaration: C-style cast
    S z = int(a);  // object declaration: no ambiguity for this syntax
}
}}

{{rrev|since=c++11|
However, if the outermost declarator in the ambiguous parameter declaration has a {{rlp|function|trailing return type}}, the ambiguity will only be resolved by treating it as a declaration if it starts with {{c/core|auto}}:
{{source|
typedef struct BB { int C[2]; } *B, C;

void foo()
{
    S a(B()-&gt;C);    // object declaration: B()-&gt;C cannot declare a parameter
    S b(auto()-&gt;C); // function declaration: has an unnamed parameter of type C(*)()
                    // that is adjusted from C()
}
}}
}}

====Ambiguous type-id====
An ambiguity can arise from the similarity between a function-style cast and a {{rlp|type#Type naming|type-id}}. The resolution is that any construct that could possibly be a type-id in its syntactic context shall be considered a type-id:
{{source|
// `int()` and `int(unsigned(a))` can both be parsed as type-id:
// `int()`            represents a function returning int
//                    and taking no argument
// `int(unsigned(a))` represents a function returning int
//                    and taking an argument of type unsigned
void foo(signed char a)
{
    sizeof(int());            // type-id (ill-formed)
    sizeof(int(a));           // expression
    sizeof(int(unsigned(a))); // type-id (ill-formed)
    
    (int()) + 1;            // type-id (ill-formed)
    (int(a)) + 1;           // expression
    (int(unsigned(a))) + 1; // type-id (ill-formed)
}
}}

{{rrev|since=c++11|
However, if the outermost {{spar|abstract-declarator}} in the ambiguous {{rlp|type#Type naming|type-id}} has a {{rlp|function|trailing return type}}, the ambiguity will only be resolved by treating it as a type-id if it starts with {{c/core|auto}}:
{{source|
typedef struct BB { int C[2]; } *B, C;

void foo()
{
    sizeof(B()-&gt;C[1]);    // OK, sizeof(expression)
    sizeof(auto()-&gt;C[1]); // error: sizeof of a function returning an array
}
}}
}}

===Notes===
{{feature test macro|__cpp_auto_cast|{{c|auto(x)}} and {{c|auto{x}&lt;!----&gt;}}|value=202110L|std=C++23}}

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iostream&gt;

double f = 3.14;
unsigned int n1 = (unsigned int)f; // C-style cast
unsigned int n2 = unsigned(f);     // function-style cast

class C1;
class C2;
C2* foo(C1* p)
{
    return (C2*)p; // casts incomplete type to incomplete type
}

void cpp23_decay_copy_demo()
{
    auto inc_print = [](int&amp; x, const int&amp; y)
    {
        ++x;
        std::cout &lt;&lt; "x:" &lt;&lt; x &lt;&lt; ", y:" &lt;&lt; y &lt;&lt; '\n';
    };
    
    int p{1};
    inc_print(p, p); // prints x:2 y:2, because param y here is an alias of p
    int q{1};
    inc_print(q, auto{q}); // prints x:2 y:1, auto{q} (C++23) casts to prvalue,
                           // so the param y is a copy of q (not an alias of q)
}

// In this example, C-style cast is interpreted as static_cast
// even though it would work as reinterpret_cast
struct A {};
struct I1 : A {};
struct I2 : A {};
struct D : I1, I2 {};

int main()
{
    D* d = nullptr;
//  A* a = (A*)d;                   // compile-time error
    A* a = reinterpret_cast&lt;A*&gt;(d); // this compiles
    assert(a == nullptr);
    
    cpp23_decay_copy_demo();
}
|output=
x:2 y:2
x:2 y:1
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1223|paper=P2915R0|std=C++11|before=the addition of trailing return type introduced more ambiguities|after=resolves them}}
{{dr list item|wg=cwg|dr=1893|std=C++11|before=function-style cast did not consider pack expansions|after=considers them}}
{{dr list item|wg=cwg|dr=2351|std=C++11|before={{c|void{}&lt;!----&gt;}} was ill-formed|after=made well-formed}}
{{dr list item|wg=cwg|dr=2620|std=C++98|before=the resolution of ambiguous function&lt;br&gt;parameters might be misinterpreted|after=improved the wording}}
{{dr list item|wg=cwg|dr=2828|std=C++98|before=a C-style cast was ill-formed if multiple interpretations&lt;br&gt;of a {{c/core|static_cast}} followed by a {{c/core|const_cast}} exist,&lt;br&gt;regardless of whether these conversions are actually used|after=only considers the&lt;br&gt;conversions&lt;br&gt;possibly being used}}
{{dr list item|wg=cwg|dr=2894|std=C++98|before=function-style casts could create reference rvalues|after=can only create reference lvalues}}
{{dr list end}}

===References===
{{ref std c++23}}
{{ref std|section=7.6.1.4|title=Explicit type conversion (functional notation)|id=expr.type.conv}}
{{ref std|section=7.6.3|title=Explicit type conversion (cast notation)|id=expr.cast}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=7.6.1.4|title=Explicit type conversion (functional notation)|id=expr.type.conv}}
{{ref std|section=7.6.3|title=Explicit type conversion (cast notation)|id=expr.cast}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=8.2.3|title=Explicit type conversion (functional notation)|id=expr.type.conv}}
{{ref std|section=8.4|title=Explicit type conversion (cast notation)|id=expr.cast}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=5.2.3|title=Explicit type conversion (functional notation)|id=expr.type.conv}}
{{ref std|section=5.4|title=Explicit type conversion (cast notation)|id=expr.cast}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=5.2.3|title=Explicit type conversion (functional notation)|id=expr.type.conv}}
{{ref std|section=5.4|title=Explicit type conversion (cast notation)|id=expr.cast}}
{{ref std end}}
{{ref std c++03}}
{{ref std|section=5.2.3|title=Explicit type conversion (functional notation)|id=expr.type.conv}}
{{ref std|section=5.4|title=Explicit type conversion (cast notation)|id=expr.cast}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=5.2.3|title=Explicit type conversion (functional notation)|id=expr.type.conv}}
{{ref std|section=5.4|title=Explicit type conversion (cast notation)|id=expr.cast}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc const_cast}}
{{dsc inc|cpp/language/dsc static_cast}}
{{dsc inc|cpp/language/dsc dynamic_cast}}
{{dsc inc|cpp/language/dsc reinterpret_cast}}
{{dsc inc|cpp/language/dsc implicit cast}}
{{dsc see c|c/language/cast|cast operator|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}