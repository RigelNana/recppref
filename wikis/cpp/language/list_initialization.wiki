{{title|List-initialization {{mark since c++11}}}}
{{cpp/language/initialization/navbar}}

Initializes an object from a {{rlp|initialization|brace-enclosed initializer list}}.

===Syntax===
====Direct-list-initialization====
{{sdsc begin}}
{{sdsc|num=1|
{{spar|T object}} {{ttb|{}} {{spar|arg1, arg2, ...}} {{ttb|};}}
{{rrev|since=c++20|
{{spar|T object}}{{ttb|{.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|};}}
}}
}}

{{sdsc|num=2|
{{spar|T}} {{ttb|{}} {{spar|arg1, arg2, ...}} {{ttb|}&lt;!----&gt;}}
{{rrev|since=c++20|
{{spar|T}} {{ttb|{.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|}&lt;!----&gt;}}
}}
}}

{{sdsc|num=3|
{{ttb|new}} {{spar|T}} {{ttb|{}} {{spar|arg1, arg2, ...}} {{ttb|}&lt;!----&gt;}}
{{rrev|since=c++20|
{{ttb|new}} {{spar|T}} {{ttb|{.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|}&lt;!----&gt;}}
}}
}}

{{sdsc|num=4|
{{spar|Class}} {{ttb|{}} {{spar|T member}} {{ttb|{}} {{spar|arg1, arg2, ...}} {{ttb|}; };}}
{{rrev|since=c++20|
{{spar|Class}} {{ttb|{}} {{spar|T member}} {{ttb|{.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|}; };}}
}}
}}

{{sdsc|num=5|
{{spar|Class}}{{ttb|::}}{{spar|Class}}{{ttb|() :}} {{spar|member}} {{ttb|{}} {{spar|arg1, arg2, ...}} {{ttb|} {...}}
{{rrev|since=c++20|
{{spar|Class}}{{ttb|::}}{{spar|Class}}{{ttb|() :}} {{spar|member}} {{ttb|{.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!----&gt;}} {{spar|...}}{{ttb|} {...}}
}}
}}
{{sdsc end}}

====Copy-list-initialization====
{{sdsc begin}}
{{sdsc|num=6|
{{spar|T object}} {{ttb|1== {}} {{spar|arg1, arg2, ...}} {{ttb|};}}

{{rrev|since=c++20|
{{spar|T object}} {{ttb|1== {.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|};}}
}}
}}

{{sdsc|num=7|
{{spar|function}} {{ttb|({}} {{spar|arg1, arg2, ...}} {{ttb|})}}
{{rrev|since=c++20|
{{spar|function}} {{ttb|({.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|})}}
}}
}}

{{sdsc|num=8|
{{ttb|return {}} {{spar|arg1, arg2, ...}} {{ttb|};}}
{{rrev|since=c++20|
{{ttb|return }}{{ttb|{.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|};}}
}}
}}

{{sdsc|num=9|
{{spar|object}} {{ttb|[{}} {{spar|arg1, arg2, ...}} {{ttb|}]}}
{{rrev|since=c++20|
{{spar|object}} {{ttb|[{.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|}]}}
}}
}}

{{sdsc|num=10|
{{spar|object}} {{ttb|1== {}} {{spar|arg1, arg2, ...}} {{ttb|}&lt;!----&gt;}}
{{rrev|since=c++20|
{{spar|object}} {{ttb|1== {.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|}&lt;!----&gt;}}
}}
}}

{{sdsc|num=11|
{{spar|U}} {{ttb|({}} {{spar|arg1, arg2, ...}} {{ttb|})}}
{{rrev|since=c++20|
{{spar|U}} {{ttb|({.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|})}}
}}
}}

{{sdsc|num=12|
{{spar|Class}} {{ttb|{}} {{spar|T member}} {{ttb|1== {}} {{spar|arg1, arg2, ...}} {{ttb|}; };}}
{{rrev|since=c++20|
{{spar|Class}} {{ttb|{}} {{spar|T member}} {{ttb|1== {.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!----&gt;}} {{spar|...}} {{ttb|}; };}}
}}
}}
{{sdsc end}}

List initialization is performed in the following situations:
* direct-list-initialization (both explicit and non-explicit constructors are considered)

@1@ initialization of a named variable with a brace-enclosed initializer list
@2@ initialization of an unnamed temporary with a brace-enclosed initializer list
@3@ initialization of an object with dynamic storage duration with a {{rlp|new|new-expression}}, where the initializer is a brace-enclosed initializer list
@4@ in a non-static {{rlp|data members#Member initialization|data member initializer}} that does not use the equals sign
@5@ in a {{rlp|initializer list|member initializer list}} of a constructor if a brace-enclosed initializer list is used

* copy-list-initialization (both explicit and non-explicit constructors are considered, but only non-explicit constructors may be called)

@6@ initialization of a named variable with a brace-enclosed initializer list after an equals sign
@7@ in a function call expression, with a brace-enclosed initializer list used as an argument and list-initialization initializes the function parameter
@8@ in a {{c/core|return}} statement with a brace-enclosed initializer list used as the return expression and list-initialization initializes the returned object
@9@ in a {{rlp|operator member access#Built-in subscript operator|subscript expression}} with a user-defined {{tt|operator[]}}, where list-initialization initializes the parameter of the overloaded operator
@10@ in an {{rlp|operator assignment|assignment expression}}, where list-initialization initializes the parameter of the overloaded operator
@11@ {{rlp|explicit cast|functional cast expression}} or other constructor invocations, where a brace-enclosed initializer list is used in place of a constructor argument. Copy-list-initialization initializes the constructor's parameter (note; the type {{tt|U}} in this example is not the type that is being list-initialized; {{tt|U}}'s constructor's parameter is)
@12@ in a non-static {{rlp|data members#Member initialization|data member initializer}} that uses the equals sign

===Explanation===
The effects of list-initialization of an object of type (possibly cv-qualified) {{tt|T}} are:
{{rrev|since=c++20|
* If the brace-enclosed initializer list contains a {{rlp|aggregate initialization#Designated initializers|designated initializer list}} and {{tt|T}} is not a reference type, {{tt|T}} must be an aggregate class. The ordered identifiers in the designators of the designated initializer list must form a subsequence of the ordered identifiers in the direct non-static data members of {{tt|T}}. {{rlp|aggregate initialization|Aggregate initialization}} is performed.
}}
* If {{tt|T}} is an aggregate class and the brace-enclosed initializer list{{rev inl|since=c++20|, which does not contain a designated initializer list,}} has a single initializer clause of the same or derived type (possibly cv-qualified), the object is initialized from that initializer clause (by {{rlp|copy initialization|copy-initialization}} for copy-list-initialization, or by {{rlp|direct initialization|direct-initialization}} for direct-list-initialization).
* Otherwise, if {{tt|T}} is a character array and the brace-enclosed initializer list has a single initializer clause that is an appropriately-typed string literal, the array is  {{rlp|aggregate initialization#Character arrays|initialized from the string literal as usual}}.

* Otherwise, if {{tt|T}} is an {{rlp|aggregate initialization|aggregate type}}, {{rlp|aggregate initialization}} is performed.

* Otherwise, if the brace-enclosed initializer list is empty and {{tt|T}} is a class type with a default constructor, {{rlp|value initialization|value-initialization}} is performed.

* Otherwise, if {{tt|T}} is a specialization of {{lc|std::initializer_list}}, the object is initialized as described [[#List-initializing std::initializer_list|below]].

* Otherwise, if {{tt|T}} is a class type, the constructors of {{tt|T}} are considered, in two phases:

:* All constructors that take {{lc|std::initializer_list}} as the only argument, or as the first argument if the remaining arguments have default values, are examined, and matched by {{rlp|overload resolution}} against a single argument of type {{lc|std::initializer_list}}.

:* If the previous stage does not produce a match, all constructors of {{tt|T}} participate in {{rlp|overload resolution#Implicit conversion sequence in list-initialization|overload resolution}} against the set of arguments that consists of the initializer clauses of the brace-enclosed initializer list, with the restriction that only non-narrowing conversions are allowed. If this stage produces an explicit constructor as the best match for a copy-list-initialization, compilation fails (note, in simple copy-initialization, explicit constructors are not considered at all).

{{rrev|since=c++17|
* Otherwise, if {{tt|T}} is an {{rlp|enum|enumeration type}} that with fixed underlying type {{tt|U}}, the brace-enclosed initializer list has only one initializer {{c|v}}, and all following conditions are satisfied, then the enumeration is initialized with the result of converting {{c|v}} to {{tt|U}}:
** The initialization is direct-list-initialization.
** {{c|v}} is of [[cpp/named req/ScalarType|scalar type]].
** {{c|v}} is implicitly convertible to {{tt|U}}.
** The conversion from {{c|v}} to {{tt|U}} is non-narrowing.
}}

* Otherwise (if {{tt|T}} is not a class type), if the brace-enclosed initializer list has only one initializer clause and either {{tt|T}} is not a reference type or is a reference type whose referenced type is same as or is a base class of the type of the initializer clause, {{tt|T}} is {{rlp|direct initialization|direct-initialized}} (in direct-list-initialization) or {{rlp|copy initialization|copy-initialized}} (in copy-list-initialization), except that narrowing conversions are not allowed.

* Otherwise, if {{tt|T}} is a reference type that is not compatible with the type of the initializer clause:
{{rev begin}}
{{rev|until=c++17|
:* a prvalue temporary of the type referenced by {{tt|T}} is copy-list-initialized, and the reference is bound to that temporary (this fails if the reference is a non-const lvalue reference).
}}
{{rev|since=c++17|
:* a prvalue is generated. The prvalue initializes its result object by copy-list-initialization. The prvalue is then used to direct-initialize the reference (this fails if the reference is a non-const lvalue reference). The type of the temporary is the type referenced by {{tt|T}}{{rev inl|since=c++20|, unless {{tt|T}} is “reference to array of unknown bound of {{tt|U}}”, in which case the type of the temporary is the type of {{c|x}} in the declaration {{c|U x[] H}}, where {{tt|H}} is the initializer list}}.
}}
{{rev end}}

* Otherwise, if the brace-enclosed initializer list has no initializer clause, {{tt|T}} is {{rlp|value initialization|value-initialized}}.

{{anchor|List-initializing std::initializer_list}}
===List-initializing {{lc|std::initializer_list}}===
An object of type {{c/core|std::initializer_list&lt;E&gt;}} is constructed from an initializer list as if the compiler generated{{rev inl|since=c++17| and {{rlp|implicit conversion#Temporary materialization|materialized}}}} a {{rlp|value category|prvalue}} of type “array of {{c|N}} {{c/core|const E}}”, where {{c|N}} is the number of initializer clauses in the initializer list; this is called the initializer list’s ''backing array''.

Each element of the backing array is {{rlp|copy initialization|copy-initialized}} with the corresponding initializer clause of the initializer list, and the {{c/core|std::initializer_list&lt;E&gt;}} object is constructed to refer to that array. A constructor or conversion function selected for the copy is required to be {{rlp|access|accessible}} in the context of the initializer list. If a narrowing conversion is required to initialize any of the elements, the program is ill-formed.

The backing array has the same lifetime as any other {{rlp|lifetime#Temporary object lifetime|temporary object}}, except that initializing an {{lc|std::initializer_list}} object from the backing array extends the lifetime of the array exactly like {{rlp|reference initialization#Lifetime of a temporary|binding a reference to a temporary}}.
{{source|1=
void f(std::initializer_list&lt;double&gt; il);

void g(float x)
{
   f({1, x, 3});
}

void h()
{
   f({1, 2, 3});
}

struct A { mutable int i; };

void q(std::initializer_list&lt;A&gt;);

void r()
{
    q({A{1}, A{2}, A{3}&lt;!----&gt;});
}

// The initialization above will be implemented in a way roughly equivalent to below,
// assuming that the compiler can construct an initializer_list object with a pair of
// pointers, and with the understanding that `__b` does not outlive the call to `f`.

void g(float x)
{
    const double __a[3] = {double{1}, double{x}, double{3}&lt;!----&gt;}; // backing array
    f(std::initializer_list&lt;double&gt;(__a, __a + 3));
}

void h()
{
    static constexpr double __b[3] =
        {double{1}, double{2}, double{3}&lt;!----&gt;}; // backing array
    f(std::initializer_list&lt;double&gt;(__b, __b + 3));
}

void r()
{
    const A __c[3] = {A{1}, A{2}, A{3}&lt;!----&gt;}; // backing array
    q(std::initializer_list&lt;A&gt;(__c, __c + 3));
}
}}

Whether all backing arrays are distinct (that is, are stored in {{rlp|object#Subobjects|non-overlapping objects}}) is unspecified:
{{source|1=
bool fun(std::initializer_list&lt;int&gt; il1, std::initializer_list&lt;int&gt; il2)
{
    return il2.begin() == il1.begin() + 1;
}

bool overlapping = fun({1, 2, 3}, {2, 3, 4}); // the result is unspecified:
                                              // the back arrays can share
                                              // storage within {1, 2, 3, 4}
}}

===Narrowing conversions===
List-initialization limits the allowed {{rlp|implicit conversion}}s by prohibiting the following:

* conversion from a floating-point type to an integer type

* conversion from a floating-point type {{tt|T}} to another floating-point type whose {{rlpsd|usual arithmetic conversions#Floating-point conversion rank}} is neither greater than nor equal to that of {{tt|T}}, except where the conversion result is a {{rlp|constant expression}} and one of the following conditions is satisfied:
** The converted value is finite, and the conversion does not overflow.
** The values before and after the conversion are not finite.

* conversion from an integer type to a floating-point type, except where the source is a constant expression whose value can be stored exactly in the target type

* conversion from integer or unscoped enumeration type to integer type that cannot represent all values of the original, except where
** the source is a {{rlp|bit field|bit-field}} whose width {{c|w}} is less than that of its type (or, for an {{rlp|enum|enumeration type}}, its underlying type) and the target type can represent all the values of a hypothetical extended integer type with width {{c|w}} and with the same signedness as the original type, or
** the source is a constant expression whose value can be stored exactly in the target type

* conversion from a pointer type or pointer-to-member type to {{c/core|bool}}

===Notes===
Every initializer clause is {{rlp|eval order|sequenced before}} any initializer clause that follows it in the brace-enclosed initializer list. This is in contrast with the arguments of a {{rlp|operator other#Built-in function call operator|function call expression}}, which are {{rev inl|until=c++17|{{rlp|eval order|unsequenced}}}}{{rev inl|since=c++17|{{rlp|eval order|indeterminately sequenced}}}}.

A brace-enclosed initializer list is not an expression and therefore has no type, e.g. {{c/core|decltype({1, 2})}} is ill-formed. Having no type implies that template type deduction cannot deduce a type that matches a brace-enclosed initializer list, so given the declaration {{c|template&lt;class T&gt; void f(T);}} the expression {{c|f({1, 2, 3})}} is ill-formed. However, the template parameter can otherwise be deduced, as is the case for {{c|std::vector&lt;int&gt; v(std::istream_iterator&lt;int&gt;(std::cin), {})}}, where the iterator type is deduced by the first argument but also used in the second parameter position. A special exception is made for {{rlp|template argument deduction#Other contexts|type deduction using the keyword {{c/core|auto}}}}, which deduces any brace-enclosed initializer list as {{lc|std::initializer_list}} in copy-list-initialization.

Also because a brace-enclosed initializer list has no type, {{rlp|overload resolution#Implicit conversion sequence in list-initialization|special rules for overload resolution}} apply when it is used as an argument to an overloaded function call.

Aggregates copy/move initialize directly from brace-enclosed initializer list of a single initializer clause of the same type, but non-aggregates consider {{lc|std::initializer_list}} constructors first:
{{source|1=
struct X {}; // aggregate

struct Q     // non-aggregate
{
    Q() = default;
    Q(Q const&amp;) = default;
    Q(std::initializer_list&lt;Q&gt;) {}
};

int main()
{
    X x;
    X x2 = X{x}; // copy-constructor (not aggregate initialization)
    
    Q q;
    Q q2 = Q{q}; // initializer-list constructor (not copy constructor)
}
}}

Some compilers (e.g., gcc 10) only consider conversion from a pointer or a pointer-to-member to {{c/core|bool}} narrowing in C++20 mode.

{{feature test macro|std=C++11|value=200806L|__cpp_initializer_lists|List-initialization and {{lc|std::initializer_list}}}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

struct Foo
{
    std::vector&lt;int&gt; mem = {1, 2, 3}; // list-initialization of a non-static member
    std::vector&lt;int&gt; mem2;
    
    Foo() : mem2{-1, -2, -3} {} // list-initialization of a member in constructor
};

std::pair&lt;std::string, std::string&gt; f(std::pair&lt;std::string, std::string&gt; p)
{
    return {p.second, p.first}; // list-initialization in return statement
}

int main()
{
    int n0{};  // value-initialization (to zero)
    int n1{1}; // direct-list-initialization
    
    std::string s1{'a', 'b', 'c', 'd'}; // initializer-list constructor call
    std::string s2{s1, 2, 2};           // regular constructor call
    std::string s3{0x61, 'a'}; // initializer-list ctor is preferred to (int, char)
    
    int n2 = {1}; // copy-list-initialization
    double d = double{1.2}; // list-initialization of a prvalue, then copy-init
    auto s4 = std::string{"HelloWorld"}; // same as above, no temporary
                                         // created since C++17
    
    std::map&lt;int, std::string&gt; m = // nested list-initialization
    {
        {1, "a"},
        {2, {'a', 'b', 'c'}&lt;!----&gt;},
        {3, s1}
    };
    
    std::cout &lt;&lt; f({"hello", "world"}).first // list-initialization in function call
              &lt;&lt; '\n';
    
    const int (&amp;ar)[2] = {1, 2}; // binds an lvalue reference to a temporary array
    int&amp;&amp; r1 = {1}; // binds an rvalue reference to a temporary int
//  int&amp; r2 = {2}; // error: cannot bind rvalue to a non-const lvalue ref
    
//  int bad{1.0}; // error: narrowing conversion
    unsigned char uc1{10}; // okay
//  unsigned char uc2{-1}; // error: narrowing conversion
    
    Foo f;
    
    std::cout &lt;&lt; n0 &lt;&lt; ' ' &lt;&lt; n1 &lt;&lt; ' ' &lt;&lt; n2 &lt;&lt; '\n'
              &lt;&lt; s1 &lt;&lt; ' ' &lt;&lt; s2 &lt;&lt; ' ' &lt;&lt; s3 &lt;&lt; '\n';
    for (auto p : m)
        std::cout &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; '\n';
    for (auto n : f.mem)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    for (auto n : f.mem2)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
    
    [](...){}(d, ar, r1, uc1); // has effect of [[maybe_unused]]
}
|output=
world
0 1 1
abcd cd aa
1 a
2 abc
3 abcd
1 2 3 -1 -2 -3 
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1288|std=C++11|before=list-initializing a reference with a brace-enclosed initializer list of a&lt;br&gt;single initializer clause always bound the reference to a temporary|after=bind to that initializer&lt;br&gt;clause if valid}}
{{dr list item|wg=cwg|dr=1290|std=C++11|before=the lifetime of the backing array was not correctly specified|after=specified same as other&lt;br&gt;temporary objects}}
{{dr list item|wg=cwg|dr=1324|std=C++11|before=initialization considered first for initialization from {{tt|{}&lt;!----&gt;}}|after=aggregate initialization&lt;br&gt;considered first}}
{{dr list item|wg=cwg|dr=1418|std=C++11|before=the type of the backing array lacked {{c/core|const}}|after={{c/core|const}} added}}
{{dr list item|wg=cwg|dr=1467|std=C++11|before=same-type initialization of aggregates and character&lt;br&gt;arrays was prohibited; initializer-list constructors had&lt;br&gt;priority over copy constructors for single-clause lists|after=same-type initialization&lt;br&gt;allowed; single-clause&lt;br&gt;lists initialize directly}}
{{dr list item|wg=cwg|dr=1494|std=C++11|before=when list-initializing a reference with an initializer clause of an&lt;br&gt;incompatible type, it was unspecified whether the temporary&lt;br&gt;created is direct-list-initialized or copy-list-initialized|after=it depends on the&lt;br&gt;kind of initialization&lt;br&gt;for the reference}}
{{dr list item|wg=cwg|dr=2137|std=C++11|before=initializer-list constructors lost to copy&lt;br&gt;constructors when list-initializing {{tt|X}} from {{tt|{X}&lt;!----&gt;}}|after=non-aggregates consider&lt;br&gt;initializer-lists first}}
{{dr list item|wg=cwg|dr=2252|std=C++17|before=enumerations could be list-initialized from non-scalar values|after=prohibited}}
{{dr list item|wg=cwg|dr=2267|std=C++11|before=the resolution of {{cwg|1494}} made clear&lt;br&gt;that temporaries could be direct-list-initialized|after=they are copy-list-initialized&lt;br&gt;when list-initializing references}}
{{dr list item|wg=cwg|dr=2374|std=C++17|before=direct-list-initialization of an enum allowed too many source types|after=restricted}}
{{dr list item|wg=cwg|dr=2627|std=C++11|before=a narrow bit-field of a larger integer type can be promoted to&lt;br&gt;a smaller integer type, but it was still a narrowing conversion|after=it is not a&lt;br&gt;narrowing conversion}}
{{dr list item|wg=cwg|dr=2713|std=C++20|before=references to aggregate classes could not&lt;br&gt;be initialized by designated initializer lists|after=allowed}}
{{dr list item|wg=cwg|dr=2830|std=C++11|before=list-initialization did not ignore the top-level cv-qualification|after=ignores}}
{{dr list item|wg=cwg|dr=2864|std=C++11|before=floating-point conversions that overflow were not narrowing|after=they are narrowing}}
{{dr list item|paper=P1957R2|std=C++11|before=conversion from a pointer/pointer-to-member&lt;br&gt;to {{c/core|bool}} was not narrowing|after=considered narrowing}}
{{dr list item|paper=P2752R3|std=C++11|before=backing arrays with overlapping lifetime could not overlap|after=they may overlap}}
{{dr list end}}

===See also===
* {{rlp|constructor}}
* {{rlp|converting constructor}}
* {{rlp|copy assignment}}
* {{rlp|copy constructor}}
* {{rlp|copy elision}}
* {{rlp|default constructor}}
* {{rlpt|explicit}}
* {{rlp|initialization}}
** {{rlp|aggregate initialization}}
** {{rlp|constant initialization}}
** {{rlp|copy initialization}}
** {{rlp|direct initialization}}
** {{rlp|reference initialization}}
** {{rlp|value initialization}}
** {{rlp|zero initialization}}
* {{rlp|move assignment}}
* {{rlp|move constructor}}
* {{rlpt|new}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}