{{title|User-defined conversion function}}
{{cpp/language/expressions/navbar}}
Enables {{rlp|implicit cast|implicit conversion}} or {{rlp|explicit cast|explicit conversion}} from a {{rlp|class|class type}} to another type.

===Syntax===
Conversion function is declared like a {{rlp|member functions|non-static member function}} or member {{rlp|function template}} with no parameters, no explicit return type, and with the name of the form:
{{sdsc begin}}
{{sdsc|num=1|{{ttb|operator}} {{spar|conversion-type-id}}}}
{{sdsc|num=2|notes={{mark since c++11}}|{{ttb|explicit}} {{ttb|operator}} {{spar|conversion-type-id}}}}
{{sdsc|num=3|notes={{mark since c++20}}|{{ttb|explicit (}} {{spar|expression}} {{ttb|)}} {{ttb|operator}} {{spar|conversion-type-id}}}}
{{sdsc end}}
@1@ Declares a user-defined conversion function that participates in all {{rlp|implicit cast|implicit}} and {{rlp|explicit cast|explicit conversions}}.
@2@ Declares a user-defined conversion function that participates in {{rlp|direct initialization|direct-initialization}} and {{rlp|explicit cast|explicit conversions}} only.
@3@ Declares a user-defined conversion function that is {{rlp|explicit|conditionally explicit}}.

{{spar|conversion-type-id}} is a {{rlp|type#Type naming|type-id}} except that function and array operators {{ttb|[]}} or {{ttb|()}} are not allowed in its declarator (thus conversion to types such as pointer to array requires a type alias/typedef or an identity template: see below). Regardless of typedef, {{spar|conversion-type-id}} cannot represent an array or a function type.

Although the return type is not allowed in the declaration of a user-defined conversion function, the {{spar|decl-specifier-seq}} of {{rlp|declarations#Specifiers|the declaration grammar}} may be present and may include any specifier other than {{spar|type-specifier}} or the keyword {{tt|static}}, In particular, besides {{rlpt|explicit}}, the specifiers {{rlpt|inline}}, {{rlpt|virtual}}{{rev inl|since=c++11|, {{rlpt|constexpr}}}}{{rev inl|since=c++20|, {{rlpt|consteval}}}}, and {{rlpt|friend}} are also allowed (note that {{tt|friend}} requires a qualified name: {{c|friend A::operator B();}}).

When such member function is declared in class X, it performs conversion from X to 
{{spar|conversion-type-id}}:
{{source|1=
struct X
{
    // implicit conversion
    operator int() const { return 7; }
    
    // explicit conversion
    explicit operator int*() const { return nullptr; }
    
    // Error: array operator not allowed in conversion-type-id
//  operator int(*)[3]() const { return nullptr; }
    
    using arr_t = int[3];
    operator arr_t*() const { return nullptr; } // OK if done through typedef
//  operator arr_t () const; // Error: conversion to array not allowed in any case
};

int main()
{
    X x;

    int n = static_cast&lt;int&gt;(x);   // OK: sets n to 7
    int m = x;                     // OK: sets m to 7

    int* p = static_cast&lt;int*&gt;(x); // OK: sets p to null
//  int* q = x; // Error: no implicit conversion

    int (*pa)[3] = x;  // OK
}
}}

===Explanation===
User-defined conversion function is invoked in the second stage of the {{rlp|implicit cast|implicit conversion}}, which consists of zero or one {{rlp|converting constructor}} or zero or one user-defined conversion function.

If both conversion functions and converting constructors can be used to perform some user-defined conversion, the conversion functions and constructors are both considered by {{rlp|overload resolution}} in {{rlp|copy initialization|copy-initialization}} and {{rlp|reference initialization|reference-initialization}} contexts, but only the constructors are considered in {{rlp|direct initialization|direct-initialization}} contexts.
{{source|1=
struct To
{
    To() = default;
    To(const struct From&amp;) {} // converting constructor
};

struct From
{
    operator To() const {return To();} // conversion function
};

int main()
{
    From f;
    To t1(f);  // direct-initialization: calls the constructor
    // Note: if converting constructor is not available, implicit copy constructor
    // will be selected, and conversion function will be called to prepare its argument
    
//  To t2 = f; // copy-initialization: ambiguous
    // Note: if conversion function is from a non-const type, e.g.
    // From::operator To();, it will be selected instead of the ctor in this case
    
    To t3 = static_cast&lt;To&gt;(f); // direct-initialization: calls the constructor
    const To&amp; r = f;            // reference-initialization: ambiguous
}
}}

Conversion function to its own (possibly cv-qualified) class (or to a reference to it), to the base of its own class (or to a reference to it), and to the type {{c|void}} can be defined, but can not be executed as part of the conversion sequence, except, in some cases, through {{rlp|virtual}} dispatch:
{{source|1=
struct D;

struct B
{
    virtual operator D() = 0;
};

struct D : B
{
    operator D() override { return D(); }
};

int main()
{
    D obj;
    D obj2 = obj; // does not call D::operator D()
    B&amp; br = obj;
    D obj3 = br;  // calls D::operator D() through virtual dispatch
}
}}

It can also be called using member function call syntax:
{{source|1=
struct B {};

struct X : B
{
    operator B&amp;() { return *this; };
};

int main()
{
    X x;
    B&amp; b1 = x;                  // does not call X::operatorB&amp;()
    B&amp; b2 = static_cast&lt;B&amp;&gt;(x); // does not call X::operatorB&amp;
    B&amp; b3 = x.operator B&amp;();    // calls X::operatorB&amp;
}
}}

When making an explicit call to the conversion function, {{spar|conversion-type-id}} is greedy: it is the longest sequence of tokens that could possibly form a {{spar|conversion-type-id}} {{rev inl|since=c++11|(including attributes, if any)}}:
{{source|
&amp; x.operator int * a; // error: parsed as &amp; (x.operator int*) a,
                      //           not as &amp; (x.operator int) * a

operator int [[noreturn]] (); // error: noreturn attribute applied to a type
}}

{{rev begin}}
{{rev|since=c++14|
The placeholder {{rlp|auto}} can be used in {{spar|conversion-type-id}}, indicating a {{rlp|function#Return type deduction|deduced return type}}:
{{source|1=
struct X
{
    operator int(); // OK
    operator auto() -&gt; short; // error: trailing return type not part of syntax
    operator auto() const { return 10; } // OK: deduced return type
    operator decltype(auto)() const { return 10l; } // OK: deduced return type
};
}} 
Note: a {{rlp|member template#Conversion function templates|conversion function template}} is not allowed to have a deduced return type.
}}
{{rev end}}

Conversion functions can be inherited and can be {{rlp|virtual}}, but cannot be {{rlp|static}}. A conversion function in the derived class does not hide a conversion function in the base class unless they are converting to the same type.

Conversion function can be a template member function, for example, [[cpp/memory/auto_ptr/operator auto_ptr|{{tt|std::auto_ptr&lt;T&gt;::operator auto_ptr&lt;Y&gt;}}]]. See {{rlp|member template#Conversion function templates|member template}} and {{rlp|template argument deduction#Conversion function template|template argument deduction}} for applicable special rules.

===Keywords===
{{ltt|cpp/keyword/operator}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=296|std=C++98|before=conversion functions could be static|after=they cannot be declared static}}
{{dr list item|wg=cwg|dr=2016|std=C++98|before=conversion functions could not specify return types,&lt;br&gt;but the types are present in {{spar|conversion-type-id}}|after=return types cannot be specified in the&lt;br&gt;declaration specifiers of conversion functions}}
{{dr list item|wg=cwg|dr=2175|std=C++11&lt;!-- the same orginial wording in C++98 has no defect because of the absence of attributes --&gt;|before=it was unclear whether the {{c|[[noreturn]]}} in&lt;br&gt;{{c|operator int [[noreturn]] ();}} is parsed as a part of&lt;br&gt;{{spar|noptr-declarator}} (of function declarator) or {{spar|conversion-type-id}}|after=it is parsed as a part of&lt;br&gt;{{spar|conversion-type-id}}}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}