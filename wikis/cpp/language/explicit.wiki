{{title|{{tt|explicit}} specifier}}
{{cpp/language/classes/navbar}}

===Syntax===
{{sdsc begin}}
{{sdsc|num=1|
{{ttb|explicit}}
}}
{{sdsc|num=2|notes={{mark since c++20}}|
{{ttb|explicit (}} {{spar|expression}} {{ttb|)}}
}}
{{sdsc end}}
{{par begin}}
{{par|{{spar|expression}}|{{rlp|constant expression#Converted constant expression|contextually converted constant expression of type {{c/core|bool}}}}}}
{{par end}}


@1@ Specifies that a constructor {{rev inl|since=c++11|or conversion function}}{{rev inl|since=c++17|or {{rlp|ctad|deduction guide}}}} is explicit, that is, it cannot be used for {{rlp|implicit conversion}}s and {{rlp|copy initialization|copy-initialization}}.

{{rrev|since=c++20|
@2@ The {{c/core|explicit}} specifier may be used with a constant expression. The function is explicit if and only if that constant expression evaluates to {{c|true}}.
}}

The explicit specifier may only appear within the {{spar|decl-specifier-seq}} of the declaration of a constructor {{rev inl|since=c++11|or conversion function}} within its class definition.

===Notes===
A constructor {{rev inl|until=c++11|with a single non-default parameter}} that is declared without the function specifier {{c/core|explicit}} is called a {{rlp|converting constructor}}.

Both constructors (other than {{rlp|copy constructor|copy}}/{{rlp|move constructor|move}}) and user-defined conversion functions may be function templates; the meaning of {{c/core|explicit}} does not change.

{{rrev|since=c++20|1=
A {{ttb|(}} token that follows {{c/core|explicit}} is always parsed as part of the explicit specifier:
{{source|1=
struct S
{
    explicit (S)(const S&amp;);    // error in C++20, OK in C++17
    explicit (operator int)(); // error in C++20, OK in C++17
};
}}
}}
{{feature test macro|value=201806L|std=C++20|__cpp_conditional_explicit|conditional {{c/core|explicit}}}}

===Keywords===
{{ltt|cpp/keyword/explicit}}

===Example===
{{example|code=
struct A
{
    A(int) {}      // converting constructor
    A(int, int) {} // converting constructor (C++11)
    operator bool() const { return true; }
};

struct B
{
    explicit B(int) {}
    explicit B(int, int) {}
    explicit operator bool() const { return true; }
};

int main()
{
    A a1 = 1;      // OK: copy-initialization selects A::A(int)
    A a2(2);       // OK: direct-initialization selects A::A(int)
    A a3 {4, 5};   // OK: direct-list-initialization selects A::A(int, int)
    A a4 = {4, 5}; // OK: copy-list-initialization selects A::A(int, int)
    A a5 = (A)1;   // OK: explicit cast performs static_cast
    if (a1) { }    // OK: A::operator bool()
    bool na1 = a1; // OK: copy-initialization selects A::operator bool()
    bool na2 = static_cast&lt;bool&gt;(a1); // OK: static_cast performs direct-initialization
    
//  B b1 = 1;      // error: copy-initialization does not consider B::B(int)
    B b2(2);       // OK: direct-initialization selects B::B(int)
    B b3 {4, 5};   // OK: direct-list-initialization selects B::B(int, int)
//  B b4 = {4, 5}; // error: copy-list-initialization does not consider B::B(int, int)
    B b5 = (B)1;   // OK: explicit cast performs static_cast
    if (b2) { }    // OK: B::operator bool()
//  bool nb1 = b2; // error: copy-initialization does not consider B::operator bool()
    bool nb2 = static_cast&lt;bool&gt;(b2); // OK: static_cast performs direct-initialization
    
    [](...){}(a4, a5, na1, na2, b5, nb2); // suppresses “unused variable” warnings
}
}}

===See also===
* {{rlp|converting constructor}}
* {{rlp|initialization}}
* {{rlp|copy initialization}}
* {{rlp|direct initialization}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}