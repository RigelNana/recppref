{{title|Copy elision}}
{{cpp/language/initialization/navbar}}
When certain criteria are met, the creation of a class object from a source object of the same type (ignoring cv-qualification) can be omitted, even if the selected constructor and/or the destructor for the object have side effects. This elision of object creation is called ''copy elision''{{sep}}.

===Explanation===
Copy elision is permitted in the following circumstances (which may be combined to eliminate multiple copies):
* In a {{rlp|return|{{c/core|return}} statement}} in a function with a class return type, when the operand is the name of a non-volatile object {{c|obj}} with {{rlpsd|storage duration#Automatic storage duration}} (other than a function parameter or a {{rlp|catch|handler}} parameter), the {{rlp|copy initialization|copy-initialization}} of the result object can be omitted by constructing {{c|obj}} directly into the function call’s result object. This variant of copy elision is known as ''named return value optimization'' (NRVO).
{{rev begin}}
{{rev|until=c++17|
* When a class object {{c|target}} is copy-initialized with a temporary class object {{c|obj}} that has not been bound to a reference, the copy-initialization can be omitted by constructing {{c|obj}} directly into {{c|target}}. This variant of copy elision is known as ''unnamed return value optimization'' (URVO). Since C++17, URVO is mandatory and no longer considered a form of copy elision; see below.
}}
{{rev|since=c++11|
* In a {{rlp|throw|{{c/core|throw}} expression}}, when the operand is the name of a non-volatile object {{c|obj}} with automatic storage duration (other than a function parameter or a handler parameter) that belongs to a {{rlp|scope}} that does not contain the innermost enclosing {{rlp|try|{{c/core|try}} block}} (if exists), the copy-initialization of the exception object can be omitted by constructing {{c|obj}} directly into the exception object.
* In a {{rlp|catch|handler}}, the copy-initialization of the handler argument can be omitted by treating the handler parameter as an alias for the exception object if the meaning of the program will be unchanged except for the execution of constructors and destructors for the handler argument.
}}
{{rev|since=c++20|
* In {{rlp|coroutines}}, a copy of a coroutine parameter can be omitted. In this case, references to that copy are replaced with references to the corresponding parameter if the meaning of the program will be unchanged except for the execution of a constructor and destructor for the parameter copy object.
}}
{{rev end}}

When copy elision occurs, the implementation treats the source and target of the omitted initialization as simply two different ways of referring to the same object.

{{rev begin}}
{{rev|until=c++11|
The destruction occurs at the later of the times when the two objects would have been destroyed without the optimization.
}}
{{rev|since=c++11|
If the first parameter of the selected constructor is an rvalue reference to the object’s type, the destruction of that object occurs when the target would have been destroyed. Otherwise, the destruction occurs at the later of the times when the two objects would have been destroyed without the optimization.
}}
{{rev end}}


{{rrev|since=c++17|
===Prvalue semantics ("guaranteed copy elision")===
Since C++17, a prvalue is not materialized until needed, and then it is constructed directly into the storage of its final destination. This sometimes means that even when the language syntax visually suggests a copy/move (e.g. {{rlp|copy initialization}}), no copy/move is performed — which means the type need not have an accessible copy/move constructor at all. Examples include:
* Initializing the returned object in a {{rlp|return|return statement}}, when the operand is a {{rlp|value category|prvalue}} of the same class type (ignoring {{rlp|cv|cv-qualification}}) as the function return type:
{{source|1=
T f()
{
    return U(); // constructs a temporary of type U,
                // then initializes the returned T from the temporary
}
T g()
{
    return T(); // constructs the returned T directly; no move
}
}}
: &lt;!--CWG2426--&gt; The destructor of the type returned must be accessible at the point of the return statement and non-deleted, even though no T object is destroyed.
* In the initialization of an object, when the initializer expression is a {{rlp|value category|prvalue}} of the same class type (ignoring {{rlp|cv|cv-qualification}}) as the variable type:
{{source|1=
T x = T(T(f())); // x is initialized by the result of f() directly; no move
}}
:This can only apply when the object being initialized is known not to be a potentially-overlapping subobject:
{{source|
struct C { /* ... */ };
C f();

struct D;
D g();

struct D : C
{
    D() : C(f()) {}    // no elision when initializing a base class subobject
    D(int) : D(g()) {} // no elision because the D object being initialized might
                       // be a base-class subobject of some other class
};
}}

Note: This rule does not specify an optimization, and the Standard does not formally describe it as "copy elision" (because nothing is being elided). Instead, the C++17 core language specification of {{rlp|value category|prvalues}} and {{rlp|implicit conversion#Temporary materialization|temporaries}} is fundamentally different from that of earlier C++ revisions: there is no longer a temporary to copy/move from. Another way to describe C++17 mechanics is "unmaterialized value passing" or "deferred temporary materialization": prvalues are returned and used without ever materializing a temporary.
}}

===Notes===
Copy elision is {{rev inl|until=c++14|the only allowed form of optimization}} {{rev inl|since=c++14|one of the two allowed forms of optimization, alongside {{rlp|new#Allocation|allocation elision and extension}},}} that can change observable side-effects. Because some compilers do not perform copy elision in every situation where it is allowed (e.g., in debug mode), programs that rely on the side-effects of copy/move constructors and destructors are not portable.

{{rrev|since=c++11|
In a {{c/core|return}} statement or a {{c/core|throw}} expression, if the compiler cannot perform copy elision but the conditions for copy elision are met, or would be met except that the source is a function parameter, {{rev inl|until=c++23|the compiler will attempt to use the move constructor even if the source operand is designated by an lvalue}} {{rev inl|since=c++23|the source operand will be treated as an rvalue}}; see {{rlp|return#Notes|{{c/core|return}} statement}} for details.

In {{rlp|constant expression}} and {{rlp|constant initialization}}, copy elision is never performed.&lt;!-- CWG 2278, reversing the resolution of CWG 2022 --&gt;
{{source|1=
struct A
{
    void* p;
    constexpr A() : p(this) {}
    A(const A&amp;); // Disable trivial copyability
};

constexpr A a;  // OK: a.p points to a

constexpr A f()
{
    A x;
    return x;
}
constexpr A b = f(); // error: b.p would be dangling and point to the x inside f

constexpr A c = A(); // (until C++17) error: c.p would be dangling and point to a temporary
                     // (since C++17) OK: c.p points to c; no temporary is involved 
}}
}}

{{feature test macro|std=C++17|value=201606L|__cpp_guaranteed_copy_elision|Guaranteed copy elision through simplified {{rlp|value category|value categories}}}}

===Example===
{{example
|
|code=
#include &lt;iostream&gt;

struct Noisy
{
    Noisy() { std::cout &lt;&lt; "constructed at " &lt;&lt; this &lt;&lt; '\n'; }
    Noisy(const Noisy&amp;) { std::cout &lt;&lt; "copy-constructed\n"; }
    Noisy(Noisy&amp;&amp;) { std::cout &lt;&lt; "move-constructed\n"; }
    ~Noisy() { std::cout &lt;&lt; "destructed at " &lt;&lt; this &lt;&lt; '\n'; }
};

Noisy f()
{
    Noisy v = Noisy(); // (until C++17) copy elision initializing v from a temporary;
                       //               the move constructor may be called
                       // (since C++17) "guaranteed copy elision"
    return v; // copy elision ("NRVO") from v to the result object;
              // the move constructor may be called
}

void g(Noisy arg)
{
    std::cout &lt;&lt; "&amp;arg = " &lt;&lt; &amp;arg &lt;&lt; '\n';
}

int main()
{
    Noisy v = f(); // (until C++17) copy elision initializing v from the result of f()
                   // (since C++17) "guaranteed copy elision"
    
    std::cout &lt;&lt; "&amp;v = " &lt;&lt; &amp;v &lt;&lt; '\n';
    
    g(f()); // (until C++17) copy elision initializing arg from the result of f()
            // (since C++17) "guaranteed copy elision"
}
|p=true
|output=
constructed at 0x7fffd635fd4e
&amp;v = 0x7fffd635fd4e
constructed at 0x7fffd635fd4f
&amp;arg = 0x7fffd635fd4f
destructed at 0x7fffd635fd4f
destructed at 0x7fffd635fd4e
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1967|std=C++11|before=when copy elision is done using a move constructor, the&lt;br&gt;lifetime of the moved-from object was still considered|after=not considered}}
{{dr list item|wg=cwg|dr=2426|std=C++17|before=destructor was not required when returning a prvalue|after=destructor is potentially invoked}}
{{dr list item|wg=cwg|dr=2930|std=C++98|before=only copy(/move) operations could be elided, but a&lt;br&gt;non-copy(/move) constructor can be selected by copy-initialization|after=elides any object construction&lt;br&gt;of related copy-initializations}}
{{dr list end}}

===See also===
* {{rlp|copy initialization}}
* {{rlp|copy constructor}}
* {{rlp|move constructor}}

{{langlinks|de|es|fr|it|ja|ko|pt|ru|zh}}