{{title|Reference initialization}}
{{cpp/language/initialization/navbar}}
Binds a reference to an object.

===Syntax===
=====Non-list-initialization=====
{{sdsc begin}}
{{sdsc|num=1|
{{spar sep|T}}{{ttb|&amp;}} {{spar|ref}} {{ttb|1==}} {{spar|target}} {{ttb|;}}&lt;br&gt;
{{spar sep|T}}{{ttb|&amp;}} {{spar|ref}} {{ttb|(}} {{spar|target}} {{ttb|);}}
}}
{{sdsc|num=2|notes={{mark since c++11}}|
{{spar sep|T}}{{ttb|&amp;&amp;}} {{spar|ref}} {{ttb|1==}} {{spar|target}} {{ttb|;}}&lt;br&gt;
{{spar sep|T}}{{ttb|&amp;&amp;}} {{spar|ref}} {{ttb|(}} {{spar|target}} {{ttb|);}}
}}
{{sdsc|num=3|
{{spar|func-refpar}} {{ttb|(}} {{spar|target}} {{ttb|)}}
}}
{{sdsc|num=4|notes={{mark|inside the definition of {{spar sep|func-refret}}}}|
{{ttb|return}} {{spar|target}} {{ttb|;}}
}}
{{sdsc|num=5|notes={{mark|inside the definition of {{spar sep|Class}}}}|
{{spar|Class}}{{ttb|::}}{{spar|Class}}{{ttb|(}}...{{ttb|) :}} {{spar|ref-member}} {{ttb|(}} {{spar|target}} {{ttb|) {}} ... {{ttb|}&lt;!-- --&gt;}}
}}
{{sdsc end}}

=====Ordinary list-initialization {{mark since c++11}}=====
{{sdsc begin}}
{{sdsc|num=1|
{{spar sep|T}}{{ttb|&amp;}} {{spar|ref}} {{ttb|1== {}} {{spar|arg1}}{{ttb|,}} {{spar|arg2}}{{ttb|,}} ... {{ttb|};}}&lt;br&gt;
{{spar sep|T}}{{ttb|&amp;}} {{spar|ref}} {{ttb|{}} {{spar|arg1}}{{ttb|,}} {{spar|arg2}}{{ttb|,}} ... {{ttb|};}}
}}
{{sdsc|num=2|
{{spar sep|T}}{{ttb|&amp;&amp;}} {{spar|ref}} {{ttb|1== {}} {{spar|arg1}}{{ttb|,}} {{spar|arg2}}{{ttb|,}} ... {{ttb|};}}&lt;br&gt;
{{spar sep|T}}{{ttb|&amp;&amp;}} {{spar|ref}} {{ttb|{}} {{spar|arg1}}{{ttb|,}} {{spar|arg2}}{{ttb|,}} ... {{ttb|};}}
}}
{{sdsc|num=3|
{{spar|func-refpar}} {{ttb|({}} {{spar|arg1}}{{ttb|,}} {{spar|arg2}}{{ttb|,}} ... {{ttb|});}}
}}
{{sdsc end}}

=====Designated list-initialization {{mark since c++20}}=====
{{sdsc begin}}
{{sdsc|num=1|
{{spar sep|T}}{{ttb|&amp;}} {{spar|ref}} {{ttb|1== {.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!-- --&gt;}} ... {{ttb|};}}&lt;br&gt;
{{spar sep|T}}{{ttb|&amp;}} {{spar|ref}} {{ttb|{.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!-- --&gt;}} ... {{ttb|};}}
}}
{{sdsc|num=2|
{{spar sep|T}}{{ttb|&amp;&amp;}} {{spar|ref}} {{ttb|1== {.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!-- --&gt;}} ... {{ttb|};}}&lt;br&gt;
{{spar sep|T}}{{ttb|&amp;&amp;}} {{spar|ref}} {{ttb|{.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!-- --&gt;}} ... {{ttb|};}}
}}
{{sdsc|num=3|
{{spar|func-refpar}} {{ttb|({.}}{{spar|des1}} {{ttb|1==}} {{spar|arg1}} {{ttb|, .}}{{spar|des2}} {{ttb|{}} {{spar|arg2}} {{ttb|}&lt;!-- --&gt;}} ... {{ttb|});}}
}}
{{sdsc end}}

A reference to {{tt|T}} can be initialized with an object of type {{tt|T}}, a function of type {{tt|T}}, or an object implicitly convertible to {{tt|T}}. Once initialized, a reference cannot be reseated (changed) to refer to another object.

References are initialized in the following situations:
@1@ When a named {{rlp|reference#Lvalue references|lvalue reference}} variable is declared with an initializer.
@2@ When a named {{rlp|reference#Rvalue references|rvalue reference}} variable is declared with an initializer.
@3@ In a function call expression, when the function parameter has reference type.
@4@ In the {{c/core|return}} statement, when the function returns a reference type. {{rev inl|since=c++26|The program is ill-formed if the returned reference is bound to the result of a [[#Lifetime_of_a_temporary|temporary expression]].}}
@5@ When a {{rlp|data members|non-static data member}} of reference type is initialized using a {{rlp|initializer list|member initializer}}.

===Explanation===
{{par begin}}
{{par|{{spar|T}}|the referenced type}}
{{par|{{spar|ref}}|the reference variable to be initialized}}
{{par|{{spar|target}}|the initializer expression being used}}
{{par|{{spar|func-refpar}}|a function with a parameter of reference type ({{spar sep|T}}{{tt|&amp;}}{{rev inl|since=c++11| or {{spar sep|T}}{{tt|&amp;&amp;}}}})}}
{{par|{{spar|func-refret}}|a function whose returns type is a reference type ({{spar sep|T}}{{tt|&amp;}}{{rev inl|since=c++11| or {{spar sep|T}}{{tt|&amp;&amp;}}}})}}
{{par|{{spar|Class}}|a class name}}
{{par|{{spar|ref-member}}|a non-static data member of reference type ({{spar sep|T}}{{tt|&amp;}}{{rev inl|since=c++11| or {{spar sep|T}}{{tt|&amp;&amp;}}}}) of {{spar|Class}}}}
{{par|{{spar|des1}}, {{spar|des2}}, ...|designators}}
{{par|{{spar|arg1}}, {{spar|arg2}}, ...|the initializers in initializer lists}}
{{par end}}

===Definitions===
For two types {{tt|T1}} and {{tt|T2}}:
* Given the cv-unqualified versions of {{tt|T1}} and {{tt|T2}} as {{tt|U1}} and {{tt|U2}} respectively, if {{tt|U1}} is {{rlp|implicit conversion#Similar types|similar}} to {{tt|U2}}, or {{tt|U1}} is a {{rlp|derived class|base class}} of {{tt|U2}}, {{tt|T1}} is ''reference-related'' to {{tt|T2}}.
* If a prvalue of type “pointer to {{tt|T2}}” can be converted to the type “pointer to {{tt|T1}}” via a standard conversion sequence, {{tt|T1}} is ''reference-compatible'' with {{tt|T2}}.

===Initialization rules===
{{rrev|since=c++11|
If a reference initialization uses an ordinary{{rev inl|since=c++20| or designated}} list-initialization, the rules of {{rlp|list initialization|list-initialization}} are followed.
}}

For non-list reference initialization, given the type of {{spar|target}} as {{tt|U}}, the reference either ''binds directly'' to {{spar|target}} or binds to a value of type {{tt|T}} converted from {{spar|target}}. Direct binding is considered first, followed by indirect binding, if neither binding is available, the program is ill-formed.

In all cases where the reference-compatible relationship of two types is used to establish the validity of a reference binding and the standard conversion sequence would be ill-formed, a program that necessitates such a binding is ill-formed.

====Direct binding====
If all following conditions are satisfied:
* The reference to be initialized is an lvalue reference.
* {{spar|target}} is a non-{{rlp|bit field|bit-field}} lvalue.
* {{tt|T}} is reference-compatible with {{tt|U}}.
Then the reference binds to {{spar|target}}, or to its appropriate base class subobject:
{{source|1=
double d = 2.0;
double&amp; rd = d;        // rd refers to d
const double&amp; rcd = d; // rcd refers to d

struct A {};
struct B : A {} b;

A&amp; ra = b;             // ra refers to A subobject in b
const A&amp; rca = b;      // rca refers to A subobject in b
}}

Otherwise, if all following conditions are satisfied:
* The reference to be initialized is an lvalue reference.
* {{tt|U}} is a class type.
* {{tt|T}} is not reference-related to {{tt|U}}.
* {{spar|target}} can be converted to an lvalue of type {{tt|V}} such that {{tt|T}} is reference-compatible with {{tt|V}}.
Then the reference binds to the lvalue result of the conversion, or to its appropriate base class subobject:
{{source|1=
struct A {};
struct B : A { operator int&amp;(); };

int&amp; ir = B(); // ir refers to the result of B::operator int&amp;
}}

Otherwise, if the reference to be initialized is an lvalue reference, and {{tt|T}} is not const-qualified or is volatile-qualified, the prorgram is ill-formed:
{{source|1=
double&amp; rd2 = 2.0; // error: not an lvalue and reference is not const
int i = 2;
double&amp; rd3 = i;   // error: type mismatch and reference is not const
}}

Otherwise, if all following conditions are satisfied:
* {{spar|target}} is a value of any following category:
{{rev begin}}
{{rev|until=c++11|
:* rvalue
}}
{{rev|since=c++11|until=c++17|
:* non-bit-field xvalue
:* class prvalue
:* array prvalue
:* function lvalue
}}
{{rev|since=c++17|
:* non-bit-field rvalue
:* function lvalue
}}
{{rev end}}
* {{tt|T}} is reference-compatible with {{tt|U}}.
Then the reference binds to {{spar|target}}, or to its appropriate base class subobject:
{{source|1=
struct A {};
struct B : A {};
extern B f();

const A&amp; rca2 = f(); // bound to the A subobject of the B rvalue.
A&amp;&amp; rra = f();       // same as above

int i2 = 42;
int&amp;&amp; rri = static_cast&lt;int&amp;&amp;&gt;(i2); // bound directly to i2
}}

{{rrev|since=c++17|
If {{spar|target}} is a prvalue, {{rlpsd|implicit conversion#Temporary materialization}} is applied to it, considering the type of the prvalue to be the adjusted type {{tt|P}}.
* {{tt|P}} is {{rlp|implicit conversion#Qualification conversions|adjusted}} from the type of {{spar|target}} (i.e. {{tt|U}}) by adding the cv-qualification of {{tt|T}} to it.

In this case, the reference binds to the result object, or to its appropriate base class subobject.
}}

Otherwise, if all following conditions are satisfied:
* {{tt|U}} is a class type.
* {{tt|T}} is not reference-related to {{tt|U}}.
* {{spar|target}} can be converted to a value {{c|v}} of type {{tt|V}} such that {{tt|T}} is reference-compatible with {{tt|V}}, where {{c|v}} is of any following category:
{{rev begin}}
{{rev|until=c++11|
:* rvalue
}}
{{rev|since=c++11|until=c++17|
:* xvalue
:* class prvalue
:* function lvalue
}}
{{rev|since=c++17|
:* rvalue
:* function lvalue
}}
{{rev end}}
Then the reference binds to the result of the conversion, or to its appropriate base class subobject:
{{source|1=
struct A {};
struct B : A {};
struct X { operator B(); } x;

const A&amp; r = x; // bound to the A subobject of the result of the conversion
B&amp;&amp; rrb = x;    // bound directly to the result of the conversion
}}

{{rrev|since=c++17|
If the result of the conversion is a prvalue, {{rlpsd|implicit conversion#Temporary materialization}} is applied to it, considering the type of the prvalue to be the adjusted type {{tt|P}}.
* {{tt|P}} is {{rlp|implicit conversion#Qualification conversions|adjusted}} from the type of the conversion result by adding the cv-qualification of {{tt|T}} to it.

In this case, the reference binds to the result object, or to its appropriate base class subobject.
}}

====Indirect binding====
If direct binding is not available, indirect binding is considered. In this case, {{tt|T}} cannot be reference-related to {{tt|U}}.

If {{tt|T}} or {{tt|U}} is a class type, user-defined conversions are considered using the rules for {{rlp|copy initialization|copy-initialization}} of an object of type {{tt|T}} by user-defined conversion. The program is ill-formed if the corresponding non-reference copy-initialization would be ill-formed. The result of the call to the conversion function, as described for the non-reference {{rlp|copy initialization|copy-initialization}}, is then used to direct-initialize the reference. For this direct-initialization, user-defined conversions are not considered.

{{rev begin}}
{{rev|until=c++17|
Otherwise, a temporary of type {{tt|T}} is created and copy-initialized from {{spar|target}}. The reference is then bound to the temporary.
}}
{{rev|since=c++17|
Otherwise, {{spar|target}} is implicitly converted to a prvalue of type “cv-unqualified {{tt|T}}”. The temporary materialization conversion is applied, considering the type of the prvalue to be {{tt|T}}, and the reference is bound to the result object.
}}
{{rev end}}

{{source|1=
const std::string&amp; rs = "abc"; // rs refers to temporary copy-initialized from char array
const double&amp; rcd2 = 2;        // rcd2 refers to temporary with value 2.0
int i3 = 2;
double&amp;&amp; rrd3 = i3;            // rrd3 refers to temporary with value 2.0
}}

===Lifetime of a temporary===
Whenever a reference is bound to a temporary object or to a subobject thereof, the lifetime of the temporary object is extended to match the lifetime of the reference (check {{rlp|lifetime#Temporary object lifetime|temporary object lifetime exceptions}}), where the temporary object or its subobject is denoted by one of following expression:
{{rrev multi|rev1=
* a {{rlps|value category#prvalue}} expression of an object type,
|since2=c++17|rev2=
* a {{rlp|implicit conversion#Temporary materialization|temporary materialization conversion}},
}}
* a parenthesized expression {{c|(e)}}, where {{c|e}} is one of these expressions,
* a {{rlp|operator member access#Built-in subscript operator|built-in subscript expression}} of form {{c|a[n]}} or {{c|n[a]}}, where {{c|a}} is an array and is one of these expressions,
* a {{rlp|operator member access#Built-in member access operators|class member access expression}} of form {{c|e.m}}, where {{c|e}} is one of these expressions and {{c|m}} designates a non-static data member of object type,
* a {{rlp|operator member access#Built-in pointer-to-member access operators|pointer-to-member operation}} of form {{c|e.*mp}}, where {{c|e}} is one of these expressions and {{c|mp}} is a pointer to data member,
* a {{rlpt|const_cast}}, {{rlpt|static_cast}}, {{rlpt|dynamic_cast}}, or {{rlpt|reinterpret_cast}} conversion without a user-defined conversion that converts one of these expressions to the glvalue refers to the object designated by the operand, or to its complete object or a subobject thereof (an {{rlp|explicit cast}} expression is interpreted as a sequence of these casts),
* a {{rlp|operator other#Conditional operator|conditional expression}} of form {{c|cond ? e1 : e2}} that is a glvalue, where {{c|e1}} or {{c|e2}} is one of these expressions, or
* a {{rlp|operator other#Built-in comma operator|built-in comma expression}} of form {{c|x, e}} that is a glvalue, where {{c|e}} is one of these expressions.

There are following exceptions to this lifetime rule:
{{rrev|until=c++26|
* a temporary bound to a return value of a function in a {{c/core|return}} statement is not extended: it is destroyed immediately at the end of the return expression. Such {{c/core|return}} statement always returns a dangling reference.
}}
* a temporary bound to a reference parameter in a function call exists until the end of the full expression containing that function call: if the function returns a reference, which outlives the full expression, it becomes a dangling reference.
{{rrev|since=c++11|
* a temporary bound to a reference in the initializer used in a new-expression exists until the end of the full expression containing that new-expression, not as long as the initialized object. If the initialized object outlives the full expression, its reference member becomes a dangling reference.
}}
{{rrev|since=c++20|
* a temporary bound to a reference in a reference element of an aggregate initialized using {{rlp|direct_initialization|direct-initialization}} syntax '''('''parentheses''')''' exists until the end of the full expression containing the initializer, as opposed to {{rlp|list_initialization|list-initialization}} syntax '''{'''braces'''}'''.
{{source|1=
struct A
{
    int&amp;&amp; r;
};

A a1{7}; // OK, lifetime is extended
A a2(7); // well-formed, but dangling reference
}}
}}

In general, the lifetime of a temporary cannot be further extended by "passing it on": a second reference, initialized from the reference variable or data member to which the temporary was bound, does not affect its lifetime.

===Notes===
References appear without initializers only in function parameter declaration, in function return type declaration, in the declaration of a class member, and with the {{rlpt|storage duration|extern}} specifier.

Until the resolution of {{cwg|1696}}, a temporary is permitted to bound to a reference member in a constructor {{rlp|initializer list}}, and it persists only until the constructor exits, not as long as the object exists. Such initialization is ill-formed since {{cwg|1696|-}}, although many compilers still support it (a notable exception is clang).

===Example===
{{example
|
|code=
#include &lt;sstream&gt;
#include &lt;utility&gt;

struct S
{
    int mi;
    const std::pair&lt;int, int&gt;&amp; mp; // reference member
};

void foo(int) {}

struct A {};

struct B : A
{
    int n;
    operator int&amp;() { return n; }
};

B bar() { return B(); }

//int&amp; bad_r;      // error: no initializer
extern int&amp; ext_r; // OK

int main()
{
//  Lvalues
    int n = 1;
    int&amp; r1 = n;                    // lvalue reference to the object n
    const int&amp; cr(n);               // reference can be more cv-qualified
    volatile int&amp; cv{n};            // any initializer syntax can be used
    int&amp; r2 = r1;                   // another lvalue reference to the object n
//  int&amp; bad = cr;                  // error: less cv-qualified
    int&amp; r3 = const_cast&lt;int&amp;&gt;(cr); // const_cast is needed

    void (&amp;rf)(int) = foo; // lvalue reference to function
    int ar[3];
    int (&amp;ra)[3] = ar;     // lvalue reference to array

    B b;
    A&amp; base_ref = b;        // reference to base subobject
    int&amp; converted_ref = b; // reference to the result of a conversion

//  Rvalues
//  int&amp; bad = 1;        // error: cannot bind lvalue ref to rvalue
    const int&amp; cref = 1; // bound to rvalue
    int&amp;&amp; rref = 1;      // bound to rvalue

    const A&amp; cref2 = bar(); // reference to A subobject of B temporary
    A&amp;&amp; rref2 = bar();      // same

    int&amp;&amp; xref = static_cast&lt;int&amp;&amp;&gt;(n); // bind directly to n
//  int&amp;&amp; copy_ref = n;                 // error: can't bind to an lvalue
    double&amp;&amp; copy_ref = n;              // bind to an rvalue temporary with value 1.0

//  Restrictions on temporary lifetimes
//  std::ostream&amp; buf_ref = std::ostringstream() &lt;&lt; 'a';
                     // the ostringstream temporary was bound to the left operand
                     // of operator&lt;&lt; but its lifetime ended at the semicolon so
                     // the buf_ref is a dangling reference

    S a {1, {2, 3}&lt;!----&gt;}; // temporary pair {2, 3} bound to the reference member
                     // a.mp and its lifetime is extended to match 
                     // the lifetime of object a

    S* p = new S{1, {2, 3}&lt;!----&gt;}; // temporary pair {2, 3} bound to the reference
                             // member p-&gt;mp, but its lifetime ended at the semicolon
                             // p-&gt;mp is a dangling reference
    delete p;

    // Imitate [[maybe_unused]] applied to the following variables:
    [](...){}
    (
        cv, r2, r3, rf, ra, base_ref, converted_ref,
        a, cref, rref, cref2, rref2, copy_ref, xref
    );
}
|output=
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=391|std=C++98|before=initialize a reference to const-qualified type with a class type&lt;br&gt;rvalue might create a temporary, and a constructor of that class&lt;br&gt;was required in order to copy the rvalue into that temporary|after=no temporary is&lt;br&gt;created, constructor&lt;br&gt;is not required}}
{{dr list item|wg=cwg|dr=450|std=C++98|before=a reference to const-qualified array could not be&lt;br&gt;initialized with a reference-compatible array rvalue|after=allowed}}
{{dr list item|wg=cwg|dr=589|std=C++98|before=a reference could not bind directly to an array or class rvalue|after=allowed}}
{{dr list item|wg=cwg|dr=656|std=C++98|before=a reference to const-qualified type initialized with a type which is not&lt;br&gt;reference-compatible but has a conversion function to a reference-&lt;br&gt;compatible type was bound to a temporary copied from the return&lt;br&gt;value (or its base class subobject) of the conversion function|after=bound to the return&lt;br&gt;value (or its base class&lt;br&gt;subobject) directly}}
{{dr list item|wg=cwg|dr=1287|std=C++11|before=the conversion from {{spar|target}} of class type to another&lt;br&gt;reference-compatible type could only be implicit|after=allow explicit&lt;br&gt;conversions}}
{{dr list item|wg=cwg|dr=1295|std=C++11|before=a reference could bind to a bit-field xvalue|after=prohibited}}
{{dr list item|wg=cwg|dr=1299|std=C++98|before=the definition of temporary was unclear|after=made clear}}
{{dr list item|wg=cwg|dr=1571|std=C++98|before=user-defined conversions in indirect&lt;br&gt;binding did not consider the type of {{spar|target}}|after=considered}}
{{dr list item|wg=cwg|dr=1604|std=C++98|before=user-defined conversions were not considered in indirect binding|after=considered}}
{{dr list item|wg=cwg|dr=2352|std=C++98|before=reference compatibility did not consider qualification conversions|after=considered}}
{{dr list item|wg=cwg|dr=2481|std=C++17|before=cv-qualification was not added to the result type&lt;br&gt;of temporary materialization in indirect binding|after=added}}
{{dr list item|wg=cwg|dr=2657|std=C++17|before=cv-qualification was not added to the result type&lt;br&gt;of temporary materialization in direct binding|after=added}}
{{dr list item|wg=cwg|dr=2801|std=C++98|before=reference-related types were allowed for indirect binding|after=prohibited}}
{{dr list end}}

===See also===
* {{rlp|constructor}}
* {{rlp|converting constructor}}
* {{rlp|copy assignment}}
* {{rlp|copy constructor}}
* {{rlpt|explicit}}
* {{rlp|initialization}}
** {{rlp|constant initialization}}
** {{rlp|copy initialization}}
** {{rlp|direct initialization}}
** {{rlp|list initialization}}
* {{rlp|move assignment}}
* {{rlp|move constructor}}
* {{rlpt|new}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}