{{title|Undefined behavior}}
{{cpp/language/basics/navbar}}
Renders the entire program meaningless if certain rules of the language are violated.

===Explanation===
The C++ standard precisely defines the {{rlp|as if|observable behavior}} of every C++ program that does not fall into one of the following classes:

* ''ill-formed'' - The program has syntax errors or diagnosable semantic errors.
:* A conforming C++ compiler is required to issue a diagnostic, even if it defines a language extension that assigns meaning to such code (such as with variable-length arrays).
:* The text of the standard uses ''shall'', ''shall not'', and ''ill-formed'' to indicate these requirements.&lt;!-- see  http://stackoverflow.com/questions/25300461 for the discussion on whether shall violations mean ill-formed or undefined --&gt;

* ''ill-formed, {{rlp|ndr|no diagnostic required}}'' - The program has semantic errors which may not be diagnosable in general case (e.g. violations of the {{rlp|definition|ODR}} or other errors that are only detectable at link time).
:* The behavior is undefined if such program is executed.

* ''implementation-defined behavior'' - The behavior of the program varies between implementations, and the conforming implementation must document the effects of each behavior.
:* For example, the type of {{lc|std::size_t}} or the number of bits in a byte, or the text of {{lc|std::bad_alloc::what}}.
:* A subset of implementation-defined behavior is ''locale-specific behavior'', which depends on the implementation-supplied [[cpp/locale|locale]].

* ''unspecified behavior'' - The behavior of the program varies between implementations, and the conforming implementation is not required to document the effects of each behavior.
:* For example, {{rlp|eval order|order of evaluation}}, whether identical {{rlp|string literal}}s are distinct, the amount of array allocation overhead, etc.
:* Each unspecified behavior results in one of a set of valid results.

{{rrev|since=c++26|
* ''erroneous behavior'' - The (incorrect) behavior that the implementation is recommended to diagnose.
:* Erroneous behavior is always the consequence of incorrect program code.
:* The evaluation of a constant expression never results in an erroneous behavior.
:* If the execution contains an operation specified as having erroneous behavior, the implementation is permitted and recommended to issue a diagnostic, and is permitted to terminate the execution at an unspecified time after that operation.
:* An implementation can issue a diagnostic if it can determine that erroneous behavior is reachable under an implementation-specific set of assumptions about the program behavior, which can result in false positives.

{{cot|Examples of erroneous behavior}}
{{source|1=
#include &lt;cassert&gt;
#include &lt;cstring&gt;

void f()
{   
    int d1, d2;       // d1, d2 have erroneous values
    int e1 = d1;      // erroneous behavior
    int e2 = d1;      // erroneous behavior
    assert(e1 == e2); // holds
    assert(e1 == d1); // holds, erroneous behavior
    assert(e2 == d1); // holds, erroneous behavior

    std::memcpy(&amp;d2, &amp;d1, sizeof(int)); // no erroneous behavior, but
                                        // d2 has an erroneous value

    assert(e1 == d2); // holds, erroneous behavior
    assert(e2 == d2); // holds, erroneous behavior
}

unsigned char g(bool b)
{
    unsigned char c;     // c has erroneous value
    unsigned char d = c; // no erroneous behavior, but d has an erroneous value
    assert(c == d);      // holds, both integral promotions have erroneous behavior
    int e = d;           // erroneous behavior
    return b ? d : 0;    // erroneous behavior if b is true
}
}}
{{cob}}
}}

* ''undefined behavior'' - There are no restrictions on the behavior of the program.
:* Some examples of undefined behavior are data races, memory accesses outside of array bounds, signed integer overflow, null pointer dereference, {{rlp|eval order|more than one}} modifications of the same scalar in an expression {{rev inl|until=c++11|without any intermediate sequence point}}{{rev inl|since=c++11|that is unsequenced}}, access to an object through {{rlp|reinterpret_cast#Type aliasing|a pointer of a different type}}, etc.
:* Implementations are not required to diagnose undefined behavior (although many simple situations are diagnosed), and the compiled program is not required to do anything meaningful.

{{rrev|since=c++11|
* ''runtime-undefined behavior'' - The behavior that is undefined except when it occurs during the evaluation of an expression as a {{rlpsd|constant expression#Core constant expression}}.
}}

===UB and optimization===
Because correct C++ programs are free of undefined behavior, compilers may produce unexpected results when a program that actually has UB is compiled with optimization enabled:

For example,
====Signed overflow====
{{source|1=
int foo(int x)
{
    return x + 1 &gt; x; // either true or UB due to signed overflow
}
}}
may be compiled as ([https://godbolt.org/z/re39h7P1K demo])
{{source|
foo(int):
        mov     eax, 1
        ret
}}

====Access out of bounds====
{{source|1=
int table[4] = {};
bool exists_in_table(int v)
{
    // return true in one of the first 4 iterations or UB due to out-of-bounds access
    for (int i = 0; i &lt;= 4; i++)
        if (table[i] == v)
            return true;
    return false;
}
}}
May be compiled as ([https://godbolt.org/z/vMbsdo5az demo])
{{source|
exists_in_table(int):
        mov     eax, 1
        ret
}}

====Uninitialized scalar====
{{source|1=
std::size_t f(int x)
{
    std::size_t a;
    if (x) // either x nonzero or UB
        a = 42;
    return a;
}
}}
May be compiled as ([https://godbolt.org/z/1sraffdM8 demo])
{{source|
f(int):
        mov     eax, 42
        ret
}}

{{example
|The output shown was observed on an older version of gcc
|code=
#include &lt;cstdio&gt;

int main()
{
    bool p; // uninitialized local variable
    if (p)  // UB access to uninitialized scalar
        std::puts("p is true");
    if (!p) // UB access to uninitialized scalar
        std::puts("p is false");
}
|p=true
|output=
p is true
p is false
}}

====Invalid scalar====
{{source|1=
int f()
{
    bool b = true;
    unsigned char* p = reinterpret_cast&lt;unsigned char*&gt;(&amp;b);
    *p = 10;
    // reading from b is now UB
    return b == 0;
}
}}
May be compiled as ([https://godbolt.org/z/4vKxhcea4 demo])
{{source|
f():
        mov     eax, 11
        ret
}}

====Null pointer dereference====
The examples demonstrate reading from the result of dereferencing a null pointer.
{{source|1=
int foo(int* p)
{
    int x = *p;
    if (!p)
        return x; // Either UB above or this branch is never taken
    else
        return 0;
}

int bar()
{
    int* p = nullptr;
    return *p; // Unconditional UB
}
}}
may be compiled as ([https://godbolt.org/z/edxr5W5T7 demo])
{{source|
foo(int*):
        xor     eax, eax
        ret
bar():
        ret
}}

====Access to pointer passed to {{lc|std::realloc}}====
{{example
|Choose clang to observe the output shown
|code=
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;

int main()
{
    int* p = (int*)std::malloc(sizeof(int));
    int* q = (int*)std::realloc(p, sizeof(int));
    *p = 1; // UB access to a pointer that was passed to realloc
    *q = 2;
    if (p == q) // UB access to a pointer that was passed to realloc
        std::cout &lt;&lt; *p &lt;&lt; *q &lt;&lt; '\n';
}
|p=true
|output=
12
}}

====Infinite loop without side-effects====
{{example|Choose clang or the latest gcc to observe the output shown.
|code=
#include &lt;iostream&gt;

bool fermat()
{
    const int max_value = 1000;

    // Non-trivial infinite loop with no side effects is UB
    for (int a = 1, b = 1, c = 1; true; )
    {
        if (((a * a * a) == ((b * b * b) + (c * c * c))))
            return true; // disproved :()
        a++;
        if (a &gt; max_value)
        {
            a = 1;
            b++;
        }
        if (b &gt; max_value)
        {
            b = 1;
            c++;
        }
        if (c &gt; max_value)
            c = 1;
    }

    return false; // not disproved
}

int main()
{
    std::cout &lt;&lt; "Fermat's Last Theorem ";
    fermat()
        ? std::cout &lt;&lt; "has been disproved!\n"
        : std::cout &lt;&lt; "has not been disproved.\n";
}
|p=true
|output=
Fermat's Last Theorem has been disproved!
}}

===Ill-formed with diagnostic message===
Note that compilers are permitted to extend the language in ways that give meaning to ill-formed programs. The only thing C++ standard requires in such cases is a diagnostic message (compiler warning), unless the program was "ill-formed no diagnostic required".

For example, unless language extensions are disabled via {{tt|--pedantic-errors}}, GCC will compile the following example [https://coliru.stacked-crooked.com/a/3cc6bdd9576df9a5 with only a warning] even though it [https://eel.is/c++draft/dcl.init.list#example-6 appears in the C++ standard] as an example of an "error" (see also [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=55783 GCC Bugzilla #55783])

{{example
|code=
#include &lt;iostream&gt;

// Example tweak, do not use constant
double a{1.0};

// C++23 standard, §9.4.5 List-initialization [dcl.init.list], Example #6:
struct S
{
    // no initializer-list constructors
    S(int, double, double); // #1
    S();                    // #2
    // ...
};

S s1 = {1, 2, 3.0}; // OK, invoke #1
S s2{a, 2, 3}; // error: narrowing
S s3{}; // OK, invoke #2
// — end example]

S::S(int, double, double) {}
S::S() {}

int main()
{
    std::cout &lt;&lt; "All checks have passed.\n";
}
|p=true
|output=
main.cpp:17:6: error: type 'double' cannot be narrowed to 'int' in initializer ⮠
list [-Wc++11-narrowing]
S s2{a, 2, 3}; // error: narrowing
     ^
main.cpp:17:6: note: insert an explicit cast to silence this issue
S s2{a, 2, 3}; // error: narrowing
     ^
     static_cast&lt;int&gt;( )
1 error generated.
}}

===References===
{{cot}}
{{ref std c++23}}
{{ref std|section=3.25|title=ill-formed program|id=defns.ill.formed}}
{{ref std|section=3.26|title=implementation-defined behavior|id=defns.impl.defined}}
{{ref std|section=3.66|title=unspecified behavior|id=defns.unspecified}}
{{ref std|section=3.68|title=well-formed program|id=defns.well.formed}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=TBD|title=ill-formed program|id=defns.ill.formed}}
{{ref std|section=TBD|title=implementation-defined behavior|id=defns.impl.defined}}
{{ref std|section=TBD|title=unspecified behavior|id=defns.unspecified}}
{{ref std|section=TBD|title=well-formed program|id=defns.well.formed}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=TBD|title=ill-formed program|id=defns.ill.formed}}
{{ref std|section=TBD|title=implementation-defined behavior|id=defns.impl.defined}}
{{ref std|section=TBD|title=unspecified behavior|id=defns.unspecified}}
{{ref std|section=TBD|title=well-formed program|id=defns.well.formed}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=TBD|title=ill-formed program|id=defns.ill.formed}}
{{ref std|section=TBD|title=implementation-defined behavior|id=defns.impl.defined}}
{{ref std|section=TBD|title=unspecified behavior|id=defns.unspecified}}
{{ref std|section=TBD|title=well-formed program|id=defns.well.formed}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=TBD|title=ill-formed program|id=defns.ill.formed}}
{{ref std|section=TBD|title=implementation-defined behavior|id=defns.impl.defined}}
{{ref std|section=TBD|title=unspecified behavior|id=defns.unspecified}}
{{ref std|section=TBD|title=well-formed program|id=defns.well.formed}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=TBD|title=ill-formed program|id=defns.ill.formed}}
{{ref std|section=TBD|title=implementation-defined behavior|id=defns.impl.defined}}
{{ref std|section=TBD|title=unspecified behavior|id=defns.unspecified}}
{{ref std|section=TBD|title=well-formed program|id=defns.well.formed}}
{{ref std end}}
{{cob}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/attributes/dsc assume}}
{{dsc inc|cpp/language/attributes/dsc indeterminate}}
{{dsc inc|cpp/utility/dsc unreachable}}
{{dsc see c|c/language/behavior|Undefined behavior|nomono=true}}
{{dsc end}}

===External links===
{{elink begin}}
{{elink|[https://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html The LLVM Project Blog: What Every C Programmer Should Know About Undefined Behavior #1/3]}}
{{elink|[https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html The LLVM Project Blog: What Every C Programmer Should Know About Undefined Behavior #2/3]}}
{{elink|[https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html The LLVM Project Blog: What Every C Programmer Should Know About Undefined Behavior #3/3]}}
{{elink|1=[https://devblogs.microsoft.com/oldnewthing/20140627-00/?p=633 Undefined behavior can result in time travel (among other things, but time travel is the funkiest)]}}
{{elink|[https://www.cs.utah.edu/~regehr/papers/overflow12.pdf Understanding Integer Overflow in C/C++]}}
{{elink|[https://lwn.net/Articles/342330/ Fun with NULL pointers, part 1] (local exploit in Linux 2.6.30 caused by UB due to null pointer dereference)}}
{{elink|[https://web.archive.org/web/20201108094235/https://kukuruku.co/post/undefined-behavior-and-fermats-last-theorem/ Undefined Behavior and Fermat’s Last Theorem]}}
{{elink|[https://pvs-studio.com/en/blog/posts/cpp/1129/ C++ programmer's guide to undefined behavior]}}
{{elink end}}

{{langlinks|es|ja|ru|zh}}