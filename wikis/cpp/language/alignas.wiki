{{title|{{tt|alignas}} specifier {{mark since c++11}}}}
{{cpp/language/declarations/navbar}}

Specifies the {{rlp|object#Alignment|alignment requirement}} of a type or an object.

===Syntax===
{{sdsc begin}}
{{sdsc|{{ttb|alignas(}} {{spar|expression}} {{ttb|)}}}}
{{sdsc|{{ttb|alignas(}} {{spar|type-id}} {{ttb|)}}}}
{{sdsc|{{ttb|alignas(}} {{spar|pack}} {{ttb|...}} {{ttb|)}}}}
{{sdsc end}}

@1@ {{spar|expression}} must be an {{rlpsd|constant expression#Integral constant expression}} that evaluates to zero, or to a valid value for an {{rlpsd|object#Alignment}} or extended alignment.
@2@ Equivalent to {{box|{{c/core|alignas(alignof(}} {{spar tt|type-id}} {{c/core|))}}}}.
@3@ Equivalent to multiple alignas specifiers applied to the same declaration, one for each member of the {{rlp|parameter pack}}, which can be either type or non-type parameter pack.

===Explanation===
The {{c|alignas}} specifier may be applied to:
* the declaration or definition of a {{rlp|classes|class}};
* the declaration of a non-bitfield class data member;
* the declaration of a variable, except that it cannot be applied to the following:
** a function parameter;
** the exception parameter of a catch clause.

The object or the type declared by such a declaration will have its {{rlp|object#Alignment|alignment requirement}} equal to the strictest (largest) non-zero {{spar|expression}} of all {{tt|alignas}} specifiers used in the declaration, unless it would weaken the natural alignment of the type.

If the strictest (largest) {{tt|alignas}} on a declaration is weaker than the alignment it would have without any {{tt|alignas}} specifiers (that is, weaker than its natural alignment or weaker than {{tt|alignas}} on another declaration of the same object or type), the program is ill-formed:
{{source|
struct alignas(8) S {};
struct alignas(1) U { S s; }; // error: alignment of U would have been 8 without alignas(1)
}}

Invalid non-zero alignments, such as {{c|alignas(3)}} are ill-formed.

Valid non-zero alignments that are weaker than another {{c|alignas}} on the same declaration are ignored.

{{c|alignas(0)}} is always ignored.

===Notes===
As of the ISO C11 standard, the C language has the {{c|_Alignas}} keyword and defines {{c|alignas}} as a preprocessor macro expanding to the keyword in the header {{ltt|c/types|&lt;stdalign.h&gt;}}.

In C++, this is a keyword, and
{{rev begin}}
{{rev|until=c++20|
the headers {{ltt|cpp/header/cstdalign|&lt;stdalign.h&gt;}} and {{header|cstdalign}} do not define such macro. They do, however, define the macro constant {{c|__alignas_is_defined}}.
}}
{{rev|since=c++20|
the header {{ltt|cpp/header/cstdalign|&lt;stdalign.h&gt;}} does not define such macro. It does, however, define the macro constant {{c|__alignas_is_defined}}.
}}
{{rev end}}

===Keywords===
{{ltt|cpp/keyword/alignas}}

===Example===
{{example
|code=
#include &lt;iostream&gt;

// Every object of type struct_float will be aligned
// to alignof(float) boundary (usually 4):
struct alignas(float) struct_float
{
    // your definition here
};

// Every object of type sse_t will be aligned to 32-byte boundary:
struct alignas(32) sse_t
{
    float sse_data[4];
};

int main()
{
    struct default_aligned
    {
        float data[4];
    } a, b, c;
    sse_t x, y, z;

    std::cout
        &lt;&lt; "alignof(struct_float) = " &lt;&lt; alignof(struct_float) &lt;&lt; '\n'
        &lt;&lt; "sizeof(sse_t) = " &lt;&lt; sizeof(sse_t) &lt;&lt; '\n'
        &lt;&lt; "alignof(sse_t) = " &lt;&lt; alignof(sse_t) &lt;&lt; '\n'
        &lt;&lt; std::hex &lt;&lt; std::showbase
        &lt;&lt; "&amp;a: " &lt;&lt; &amp;a &lt;&lt; "\n"
           "&amp;b: " &lt;&lt; &amp;b &lt;&lt; "\n"
           "&amp;c: " &lt;&lt; &amp;c &lt;&lt; "\n"
           "&amp;x: " &lt;&lt; &amp;x &lt;&lt; "\n"
           "&amp;y: " &lt;&lt; &amp;y &lt;&lt; "\n"
           "&amp;z: " &lt;&lt; &amp;z &lt;&lt; '\n';
}
|p=true
|output=
alignof(struct_float) = 4
sizeof(sse_t) = 32
alignof(sse_t) = 32
&amp;a: 0x7fffcec89930
&amp;b: 0x7fffcec89940
&amp;c: 0x7fffcec89950
&amp;x: 0x7fffcec89960
&amp;y: 0x7fffcec89980
&amp;z: 0x7fffcec899a0
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1437|std=C++11|before=alignas could be used in alias declarations|after=prohibited}}
{{dr list item|wg=cwg|dr=2354|std=C++11|before=alignas could be applied to the declaration of an enumeration|after=prohibited}}
{{dr list end}}

===References===
{{ref std c++23}}
{{ref std|section=9.12.4|title=Carries dependency attribute|id=dcl.attr.depend}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=9.12.3|title=Carries dependency attribute|id=dcl.attr.depend}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=10.6.3|title=Carries dependency attribute|id=dcl.attr.depend}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=7.6.4|title=Carries dependency attribute|id=dcl.attr.depend}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=7.6.4|title=Carries dependency attribute|id=dcl.attr.depend}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc alignof}}
{{dsc inc|cpp/types/dsc alignment_of}}
{{dsc see c|c/language/_Alignas|_Alignas, alignas}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}