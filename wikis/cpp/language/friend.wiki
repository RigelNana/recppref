{{title|Friend declaration}}
{{cpp/language/classes/navbar}}
The friend declaration appears in a {{rlp|class|class body}} and grants a function or another class access to private and protected members of the class where the friend declaration appears.

===Syntax===
{{sdsc begin}}
{{sdsc|num=1|{{ttb|friend}} {{spar|function-declaration}}}}
{{sdsc|num=2|{{ttb|friend}} {{spar|function-definition}}}}
{{sdsc|num=3|notes={{mark until c++26}}|{{ttb|friend}} {{spar|elaborated-type-specifier}} {{ttb|;}}}}
{{sdsc|num=4|notes={{mark since c++11}}&lt;br&gt;{{mark until c++26}}|
{{ttb|friend}} {{spar|simple-type-specifier}} {{ttb|;}}
{{ttb|friend}} {{spar|typename-specifier}} {{ttb|;}}
}}
{{sdsc|num=5|notes={{mark since c++26}}|{{ttb|friend}} {{spar|friend-type-specifier-list}} {{ttb|;}}}}
{{sdsc end}}

@1,2@ A function friend declaration.

@3-5@ A class friend declaration.

{{par begin}}
{{par|{{spar|function-declaration}}|a {{rlp|function|function declaration}}}}
{{par|{{spar|function-definition}}|a {{rlpsd|function#Function definition}}}}
{{par|{{spar|elaborated-type-specifier}}|an {{rlp|elaborated type specifier}}}}
{{par|{{spar|simple-type-specifier}}|a {{rlp|declarations#Specifiers|simple type specifier}}}}
{{par|{{spar|typename-specifier}}|the keyword {{c/core|typename}} followed by a qualified identifier or qualified {{rlp|templates#Template identifiers|simple template identifier}}}}
{{par|{{spar|friend-type-specifier-list}}|a non-empty comma-separated list of {{spar|simple-type-specifier}}, {{spar|elaborated-type-specifier}}, and {{spar sep|typename-specifier}}s, each specifier can be followed by an ellipsis ({{tt|...}})}}
{{par end}}

===Description===
@1@ Designates a function or several functions as friends of this class:
{{source|
class Y
{
    int data; // private member
    
    // the non-member function operator&lt;&lt; will have access to Y's private members
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Y&amp; o);
    friend char* X::foo(int); // members of other classes can be friends too
    friend X::X(char), X::~X(); // constructors and destructors can be friends
};

// friend declaration does not declare a member function
// this operator&lt;&lt; still needs to be defined, as a non-member
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Y&amp; y)
{
    return out &lt;&lt; y.data; // can access private member Y::data
}
}}

@2@ (only allowed in non-{{rlp|class#Local classes|local}} class definitions) Defines a non-member function, and makes it a friend of this class at the same time. Such non-member function is always {{rlp|inline}}{{rev inl|since=c++20|, unless it is attached to a {{rlp|modules|named module}}}}.
{{source|1=
class X
{
    int a;
    
    friend void friend_set(X&amp; p, int i)
    {
        p.a = i; // this is a non-member function
    }
public:
    void member_set(int i)
    {
        a = i; // this is a member function
    }
};
}}

@3,4@ Designates a class as a friend of this class. This means that the friend's member declarations and definitions can access private and protected members of this class and also that the friend can inherit from private and protected members of this class.

:@3@ The class is named by {{spar|elaborated-type-specifier}}. The name of the class that is used in this friend declaration does not need to be previously declared.

:@4@ The class is named by {{spar|simple-type-specifier}} or {{spar|typename-specifier}}. If the named type is not a class type, this friend declaration is ignored. This declaration will not forward declare a new type.

@5@ Designates all classes in {{spar|friend-type-specifier-list}} as a friend of this class. This means that the friends' member declarations and definitions can access private and protected members of this class and also that the friends can inherit from private and protected members of this class. If a named type is not a class type, it is ignored in this friend declaration.

@@ Each specifier in {{spar|friend-type-specifier-list}} names a class if the specifier is not followed by an ellipsis, otherwise {{rlp|parameter pack#Friend declarations|pack expansion}} applies.
{{source|1=
class Y {};

class A
{
    int data; // private data member
    
    class B {}; // private nested type
    
    enum { a = 100 }; // private enumerator
    
    friend class X; // friend class forward declaration (elaborated class specifier)
    friend Y; // friend class declaration (simple type specifier) (since C++11)
    
    // the two friend declarations above can be merged since C++26:
    // friend class X, Y;
};

class X : A::B // OK: A::B accessible to friend
{
    A::B mx; // OK: A::B accessible to member of friend
    
    class Y
    {
        A::B my; // OK: A::B accessible to nested member of friend
    };
    
    int v[A::a]; // OK: A::a accessible to member of friend
};
}}

===Template friends===
Both {{rlp|function template}} and {{rlp|class template}} declarations may appear with the {{tt|friend}} specifier in any non-local class or class template (although only function templates may be defined within the class or class template that is granting friendship). In this case, every specialization of the template becomes a friend, whether it is implicitly instantiated, partially specialized, or explicitly specialized.

{{source|
class A
{
    template&lt;typename T&gt;
    friend class B; // every B&lt;T&gt; is a friend of A
    
    template&lt;typename T&gt;
    friend void f(T) {} // every f&lt;T&gt; is a friend of A
};
}}

Friend declarations cannot refer to partial specializations, but can refer to full specializations:

{{source|
template&lt;class T&gt;
class A {};      // primary

template&lt;class T&gt;
class A&lt;T*&gt; {};  // partial

template&lt;&gt;
class A&lt;int&gt; {}; // full

class X
{
    template&lt;class T&gt;
    friend class A&lt;T*&gt;;  // Error
    
    friend class A&lt;int&gt;; // OK
};
}}

When a friend declaration refers to a full specialization of a function template, the keyword {{c/core|inline}}{{rev inl|since=c++11|, {{c/core|constexpr}}}}{{rev inl|since=c++20|, {{c/core|consteval}}}} and default arguments cannot be used:

{{source|1=
template&lt;class T&gt;
void f(int);

template&lt;&gt;
void f&lt;int&gt;(int);

class X
{
    friend void f&lt;int&gt;(int x = 1); // error: default args not allowed
};
}}

&lt;!-- based on post-CWG 1862 wording of [temp.friend]p4--&gt;
A template friend declaration can name a member of a class template A, which can be either a member function or a member type (the type must use {{rlp|elaborated type specifier|elaborated-type-specifier}}). Such declaration is only well-formed if the last component in its nested-name-specifier (the name to the left of the last {{ttb|::}}) is a simple-template-id (template name followed by argument list in angle brackets) that names the class template. The template parameters of such template friend declaration must be deducible from the simple-template-id.

In this case, the member of any specialization of either A or partial specializations of A becomes a friend. This does not involve instantiating the primary template A or partial specializations of A: the only requirements are that the deduction of the template parameters of A from that specialization succeeds, and that substitution of the deduced template arguments into the friend declaration produces a declaration that would be a valid redeclaration of the member of the specialization:

{{source|
// primary template
template&lt;class T&gt;
struct A
{ 
    struct B {};
    
    void f();
    
    struct D { void g(); };
    
    T h();
    
    template&lt;T U&gt;
    T i();
};

// full specialization
template&lt;&gt;
struct A&lt;int&gt;
{
    struct B {};
    
    int f();
    
    struct D { void g(); };
    
    template&lt;int U&gt;
    int i();
};

// another full specialization
template&lt;&gt;
struct A&lt;float*&gt;
{
    int *h();
};

// the non-template class granting friendship to members of class template A
class X
{
    template&lt;class T&gt;
    friend struct A&lt;T&gt;::B; // all A&lt;T&gt;::B are friends, including A&lt;int&gt;::B
    
    template&lt;class T&gt;
    friend void A&lt;T&gt;::f(); // A&lt;int&gt;::f() is not a friend because its signature
                           // does not match, but e.g. A&lt;char&gt;::f() is a friend
    
//  template&lt;class T&gt;
//  friend void A&lt;T&gt;::D::g(); // ill-formed, the last part of the nested-name-specifier,
//                            // D in A&lt;T&gt;::D::, is not simple-template-id
    
    template&lt;class T&gt;
    friend int* A&lt;T*&gt;::h(); // all A&lt;T*&gt;::h are friends:
                            // A&lt;float*&gt;::h(), A&lt;int*&gt;::h(), etc
    
    template&lt;class T&gt; 
    template&lt;T U&gt;       // all instantiations of A&lt;T&gt;::i() and A&lt;int&gt;::i() are friends, 
    friend T A&lt;T&gt;::i(); // and thereby all specializations of those function templates
};
}}

{{rev begin}}
{{rev|since=c++11|
{{rlp|template parameters#Default template arguments|Default template arguments}} are only allowed on template friend declarations if the declaration is a definition and no other declarations of this function template appear in this translation unit.
}}
{{rev end}}

===Template friend operators===
A common use case for template friends is declaration of a non-member operator overload that acts on a class template, e.g. {{c|operator&lt;&lt;(std::ostream&amp;, const Foo&lt;T&gt;&amp;)}} for some user-defined {{c|Foo&lt;T&gt;}}.

Such operator can be defined in the class body, which has the effect of generating a separate non-template {{c|operator&lt;&lt;}} for each {{tt|T}} and makes that non-template {{c|operator&lt;&lt;}} a friend of its {{c|Foo&lt;T&gt;}}:

{{example|code=
#include &lt;iostream&gt;

template&lt;typename T&gt;
class Foo
{
public:
    Foo(const T&amp; val) : data(val) {}
private:
    T data;
    
    // generates a non-template operator&lt;&lt; for this T
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Foo&amp; obj)
    {
        return os &lt;&lt; obj.data;
    }
};

int main()
{
    Foo&lt;double&gt; obj(1.23);
    std::cout &lt;&lt; obj &lt;&lt; '\n';
}
|output=1.23
}}

or the function template has to be declared as a template before the class body, in which case the friend declaration within {{c|Foo&lt;T&gt;}} can refer to the full specialization of {{c|operator&lt;&lt;}} for its {{tt|T}}:

{{example|code=
#include &lt;iostream&gt;

template&lt;typename T&gt;
class Foo; // forward declare to make function declaration possible

template&lt;typename T&gt; // declaration
std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Foo&lt;T&gt;&amp;);

template&lt;typename T&gt;
class Foo
{
public:
    Foo(const T&amp; val) : data(val) {}
private:
    T data;
    
    // refers to a full specialization for this particular T 
    friend std::ostream&amp; operator&lt;&lt; &lt;&gt; (std::ostream&amp;, const Foo&amp;);
    
    // note: this relies on template argument deduction in declarations
    // can also specify the template argument with operator&lt;&lt; &lt;T&gt;"
};

// definition
template&lt;typename T&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Foo&lt;T&gt;&amp; obj)
{
    return os &lt;&lt; obj.data;
}

int main()
{
    Foo&lt;double&gt; obj(1.23);
    std::cout &lt;&lt; obj &lt;&lt; '\n';
}
}}

===Linkage===
{{rlp|storage duration|Storage class specifiers}} are not allowed in friend declarations.

{{rrev|since=c++20|
If a function or function template is first declared and defined in a friend declaration, and the enclosing class is defined within an {{rlp|modules#Exporting declarations and definitions|exporting declarations}}, its name has the same linkage as the name of the enclosing class.
}}

{{rev inl|until=c++20|If}}{{rev inl|since=c++20|Otherwise, if}} a function or function template is declared in a friend declaration, and a {{rlp|conflicting declarations#Corresponding declarations|corresponding non-friend declaration}} is reachable, the name has the linkage determined from that prior declaration.

Otherwise, the linkage of the name introduced by a friend declaration is determined as usual.

===Notes===
Friendship is not transitive (a friend of your friend is not your friend).

Friendship is not inherited (your friend's children are not your friends, and your friends are not your children's friends).

{{rlp|access|Access specifiers}} have no effect on the meaning of friend declarations (they can appear in {{c/core|private:}} or in {{c/core|public:}} sections, with no difference).

A friend class declaration cannot define a new class ({{c|friend class X {};}} is an error).

When a local class declares an unqualified function or class as a friend, only functions and classes in the innermost non-class scope are {{rlp|lookup|looked up}}, not the global functions:
{{source|
class F {};

int f();

int main()
{
    extern int g();
    
    class Local // Local class in the main() function
    {
        friend int f(); // Error, no such function declared in main()
        friend int g(); // OK, there is a declaration for g in main()
        friend class F; // friends a local F (defined later)
        friend class ::F; // friends the global F
    };
    
    class F {}; // local F
}
}}

A name first declared in a friend declaration within a class or class template {{tt|X}} becomes a member of the innermost enclosing namespace of {{tt|X}}, but is not visible for lookup (except argument-dependent lookup that considers {{tt|X}}) unless a matching declaration at namespace scope is provided - see {{rlp|namespace#Namespaces|namespaces}} for details.

{{feature test macro|__cpp_variadic_friend|Variadic friend declarations|value=202403L|std=C++26}}

===Keywords===
{{ltt|cpp/keyword/friend}}

===Example===
{{example
|Stream insertion and extraction operators are often declared as non-member friends:
|code=
#include &lt;iostream&gt;
#include &lt;sstream&gt;

class MyClass
{
    int i;                   // friends have access to non-public, non-static
    static inline int id{6}; // and static (possibly inline) members
    
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyClass&amp;);
    friend std::istream&amp; operator&gt;&gt;(std::istream&amp; in, MyClass&amp;);
    friend void change_id(int);
public:
    MyClass(int i = 0) : i(i) {}
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyClass&amp; mc)
{
    return out &lt;&lt; "MyClass::id = " &lt;&lt; MyClass::id &lt;&lt; "; i = " &lt;&lt; mc.i;
}

std::istream&amp; operator&gt;&gt;(std::istream&amp; in, MyClass&amp; mc)
{
    return in &gt;&gt; mc.i;
}

void change_id(int id) { MyClass::id = id; }

int main()
{
    MyClass mc(7);
    std::cout &lt;&lt; mc &lt;&lt; '\n';
//  mc.i = 333*2;  // error: i is a private member
    std::istringstream("100") &gt;&gt; mc;
    std::cout &lt;&lt; mc &lt;&lt; '\n';
//  MyClass::id = 222*3;  // error: id is a private member
    change_id(9);
    std::cout &lt;&lt; mc &lt;&lt; '\n';
}
|output=
MyClass::id = 6; i = 7
MyClass::id = 6; i = 100
MyClass::id = 9; i = 100
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=45|std=C++98|before=members of a class nested in a friend&lt;br&gt;class of {{tt|T}} have no special access to {{tt|T}}|after=a nested class has the same&lt;br&gt;access as the enclosing class}}
{{dr list item|wg=cwg|dr=500|std=C++98|before=friend class of {{tt|T}} cannot inherit from private or&lt;br&gt;protected members of {{tt|T}}, but its nested class can|after=both can inherit&lt;br&gt;from such members}}
{{dr list item|wg=cwg|dr=1439|std=C++98|before=the rule targeting friend declarations in non-local&lt;br&gt;classes did not cover template declarations|after=covered}}
{{dr list item|wg=cwg|dr=1477|std=C++98|before=a name first declared in a friend declaration within a class&lt;br&gt;or class template was not visible for lookup if the matching&lt;br&gt;declaration is provided in another namespace scope|after=it is visible for&lt;br&gt;lookup in this case}}
{{dr list item|wg=cwg|dr=1804|std=C++98|before=when a member of a class template is friended, the corresponding&lt;br&gt;member of specializations of partial specializations of the class&lt;br&gt;template was not a friend of the class granting friendship|after=such members&lt;br&gt;are also friends}}
{{dr list item|wg=cwg|dr=2379|std=C++11|before=friend declarations referring to full specializations&lt;br&gt;of function templates could be declared constexpr|after=prohibited}}
{{dr list item|wg=cwg|dr=2588|std=C++98|before=the linkages of names introduced by friend declarations were unclear|after=made clear}}
{{dr list end}}

===References===
{{ref std c++23}}
{{ref std|section=11.8.4|title=Friends|id=class.friend}}
{{ref std|section=13.7.5|title=Friends|id=temp.friend}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=11.9.3|title=Friends|id=class.friend}}
{{ref std|section=13.7.4|title=Friends|id=temp.friend}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=14.3|title=Friends|id=class.friend}}
{{ref std|section=17.5.4|title=Friends|id=temp.friend}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=11.3|title=Friends|id=class.friend}}
{{ref std|section=14.5.4|title=Friends|id=temp.friend}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=11.3|title=Friends|id=class.friend}}
{{ref std|section=14.5.4|title=Friends|id=temp.friend}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=11.3|title=Friends|id=class.friend}}
{{ref std|section=14.5.3|title=Friends|id=temp.friend}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc class}}
{{dsc inc|cpp/language/dsc access}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}