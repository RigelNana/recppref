{{title|Alternative operator representations}}
{{cpp/language/expressions/navbar}}

C++ (and C) source code may be written in any non-ASCII 7-bit character set that includes the {{enwiki|ISO 646|ISO 646:1983}} invariant character set. However, several C++ operators and punctuators require characters that are outside of the ISO 646 codeset: {{tt|{, }, [, ], #, \, ^, {{!}}, ~}}. To be able to use character encodings where some or all of these symbols do not exist (such as the German {{enwiki|DIN 66003}}), C++ defines the following alternatives composed of ISO 646 compatible characters.

===Alternative tokens===
There are alternative spellings for several operators and other tokens that use non-ISO646 characters. In all respects of the language, each alternative token behaves exactly the same as its primary token, except for its spelling (the [[cpp/preprocessor/replace|stringification operator]] can make the spelling visible). The two-letter alternative tokens are sometimes called "digraphs". Despite being four-letters long, {{c|%:%:}} is also considered a digraph.

{|class="wikitable"
|-
!Primary
!Alternative
|-
|{{tt|&amp;&amp;}}
|{{ltt|cpp/keyword/and}}
|-
|{{tt|1=&amp;=}}
|{{ltt|cpp/keyword/and_eq}}
|-
|{{tt|&amp;}}
|{{ltt|cpp/keyword/bitand}}
|-
|{{tt|&amp;#124;}}
|{{ltt|cpp/keyword/bitor}}
|-
|{{tt|~}}
|{{ltt|cpp/keyword/compl}}
|-
|{{tt|!}}
|{{ltt|cpp/keyword/not}}
|-
|{{tt|1=!=}}
|{{ltt|cpp/keyword/not_eq}}
|-
|{{tt|&amp;#124;&amp;#124;}}
|{{ltt|cpp/keyword/or}}
|-
|{{tt|1=&amp;#124;=}}
|{{ltt|cpp/keyword/or_eq}}
|-
|{{tt|^}}
|{{ltt|cpp/keyword/xor}}
|-
|{{tt|1=^=}}
|{{ltt|cpp/keyword/xor_eq}}
|-
|{{tt|{}}||{{tt|&lt;%}}
|-
|{{tt|}&lt;!----&gt;}}||{{tt|%&gt;}}
|-
|{{tt|[}}||{{tt|&lt;:}}
|-
|{{tt|]}}||{{tt|:&gt;}}
|-
|{{tt|#}}||{{tt|%:}}
|-
|{{tt|##}}||{{tt|%:%:}}
|}

{{anchor|Trigraphs}}
===Trigraphs {{mark until c++17|removed=yes}}===
The following three-character groups (trigraphs) are {{rlp|translation phases|parsed before comments and string literals are recognized}}, and each appearance of a trigraph is replaced by the corresponding primary character:

{|class="wikitable"
|-style="text-align: left;"
!Primary
!Trigraph
|-
|{{tt|{}}||{{tt|??&lt;}}
|-
|{{tt|}}}||{{tt|??&gt;}}
|-
|{{tt|[}}||{{tt|??(}}
|-
|{{tt|]}}||{{tt|??)}}
|-
|{{tt|#}}||{{tt|1=??=}}
|-
|{{tt|\}}||{{tt|??/}}
|-
|{{tt|^}}||{{tt|??'}}
|-
|{{tt|&lt;nowiki&gt;|&lt;/nowiki&gt;}}||{{tt|??!}}
|-
|{{tt|~}}||{{tt|??-}}
|}

Because trigraphs are processed early, a comment such as {{c|// Will the next line be executed?????/}} will effectively comment out the following line, and the string literal such as {{c|"Enter date ??/??/??"}} is parsed as {{c|"Enter date \\??"}}.

===Notes===
The characters {{c|&amp;}} and {{c|!}} are invariant under ISO-646, but alternatives are provided for the tokens that use these characters anyway to accommodate even more restrictive historical charsets&lt;!-- best reference found so far "The Danish delegation did not, in fact, have a way of representing those characters on their terminals" from https://groups.google.com/d/msg/comp.std.c/eYbj0lCIvn4/89oK8U6JpqEJ , but it doesn't specifically call out &amp; and ! --&gt;.

There is no alternative spelling (such as {{c|eq}}) for the equality operator {{c|1===}} because the character {{c|1==}} was present in all supported charsets.

===Compatibility with C===
The same words are defined in the C programming language in the include file {{header|iso646.h|lang=c}} as macros. Because in C++ these are built into the language, the C++ version of {{ltt|cpp/header/ciso646|&lt;iso646.h&gt;}}, as well as {{header|ciso646}}, does not define anything. The non-word digraphs (e.g {{c|&lt;%}}), however, are part of the core language and can be used without including any header (otherwise, they would be unusable on any charset that lacks {{c|#}}).

===Keywords===
{{ltt|cpp/keyword/and}},
{{ltt|cpp/keyword/and_eq}},
{{ltt|cpp/keyword/bitand}},
{{ltt|cpp/keyword/bitor}},
{{ltt|cpp/keyword/compl}},
{{ltt|cpp/keyword/not}},
{{ltt|cpp/keyword/not_eq}},
{{ltt|cpp/keyword/or}},
{{ltt|cpp/keyword/or_eq}},
{{ltt|cpp/keyword/xor}},
{{ltt|cpp/keyword/xor_eq}}

===Example===
{{example
|The following example demonstrates the use of several alternative tokens.
|code=
%:include &lt;iostream&gt;

struct X
&lt;%
    compl X() &lt;%%&gt; // destructor
    X() &lt;%%&gt;
    X(const X bitand) = delete; // copy constructor
    // X(X and) = delete; // move constructor
    
    bool operator not_eq(const X bitand other)
    &lt;%
       return this not_eq bitand other;
    %&gt;
%&gt;;

int main(int argc, char* argv&lt;::&gt;) 
&lt;%
    // lambda with reference-capture:
    auto greet = &lt;:bitand:&gt;(const char* name)
    &lt;%
        std::cout &lt;&lt; "Hello " &lt;&lt; name
                  &lt;&lt; " from " &lt;&lt; argv&lt;:0:&gt; &lt;&lt; '\n';
    %&gt;;
    
    if (argc &gt; 1 and argv&lt;:1:&gt; not_eq nullptr)
        greet(argv&lt;:1:&gt;);
    else
        greet("Anon");
%&gt;
|p=true
|output=Hello Anon from ./a.out
}}

===References===
{{ref std c++23}}
{{ref std|section=5.5|title=Alternative tokens|id=lex.digraph}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=5.5|title=Alternative tokens|id=lex.digraph}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=5.5|title=Alternative tokens|id=lex.digraph}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=2.4|title=Trigraph sequences|id=lex.trigraph}}
{{ref std|section=2.6|title=Alternative tokens|id=lex.digraph}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=2.4|title=Trigraph sequences|id=lex.trigraph}}
{{ref std|section=2.6|title=Alternative tokens|id=lex.digraph}}
{{ref std end}}
{{ref std c++03}}
{{ref std|section=2.3|title=Trigraph sequences|id=lex.trigraph}}
{{ref std|section=2.5|title=Alternative tokens|id=lex.digraph}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=2.3|title=Trigraph sequences|id=lex.trigraph}}
{{ref std|section=2.5|title=Alternative tokens|id=lex.digraph}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc see c|c/language/operator alternative|Alternative operators and tokens|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}