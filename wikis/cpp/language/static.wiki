{{title|{{tt|static}} members}}
{{cpp/language/classes/navbar}}

Inside a class definition, the keyword {{ltt|cpp/keywords/static}} declares members that are not bound to class instances.

Outside a class definition, it has a different meaning: see {{rlp|storage duration}}.

===Syntax===
A declaration for a static member is a {{rlp|class#Member specification|member declaration}} whose declaration specifiers contain the keyword {{c|static}}. The keyword {{c|static}} usually appears before other specifiers (which is why the syntax is often informally described as {{c|static}} {{spar|data-member}} or {{c|static}} {{spar|member-function}}), but may appear anywhere in the specifier sequence.

The name of any static data member and static member function must be different from the name of the containing class.

===Explanation===
Static members of a class are not associated with the objects of the class: they are independent variables with static{{rev inl|since=c++11| or thread}} {{rlp|storage duration|storage duration}} or regular functions.

The {{c|static}} keyword is only used with the declaration of a static member, inside the class definition, but not with the definition of that static member:

{{source|1=
class X { static int n; }; // declaration (uses 'static')
int X::n = 1;              // definition (does not use 'static')
}}

The declaration inside the class body is not a definition and may declare the member to be of {{rlp|incomplete type}} (other than {{c|void}}), including the type in which the member is declared:

{{source|
struct Foo;

struct S
{
    static int a[]; // declaration, incomplete type
    static Foo x;   // declaration, incomplete type
    static S s;     // declaration, incomplete type (inside its own definition)
};

int S::a[10]; // definition, complete type
struct Foo {};
Foo S::x;     // definition, complete type
S S::s;       // definition, complete type
}}

{{rrev|since=c++11|
However, if the declaration uses {{ltt|cpp/language/constexpr}}{{rev inl|since=c++17| or {{ltt|cpp/language/inline}}}} specifier, the member must be declared to have complete type.
}}

To refer to a static member {{tt|m}} of class {{tt|T}}, two forms may be used: qualified name {{tt|T::m}} or member access expression {{tt|E.m}} or {{tt|E-&gt;m}}, where {{tt|E}} is an expression that evaluates to {{tt|T}} or {{tt|T*}} respectively. When in the same class scope, the qualification is unnecessary:

{{source|1=
struct X
{
    static void f(); // declaration
    static int n;    // declaration
};

X g() { return X(); } // some function returning X

void f()
{
    X::f();  // X::f is a qualified name of static member function
    g().f(); // g().f is member access expression referring to a static member function
}

int X::n = 7; // definition

void X::f() // definition
{
    n = 1; // X::n is accessible as just n in this scope
}
}}

Static members obey the {{rlp|access|class member access rules (private, protected, public)}}.

====Static member functions====
Static member functions are not associated with any object. When called, they have no {{c|this}} pointer.

Static member functions cannot be {{c|virtual}}, {{c|const}}, {{c|volatile}}, or {{rlp|member functions#ref-qualified member functions|ref-qualified}}.

The address of a static member function may be stored in a regular {{rlp|pointer#Pointers to functions|pointer to function}}, but not in a {{rlp|pointer#Pointers to member functions|pointer to member function}}.

====Static data members====
Static data members are not associated with any object. They exist even if no objects of the class have been defined. There is only one instance of the static data member in the entire program with static {{rlp|storage duration}}{{rev inl|since=c++11|, unless the keyword {{ltt|cpp/keyword/thread_local}} is used, in which case there is one such object per thread with thread storage duration}}.

Static data members cannot be {{c|mutable}}.

Static data members of a class in namespace scope have {{rlp|storage duration|external linkage}} if the class itself has external linkage (is not a member of {{rlp|namespace#Unnamed namespaces|unnamed namespace}}). Local classes (classes defined inside functions) and unnamed classes, including member classes of unnamed classes, cannot have static data members.

{{rrev|since=c++17|
A static data member may be declared {{ltt|cpp/language/inline}}. An inline static data member can be defined in the class definition and may specify an initializer. It does not need an out-of-class definition:
{{source|1=
struct X
{
    inline static int fully_usable = 1; // No out-of-class definition required, ODR-usable
    inline static const std::string class_name{"X"}; // Likewise

    static const int non_addressable = 1; // C.f. non-inline constants, usable
                                          // for its value, but not ODR-usable
    // static const std::string class_name{"X"}; // Non-integral declaration of this
                                                 // form is disallowed entirely
};
}}
}}

====Constant static members====
If a static data member of integral or enumeration type is declared {{c|const}} (and not {{c|volatile}}), it can be initialized with an {{rlp|initialization|initializer}} in which every expression is a {{rlp|constexpr|constant expression}}, right inside the class definition:

{{source|1=
struct X
{
    const static int n = 1;
    const static int m{2}; // since C++11
    const static int k;
};
const int X::k = 3;
}}

{{rrev|since=c++11|
If a static data member of {{named req|LiteralType}} is declared {{c|constexpr}}, it must be initialized with an initializer in which every expression is a constant expression, right inside the class definition:

{{source|1=
struct X
{
    constexpr static int arr[] = { 1, 2, 3 };        // OK
    constexpr static std::complex&lt;double&gt; n = {1,2}; // OK
    constexpr static int k; // Error: constexpr static requires an initializer
};
}}
}}

If a const {{rev inl|since=c++17|non-inline}} static data member {{rev inl|since=c++11|until=c++17|or a constexpr static data member}} is {{rlps|definition#ODR-use}}, a definition at namespace scope is still required, but it cannot have an initializer.

{{rrev|since=c++17|
A {{c|constexpr}} static data member is implicitly {{c|inline}} and does not need to be redeclared at namespace scope. This redeclaration without an initializer (formerly required) is still permitted, but is deprecated.
}}

{{source|1=
struct X
{
    static const int n = 1;
    static constexpr int m = 4;
};

const int *p = &amp;X::n, *q = &amp;X::m; // X::n and X::m are ODR-used
const int X::n;             // … so a definition is necessary
constexpr int X::m;         // … (except for X::m in C++17)
}}

===Keywords===
{{ltt|cpp/keyword/static}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=194|std=C++98|before=(static) member function names can be the same as the class name|after=naming restriction added (including&lt;br&gt;{{rlp|member functions#Defect report|non-static member functions}})}}
{{dr list end}}

===References===
{{ref std c++23}}
{{ref std|section=11.4.9|title=Static members|id=class.static}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=11.4.8|title=Static members|id=class.static}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=12.2.3|title=Static members|id=class.static}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=9.4|title=Static members|id=class.static}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=9.4|title=Static members|id=class.static}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=9.4|title=Static members|id=class.static}}
{{ref std end}}

===See also===
* {{rlp|storage_duration|{{tt|static}} storage specifier}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}