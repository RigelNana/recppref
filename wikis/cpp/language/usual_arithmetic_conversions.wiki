{{title|Usual arithmetic conversions}}
{{cpp/language/expressions/navbar}}

Many binary operators that expect operands of {{rlp|type|arithmetic}} or {{rlp|enum|enumeration}} type cause conversions and yield result types in a similar way. The purpose is to yield a common type, which is also the type of the result. This pattern is called the ''usual arithmetic conversions''.

===Definition===
Usual arithmetic conversions are defined as follows:
====Stage 1====
Applies {{rlpsd|implicit conversion#Lvalue-to-rvalue conversion}} to both operands, the resulting prvalues are used in place of the original operands for the remaining process.

====Stage 2====
{{rrev|since=c++11|
* If either operand is of {{rlp|enum#Scoped enumerations|scoped enumeration type}}, no conversions are performed; if the other operand does not have the same type, the expression is ill-formed.
* Otherwise, proceed to the next stage.
}}

====Stage 3====
{{rrev|since=c++26|
* If either operand is of {{rlp|enum|enumeration type}}, and the other operand is of a different enumeration type or a floating-point type, the expression is ill-formed.
* Otherwise, proceed to the next stage.
}}

====Stage 4====
* If either operand is of {{rlp|types#Floating-point types|floating-point type}}, the following rules are applied:
:* If both operands have the same type, no further conversion will be performed.
:* Otherwise, if one of the operands is of a non-floating-point type, that operand is converted to the type of the other operand.
:* Otherwise, if the {{lsd|#Floating-point conversion rank}}s of the types of the operands are {{rev inl|since=c++23|ordered but}} not equal, then the operand of the type with the lesser floating-point conversion rank is converted to the type of the other operand.
{{rrev|since=c++23|
:* Otherwise, if the floating-point conversion ranks of the types of the operands are equal, then the operand with the lesser {{lsd|#Floating-point conversion subrank}} is converted to the type of the other operand.
:* Otherwise, the expression is ill-formed.
}}
* Otherwise, both operands are of integer types, proceed to the next stage.

====Stage 5====
Both operands are converted to a common type {{tt|C}}. Given the types {{tt|T1}} and {{tt|T2}} as the promoted type ({{rlp|implicit conversion#Integral promotion|under the rules of integral promotions}}) of the operands, the following rules are applied to determine {{tt|C}}:
* If {{tt|T1}} and {{tt|T2}} are the same type, {{tt|C}} is that type.
* Otherwise, if {{tt|T1}} and {{tt|T2}} are both signed integer types or both unsigned integer types, {{tt|C}} is the type of greater [[#Integer conversion rank|integer conversion rank]].
* Otherwise, one type between {{tt|T1}} and {{tt|T2}} is an signed integer type {{tt|S}}, the other type is an unsigned integer type {{tt|U}}. Apply the following rules:
:* If the integer conversion rank of {{tt|U}} is greater than or equal to the integer conversion rank of {{tt|S}}, {{tt|C}} is {{tt|U}}.
:* Otherwise, if {{tt|S}} can represent all of the values of {{tt|U}}, {{tt|C}} is {{tt|S}}.
:* Otherwise, {{tt|C}} is the unsigned integer type corresponding to {{tt|S}}.

{{rrev|since=c++20|until=c++26|
If one operand is of enumeration type and the other operand is of a different enumeration type or a floating-point type, this behavior is deprecated.
}}

===Integer conversion rank===
Every {{rlp|types#Integer types|integer type}} has an ''integer conversion rank'' defined as follows:
* No two signed integer types other than {{c/core|char}} and {{c/core|signed char}} (if {{c/core|char}} is signed) have the same rank, even if they have the same representation.
* The rank of a signed integer type is greater than the rank of any signed integer type with a smaller width.
* The ranks of the following integer types decrease in order:
{{rrev|since=c++11|
:* {{c/core|long long}}
}}
:* {{c/core|long}}
:* {{c/core|int}}
:* {{c/core|short}}
:* {{c/core|signed char}}
* The rank of any unsigned integer type equals the rank of the corresponding signed integer type.
{{rrev|since=c++11|
* The rank of any standard integer type is greater than the rank of any extended integer type with the same width.
}}
* The rank of {{c/core|bool}} is less than the rank of all standard integer types.
* The ranks of encoding character types ({{c/core|char}} {{rev inl|since=c++20|, {{c/core|char8_t}}}}{{rev inl|since=c++11|, {{c/core|char16_t}}, {{c/core|char32_t}},}} and {{c/core|wchar_t}}) equal the ranks of their {{rlp|types#Character types|underlying types}}, which means:
:* The rank of {{c/core|char}} equals the rank of {{c/core|signed char}} and {{c/core|unsigned char}}.
{{rev begin}}
{{rev|since=c++20|
:* The rank of {{c/core|char8_t}} equals the rank of {{c/core|unsigned char}}.
}}
{{rev|since=c++11|
:* The rank of {{c/core|char16_t}} equals the rank of {{lc|std::uint_least16_t}}.
:* The rank of {{c/core|char32_t}} equals the rank of {{lc|std::uint_least32_t}}.
}}
{{rev end}}
:* The rank of {{c/core|wchar_t}} equals the rank of its implementation-defined underlying type.
{{rrev|since=c++11|
* The rank of any extended signed integer type relative to another extended signed integer type with the same width is implementation-defined, but still subject to the other rules for determining the integer conversion rank.
}}
* For all integer types {{tt|T1}}, {{tt|T2}}, and {{tt|T3}}, if {{tt|T1}} has greater rank than {{tt|T2}} and {{tt|T2}} has greater rank than {{tt|T3}}, then {{tt|T1}} has greater rank than {{tt|T3}}.

The integer conversion rank is also used in the definition of {{rlpsd|implicit conversion#Integral promotion}}.

===Floating-point conversion rank and subrank===
====Floating-point conversion rank====
Every {{rlp|types#Floating-point types|floating-point type}} has a ''floating-point conversion rank'' defined as follows:
* The ranks of the standard floating-point types decrease in order:
** {{c/core|long double}}
** {{c/core|double}}
** {{c/core|float}}
{{rrev|since=c++23|
* The rank of a floating-point type {{tt|T}} is greater than the rank of any floating-point type whose set of values is a proper subset of the set of values of {{tt|T}}.
* Two extended floating-point types with the same set of values have equal ranks.
* An extended floating-point type with the same set of values as exactly one cv-unqualified standard floating-point type has a rank equal to the rank of that standard floating-point type.
* An extended floating-point type with the same set of values as more than one cv-unqualified standard floating-point type has a rank equal to the rank of {{c/core|double}}.
}}


{{rrev|since=c++23|
====Floating-point conversion subrank====
Floating-point types that have equal floating-point conversion ranks are ordered by ''floating-point conversion subrank''. The subrank forms a total order among types with equal ranks.

The types {{tt|std::float16_t}}, {{tt|std::float32_t}}, {{tt|std::float64_t}}, and {{tt|std::float128_t}} ([[cpp/types/floating-point|fixed width floating-point types]]) have a greater conversion subrank than any standard floating-point type with equal conversion rank. Otherwise, the conversion subrank order is implementation-defined.
}}

====Usage====
The floating-point conversion rank and subrank are also used to
* determine whether a conversion between different floating-point types {{rlp|implicit conversion#Floating-point conversions|can be implicit}} or is a {{rlp|list initialization#Narrowing conversions|narrowing conversion}},
* {{rlp|overload resolution#Ranking of implicit conversion sequences|distinguish the conversion sequences}} in overload resolution,
{{rrev|since=c++23|
* determine the actual type extracted by {{l2tf std|cpp/locale/num_get/get}} for the extraction of an extended floating-point type using {{ltt|cpp/io/basic_istream/operator gtgt|std::basic_istream::operator&gt;&gt;}},
* determinte the actual type inserted by {{l2tf std|cpp/locale/num_put/put}} for the insertion of an extended floating-point type using {{ltt|cpp/io/basic_ostream/operator ltlt|std::basic_ostream::operator&lt;&lt;}},
}}
* determine whether {{lc|std::complex}}'s [[cpp/numeric/complex/complex|converting constructor]] is explicit, or
* determine the common floating-point type if the arguments of different floating-point types are passed to [[cpp/numeric/math|common]] or [[cpp/numeric/special functions|special]] math functions.

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1642|std=C++98|before=usual arithmetic conversions might involve lvalues|after=applies lvalue-to-rvalue conversions first}}
{{dr list item|wg=cwg|dr=2528|std=C++20|before=the three-way comparison between {{c/core|unsigned char}}&lt;br&gt;and {{c/core|unsigned int}} is ill-formed because&lt;br&gt;of the intermediate integral promotion&lt;ref&gt;Before the resolution, {{c/core|unsigned char}} is promoted to {{c/core|int}} at the beginning of stage 5, then it is converted to {{c/core|unsigned int}}. However, the latter conversion is narrowing, which makes the three-way comparison ill-formed.&lt;/ref&gt;|after=determines the common type based&lt;br&gt;on the promoted types, without&lt;br&gt;actually promoting the operands&lt;ref&gt;After the resolution, the common type is still {{c/core|unsigned int}}. The difference is that {{c/core|unsigned char}} is directly converted to {{c/core|unsigned int}} without the intermediate integral promotion. The conversion is not narrowing and hence the three-way comparison is well-formed.&lt;/ref&gt;}}
{{dr list item|wg=cwg|dr=2892|std=C++98|before=when both operands are of the same&lt;br&gt;floating-point type, the meaning of “no&lt;br&gt;further conversion is needed” was unclear|after=changed to “no further&lt;br&gt;conversion will be performed”}}
{{dr list end}}
&lt;references/&gt;

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}