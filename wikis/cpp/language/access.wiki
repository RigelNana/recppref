{{title|Access specifiers}}
{{cpp/language/classes/navbar}}
In a {{spar|member-specification}} of a {{rlp|class|class/struct}} or {{rlp|union}}, define the accessibility of subsequent members.

In a {{spar|base-specifier}} of a {{rlp|derived class}} declaration, define the accessibility of inherited members of the subsequent base class.

===Syntax===
{{sdsc begin}}
{{sdsc|num=1|{{ttb|public}} {{ttb|:}} {{spar|member-declarations}}}}
{{sdsc|num=2|{{ttb|protected}} {{ttb|:}} {{spar|member-declarations}}}}
{{sdsc|num=3|{{ttb|private}} {{ttb|:}} {{spar|member-declarations}}}}
{{sdsc|num=4|{{c|public}} {{spar|base-class}}}}
{{sdsc|num=5|{{c|protected}} {{spar|base-class}}}}
{{sdsc|num=6|{{c|private}} {{spar|base-class}}}}
{{sdsc end}}

@1@ The members declared after the access specifier have public member access.
@2@ The members declared after the access specifier have protected member access.
@3@ The members declared after the access specifier have private member access.
@4@ {{rlp|derived class#Public inheritance|Public inheritance}}: the public and protected members of the {{rlp|derived class|base class}} listed after the access specifier keep their member access in the derived class.
@5@ {{rlp|derived class#Protected inheritance|Protected inheritance}}: the public and protected members of the {{rlp|derived class|base class}} listed after the access specifier are protected members of the derived class.
@6@ {{rlp|derived class#Private inheritance|Private inheritance}}: the public and protected members of the {{rlp|derived class|base class}} listed after the access specifier are private members of the derived class.

The private members of the base class are always inaccessible to the derived class regardless of public, protected, or private inheritance.

===Explanation===
The name of every {{rlp|class}} member (static, non-static, function, type, etc) has an associated "member access". When a name of the member is used anywhere a program, its access is checked, and if it does not satisfy the access rules, the program does not compile:

{{example|code=
#include &lt;iostream&gt;

class Example
{
public:             // all declarations after this point are public
    void add(int x) // member "add" has public access
    {
        n += x;     // OK: private Example::n can be accessed from Example::add
    }
private:            // all declarations after this point are private
    int n = 0;      // member "n" has private access
};

int main()
{
    Example e;
    e.add(1); // OK: public Example::add can be accessed from main
//  e.n = 7;  // error: private Example::n cannot be accessed from main
}
}}

Access specifiers give the author of the class the ability to decide which class members are accessible to the users of the class (that is, the ''interface'') and which members are for internal use of the class (the ''implementation'').

===In detail===
All members of a class (bodies of {{rlp|member functions}}, initializers of member objects, and the entire {{rlp|nested types|nested class definitions}}) have access to all names the class can access. A local class within a member function has access to all names the member function can access. 

A class defined with the keyword {{tt|class}} has private access for its members and its base classes by default. A class defined with the keyword {{tt|struct}} has public access for its members and its base classes by default. A {{rlp|union}} has public access for its members by default.

To grant access to additional functions or classes to protected or private members, a {{rlp|friend|friendship declaration}} may be used.

Accessibility applies to all names with no regard to their origin, so a name introduced by a {{rlp|typedef}} or {{rlp|using declaration}}s (except inheriting constructors) is checked, not the name it refers to:

{{source|1=
class A : X
{
    class B {};   // B is private in A
public:
    typedef B BB; // BB is public
};

void f()
{
    A::B y;  // error: A::B is private
    A::BB x; // OK: A::BB is public
}
}}

Member access does not affect visibility: names of private and privately-inherited members are visible and considered by overload resolution, implicit conversions to inaccessible base classes are still considered, etc. Member access check is the last step after any given language construct is interpreted. The intent of this rule is that replacing any {{tt|private}} with {{tt|public}} never alters the behavior of the program.

Access checking for the names used in {{rlp|default arguments|default function arguments}} as well as in the default {{rlp|template parameters#Default template arguments|template parameters}} is performed at the point of declaration, not at the point of use.

Access rules for the names of {{rlp|virtual|virtual functions}} are checked at the call point using the type of the expression used to denote the object for which the member function is called. The access of the final overrider is ignored:

{{source|1=
struct B
{
    virtual int f(); // f is public in B
};

class D : public B
{
private:
    int f(); // f is private in D
};

void f()
{
    D d;
    B&amp; b = d;
    
    b.f(); // OK: B::f is public, D::f is invoked even though it's private
    d.f(); // error: D::f is private
}
}}

A name that is private according to unqualified {{rlp|lookup|name lookup}}, may be accessible through qualified name lookup:

{{source|1=
class A {};

class B : private A {};

class C : public B
{
    A* p;   // error: unqualified name lookup finds A as the private base of B
    ::A* q; // OK: qualified name lookup finds the namespace-level declaration
};
}}

A name that is accessible through multiple paths in the inheritance graph has the access of the path with the most access:

{{source|1=
class W
{
public:
    void f();
};

class A : private virtual W {};

class B : public virtual W {};

class C : public A, public B
{
    void f()
    {
        W::f(); // OK: W is accessible to C through B
    }
};
}}

Any number of access specifiers may appear within a class, in any order.

{{rrev|until=c++23|
Member access specifiers may affect {{rlp|data members#Layout|class layout}}: the addresses of non-static data members are only guaranteed to increase in order of declaration for the members {{rev inl|until=c++11|not separated by an access specifier}}{{rev inl|since=c++11|with the same access}}.
}}
{{rrev|since=c++11|
For [[cpp/named req/StandardLayoutType|standard-layout types]], all non-static data members must have the same access.
}}

When a member is redeclared within the same class, it must do so under the same member access:

{{source|1=
struct S
{
    class A;    // S::A is public
private:
    class A {}; // error: cannot change access
};
}}

===Public member access===
Public members form a part of the public interface of a class (other parts of the public interface are the non-member functions found by {{rlp|adl|ADL}}).

A public member of a class is accessible anywhere:

{{source|1=
class S
{
public:
    // n, E, A, B, C, U, f are public members
    int n;
    enum E {A, B, C};
    struct U {};
    static void f() {}
};

int main()
{
    S::f();     // S::f is accessible in main
    
    S s;
    s.n = S::B; // S::n and S::B are accessible in main
    
    S::U x;     // S::U is accessible in main
}
}}

===Protected member access===
Protected members form the interface of a class to its derived classes (which is distinct from the public interface of the class).

A protected member of a class is only accessible
@1@ to the members and friends of that class;
@2@ to the members and friends of any derived class of that class, but only when the class of the object through which the protected member is accessed is that derived class or a derived class of that derived class:

{{source|1=
struct Base
{
protected:
    int i;
private:
    void g(Base&amp; b, struct Derived&amp; d);
};

struct Derived : Base
{
    friend void h(Base&amp; b, Derived&amp; d);
    void f(Base&amp; b, Derived&amp; d) // member function of a derived class
    {
        ++d.i;                  // OK: the type of d is Derived
        ++i;                    // OK: the type of the implied '*this' is Derived
//      ++b.i;                  // error: can't access a protected member through
                                // Base (otherwise it would be possible to change
                                // other derived classes, like a hypothetical
                                // Derived2, base implementation)
    }
};
 
void Base::g(Base&amp; b, Derived&amp; d) // member function of Base
{
    ++i;                          // OK
    ++b.i;                        // OK
    ++d.i;                        // OK
}

void h(Base&amp; b, Derived&amp; d) // Friend of Derived
{
    ++d.i;                  // OK: friend of Derived can access a protected 
                            // member through an object of Derived
//  ++b.i;                  // error: friend of Derived is not a friend of Base
}

void x(Base&amp; b, Derived&amp; d) // non-member non-friend
{
//  ++b.i;                  // error: no access from non-member
//  ++d.i;                  // error: no access from non-member
}
}}

When a pointer to a protected member is formed, it must use a derived class in its declaration:

{{source|1=
struct Base
{
protected:
    int i;
};

struct Derived : Base
{
    void f()
    {
//      int Base::* ptr = &amp;Base::i;    // error: must name using Derived
        int Base::* ptr = &amp;Derived::i; // OK
    }
};
}}

===Private member access===
Private members form the implementation of a class, as well as the private interface for the other members of the class.

A private member of a class is only accessible to the members and friends of that class, regardless of whether the members are on the same or different instances:

{{source|1=
class S
{
private:
    int n; // S::n is private
public:
    S() : n(10) {}                    // this-&gt;n is accessible in S::S
    S(const S&amp; other) : n(other.n) {} // other.n is accessible in S::S
};
}}

The {{rlp|explicit cast}} (C-style and function-style) allows casting from a derived lvalue to reference to its private base, or from a pointer to derived to a pointer to its private base.

===Inheritance===
See {{rlp|derived class|derived classes}} for the meaning of public, protected, and private inheritance.

===Keywords===
{{ltt|cpp/keyword/public}},
{{ltt|cpp/keyword/protected}},
{{ltt|cpp/keyword/private}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1873|std=C++98|before=protected members were accessible to friends of derived classes|after=made inaccessible}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}