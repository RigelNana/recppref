{{title|Fundamental types}}
{{cpp/language/basics/navbar}}

{{petty|(See also {{rlp|type}} for type system overview and [[cpp/types|the list of type-related utilities]] that are provided by the C++ library)}}

The following types are collectively called ''fundamental types''{{sep}}:
* (possibly cv-qualified) {{c/core|void}}
{{rrev|since=c++11|
* (possibly cv-qualified) {{lc|std::nullptr_t}}
}}
* [[#Integral types|integral types]]
* [[#Floating-point types|floating-point types]]

{{anchor|void}}
==={{c/core|void}}===
:{{c/core|void}} — type with an empty set of values. It is an {{rlp|incomplete type}} that cannot be completed (consequently, objects of type {{c/core|void}} are disallowed). There are no {{rlp|array}}s of {{c/core|void}}, nor {{rlp|reference}}s to {{c/core|void}}. However, {{rlp|pointer#Pointers to void|pointers to {{c/core|void}}}} and {{rlp|function}}s returning type {{c/core|void}} (''procedures'' in other languages) are permitted.

{{rrev|since=c++11|
{{anchor|nullptr_t}}
==={{lc|std::nullptr_t}}===
{{dcl begin}}
{{dcl header|cstddef}}
{{dcl|since=c++11|
typedef decltype(nullptr) nullptr_t;
}}
{{dcl end}}

{{lc|std::nullptr_t}} is the type of the null pointer literal, {{rlpt|nullptr}}. It is a distinct type that is not itself a pointer type or a pointer to member type. All Its prvalues are {{rlp|pointer#Null pointers|null pointer constants}}.

{{c|sizeof(std::nullptr_t)}} is equal to {{c|sizeof(void*)}}.
}}

{{anchor|Integer types}}
===Integral types===
====Standard integer types====
:{{c/core|int}} — basic integer type. The keyword {{c/core|int}} may be omitted if any of the modifiers listed below are used. If no length modifiers are present, it's guaranteed to have a width of at least 16 bits. However, on 32/64 bit systems it is almost exclusively guaranteed to have width of at least 32 bits (see below).

=====Modifiers=====
Modifies the basic integer type. Can be mixed in any order. Only one of each group can be present in type name.

* Signedness:
:{{c/core|signed}} — target type will have signed representation (this is the default if omitted)
:{{c/core|unsigned}} — target type will have unsigned representation
* Size:
:{{c/core|short}} — target type will be optimized for space and will have width of at least 16 bits.
:{{c/core|long}} — target type will have width of at least 32 bits.
{{rrev|since=c++11|
{{anchor|long long}}
:{{c/core|long long}} — target type will have width of at least 64 bits.
}}

Note: as with all type specifiers, any order is permitted: {{c/core|unsigned long long int}} and {{c/core|long int unsigned long}} name the same type.

{{anchor|Integer properties}}
=====Properties=====
The following table summarizes all available standard integer types and their properties in various common data models:

{|class="wikitable" style="text-align:center;"
|-
! rowspan="2"|Type specifier
! rowspan="2"|Equivalent type
! colspan="5"|Width in bits by [[#Data models|data model]]
|-
&lt;!-- --&gt;
&lt;!-- --&gt;
! C++ standard
! LP32
! ILP32
! LLP64
! LP64
|-
|{{left|{{c/core|signed char}}}}
|{{c/core|signed char}}
|rowspan="2"|at least&lt;br&gt; '''8'''
|rowspan="2"|'''8'''
|rowspan="2"|'''8'''
|rowspan="2"|'''8'''
|rowspan="2"|'''8'''
|-
|{{left|{{c/core|unsigned char}}}}
|{{c/core|unsigned char}}
|-
|{{left|{{c/core|short}}}}
|rowspan="4"|{{c/core|short int}}
|rowspan="6"|at least&lt;br&gt; '''16'''
|rowspan="6"|'''16'''
|rowspan="6"|'''16'''
|rowspan="6"|'''16'''
|rowspan="6"|'''16'''
|-
|{{left|{{c/core|short int}}}}
|-
|{{left|{{c/core|signed short}}}}
|-
|{{left|{{c/core|signed short int}}}}
|-
|{{left|{{c/core|unsigned short}}}}
|rowspan="2"|{{c/core|unsigned short int}}
|-
|{{left|{{c/core|unsigned short int}}}}
|-
|{{left|{{c/core|int}}}}
|rowspan="3"|{{c/core|int}}
|rowspan="5"|at least&lt;br&gt; '''16'''
|rowspan="5"|'''16'''
|rowspan="5"|'''32'''
|rowspan="5"|'''32'''
|rowspan="5"|'''32'''
|-
|{{left|{{c/core|signed}}}}
|-
|{{left|{{c/core|signed int}}}}
|-
|{{left|{{c/core|unsigned}}}}
|rowspan="2"|{{c/core|unsigned int}}
|-
|{{left|{{c/core|unsigned int}}}}
|-
|{{left|{{c/core|long}}}}
|rowspan="4"|{{c/core|long int}}
|rowspan="6"|at least&lt;br&gt; '''32'''
|rowspan="6"|'''32'''
|rowspan="6"|'''32'''
|rowspan="6"|'''32'''
|rowspan="6"|'''64'''
|-
|{{left|{{c/core|long int}}}}
|-
|{{left|{{c/core|signed long}}}}
|-
|{{left|{{c/core|signed long int}}}}
|-
|{{left|{{c/core|unsigned long}}}}
|rowspan="2"|{{c/core|unsigned long int}}
|-
|{{left|{{c/core|unsigned long int}}}}
|-
|{{left|{{c/core|long long}}}}
|rowspan="4"|{{c/core|long long int}}&lt;br&gt;{{mark c++11}}
|rowspan="6"|at least&lt;br&gt; '''64'''
|rowspan="6"|'''64'''
|rowspan="6"|'''64'''
|rowspan="6"|'''64'''
|rowspan="6"|'''64'''
|-
|{{left|{{c/core|long long int}}}}
|-
|{{left|{{c/core|signed long long}}}}
|-
|{{left|{{c/core|signed long long int}}}}
|-
|{{left|{{c/core|unsigned long long}}}}
|rowspan="2"|{{c/core|unsigned long long int}}&lt;br&gt;{{mark c++11}}
|-
|{{left|{{c/core|unsigned long long int}}}}
|}

Note: integer arithmetic is defined differently for the signed and unsigned integer types. See {{rlp|operator arithmetic|arithmetic operators}}, in particular  {{rlp|operator arithmetic#Overflows|integer overflows}}.

{{lc|std::size_t}} is the unsigned integer type of the result of the {{rlpt|sizeof}} operator{{rev inl|since=c++11| as well as the {{rlpt|sizeof...}} operator and the {{rlpt|alignof}} operator}}.

{{rrev|since=c++11|
====Extended integer types====
The extended integer types are implementation-defined. Note that [[cpp/types/integer|fixed width integer types]] are typically aliases of the standard integer types.
}}

====Boolean type====
:{{c/core|bool}} — integer type, capable of holding one of the two values: {{rlpt|bool literal|true}} or {{rlpt|bool literal|false}}. The value of {{c|sizeof(bool)}} is implementation defined and might differ from {{c|1}}.

====Character types====
Character types are integer types used for a character representation.
:{{c/core|signed char}} — type for signed character representation.
:{{c/core|unsigned char}} — type for unsigned character representation. Also used to inspect {{rlp|object|object representations}} (raw memory).
:{{c/core|char}} — type for character representation which can be most efficiently processed on the target system (has the same representation and alignment as either {{c/core|signed char}} or {{c/core|unsigned char}}, but is always a distinct type). [[cpp/string/multibyte|Multibyte characters strings]] use this type to represent code units. {{rev inl|since=c++11|For every value of type {{c/core|unsigned char}} in range {{closed range|0|255}}, converting the value to {{c/core|char}} and then back to {{c/core|unsigned char}} produces the original value.}} The signedness of {{c/core|char}} depends on the compiler and the target platform: the defaults for ARM and PowerPC are typically unsigned, the defaults for x86 and x64 are typically signed.
:{{c/core|wchar_t}} — type for wide character representation (see [[cpp/string/wide|wide strings]]). It has the same size, signedness, and alignment as one of the integer types, but is a distinct type. In practice, it is 32 bits and holds UTF-32 on Linux and many other non-Windows systems, but 16 bits and holds UTF-16 code units on Windows. The standard used to require {{c/core|wchar_t}} to be large enough to represent any supported character code point. However, such requirement cannot be fulfilled on Windows, and thus it is considered as a [[#Defect reports|defect]] and removed.
{{rrev|since=c++11|
{{anchor|char16_t}}
:{{c/core|char16_t}} — type for UTF-16 character representation, required to be large enough to represent any UTF-16 code unit (16 bits). It has the same size, signedness, and alignment as {{lc|std::uint_least16_t}}, but is a distinct type.
{{anchor|char32_t}}
:{{c/core|char32_t}} — type for UTF-32 character representation, required to be large enough to represent any UTF-32 code unit (32 bits). It has the same size, signedness, and alignment as {{lc|std::uint_least32_t}}, but is a distinct type.
}}
&lt;p&gt;
{{rrev|since=c++20|
{{anchor|char8_t}}
:{{c/core|char8_t}} — type for UTF-8 character representation, required to be large enough to represent any UTF-8 code unit (8 bits). It has the same size, signedness, and alignment as {{c/core|unsigned char}} (and therefore, the same size and alignment as {{c/core|char}} and {{c/core|signed char}}), but is a distinct type.
}}

Besides the minimal bit counts, the C++ Standard guarantees that
:{{c|1}} {{c/core|1===}} {{c|sizeof(char)}} {{tt|&amp;le;}} {{c|sizeof(short)}} {{tt|&amp;le;}} {{c|sizeof(int)}} {{tt|&amp;le;}} {{c|sizeof(long)}} {{tt|&amp;le;}} {{c|sizeof(long long)}}.

Note: this allows the extreme case in which {{enwiki|Byte|bytes}} are sized 64 bits, all types (including {{c/core|char}}) are 64 bits wide, and {{rlpt|sizeof}} returns {{c|1}} for every type.

===Floating-point types===
====Standard floating-point types====
The following three types and their cv-qualified versions are collectively called standard floating-point types.

:{{c/core|float}} — single precision floating-point type. Usually {{enwiki|Single-precision floating-point format|IEEE-754 binary32 format}}.
:{{c/core|double}} — double precision floating-point type. Usually {{enwiki|Double-precision floating-point format|IEEE-754 binary64 format}}.
:{{c/core|long double}} — extended precision floating-point type. Does not necessarily map to types mandated by IEEE-754.
:* {{enwiki|Quadruple-precision floating-point format|IEEE-754 binary128 format}} is used by some HP-UX, SPARC, MIPS, ARM64, and z/OS implementations.
:* The most well known {{enwiki|Extended precision|IEEE-754 binary64-extended format}} is {{enwiki|Extended precision#x86 extended precision format|x87 80-bit extended precision format}}. It is used by many x86 and x86-64 implementations (a notable exception is MSVC, which implements {{c/core|long double}} in the same format as {{c/core|double}}, i.e. binary64).
:* On PowerPC {{enwiki|Quadruple-precision floating-point format#Double-double arithmetic|double-double}} can be used.

{{rrev|since=c++23|
====Extended floating-point types====
The extended floating-point types are implementation-defined. They may include [[cpp/types/floating-point|fixed width floating-point types]].
}}

{{anchor|Floating-point properties}}
====Properties====
Floating-point types may support [[cpp/types/numeric limits|special values]]:
* ''infinity'' (positive and negative), see {{lc|INFINITY}}
* the ''negative zero'', {{c|-0.0}}. It compares equal to the positive zero, but is meaningful in some arithmetic operations, e.g. {{c|1=1.0 / 0.0 == INFINITY}}, but {{c|1=1.0 / -0.0 == -INFINITY}}), and for some mathematical functions, e.g. {{ltt|cpp/numeric/complex/sqrt|sqrt{{small|(std::complex)}}}}
* ''not-a-number'' (NaN), which does not compare equal with anything (including itself). Multiple bit patterns represent NaNs, see {{lc|std::nan}}, {{lc|NAN}}. Note that C++ takes no special notice of signalling NaNs other than detecting their support by {{lc|std::numeric_limits::has_signaling_NaN}}, and treats all NaNs as quiet.

Floating-point numbers may be used with {{rlp|operator arithmetic|arithmetic operators}} {{c|+}}, {{c|-}}, {{c|/}}, and {{c|*}} as well as various mathematical functions from {{header|cmath}}. Both built-in operators and library functions may raise floating-point exceptions and set {{lc|errno}} as described in {{ltt|cpp/numeric/math/math errhandling}}.

Floating-point expressions may have greater range and precision than indicated by their types, see {{lc|FLT_EVAL_METHOD}}. Floating-point expressions may also be ''contracted'', that is, calculated as if all intermediate values have infinite range and precision, see {{ltt|cpp/preprocessor/impl##pragma STDC|#pragma STDC FP_CONTRACT}}. Standard C++ does not restrict the accuracy of floating-point operations.

Some operations on floating-point numbers are affected by and modify the state of [[cpp/numeric/fenv|the floating-point environment]] (most notably, the rounding direction).

{{rlp|implicit conversion|Implicit conversions}} are defined between floating types and integer types.

See {{lsd|cpp/types/climits#Limits of floating-point types}} and {{lc|std::numeric_limits}} for additional details, limits, and properties of the floating-point types.

===Range of values===
The following table provides a reference for the limits of common numeric representations.

Prior to C++20, the C++ Standard allowed any signed integer representation, and the minimum guaranteed range of N-bit signed integers was from {{mathjax-or|\(\scriptsize -(2^{N-1}-1)\)|-(2{{su|p=N-1}}-1)}} to {{mathjax-or|\(\scriptsize +2^{N-1}-1\)|+2{{su|p=N-1}}-1}} (e.g. '''−127''' to '''127''' for a signed 8-bit type), which corresponds to the limits of {{enwiki|Ones' complement|ones' complement}} or {{enwiki|Signed number representations#Sign-and-magnitude method|sign-and-magnitude}}.

However, all C++ compilers use {{enwiki|Two's complement|two's complement}} representation, and as of C++20, it is the only representation allowed by the standard, with the guaranteed range from {{mathjax-or|\(\scriptsize -2^{N-1}\)|-2{{su|p=N-1}}}} to {{mathjax-or|\(\scriptsize +2^{N-1}-1\)|+2{{su|p=N-1}}-1}} (e.g. '''−128''' to '''127''' for a signed 8-bit type).

8-bit ones' complement and sign-and-magnitude representations for {{c/core|char}} have been disallowed since C++11 (via the resolution of {{cwg|1759}}), because a UTF-8 code unit of value 0x80 used in a {{rlp|string literal|UTF-8 string literal}} must be storable in a {{c/core|char}} type object.

The range for a floating-point type {{tt|T}} is defined as follows:
* The minimum guaranteed range is the most negative finite floating-point number representable in {{tt|T}} through the most positive finite floating-point number representable in {{tt|T}}.
* If negative infinity is representable in {{tt|T}}, the range of {{tt|T}} is extended to all negative real numbers.
* If positive infinity is representable in {{tt|T}}, the range of {{tt|T}} is extended to all positive real numbers.

Since negative and positive infinity are representable in [https://www.iso.org/standard/80985.html ISO/IEC/IEEE 60559] formats, all real numbers lie within the range of representable values of a floating-point type adhering to ISO/IEC/IEEE 60559.

{{cpp/language/types/range of values}}

Note: actual (as opposed to guaranteed minimal) limits on the values representable by these types are available in [[cpp/types/climits|C numeric limits interface]] and {{lc|std::numeric_limits}}.

===Data models===
The choices made by each implementation about the sizes of the fundamental types are collectively known as ''data model''. Four data models found wide acceptance:

32 bit systems:
:*'''LP32''' or '''2/4/4''' ({{c/core|int}} is 16-bit, {{c/core|long}} and pointer are 32-bit)
::* Win16 API
:*'''ILP32''' or '''4/4/4''' ({{c/core|int}}, {{c/core|long}}, and pointer are 32-bit);
::* Win32 API
::* Unix and Unix-like systems (Linux, macOS)

64 bit systems:
:* '''LLP64''' or '''4/4/8''' ({{c/core|int}} and {{c/core|long}} are 32-bit, pointer is 64-bit)
::* [https://learn.microsoft.com/en-us/windows/win32/desktop-programming Win32 API] (also called the Windows API) with compilation target {{enwiki|AArch64|64-bit ARM}} (AArch64) or {{enwiki|x86-64}} (a.k.a. x64)
:* '''LP64''' or '''4/8/8''' ({{c/core|int}} is 32-bit, {{c/core|long}} and pointer are 64-bit)
::* Unix and Unix-like systems (Linux, macOS)

Other models are very rare. For example, '''ILP64''' ('''8/8/8''': {{c/core|int}}, {{c/core|long}}, and pointer are 64-bit) only appeared in some early 64-bit Unix systems (e.g. {{enwiki|UNICOS|UNICOS on Cray}}).

===Notes===
{{ftm begin|std=1|comment=1}}
{{ftm|value=200704L|std=C++11|__cpp_unicode_characters|New character types ({{c/core|char16_t}} and {{c/core|char32_t}})}}
{{ftm|value=201811L|std=C++20|__cpp_char8_t|rowspan="2"|{{c/core|char8_t}}}}
{{ftm|value=202207L|std=C++23|-|{{c/core|char8_t}} compatibility and portability fix ({{rlp|aggregate initialization#Character arrays|allow initialization of {{tt|(unsigned) char}} arrays}} from {{rlp|string literal|UTF-8 string literals}})}}
{{ftm end}}

===Keywords===
{{ltt|cpp/keyword/void}},
{{ltt|cpp/keyword/bool}},
{{ltt|cpp/keyword/true}},
{{ltt|cpp/keyword/false}},
{{ltt|cpp/keyword/char}},
{{ltt|cpp/keyword/char8_t}},
{{ltt|cpp/keyword/char16_t}},
{{ltt|cpp/keyword/char32_t}},
{{ltt|cpp/keyword/wchar_t}},
{{ltt|cpp/keyword/int}},
{{ltt|cpp/keyword/short}},
{{ltt|cpp/keyword/long}},
{{ltt|cpp/keyword/signed}},
{{ltt|cpp/keyword/unsigned}},
{{ltt|cpp/keyword/float}},
{{ltt|cpp/keyword/double}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=238|std=C++98|before=the constraints placed on a floating-point implementation was unspecified|after=specified as&lt;br&gt;no constraint}}
{{dr list item|wg=cwg|dr=1759|std=C++11|before={{c/core|char}} is not guaranteed to be able to represent UTF-8 code unit 0x80|after=guaranteed}}
{{dr list item|wg=cwg|dr=2689|std=C++11|before=cv-qualified {{lc|std::nullptr_t}} was not a fundemental type|after=it is}}
{{dr list item|wg=cwg|dr=2723|std=C++98|before=the ranges of representable values for floating-point types were not specified|after=specified}}
{{dr list item|paper=P2460R2|std=C++98|before={{c/core|wchar_t}} was required to be able to represent distinct codes for all members&lt;br&gt;of the largest extended character set specified among the supported locales|after=not required}}
{{dr list end}}

===References===
{{ref std c++23}}
{{ref std|section=6.8.2|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=6.8.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=6.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=3.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=3.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++03}}
{{ref std|section=3.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=3.9.1|title=Fundamental types|id=basic.fundamental}}
{{ref std end}}

===See also===
* {{rlp|type|The C++ type system overview}}
* {{rlp|cv|Const-volatility (cv) specifiers and qualifiers}}
* {{rlp|storage duration|Storage duration specifiers}}
{{dsc begin}}
{{dsc see c|c/language/arithmetic types|arithmetic types|nomono=true}}
{{dsc end}}

{{langlinks|ar|de|es|fr|it|ja|pl|pt|ru|zh}}