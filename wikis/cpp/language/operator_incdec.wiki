{{title|Increment/decrement operators}}
{{cpp/language/expressions/navbar}}
Increment/decrement operators increment or decrement the value of the object. 

{|class="wikitable" style="font-size:85%;"
|-
!rowspan="2"|Operator name
!rowspan="2"|Syntax
!rowspan="2"|{{rlp|operators|Over&amp;#8203;load&amp;#8203;able}}
!colspan="2"|Prototype examples (for {{c/core|class T}})
|-
!Inside class definition
!Outside class definition
|-
|pre-increment
|{{tt|++a}} 
|{{yes}}
|{{c|T&amp; T::operator++();}} 
|{{c|T&amp; operator++(T&amp; a);}}
|-
|pre-decrement
|{{tt|--a}} 
|{{yes}}
|{{c|T&amp; T::operator--();}} 
|{{c|T&amp; operator--(T&amp; a);}}
|-
|post-increment
|{{tt|a++}} 
|{{yes}}
|{{c|T T::operator++(int);}} 
|{{c|T operator++(T&amp; a, int);}}
|-
|post-decrement
|{{tt|a--}} 
|{{yes}}
|{{c|T T::operator--(int);}} 
|{{c|T operator--(T&amp; a, int);}}
|-
|colspan="5"|
:'''Notes'''&lt;br&gt;
* Prefix versions of the built-in operators return ''references'' and postfix versions return ''values'', and typical {{rlp|operators|user-defined overloads}} follow the pattern so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including {{c/core|void}}).
* The {{c/core|int}} parameter is a dummy parameter used to differentiate between prefix and postfix versions of the operators. When the user-defined postfix operator is called, the value passed in that parameter is always zero, although it may be changed by calling the operator using function call notation (e.g., {{c|a.operator++(2)}} or {{c|operator++(a, 2)}}).
|}

===Prefix operators===
The prefix increment and decrement expressions have the form
{{sdsc begin}}
{{sdsc|{{ttb|++}} {{spar|expression}}}}
{{sdsc|{{ttb|--}} {{spar|expression}}}}
{{sdsc  end}}
@1@ prefix increment (pre-increment)
@2@ prefix decrement (pre-decrement)

====Built-in prefix operators====
@1@ The expression {{c|++x}} is equivalent to {{c|1=x += 1}}, with the following exceptions:
{{rev begin}}
{{rev|until=c++17|
* If the type of {{spar|expression}} is (possibly volatile-qualified) {{c/core|bool}}, {{spar|expression}} is set to {{c|true}}. Such a increment is deprecated.
}}
{{rev|since=c++17|
* If the type of {{spar|expression}} is (possibly cv-qualified) {{c/core|bool}}, the program is ill-formed.
}}
{{rev|since=c++20|
* If the type of {{spar|expression}} is volatile-qualified, the increment is deprecated.
}}
{{rev end}}

@2@ The expression {{c|--x}} is equivalent to {{c|1=x -= 1}}, with the following exceptions:
* If the type of {{spar|expression}} is (possibly cv-qualified) {{c/core|bool}}, the program is ill-formed.
{{rrev|since=c++20|
* If the type of {{spar|expression}} is volatile-qualified, the decrement is deprecated.
}}

{{anchor|Prefix overloads}}

====Overloads====
In {{rlp|overload resolution#Call to an overloaded operator|overload resolution against user-defined operators}}, for every optionally volatile-qualified arithmetic type {{tt|A}} other than {{c/core|bool}}, and for every optionally volatile-qualified pointer {{tt|P}} to optionally cv-qualified object type, the following function signatures participate in overload resolution:
{{dcl begin}}
{{dcl|A&amp; operator++(A&amp;)}}
{{dcl|bool&amp; operator++(bool&amp;)|notes={{mark deprecated}}{{mark until c++17}}}}
{{dcl|P&amp; operator++(P&amp;)}}
{{dcl|A&amp; operator--(A&amp;)}}
{{dcl|P&amp; operator--(P&amp;)}}
{{dcl end}}

===Postfix operators===
The postfix increment and decrement expressions have the form
{{sdsc begin}}
{{sdsc|{{spar|expression}} {{ttb|++}}}}
{{sdsc|{{spar|expression}} {{ttb|--}}}}
{{sdsc end}}
@1@ postfix increment (post-increment)
@2@ postfix decrement (post-decrement)

====Built-in postfix operators====
The result of postfix increment or decrement is the value obtained by applying the {{rlpsd|implicit conversion#Lvalue-to-rvalue conversion}} to {{spar|expression}} (before modification). The type of the result is the cv-unqualified version of the type of {{spar|expression}}.

If {{spar|expression}} is not a modifiable lvalue of an arithmetic type{{rev inl|since=c++17| other than (possibly cv-qualified) {{c/core|bool}}}}, or a pointer to a complete object type, the program is ill-formed.

{{rrev|since=c++20|
If the type of {{spar|expression}} is volatile-qualified, the increment or decrement is deprecated.
}}

@1@ The value of {{spar|expression}} is modified as if it were the operand of the prefix {{tt|++}} operator.

@2@ The value of {{spar|expression}} is modified as if it were the operand of the prefix {{tt|--}} operator.

The value computation of a postfix increment or decrement is {{rlp|eval order|sequenced before}} the modification of {{spar|expression}}. With respect to an indeterminately-sequenced function call, the operation of a postfix increment or decrement is a single evaluation.

{{anchor|Postfix overloads}}
====Overloads====
In {{rlp|overload resolution#Call to an overloaded operator|overload resolution against user-defined operators}}, for every optionally volatile-qualified arithmetic type {{tt|A}} other than {{c/core|bool}}, and for every optionally volatile-qualified pointer {{tt|P}} to optionally cv-qualified object type, the following function signatures participate in overload resolution:
{{dcl begin}}
{{dcl|A operator++(A&amp;, int)}}
{{dcl|bool operator++(bool&amp;, int)|notes={{mark deprecated}}{{mark until c++17}}}}
{{dcl|P operator++(P&amp;, int)}}
{{dcl|A operator--(A&amp;, int)}}
{{dcl|P operator--(P&amp;, int)}}
{{dcl end}}

====Example====
{{example
|code=
#include &lt;iostream&gt;

int main()
{
    int n1 = 1;
    int n2 = ++n1;
    int n3 = ++ ++n1;
    int n4 = n1++;
//  int n5 = n1++ ++;   // error
//  int n6 = n1 + ++n1; // undefined behavior
    std::cout &lt;&lt; "n1 = " &lt;&lt; n1 &lt;&lt; '\n'
              &lt;&lt; "n2 = " &lt;&lt; n2 &lt;&lt; '\n'
              &lt;&lt; "n3 = " &lt;&lt; n3 &lt;&lt; '\n'
              &lt;&lt; "n4 = " &lt;&lt; n4 &lt;&lt; '\n';
}
|output=
n1 = 5
n2 = 2
n3 = 4
n4 = 4
}}

===Notes===
Because of the side-effects involved, built-in increment and decrement operators must be used with care to avoid undefined behavior due to violations of {{rlp|eval order|sequencing rules}}.

Because a temporary copy of the object is constructed during post-increment and post-decrement, pre-increment or pre-decrement operators are usually more efficient in contexts where the returned value is not used.

===Standard library===
Increment and decrement operators are overloaded for many standard library types. In particular, every {{named req|Iterator}} overloads {{c/core|operator++}} and every {{named req|BidirectionalIterator}} overloads {{c/core|operator--}}, even if those operators are no-ops for the particular iterator.

{{dsc begin}}
{{dsc h2|overloads for arithmetic types}}
{{dsc inc|cpp/atomic/atomic/dsc operator arith}}
{{dsc inc|cpp/chrono/duration/dsc operator arith2}}
{{dsc h2|overloads for iterator types}}
{{dsc inc|cpp/memory/raw_storage_iterator/dsc operator arith}}
{{dsc inc|cpp/iterator/adaptor/dsc operator arith|reverse_iterator}}
{{dsc inc|cpp/iterator/adaptor/dsc operator arith|move_iterator}}
{{dsc inc|cpp/iterator/inserter/dsc operator arith|front_insert_iterator}}
{{dsc inc|cpp/iterator/inserter/dsc operator arith|back_insert_iterator}}
{{dsc inc|cpp/iterator/inserter/dsc operator arith|insert_iterator}}
{{dsc inc|cpp/iterator/istream_iterator/dsc operator arith}}
{{dsc inc|cpp/iterator/ostream_iterator/dsc operator arith}}
{{dsc inc|cpp/iterator/istreambuf_iterator/dsc operator arith}}
{{dsc inc|cpp/iterator/ostreambuf_iterator/dsc operator arith}}
{{dsc inc|cpp/regex/regex_iterator/dsc operator arith}}
{{dsc inc|cpp/regex/regex_token_iterator/dsc operator arith}}
{{dsc end}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=2855|std=C++98|before=usual arithmetic conversions are applied for built-in pre-increment and&lt;br&gt;pre-decrement, but were not applied for their postfix counterparts&lt;ref&gt;The prefix {{c|++x}} is equivalent to {{c|1=x += 1}}, and the latter is applicable for usual arithmetic conversions (i.e. yield a common type between {{c/core|decltype(x)}} and {{c/core|int}}). However, the effect of the postfix {{c|x++}} is simply “adding one to {{c|x}}”, there is no binary operator present, so no usual arithmetic conversions will take place.&lt;/ref&gt;|after=also applied}}
{{dr list item|wg=cwg|dr=2901|std=C++98|before=lvalue-to-rvalue conversions were not applied&lt;br&gt;for built-in post-increment and post-decrement|after=applied}}
{{dr list end}}
&lt;references/&gt;

===See also===
{{rlp|operator precedence|Operator precedence}}

{{rlp|operators|Operator overloading}}
 
{{cpp/language/operators}}
{{dsc begin}}
{{dsc see c|c/language/operator incdec|Increment/decrement operators|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}