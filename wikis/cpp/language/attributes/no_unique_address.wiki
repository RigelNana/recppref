{{cpp/language/attributes/title|no_unique_address|notes={{mark since c++20}}}}
{{cpp/language/attributes/navbar}}

Allows this data member to be overlapped with other non-static data members or base class subobjects of its class.

===Syntax===
{{sdsc begin}}
{{sdsc|1=
{{ttb|{{c/core|[[no_unique_address]]}}}}
}}
{{sdsc end}}

===Explanation===
Applies to the name being declared in the declaration of a non-static data member that's not a bit-field.

Makes this member subobject [[cpp/language/object#Subobjects|potentially-overlapping]], i.e., allows this member to be overlapped with other non-static data members or base class subobjects of its class. This means that if the member has an empty class type (e.g. stateless allocator), the compiler may optimise it to occupy no space, just like if it were an [[cpp/language/ebo|empty base]]. If the member is not empty, any tail padding in it may be also reused to store other data members.

===Notes===
{{c|[[no_unique_address]]}} is ignored by MSVC even in C++20 mode; instead, {{c|[[msvc::no_unique_address]]}} is provided.

===Example===
{{example
|code=
#include &lt;iostream&gt;

struct Empty {}; // empty class

struct X
{
    int i;
    Empty e;
};

struct Y
{
    int i;
    [[no_unique_address]] Empty e;
};

struct Z
{
    char c;
    [[no_unique_address]] Empty e1, e2;
};

struct W
{
    char c[2];
    [[no_unique_address]] Empty e1, e2;
};

int main()
{
    // the size of any object of empty class type is at least 1
    static_assert(sizeof(Empty) &gt;= 1);

    // at least one more byte is needed to give e a unique address
    static_assert(sizeof(X) &gt;= sizeof(int) + 1);

    // empty member optimized out
    std::cout &lt;&lt; "sizeof(Y) == sizeof(int) is " &lt;&lt; std::boolalpha 
              &lt;&lt; (sizeof(Y) == sizeof(int)) &lt;&lt; '\n';

    // e1 and e2 cannot share the same address because they have the
    // same type, even though they are marked with [[no_unique_address]]. 
    // However, either may share address with c.
    static_assert(sizeof(Z) &gt;= 2);

    // e1 and e2 cannot have the same address, but one of them can share with
    // c[0] and the other with c[1]
    std::cout &lt;&lt; "sizeof(W) == 2 is " &lt;&lt; (sizeof(W) == 2) &lt;&lt; '\n';
}
|p=true
|output=
sizeof(Y) == sizeof(int) is true
sizeof(W) == 2 is true
}}

===References===
{{ref std c++23}}
{{ref std|section=9.12.11|title=No unique address attribute|id=dcl.attr.nouniqueaddr}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=9.12.10|title=No unique address attribute|id=dcl.attr.nouniqueaddr}}
{{ref std end}}

{{langlinks|de|es|ja|ru|zh}}