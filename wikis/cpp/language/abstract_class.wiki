{{title|Abstract class}}
{{cpp/language/classes/navbar}}

Defines an abstract type which cannot be instantiated, but can be used as a base class.

===Syntax===
A ''pure virtual'' function is a {{rlp|virtual|virtual function}} whose {{rlp|function|declarator}} has the following syntax:

{{sdsc begin}}
{{sdsc|{{spar|declarator}} {{spar optional|virt-specifier}} {{ttb|1==}} {{ttb|0}}}}
{{sdsc end}}

Here the sequence {{ttb|1== 0}} is known as {{spar|pure-specifier}}, and appears either immediately after the {{spar|declarator}} or after the optional {{spar|virt-specifier}} ({{rlpt|override}} or {{rlpt|final}}).

{{spar|pure-specifier}} cannot appear in a member function definition or {{rlp|friend}} declaration.

{{source|1=
struct Base
{
    virtual int g();
    virtual ~Base() {}
};

struct A : Base
{
    // OK: declares three member virtual functions, two of them pure
    virtual int f() = 0, g() override = 0, h();
    
    // OK: destructor can be pure too
    ~A() = 0;
    
    // Error: pure-specifier on a function definition
    virtual int b() = 0 {}
};
}}

An ''abstract class'' is a class that either defines or inherits at least one function for which {{rlp|virtual|the final overrider}} is ''pure virtual''.

===Explanation===
Abstract classes are used to represent general concepts (for example, Shape, Animal), which can be used as base classes for concrete classes (for example, Circle, Dog).

No objects of an abstract class can be created (except for base subobjects of a class derived from it) and no non-static data members whose type is an abstract class can be declared.

Abstract types cannot be used as parameter types, as function return types, or as the type of an explicit conversion (note this is checked at the point of definition and function call, since at the point of function declaration parameter and return type may be incomplete).

Pointers and references to an abstract class can be declared.

{{example|code=
struct Abstract
{
    virtual void f() = 0;  // pure virtual
}; // "Abstract" is abstract

struct Concrete : Abstract
{
    void f() override {}   // non-pure virtual
    virtual void g();      // non-pure virtual
}; // "Concrete" is non-abstract

struct Abstract2 : Concrete
{
    void g() override = 0; // pure virtual overrider
}; // "Abstract2" is abstract

int main()
{
    // Abstract a;   // Error: abstract class
    Concrete b;      // OK
    Abstract&amp; a = b; // OK to reference abstract base
    a.f();           // virtual dispatch to Concrete::f()
    // Abstract2 a2; // Error: abstract class (final overrider of g() is pure)
}
}}

The definition of a pure virtual function may be provided (and must be provided if the pure virtual is the {{rlp|destructor}}): the member functions of the derived class are free to call the abstract base's pure virtual function using qualified function id. This definition must be provided outside of the class body (the syntax of a function declaration doesn't allow both the pure specifier {{ttb|{{=}} 0}} and a function body).

Making a virtual call to a pure virtual function from a constructor or the destructor of the abstract class is undefined behavior (regardless of whether it has a definition or not).

{{source|1=
struct Abstract
{
    virtual void f() = 0; // pure virtual
    virtual void g() {}   // non-pure virtual
    
    ~Abstract()
    {
        g();           // OK: calls Abstract::g()
        // f();        // undefined behavior
        Abstract::f(); // OK: non-virtual call
    }
};

// definition of the pure virtual function
void Abstract::f()
{
    std::cout &lt;&lt; "A::f()\n";
}

struct Concrete : Abstract
{
    void f() override
    {
        Abstract::f(); // OK: calls pure virtual function
    }
    
    void g() override {}
    
    ~Concrete()
    {
        g(); // OK: calls Concrete::g()
        f(); // OK: calls Concrete::f()
    }
};
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=390|std=C++98|before=an undefined pure virtual destructor might be called|after=a definition is required in this case}}
{{dr list item|wg=cwg|dr=2153|std=C++98|before={{spar|pure-specifier}} could appear in friend declarations|after=prohibited}}
{{dr list end}}

===See also===
* {{rlpt|virtual}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}