{{title|Address of an overloaded function}}
{{cpp/language/functions/navbar}}

Besides {{rlp|operator other|function-call expressions}}, where {{rlp|overload resolution}} takes place, the name of an overloaded function may appear in the following 7 contexts:

{|class="wikitable"
!Context
!Target
|-
|{{rlp|initialization|initializer}} in a {{rlp|declarations|declaration}} of an object or {{rlp|reference initialization|reference}}
|the object or reference being initialized
|-
|on the right-hand-side of an assignment expression
|the left-hand side of the assignment
|-
|as a function call argument
|the function parameter
|-
|as a user-defined operator argument
|the operator parameter
|-
|the {{rlpt|return}} statement
|the return value of a function or conversion
|-
|{{rlp|explicit cast}} or {{rlpt|static_cast}} argument
|the corresponding cast
|-
|non-type {{rlp|template parameters|template argument}}
|the corresponding template parameter
|}

In each context, the name of an overloaded function may be preceded by address-of operator {{ttb|&amp;}} and may be enclosed in a redundant set of parentheses.

{{rrev|since=c++26|
If the target type contains a {{rlp|auto|placeholder type}}, placeholder type deduction is performed, and the following description uses the deduced type as target type.
}}

===Selecting functions===
When the address of an overloaded function is taken, a set {{tt|S}} of functions is selected from the overload set referred to by the name of the overload function:
* If there is no target, all non-template functions named are selected.
* Otherwise, a non-template function with type {{tt|F}} is selected for the function type {{tt|FT}} of the target type if {{tt|F}}{{rev inl|since=c++17| (after possibly applying the {{rlp|implicit conversion#Function pointer conversions|function pointer conversion}})}} is identical to {{tt|FT}}.&lt;ref&gt;In other words, the class of which the function is a member is ignored if the target type is a pointer-to-member-function type.&lt;/ref&gt;
* The specialization (if any) generated by {{rlp|template argument deduction}} for each function template named is also added to {{tt|S}}.

If the target is of function pointer type or reference to function type, {{tt|S}} can only include non-member functions{{rev inl|since=c++23|, explicit object member functions}} and static member functions. If the target is of pointer-to-member-function type, {{tt|S}} can only include implicit object member functions.

&lt;references/&gt;

===Eliminating functions===
After forming the set {{tt|S}}, functions are elimiated in the following order:
{{rrev|since=c++20|
* All functions with associated {{rlpsd|constraints#Constraints}} that are not satisfied are eliminated from the {{tt|S}}.
}}
* If more than one function in {{tt|S}} remains, all function template specializations in {{tt|S}} are eliminated if {{tt|S}} also contains a non-template function.
{{rrev|since=c++20|
* Any given non-template function {{c|func}} is eliminated if {{tt|S}} contains a second non-template function that is {{rlp|constraints#Partial ordering of constraints|more partial-ordering-constrained}} than {{c|func}}.
}}
* Any given function template specialization {{c|spec}} is eliminated if {{tt|S}} contains a second function template specialization whose function template is {{rlp|function template#Function template overloading|more specialized}} than the function template of {{c|spec}}.

After such eliminations (if any), exactly one selected function should remain in {{tt|S}}. Otherwise, the program is ill-formed.

===Example===
{{example
|code=
int f(int) { return 1; }
int f(double) { return 2; }

void g(int(&amp;f1)(int), int(*f2)(double)) { f1(0); f2(0.0); }

template&lt;int(*F)(int)&gt;
struct Templ {};

struct Foo
{
    int mf(int) { return 3; }
    int mf(double) { return 4; }
};

struct Emp
{
    void operator&lt;&lt;(int (*)(double)) {}
};

int main()
{
    // 1. initialization
    int (*pf)(double) = f; // selects int f(double)
    int (&amp;rf)(int) = f; // selects int f(int)
    int (Foo::*mpf)(int) = &amp;Foo::mf; // selects int mf(int)
    
    // 2. assignment
    pf = nullptr;
    pf = &amp;f; // selects int f(double)
    
    // 3. function argument
    g(f, f); // selects int f(int) for the 1st argument
             // and int f(double) for the second
    
    // 4. user-defined operator
    Emp{} &lt;&lt; f; //selects int f(double)
    
    // 5. return value
    auto foo = []() -&gt; int (*)(int)
    {
        return f; // selects int f(int)
    };
    
    // 6. cast
    auto p = static_cast&lt;int(*)(int)&gt;(f); // selects int f(int)
    
    // 7. template argument
    Templ&lt;f&gt; t;  // selects int f(int)
    
    // prevent “unused variable” warnings as if by [[maybe_unused]]
    [](...){}(pf, rf, mpf, foo, p, t);
}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=202|std=C++98|before=non-type template argument was not a context&lt;br&gt;of taking the address of an overloaded function|after=it is}}
{{dr list item|wg=cwg|dr=250|std=C++98|before=function template specializations generated with non-deduced&lt;br&gt;template arguments were not selected from the overload set|after=also selected}}
{{dr list item|wg=cwg|dr=1153|std=C++98|before=it was unclear whether a given function type matches the target type|after=made clear}}
{{dr list item|wg=cwg|dr=1563|std=C++11|before=it was unclear whether list-initialization is a context&lt;br&gt;of taking the address of an overloaded function|after=made clear}}
{{dr list end}}

===References===
{{ref std c++23}}
{{ref std|section=12.3|title=Address of overloaded function|id=over.over}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=12.5|title=Address of overloaded function|id=over.over}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=16.4|title=Address of overloaded function|id=over.over}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=13.4|title=Address of overloaded function|id=over.over}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=13.4|title=Address of overloaded function|id=over.over}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=13.4|title=Address of overloaded function|id=over.over}}
{{ref std end}}

{{langlinks|es|ja|ru|zh}}