{{title|Floating-point literal}}
{{cpp/language/expressions/navbar}}

Floating-point literal defines a compile-time constant whose value is specified in the source file.

===Syntax===
{{sdsc begin}}
{{sdsc|num=1| {{spar|digit-sequence}} {{spar|decimal-exponent}} {{spar optional|suffix}}}}
{{sdsc|num=2| {{spar|digit-sequence}} {{ttb|.}} {{spar optional|decimal-exponent}} {{spar optional|suffix}}}}
{{sdsc|num=3| {{spar optional|digit-sequence}} {{ttb|.}} {{spar|digit-sequence}} {{spar optional|decimal-exponent}} {{spar optional|suffix}}}}
{{sdsc|num=4|notes={{mark since c++17}}|{{ttb|0x}} {{!}} {{ttb|0X}} {{spar|hex-digit-sequence}} {{spar|hex-exponent}} {{spar optional|suffix}}}}
{{sdsc|num=5|notes={{mark since c++17}}|{{ttb|0x}} {{!}} {{ttb|0X}} {{spar|hex-digit-sequence}} {{ttb|.}} {{spar|hex-exponent}} {{spar optional|suffix}}}}
{{sdsc|num=6|notes={{mark since c++17}}|{{ttb|0x}} {{!}} {{ttb|0X}} {{spar optional|hex-digit-sequence}} {{ttb|.}} {{spar|hex-digit-sequence}} {{spar|hex-exponent}} {{spar optional|suffix}}}}
{{sdsc end}}
@1@ {{spar|digit-sequence}} representing a whole number without a decimal separator, in this case the exponent is not optional: {{c|1e10}}, {{c|1e-5L}}.
@2@ {{spar|digit-sequence}} representing a whole number with a decimal separator, in this case the exponent is optional: {{c|1.}}, {{c|1.e-2}}.
@3@ {{spar|digit-sequence}} representing a fractional number. The exponent is optional: {{c|3.14}}, {{c|.1f}}, {{c|0.1e-1L}}.
@4@ Hexadecimal {{spar|digit-sequence}} representing a whole number without a radix separator. The exponent is never optional for hexadecimal floating-point literals: {{c|0x1ffp10}}, {{c|0X0p-1}}.
@5@ Hexadecimal {{spar|digit-sequence}} representing a whole number with a radix separator. The exponent is never optional for hexadecimal floating-point literals: {{c|0x1.p0}}, {{c|0xf.p-1}}.
@6@ Hexadecimal {{spar|digit-sequence}} representing a fractional number with a radix separator. The exponent is never optional for hexadecimal floating-point literals: {{c|0x0.123p-1}}, {{c|0xa.bp10l}}.

{{spar|decimal-exponent}} has the form
{{sdsc begin}}
{{sdsc|{{ttb|e}} {{!}} {{ttb|E}} {{spar optional|exponent-sign}} {{spar|digit-sequence}}}}
{{sdsc end}}

{{spar|hex-exponent}} has the form
{{sdsc begin}}
{{sdsc|{{ttb|p}} {{!}} {{ttb|P}} {{spar optional|exponent-sign}} {{spar|digit-sequence}}|notes={{mark since c++17}}}}
{{sdsc end}}

{{spar|exponent-sign}}, if present, is either {{ttb|+}} or {{ttb|-}}

{{spar|suffix}}, if present, is one of {{ttb|f}}, {{ttb|l}}, {{ttb|F}}, {{ttb|L}}{{rev inl|since=c++23|, {{ttb|f16}}, {{ttb|f32}}, {{ttb|f64}}, {{ttb|f128}}, {{ttb|bf16}}, {{ttb|F16}}, {{ttb|F32}}, {{ttb|F64}}, {{ttb|F128}}, {{ttb|BF16}}}}. The suffix determines the type of the floating-point literal:
:* (no suffix) defines {{c/core|double}}
:* {{ttb|f F}} defines {{c/core|float}}
:* {{ttb|l L}} defines {{c/core|long double}}
{{rrev|since=c++23|
:* {{ttb|f16 F16}} defines {{lc|std::float16_t}}
:* {{ttb|f32 F32}} defines {{lc|std::float32_t}}
:* {{ttb|f64 F64}} defines {{lc|std::float64_t}}
:* {{ttb|f128 F128}} defines {{lc|std::float128_t}}
:* {{ttb|bf16 BF16}} defines {{lc|std::bfloat16_t}}
}}

{{anchor|Single quote}}
{{rrev|since=c++14|
Optional single quotes ({{c/core|'}}) may be inserted between the digits as a separator; they are ignored when determining the value of the literal.
}}

===Explanation===
Decimal scientific notation is used, meaning that the value of the floating-point literal is the significand multiplied by the number 10 raised to the power of {{spar|decimal-exponent}}. E.g. the mathematical meaning of {{c|123e4}} is ''123Ã—10&lt;sup&gt;4&lt;/sup&gt;''.

{{rrev|since=c++17|
If the floating literal begins with the character sequence {{tt|0x}} or {{tt|0X}}, the floating literal is a ''hexadecimal floating literal''. Otherwise, it is a ''decimal floating literal''.

For a ''hexadecimal floating literal'', the significand is interpreted as a hexadecimal rational number, and the {{spar|digit-sequence}} of the exponent is interpreted as the (decimal) integer power of 2 by which the significand has to be scaled.

{{cc|1=double d = 0x1.4p3;}}{{tt|// hex fraction 1.4 (decimal 1.25) scaled by 2{{sup|3}}, that is 10.0}}
}}

===Notes===
The hexadecimal floating-point literals were not part of C++ until C++17, although they can be parsed and printed by the I/O functions since C++11: both C++ I/O streams when {{lc|std::hexfloat}} is enabled and the C I/O streams: {{lc|std::printf}}, {{lc|std::scanf}}, etc. See {{lc|std::strtof}} for the format description.

{{feature test macro|value=201603L|std=C++17|__cpp_hex_float|Hexadecimal floating literals}}

===Example===
{{example|code=
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;typeinfo&gt;

#define OUT(x) '\n' &lt;&lt; std::setw(16) &lt;&lt; #x &lt;&lt; x

int main()
{
    std::cout
        &lt;&lt; "Literal" "\t" "Printed value" &lt;&lt; std::left
        &lt;&lt; OUT( 58.            ) // double
        &lt;&lt; OUT( 4e2            ) // double
        &lt;&lt; OUT( 123.456e-67    ) // double
        &lt;&lt; OUT( 123.456e-67f   ) // float, truncated to zero
        &lt;&lt; OUT( .1E4f          ) // float
        &lt;&lt; OUT( 0x10.1p0       ) // double
        &lt;&lt; OUT( 0x1p5          ) // double
        &lt;&lt; OUT( 0x1e5          ) // integer literal, not floating-point
        &lt;&lt; OUT( 3.14'15'92     ) // double, single quotes ignored (C++14)
        &lt;&lt; OUT( 1.18e-4932l    ) // long double
        &lt;&lt; std::setprecision(39)
        &lt;&lt; OUT( 3.4028234e38f  ) // float
        &lt;&lt; OUT( 3.4028234e38   ) // double
        &lt;&lt; OUT( 3.4028234e38l  ) // long double
        &lt;&lt; '\n';

    static_assert(3.4028234e38f == std::numeric_limits&lt;float&gt;::max());

    static_assert(3.4028234e38f ==  // ends with 4
                  3.4028235e38f);   // ends with 5

    static_assert(3.4028234e38 !=   // ends with 4
                  3.4028235e38);    // ends with 5

    // Both floating-point constants below are 3.4028234e38
    static_assert(3.4028234e38f !=  // a float (then promoted to double)
                  3.4028234e38);    // a double
}
|p=true
|output=
Literal         Printed value
58.             58
4e2             400
123.456e-67     1.23456e-65
123.456e-67f    0
.1E4f           1000
0x10.1p0        16.0625
0x1p5           32
0x1e5           485
3.14'15'92      3.14159
1.18e-4932l     1.18e-4932
3.4028234e38f   340282346638528859811704183484516925440
3.4028234e38    340282339999999992395853996843190976512
3.4028234e38l   340282339999999999995912555211526242304
}}

===References===
{{ref std c++23}}
{{ref std| section = 5.13.4| title=Floating-point literals| id= lex.fcon}}
{{ref std end}}
{{ref std c++20}}
{{ref std| section = 5.13.4| title=Floating-point literals| id= lex.fcon}}
{{ref std end}}
{{ref std c++17}}
{{ref std| section = 5.13.4| title=Floating literals| id= lex.fcon}}
{{ref std end}}
{{ref std c++14}}
{{ref std| section = 2.14.4| title=Floating literals| id= lex.fcon}}
{{ref std end}}
{{ref std c++11}}
{{ref std| section = 2.14.4| title=Floating literals| id= lex.fcon}}
{{ref std end}}
&lt;!--{{ref std c++03}}
{{ref std| section = 2.13.3| title=Floating literals| id= lex.fcon}}
{{ref std end}}N1804--&gt;
{{ref std c++98}}
{{ref std| section = 2.13.3| title=Floating literals| id= lex.fcon}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc user_literal}}
{{dsc see c|c/language/floating_constant|Floating constant|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}