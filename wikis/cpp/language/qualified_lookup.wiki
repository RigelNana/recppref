{{title|Qualified name lookup}}
{{cpp/language/basics/navbar}}
A ''qualified'' name is a name that appears on the right hand side of the scope resolution operator {{ttb|::}} (see also {{rlp|identifiers#Qualified identifiers|qualified identifiers}}).
A qualified name may refer to a 
* class member (including static and non-static functions, types, templates, etc),
* namespace member (including another namespace),
* enumerator.

If there is nothing on the left hand side of the {{ttb|::}}, the lookup considers only declarations in [[#Namespace members|the global namespace scope]]. This makes it possible to refer to such names even if they were hidden by a local declaration:
{{source|1=
#include &lt;iostream&gt;

namespace M {
    const char* fail = "fail\n";
}

using M::fail;

namespace N {
    const char* ok = "ok\n";
}

using namespace N;

int main()
{
    struct std {};
    
    std::cout &lt;&lt; ::fail; // Error: unqualified lookup for 'std' finds the struct
    ::std::cout &lt;&lt; ::ok; // OK: ::std finds the namespace std
}
}}

Before name lookup can be performed for the name on the right hand side of {{ttb|::}}, lookup must be completed for the name on its left hand side (unless a {{rlp|decltype}} expression is used, or there is nothing on the left). This lookup, which may be qualified or unqualified, depending on whether there's another {{ttb|::}} to the left of that name, considers only namespaces, class types, enumerations, and templates whose specializations are types. If the name found on the left does not designate a namespace or a class, enumeration, or dependent type, the program is ill-formed:
{{source|1=
struct A
{
    static int n;
};

int main()
{
    int A;
    A::n = 42; // OK: unqualified lookup of A to the left of :: ignores the variable
    A b;       // Error: unqualified lookup of A finds the variable A
}

template&lt;int&gt;
struct B : A {};

namespace N
{
    template&lt;int&gt;
    void B();
    
    int f()
    {
        return B&lt;0&gt;::n; // Error: N::B&lt;0&gt; is not a type
    }
}
}}

When a qualified name is used as a {{rlp|declarations|declarator}}, then {{rlp|unqualified lookup}} of the names used in the same declarator that follow that qualified name, but not the names that precede it, is performed in the scope of the member's class or namespace:
{{source|1=
class X {};

constexpr int number = 100;

struct C
{
    class X {};
    static const int number = 50;
    static X arr[number];
};

X C::arr[number], brr[number];    // Error: look up for X finds ::X, not C::X
C::X C::arr[number], brr[number]; // OK: size of arr is 50, size of brr is 100
}}

If {{ttb|::}} is followed by the character {{ttb|~}} that is in turn followed by an identifier (that is, it specifies a destructor or pseudo-destructor), that identifier is looked up in the same scope as the name on the left hand side of {{ttb|::}}
{{source|1=
struct C { typedef int I; };

typedef int I1, I2;

extern int *p, *q;

struct A { ~A(); };

typedef A AB;

int main()
{
    p-&gt;C::I::~I(); // The name I after ~ is looked up in the same scope as I before ::
                   // (that is, within the scope of C, so it finds C::I)
    
    q-&gt;I1::~I2();  // The name I2 is looked up in the same scope as I1
                   // (that is, from the current scope, so it finds ::I2)
    
    AB x;
    x.AB::~AB();   // The name AB after ~ is looked up in the same scope as AB before ::
                   // (that is, from the current scope, so it finds ::AB)
}
}}

{{rev begin}}
{{rev|since=c++11|
====Enumerators====
If the lookup of the left-hand side name comes up with an {{rlp|enum|enumeration}} (either scoped or unscoped), the lookup of the right-hand side must result in an enumerator that belongs that enumeration, otherwise the program is ill-formed.
}}
{{rev end}}

====Class members====
If the lookup of the left hand side name comes up with a class/struct or union name, the name on the right hand side of {{ttb|::}} is looked up in the scope of that class (and so may find a declaration of a member of that class or of its base), with the following exceptions:
* A destructor is looked up as described above (in the scope of the name to the left of ::).
* A conversion-type-id in a {{rlp|cast operator|user-defined conversion}} function name is first looked up in the scope of the class. If not found, the name is then looked up in the current scope. {{mark unreviewed dr|cwg|1111}}{{mark unreviewed dr|cwg|2385}}
* Names used in template arguments are looked up in the current scope (not in the scope of the template name).
* Names in {{rlp|namespace|using-declarations}} also consider class/enum names that are hidden by the name of a variable, data member, function, or enumerator declared in the same scope.
{{todo|micro-examples for the above}}

If the right hand side of {{ttb|::}} names the same class as the left hand side, the name designates the {{rlp|constructor}} of that class. Such qualified name can only be used in a declaration of a constructor and in the {{rlp|using declaration|using-declaration}} for an {{rlp|using declaration#Inheriting constructors|inheriting constructor}}. In those lookups where function names are ignored (that is, when looking up a name on the left of {{ttb|::}}, when looking up a name in {{rlp|elaborated type specifier}}, or {{rlp|derived class|base specifier}}), the same syntax resolves to the injected-class-name:
{{source|1=
struct A { A(); };

struct B : A { B(); };

A::A() {} // A::A names a constructor, used in a declaration
B::B() {} // B::B names a constructor, used in a declaration

B::A ba;  // B::A names the type A (looked up in the scope of B)
A::A a;   // Error: A::A does not name a type

struct A::A a2; // OK: lookup in elaborated type specifier ignores functions
                // so A::A simply names the class A as seen from within the scope of A
                // (that is, the injected-class-name)
}}

Qualified name lookup can be used to access a class member that is hidden by a nested declaration or by a derived class. A call to a qualified member function is never virtual:
{{source|1=
struct B { virtual void foo(); };

struct D : B { void foo() override; };

int main()
{
    D x;
    B&amp; b = x;
    
    b.foo();    // Calls D::foo (virtual dispatch)
    b.B::foo(); // Calls B::foo (static dispatch)
}
}}

====Namespace members====
If the name on the left of {{ttb|::}} refers to a namespace or if there is nothing on the left of {{ttb|::}} (in which case it refers to the global namespace), the name that appears on the right hand side of {{ttb|::}} is looked up in the scope of that namespace, except that 
* names used in template arguments are looked up in the current scope:
{{source|1=
namespace N
{
    template&lt;typename T&gt;
    struct foo {};
    
    struct X {};
}

N::foo&lt;X&gt; x; // Error: X is looked up as ::X, not as N::X
}}

Qualified lookup within the scope of a {{rlp|namespace}} {{tt|N}} first considers all declarations that are located in {{tt|N}} and all declarations that are located in the {{rlp|namespace#Inline namespaces|inline namespace members}} of {{tt|N}} (and, transitively, in their inline namespace members). If there are no declarations in that set then it considers declarations in all namespaces named by {{rlp|namespace#Using-directives|using-directives}} found in {{tt|N}} and in all transitive inline namespace members of {{tt|N}}. The rules are applied recursively:

{{source|1=
int x;

namespace Y
{
    void f(float);
    void h(int);
}

namespace Z
{
    void h(double);
}

namespace A
{
    using namespace Y;
    void f(int);
    void g(int);
    int i;
}

namespace B
{
    using namespace Z;
    void f(char);
    int i;
}

namespace AB
{
    using namespace A;
    using namespace B;
    void g();
}

void h()
{
    AB::g();  // AB is searched, AB::g found by lookup and is chosen AB::g(void)
              // (A and B are not searched)
    
    AB::f(1); // First, AB is searched. There is no f
              // Then, A, B are searched
              // A::f, B::f found by lookup
              // (but Y is not searched so Y::f is not considered)
              // Overload resolution picks A::f(int)
    
    AB::x++;  // First, AB is searched. There is no x
              // Then A, B are searched. There is no x
              // Then Y and Z are searched. There is still no x: this is an error
    
    AB::i++;  // AB is searched. There is no i
              // Then A, B are searched. A::i and B::i found by lookup: this is an error
    
    AB::h(16.8); // First, AB is searched. There is no h
                 // Then A, B are searched. There is no h
                 // Then Y and Z are searched
                 // Lookup finds Y::h and Z::h. Overload resolution picks Z::h(double)
}
}}

It is allowed for the same declaration to be found more than once:
{{source|1=
namespace A { int a; }

namespace B { using namespace A; }

namespace D { using A::a; }

namespace BD
{
    using namespace B;
    using namespace D;
}

void g()
{
    BD::a++; // OK: finds the same A::a through B and through D
}
}}
{{todo|the rest of N4861 6.5.3.2[namespace.qual], try to shorten their examples}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=215|std=C++98|before=the name preceding {{ttb|::}} must be a class name or namespace&lt;br&gt;name, so template parameters were not allowed there|after=the name must designate a class,&lt;br&gt;namespace or dependent type}}
{{dr list item|wg=cwg|dr=318|std=C++98|before=if the right hand side of {{ttb|::}} names the same class&lt;br&gt;as the left hand side, the qualified name was always&lt;br&gt;considered to name the constructor of that class|after=only name the constructor&lt;br&gt;when acceptable (e.g. not in&lt;br&gt;an elaborated type specifier)}}
{{dr list end}}

===See also===
* {{rlp|unqualified lookup|Unqualified name lookup}} 
* {{rlp|scope|Scope}} 
* {{rlp|adl|Argument-dependent lookup}} 
* {{rlp|function template|Template argument deduction}}
* {{rlp|overload resolution|Overload resolution}}

{{langlinks|es|ja|ru|zh}}