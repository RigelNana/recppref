{{title|Enumeration declaration}}
{{cpp/language/declarations/navbar}}

An ''enumeration'' is a distinct type whose value is restricted to a range of values (see below for details), which may include several explicitly named constants ("''enumerators''").

The values of the constants are values of an integral type known as the ''underlying type'' of the enumeration. An enumeration has the same {{rlp|sizeof|size}}, {{rlp|object#Object representation and value representation|value representation}}, and {{rlp|object#Alignment|alignment requirements}} as its underlying type. Furthermore, each value of an enumeration has the same representation as the corresponding value of the underlying type.

An enumeration is (re)declared using the following syntax:
{{sdsc begin}}
{{sdsc|num=1|1=
{{spar|enum-key}} {{spar optional|attr}} {{spar optional|enum-head-name}} {{spar optional|enum-base}}&lt;br&gt;{{ttb|{}} {{spar optional|enumerator-list}} {{ttb|}&lt;!----&gt;}}
}}
{{sdsc|num=2|1=
{{spar|enum-key}} {{spar optional|attr}} {{spar optional|enum-head-name}} {{spar optional|enum-base}}&lt;br&gt;{{ttb|{}} {{spar|enumerator-list}} {{ttb|, }&lt;!----&gt;}}
}}
{{sdsc|num=3|notes={{mark since c++11}}|1=
{{spar|enum-key}} {{spar optional|attr}} {{spar|enum-head-name}} {{spar optional|enum-base}} {{ttb|;}}
}}
{{sdsc end}}
@1@ {{spar|enum-specifier}}, which appears in {{spar|decl-specifier-seq}} of the {{rlp|declarations|declaration}} syntax: defines the enumeration type and its enumerators.
@2@ A trailing comma can follow the {{spar|enumerator-list}}.
@3@ Opaque enum declaration: defines the enumeration type but not its enumerators: after this declaration, the type is a complete type and its size is known.

{{par begin}}
{{par|{{spar|enum-key}}|
{{rrev multi|rev1={{ttb|enum}}
|since2=c++11|rev2=one of {{ttb|enum}}, {{ttb|enum class}}, or {{ttb|enum struct}}}}}}
{{par|{{spar|attr}}|{{mark since c++11}} optional sequence of any number of {{rlp|attributes}}}}
{{par|{{spar|enum-head-name}}|
{{rrev multi|rev1=the name of the enumeration that's being declared, it can be omitted.
|since2=c++11|rev2=the name of the enumeration that's being declared, optionally preceded by a {{spar|nested-name-specifier}}: sequence of names and scope-resolution operators {{tt|::}}, ending with scope-resolution operator. It can only be omitted in unscoped non-opaque enumeration declarations.&lt;br&gt;
{{spar|nested-name-specifier}} may only appear if the enumeration name is present and this declaration is a redeclaration. For opaque enumeration declarations, {{spar|nested-name-specifier}} can only appear before the name of the enumeration in {{rlp|template specialization|explicit specialization declarations}}.&lt;br&gt;
If {{spar|nested-name-specifier}} is present, the ''enum-specifier'' cannot refer to an enumeration  merely inherited or introduced by a {{rlp|using declaration|{{c/core|using}} declaration}}, and the ''enum-specifier'' can only appear in a namespace enclosing the previous declaration. In such cases, {{spar|nested-name-specifier}} cannot begin with a {{rlp|decltype}} specifier.}}}}
{{par|{{spar|enum-base}}|{{mark since c++11}} colon ({{ttb|:}}), followed by a {{spar|type-specifier-seq}} that names an integral type (if it is cv-qualified, qualifications are ignored) that will serve as the fixed underlying type for this enumeration type}}
{{par|{{spar|enumerator-list}}|comma-separated list of enumerator definitions, each of which is either simply a unique {{spar|identifier}}, which becomes the name of the enumerator, or a unique identifier with a constant expression: {{spar|identifier}} {{ttb|{{=}}}} {{spar|constant-expression}}. {{rev inl|since=c++17|In either case, the {{spar|identifier}} can be directly followed by an optional {{rlp|attributes|attribute specifier sequence}}.}}}}
{{par end}}

There are two distinct kinds of enumerations: ''unscoped enumeration'' (declared with the {{spar|enum-key}} {{ttb|enum}}) and ''scoped enumeration'' (declared with the {{spar|enum-key}} {{ttb|enum class}} or {{ttb|enum struct}}).

===Unscoped enumerations===
{{sdsc begin}}
{{sdsc|num=1|1=
{{ttb|enum}} {{spar optional|name}} {{ttb|{}} {{spar|enumerator}} {{ttb|1==}} {{spar|constant-expression}} {{ttb|,}} {{spar|enumerator}} {{ttb|{{=}}}} {{spar|constant-expression}} {{ttb|,}} ... {{ttb|}&lt;!----&gt;}} 
}}
{{sdsc|num=2|notes={{mark since c++11}}|1=
{{ttb|enum}} {{spar optional|name}} {{ttb|:}} {{spar|type}} {{ttb|{}} {{spar|enumerator}} {{ttb|1==}} {{spar|constant-expression}} {{ttb|,}} {{spar|enumerator}} {{ttb|1==}} {{spar|constant-expression}} {{ttb|,}} ... {{ttb|}&lt;!----&gt;}}
}}
{{sdsc|num=3|notes={{mark since c++11}}|1=
{{ttb|enum}} {{spar|name}} {{ttb|:}} {{spar|type}} {{ttb|;}}
}}
{{sdsc end}}
@1@ Declares an unscoped enumeration type whose underlying type is not fixed (in this case, the underlying type is an implementation-defined integral type that can represent all enumerator values; this type is not larger than {{c/core|int}} unless the value of an enumerator cannot fit in an {{c/core|int}} or {{c/core|unsigned int}}. If the {{spar|enumerator-list}} is empty, the underlying type is as if the enumeration had a single enumerator with value {{c|0}}. If no integral type can represent all the enumerator values, the enumeration is ill-formed).
@2@ Declares an unscoped enumeration type whose underlying type is fixed.
@3@ Opaque enum declaration for an unscoped enumeration must specify the name and the underlying type.

Each {{spar|enumerator}} becomes a named constant of the enumeration's type (that is, {{spar|name}}), visible in the enclosing scope, and can be used whenever constants are required.
{{source|1=
enum Color { red, green, blue };
Color r = red;

switch(r)
{
    case red  : std::cout &lt;&lt; "red\n";   break;
    case green: std::cout &lt;&lt; "green\n"; break;
    case blue : std::cout &lt;&lt; "blue\n";  break;
}
}}

Each enumerator is associated with a value of the underlying type. When {{ttb|1==}} are provided in an {{spar|enumerator-list}}, the values of enumerators are defined by those associated {{spar|constant-expression}}s. If the first enumerator does not have {{ttb|1==}}, the associated value is zero. For any other enumerator whose definition does not have an {{ttb|1==}}, the associated value is the value of the previous enumerator plus one.
{{source|1=enum Foo { a, b, c = 10, d, e = 1, f, g = f + c };
//a = 0, b = 1, c = 10, d = 11, e = 1, f = 2, g = 12}}

The {{spar|name}} of an unscoped enumeration may be omitted: such declaration only introduces the enumerators into the enclosing scope:
{{source|1=enum { a, b, c = 0, d = a + 2 }; // defines a = 0, b = 1, c = 0, d = 2}}

When an unscoped enumeration is a class member, its enumerators may be accessed using class member access operators {{ttb|.}} and {{ttb|-&gt;}}:
{{source|1=
struct X
{
    enum direction { left = 'l', right = 'r' };
};
X x;
X* p = &amp;x;

int a = X::direction::left; // allowed only in C++11 and later
int b = X::left;
int c = x.left;
int d = p-&gt;left;
}}

{{rrev|since=c++11|
In the {{rlp|declarations#Specifiers|declaration specifiers}} of a {{rlp|class#Member specification|member declaration}}, the sequence

:{{ttb|enum}} {{spar|enum-head-name}} {{ttb|:}}

is always parsed as a part of enumeration declaration:
{{source|
struct S
{
    enum E1 : int {};
    enum E1 : int {}; // error: redeclaration of enumeration,
                      // NOT parsed as a zero-length bit-field of type enum E1
};

enum E2 { e1 };

void f()
{
    false ? new enum E2 : int(); // OK: 'int' is NOT parsed as the underlying type
}
}}
}}

====Enumeration name for linkage purposes====
An unnamed enumeration that does not have a {{rlps|typedef#typedef name for linkage purposes}} and that has an enumerator is denoted, for {{rlp|storage duration|linkage purposes}}, by its underlying type and its first enumerator; such an enumeration is said to have an enumerator as a ''name for linkage purposes''.

===Scoped enumerations===
{{rrev|since=c++11|
{{sdsc begin}}
{{sdsc|num=1|1=
{{ttb|enum struct{{!}}class}} {{spar|name}} {{ttb|{}} {{spar|enumerator}} {{ttb|1==}} {{spar|constant-expression}} {{ttb|,}} {{spar|enumerator}} {{ttb|1==}} {{spar|constant-expression}} {{ttb|,}} ... {{ttb|}&lt;!----&gt;}}
}}
{{sdsc|num=2|1=
{{ttb|enum struct{{!}}class}} {{spar|name}} {{ttb|:}} {{spar|type}} {{ttb|{}} {{spar|enumerator}} {{ttb|1==}} {{spar|constant-expression}} {{ttb|,}} {{spar|enumerator}} {{ttb|1==}} {{spar|constant-expression}} {{ttb|,}} ... {{ttb|}&lt;!----&gt;}}
}}
{{sdsc|num=3|1=
{{ttb|enum struct{{!}}class}} {{spar|name}} {{ttb|;}}
}}
{{sdsc|num=4|1=
{{ttb|enum struct{{!}}class}} {{spar|name}} {{ttb|:}} {{spar|type}} {{ttb|;}}
}}
{{sdsc end}}

@1@ declares a scoped enumeration type whose underlying type is {{c/core|int}} (the keywords {{c/core|class}} and {{c/core|struct}} are exactly equivalent)
@2@ declares a scoped enumeration type whose underlying type is {{spar|type}}
@3@ opaque enum declaration for a scoped enumeration whose underlying type is {{c/core|int}}
@4@ opaque enum declaration for a scoped enumeration whose underlying type is {{spar|type}}

Each {{spar|enumerator}} becomes a named constant of the enumeration's type (that is, {{spar|name}}), which is contained within the scope of the enumeration, and can be accessed using scope resolution operator. There are no implicit conversions from the values of a scoped enumerator to integral types, although {{rlpt|static_cast}} may be used to obtain the numeric value of the enumerator.
{{example
|code=
#include &lt;iostream&gt;

int main()
{
    enum class Color { red, green = 20, blue };
    Color r = Color::blue;

    switch(r)
    {
        case Color::red  : std::cout &lt;&lt; "red\n";   break;
        case Color::green: std::cout &lt;&lt; "green\n"; break;
        case Color::blue : std::cout &lt;&lt; "blue\n";  break;
    }

    // int n = r; // error: no implicit conversion from scoped enum to int
    int n = static_cast&lt;int&gt;(r); // OK, n = 21
    std::cout &lt;&lt; n &lt;&lt; '\n'; // prints 21
}
}}
}}
{{anchor|enum_relaxed_init_cpp17}}
{{rrev|since=c++17|
An enumeration can be initialized from an integer without a cast, using {{rlp|list initialization}}, if all of the following are true:
* The initialization is direct-list-initialization.
* The initializer list has only a single element.
* The enumeration is either scoped or unscoped with underlying type fixed.
* The conversion is non-narrowing.

This makes it possible to introduce new integer types (e.g. {{tt|SafeInt}}) that enjoy the same existing calling conventions as their underlying integer types, even on ABIs that penalize passing/returning structures by value.

{{source|1=
enum byte : unsigned char {}; // byte is a new integer type; see also std::byte (C++17)
byte b{42};        // OK as of C++17 (direct-list-initialization)
byte c = {42};     // error
byte d = byte{42}; // OK as of C++17; same value as b
byte e{-1};        // error

struct A { byte b; };
A a1 = {&lt;!----&gt;{42}&lt;!----&gt;};     // error (copy-list-initialization of a constructor parameter)
A a2 = {byte{42}&lt;!----&gt;}; // OK as of C++17

void f(byte);
f({42}); // error (copy-list-initialization of a function parameter)

enum class Handle : std::uint32_t { Invalid = 0 };
Handle h{42}; // OK as of C++17
}}
}}


{{rrev|since=c++20|
==={{c/core|using enum}} declaration===
{{sdsc begin}}
{{sdsc|notes={{mark since c++20}}|
{{ttb|using enum}} {{spar|using-enum-declarator}} {{ttb|;}}
}}
{{sdsc end}}

{{par begin}}
{{par|{{spar|declarator}}|a (possibly qualified) {{rlp|identifiers|identifier}} or {{rlp|templates#Template identifiers|simple template identifiers}}}}
{{par end}}


{{spar|declarator}} must name a non-{{rlp|dependent name#Dependent types|dependent}} enumeration type. The enumeration declarations are found by type-only ordinary {{rlp|qualified lookup|qualified}} or {{rlp|unqualified lookup|unqualified}} lookup, depending on whether {{spar|declarator}} is qualified.

{{source|1=
enum E { x };

void f()
{
    int E;
    using enum E; // OK
}

using F = E;
using enum F; // OK

template&lt;class T&gt;
using EE = T;

void g()
{
    using enum EE&lt;E&gt;; // OK
}
}}

A {{c/core|using enum}} declaration introduces the enumerator names of the named enumeration as if by a {{rlp|using declaration|{{c/core|using}} declaration}} for each enumerator. When in class scope, a {{c/core|using enum}} declaration adds the enumerators of the named enumeration as members to the scope, making them accessible for member lookup.

{{source|1=
enum class fruit { orange, apple };

struct S
{
    using enum fruit; // OK: introduces orange and apple into S
};

void f()
{
    S s;
    s.orange;  // OK: names fruit::orange
    S::orange; // OK: names fruit::orange
}
}}

Two {{c/core|using enum}} declarations that introduce two enumerators of the same name conflict.
{{source|1=
enum class fruit { orange, apple };
enum class color { red, orange };

void f()
{
    using enum fruit;    // OK
    // using enum color; // error: color::orange and fruit::orange conflict
}
}}
}}

===Notes===
Values of unscoped enumeration type can be {{rlp|implicit conversion#Promotion from enumeration types|promoted}} or {{rlp|implicit conversion#Integral conversions|converted}} to integral types:
{{source|1=
enum color { red, yellow, green = 20, blue };
color col = red;
int n = blue; // n == 21
}}

Values of integer, floating-point, and enumeration types can be converted to any enumeration type by using {{rlpt|static_cast}}. Note that the value after such conversion may not necessarily equal any of the named enumerators defined for the enumeration:
{{source|1=
enum access_t { read = 1, write = 2, exec = 4 }; // enumerators: 1, 2, 4 range: 0..7
access_t rwe = static_cast&lt;access_t&gt;(7);
assert((rwe &amp; read) &amp;&amp; (rwe &amp; write) &amp;&amp; (rwe &amp; exec));

access_t x = static_cast&lt;access_t&gt;(8.0); // undefined behavior since CWG 1766
access_t y = static_cast&lt;access_t&gt;(8);   // undefined behavior since CWG 1766

enum foo { a = 0, b = UINT_MAX }; // range: [0, UINT_MAX]
foo x = foo(-1); // undefined behavior since CWG 1766,
                 // even if foo's underlying type is unsigned int
}}

{{ftm begin|core=1|std=1|comment=1}}
{{ftm|std=C++17|value=201411L|__cpp_enumerator_attributes|{{rlp|attributes|Attributes}} for enumerators}}
{{ftm|std=C++20|value=201907L|__cpp_using_enum|[[#Using-enum-declaration|{{tt|using enum}}]]}}
{{ftm end}}

===Keywords===
{{ltt|cpp/keyword/enum}},
{{ltt|cpp/keyword/struct}},
{{ltt|cpp/keyword/class}},
{{ltt|cpp/keyword/using}}

===Example===
{{example
|code=
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

// enum that takes 16 bits
enum smallenum: std::int16_t
{
    a,
    b,
    c
};

// color may be red (value 0), yellow (value 1), green (value 20), or blue (value 21)
enum color
{
    red,
    yellow,
    green = 20,
    blue
};

// altitude may be altitude::high or altitude::low
enum class altitude: char
{
    high = 'h',
    low = 'l', // trailing comma only allowed after CWG 518
}; 

// the constant d is 0, the constant e is 1, the constant f is 3
enum
{
    d,
    e,
    f = e + 2
};

// enumeration types (both scoped and unscoped) can have overloaded operators
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, color c)
{
    switch(c)
    {
        case red   : os &lt;&lt; "red";    break;
        case yellow: os &lt;&lt; "yellow"; break;
        case green : os &lt;&lt; "green";  break;
        case blue  : os &lt;&lt; "blue";   break;
        default    : os.setstate(std::ios_base::failbit);
    }
    return os;
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, altitude al)
{
    return os &lt;&lt; static_cast&lt;char&gt;(al);
}

// The scoped enum (C++11) can be partially emulated in earlier C++ revisions:

enum struct E11 { x, y }; // since C++11

struct E98 { enum { x, y }; }; // OK in pre-C++11

namespace N98 { enum { x, y }; } // OK in pre-C++11

struct S98 { static const int x = 0, y = 1; }; // OK in pre-C++11

void emu()
{
    std::cout &lt;&lt; (static_cast&lt;int&gt;(E11::y) + E98::y + N98::y + S98::y) &lt;&lt; '\n'; // 4
}

namespace cxx20
{
    enum class long_long_long_name { x, y };

    void using_enum_demo()
    {
        std::cout &lt;&lt; "C++20 `using enum`: __cpp_using_enum == ";
        switch (auto rnd = []{return long_long_long_name::x;}; rnd())
        {
#if defined(__cpp_using_enum)
            using enum long_long_long_name;
            case x: std::cout &lt;&lt; __cpp_using_enum &lt;&lt; "; x\n"; break;
            case y: std::cout &lt;&lt; __cpp_using_enum &lt;&lt; "; y\n"; break;
#else
            case long_long_long_name::x: std::cout &lt;&lt; "?; x\n"; break;
            case long_long_long_name::y: std::cout &lt;&lt; "?; y\n"; break;
#endif
        }
    }
}

int main()
{
    color col = red;
    altitude a;
    a = altitude::low;

    std::cout &lt;&lt; "col = " &lt;&lt; col &lt;&lt; '\n'
              &lt;&lt; "a = "   &lt;&lt; a   &lt;&lt; '\n'
              &lt;&lt; "f = "   &lt;&lt; f   &lt;&lt; '\n';

    cxx20::using_enum_demo();
}
|p=true
|output=
col = red
a = l
f = 3
C++20 `using enum`: __cpp_using_enum == 201907; x
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=377|std=C++98|before=the behavior was unspecified when no integral&lt;br&gt;type can represent all the enumerator values|after=the enumeration is ill-&lt;br&gt;formed in this case}}
{{dr list item|wg=cwg|dr=518|std=C++98|before=a trailing comma was not allowed after the enumerator list|after=allowed}}
{{dr list item|wg=cwg|dr=1514|std=C++11|before=a redefinition of enumeration with fixed underlying type&lt;br&gt;could be parsed as a bit-field in a class member declaration|after=always parsed as a redefinition}}
{{dr list item|wg=cwg|dr=1638|std=C++11|before=grammar of opaque enumeration declaration&lt;br&gt;prohibited use for template specializations|after=nested-name-specifier&lt;br&gt;permitted}}
{{dr list item|wg=cwg|dr=1766|std=C++98|before=casting an out-of-range value to an enumeration&lt;br&gt;without fixed underlying type had an unspecified result|after=the behavior is undefined}}
{{dr list item|wg=cwg|dr=1966|std=C++11|before=the resolution of {{cwg|1514}} made the {{tt|:}}&lt;br&gt;of a conditional expression part of {{spar|enum-base}}|after=only apply the resolution to&lt;br&gt;member declaration specifiers}}
{{dr list item|wg=cwg|dr=2156|std=C++11|before=enum definitions could define&lt;br&gt;enumeration types by using-declarations|after=prohibited}}
{{dr list item|wg=cwg|dr=2157|std=C++11|before=the resolution of {{cwg|1966}} did&lt;br&gt;not cover qualified enumeration names|after=covered}}
{{dr list item|wg=cwg|dr=2530|std=C++98|before=an enumerator list could contain multiple&lt;br&gt;enumerators with the same identifier|after=prohibited}}
{{dr list item|wg=cwg|dr=2590|std=C++98|before=the size, value representation and alignment requirements&lt;br&gt;of an enumeration did not depend on its underlying type|after=all of them are identical to&lt;br&gt;those of the underlying type}}
{{dr list item|wg=cwg|dr=2621|std=C++20|before=the enumeration name lookup used in&lt;br&gt;{{c/core|using enum}} declarations was unclear|after=made clear}}
{{dr list item|wg=cwg|dr=2877|std=C++20|before=the enumeration name lookup used in&lt;br&gt;{{c/core|using enum}} declarations was not type-only|after=made type-only}}
{{dr list end}}

===References===
{{ref std c++23}}
{{ref std|section=9.7.1|title=Enumeration declarations|id=dcl.enum}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=9.7.1|title=Enumeration declarations|id=dcl.enum}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=10.2|title=Enumeration declarations|id=dcl.enum}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=7.2|title=Enumeration declarations|id=dcl.enum}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=7.2|title=Enumeration declarations|id=dcl.enum}}
{{ref std end}}
{{ref std c++03}}
{{ref std|section=7.2|title=Enumeration declarations|id=dcl.enum}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=7.2|title=Enumeration declarations|id=dcl.enum}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_enum}}
{{dsc inc|cpp/types/dsc is_scoped_enum}}
{{dsc inc|cpp/types/dsc underlying_type}}
{{dsc inc|cpp/utility/dsc to_underlying}}
{{dsc see c|c/language/enum|Enumerations|nomono=true}}
{{dsc end}}

{{langlinks|ar|de|es|fr|it|ja|pt|ru|zh}}