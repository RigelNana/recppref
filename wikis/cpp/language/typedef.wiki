{{title|{{tt|typedef}} specifier}}
{{cpp/language/declarations/navbar}}

:* {{ttb|typedef}} - creates an alias that can be used anywhere in place of a (possibly complex) type name.

===Explanation===
The {{c/core|typedef}} specifier, when used in a {{rlp|declarations|declaration}}, specifies that the declaration is a ''typedef declaration'' rather than a variable or function declaration.

Typically, the {{c/core|typedef}} specifier appears at the start of the declaration, though it is permitted to appear after the {{rlp|declarations#Specifiers|type specifiers}}, or between two type specifiers. The {{c/core|typedef}} specifier cannot be combined with any other specifier except for type specifiers.

A typedef declaration may declare one or many identifiers on the same line (e.g. {{c/core|int}} and a pointer to {{c/core|int}}), it may declare array and function types, pointers and references, class types, etc. Every identifier introduced in this declaration becomes a ''typedef name'', which is a synonym for the type of the object or function that it would become if the keyword {{c/core|typedef}} were removed.

The typedef names are aliases for existing types, and are not declarations of new types. {{c/core|typedef}} cannot be used to change the meaning of an existing type name (including a typedef name). Once declared, a typedef name may only be redeclared to refer to the same type again. Typedef names are only in effect in the scope where they are visible: different functions or class declarations may define identically-named types with different meaning.

The {{c/core|typedef}} specifier may not appear in the declaration of a function parameter nor in the {{spar|decl-specifier-seq}} of a {{rlpsd|function#Function definition}}:
{{source|code=
void f1(typedef int param); // ill-formed
typedef int f2() {}         // ill-formed
}}

The {{c/core|typedef}} specifier may not appear in a declaration that does not contain a declarator:
{{source|code=
typedef struct X {}; // ill-formed
}}

===typedef name for linkage purposes===
If a typedef declaration defines an unnamed {{rlp|classes|class}} or {{rlp|enum|enumeration}}, the first typedef name of the class type or enumeration type declared by the declaration is the ''typedef name for linkage purposes'' of that type.

For example, in {{c|typedef struct { /* ... */ } S;}}, {{tt|S}} is a typedef name for linkage purposes. The class or enumeration type defined in this way has {{rlp|storage duration#Linkage|external linkage}} (unless it is in an unnamed namespace).

{{rrev|since=c++20|
An unnamed class defined in this way should only contain C-compatible constructs. In particular, it must not

* declare any members other than non-static data members, member enumerations, or member classes,
* have any {{rlp|derived class|base classes}} or {{rlp|data members#Member initialization|default member initializers}}, or
* contain a {{rlp|lambda|lambda expression}},

and all member classes must also satisfy these requirements (recursively). 
}}

===Notes===
{{rrev|since=c++11|
{{rlp|type alias|Type aliases}} provide the same functionality as typedef declarations using a different syntax, and are also applicable to template names.
}}

===Keywords===
{{ltt|cpp/keyword/typedef}}

===Example===
{{source|code=
// simple typedef
typedef unsigned long ulong;

// the following two objects have the same type
unsigned long l1;
ulong l2;

// more complicated typedef
typedef int int_t, *intp_t, (&amp;fp)(int, ulong), arr_t[10];

// the following two objects have the same type
int a1[10];
arr_t a2;

// beware: the following two objects do not have the same type
const intp_t p1 = 0; // int *const p1 = 0
const int *p2;

// common C idiom to avoid having to write "struct S"
typedef struct { int a; int b; } S, *pS;

// the following two objects have the same type
pS ps1;
S* ps2;

// error: storage-class-specifier cannot appear in a typedef declaration
// typedef static unsigned int uint;

// typedef can be used anywhere in the decl-specifier-seq
long unsigned typedef int long ullong;
// more conventionally spelled "typedef unsigned long long int ullong;"

// std::add_const, like many other metafunctions, use member typedefs
template&lt;class T&gt;
struct add_const
{
    typedef const T type;
};

typedef struct Node
{
    struct listNode* next; // declares a new (incomplete) struct type named listNode
} listNode; // error: conflicts with the previously declared struct name

// C++20 error: "struct with typedef name for linkage" has member functions
typedef struct { void f() {} } C_Incompatible;
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=576|std=C++98|before={{c/core|typedef}} was not allowed in the entire function definition|after=allowed in function body}}
{{dr list item|wg=cwg|dr=2071|std=C++98|before={{c/core|typedef}} could appear in a declaration that does not contain a declarator|after=now disallowed}}
{{dr list end}}

===See also===
* {{rlp|type alias|Type alias}}
* {{rlp|type alias|Alias template}}
{{dsc begin}}
{{dsc see c|c/language/typedef|Typedef declaration}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}