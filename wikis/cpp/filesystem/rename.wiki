{{cpp/filesystem/title|rename}}
{{cpp/filesystem/navbar}}
{{dcl begin}}
{{dcl header|filesystem}}
{{dcl|num=1|since=c++17|1=
void rename( const std::filesystem::path&amp; old_p,
             const std::filesystem::path&amp; new_p );
}}
{{dcl|num=2|since=c++17|1=
void rename( const std::filesystem::path&amp; old_p,
             const std::filesystem::path&amp; new_p,
             std::error_code&amp; ec ) noexcept;
}}
{{dcl end}}

Moves or renames the filesystem object identified by {{c|old_p}} to {{c|new_p}} as if by the POSIX [https://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html {{tt|rename}}]:

* If {{c|old_p}} is a non-directory file, then {{c|new_p}} must be one of:
:* the same file as {{c|old_p}} or a hardlink to it: nothing is done in this case.
:* existing non-directory file: {{c|new_p}} is first deleted, then, without allowing other processes to observe {{c|new_p}} as deleted, the pathname {{c|new_p}} is linked to the file and {{c|old_p}} is unlinked from the file. Write permissions are required to both the directory that contains {{c|old_p}} and the directory that contains {{c|new_p}}.
:* non-existing file in an existing directory: The pathname {{c|new_p}} is linked to the file and {{c|old_p}} is unlinked from the file. Write permissions are required to both the directory that contains {{c|old_p}} and the directory that contains {{c|new_p}}.
* If {{c|old_p}} is a directory, then {{c|new_p}} must be one of:
:* the same directory as {{c|old_p}} or a hardlink to it: nothing is done in this case.
:* existing directory: {{c|new_p}} is deleted if empty on POSIX systems, but this may be an error on other systems. If not an error, then {{c|new_p}} is first deleted, then, without allowing other processes to observe {{c|new_p}} as deleted, the pathname {{c|new_p}} is linked to the directory and {{c|old_p}} is unlinked from the directory. Write permissions are required to both the directory that contains {{c|old_p}} and the directory that contains {{c|new_p}}.
:* non-existing directory, not ending with a directory separator, and whose parent directory exists: The pathname {{c|new_p}} is linked to the directory and {{c|old_p}} is unlinked from the directory. Write permissions are required to both the directory that contains {{c|old_p}} and the directory that contains {{c|new_p}}.
* Symlinks are not followed: if {{c|old_p}} is a symlink, it is itself renamed, not its target. If {{c|new_p}} is an existing symlink, it is itself erased, not its target.

Rename fails if
* {{c|new_p}} ends with {{spar|dot}} or with {{spar|dot-dot}}.
* {{c|new_p}} names a non-existing directory ending with a directory separator.
* {{c|old_p}} is a directory which is an ancestor of {{c|new_p}}.

===Parameters===
{{par begin}}
{{par|old_p|path to move or rename}}
{{par|new_p|target path for the move/rename operation}}
{{par|ec|out-parameter for error reporting in the non-throwing overload}}
{{par end}}

===Return value===
(none)

===Exceptions===
{{cpp/filesystem/error_handling|old_p|new_p|throw=1/2}}

===Example===
{{example
|code=
#include &lt;filesystem&gt;
#include &lt;fstream&gt;
namespace fs = std::filesystem;

int main()
{
    std::filesystem::path p = std::filesystem::current_path() / "sandbox";
    std::filesystem::create_directories(p / "from");
    std::ofstream{ p / "from/file1.txt" }.put('a');
    std::filesystem::create_directory(p / "to");

//  fs::rename(p / "from/file1.txt", p / "to/"); // error: "to" is a directory
    fs::rename(p / "from/file1.txt", p / "to/file2.txt"); // OK
//  fs::rename(p / "from", p / "to"); // error: "to" is not empty
    fs::rename(p / "from", p / "to/subdir"); // OK

    std::filesystem::remove_all(p);
}
|output=
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/c/dsc rename}}
{{dsc inc|cpp/filesystem/dsc remove}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}