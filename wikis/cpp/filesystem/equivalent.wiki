{{cpp/filesystem/title|equivalent}}
{{cpp/filesystem/navbar}}
{{dcl begin}}
{{dcl header|filesystem}}
{{dcl|num=1|since=c++17|1=
bool equivalent( const std::filesystem::path&amp; p1,
                 const std::filesystem::path&amp; p2 );
}}
{{dcl|num=2|since=c++17|1=
bool equivalent( const std::filesystem::path&amp; p1,
                 const std::filesystem::path&amp; p2,
                 std::error_code&amp; ec ) noexcept;
}}
{{dcl end}}

Checks whether the paths {{c|p1}} and {{c|p2}} resolve to the same file system entity.

If either {{c|p1}} or {{c|p2}} does not exist, an error is reported.

The non-throwing overload returns {{c|false}} on errors.

===Parameters===
{{par begin}}
{{par|p1, p2|paths to check for equivalence}}
{{par|ec|out-parameter for error reporting in the non-throwing overload}}
{{par end}}

===Return value===
{{c|true}} if the {{c|p1}} and {{c|p2}} refer to the same file or directory and their file status is the same. {{c|false}} otherwise.

===Exceptions===
{{cpp/filesystem/error_handling|p1|p2|throw=1/2}}

===Notes===
Two paths are considered to resolve to the same file system entity if the two candidate entities the paths resolve to are located on the same device at the same location. For POSIX, this means that the {{tt|st_dev}} and {{tt|st_ino}} members of their POSIX [https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html {{tt|stat}} structure], obtained as if by POSIX [https://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html {{tt|stat()}}], are equal.

In particular, all hard links for the same file or directory are equivalent, and a symlink and its target on the same file system are equivalent.

===Example===
{{example
|code=
#include &lt;cstdint&gt;
#include &lt;filesystem&gt;
#include &lt;iostream&gt;
namespace fs = std::filesystem;

int main()
{
    // hard link equivalency
    fs::path p1 = ".";
    fs::path p2 = fs::current_path();
    if (fs::equivalent(p1, p2))
        std::cout &lt;&lt; p1 &lt;&lt; " is equivalent to " &lt;&lt; p2 &lt;&lt; '\n';

    // symlink equivalency
    for (const fs::path lib : {"/lib/libc.so.6", "/lib/x86_64-linux-gnu/libc.so.6"})
    {
        try
        {
            p2 = lib.parent_path() / fs::read_symlink(lib);
        }
        catch (std::filesystem::filesystem_error const&amp; ex)
        {
            std::cout &lt;&lt; ex.what() &lt;&lt; '\n';
            continue;
        }

        if (fs::equivalent(lib, p2))
            std::cout &lt;&lt; lib &lt;&lt; " is equivalent to " &lt;&lt; p2 &lt;&lt; '\n';
    }
}
|p=true
|output=
"." is equivalent to "/var/tmp/test"
filesystem error: read_symlink: No such file or directory [/lib/libc.so.6]
"/lib/x86_64-linux-gnu/libc.so.6" is equivalent to "/lib/x86_64-linux-gnu/libc-2.23.so"
}}

===Defect reports===
{{dr list begin}}
{{dr list item|dr=2937|wg=lwg|std=C++17|before=error condition specified incorrectly|after=corrected}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/filesystem/path/dsc compare}}
{{dsc inc|cpp/filesystem/path/dsc operator_cmp}}
{{dsc inc|cpp/filesystem/dsc status}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}