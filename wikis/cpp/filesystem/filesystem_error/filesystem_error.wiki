{{cpp/filesystem/filesystem_error/title|filesystem_error}}
{{cpp/filesystem/filesystem_error/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++17|
filesystem_error( const std::string&amp; what_arg,
                  std::error_code ec );
}}
{{dcl|num=2|since=c++17|
filesystem_error( const std::string&amp; what_arg,
                  const std::filesystem::path&amp; p1,
                  std::error_code ec );
}}
{{dcl|num=3|since=c++17|
filesystem_error( const std::string&amp; what_arg,
                  const std::filesystem::path&amp; p1,
                  const std::filesystem::path&amp; p2,
                  std::error_code ec );
}}
{{dcl|num=4|since=c++17|
filesystem_error( const filesystem_error&amp; other ) noexcept;
}}
{{dcl end}}

Constructs a new {{tt|filesystem_error}} object.

@1-3@ The error code is set to {{c|ec}} and optionally, the paths that were involved in the operation that resulted in the error, are set to {{c|p1}} and {{c|p2}}. {{rlpf|what}} after construction returns a string that contains {{c|what_arg}} (assuming that it does not contain an embedded null character &lt;!-- LWG3112 --&gt;). If either or both {{tt|path}} arguments are not provided, a null {{tt|path}} is used instead.

@4@ Copy constructor. Initialize the contents with those of {{tt|other}}. If {{c|*this}} and {{c|other}} both have dynamic type {{tt|std::filesystem_error::filesystem_error}} then {{c|1=std::strcmp(what(), other.what()) == 0}}.

===Parameters===
{{par begin}}
{{par|what_arg|explanatory string}}
{{par|ec|error code for the specific operating system dependent error}}
{{par|p1, p2|paths involved in the operation raising system error}}
{{par|other|another {{tt|filesystem_error}} object to copy}}
{{par end}}

===Notes===
Because copying {{tt|std::filesystem::filesystem_error}} is not permitted to throw exceptions, the explanatory string is typically stored internally in a separately-allocated reference-counted storage. This is also why there is no constructor taking {{tt|std::string&amp;&amp;}}: it would have to copy the content anyway.

Typical implementations also store {{tt|path}} objects referenced by {{lc|path1()}} and {{lc|path2()}} in the reference-counted storage.

===Example===
{{example}}

{{langlinks|es|ja|ru|zh}}