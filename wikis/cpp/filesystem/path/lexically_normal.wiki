{{cpp/filesystem/path/title|lexically_normal|lexically_relative|lexically_proximate}}
{{cpp/filesystem/path/navbar}}
{{dcl begin}}
{{dcl|since=c++17|num=1|1=
path lexically_normal() const;
}}
{{dcl|since=c++17|num=2|1=
path lexically_relative( const path&amp; base ) const;
}}
{{dcl|since=c++17|num=3|1=
path lexically_proximate( const path&amp; base ) const;
}}
{{dcl end}}

@1@ Returns {{c|*this}} converted to [[cpp/filesystem/path|normal form]] in its generic format.
@2@ Returns {{c|*this}} made relative to {{c|base}}. 
:* First, if {{c|1=root_name() != base.root_name()}} is {{c|true}} or {{c|1=is_absolute() != base.is_absolute()}} is {{c|true}} or {{c|(!has_root_directory() &amp;&amp; base.has_root_directory())}} is {{c|true}} or any filename in {{c|relative_path()}} or {{c|base.relative_path()}} can be interpreted as a {{spar|root-name}}, returns a default-constructed path.
:* Otherwise, first determines the first mismatched element of {{c|*this}} and {{c|base}} as if by {{c|auto [a, b] {{=}} mismatch(begin(), end(), base.begin(), base.end())}}, then
::* if {{c|a {{==}} end()}} and {{c|b {{==}} base.end()}}, returns {{c|path(".")}},
::* otherwise, define {{math|N}} as the number of nonempty filename elements that are neither {{spar|dot}} nor {{spar|dot-dot}} in {{c|[b, base.end())}}, minus the number of {{spar|dot-dot}} filename elements, If {{math|N &lt; 0}}, returns a default-constructed path,
::* otherwise, if {{math|N {{=}} 0}} and {{c|a {{==}} end() {{!!}} a-&gt;empty()}}, returns {{c|path(".")}},
::* otherwise returns an object composed from
:::* a default-constructed {{c|path()}} followed by
:::* {{math|N}} applications of {{c|operator/{{=}}(path(".."))}}, followed by
:::* one application of {{c|1=operator/=}} for each element in the half-open range {{range|a|end()}}.
@3@ If the value of {{c|lexically_relative(base)}} is not an empty path, return it. Otherwise return {{c|*this}}.

===Parameters===
(none)

===Return value===
@1@ The normal form of the path.
@2@ The relative form of the path.
@3@ The proximate form of the path.

{{cpp/impldef exception}}

===Notes===
These conversions are purely lexical. They do not check that the paths exist, do not follow symlinks, and do not access the filesystem at all. For symlink-following counterparts of {{tt|lexically_relative}} and {{tt|lexically_proximate}}, see {{ltt|cpp/filesystem/relative|relative}} and {{ltt|cpp/filesystem/relative|proximate}}.

On Windows, the returned {{tt|path}} has backslashes (the preferred separators).

On POSIX, no filename in a relative path is acceptable as a {{spar|root-name}}.

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;filesystem&gt;
#include &lt;iostream&gt;
namespace fs = std::filesystem;

int main()
{
    assert(fs::path("a/./b/..").lexically_normal() == "a/");
    assert(fs::path("a/.///b/../").lexically_normal() == "a/");
    assert(fs::path("/a/d").lexically_relative("/a/b/c") == "../../d");
    assert(fs::path("/a/b/c").lexically_relative("/a/d") == "../b/c");
    assert(fs::path("a/b/c").lexically_relative("a") == "b/c");
    assert(fs::path("a/b/c").lexically_relative("a/b/c/x/y") == "../..");
    assert(fs::path("a/b/c").lexically_relative("a/b/c") == ".");
    assert(fs::path("a/b").lexically_relative("c/d") == "../../a/b");
    assert(fs::path("a/b").lexically_relative("/a/b") == "");
    assert(fs::path("a/b").lexically_proximate("/a/b") == "a/b");
}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3070|std=c++17|before=a filename that can also be a root-name may cause surprising result|after=treated as error case}}
{{dr list item|wg=lwg|dr=3096|std=c++17|before=trailing "/" and "/." are handled incorrectly|after=corrected}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/filesystem/dsc relative}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}