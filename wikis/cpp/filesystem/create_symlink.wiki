{{cpp/filesystem/title|create_symlink|create_directory_symlink}}
{{cpp/filesystem/navbar}}
{{dcl begin}}
{{dcl header|filesystem}}
{{dcl|num=1|since=c++17|1=
void create_symlink( const std::filesystem::path&amp; target,
                     const std::filesystem::path&amp; link );
}}
{{dcl|num=2|since=c++17|1=
void create_symlink( const std::filesystem::path&amp; target,
                     const std::filesystem::path&amp; link,
                     std::error_code&amp; ec ) noexcept;
}}
{{dcl|num=3|since=c++17|1=
void create_directory_symlink( const std::filesystem::path&amp; target,
                               const std::filesystem::path&amp; link );
}}
{{dcl|num=4|since=c++17|1=
void create_directory_symlink( const std::filesystem::path&amp; target,
                               const std::filesystem::path&amp; link,
                               std::error_code&amp; ec ) noexcept;
}}
{{dcl end}}

Creates a symbolic link {{c|link}} with its target set to {{c|target}} as if by POSIX [https://pubs.opengroup.org/onlinepubs/9699919799/functions/symlink.html {{tt|symlink()}}]: the pathname {{c|target}} may be invalid or non-existing.

Some operating systems require symlink creation to identify that the link is to a directory. Portable code should use {{v|3,4}} to create directory symlinks rather than {{v|1,2}}, even though there is no distinction on POSIX systems.

===Parameters===
{{par begin}}
{{par|target|path to point the symlink to, does not have to exist}}
{{par|link|path of the new symbolic link}}
{{par|ec|out-parameter for error reporting in the non-throwing overload}}
{{par end}}

===Return value===
(none)

===Exceptions===
{{cpp/filesystem/error_handling|target|link|throw=1,3/2,4}}

===Notes===
Some operating systems do not support symbolic links at all or support them only for regular files.

Some file systems do not support symbolic links regardless of the operating system, for example the FAT system used on some memory cards and flash drives.

Like a hard link, a symbolic link allows a file to have multiple logical names. The presence of a hard link guarantees the existence of a file, even after the original name has been removed. A symbolic link provides no such assurance; in fact, the file named by the {{c|target}} argument need not exist when the link is created. A symbolic link can cross file system boundaries.

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;filesystem&gt;
#include &lt;iostream&gt;
namespace fs = std::filesystem;

int main()
{
    fs::create_directories("sandbox/subdir");
    fs::create_symlink("target", "sandbox/sym1");
    fs::create_directory_symlink("subdir", "sandbox/sym2");

    for (auto it = fs::directory_iterator("sandbox"); it != fs::directory_iterator(); ++it)
        if (is_symlink(it-&gt;symlink_status()))
            std::cout &lt;&lt; *it &lt;&lt; "-&gt;" &lt;&lt; read_symlink(*it) &lt;&lt; '\n';

    assert(std::filesystem::equivalent("sandbox/sym2", "sandbox/subdir"));
    fs::remove_all("sandbox");
}
|p=true
|output=
"sandbox/sym1"-&gt;"target"
"sandbox/sym2"-&gt;"subdir"
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/filesystem/dsc status}}
{{dsc inc|cpp/filesystem/dsc read_symlink}}
{{dsc inc|cpp/filesystem/dsc create_hard_link}}
{{dsc end}}

{{langlinks|es|ja|zh}}