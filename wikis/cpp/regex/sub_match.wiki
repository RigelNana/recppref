{{cpp/title|sub_match}}
{{cpp/regex/sub_match/navbar}}
{{ddcl|header=regex|since=c++11|
template&lt; class BidirIt &gt;
class sub_match;
}}

The class template {{tt|std::sub_match}} is used by the regular expression engine to denote sequences of characters matched by marked sub-expressions.
A match is a {{range|begin|end}} pair within the target range matched by the regular expression, but with additional observer functions to enhance code clarity.

Only the default constructor is publicly accessible. Instances of {{tt|std::sub_match}} are normally constructed and populated as a part of a {{lc|std::match_results}} container during the processing of one of the regex algorithms.

The member functions return defined default values unless the [[#Data members|{{tt|matched}}]] member is {{c|true}}.

{{tt|std::sub_match}} inherits from {{c/core|std::pair&lt;BidirIt, BidirIt&gt;}}, although it cannot be treated as a {{lc|std::pair}} object because member functions such as assignment will not work as expected.

===Type requirements===
{{par begin}}
{{par req named|BidirIt|BidirectionalIterator}}
{{par end}}

===Specializations===
Several specializations for common character sequence types are provided: 

{{dsc begin}}
{{dsc header|regex}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|std::csub_match}}|{{c/core|std::sub_match&lt;const char*&gt;}}}}
{{dsc|{{tt|std::wcsub_match}}|{{c/core|std::sub_match&lt;const wchar_t*&gt;}}}}
{{dsc|{{tt|std::ssub_match}}|{{c/core|std::sub_match&lt;std::string::const_iterator&gt;}}}}
{{dsc|{{tt|std::wssub_match}}|{{c/core|std::sub_match&lt;std::wstring::const_iterator&gt;}}}}
{{dsc end}}

===Nested types===
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|iterator}}|{{tt|BidirIt}}}}
{{dsc|{{tt|value_type}}|{{c/core|std::iterator_traits&lt;BidirIt&gt;::value_type}}}}
{{dsc|{{tt|difference_type}}|{{c/core|std::iterator_traits&lt;BidirIt&gt;::difference_type}}}}
{{dsc|{{tt|string_type}}|{{c/core|std::basic_string&lt;value_type&gt;}}}}
{{dsc end}}

===Data members===
{{dsc begin}}
{{dsc hitem|Member|Description}}
{{dsc mem obj|nolink=true|{{dsc small|{{c/core|bool}}}} {{tt|matched}}|whether this match was successful}}
{{dsc end}}

{{inherited|[[cpp/utility/pair|{{small|std::}}pair]]|
{{dsc begin}}
{{dsc mem obj|nolink=true|{{dsc small|BidirIt}} first|start of the match sequence}}
{{dsc mem obj|nolink=true|{{dsc small|BidirIt}} second|one-past-the-end of the match sequence}}
{{dsc end}}
}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/regex/sub_match/dsc constructor}}
{{dsc h2|Observers}}
{{dsc inc|cpp/regex/sub_match/dsc length}}
{{dsc inc|cpp/regex/sub_match/dsc str}}
{{dsc inc|cpp/regex/sub_match/dsc compare}}
{{dsc h2|Modifiers}}
{{dsc inc|cpp/regex/sub_match/dsc swap}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/regex/sub_match/dsc operator_cmp}}
{{dsc inc|cpp/regex/sub_match/dsc operator_ltlt}}
{{dsc end}}

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

int main()
{
    std::string sentence{"Friday the thirteenth."};
    const std::regex re{"([A-z]+) ([a-z]+) ([a-z]+)"};
    std::smatch words;
    std::regex_search(sentence, words, re);
    std::cout &lt;&lt; std::boolalpha;
    for (const auto&amp; m : words)
    {
        assert(m.matched);
        std::cout &lt;&lt; "m: [" &lt;&lt; m &lt;&lt; "], m.length(): " &lt;&lt; m.length() &lt;&lt; ", "
                     "*m.first: '" &lt;&lt; *m.first &lt;&lt; "', "
                     "*m.second: '" &lt;&lt; *m.second &lt;&lt; "'\n";
    }
}
|output=
m: [Friday the thirteenth], m.length(): 21, *m.first: 'F', *m.second: '.'
m: [Friday], m.length(): 6, *m.first: 'F', *m.second: ' '
m: [the], m.length(): 3, *m.first: 't', *m.second: ' '
m: [thirteenth], m.length(): 10, *m.first: 't', *m.second: '.'
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/regex/dsc regex_token_iterator}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}