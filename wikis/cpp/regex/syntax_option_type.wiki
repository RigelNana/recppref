{{cpp/title|n=regex_constants::|syntax_option_type}}
{{cpp/regex/navbar}}

{{dcl begin}}
{{dcl header|regex}}
{{dcl|num=1|since=c++11|1=
using syntax_option_type = /* implementation-defined */;
}}
{{dcl|num=2|since=c++11|notes={{mark|inline since C++17}}|1=
constexpr syntax_option_type icase      = /* unspecified */;
constexpr syntax_option_type nosubs     = /* unspecified */;
constexpr syntax_option_type optimize   = /* unspecified */;
constexpr syntax_option_type collate    = /* unspecified */;
constexpr syntax_option_type ECMAScript = /* unspecified */;
constexpr syntax_option_type basic      = /* unspecified */;
constexpr syntax_option_type extended   = /* unspecified */;
constexpr syntax_option_type awk        = /* unspecified */;
constexpr syntax_option_type grep       = /* unspecified */;
constexpr syntax_option_type egrep      = /* unspecified */;
}}
{{dcl|num=3|since=c++17|1=
inline constexpr syntax_option_type multiline = /* unspecified */;
}}
{{dcl end}}

@1@ The {{tt|syntax_option_type}} is a {{named req|BitmaskType}} that contains options that govern how regular expressions behave.

@2,3@ The possible values ({{tt|icase}}, {{tt|optimize}}, etc.) for type {{v|1}} are duplicated inside {{ltt|cpp/regex/basic_regex/constants|std::basic_regex}}.

===Constants===
{{cpp/regex/syntax option type consts}}

===Notes===
Because POSIX uses "leftmost longest" matching rule (the longest matching subsequence is matched, and if there are several such subsequences, the first one is matched), it is not suitable, for example, for parsing markup languages: a POSIX regex such as {{c|"&lt;tag[^&gt;]*&gt;.*&lt;/tag&gt;"}} would match everything from the first {{c|"&lt;tag"}} to the last {{c|"&lt;/tag&gt;"}}, including every {{c|"&lt;/tag&gt;"}} and {{c|"&lt;tag&gt;"}} in-between. On the other hand, ECMAScript supports non-greedy matches, and the ECMAScript regex {{c|"&lt;tag[^&gt;]*&gt;.*?&lt;/tag&gt;"}} would match only until the first closing tag.

===Example===
{{example
|Illustrates the difference in the matching algorithm between ECMAScript and POSIX regular expressions:
|code=
#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

int main()
{
    std::string str = "zzxayyzz";
    std::regex re1(".*(a{{!}}xayy)"); // ECMA
    std::regex re2(".*(a{{!}}xayy)", std::regex::extended); // POSIX
    
    std::cout &lt;&lt; "Searching for .*(a{{!}}xayy) in zzxayyzz:\n";
    std::smatch m;
    std::regex_search(str, m, re1);
    std::cout &lt;&lt; "  ECMA (depth first search) match: " &lt;&lt; m[0] &lt;&lt; '\n';
    std::regex_search(str, m, re2);
    std::cout &lt;&lt; "  POSIX (leftmost longest)  match: " &lt;&lt; m[0] &lt;&lt; '\n';
}
|output=
Searching for .*(a{{!}}xayy) in zzxayyzz:
  ECMA (depth first search) match: zzxa
  POSIX (leftmost longest)  match: zzxayy
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2053|std=C++11|before=the constants were declared {{c/core|static}}|after=removed the {{c/core|static}} specifier}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/regex/dsc basic_regex}}
{{dsc end}}

{{langlinks|ar|de|es|fr|it|ja|ko|pt|ru|zh}}