{{cpp/title|n=regex_constants::|error_type}}
{{cpp/regex/navbar}}
{{dcl begin}}
{{dcl header|regex}}
{{dcl|num=1|since=c++11|1=
using error_type = /* implementation-defined */;
}}
{{dcl|num=2|since=c++11|notes={{mark|inline since C++17}}|1=
constexpr error_type error_collate =    /* unspecified */;
constexpr error_type error_ctype =      /* unspecified */;
constexpr error_type error_escape =     /* unspecified */;
constexpr error_type error_backref =    /* unspecified */;
constexpr error_type error_brack =      /* unspecified */;
constexpr error_type error_paren =      /* unspecified */;
constexpr error_type error_brace =      /* unspecified */;
constexpr error_type error_badbrace =   /* unspecified */;
constexpr error_type error_range =      /* unspecified */;
constexpr error_type error_space =      /* unspecified */;
constexpr error_type error_badrepeat =  /* unspecified */;
constexpr error_type error_complexity = /* unspecified */;
constexpr error_type error_stack =      /* unspecified */;
}}
{{dcl end}}

@1@ The {{tt|error_type}} is a type that describes errors that may occur during regular expression parsing.

===Constants===
{{dsc begin}}
{{dsc hitem|Name|Explanation}}
{{dsc|{{tt|error_collate}}|the expression contains an invalid collating element name}}
{{dsc|{{tt|error_ctype}}|the expression contains an invalid character class name}}
{{dsc|{{tt|error_escape}}|the expression contains an invalid escaped character or a trailing escape}}
{{dsc|{{tt|error_backref}}|the expression contains an invalid back reference}}
{{dsc|{{tt|error_brack}}|the expression contains mismatched square brackets ({{c|'['}} and {{c|']'}})}}
{{dsc|{{tt|error_paren}}|the expression contains mismatched parentheses ({{c|'('}} and {{c|')'}})}}
{{dsc|{{tt|error_brace}}|the expression contains mismatched curly braces ({{c|'{'}} and {{c|'}'}})}}
{{dsc|{{tt|error_badbrace}}|the expression contains an invalid range in a {{c|{}&lt;!----&gt;}} expression}}
{{dsc|{{tt|error_range}}|the expression contains an invalid character range (e.g. [b-a])}}
{{dsc|{{tt|error_space}}|there was not enough memory to convert the expression into a finite state machine}}
{{dsc|{{tt|error_badrepeat}}|{{c|'*'}}, {{c|'?'}}, {{c|'+'}} or {{c|'{'}} was not preceded by a valid regular expression}}
{{dsc|{{tt|error_complexity}}|the complexity of an attempted match exceeded a predefined level}}
{{dsc|{{tt|error_stack}}|there was not enough memory to perform a match}}
{{dsc end}}

===Example===
{{example
|Implements regular expressions checker:
|code=
#include &lt;cstddef&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

void regular_expression_checker(const std::string&amp; text,
                                const std::string&amp; regex,
                                const std::regex::flag_type flags)
{
    std::cout &lt;&lt; "Text: " &lt;&lt; std::quoted(text) &lt;&lt; '\n'
              &lt;&lt; "Regex: " &lt;&lt; std::quoted(regex) &lt;&lt; '\n';
    
    try
    {
        const std::regex re{regex, flags};
        const bool matched = std::regex_match(text, re);
        
        std::stringstream out;
        out &lt;&lt; (matched ? "MATCH!\n" : "DOES NOT MATCH!\n");
        
        std::smatch m;
        if (std::regex_search(text, m, re); !m.empty())
        {
            out &lt;&lt; "prefix = [" &lt;&lt; m.prefix().str().data() &lt;&lt; "]\n";
            
            for (std::size_t i{}; i != m.size(); ++i)
                out &lt;&lt; "  m[" &lt;&lt; i &lt;&lt; "] = [" &lt;&lt; m[i].str().data() &lt;&lt; "]\n";
            
            out &lt;&lt; "suffix = [" &lt;&lt; m.suffix().str().data() &lt;&lt; "]\n";
        }
        std::cout &lt;&lt; out.str() &lt;&lt; '\n';
    }
    catch (std::regex_error&amp; e)
    {
        std::cout &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; ".\n\n";
    }
}

int main()
{
    constexpr std::regex::flag_type your_flags
        = std::regex::flag_type{0}
    // Choose one of the supported grammars:
        {{!}} std::regex::ECMAScript
    //  {{!}} std::regex::basic
    //  {{!}} std::regex::extended
    //  {{!}} std::regex::awk
    //  {{!}} std::regex::grep
    //  {{!}} std::regex::egrep
    // Choose any of the next options:
    //  {{!}} std::regex::icase
    //  {{!}} std::regex::nosubs
    //  {{!}} std::regex::optimize
    //  {{!}} std::regex::collate
    //  {{!}} std::regex::multiline
        ;
    
    const std::string your_text = "Hello regular expressions.";
    const std::string your_regex = R"(([a-zA-Z]+) ([a-z]+) ([a-z]+)\.)";
    regular_expression_checker(your_text, your_regex, your_flags);
    
    regular_expression_checker("Invalid!", R"(((.)(.))", your_flags);
    regular_expression_checker("Invalid!", R"([.)", your_flags);
    regular_expression_checker("Invalid!", R"([.]{})", your_flags);
    regular_expression_checker("Invalid!", R"([1-0])", your_flags);
}
|p=true
|output=
Text: "Hello regular expressions."
Regex: "([a-zA-Z]+) ([a-z]+) ([a-z]+)\\."
MATCH!
prefix = []
  m[0] = [Hello regular expressions.]
  m[1] = [Hello]
  m[2] = [regular]
  m[3] = [expressions]
suffix = []

Text: "Invalid!"
Regex: "((.)(.)"
Error: Mismatched '(' and ')' in regular expression.

Text: "Invalid!"
Regex: "[."
Error: Unexpected character within '[...]' in regular expression.

Text: "Invalid!"
Regex: "[.]{}"
Error: Invalid range in '{}' in regular expression.

Text: "Invalid!"
Regex: "[1-0]"
Error: Invalid range in bracket expression..
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2053|std=C++11|before=the constants were declared {{c/core|static}}|after=removed the {{c/core|static}} specifier}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/regex/dsc regex_error}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}