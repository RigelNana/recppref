{{title|Modified ECMAScript regular expression grammar}}
{{cpp/regex/navbar}}
This page describes the regular expression grammar that is used when {{lc|std::basic_regex}} is constructed with {{rlpt|syntax_option_type}} set to {{tt|ECMAScript}} (the default). See {{rlpt|syntax_option_type}} for the other supported regular expression grammars.

The {{tt|ECMAScript}} 3 regular expression grammar in C++ is [https://ecma-international.org/ecma-262/5.1/#sec-15.10 ECMA-262 grammar] with modifications marked with {{mark|C++ only}} below.

===Overview===
The [https://eel.is/c++draft/re.grammar modified regular expression grammar] is mostly ECMAScript RegExp grammar with a POSIX-type expansion on locales under ''ClassAtom''. Some clarifications on equality checks and number parsing is made. For many of the examples here, you can try this equivalent in your browser console:

{{source|1=function match(s, re) { return s.match(new RegExp(re)); }|lang=JavaScript}}

The "normative references" in the standard specifies ECMAScript 3. We link to the ECMAScript 5.1 spec here because it is a version with only minor changes from ECMAScript 3, and it also has an HTML version. See the [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions MDN Guide on JavaScript RegExp] for an overview on the dialect features.

===Alternatives===
A regular expression pattern is a sequence of one or more ''Alternative''s, separated by the disjunction operator {{ttb|{{!}}}} (in other words, the disjunction operator has the lowest precedence).

''Pattern'' ::
:''Disjunction''

''Disjunction'' ::
:''Alternative''
:''Alternative'' {{ttb|{{!}}}} ''Disjunction''

The pattern first tries to skip the ''Disjunction'' and match the left ''Alternative'' followed by the rest of the regular expression (after the Disjunction).

If it fails, it tries to skip the left ''Alternative'' and match the right ''Disjunction'' (followed by the rest of the regular expression).

If the left ''Alternative'', the right ''Disjunction'', and the remainder of the regular expression all have choice points, all choices in the remainder of the expression are tried before moving on to the next choice in the left ''Alternative''. If choices in the left ''Alternative'' are exhausted, the right ''Disjunction'' is tried instead of the left ''Alternative''.

Any capturing parentheses inside a skipped ''Alternative'' produce empty submatches.

{{example
|code=
{{cpp/regex/example common}}

int main()
{
    show_matches("abcdef", "abc{{!}}def");
    show_matches("abc", "ab{{!}}abc"); // left Alternative matched first

    // Match of the input against the left Alternative (a) followed
    // by the remained of the regex (c{{!}}bc) succeeds, which results
    // in m[1]="a" and m[4]="bc".
    // The skipped Alternatives (ab) and (c) leave their submatches
    // m[3] and m[5] empty.
    show_matches("abc", "((a){{!}}(ab))((c){{!}}(bc))");
}
|output=
input=[abcdef], regex=[abc{{!}}def]
  prefix=[]
  smatch: m[0]=[abc]
  suffix=[def]
input=[abc], regex=[ab{{!}}abc]
  prefix=[]
  smatch: m[0]=[ab]
  suffix=[c]
input=[abc], regex=[((a){{!}}(ab))((c){{!}}(bc))]
  prefix=[]
  smatch: m[0]=[abc] m[1]=[a] m[2]=[a] m[3]=[] m[4]=[bc] m[5]=[] m[6]=[bc]
  suffix=[]
}}

===Terms===
Each ''Alternative'' is either empty or is a sequence of ''Term''s (with no separators between the ''Term''s)

''Alternative'' ::
: ''[empty]''
: ''Alternative'' ''Term''

Empty ''Alternative'' always matches and does not consume any input.

Consecutive ''Term''s try to simultaneously match consecutive portions of the input.

If the left ''Alternative'', the right ''Term'', and the remainder of the regular expression all have choice points, all choices in the remained of the expression are tried before moving on to the next choice in the right ''Term'', and all choices in the right ''Term'' are tried before moving on to the next choice in the left ''Alternative''.

{{example
|code=
{{cpp/regex/example common}}

int main()
{
    show_matches("abcdef", ""); // empty regex is a single empty Alternative
    show_matches("abc", "abc{{!}}"); // left Alternative matched first
    show_matches("abc", "{{!}}abc"); // left Alternative matched first, leaving abc unmatched
}
|output=
input=[abcdef], regex=[]
  prefix=[]
  smatch: m[0]=[]
  suffix=[abcdef]
input=[abc], regex=[abc{{!}}]
  prefix=[]
  smatch: m[0]=[abc]
  suffix=[]
input=[abc], regex=[{{!}}abc]
  prefix=[]
  smatch: m[0]=[]
  suffix=[abc]
}}

===Quantifiers===
* Each ''Term'' is either an ''Assertion'' (see below), or an ''Atom'' (see below), or an ''Atom'' immediately followed by a ''Quantifier''

''Term'' ::
: ''Assertion''
: ''Atom''
: ''Atom'' ''Quantifier''

Each ''Quantifier'' is either a ''greedy'' quantifier (which consists of just one ''QuantifierPrefix'') or a ''non-greedy'' quantifier (which consists of one ''QuantifierPrefix'' followed by the question mark {{ttb|?}}).

''Quantifier'' ::
: ''QuantifierPrefix''
: ''QuantifierPrefix'' {{ttb|?}}

Each ''QuantifierPrefix'' determines two numbers: the minimum number of repetitions and the maximum number of repetitions, as follows:
{|table class=wikitable
|-
!QuantifierPrefix||Minimum||Maximum
|-
| {{ttb|*}}
| zero
| infinity
|-
| {{ttb|+}}
| one
| infinity
|-
| {{ttb|?}}
| zero
| one
|-
| {{ttb|{ }} ''DecimalDigits'' {{ttb|} }}
| value of DecimalDigits
| value of DecimalDigits
|-
| {{ttb|{}} ''DecimalDigits'' {{ttb|,}} {{ttb|} }}
| value of DecimalDigits
| infinity
|-
| {{ttb|{}} ''DecimalDigits'' {{ttb|,}} ''DecimalDigits'' {{ttb|} }}
| value of DecimalDigits before the comma
| value of DecimalDigits after the comma
|}

The values of the individual ''DecimalDigits'' are obtained by calling {{lc|std::regex_traits::value}}{{mark|C++ only}} on each of the digits.

An ''Atom'' followed by a ''Quantifier'' is repeated the number of times specified by the ''Quantifier''. A ''Quantifier'' can be ''non-greedy'', in which case the ''Atom'' pattern is repeated as few times as possible while still matching the remainder of the regular expression, or it can be ''greedy'', in which case the ''Atom'' pattern is repeated as many times as possible while still matching the remainder of the regular expression.

The ''Atom'' pattern is what is repeated, not the input that it matches, so different repetitions of the ''Atom'' can match different input substrings.

If the ''Atom'' and the remainder of the regular expression all have choice points, the ''Atom'' is first matched as many (or as few, if ''non-greedy'') times as possible. All choices in the remainder of the regular expression are tried before moving on to the next choice in the last repetition of ''Atom''. All choices in the last (nth) repetition of ''Atom'' are tried before moving on to the next choice in the next-to-last (n–1)st repetition of ''Atom''; at which point it may turn out that more or fewer repetitions of ''Atom'' are now possible; these are exhausted (again, starting with either as few or as many as possible) before moving on to the next choice in the (n-1)st repetition of ''Atom'' and so on.

The ''Atom'''s captures are cleared each time it is repeated (see the {{c|"(z)((a+)?(b+)?(c))*"}} example below)

{{example
|code=
{{cpp/regex/example common}}

int main()
{
    // greedy match, repeats [a-z] 4 times
    show_matches("abcdefghi", "a[a-z]{2,4}");
    // non-greedy match, repeats [a-z] 2 times
    show_matches("abcdefghi", "a[a-z]{2,4}?");

    // Choice point ordering for quantifiers results in a match
    // with two repetitions, first matching the substring "aa",
    // second matching the substring "ba", leaving "ac" not matched
    // ("ba" appears in the capture clause m[1])
    show_matches("aabaac", "(aa{{!}}aabaac{{!}}ba{{!}}b{{!}}c)*");

    // Choice point ordering for quantifiers makes this regex 
    // calculate the greatest common divisor between 10 and 15
    // (the answer is 5, and it populates m[1] with "aaaaa")
    show_matches("aaaaaaaaaa,aaaaaaaaaaaaaaa", "^(a+)\\1*,\\1+$");

    // the substring "bbb" does not appear in the capture clause m[4]
    // because it is cleared when the second repetition of the atom
    // (a+)?(b+)?(c) is matching the substring "ac"
    // NOTE: gcc gets this wrong - it does not correctly clear the
    // matches[4] capture group as required by ECMA-262 21.2.2.5.1,
    // and thus incorrectly captures "bbb" for that group.
    show_matches("zaacbbbcac", "(z)((a+)?(b+)?(c))*");
}
|output=
input=[abcdefghi], regex=[a[a-z]{2,4}]
  prefix=[]
  smatch: m[0]=[abcde]
  suffix=[fghi]
input=[abcdefghi], regex=[a[a-z]{2,4}?]
  prefix=[]
  smatch: m[0]=[abc]
  suffix=[defghi]
input=[aabaac], regex=[(aa{{!}}aabaac{{!}}ba{{!}}b{{!}}c)*]
  prefix=[]
  smatch: m[0]=[aaba] m[1]=[ba]
  suffix=[ac]
input=[aaaaaaaaaa,aaaaaaaaaaaaaaa], regex=[^(a+)\1*,\1+$]
  prefix=[]
  smatch: m[0]=[aaaaaaaaaa,aaaaaaaaaaaaaaa] m[1]=[aaaaa]
  suffix=[]
input=[zaacbbbcac], regex=[(z)((a+)?(b+)?(c))*]
  prefix=[]
  smatch: m[0]=[zaacbbbcac] m[1]=[z] m[2]=[ac] m[3]=[a] m[4]=[] m[5]=[c] 
  suffix=[]
}}

===Assertions===
''Assertion''s match conditions, rather than substrings of the input string. They never consume any characters from the input. Each ''Assertion'' is one of the following

''Assertion'' ::
: {{ttb|^}}
: {{ttb|$}}
: {{ttb|\}} {{ttb|b}}
: {{ttb|\}} {{ttb|B}}
: {{ttb|(}} {{ttb|?}} {{ttb|{{=}}}} ''Disjunction'' {{ttb|)}}
: {{ttb|(}} {{ttb|?}} {{ttb|!}} ''Disjunction'' {{ttb|)}}

The assertion {{ttb|^}} (beginning of line) matches 
@1@ The position that immediately follows a ''LineTerminator'' character {{rev inl|until=c++17|(this may not be supported)}}{{rev inl|since=c++17| (this is only guaranteed if {{ltt|cpp/regex/syntax_option_type|std::regex_constants::multiline}}{{mark|C++ only}} is enabled)}}
@2@ The beginning of the input (unless {{lc|std::regex_constants::match_not_bol}}{{mark|C++ only}} is enabled)

The assertion {{ttb|$}} (end of line) matches
@1@ The position of a ''LineTerminator'' character {{rev inl|until=c++17|(this may not be supported)}}{{rev inl|since=c++17|(this is only guaranteed if {{ltt|cpp/regex/syntax_option_type|std::regex_constants::multiline}}{{mark|C++ only}} is enabled)}}
@2@ The end of the input (unless {{lc|std::regex_constants::match_not_eol}}{{mark|C++ only}} is enabled)

In the two assertions above and in the Atom {{ttb|.}} below, ''LineTerminator'' is one of the following four characters: {{tt|U+000A}} ({{tt|\n}} or line feed), {{tt|U+000D}} ({{tt|\r}} or carriage return), {{tt|U+2028}} (line separator), or {{tt|U+2029}} (paragraph separator)

The assertion {{ttb|\b}} (word boundary) matches 
@1@ The beginning of a word (current character is a letter, digit, or underscore, and the previous character is not)
@2@ The end of a word (current character is not a letter, digit, or underscore, and the previous character is one of those)
@3@ The beginning of input if the first character is a letter, digit, or underscore (unless {{lc|std::regex_constants::match_not_bow}}{{mark|C++ only}} is enabled)
@4@ The end of input if the last character is a letter, digit, or underscore (unless {{lc|std::regex_constants::match_not_eow}}{{mark|C++ only}} is enabled)

The assertion {{ttb|\B}} (negative word boundary) matches everything EXCEPT the following
@1@ The beginning of a word (current character is a letter, digit, or underscore, and the previous character is not one of those or does not exist)
@2@ The end of a word (current character is not a letter, digit, or underscore (or the matcher is at the end of input), and the previous character is one of those)

The assertion {{ttb|(}} {{ttb|?}} {{ttb|{{=}}}} ''Disjunction'' {{ttb|)}} (zero-width positive lookahead) matches if ''Disjunction'' would match the input at the current position

The assertion {{ttb|(}} {{ttb|?}} {{ttb|!}} ''Disjunction'' {{ttb|)}} (zero-width negative lookahead) matches if ''Disjunction'' would NOT match the input at the current position.

For both Lookahead assertions, when matching the ''Disjunction'', the position is not advanced before matching the remainder of the regular expression. Also, if ''Disjunction'' can match at the current position in several ways, only the first one is tried.

ECMAScript forbids backtracking into the lookahead Disjunctions, which affects the behavior of backreferences into a positive lookahead from the remainder of the regular expression (see example below). Backreferences into the negative lookahead from the rest of the regular expression are always undefined (since the lookahead Disjunction must fail to proceed).

Note: Lookahead assertions may be used to create logical AND between multiple regular expressions (see example below).

{{example
|code=
{{cpp/regex/example common}}

int main()
{
    // matches the a at the end of input
    show_matches("aaa", "a$");

    // matches the o at the end of the first word
    show_matches("moo goo gai pan", "o\\b");

    // the lookahead matches the empty string immediately after the first b
    // this populates m[1] with "aaa" although m[0] is empty
    show_matches("baaabac", "(?=(a+))");

    // because backtracking into lookaheads is prohibited, 
    // this matches aba rather than aaaba
    show_matches("baaabac", "(?=(a+))a*b\\1");

    // logical AND via lookahead: this password matches IF it contains
    // at least one lowercase letter
    // AND at least one uppercase letter
    // AND at least one punctuation character
    // AND be at least 6 characters long
    show_matches("abcdef", "(?=.*[[:lower:]])(?=.*[[:upper:]])(?=.*[[:punct:]]).{6,}");
    show_matches("aB,def", "(?=.*[[:lower:]])(?=.*[[:upper:]])(?=.*[[:punct:]]).{6,}");
}
|output=
input=[aaa], regex=[a$]
  prefix=[aa]
  smatch: m[0]=[a] 
  suffix=[]
input=[moo goo gai pan], regex=[o\b]
  prefix=[mo]
  smatch: m[0]=[o] 
  suffix=[ goo gai pan]
input=[baaabac], regex=[(?=(a+))]
  prefix=[b]
  smatch: m[0]=[] m[1]=[aaa] 
  suffix=[aaabac]
input=[baaabac], regex=[(?=(a+))a*b\1]
  prefix=[baa]
  smatch: m[0]=[aba] m[1]=[a] 
  suffix=[c]
input=[abcdef], regex=[(?=.*[[:lower:]])(?=.*[[:upper:]])(?=.*[[:punct:]]).{6,}]: NO MATCH
input=[aB,def], regex=[(?=.*[[:lower:]])(?=.*[[:upper:]])(?=.*[[:punct:]]).{6,}]
  prefix=[]
  smatch: m[0]=[aB,def] 
  suffix=[]
}}

===Atoms===
An ''Atom'' can be one of the following:

''Atom'' ::
: ''PatternCharacter''
: {{ttb|.}}
: {{ttb|\}} ''AtomEscape''
: ''CharacterClass''
: {{ttb|(}} ''Disjunction'' {{ttb|)}}
: {{ttb|(}} {{ttb|?}} {{ttb|:}} ''Disjunction'' {{ttb|)}}

where
''AtomEscape'' ::
: ''DecimalEscape''
: ''CharacterEscape''
: ''CharacterClassEscape''

Different kinds of atoms evaluate differently.

===Sub-expressions===
The ''Atom'' {{ttb|(}} ''Disjunction'' {{ttb|)}} is a marked subexpression: it executes the ''Disjunction'' and stores the copy of the input substring that was consumed by ''Disjunction'' in the submatch array at the index that corresponds to the number of times the left open parenthesis {{ttb|(}} of marked subexpressions has been encountered in the entire regular expression at this point.

Besides being returned in the {{lc|std::match_results}}, the captured submatches are accessible as backreferences ({{tt|\1}}, {{tt|\2}}, ...) and can be referenced in regular expressions. Note that  {{lc|std::regex_replace}} uses {{tt|$}} instead of {{tt|\}} for backreferences ({{tt|$1}}, {{tt|$2}}, ...) in the same manner as {{tt|String.prototype.replace}} (ECMA-262, part 15.5.4.11).

The ''Atom'' {{ttb|(}} {{ttb|?}} {{ttb|:}} ''Disjunction'' {{ttb|)}} (non-marking subexpression) simply evaluates the ''Disjunction'' and does not store its results in the submatch. This is a purely lexical grouping.

{{example}}

===Backreferences===
''DecimalEscape'' ::
: ''DecimalIntegerLiteral'' [''lookahead'' ∉ ''DecimalDigit'']

If {{ttb|\}} is followed by a decimal number {{tt|N}} whose first digit is not {{tt|0}}, then the escape sequence is considered to be a ''backreference''. The value {{tt|N}} is obtained by calling {{lc|std::regex_traits::value}}{{mark|C++ only}} on each of the digits and combining their results using base-10 arithmetic. It is an error if {{tt|N}} is greater than the total number of left capturing parentheses in the entire regular expression.

When a backreference {{tt|\N}} appears as an ''Atom'', it matches the same substring as what is currently stored in the N'th element of the submatch array.

The decimal escape {{tt|\0}} is NOT a backreference: it is a character escape that represents the [[cpp/language/ascii | {{c|NUL}}]] character. It cannot be followed by a decimal digit.

As above, note that  {{lc|std::regex_replace}} uses {{tt|$}} instead of {{tt|\}} for backreferences ({{tt|$1}}, {{tt|$2}}, ...).

{{example}}

===Single character matches===
The ''Atom'' {{ttb|.}} matches and consumes any one character from the input string except for ''LineTerminator'' ({{tt|U+000D}}, {{tt|U+000A}}, {{tt|U+2029}}, or {{tt|U+2028}})

The ''Atom'' ''PatternCharacter'', where ''PatternCharacter'' is any ''SourceCharacter'' EXCEPT the characters {{ttb|^ $ \ . * + ? ( ) [ ] { } {{!}}}}, matches and consumes one character from the input if it is equal to this ''PatternCharacter''.

The equality for this and all other single character matches is defined as follows:
@1@ If {{lc|std::regex_constants::icase}} is set, the characters are equal if the return values of {{lc|std::regex_traits::translate_nocase}} are equal {{mark|C++ only}}.
@2@ Otherwise, if {{lc|std::regex_constants::collate}} is set, the characters are equal if the return values of {{lc|std::regex_traits::translate}} are equal {{mark|C++ only}}.
@3@ Otherwise, the characters are equal if {{c|1=operator==}} returns {{c|true}}.

Each ''Atom'' that consists of the escape character {{ttb|\}} followed by ''CharacterEscape'' as well as the special DecimalEscape {{ttb|\0}}, matches and consumes one character from the input if it is equal to the character represented by the ''CharacterEscape''. The following character escape sequences are recognized:

''CharacterEscape'' ::
: ''ControlEscape''
: {{ttb|c}} ''ControlLetter''
: ''HexEscapeSequence''
: ''UnicodeEscapeSequence''
: ''IdentityEscape''

Here, ''ControlEscape'' is one of the following five characters: {{ttb|f n r t v}}

{|table class=wikitable
|-
!ControlEscape||Code Unit||Name
|-
|{{ttb|f}}
|U+000C
|form feed
|-
|{{ttb|n}}
|U+000A
|new line
|-
|{{ttb|r}}
|U+000D
|carriage return
|-
|{{ttb|t}}
|U+0009
|horizontal tab
|-
|{{ttb|v}}
|U+000B
|vertical tab
|}

''ControlLetter'' is any lowercase or uppercase ASCII letters and this character escape matches the character whose code unit equals the remainder of dividing the value of the code unit of ''ControlLetter'' by {{c|32}}. For example, {{ttb|\cD}} and {{ttb|\cd}} both match code unit {{tt|U+0004}} (EOT) because 'D' is {{tt|U+0044}} and {{c|1= 0x44 % 32 == 4}}, and 'd' is {{tt|U+0064}} and {{c|1= 0x64 % 32 == 4}}.

''HexEscapeSequence'' is the letter {{ttb|x}} followed by exactly two ''HexDigit''s (where ''HexDigit'' is one of {{ttb|0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F}}). This character escape matches the character whose code unit equals the numeric value of the two-digit hexadecimal number.

''UnicodeEscapeSequence'' is the letter {{ttb|u}} followed by exactly four ''HexDigit''s. This character escape matches the character whose code unit equals the numeric value of this four-digit hexadecimal number. If the value does not fit in this {{lc|std::basic_regex}}'s {{tt|CharT}}, {{lc|std::regex_error}} is thrown {{mark|C++ only}}.

''IdentityEscape'' can be any non-alphanumeric character: for example, another backslash. It matches the character as-is.

{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

void show_matches(const std::wstring&amp; in, const std::wstring&amp; re)
{
    std::wsmatch m;
    std::regex_search(in, m, std::wregex(re));
    if (!m.empty())
    {
        std::wcout &lt;&lt; L"input=[" &lt;&lt; in &lt;&lt; L"], regex=[" &lt;&lt; re &lt;&lt; L"]\n  "
                      L"prefix=[" &lt;&lt; m.prefix() &lt;&lt; L"]\n  wsmatch: ";
        for (std::size_t n = 0; n &lt; m.size(); ++n)
            std::wcout &lt;&lt; L"m[" &lt;&lt; n &lt;&lt; L"]=[" &lt;&lt; m[n] &lt;&lt; L"] ";
        std::wcout &lt;&lt; L"\n  suffix=[" &lt;&lt; m.suffix() &lt;&lt; L"]\n";
    }
    else
        std::wcout &lt;&lt; L"input=[" &lt;&lt; in &lt;&lt; "], regex=[" &lt;&lt; re &lt;&lt; L"]: NO MATCH\n";
}

int main()
{
    // Most escapes are similar to C++, save for metacharacters. You will have to
    // double-escape or use raw strings on the slashes though.
    show_matches(L"C++\\", LR"(C\+\+\\)");

    // Escape sequences and NUL.
    std::wstring s(L"ab\xff\0cd", 5);
    show_matches(s, L"(\\0{{!}}\\u00ff)");

    // No matching for non-BMP Unicode is defined, because ECMAScript uses UTF-16
    // atoms. Whether this emoji banana matches can be platform dependent:
    // These need to be wide-strings!
    show_matches(L"\U0001f34c", L"[\\u0000-\\ufffe]+");
}
|p=true
|output=&lt;nowiki&gt;
input=[C++\], regex=[C\+\+\\]
  prefix=[]
  wsmatch: m[0]=[C++\]
  suffix=[]
input=[ab?c], regex=[(\0{{!}}\u00ff)]
  prefix=[ab]
  wsmatch: m[0]=[?] m[1]=[?]
  suffix=[c]
input=[?], regex=[[\u0000-\ufffe]+]: NO MATCH
&lt;/nowiki&gt;
}}

===Character classes===
An Atom can represent a character class, that is, it will match and consume one character if it belongs to one of the predefined groups of characters.

A character class can be introduced through a character class escape:

''Atom'' ::
: {{ttb|\}} ''CharacterClassEscape''

or directly

''Atom'' ::
: ''CharacterClass''

The character class escapes are shorthands for some of the common characters classes, as follows:

{|table class=wikitable
|-
!CharacterClassEscape||ClassName expression{{mark|C++ only}}||Meaning
|-
| {{ttb|d}}
| {{ttb|&lt;nowiki&gt;[[&lt;/nowiki&gt;:digit:]]}}
| digits
|-
| {{ttb|D}}
| {{ttb|[^[:digit:]]}}
| non-digits
|-
| {{ttb|s}}
| {{ttb|&lt;nowiki&gt;[[&lt;/nowiki&gt;:space:]]}}
| whitespace characters
|-
| {{ttb|S}}
| {{ttb|[^[:space:]]}}
| non-whitespace characters
|-
| {{ttb|w}}
| {{ttb|[_[:alnum:]]}}
| alphanumeric characters and the character {{ttb|_}}
|-
| {{ttb|W}}
| {{ttb|[^_[:alnum:]]}}
| characters other than alphanumeric or {{ttb|_}}
|}{{small|The exact meaning of each of these character class escapes in C++ is defined in terms of the locale-dependent named character classes, and not by explicitly listing the acceptable characters as in ECMAScript.}}

A ''CharacterClass'' is a bracket-enclosed sequence of ''ClassRanges'', optionally beginning with the negation operator {{ttb|^}}. If it begins with {{ttb|^}}, this ''Atom'' matches any character that is NOT in the set of characters represented by the union of all ''ClassRanges''. Otherwise, this ''Atom'' matches any character that IS in the set of the characters represented by the union of all ''ClassRanges''.

''CharacterClass'' ::
: {{ttb|[}} {{ttb|[}} ''lookahead ∉ {''{{ttb|^}}''}]'' ''ClassRanges'' {{ttb|]}}
: {{ttb|[}} {{ttb|^}} ''ClassRanges'' {{ttb|]}}

ClassRanges ::
: [empty]
: ''NonemptyClassRanges''

''NonemptyClassRanges'' ::
: ''ClassAtom''
: ''ClassAtom'' ''NonemptyClassRangesNoDash''
: ''ClassAtom'' - ''ClassAtom'' ''ClassRanges''

If non-empty class range has the form {{ttb|''ClassAtom'' - ''ClassAtom''}}, it matches any character from a range defined as follows: {{mark|C++ only}}

The first ''ClassAtom'' must match a single collating element {{tt|c1}} and the second ''ClassAtom'' must match a single collating element {{tt|c2}}. To test if the input character {{tt|c}} is matched by this range, the following steps are taken:
@1@ If {{lc|std::regex_constants::collate}} is not on, the character is matched by direct comparison of code points: {{tt|c}} is matched if {{tt|c1 &lt;{{=}} c &amp;&amp; c &lt;{{=}} c2}}
@1@ Otherwise (if {{lc|std::regex_constants::collate}} is enabled):
:@1@ If {{lc|std::regex_constants::icase}} is enabled, all three characters ({{tt|c}}, {{tt|c1}}, and {{tt|c2}}) are passed {{lc|std::regex_traits::translate_nocase}}
:@2@ Otherwise (if {{lc|std::regex_constants::icase}} is not set), all three characters ({{tt|c}}, {{tt|c1}}, and {{tt|c2}}) are passed {{lc|std::regex_traits::translate}}
@2@ The resulting strings are compared using {{lc|std::regex_traits::transform}} and the character {{tt|c}} is matched if {{tt|transformed c1 &lt;{{=}} transformed c &amp;&amp; transformed c &lt;{{=}} transformed c2}}

The character {{ttb|-}} is treated literally if it is
* the first or last character of ''ClassRanges''
* the beginning or end ClassAtom of a dash-separated range specification
* immediately follows a dash-separated range specification.
* escaped with a backslash as a ''CharacterEscape''

NonemptyClassRangesNoDash ::
: ''ClassAtom''
: ''ClassAtomNoDash'' ''NonemptyClassRangesNoDash''
: ''ClassAtomNoDash'' - ''ClassAtom'' ''ClassRanges''

''ClassAtom'' ::
: {{ttb|-}}
: ''ClassAtomNoDash''
: ''ClassAtomExClass''{{mark|C++ only}}
: ''ClassAtomCollatingElement''{{mark|C++ only}}
: ''ClassAtomEquivalence''{{mark|C++ only}}

ClassAtomNoDash ::
: ''SourceCharacter'' but not one of {{ttb|\ or ] or -}}
: {{ttb|\}} ''ClassEscape''

Each ''ClassAtomNoDash'' represents a single character -- either ''SourceCharacter'' as-is or escaped as follows:

ClassEscape ::
: ''DecimalEscape''
: {{ttb|b}}
: ''CharacterEscape''
: ''CharacterClassEscape''

The special ''ClassEscape'' {{ttb|\b}} produces a character set that matches the code unit U+0008 (backspace). Outside of ''CharacterClass'', it is the word-boundary ''Assertion''.

The use of {{ttb|\B}} and the use of any backreference (''DecimalEscape'' other than zero) inside a ''CharacterClass'' is an error.

The characters {{ttb|-}} and {{ttb|]}} may need to be escaped in some situations in order to be treated as atoms. Other characters that have special meaning outside of ''CharacterClass'', such as {{ttb|*}} or {{ttb|?}}, do not need to be escaped.

{{example}}

===POSIX-based character classes===
These character classes are an extension to the ECMAScript grammar, and are equivalent to character classes found in the POSIX regular expressions.

ClassAtomExClass{{mark|C++ only}} ::
: {{ttb|[:}} ''ClassName'' {{ttb|:]}}

Represents all characters that are members of the named character class ''ClassName''. The name is valid only if {{lc|std::regex_traits::lookup_classname}} returns non-zero for this name. As described in {{lc|std::regex_traits::lookup_classname}}, the following names are guaranteed to be recognized: {{ttb|alnum, alpha, blank, cntrl, digit, graph, lower, print, punct, space, upper, xdigit, d, s, w}}. Additional names may be provided by system-supplied locales (such as {{ttb|jdigit}} or {{ttb|jkanji}} in Japanese) or implemented as a user-defined extension.

ClassAtomCollatingElement{{mark|C++ only}} ::
: {{ttb|[.}} ''ClassName'' {{ttb|.]}}

Represents the named collating element, which may represent a single character or a sequence of characters that collates as a single unit under the imbued locale, such as {{tt|[.tilde.]}} or {{tt|[.ch.]}} in Czech. The name is valid only if {{lc|std::regex_traits::lookup_collatename}} is not an empty string.

When using {{lc|std::regex_constants::collate}}, collating elements can always be used as ends points of a range (e.g. {{tt|&lt;nowiki&gt;[[&lt;/nowiki&gt;.dz.]-g]}} in Hungarian).

ClassAtomEquivalence{{mark|C++ only}} ::
: {{ttb|1=[=}} ''ClassName'' {{ttb|1==]}}

Represents all characters that are members of the same equivalence class as the named collating element, that is, all characters whose primary collation key is the same as that for collating element ''ClassName''. The name is valid only if {{lc|std::regex_traits::lookup_collatename}} for that name is not an empty string and if the value returned by {{lc|std::regex_traits::transform_primary}} for the result of the call to {{lc|std::regex_traits::lookup_collatename}} is not an empty string.

A primary sort key is one that ignores case, accentuation, or locale-specific tailorings; so for example {{tt|&lt;nowiki&gt;[[=a=]]&lt;/nowiki&gt;}} matches any of the characters: {{tt|a, À, Á, Â, Ã, Ä, Å, A, à, á, â, ã, ä and å. }}

ClassName{{mark|C++ only}} ::
: ClassNameCharacter
: ClassNameCharacter ClassName

ClassNameCharacter{{mark|C++ only}} ::
: ''SourceCharacter'' but not one of {{ttb|1=. = :}}

{{example}}

{{langlinks|es|ja|zh}}