{{cpp/regex/basic_regex/title|basic_regex}}
{{cpp/regex/basic_regex/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++11|1=
basic_regex();
}}
{{dcl|num=2|since=c++11|1=
explicit basic_regex( const CharT* s,
                      flag_type f = std::regex_constants::ECMAScript );
}}
{{dcl|num=3|since=c++11|1=
basic_regex( const CharT* s, std::size_t count,
             flag_type f = std::regex_constants::ECMAScript );
}}
{{dcl|num=4|since=c++11|1=
basic_regex( const basic_regex&amp; other );
}}
{{dcl|num=5|since=c++11|1=
basic_regex( basic_regex&amp;&amp; other ) noexcept;
}}
{{dcl|num=6|since=c++11|1=
template&lt; class ST, class SA &gt;
explicit basic_regex( const std::basic_string&lt;CharT,ST,SA&gt;&amp; str,
                      flag_type f = std::regex_constants::ECMAScript );
}}
{{dcl|num=7|since=c++11|1=
template&lt; class ForwardIt &gt;
basic_regex( ForwardIt first, ForwardIt last,
             flag_type f = std::regex_constants::ECMAScript );
}}
{{dcl|num=8|since=c++11|1=
basic_regex( std::initializer_list&lt;CharT&gt; init,
             flag_type f = std::regex_constants::ECMAScript );
}}
{{dcl end}}

Constructs a new regular expression from a sequence of characters interpreted according to the flags {{c|f}}.

@1@ Default constructor. Constructs an empty regular expression which will match nothing.

@2@ Constructs a regex from a null-terminated string {{c|s}}.

@3@ Constructs a regex from a sequence of {{c|count}} characters, pointed to by {{c|s}}.

@4@ Copy constructor. Constructs a regex by copying {{c|other}}.

@5@ Move constructor. Constructs a regex with the contents of {{c|other}} using move semantics.

@6@ Constructs a regex from a string {{c|str}}.

@7@ Range constructor. Constructs the string  with the contents of the range {{range|first|last}}.

@8@ Initializer list constructor. Constructs the string with the contents of the initializer list {{c|init}}.

===Parameters===
{{par begin}}
{{par|s|pointer to a null-terminated string}}
{{par|count|length of a character sequence used to initialize the regex}}
{{par|first, last|range of a character sequence used to initialize the regex}}
{{par|str|a basic_string used as a source used to initialize the regex}}
{{par|other|another regex to use as source to initialize the regex}}
{{par|init|initializer list used to initialize the regex}}
{{par|f|flags used to guide the interpretation of the character sequence as a regular expression}}
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par end}}

===Exceptions===
@1@ {{cpp/impldef exception item}}

@2,3@ {{lc|std::regex_error}} if the supplied regular expression is not valid.

@4@ {{cpp/impldef exception item}}

@6-8@ {{lc|std::regex_error}} if the supplied regular expression is not valid.

===Example===
{{example
|code=
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

void match_and_print(const std::string&amp; text, const std::regex&amp; pattern)
{
    std::sregex_iterator it(text.begin(), text.end(), pattern), it_end;
    int count = 0;
    for (; it != it_end; ++it)
    {
        const std::smatch&amp; match = *it;
        std::cout &lt;&lt; ++count &lt;&lt; ". " &lt;&lt; std::quoted(match.str()) &lt;&lt; '\n';
    }
    std::cout &lt;&lt; (count ? "\n" : "no match found\n\n");
}

int main()
{
    const std::string text = "Hello, World! 12345";

    // Matches one or more digits
    std::string pattern_text = "\\d+";
    std::cout &lt;&lt; "digits (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    auto pattern = std::regex(pattern_text);
    match_and_print(text, pattern);

    // Matches one or more characters split by space
    pattern_text = "[^\\s]+";
    std::cout &lt;&lt; "words (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    pattern = std::regex(pattern_text);
    match_and_print(text, pattern);

    // Matches one or more characters split by space
    pattern_text = "[a-zA-Z]+";
    std::cout &lt;&lt; "words without symbols and digits (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    pattern = std::regex(pattern_text);
    match_and_print(text, pattern);

    // Matches one non digits, non alphabet
    pattern_text = "[^0-9A-Za-z]";
    std::cout &lt;&lt; "symbol (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    pattern = std::regex(pattern_text);
    match_and_print(text, pattern);

    // Matches one or more lowercase
    pattern_text = "[a-z]+";
    std::cout &lt;&lt; "lowercase (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    pattern = std::regex(pattern_text);
    match_and_print(text, pattern);

    // Matches one or more lowercase with std::regex::icase flag
    pattern_text = "[a-z]+";
    std::cout &lt;&lt; "lowercase with ignore case flag (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    pattern = std::regex(pattern_text, std::regex::icase);
    match_and_print(text, pattern);

    // Matches basic POSIX regular expression
    pattern_text = "[[:digit:]]+";
    std::cout &lt;&lt; "basic POSIX regex (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    pattern = std::regex(pattern_text, std::regex::basic);
    match_and_print(text, pattern);

    // Matches extended POSIX regular expression
    pattern_text = "[[:digit:]]+";
    std::cout &lt;&lt; "extended POSIX regex (" &lt;&lt; pattern_text &lt;&lt; "):\n";
    pattern = std::regex(pattern_text, std::regex::extended);
    match_and_print(text, pattern);
}
|output=
digits (\d+):
1. "12345"

words ([^\s]+):
1. "Hello,"
2. "World!"
3. "12345"

words without symbols and digits ([a-zA-Z]+):
1. "Hello"
2. "World"

symbol ([^0-9A-Za-z]):
1. ","
2. " "
3. "!"
4. " "

lowercase ([a-z]+):
1. "ello"
2. "orld"

lowercase with ignore case flag ([a-z]+):
1. "Hello"
2. "World"

basic POSIX regex ([[:digit:]]+):
no match found

extended POSIX regex ([[:digit:]]+):
1. "12345"
}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}