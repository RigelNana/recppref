{{cpp/title|regex_match}}
{{cpp/regex/navbar}}
{{dcl begin}}
{{dcl header|regex}}
{{dcl|num=1|since=c++11|1=
template&lt; class BidirIt, class Alloc, class CharT, class Traits &gt;
bool regex_match( BidirIt first, BidirIt last,
                  std::match_results&lt;BidirIt, Alloc&gt;&amp; m,
                  const std::basic_regex&lt;CharT, Traits&gt;&amp; e,
                  std::regex_constants::match_flag_type flags =
                      std::regex_constants::match_default );
}}
{{dcl|num=2|since=c++11|1=
template&lt; class BidirIt, class CharT, class Traits &gt;
bool regex_match( BidirIt first, BidirIt last,
                  const std::basic_regex&lt;CharT, Traits&gt;&amp; e,
                  std::regex_constants::match_flag_type flags =
                      std::regex_constants::match_default );
}}
{{dcl|num=3|since=c++11|1=
template&lt; class CharT, class Alloc, class Traits &gt;
bool regex_match( const CharT* str,
                  std::match_results&lt;const CharT*, Alloc&gt;&amp; m,
                  const std::basic_regex&lt;CharT, Traits&gt;&amp; e,
                  std::regex_constants::match_flag_type flags =
                      std::regex_constants::match_default );
}}
{{dcl|num=4|since=c++11|1=
template&lt; class CharT, class Traits &gt;
bool regex_match( const CharT* str, const std::basic_regex&lt;CharT, Traits&gt;&amp; e,
                  std::regex_constants::match_flag_type flags =
                      std::regex_constants::match_default );
}}
{{dcl|num=5|since=c++11|1=
template&lt; class STraits, class SAlloc, class Alloc,
          class CharT, class Traits &gt;
bool regex_match
    ( const std::basic_string&lt;CharT, STraits, SAlloc&gt;&amp; s,
      std::match_results
          &lt;typename std::basic_string&lt;CharT, STraits, SAlloc&gt;::const_iterator,
           Alloc&gt;&amp; m,
      const std::basic_regex&lt;CharT, Traits&gt;&amp; e,
      std::regex_constants::match_flag_type flags =
          std::regex_constants::match_default );
}}
{{dcl|num=6|since=c++11|1=
template&lt; class STraits, class SAlloc, class CharT, class Traits &gt;
bool regex_match( const std::basic_string&lt;CharT, STraits, SAlloc&gt;&amp; s,
                  const std::basic_regex&lt;CharT, Traits&gt;&amp; e,
                  std::regex_constants::match_flag_type flags =
                      std::regex_constants::match_default );
}}
{{dcl|num=7|since=c++11|1=
template&lt; class STraits, class SAlloc, class Alloc,
          class CharT, class Traits &gt;
bool regex_match
    ( const std::basic_string&lt;CharT, STraits, SAlloc&gt;&amp;&amp;,
      std::match_results
          &lt;typename std::basic_string&lt;CharT, STraits, SAlloc&gt;::const_iterator,
           Alloc&gt;&amp;,
      const std::basic_regex&lt;CharT, Traits&gt;&amp;,
      std::regex_constants::match_flag_type flags =
          std::regex_constants::match_default ) = delete;
}}
{{dcl end}}

Determines if the regular expression {{c|e}} matches the entire target character sequence. The detailed match result is stored in {{c|m}} (if present).

@1,2@ The target character sequence is represented by the range {{range|first|last}}.
{{rev begin}}
{{rev|until=c++23|
If {{tt|BidirIt}} does not satisfy the requirements of {{named req|BidirectionalIterator}}, the behavior is undefined.
}}
{{rev|since=c++23|
If {{tt|BidirIt}} does not model {{lconcept|bidirectional_iterator}}, the behavior is undefined.
}}
{{rev end}}

@3,4@ The target character sequence is represented by the range {{range|str|str + std::char_traits&lt;CharT&gt;::length(str)}}.

@5,6@ The target character sequence is represented by the string {{c|s}}.

@7@ The target character sequence cannot be represented by a {{lc|std::string}} rvalue.

If the match does not exist, the following expressions involving {{c|m}} (if exists) should yield the specified values:
{|class="wikitable" style="text-align: center;"
!{{nbsp}}Expression{{nbsp}}
!{{nbsp}}Value{{nbsp}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/ready}}{{c/core|()}}}}
|{{c|true}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/size}}{{c/core|()}}}}
|{{c|0}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/empty}}{{c/core|()}}}}
|{{c|true}}
|}

If the match exists, given any integer in {{open range|â€‹0|m.size()}} as {{c|n}}, the following expressions involving {{c|m}} should yield the specified values for each overload listed below:
{|class="wikitable" style="text-align: center;"
!rowspan=2|{{nbsp|6}}Expression{{nbsp|6}}
!colspan=3|Value
|-
!{{nbsp|11}}Overload {{v|1}}{{nbsp|11}}
!{{nbsp|11}}Overload {{v|3}}{{nbsp|11}}
!{{nbsp|11}}Overload {{v|5}}{{nbsp|11}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/ready}}{{c/core|()}}}}
|colspan=3|{{c|true}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/size}}{{c/core|()}}}}
|colspan=3|{{box|{{c/core|1 + e.}}{{ltt|cpp/regex/basic_regex/mark_count}}{{c/core|()}}}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/empty}}{{c/core|()}}}}
|colspan=3|{{c|false}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/prefix}}{{c/core|().first}}}}
|rowspan=2|{{c|first}}
|rowspan=2|{{c|str}}
|rowspan=2|{{c|s.begin()}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/prefix}}{{c/core|().second}}}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/prefix}}{{c/core|().matched}}}}
|colspan=3|{{nbsp|4}}{{c|false}}&lt;ref&gt;The match prefix is empty.&lt;/ref&gt;
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/suffix}}{{c/core|().first}}}}
|rowspan=2|{{c|last}}
|rowspan=2|&lt;span style="text-align: start;"&gt;{{c multi|std::char_traits&lt;CharT&gt;::|    length(str) + str}}&lt;/span&gt;
|rowspan=2|{{c|s.end()}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/suffix}}{{c/core|().second}}}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/suffix}}{{c/core|().matched}}}}
|colspan=3|{{nbsp|4}}{{c|false}}&lt;ref&gt;The match suffix is empty.&lt;/ref&gt;
|-
|{{box|{{c/core|m}}{{ltt|cpp/regex/match_results/operator at|[0]}}{{c/core|.first}}}}
|{{c|first}}
|{{c|str}}
|{{c|s.begin()}}
|-
|{{box|{{c/core|m}}{{ltt|cpp/regex/match_results/operator at|[0]}}{{c/core|.second}}}}
|{{c|last}}
|&lt;span style="text-align: start;"&gt;{{c multi|std::char_traits&lt;CharT&gt;::|    length(str) + str}}&lt;/span&gt;
|{{c|s.end()}}
|-
|{{box|{{c/core|m}}{{ltt|cpp/regex/match_results/operator at|[0]}}{{c/core|.matched}}}}
|colspan=3|{{nbsp|4}}{{c|true}}&lt;ref&gt;The entire sequence is matched.&lt;/ref&gt;
|-
|{{box|{{c/core|m}}{{ltt|cpp/regex/match_results/operator at|[n]}}{{c/core|.first}}}}
|colspan=3|
* {{c|last}} if [[cpp/regex/ecmascript#Sub-expressions|marked sub-expression]] {{c|n}} did not participate in the match
* the start of the sequence otherwise matching sub-expression {{c|n}} otherwise
|-
|{{box|{{c/core|m}}{{ltt|cpp/regex/match_results/operator at|[n]}}{{c/core|.second}}}}
|colspan=3|
* {{c|last}} if [[cpp/regex/ecmascript#Sub-expressions|marked sub-expression]] {{c|n}} did not participate in the match
* the end of the sequence otherwise matching sub-expression {{c|n}} otherwise
|-
|{{box|{{c/core|m}}{{ltt|cpp/regex/match_results/operator at|[n]}}{{c/core|.matched}}}}
|colspan=3|
* {{c|false}} if [[cpp/regex/ecmascript#Sub-expressions|marked sub-expression]] {{c|n}} did not participate in the match
* {{c|true}} otherwise
|}
&lt;references/&gt;

===Parameters===
{{par begin}}
{{par|first, last|the target character range}}
{{par|str|the target null-terminated C-style string}}
{{par|s|the target {{lc|std::basic_string}}}}
{{par|m|the match results}}
{{par|e|the regular expression}}
{{par|flags|flags used to determine how the match will be performed}}
{{par end}}

===Return value===
Returns {{c|true}} if the entire target sequence matches {{c|e}}, {{c|false}} otherwise.

===Notes===
Because {{tt|regex_match}} only considers full matches, the same regex may give different matches between {{tt|regex_match}} and {{lc|std::regex_search}}:
{{source|1=
std::regex re("Get{{!}}GetValue");
std::cmatch m;
std::regex_search("GetValue", m, re);  // returns true, and m[0] contains "Get"
std::regex_match ("GetValue", m, re);  // returns true, and m[0] contains "GetValue"
std::regex_search("GetValues", m, re); // returns true, and m[0] contains "Get"
std::regex_match ("GetValues", m, re); // returns false
}}

===Example===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

int main()
{
    // Simple regular expression matching
    const std::string fnames[] = {"foo.txt", "bar.txt", "baz.dat", "zoidberg"};
    const std::regex txt_regex("[a-z]+\\.txt");
    
    for (const auto&amp; fname : fnames)
        std::cout &lt;&lt; fname &lt;&lt; ": " &lt;&lt; std::regex_match(fname, txt_regex) &lt;&lt; '\n';
    
    // Extraction of a sub-match
    const std::regex base_regex("([a-z]+)\\.txt");
    std::smatch base_match;
    
    for (const auto&amp; fname : fnames)
        if (std::regex_match(fname, base_match, base_regex))
            // The first sub_match is the whole string; the next
            // sub_match is the first parenthesized expression.
            if (base_match.size() == 2)
            {
                std::ssub_match base_sub_match = base_match[1];
                std::string base = base_sub_match.str();
                std::cout &lt;&lt; fname &lt;&lt; " has a base of " &lt;&lt; base &lt;&lt; '\n';
            }
    
    // Extraction of several sub-matches
    const std::regex pieces_regex("([a-z]+)\\.([a-z]+)");
    std::smatch pieces_match;
    
    for (const auto&amp; fname : fnames)
        if (std::regex_match(fname, pieces_match, pieces_regex))
        {
            std::cout &lt;&lt; fname &lt;&lt; '\n';
            for (std::size_t i = 0; i &lt; pieces_match.size(); ++i)
            {
                std::ssub_match sub_match = pieces_match[i];
                std::string piece = sub_match.str();
                std::cout &lt;&lt; "  submatch " &lt;&lt; i &lt;&lt; ": " &lt;&lt; piece &lt;&lt; '\n';
            }
        }
}
|output=
foo.txt: 1
bar.txt: 1
baz.dat: 0
zoidberg: 0
foo.txt has a base of foo
bar.txt has a base of bar
foo.txt
  submatch 0: foo.txt
  submatch 1: foo
  submatch 2: txt
bar.txt
  submatch 0: bar.txt
  submatch 1: bar
  submatch 2: txt
baz.dat
  submatch 0: baz.dat
  submatch 1: baz
  submatch 2: dat
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2205|std=C++11|before={{c|n}} could be zero in the postcondition|after=can only be positive}}
{{dr list item|wg=lwg|dr=2273|std=C++11|before=it was unclear whether partial matches are considered|after=only considers full matches}}
{{dr list item|wg=lwg|dr=2329|std=C++11|before=overload {{v|5}} accepted {{tt|basic_string}} rvalues,&lt;br&gt;which could result in dangling iterators|after=rejected via deleted overload {{v|7}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/regex/dsc basic_regex}}
{{dsc inc|cpp/regex/dsc match_results}}
{{dsc inc|cpp/regex/dsc regex_search}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}