{{cpp/title|match_results}}
{{cpp/regex/match_results/navbar}}
{{dcl begin}}
{{dcl header|regex}}
{{dcl|num=1|since=c++11|1=
template&lt;
    class BidirIt,
    class Alloc = std::allocator&lt;std::sub_match&lt;BidirIt&gt;&gt;
&gt; class match_results;
}}
{{dcl|num=2|since=c++17|1=
namespace pmr {
    template &lt;class BidirIt&gt;
    using match_results = std::match_results&lt;BidirIt,
                              std::pmr::polymorphic_allocator&lt;
                                  std::sub_match&lt;BidirIt&gt;&gt;&gt;;
}
}}
{{dcl end}}

The class template {{tt|std::match_results}} holds a collection of character sequences that represent the result of a regular expression match.

This is a specialized allocator-aware container. It can only be default created, obtained from {{lc|std::regex_iterator}}, or modified by {{lc|std::regex_search}} or {{lc|std::regex_match}}. Because {{tt|std::match_results}} holds {{lc|std::sub_match}}es, each of which is a pair of iterators into the original character sequence that was matched, it's undefined behavior to examine {{tt|std::match_results}} if the original character sequence was destroyed or iterators to it were invalidated for other reasons.

The first {{lc|std::sub_match}} (index 0) contained in a {{tt|std::match_result}} always represents the full match within a target sequence made by a regex, and subsequent {{lc|std::sub_match}}es represent sub-expression matches corresponding in sequence to the left parenthesis delimiting the sub-expression in the regex.

{{tt|std::match_results}} meets the requirements of a {{named req|AllocatorAwareContainer}} and of a {{named req|SequenceContainer}}, except that only copy assignment, move assignment, and operations defined for a constant containers are supported, and that the semantics of comparison functions are different from those required for a container.

===Type requirements===
{{par begin}}
{{par req named|BidirIt|BidirectionalIterator}}
{{par req named|Alloc|Allocator}}
{{par end}}

===Specializations===
Several specializations for common character sequence types are provided: 

{{dsc begin}}
{{dsc header|regex}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|std::cmatch}}|{{c/core|std::match_results&lt;const char*&gt;}}}}
{{dsc|{{tt|std::wcmatch}}|{{c/core|std::match_results&lt;const wchar_t*&gt;}}}}
{{dsc|{{tt|std::smatch}}|{{c/core|std::match_results&lt;std::string::const_iterator&gt;}}}}
{{dsc|{{tt|std::wsmatch}}|{{c/core|std::match_results&lt;std::wstring::const_iterator&gt;}}}}
{{dsc|{{tt|std::pmr::cmatch}} {{mark c++17}}|{{c/core|std::pmr::match_results&lt;const char*&gt;}}}}
{{dsc|{{tt|std::pmr::wcmatch}} {{mark c++17}}|{{c/core|std::pmr::match_results&lt;const wchar_t*&gt;}}}}
{{dsc|{{tt|std::pmr::smatch}} {{mark c++17}}|{{c/core|std::pmr::match_results&lt;std::string::const_iterator&gt;}}}}
{{dsc|{{tt|std::pmr::wsmatch}} {{mark c++17}}|{{c/core|std::pmr::match_results&lt;std::wstring::const_iterator&gt;}}}}
{{dsc end}}

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc|{{tt|allocator_type}}|{{tt|Allocator}}}}
{{dsc|{{tt|value_type}}|{{c/core|std::sub_match&lt;BidirIt&gt;}}}}
{{dsc|{{tt|const_reference}}|{{c/core|const value_type&amp;}}}}
{{dsc|{{tt|reference}}|{{tt|value_type&amp;}}}}
{{dsc|{{tt|const_iterator}}|''implementation-defined'' (depends on the underlying container)}}
{{dsc|{{tt|iterator}}|{{tt|const_iterator}}}}
{{dsc|{{tt|difference_type}}|{{c/core|std::iterator_traits&lt;BidirIt&gt;::difference_type}}}}
{{dsc|{{tt|size_type}}|{{c/core|std::allocator_traits&lt;Alloc&gt;::size_type}}}}
{{dsc|{{tt|char_type}}|{{c/core|std::iterator_traits&lt;BidirIt&gt;::value_type}}}}
{{dsc|{{tt|string_type}}|{{c/core|std::basic_string&lt;char_type&gt;}}}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/regex/match_results/dsc constructor}}
{{dsc inc|cpp/regex/match_results/dsc destructor}}
{{dsc inc|cpp/regex/match_results/dsc operator{{=}}}}
{{dsc inc|cpp/regex/match_results/dsc get_allocator}}

{{dsc h2|State}}
{{dsc mem fun|cpp/regex/match_results/ready|checks if the results are available}}

{{dsc h2|Size}}
{{dsc inc|cpp/regex/match_results/dsc empty}}
{{dsc inc|cpp/regex/match_results/dsc size}}
{{dsc inc|cpp/regex/match_results/dsc max_size}}

{{dsc h2|Element access}}
{{dsc inc|cpp/regex/match_results/dsc length}}
{{dsc inc|cpp/regex/match_results/dsc position}}
{{dsc inc|cpp/regex/match_results/dsc str}}
{{dsc inc|cpp/regex/match_results/dsc operator_at}}
{{dsc inc|cpp/regex/match_results/dsc prefix}}
{{dsc inc|cpp/regex/match_results/dsc suffix}}

{{dsc h2|Iterators}}
{{dsc inc|cpp/regex/match_results/dsc begin}}
{{dsc inc|cpp/regex/match_results/dsc end}}

{{dsc h2|Format}}
{{dsc inc|cpp/regex/match_results/dsc format}}

{{dsc h2|Modifiers}}
{{dsc inc|cpp/regex/match_results/dsc swap}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/regex/match_results/dsc operator_cmp}}
{{dsc inc|cpp/regex/match_results/dsc swap2}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|ko|pt|ru|zh}}