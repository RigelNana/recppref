{{cpp/title|regex_search}}
{{cpp/regex/navbar}}
{{dcl begin}}
{{dcl header|regex}}
{{dcl|num=1|since=c++11|1=
template&lt; class BidirIt, class Alloc, class CharT, class Traits &gt;
bool regex_search( BidirIt first, BidirIt last,
                   std::match_results&lt;BidirIt, Alloc&gt;&amp; m,
                   const std::basic_regex&lt;CharT, Traits&gt;&amp; e,
                   std::regex_constants::match_flag_type flags =
                       std::regex_constants::match_default );
}}
{{dcl|num=2|since=c++11|1=
template&lt; class BidirIt, class CharT, class Traits &gt;
bool regex_search( BidirIt first, BidirIt last,
                   const std::basic_regex&lt;CharT, Traits&gt;&amp; e,
                   std::regex_constants::match_flag_type flags =
                       std::regex_constants::match_default );
}}
{{dcl|num=3|since=c++11|1=
template&lt; class CharT, class Alloc, class Traits &gt;
bool regex_search( const CharT* str,
                   std::match_results&lt;const CharT*, Alloc&gt;&amp; m,
                   const std::basic_regex&lt;CharT, Traits&gt;&amp; e,
                   std::regex_constants::match_flag_type flags =
                       std::regex_constants::match_default );
}}
{{dcl|num=4|since=c++11|1=
template&lt; class CharT, class Traits &gt;
bool regex_search( const CharT* str, const std::basic_regex&lt;CharT, Traits&gt;&amp; e,
                   std::regex_constants::match_flag_type flags =
                       std::regex_constants::match_default );
}}
{{dcl|num=5|since=c++11|1=
template&lt; class STraits, class SAlloc, class Alloc,
          class CharT, class Traits &gt;
bool regex_search
    ( const std::basic_string&lt;CharT, STraits, SAlloc&gt;&amp; s,
      std::match_results
          &lt;typename std::basic_string&lt;CharT, STraits, SAlloc&gt;::const_iterator,
           Alloc&gt;&amp; m,
      const std::basic_regex&lt;CharT, Traits&gt;&amp; e,
      std::regex_constants::match_flag_type flags =
          std::regex_constants::match_default );
}}
{{dcl|num=6|since=c++11|1=
template&lt; class STraits, class SAlloc, class CharT, class Traits &gt;
bool regex_search( const std::basic_string&lt;CharT, STraits, SAlloc&gt;&amp; s,
                   const std::basic_regex&lt;CharT, Traits&gt;&amp; e,
                   std::regex_constants::match_flag_type flags =
                       std::regex_constants::match_default );
}}
{{dcl|num=7|since=c++11|1=
template&lt; class STraits, class SAlloc, class Alloc,
          class CharT, class Traits &gt;
bool regex_search
    ( const std::basic_string&lt;CharT, STraits, SAlloc&gt;&amp;&amp;,
      std::match_results
          &lt;typename std::basic_string&lt;CharT, STraits, SAlloc&gt;::const_iterator,
           Alloc&gt;&amp;,
      const std::basic_regex&lt;CharT, Traits&gt;&amp;,
      std::regex_constants::match_flag_type flags =
          std::regex_constants::match_default ) = delete;
}}
{{dcl end}}

Determines if there is a match between the regular expression {{c|e}} and some subsequence in the target character sequence. The detailed match result is stored in {{c|m}} (if present).

@1,2@ The target character sequence is represented by the range {{range|first|last}}.
{{rev begin}}
{{rev|until=c++23|
If {{tt|BidirIt}} does not satisfy the requirements of {{named req|BidirectionalIterator}}, the behavior is undefined.
}}
{{rev|since=c++23|
If {{tt|BidirIt}} does not model {{lconcept|bidirectional_iterator}}, the behavior is undefined.
}}
{{rev end}}

@3,4@ The target character sequence is represented by the range {{range|str|str + std::char_traits&lt;CharT&gt;::length(str)}}.

@5,6@ The target character sequence is represented by the string {{c|s}}.

@7@ The target character sequence cannot be represented by a {{lc|std::string}} rvalue.

If a match does not exist, the following expressions involving {{c|m}} (if exists) should yield the specified values:
{|class="wikitable" style="text-align: center;"
!{{nbsp}}Expression{{nbsp}}
!{{nbsp}}Value{{nbsp}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/ready}}{{c/core|()}}}}
|{{c|true}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/size}}{{c/core|()}}}}
|{{c|0}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/empty}}{{c/core|()}}}}
|{{c|true}}
|}

If a match exists, given any integer in {{open range|â€‹0|m.size()}} as {{c|n}}, the following expressions involving {{c|m}} should yield the specified values for each overload listed below:
{|class="wikitable" style="text-align: center;"
!rowspan=2|{{nbsp|6}}Expression{{nbsp|6}}
!colspan=3|Value
|-
!{{nbsp|11}}Overload {{v|1}}{{nbsp|11}}
!{{nbsp|11}}Overload {{v|3}}{{nbsp|11}}
!{{nbsp|11}}Overload {{v|5}}{{nbsp|11}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/ready}}{{c/core|()}}}}
|colspan=3|{{c|true}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/size}}{{c/core|()}}}}
|colspan=3|{{box|{{c/core|1 + e.}}{{ltt|cpp/regex/basic_regex/mark_count}}{{c/core|()}}}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/empty}}{{c/core|()}}}}
|colspan=3|{{c|false}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/prefix}}{{c/core|().first}}}}
|{{c|first}}
|{{c|str}}
|{{c|s.begin()}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/prefix}}{{c/core|().second}}}}
|colspan=3|{{c|m[0].first}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/prefix}}{{c/core|().matched}}}}
|colspan=3|{{c|1=m.prefix().first != m.prefix().second}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/suffix}}{{c/core|().first}}}}
|colspan=3|{{c|m[0].second}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/suffix}}{{c/core|().second}}}}
|{{c|last}}
|&lt;span style="text-align: start;"&gt;{{c multi|std::char_traits&lt;CharT&gt;::|    length(str) + str}}&lt;/span&gt;
|{{c|s.end()}}
|-
|{{box|{{c/core|m.}}{{ltt|cpp/regex/match_results/suffix}}{{c/core|().matched}}}}
|colspan=3|{{c|1=m.suffix().first != m.suffix().second}}
|-
|{{box|{{c/core|m}}{{ltt|cpp/regex/match_results/operator at|[0]}}{{c/core|.first}}}}
|colspan=3|the start of the sequence that matched {{c|e}}
|-
|{{box|{{c/core|m}}{{ltt|cpp/regex/match_results/operator at|[0]}}{{c/core|.second}}}}
|colspan=3|the end of the sequence that matched {{c|e}}
|-
|{{box|{{c/core|m}}{{ltt|cpp/regex/match_results/operator at|[0]}}{{c/core|.matched}}}}
|colspan=3|{{c|true}}
|-
|{{box|{{c/core|m}}{{ltt|cpp/regex/match_results/operator at|[n]}}{{c/core|.first}}}}
|colspan=3|
* {{c|last}} if [[cpp/regex/ecmascript#Sub-expressions|marked sub-expression]] {{c|n}} did not participate in the match
* the start of the sequence otherwise matching sub-expression {{c|n}} otherwise
|-
|{{box|{{c/core|m}}{{ltt|cpp/regex/match_results/operator at|[n]}}{{c/core|.second}}}}
|colspan=3|
* {{c|last}} if [[cpp/regex/ecmascript#Sub-expressions|marked sub-expression]] {{c|n}} did not participate in the match
* the end of the sequence otherwise matching sub-expression {{c|n}} otherwise
|-
|{{box|{{c/core|m}}{{ltt|cpp/regex/match_results/operator at|[n]}}{{c/core|.matched}}}}
|colspan=3|
* {{c|false}} if [[cpp/regex/ecmascript#Sub-expressions|marked sub-expression]] {{c|n}} did not participate in the match
* {{c|true}} otherwise
|}

===Parameters===
{{par begin}}
{{par|first, last|the target character range}}
{{par|str|the target null-terminated C-style string}}
{{par|s|the target {{lc|std::basic_string}}}}
{{par|m|the match results}}
{{par|e|the regular expression}}
{{par|flags|flags used to determine how the match will be performed}}
{{par end}}

===Return value===
Returns {{c|true}} if a match exists, {{c|false}} otherwise.

===Notes===
In order to examine all matches within the target sequence, {{tt|std::regex_search}} may be called in a loop, restarting each time from {{c|m[0].second}} of the previous call. {{lc|std::regex_iterator}} offers an easy interface to this iteration.

===Example===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

int main()
{
    std::string lines[] = {"Roses are #ff0000",
                           "violets are #0000ff",
                           "all of my base are belong to you"};
    
    std::regex color_regex("#([a-f0-9]{2})"
                            "([a-f0-9]{2})"
                            "([a-f0-9]{2})");
    
    // simple match
    for (const auto&amp; line : lines)
        std::cout &lt;&lt; line &lt;&lt; ": " &lt;&lt; std::boolalpha
                  &lt;&lt; std::regex_search(line, color_regex) &lt;&lt; '\n';
    std::cout &lt;&lt; '\n';
    
    // show contents of marked subexpressions within each match
    std::smatch color_match;
    for (const auto&amp; line : lines)
        if (std::regex_search(line, color_match, color_regex))
        {
            std::cout &lt;&lt; "matches for '" &lt;&lt; line &lt;&lt; "'\n";
            std::cout &lt;&lt; "Prefix: '" &lt;&lt; color_match.prefix() &lt;&lt; "'\n";
            for (std::size_t i = 0; i &lt; color_match.size(); ++i) 
                std::cout &lt;&lt; i &lt;&lt; ": " &lt;&lt; color_match[i] &lt;&lt; '\n';
            std::cout &lt;&lt; "Suffix: '" &lt;&lt; color_match.suffix() &lt;&lt; "\'\n\n";
        }
    
    // repeated search (see also std::regex_iterator)
    std::string log(R"(
        Speed:	366
        Mass:	35
        Speed:	378
        Mass:	32
        Speed:	400
	Mass:	30)");
    std::regex r(R"(Speed:\t\d*)");
    for (std::smatch sm; regex_search(log, sm, r);)
    {
        std::cout &lt;&lt; sm.str() &lt;&lt; '\n';
        log = sm.suffix();
    }
    
    // C-style string demo
    std::cmatch cm;
    if (std::regex_search("this is a test", cm, std::regex("test"))) 
        std::cout &lt;&lt; "\nFound " &lt;&lt; cm[0] &lt;&lt; " at position "
                  &lt;&lt; cm.prefix().length() &lt;&lt; '\n';
}
|output=
Roses are #ff0000: true
violets are #0000ff: true
all of my base are belong to you: false

matches for 'Roses are #ff0000'
Prefix: 'Roses are '
0: #ff0000
1: ff
2: 00
3: 00
Suffix: ''

matches for 'violets are #0000ff'
Prefix: 'violets are '
0: #0000ff
1: 00
2: 00
3: ff
Suffix: ''

Speed:	366
Speed:	378
Speed:	400

Found test at position 10
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2205|std=C++11|before={{c|n}} could be zero in the postcondition|after=can only be positive}}
{{dr list item|wg=lwg|dr=2329|std=C++11|before=overload {{v|5}} accepted {{tt|basic_string}} rvalues,&lt;br&gt;which could result in dangling iterators|after=rejected via deleted overload {{v|7}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/regex/dsc basic_regex}}
{{dsc inc|cpp/regex/dsc match_results}}
{{dsc inc|cpp/regex/dsc regex_match}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}