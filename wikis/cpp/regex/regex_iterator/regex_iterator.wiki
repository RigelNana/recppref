{{cpp/regex/regex_iterator/title|regex_iterator}}
{{cpp/regex/regex_iterator/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++11|1= 
regex_iterator();
}}
{{dcl|num=2|since=c++11|1= 
regex_iterator( BidirIt a, BidirIt b,
                const regex_type&amp; re,
                std::regex_constants::match_flag_type m =
                    std::regex_constants::match_default );
}}
{{dcl|num=3|since=c++11|1= 
regex_iterator( const regex_iterator&amp; );
}}
{{dcl|num=4|since=c++11|1= 
regex_iterator( BidirIt, BidirIt,
                const regex_type&amp;&amp;,
                std::regex_constants::match_flag_type =
                    std::regex_constants::match_default ) = delete;
}}
{{dcl end}}

Constructs a new {{tt|regex_iterator}}:

@1@ Default constructor. Constructs an end-of-sequence iterator.

@2@ Constructs a {{tt|regex_iterator}} from the sequence of characters {{range|a|b}}, the regular expression {{c|re}}, and a flag {{c|m}} that governs matching behavior. This constructor performs an initial call to {{lc|std::regex_search}} with this data. If the result of this initial call is {{c|false}}, {{c|*this}} is set to an end-of-sequence iterator.

@3@ Copies a {{tt|regex_iterator}}.

@4@ The overload {{v|2}} is not allowed to be called with a temporary regex, since the returned iterator would be immediately invalidated.

===Parameters===
{{par begin}}
{{par|a|{{named req|BidirectionalIterator}} to the beginning of the target character sequence}}
{{par|b|{{named req|BidirectionalIterator}} to the end of the target character sequence}}
{{par|re|regular expression used to search the target character sequence}}
{{par|m|flags that govern the behavior of {{c|re}}}}
{{par end}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string_view&gt;

int main()
{
    constexpr std::string_view str{R"(
        #ONE: *p = &amp;Mass;
        #Two: MOV %rd, 42
    )"};
    const std::regex re("[a-w]");

    // create regex_iterator, overload (2)
    auto it = std::regex_iterator&lt;std::string_view::iterator&gt;
    {
        str.cbegin(), str.cend(),
        re // re is lvalue; if an immediate expression was used
           // instead, e.g. std::regex{"[a-z]"}, this would
           // produce an error since overload (4) is deleted
    };

    for (decltype(it) last /* overload (1) */; it != last; ++it)
        std::cout &lt;&lt; (*it).str();
    std::cout &lt;&lt; '\n';
}
|output=
password
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2332|std=C++11|before=a {{tt|regex_iterator}} constructed from a temporary&lt;br&gt;{{tt|basic_regex}} became invalid immediately|after=such construction is disallowed via a deleted overload}}
{{dr list end}}

{{langlinks|de|es|ja|ru|zh}}