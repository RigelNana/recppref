{{cpp/title|basic_const_iterator}}
{{cpp/iterator/basic_const_iterator/navbar}}
{{ddcl|header=iterator|since=c++23|1=
template&lt; std::input_iterator Iter &gt;
class basic_const_iterator;
}}

{{tt|std::basic_const_iterator}} is an iterator adaptor which behaves exactly like the underlying iterator (which must be at least an {{named req|InputIterator}} or model {{lconcept|input_iterator}}), except that dereferencing converts the value returned by the underlying iterator as immutable. Specializations of {{tt|std::basic_const_iterator}} are constant iterators, that is, the iterator can never be used as an output iterator because modifying elements is not allowed.

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc|{{tt|iterator_category}}&lt;br&gt;{{mark cond present}}|
If {{tt|Iter}} models {{lconcept|forward_iterator}}:
* member {{tt|iterator_category}} is the same type as {{c|std::iterator_traits&lt;Iter&gt;::iterator_category}}.
Otherwise, there is no member {{tt|iterator_category}}.
}}
{{dsc|{{tt|iterator_concept}}|
* {{lc|std::contiguous_iterator_tag}}, if {{tt|Iter}} models {{lconcept|contiguous_iterator}};&lt;br&gt;
* {{lc|std::random_access_iterator_tag}}, if {{tt|Iter}} models {{lconcept|random_access_iterator}};&lt;br&gt;
* {{lc|std::bidirectional_iterator_tag}}, if {{tt|Iter}} models {{lconcept|bidirectional_iterator}};&lt;br&gt;
* {{lc|std::forward_iterator_tag}}, if {{tt|Iter}} models {{lconcept|forward_iterator}};&lt;br&gt;
* {{lc|std::input_iterator_tag}} otherwise.}}
{{dsc|{{tt|value_type}}|{{c/core|std::iter_value_t&lt;Iter&gt;}}}}
{{dsc|{{tt|difference_type}}|{{c/core|std::iter_difference_t&lt;Iter&gt;}}}}
{{dsc|{{tti|reference}} {{mark|private}}|{{c/core|std::iter_const_reference_t&lt;Iter&gt;}}&lt;br&gt;{{mark expos mem type}}}}
{{dsc end}}

===Member objects===
{{dsc begin}}
{{dsc hitem|Member name|Definition}}
{{dsc|{{tti|current}} {{mark|private}}|the underlying iterator from which {{rlt|base|base()}} copies or moves&lt;br&gt;{{mark expos mem obj}}}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/iterator/adaptor/dsc constructor|basic_const_iterator}}
{{dsc inc|cpp/iterator/adaptor/dsc base|basic_const_iterator}}
{{dsc inc|cpp/iterator/adaptor/dsc operator*|basic_const_iterator}}
{{dsc inc|cpp/iterator/adaptor/dsc operator_at|basic_const_iterator}}
{{dsc inc|cpp/iterator/basic_const_iterator/dsc operator arith}}
{{dsc inc|cpp/iterator/basic_const_iterator/dsc operator constant_iterator}}
{{dsc inc|cpp/iterator/basic_const_iterator/dsc operator cmp}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/iterator/basic_const_iterator/dsc operator cmp2}}
{{dsc inc|cpp/iterator/basic_const_iterator/dsc operator arith2}}
{{dsc inc|cpp/iterator/adaptor/dsc operator-|basic_const_iterator}}
{{dsc inc|cpp/iterator/adaptor/dsc iter_move|basic_const_iterator}}
{{dsc end}}

===Helper classes===
{{dsc begin}}
{{dsc inc|cpp/iterator/basic_const_iterator/dsc common_type}}
{{dsc end}}

===Helper alias templates===
{{dcl begin}}
{{dcl|since=c++23|1=
template&lt; std::input_iterator I &gt;
using const_iterator = /* see description */;
}}
{{dcl end}}
If {{tt|I}} models [[cpp/ranges/constant_range|{{tti|constant-iterator}}]] (an exposition-only concept), then {{c|const_iterator&lt;I&gt;}} denotes a type {{tt|I}}. Otherwise, {{c|basic_const_iterator&lt;I&gt;}}.
{{dcl begin}}
{{dcl|since=c++23|1=
template&lt; std::semiregular S &gt;
using const_sentinel = /* see description */;
}}
{{dcl end}}
If {{tt|S}} models {{lconcept|input_iterator}}, then {{c|const_sentinel&lt;S&gt;}} denotes a type {{c|const_iterator&lt;S&gt;}}. Otherwise, {{tt|S}}.

===Helper function templates===
{{dcl begin}}
{{dcl|since=c++23|1=
template&lt; std::input_iterator T &gt;
constexpr const_iterator&lt;T&gt; make_const_iterator( I it ) { return it; }
}}
{{dcl|since=c++23|1=
template&lt; std::semiregular S &gt;
constexpr const_sentinel&lt;S&gt; make_const_sentinel( S s ) { return s; }
}}
{{dcl end}}

===Notes===
{{ftm begin|sort=1}}
{{ftm|std=C++23|value=202207L|__cpp_lib_ranges_as_const|{{tt|std::basic_const_iterator}}|rowspan="2"}}
{{ftm|std=C++23|dr=yes|value=202311L|-|{{tt|std::basic_const_iterator}} should follow its underlying type's convertibility}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

int main()
{
    std::vector v{1, 2, 3};
    std::vector&lt;int&gt;::iterator i = v.begin();
    *i = 4;   // OK, v[0] == 4 now
    i[1] = 4; // OK, the same as *(i + 1) = 4;

    auto ci = std::make_const_iterator(i);
    assert(*ci == 4);   // OK, can read the underlying object
    assert(ci[0] == 4); // OK, ditto
    // *ci = 13;        // Error: location is read-only
    // ci[0] = 13;      // Error: ditto
    ci.base()[0] = 42;  // OK, underlying iterator is writable
    assert(*ci == 42);  // OK, underlying location v[0] was modified
}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P2836R1|std=C++23|before={{tt|basic_const_iterator}} doesn't follow its underlying type's convertibility|after=conversion operator provided}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}