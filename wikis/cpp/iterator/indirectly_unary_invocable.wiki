{{cpp/title|indirectly_unary_invocable|indirectly_regular_unary_invocable}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl h|{{tt|std::indirectly_unary_invocable}}}}
{{dcl|since=c++20|1=
template&lt; class F, class I &gt;
    concept indirectly_unary_invocable =
        std::indirectly_readable&lt;I&gt; &amp;&amp;
        std::copy_constructible&lt;F&gt; &amp;&amp;
        std::invocable&lt;F&amp;, /*indirect-value-t*/&lt;I&gt;&gt; &amp;&amp;
        std::invocable&lt;F&amp;, std::iter_reference_t&lt;I&gt;&gt; &amp;&amp;
        std::common_reference_with&lt;
            std::invoke_result_t&lt;F&amp;, /*indirect-value-t*/&lt;I&gt;&gt;,
            std::invoke_result_t&lt;F&amp;, std::iter_reference_t&lt;I&gt;&gt;&gt;;
}}
{{dcl h|{{tt|std::indirectly_regular_unary_invocable}}}}
{{dcl|since=c++20|1=
template&lt; class F, class I &gt;
    concept indirectly_regular_unary_invocable =
        std::indirectly_readable&lt;I&gt; &amp;&amp;
        std::copy_constructible&lt;F&gt; &amp;&amp;
        std::regular_invocable&lt;F&amp;, /*indirect-value-t*/&lt;I&gt;&gt; &amp;&amp;
        std::regular_invocable&lt;F&amp;, std::iter_reference_t&lt;I&gt;&gt; &amp;&amp;
        std::common_reference_with&lt;
            std::invoke_result_t&lt;F&amp;, /*indirect-value-t*/&lt;I&gt;&gt;,
            std::invoke_result_t&lt;F&amp;, std::iter_reference_t&lt;I&gt;&gt;&gt;;
}}
{{dcl end}}

The concepts {{tt|indirectly_unary_invocable}} and {{tt|indirectly_regular_unary_invocable}} specify requirements for algorithms that call (regular) unary invocables as their arguments. The key difference between these concepts and {{lc|std::invocable}} is that they are applied to the type the {{tt|I}} references, rather than {{tt|I}} itself.

===Notes===
The distinction between {{tt|indirectly_unary_invocable}} and {{tt|indirectly_regular_unary_invocable}} is purely semantic.

===Example===
{{example|code=
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;print&gt;
#include &lt;ranges&gt;

struct IntWrapper
{
    int i;

    explicit IntWrapper(int i) : i(i) {}
    IntWrapper(IntWrapper&amp;&amp;) = default;
    IntWrapper&amp; operator=(IntWrapper&amp;&amp;) = default;
};

int main()
{
    auto ints  = std::views::iota(1, 10);
    auto print = [] (IntWrapper w) { std::print("{} ", w.i); };
    auto wrap  = [] (int i) { return IntWrapper{i}; };

    using Proj = std::projected&lt;decltype(ints.begin()), decltype(wrap)&gt;;

    // error (evaluated to false) until P2609R3:
    // this was because 'std::iter_value_t&lt;Proj&gt; &amp;' is the same as 'IntWrapper&amp;'
    // which is not convertible to 'IntWrapper' (implicitly deleted copy ctor)
    static_assert(std::indirectly_unary_invocable&lt;decltype(print), Proj&gt;);

    // if the compile-time check above evaluates to true, then this is well-formed:
    std::ranges::for_each(ints, print, wrap);
}

|output=
1 2 3 4 5 6 7 8 9 
}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P2609R3|std=C++20|before=some requirements were defined in terms of {{c|std::iter_value_t&lt;I&gt;&amp;}}&lt;br&gt;which mishandled projections resulting in incompatibility with invocable {{c|F&amp;}}|after=defined in terms of {{c|/*indirect-value-t*/&lt;I&gt;}}&lt;br&gt;to correctly handle such projections}}
{{dr list item|paper=P2997R1|std=C++20|before=corresponding concepts required {{c|F&amp;}} to satisfy {{lconcept|invocable}} and&lt;br&gt;{{lconcept|regular_invocable}}, respectively, with {{c|std::iter_common_reference_t&lt;I&gt;}}|after=does not require}}
{{dr list end}}

{{langlinks|es|ja|zh}}