{{cpp/title|indirect_binary_predicate}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl|since=c++20|1=
template&lt; class F, class I1, class I2 &gt;
concept indirect_binary_predicate =
    std::indirectly_readable&lt;I1&gt; &amp;&amp;
    std::indirectly_readable&lt;I2&gt; &amp;&amp;
    std::copy_constructible&lt;F&gt; &amp;&amp;
    std::predicate&lt;F&amp;, /*indirect-value-t*/&lt;I1&gt;, /*indirect-value-t*/&lt;I2&gt;&gt; &amp;&amp;
    std::predicate&lt;F&amp;, /*indirect-value-t*/&lt;I1&gt;, std::iter_reference_t&lt;I2&gt;&gt; &amp;&amp;
    std::predicate&lt;F&amp;, std::iter_reference_t&lt;I1&gt;, /*indirect-value-t*/&lt;I2&gt;&gt; &amp;&amp;
    std::predicate&lt;F&amp;, std::iter_reference_t&lt;I1&gt;, std::iter_reference_t&lt;I2&gt;&gt;;
}}
{{dcl end}}

The concept {{tt|indirect_binary_predicate}} specifies requirements for algorithms that call binary predicates as their arguments. The key difference between this concept and {{lc|std::predicate}} is that it is applied to the types that {{tt|I1}} and {{tt|I2}} references, rather than {{tt|I1}} and {{tt|I2}} themselves.

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P2609R3|std=C++20|before=some requirements were defined in terms of {{c|std::iter_value_t&lt;I&gt;&amp;}}&lt;br&gt;which mishandled projections resulting in incompatibility with predicate {{c|F&amp;}}|after=defined in terms of {{c|/*indirect-value-t*/&lt;I&gt;}}&lt;br&gt;to correctly handle such projections}}
{{dr list item|paper=P2997R1|std=C++20|before={{tt|indirect_binary_predicate}} required {{c|F&amp;}} to satisfy {{lconcept|predicate}} with&lt;br&gt;{{c|std::iter_common_reference_t&lt;I&gt;}}|after=does not require}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}