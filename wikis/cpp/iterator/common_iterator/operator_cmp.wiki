{{title|1=operator{{==}}&lt;small&gt;(std::common_iterator)&lt;/small&gt;}}
{{cpp/iterator/common_iterator/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++20|1=
template &lt;class I2, std::sentinel_for&lt;I&gt; S2&gt;
    requires std::sentinel_for&lt;S, I2&gt;
friend constexpr bool operator==( const common_iterator&amp; x, 
                                  const std::common_iterator&lt;I2, S2&gt;&amp; y );
}}
{{dcl|num=2|since=c++20|1=
template &lt;class I2, std::sentinel_for&lt;I&gt; S2&gt;
    requires std::sentinel_for&lt;S, I2&gt; &amp;&amp; std::equality_comparable_with&lt;I, I2&gt;
friend constexpr bool operator==( const common_iterator&amp; x, 
                                  const std::common_iterator&lt;I2, S2&gt;&amp; y );
}}
{{dcl end}}

Compares the iterators and/or sentinels held by underlying {{lc|std::variant}} member objects {{tt|''var''}}. Two incomparable iterators or two sentinels are considered equal.

The behavior is undefined if either {{c|x}} or {{c|y}} is in an invalid state, i.e.
{{c|x.var.valueless_by_exception() {{!!}} y.var.valueless_by_exception()}} is equal to {{c|true}}.

Let {{tt|i}} be {{c|x.var.index()}} and {{tt|j}} be {{c|y.var.index()}}.

@1@ If {{c|1= i == j}} (i.e. both {{c|x}} and {{c|y}} hold iterators or both hold sentinels), returns {{c|true}}, otherwise returns {{c|1= std::get&lt;i&gt;(x.var) == std::get&lt;j&gt;(y.var)}}.

@2@ If {{c|1= i == 1 &amp;&amp; j == 1}} (i.e. both {{c|x}} and {{c|y}} hold sentinels), returns {{c|true}}, otherwise returns {{c|1= std::get&lt;i&gt;(x.var) == std::get&lt;j&gt;(y.var)}}.

{{cpp/note synthesized eq}}

{{cpp/hidden friend|std::common_iterator&amp;lt;I&gt;|plural=yes|tmpl=yes}}

===Parameters===
{{par begin}}
{{par|x, y|iterator adaptors to compare}}
{{par end}}

===Return value===
{{c|true}} if underlying iterators and/or sentinels are equal.

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iterator&gt;

int main()
{
    int a[]{0, 1, 2, 3};

    using CI = std::common_iterator&lt;
                   std::counted_iterator&lt;int*&gt;,
                   std::default_sentinel_t
                   &gt;;

    CI i1{std::counted_iterator{a + 0, 2}&lt;!----&gt;};
    CI i2{std::counted_iterator{a + 1, 2}&lt;!----&gt;};
    CI i3{std::counted_iterator{a + 0, 3}&lt;!----&gt;};
    CI i4{std::counted_iterator{a + 0, 0}&lt;!----&gt;};
    CI s1{std::default_sentinel};
    CI s2{std::default_sentinel};

    assert((i1 == i2) == true);
    assert((i1 == i3) == false);
    assert((i2 == i3) == false);
    assert((s1 == s2) == true);
    assert((i1 == s1) == false);
    assert((i4 == s1) == true);
}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3574|std=C++20|before={{tt|variant}} was fully constexpr (P2231R1) but {{tt|common_iterator}} was not|after=also made constexpr}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/common_iterator/dsc operator-}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}