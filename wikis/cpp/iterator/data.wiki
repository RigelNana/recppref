{{cpp/title|data}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{cpp/iterator/range access headers}}
{{dcla|num=1|since=c++17|
template&lt; class C &gt;
constexpr auto data( C&amp; c ) -&gt; decltype(c.data());
}}
{{dcla|num=2|since=c++17|
template&lt; class C &gt;
constexpr auto data( const C&amp; c ) -&gt; decltype(c.data());
}}
{{dcla|num=3|since=c++17|
template&lt; class T, std::size_t N &gt;
constexpr T* data( T (&amp;array)[N] ) noexcept;
}}
{{dcla|num=4|since=c++17|
template&lt; class E &gt;
constexpr const E* data( std::initializer_list&lt;E&gt; il ) noexcept;
}}
{{dcl end}}

Returns a pointer to the block of memory containing the elements of the range.

@1,2@ Returns {{c|c.data()}}.
@3@ Returns {{c|array}}.
@4@ Returns {{c|il.begin()}}.

===Parameters===
{{par begin}}
{{par|c|a container or view with a {{c|data()}} member function}}
{{par|array|an array of arbitrary type}}
{{par|il|an {{lc|std::initializer_list}}}}
{{par end}}

===Return value===
@1,2@ {{c|c.data()}}
@3@ {{c|array}}
@4@ {{c|il.begin()}}

===Exceptions===
@1@ {{cpp/impldef exception item}}

===Notes===
The overload for {{lc|std::initializer_list}} is necessary because it does not have a member function {{tt|data}}.

{{feature test macro|__cpp_lib_nonmember_container_access|{{lc|std::size()}}, {{tt|std::data()}}, and {{lc|std::empty()}}|value=201411L|std=C++17}}

===Possible implementation===
{{eq impl
|ver1=1|1=
template&lt;class C&gt;
constexpr auto data(C&amp; c) -&gt; decltype(c.data())
{
    return c.data();
}
|ver2=2|2=
template&lt;class C&gt;
constexpr auto data(const C&amp; c) -&gt; decltype(c.data())
{
    return c.data();
}
|ver3=3|3=
template&lt;class T, std::size_t N&gt;
constexpr T* data(T (&amp;array)[N]) noexcept
{
    return array;
}
|ver4=4|4=
template&lt;class E&gt;
constexpr const E* data(std::initializer_list&lt;E&gt; il) noexcept
{
    return il.begin();
}
}}

===Example===
{{example
|code=
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::string s{"Hello world!\n"};

    char a[20]; // storage for a C-style string
    std::strcpy(a, std::data(s));
//  [s.data(), s.data() + s.size()] is guaranteed to be an NTBS since C++11

    std::cout &lt;&lt; a;
}
|output=
Hello world!
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc data}}
{{dsc inc|cpp/ranges/dsc cdata}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}