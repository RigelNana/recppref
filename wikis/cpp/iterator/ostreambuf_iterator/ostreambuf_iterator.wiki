{{cpp/iterator/ostreambuf_iterator/title|ostreambuf_iterator}}
{{cpp/iterator/ostreambuf_iterator/navbar}}
{{dcl begin}}
{{dcl rev multi|num=1|until1=c++11|dcl1=
ostreambuf_iterator( streambuf_type* buffer ) throw();
|dcl2=
ostreambuf_iterator( streambuf_type* buffer ) noexcept;
}}
{{dcl rev multi|num=2|until1=c++11|dcl1=
ostreambuf_iterator( ostream_type&amp; stream ) throw();
|dcl2=
ostreambuf_iterator( ostream_type&amp; stream ) noexcept;
}}
{{dcl end}}

@1@ Constructs the iterator with the private {{tt|streambuf_type*}} member set to {{c|buffer}} and the {{ltf|cpp/iterator/ostreambuf_iterator/failed}} flag set to {{c|false}}. The behavior is undefined if {{c|buffer}} is a null pointer.

@2@ Same as {{c|ostreambuf_iterator(stream.rdbuf())}}.

===Parameters===
{{par begin}}
{{par|stream|the output stream whose {{tt|rdbuf()}} will be accessed by this iterator}}
{{par|buffer|the output stream buffer to be accessed by this iterator}}
{{par end}}

===Example===
{{example
| 
|code=
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

int main()
{
    const char* file = "test.txt";
    {
        std::basic_filebuf&lt;char&gt; f;
        f.open(file, std::ios::out);
        std::ostreambuf_iterator&lt;char&gt; out1(&amp;f);
        *out1 = 'a'; // writes to file via iterator
    }

    // read back from the file
    char a;
    std::cout &lt;&lt; ((std::ifstream{file} &gt;&gt; a), a) &lt;&lt; std::endl;

    std::ostreambuf_iterator&lt;wchar_t&gt; out2{std::wcout};
    *out2 = L'b';
}
|output=
a
b
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=112|std=C++98|before=the requirement "the argument cannot&lt;br&gt;be null" was applied to overload (2)|after=applies to overload&lt;br&gt;(1) instead}}
{{dr list item|paper=P2325R3|std=C++20|before=default constructor was provided as C++20&lt;br&gt;iterators must be {{lconcept|default_initializable}}|after=removed along with&lt;br&gt;the requirement}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}