{{cpp/title|indirectly_readable}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl|notes={{mark expos}}|1=
template&lt; class In &gt;
    concept __IndirectlyReadableImpl =
        requires(const In in) {
            typename std::iter_value_t&lt;In&gt;;
            typename std::iter_reference_t&lt;In&gt;;
            typename std::iter_rvalue_reference_t&lt;In&gt;;
            { *in } -&gt; std::same_as&lt;std::iter_reference_t&lt;In&gt;&gt;;
            { ranges::iter_move(in) } -&gt; std::same_as&lt;std::iter_rvalue_reference_t&lt;In&gt;&gt;;
        } &amp;&amp;
        std::common_reference_with&lt;
            std::iter_reference_t&lt;In&gt;&amp;&amp;, std::iter_value_t&lt;In&gt;&amp;
        &gt; &amp;&amp;
        std::common_reference_with&lt;
            std::iter_reference_t&lt;In&gt;&amp;&amp;, std::iter_rvalue_reference_t&lt;In&gt;&amp;&amp;
        &gt; &amp;&amp;
        std::common_reference_with&lt;
            std::iter_rvalue_reference_t&lt;In&gt;&amp;&amp;, const std::iter_value_t&lt;In&gt;&amp;
        &gt;;
}}
{{dcl|since=c++20|1=
template&lt; class In &gt;
    concept indirectly_readable =
        __IndirectlyReadableImpl&lt;std::remove_cvref_t&lt;In&gt;&gt;;
}}
{{dcl end}}

The concept {{tt|indirectly_readable}} is modeled by types that are readable by applying {{c|operator*}}, such as pointers, smart pointers, and input iterators.

===Semantic requirements===
Given a value {{tt|i}} of type {{tt|I}}, {{tt|I}} models {{tt|indirectly_readable}} only if all concepts it subsumes are modeled and the expression {{c|*i}} is [[cpp/concepts#Equality preservation|equality-preserving]].

{{cpp/concepts/equality preservation}}

{{langlinks|cs|de|es|fr|it|ja|ko|pl|pt|ru|zh}}