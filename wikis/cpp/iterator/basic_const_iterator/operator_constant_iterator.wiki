{{cpp/iterator/basic_const_iterator/title|operator ''constant-iterator''}}
{{cpp/iterator/basic_const_iterator/navbar}}
{{dcl begin}}
{{dcl|since=c++23|num=1|
template&lt; /*not-a-const-iterator*/ CI &gt;
  requires /*constant-iterator*/&lt;CI&gt; &amp;&amp; 
      std::convertible_to&lt;Iter const&amp;, CI&gt;
constexpr operator CI() const &amp;;
}}
{{dcl|since=c++23|num=2|
template&lt; /*not-a-const-iterator*/ CI &gt;
  requires /*constant-iterator*/&lt;CI&gt; &amp;&amp; 
      std::convertible_to&lt;Iter, CI&gt;
constexpr operator CI() &amp;&amp;;
}}
{{dcl end}}

Returns the converted constant iterator to which an underlying iterator {{lti|cpp/iterator/basic_const_iterator#Member objects|current}} can be explicitly or implicitly convertible.

{{c|CI}} satisfies the exposition-only concept {{c|/*not-a-const-iterator*/}} if and only if it's not a specialization of {{tt|basic_const_iterator}}.

===Return value===
@1@ {{box|{{tti|current}}}}
@2@ {{box|{{c/core|std::move(}}{{tti|current}}{{c/core|)}}}}

===Example===
{{example
|code=
#include &lt;iterator&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

void foo(std::vector&lt;int&gt;::const_iterator) {}

int main()
{
    auto v = std::vector&lt;int&gt;();
    {
        // ranges::cbegin below returns vector&lt;int&gt;::const_iterator
        auto i1 = std::ranges::cbegin(v);
        foo(i1); // okay
    }

    auto t = v {{!}} std::views::take_while([](int const x) { return x &lt; 100; });
    {
        // ranges::cbegin below returns basic_const_iterator&lt;vector&lt;int&gt;::iterator&gt;
        auto i2 = std::ranges::cbegin(t);
        foo(i2); // error until P2836R1
    }
}
|output=
}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P2836R1|std=C++23|before={{tt|basic_const_iterator}} doesn't follow its underlying type's convertibility|after=conversion operator provided}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}