{{cpp/title|weakly_incrementable}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator|since=c++20}}
{{dcl|since=c++20|1=
template&lt; class I &gt;
    concept weakly_incrementable =
        std::movable&lt;I&gt; &amp;&amp;
        requires(I i) {
            typename std::iter_difference_t&lt;I&gt;;
            requires /*is-signed-integer-like*/&lt;std::iter_difference_t&lt;I&gt;&gt;;
            { ++i } -&gt; std::same_as&lt;I&amp;&gt;; // not required to be equality-preserving
            i++;                         // not required to be equality-preserving
        };
}}
{{dcl end}}

For the definition of {{c/core|/*is-signed-integer-like*/}}, see {{rlpi|is-integer-like}}{{sep}}.

This concept specifies requirements on types that can be incremented with the pre- and post-increment operators, but those increment operations are not necessarily [[cpp/concepts#Equality preservation|equality-preserving]], and the type itself is not required to be {{lc|std::equality_comparable}}.

For {{tt|std::weakly_incrementable}} types, {{c|1=a == b}} does not imply that {{c|1=++a == ++b}}.  Algorithms on weakly incrementable types must be single-pass algorithms. These algorithms can be used with istreams as the source of the input data through {{lc|std::istream_iterator}}.

===Semantic requirements===
For an object {{c|i}} of type {{tt|I}}, {{tt|I}} models {{tt|std::weakly_incrementable}} only if all following conditions are satisfied:
* The expressions {{c|++i}} and {{c|i++}} have the same domain.
* If {{c|i}} is incrementable, then both {{c|++i}} and {{c|i++}} advance {{c|i}}.
* If {{c|i}} is incrementable, then {{c|1=std::addressof(++i) == std::addressof(i)}}.

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P2325R3|std=C++20|before={{lconcept|default_initializable}} was required|after=not required}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc incrementable}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}