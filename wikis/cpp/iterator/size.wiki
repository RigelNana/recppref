{{cpp/title|size|ssize}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{cpp/iterator/range access headers}}
{{dcla|num=1|since=c++17|
template&lt; class C &gt;
constexpr auto size( const C&amp; c ) -&gt; decltype(c.size());
}}
{{dcla|num=2|since=c++20|
template&lt; class C &gt;
constexpr auto ssize( const C&amp; c )
    -&gt; std::common_type_t&lt;std::ptrdiff_t,
                          std::make_signed_t&lt;decltype(c.size())&gt;&gt;;
}}
{{dcla|num=3|since=c++17|
template&lt; class T, std::size_t N &gt;
constexpr std::size_t size( const T (&amp;array)[N] ) noexcept;
}}
{{dcla|num=4|since=c++20|
template&lt; class T, std::ptrdiff_t N &gt;
constexpr std::ptrdiff_t ssize( const T (&amp;array)[N] ) noexcept;
}}
{{dcl end}}

Returns the size of the given range.

@1,2@ Returns {{c|c.size()}}, converted to the return type if necessary.
@3,4@ Returns {{c|N}}.

===Parameters===
{{par begin}}
{{par|c|a container or view with a {{tt|size}} member function}}
{{par|array|an array of arbitrary type}}
{{par end}}

===Return value===
@1@ {{c|c.size()}}
@2@ {{c multi|static_cast&lt;std::common_type_t&lt;std::ptrdiff_t,|                               std::make_signed_t&lt;decltype(c.size())&gt;&gt;&gt;(c.size())}}
@3,4@ {{c|N}}

===Exceptions===
@1,2@ {{cpp/impldef exception item}}

===Overloads===
Custom overloads of {{tt|size}} may be provided for classes and enumerations that do not expose a suitable {{tt|size()}} member function, yet can be detected.

{{rrev|since=c++20|
Overloads of {{tt|size}} found by [[cpp/language/adl|argument-dependent lookup]] can be used to customize the behavior of {{c/core|std::ranges::size}}, {{c/core|std::ranges::ssize}}, and {{c/core|std::ranges::empty}}.
}}

===Possible implementation===
{{eq impl
|title1=size (1)|ver1=1|1=
template&lt;class C&gt;
constexpr auto size(const C&amp; c) -&gt; decltype(c.size())
{
    return c.size();
}
|title2=ssize (2)|ver2=2|2=
template&lt;class C&gt;
constexpr auto ssize(const C&amp; c)
    -&gt; std::common_type_t&lt;std::ptrdiff_t,
                          std::make_signed_t&lt;decltype(c.size())&gt;&gt;
{
    using R = std::common_type_t&lt;std::ptrdiff_t,
                                 std::make_signed_t&lt;decltype(c.size())&gt;&gt;;
    return static_cast&lt;R&gt;(c.size());
}
|title3=size (3)|ver3=3|3=
template&lt;class T, std::size_t N&gt;
constexpr std::size_t size(const T (&amp;array)[N]) noexcept
{
    return N;
}
|title4=ssize (4)|ver4=4|4=
template&lt;class T, std::ptrdiff_t N&gt;
constexpr std::ptrdiff_t ssize(const T (&amp;array)[N]) noexcept
{
    return N;
}
}}

===Notes===
{{ftm begin|std=1|comment=1}}
{{ftm|std=C++17|value=201411L|__cpp_lib_nonmember_container_access|{{tt|std::size()}}, {{lc|std::data}} and {{lc|std::empty}}}}
{{ftm|std=C++20|value=201902L|__cpp_lib_ssize|{{tt|std::ssize()}} {{vl|2,4}} and unsigned {{ltf|cpp/container/span/size|std::span::size}}}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    // Works with containers
    std::vector&lt;int&gt; v{3, 1, 4};
    assert(std::size(v) == 3);
    
    // And works with built-in arrays too
    int a[]{-5, 10, 15};
    // Returns the number of elements (not bytes) as opposed to sizeof
    assert(std::size(a) == 3);
    std::cout &lt;&lt; "size of a[]: " &lt;&lt; sizeof a &lt;&lt; '\n'; // 12, if sizeof(int) == 4
    
    // Provides a safe way (compared to sizeof) of getting string buffer size
    const char str[] = "12345";
    // These are fine and give the correct result
    assert(std::size(str) == 6);
    assert(sizeof(str) == 6);
    
    // But use of sizeof here is a common source of bugs
    const char* str_decayed = "12345";
    // std::cout &lt;&lt; std::size(str_decayed) &lt;&lt; '\n'; // Usefully fails to compile
    std::cout &lt;&lt; sizeof(str_decayed) &lt;&lt; '\n'; // Prints the size of the pointer!
    
    // Since C++20 the signed size (std::ssize) is available
    auto i = std::ssize(v);
    for (--i; i != -1; --i)
        std::cout &lt;&lt; v[i] &lt;&lt; (i ? ' ' : '\n');
    assert(i == -1);

    // Note that the string literal includes the ending null character, which
    // will be part of the constructed characters array. This makes std::size
    // behave differently from std::strlen and std::string::size:
    constexpr char symbols[] = "0123456789";

    static_assert(std::size(symbols) == 11);
    static_assert(std::string(symbols).size() == 10);
    assert(std::strlen(symbols) == 10);
}
|p=true&lt;!--sizeof pointer and int--&gt;
|output=
size of a[]: 12
8
4 1 3
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc ptrdiff_t}}
{{dsc inc|cpp/types/dsc size_t}}
{{dsc inc|cpp/ranges/dsc size}}
{{dsc inc|cpp/ranges/dsc ssize}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}