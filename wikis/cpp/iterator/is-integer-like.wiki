{{title|''is-integer-like''{{sep}}, ''is-signed-integer-like''}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcla|num=1|since=c++20|expos=yes|1=
template&lt; class T &gt;
constexpr bool /*is-integer-like*/ = /* see description */;
}}
{{dcla|num=2|since=c++20|expos=yes|1=
template&lt; class T &gt;
constexpr bool /*is-signed-integer-like*/ = /* see description */;
}}
{{dcl end}}

@1@ {{c|/*is-integer-like*/&lt;T&gt;}} is {{c|true}} if and only if {{tt|T}} is an integer-like type.

@2@ {{c|/*is-signed-integer-like*/&lt;T&gt;}} is {{c|true}} if and only if {{tt|T}} is a signed-integer-like type.

===Integer-class type===
A type {{tt|T}} is an ''integer-class type'' if it is in a set of implementation-defined types that behave as [[cpp/language/types#Integral types|integer types]] do, as defined [[#Required behaviors|below]]. An integer-class type is not necessarily a [[cpp/language/classes|class type]].

An integer-class type can represent {{mathjax-or|\(\scriptsize 2^N \)|2{{su|p=N}}}} consecutive integers, where {{c|N}}, a positive integer, is called the ''width'' of the integer-class type.

An integer-class type is either signed or unsigned:
* A ''signed integer class type'' can represent all integers in {{closed range/core|{{mathjax-or|\(\scriptsize -2^{N-1} \)|-2{{su|p=N-1}}}}|{{mathjax-or|\(\scriptsize 2^{N-1}-1 \)|2{{su|p=N-1}}-1}}}}, where {{c|N}} is greater than the width of every signed integral type. 
* An ''unsigned integer class type'' can represent all integers in {{closed range/core|{{mathjax-or|\(\scriptsize 0 \)|0}}|{{mathjax-or|\(\scriptsize 2^N-1 \)|2{{su|p=N}}-1}}}}, where {{c|N}} is greater than the width of every unsigned integral type.

All integer-class types model {{lconcept|regular}} and {{lconcept|three_way_comparable}}{{c/core|&lt;std::strong_ordering&gt;}}.

A [[cpp/language/value initialization|value-initialized]] object of integer-class type has value {{c|0}}.

An expression {{c|E}} of integer-class type {{tt|T}} is [[cpp/language/implicit conversion#Contextual conversions|contextually convertible]] to {{c/core|bool}} as if by {{c|1=bool(E != T(0))}}.

===Integer-like type===
A type other than (possibly cv-qualified) {{c/core|bool}} is ''integer-like'' if it models {{lconcept|integral}} or if it is an integer-class type.
* An integer-like type is ''signed-integer-like'' if it models {{lconcept|signed_integral}} or if it is a signed-integer-class type.
* An integer-like type is ''unsigned-integer-like'' if it models {{lconcept|unsigned_integral}} or if it is an unsigned-integer-class type.

===Required behaviors===
Expressions of integer-class type are explicitly convertible to any integer-like type, and implicitly convertible to any integer-class type of equal or greater width and the same signedness. Expressions of integral type are both implicitly and explicitly convertible to any integer-class type. Conversions between integral and integer-class types and between two integer-class types do not exit via an exception. The result of such a conversion is the unique value of the destination type that is congruent to the source modulo {{mathjax-or|\(\scriptsize 2^N \)|2{{su|p=N}}}}, where {{c|N}} is the width of the destination type.

Let {{tt|Int&lt;T&gt;}} denote the following type:
* If {{tt|T}} is an integer-class type, {{tt|Int&lt;T&gt;}} is a unique hypothetical [[cpp/language/types#Extended integer types|extended integer type]] of the same signedness with the same width as {{tt|T}}.
* If {{tt|T}} is an integral type, let {{tt|Int&lt;T&gt;}} is the same type as {{tt|T}}.

Given the following types, values and operators:
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|IC}}|an integer-class type}}
{{dsc|{{tt|IL}}|an integer-like type}}
{{dsc hitem|Value|Definition}}
{{dsc|{{c|a}}|an object of type {{tt|IC}}}}
{{dsc|{{c|b}}|an object of type {{tt|IL}}}}
{{dsc|{{c|c}}|an lvalue of an integeral type}}
{{dsc|{{c|x}}|an object of type {{tt|Int&lt;IC&gt;}} that represent the same value as {{c|a}}}}
{{dsc|{{c|y}}|an object of type {{tt|Int&lt;IL&gt;}} that represent the same value as {{c|b}}}}
{{dsc hitem|Operator|Definition}}
{{dsc|{{c|1=@=}}|one of {{c|1=+=}}, {{c|1=-=}}, {{c|1=*=}}, {{c|1=/=}}, {{c|1=%=}}, {{c|1=&amp;=}}, {{c|1={{!}}=}}, {{c|1=^=}}, {{c|1=&lt;&lt;=}} and {{c|1=&gt;&gt;=}}}}
{{dsc|{{c|@}}|one of {{c|+}}, {{c|-}}, {{c|*}}, {{c|/}}, {{c|%}}, {{c|&amp;}}, {{c|{{!}}}}, {{c|^}}, {{c|&lt;&lt;}}, {{c|&gt;&gt;}}, {{c|&amp;&amp;}}, {{c|{{!!}}}}, {{c|1===}}, {{c|1=!=}}, {{c|&lt;}}, {{c|&gt;}}, {{c|1=&lt;=}}, {{c|1=&gt;=}}, {{c|1=&lt;=&gt;}} and {{c|,}}}}
{{dsc end}}

The following expressions must be well-formed and have their specified result and effects if the specified conditions are satisfied:
{|class="wikitable"
!{{nbsp}}Expression{{nbsp}}
!{{nbsp|10}}Condition{{nbsp|10}}
!Result
!Effects
|-
|{{c|a++}}
|rowspan=2 {{n/a|No condition}}
|rowspan=2|a prvalue of type {{tt|IC}} whose value is equal to that of {{c|a}} prior to the evaluation
|modifies the value of {{c|a}} by adding {{c|1}} to it
|-
|{{c|a--}}
|modifies the value of {{c|a}} by subtracting {{c|1}} to it
|-
|{{c|++a}}
|colspan=3|[[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to {{c|1=a += 1}}
|-
|{{c|--a}}
|colspan=3|expression-equivalent to {{c|1=a -= 1}}
|-
|{{c|&amp;a}}
|colspan=3|expression-equivalent to {{c|std::addressof(a)}}
|-
|{{c|!a}}
|{{c|!x}} is well-formed
|colspan=2|same as {{c|!x}}
|-
|{{c|+a}}
|{{c|+x}} is well-formed
|same as {{c|+x}}, but has type {{tt|IC}}
|same as {{c|+x}}
|-
|{{c|-a}}
|{{c|-x}} is well-formed
|same as {{c|-x}}, but has type {{tt|IC}}
|same as {{c|-x}}
|-
|{{c|~a}}
|{{c|~x}} is well-formed
|same as {{c|~x}}, but has type {{tt|IC}}
|same as {{c|~x}}
|-
|{{c|1=c @= a}}
|{{c|1=c @= x}} is well-formed
|an lvalue referring to {{c|c}}
|same as {{c|1=c @= x}}
|-
|{{c|1=a @= b}}
|{{c|1=x @= y}} is well-formed
|an lvalue referring to {{c|a}}
|same as {{c|1=x @= y}}, except that the value that would be stored into {{c|x}} is stored into {{c|a}}
|-
|{{c|a @ b}}
|{{c|x @ y}} is well-formed
|same as {{c|x @ y}}, but the result type is different:
* If {{c|x @ y}} is of type {{tt|Int&lt;IC&gt;}}, the result has type {{tt|IC}}.
* If {{c|x @ y}} is of type {{tt|Int&lt;IL&gt;}}, the result has type {{tt|IL}}.
* If {{c|x @ y}} is of any other type {{tt|T}}, the result has type {{tt|T}}.
|same as {{c|x @ y}}
|-
|{{c|b @ a}}
|{{c|y @ x}} is well-formed
|same as {{c|y @ x}}, but the result type is different:
* If {{c|y @ x}} is of type {{tt|Int&lt;IC&gt;}}, the result has type {{tt|IC}}.
* If {{c|y @ x}} is of type {{tt|Int&lt;IL&gt;}}, the result has type {{tt|IL}}.
* If {{c|y @ x}} is of any other type {{tt|T}}, the result has type {{tt|T}}.
|same as {{c|y @ x}}
|}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3366|paper=P2393R1|std=C++20|before=the conversion between an integer-class type and its corresponding&lt;br&gt;integer type was not guaranteed to produce a representable value|after=guaranteed}}
{{dr list item|wg=lwg|dr=3376|paper=P2393R1|std=C++20|before=integer-class types could only be class types|after=also allowed&lt;br&gt;non-class types}}
{{dr list item|wg=lwg|dr=3467|std=C++20|before={{c/core|bool}} was considered as an integer-like type|after=excluded}}
{{dr list item|wg=lwg|dr=3575|paper=P2393R1|std=C++20|before=integer-class types were not guaranteed to be three-way-comparable|after=guaranteed}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc weakly_incrementable}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}