{{cpp/ranges/title| distance}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl h|Call signature}}
{{dcl|num=1|since=c++20|
template&lt; class I, std::sentinel_for&lt;I&gt; S &gt;
    requires (!std::sized_sentinel_for&lt;S, I&gt;)
constexpr std::iter_difference_t&lt;I&gt;
    distance( I first, S last );
}}
{{dcl|num=2|since=c++20|
template&lt; class I, std::sized_sentinel_for&lt;std::decay_t&lt;I&gt;&gt; S &gt;
constexpr std::iter_difference_t&lt;std::decay_t&lt;I&gt;&gt;
    distance( I&amp;&amp; first, S last );
}}
{{dcl|num=3|since=c++20|
template&lt; ranges::range R &gt;
constexpr ranges::range_difference_t&lt;R&gt;
    distance( R&amp;&amp; r );
}}
{{dcl end}}

@1,2@ Returns the number of hops from {{c|first}} to {{c|last}}.
@3@ Returns the size of {{c|r}} as a signed integer.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first|iterator pointing to the first element}}
{{par|last|sentinel denoting the end of the range {{c|first}} is an iterator to}}
{{par|r|range to calculate the distance of}}
{{par end}}

===Return value===
@1@ The number of increments needed to go from {{c|first}} to {{c|last}}.
@2@ {{c|last - static_cast&lt;const std::decay_t&lt;I&gt;&amp;&gt;(first)}}.
@3@ If {{tt|R}} models {{c/core|ranges::sized_range}}, returns {{c|ranges::size(r)}}; otherwise {{c|ranges::distance(ranges::begin(r), ranges::end(r))}}.

===Complexity===
@1@ Linear.
@2@ Constant.
@3@ If {{tt|R}} models {{c/core|ranges::sized_range}} or if {{c|std::sized_sentinel_for&lt;ranges::sentinel_t&lt;R&gt;, ranges::iterator_t&lt;R&gt;&gt;}} is modeled, complexity is constant; otherwise linear.

===Possible implementation===
{{eq fun|1=
struct distance_fn
{
    template&lt;class I, std::sentinel_for&lt;I&gt; S&gt;
        requires (!std::sized_sentinel_for&lt;S, I&gt;)
    constexpr std::iter_difference_t&lt;I&gt; operator()(I first, S last) const
    {
        std::iter_difference_t&lt;I&gt; result = 0;
        while (first != last)
        {
            ++first;
            ++result;
        }
        return result;
    }
    
    template&lt;class I, std::sized_sentinel_for&lt;std::decay&lt;I&gt;&gt; S&gt;
    constexpr std::iter_difference_t&lt;I&gt; operator()(const I&amp; first, S last) const
    {
        return last - first;
    }
    
    template&lt;ranges::range R&gt;
    constexpr ranges::range_difference_t&lt;R&gt; operator()(R&amp;&amp; r) const
    {
        if constexpr (ranges::sized_range&lt;std::remove_cvref_t&lt;R&gt;&gt;)
            return static_cast&lt;ranges::range_difference_t&lt;R&gt;&gt;(ranges::size(r));
        else
            return (*this)(ranges::begin(r), ranges::end(r));
    }
};

inline constexpr auto distance = distance_fn{};
}}

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;forward_list&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

int main() 
{
    std::vector&lt;int&gt; v{3, 1, 4};
    assert(std::ranges::distance(v.begin(), v.end()) == 3);
    assert(std::ranges::distance(v.end(), v.begin()) == -3);
    assert(std::ranges::distance(v) == 3);

    std::forward_list&lt;int&gt; l{2, 7, 1};
    // auto size = std::ranges::size(l); // error: not a sizable range
    auto size = std::ranges::distance(l); // OK, but aware O(N) complexity
    assert(size == 3);
}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3392|std=C++20|before=overload {{v|1}} takes iterator by value, thus move-only&lt;br&gt;iterator lvalue with a sized sentinel was rejected|after=added overload {{v|2}}}}
{{dr list item|wg=lwg|dr=3664|std=C++20|before=the resolution of {{lwg|3392}} made&lt;br&gt;{{tt|ranges::distance}} reject array arguments|after=accepts them}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/ranges/dsc advance}}
{{dsc inc|cpp/algorithm/ranges/dsc count}}
{{dsc inc|cpp/iterator/dsc distance}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}