{{cpp/ranges/title|prev}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl h|Call signature}}
{{dcl|num=1|since=c++20|1=
template&lt; std::bidirectional_iterator I &gt;
constexpr I prev( I i );
}}
{{dcl|num=2|since=c++20|1=
template&lt; std::bidirectional_iterator I &gt;
constexpr I prev( I i, std::iter_difference_t&lt;I&gt; n );
}}
{{dcl|num=3|since=c++20|1=
template&lt; std::bidirectional_iterator I &gt;
constexpr I prev( I i, std::iter_difference_t&lt;I&gt; n, I bound );
}}
{{dcl end}}

Return the {{c|n}}{{sup|th}} predecessor of iterator {{c|i}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|i|an iterator}}
{{par|n|number of elements {{c|i}} should be descended}}
{{par|bound|iterator denoting the beginning of the range {{c|i}} points to}}
{{par end}}

===Return value===
@1@ The predecessor of {{c|i}}.
@2@ The {{c|n}}{{sup|th}} predecessor of iterator {{c|i}}.
@3@ The {{c|n}}{{sup|th}} predecessor of iterator {{c|i}}, or the first iterator that compares equal to {{c|bound}}, whichever is first.

===Complexity===
@1@ Constant.
@2,3@ Constant if {{tt|I}} models {{c|std::random_access_iterator&lt;I&gt;}}; otherwise linear.

===Possible implementation===
{{eq fun|1=
struct prev_fn
{
    template&lt;std::bidirectional_iterator I&gt;
    constexpr I operator()(I i) const
    {
        --i;
        return i;
    }

    template&lt;std::bidirectional_iterator I&gt;
    constexpr I operator()(I i, std::iter_difference_t&lt;I&gt; n) const
    {
        ranges::advance(i, -n);
        return i;
    }

    template&lt;std::bidirectional_iterator I&gt;
    constexpr I operator()(I i, std::iter_difference_t&lt;I&gt; n, I bound) const
    {
        ranges::advance(i, -n, bound);
        return i;
    }
};

inline constexpr auto prev = prev_fn();
}}

===Notes===
Although the expression {{c|--r.end()}} often compiles for containers, it is not guaranteed to do so: {{c|r.end()}} is an rvalue expression, and there is no iterator requirement that specifies that decrement of an rvalue is guaranteed to work. In particular, when iterators are implemented as pointers or its {{tt|operator--}} is lvalue-ref-qualified, {{c|--r.end()}} does not compile, while {{c|ranges::prev(r.end())}} does.

This is further exacerbated by ranges that do not model {{c|ranges::common_range}}. For example, for some underlying ranges, {{c|ranges::transform_view::end}} doesn't have the same return type as {{c|ranges::transform_view::begin}}, and so {{c|--r.end()}} won't compile. This isn't something that {{tt|ranges::prev}} can aid with, but there are workarounds.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

int main() 
{
    std::vector&lt;int&gt; v{3, 1, 4};
    auto pv = std::ranges::prev(v.end(), 2);
    std::cout &lt;&lt; *pv &lt;&lt; '\n';

    pv = std::ranges::prev(pv, 42, v.begin());
    std::cout &lt;&lt; *pv &lt;&lt; '\n';
}
|output=
1
3
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/ranges/dsc next}}
{{dsc inc|cpp/iterator/ranges/dsc advance}}
{{dsc inc|cpp/iterator/dsc prev}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}