{{cpp/ranges/title|iter_move}}
{{cpp/iterator/navbar}}

{{dcl begin}}
{{dcl header|iterator}}
{{dcl|notes={{mark custpt}}|since=c++20|1=
inline namespace /* unspecified */ {
    inline constexpr /* unspecified */ iter_move = /* unspecified */;
}
}}
{{dcl h|Call signature}}
{{dcl|since=c++20|1=
template&lt; class T &gt;
    requires /* see below */
constexpr decltype(auto) iter_move( T&amp;&amp; t ) noexcept(/* see below */);
}}
{{dcl end}}

Obtains an rvalue reference or a prvalue temporary from a given iterator.

A {{c|ranges::iter_move(t)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to:
# {{c|iter_move(t)}}, if {{c|t}} has a class or enumeration type and the expression is well-formed when treated as an [[cpp/language/expressions#Potentially-evaluated expressions|unevaluated operand]], where the [[cpp/language/overload resolution|overload resolution]] of {{tt|iter_move}} is performed only with the candidates found by [[cpp/language/adl|argument-dependent lookup]].
# Otherwise, {{c|std::move(*t)}} if {{c|*t}} is well-formed and is an lvalue.
# Otherwise, {{c|*t}} if {{c|*t}} is well-formed and is an rvalue.

In all other cases, a call to {{tt|ranges::iter_move}} is ill-formed, which can result in [[cpp/language/sfinae|substitution failure]] when {{c|ranges::iter_move(e)}} appears in the immediate context of a template instantiation.

If {{c|ranges::iter_move(e)}} is not equal to {{c|*e}}, the program is ill-formed, no diagnostic required.

{{cpp/ranges/cpo}}

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/adaptor/dsc iter_move|reverse_iterator}}
{{dsc inc|cpp/iterator/adaptor/dsc iter_move|move_iterator}}
{{dsc end}}

{{langlinks|es|ja|zh}}