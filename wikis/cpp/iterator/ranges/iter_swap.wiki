{{cpp/ranges/title|iter_swap}}
{{cpp/iterator/navbar}}

{{dcl begin}}
{{dcl header|iterator}}
{{dcl|notes={{mark custpt}}|since=c++20|1=
namespace ranges {
    inline namespace /* unspecified */ {
        inline constexpr /* unspecified */
            iter_swap = /* unspecified */;
    }
}
}}
{{dcl h|Call signature}}
{{dcl|since=c++20|1=
template&lt; class I1, class I2 &gt;
constexpr void iter_swap( I1&amp;&amp; i1, I2&amp;&amp; i2 ) noexcept(/* see below */);
}}
{{dcl h|Helper function}}
{{dcl|notes={{mark expos}}|1=
template&lt; class X, class Y &gt;
constexpr std::iter_value_t&lt;X&gt;
    iter-exchange-move( X&amp;&amp; x, Y&amp;&amp; y )
    noexcept(noexcept(std::iter_value_t&lt;X&gt;(std::ranges::iter_move(x))) &amp;&amp;
             noexcept(*x = std::ranges::iter_move(y)));
}}
{{dcl end}}

Swaps values denoted by two iterators.

The effect of the exposition-only helper function {{tti|iter-exchange-move}} is equivalent to
{{source|1=
std::iter_value_t&lt;X&gt; old(std::ranges::iter_move(x));
*x = std::ranges::iter_move(y);
return old;
}}

{{c|ranges::iter_swap(i1, i2)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to:
# {{c|(void)iter_swap(i1, i2)}}, if {{c|i1}} or {{c|i2}} has a class or enumeration type and the expression is well-formed, where the [[cpp/language/overload resolution|overload resolution]] of {{tt|iter_swap}} is performed with the additional candidate {{c|1=void iter_swap(auto, auto) = delete;}}&lt;ref&gt;This precludes calling unconstrained {{lc|std::iter_swap}}.&lt;/ref&gt;, excluding {{tt|std::ranges::iter_swap}} itself.
#* If the selected overload does not exchange the value denoted by {{c|i1}} and {{c|i2}}, the program is ill-formed, no diagnostic required.
# Otherwise, {{c|ranges::swap(*i1, *i2)}} if both {{tt|I1}} and {{tt|I2}} model {{lconcept|indirectly_readable}} and if {{c/core|std::iter_reference_t&lt;I1&gt;}} and {{c/core|std::iter_reference_t&lt;I2&gt;}} model {{lconcept|swappable_with}}.
# Otherwise, {{box|{{c/core|1=(void)(*i1 =}}{{nbspt}}{{tti|iter-exchange-move}}{{c/core|(i2, i1))}}}}, if {{c|std::indirectly_movable_storable&lt;I1, I2&gt;}} and {{c|std::indirectly_movable_storable&lt;I2, I1&gt;}} are both modeled, except that {{c|i1}} is only evaluated once.
# Otherwise, {{c|ranges::iter_swap(i1, i2)}} is ill-formed, which can result in [[cpp/language/sfinae|substitution failure]] when {{c|ranges::iter_swap(i1, i2)}} appears in the immediate context of a template instantiation.
&lt;references/&gt;

{{cpp/ranges/cpo}}

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/adaptor/dsc iter_swap|reverse_iterator}}
{{dsc inc|cpp/iterator/adaptor/dsc iter_swap|move_iterator}}
{{dsc inc|cpp/algorithm/dsc iter_swap}}
{{dsc end}}

{{langlinks|es|ja|zh}}