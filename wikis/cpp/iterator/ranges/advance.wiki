{{cpp/ranges/title|advance}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl h|Call signature}}
{{dcl|num=1|since=c++20|1=
template&lt; std::input_or_output_iterator I &gt;
constexpr void advance( I&amp; i, std::iter_difference_t&lt;I&gt; n );
}}
{{dcl|num=2|since=c++20|1=
template&lt; std::input_or_output_iterator I, std::sentinel_for&lt;I&gt; S &gt;
constexpr void advance( I&amp; i, S bound );
}}
{{dcl|num=3|since=c++20|1=
template&lt; std::input_or_output_iterator I, std::sentinel_for&lt;I&gt; S &gt;
constexpr std::iter_difference_t&lt;I&gt; advance( I&amp; i, std::iter_difference_t&lt;I&gt; n, S bound );
}}
{{dcl end}}

@1@ Increments given iterator {{c|i}} for {{c|n}} times.
@2@ Increments given iterator {{c|i}} until {{c|1=i == bound}}.
@3@ Increments given iterator {{c|i}} for {{c|n}} times, or until {{c|1=i == bound}}, whichever comes first.

If {{c|n}} is negative, the iterator is decremented. In this case, {{tt|I}} must model {{lc|std::bidirectional_iterator}}, and {{tt|S}} must be the same type as {{tt|I}} if {{c|bound}} is provided, otherwise the behavior is undefined.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|i|iterator to be advanced}}
{{par|bound|sentinel denoting the end of the range {{c|i}} is an iterator to}}
{{par|n|number of maximal increments of {{c|i}}}}
{{par end}}

===Return value===
@3@ The difference between {{c|n}} and the actual distance {{c|i}} traversed.

===Complexity===
Linear.

However, if {{tt|I}} additionally models {{lc|std::random_access_iterator}}, or {{tt|S}} models {{c|std::sized_sentinel_for&lt;I&gt;}}, or {{tt|I}} and {{tt|S}} model {{c|std::assignable_from&lt;I&amp;, S&gt;}}, complexity is constant.

===Notes===
The behavior is undefined if the specified sequence of increments or decrements would require that a non-incrementable iterator (such as the past-the-end iterator) is incremented, or that a non-decrementable iterator (such as the front iterator or the singular iterator) is decremented.

===Possible implementation===

{{eq fun|1=
struct advance_fn
{
    template&lt;std::input_or_output_iterator I&gt;
    constexpr void operator()(I&amp; i, std::iter_difference_t&lt;I&gt; n) const
    {
        if constexpr (std::random_access_iterator&lt;I&gt;)
            i += n;
        else
        {
            while (n &gt; 0)
            {
                --n;
                ++i;
            }

            if constexpr (std::bidirectional_iterator&lt;I&gt;)
            {
                while (n &lt; 0)
                {
                    ++n;
                    --i;
                }
            }
        }
    }

    template&lt;std::input_or_output_iterator I, std::sentinel_for&lt;I&gt; S&gt;
    constexpr void operator()(I&amp; i, S bound) const
    {
        if constexpr (std::assignable_from&lt;I&amp;, S&gt;)
            i = std::move(bound);
        else if constexpr (std::sized_sentinel_for&lt;S, I&gt;)
            (*this)(i, bound - i);
        else
            while (i != bound)
                ++i;
    }

    template&lt;std::input_or_output_iterator I, std::sentinel_for&lt;I&gt; S&gt;
    constexpr std::iter_difference_t&lt;I&gt;
    operator()(I&amp; i, std::iter_difference_t&lt;I&gt; n, S bound) const
    {
        if constexpr (std::sized_sentinel_for&lt;S, I&gt;)
        {
            // std::abs is not constexpr until C++23
            auto abs = [](const std::iter_difference_t&lt;I&gt; x) { return x &lt; 0 ? -x : x; };

            if (const auto dist = abs(n) - abs(bound - i); dist &lt; 0)
            {
                (*this)(i, bound);
                return -dist;
            }

            (*this)(i, n);
            return 0;
        }
        else
        {
            while (n &gt; 0 &amp;&amp; i != bound)
            {
                --n;
                ++i;
            }

            if constexpr (std::bidirectional_iterator&lt;I&gt;)
            {
                while (n &lt; 0 &amp;&amp; i != bound)
                {
                    ++n;
                    --i;
                }
            }

            return n;
        }
    }
};

inline constexpr auto advance = advance_fn();
}}

===Example===
{{example
|
|code=
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; v {3, 1, 4};

    auto vi = v.begin();

    std::ranges::advance(vi, 2);
    std::cout &lt;&lt; "1) value: " &lt;&lt; *vi &lt;&lt; '\n' &lt;&lt; std::boolalpha;

    std::ranges::advance(vi, v.end());
    std::cout &lt;&lt; "2) vi == v.end(): " &lt;&lt; (vi == v.end()) &lt;&lt; '\n';

    std::ranges::advance(vi, -3);
    std::cout &lt;&lt; "3) value: " &lt;&lt; *vi &lt;&lt; '\n';

    std::cout &lt;&lt; "4) diff: " &lt;&lt; std::ranges::advance(vi, 2, v.end())
              &lt;&lt; ", value: " &lt;&lt; *vi &lt;&lt; '\n';

    std::cout &lt;&lt; "5) diff: " &lt;&lt; std::ranges::advance(vi, 4, v.end())
              &lt;&lt; ", vi == v.end(): " &lt;&lt; (vi == v.end()) &lt;&lt; '\n';
}
|output=
1) value: 4
2) vi == v.end(): true
3) value: 3
4) diff: 0, value: 4
5) diff: 3, vi == v.end(): true
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/ranges/dsc next}}
{{dsc inc|cpp/iterator/ranges/dsc prev}}
{{dsc inc|cpp/iterator/ranges/dsc distance}}
{{dsc inc|cpp/iterator/dsc advance}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}