{{cpp/ranges/title| next}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl h|Call signature}}
{{dcl|num=1|since=c++20|1=
template&lt; std::input_or_output_iterator I &gt;
constexpr I next( I i );
}}
{{dcl|num=2|since=c++20|1=
template&lt; std::input_or_output_iterator I &gt;
constexpr I next( I i, std::iter_difference_t&lt;I&gt; n );
}}
{{dcl|num=3|since=c++20|1=
template&lt; std::input_or_output_iterator I, std::sentinel_for&lt;I&gt; S &gt;
constexpr I next( I i, S bound );
}}
{{dcl|num=4|since=c++20|1=
template&lt; std::input_or_output_iterator I, std::sentinel_for&lt;I&gt; S &gt;
constexpr I next( I i, std::iter_difference_t&lt;I&gt; n, S bound );
}}
{{dcl end}}

Return the {{c|n}}{{sup|th}} successor of iterator {{c|i}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|i|an iterator}}
{{par|n|number of elements to advance}}
{{par|bound|sentinel denoting the end of the range {{c|i}} points to}}
{{par end}}

===Return value===
@1@ The successor of iterator {{c|i}}.
@2@ The {{c|n}}{{sup|th}} successor of iterator {{c|i}}.
@3@ The first iterator equivalent to {{c|bound}}.
@4@ The {{c|n}}{{sup|th}} successor of iterator {{c|i}}, or the first iterator equivalent to {{c|bound}}, whichever is first.

===Complexity===
@1@ Constant.
@2@ Constant if {{tt|I}} models {{lc|std::random_access_iterator}}; otherwise linear.
@3@ Constant if {{tt|I}} and {{tt|S}} models both {{c|std::random_access_iterator&lt;I&gt;}} and {{c|std::sized_sentinel_for&lt;S, I&gt;}}, or if {{tt|I}} and {{tt|S}} models {{c|std::assignable_from&lt;I&amp;, S&gt;}}; otherwise linear.
@4@ Constant if {{tt|I}} and {{tt|S}} models both {{c|std::random_access_iterator&lt;I&gt;}} and {{c|std::sized_sentinel_for&lt;S, I&gt;}}; otherwise linear.

===Possible implementation===
{{eq fun|1=
struct next_fn
{
    template&lt;std::input_or_output_iterator I&gt;
    constexpr I operator()(I i) const
    {
        ++i;
        return i;
    }

    template&lt;std::input_or_output_iterator I&gt;
    constexpr I operator()(I i, std::iter_difference_t&lt;I&gt; n) const
    {
        ranges::advance(i, n);
        return i;
    }

    template&lt;std::input_or_output_iterator I, std::sentinel_for&lt;I&gt; S&gt;
    constexpr I operator()(I i, S bound) const
    {
        ranges::advance(i, bound);
        return i;
    }

    template&lt;std::input_or_output_iterator I, std::sentinel_for&lt;I&gt; S&gt;
    constexpr I operator()(I i, std::iter_difference_t&lt;I&gt; n, S bound) const
    {
        ranges::advance(i, n, bound);
        return i;
    }
};

inline constexpr auto next = next_fn();
}}

===Notes===
Although the expression {{c|++x.begin()}} often compiles, it is not guaranteed to do so: {{c|x.begin()}} is an rvalue expression, and there is no requirement that specifies that increment of an rvalue is guaranteed to work. In particular, when iterators are implemented as pointers or its {{tt|operator++}} is lvalue-ref-qualified, {{c|++x.begin()}} does not compile, while {{c|ranges::next(x.begin())}} does.

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iterator&gt;

int main() 
{
    auto v = {3, 1, 4};
    {
        auto n = std::ranges::next(v.begin());
        assert(*n == 1);
    }
    {
        auto n = std::ranges::next(v.begin(), 2);
        assert(*n == 4);
    }
    {
        auto n = std::ranges::next(v.begin(), v.end());
        assert(n == v.end());
    }
    {
        auto n = std::ranges::next(v.begin(), 42, v.end());
        assert(n == v.end());
    }
}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/ranges/dsc prev}}
{{dsc inc|cpp/iterator/ranges/dsc advance}}
{{dsc inc|cpp/iterator/dsc next}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}