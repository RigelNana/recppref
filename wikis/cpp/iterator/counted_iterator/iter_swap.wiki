{{title|iter_swap&lt;small&gt;(std::counted_iterator)&lt;/small&gt;}}
{{cpp/iterator/counted_iterator/navbar}}
{{ddcl|since=c++20|
template&lt; std::indirectly_swappable&lt;I&gt; I2 &gt;
    friend constexpr void
        iter_swap( const counted_iterator&amp; x, const std::counted_iterator&lt;I2&gt;&amp; y )
            noexcept(noexcept(ranges::iter_swap(x.base(), y.base())));
}}

Swaps the objects pointed to by two underlying iterators. The behavior is undefined if either {{c|x.count()}} or {{c|y.count()}} is equal to {{c|0}}.&lt;!--LWG 3472--&gt;

The function body is equivalent to: {{c|ranges::iter_swap(x.base(), y.base());}}.

{{cpp/hidden friend|{{c|std::counted_iterator&lt;I&gt;}}|tmpl=yes}}

===Parameters===
{{par begin}}
{{par|x, y|iterator adaptors to the elements to swap}}
{{par end}}

===Return value===
(none)

===Complexity===
Constant.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;list&gt;
#include &lt;vector&gt;

int main()
{
    std::vector p{1, 2, 3, 4},
                q{5, 6, 7, 8};

    std::counted_iterator&lt;std::vector&lt;int&gt;::iterator&gt; ip{p.begin(), 2};
    std::counted_iterator&lt;std::vector&lt;int&gt;::iterator&gt; iq{q.begin(), 3};

    std::cout &lt;&lt; *ip &lt;&lt; ' ' &lt;&lt; *iq &lt;&lt; '\n';
    iter_swap(ip, iq); // ADL
    std::cout &lt;&lt; *ip &lt;&lt; ' ' &lt;&lt; *iq &lt;&lt; '\n';

    std::list x{0, 1, 3};
    std::counted_iterator&lt;std::list&lt;int&gt;::iterator&gt; ix{x.begin(), 2};
//  iter_swap(ip, ix); // error: not indirectly swappable
}
|output=
1 5
5 1
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc swap}}
{{dsc inc|cpp/algorithm/dsc swap_ranges}}
{{dsc inc|cpp/algorithm/dsc iter_swap}}
{{dsc inc|cpp/iterator/ranges/dsc iter_swap}}
{{dsc inc|cpp/iterator/adaptor/dsc iter_move|counted_iterator}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}