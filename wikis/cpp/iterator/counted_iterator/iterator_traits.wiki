{{cpp/title|iterator_traits&lt;small&gt;&lt;std::counted_iterator&gt;&lt;/small&gt;}}
{{cpp/iterator/counted_iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl|since=c++20|1=
template&lt; std::input_iterator I &gt;
    requires /* see below */
struct iterator_traits&lt;std::counted_iterator&lt;I&gt;&gt; : std::iterator_traits&lt;I&gt; {
    using pointer = std::conditional_t&lt;std::contiguous_iterator&lt;I&gt;,
                                       std::add_pointer_t&lt;std::iter_reference_t&lt;I&gt;&gt;,
                                       void&gt;;
};
}}
{{dcl end}}

Inherits the properties from customized (generated from either a standard partial specialization or a program-defined specialization) {{c|std::iterator_traits&lt;I&gt;}}, with the member type {{tt|pointer}} adjusted, where {{tt|I}} models {{lconcept|input_iterator}}.

Notably, the {{tt|iterator_concept}} (if present) and {{tt|iterator_category}} are inherited from {{c|std::iterator_traits&lt;I&gt;}}.

The condition in the requires-clause is {{c|true}} if and only if {{c|std::iterator_traits&lt;I&gt;}} is not generated from the primary template.

===Note===
Before {{wg21|P2259R1}}, this specialization is used even if {{c|std::iterator_traits&lt;I&gt;}} is generated from the primary template. As a result, when testing {{c|std::counted_iterator&lt;I&gt;}} against an iterator concept (e.g. {{lconcept|forward_iterator}}), the determination of {{c|/*ITER_CONCEPT*/}} does not take {{tt|I::iterator_concept}} into account, and thus {{c|std::counted_iterator&lt;I&gt;}} sometimes erroneously behaves as if it cannot model that concept. This incorrect behavior is implemented in libstdc++ prior to 10.4, and in MSVC STL prior to VS 2022 17.0 Preview 3.

The standard library provides partial specializations of {{lc|std::iterator_traits}} for pointer types, {{lc|std::counted_iterator}}, and {{lc|std::common_iterator}}.

===Example===
{{example
|code=
#include &lt;iterator&gt;
#include &lt;list&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;

int main()
{
    std::vector v{1, 2, 3, 4};
    std::list l{1, 2, 3, 4};
    std::counted_iterator iv{v.begin(), 3};
    std::counted_iterator il{l.begin(), 3};
    static_assert(std::is_same&lt;int*, std::iterator_traits&lt;decltype(iv)&gt;::pointer&gt;());
    static_assert(std::is_same&lt;void, std::iterator_traits&lt;decltype(il)&gt;::pointer&gt;());
}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P2259R1|std=C++20|before=there's no requires-clause&lt;br&gt;{{tt|pointer}} is unconditionally defined as {{tt|void}}|after=constraint added}}
{{dr list end}}

===See also===
{{dsc begin}}
{{cpp/iterator/dsc iterator_traits}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}