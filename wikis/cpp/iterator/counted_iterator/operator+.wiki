{{title|operator+&lt;small&gt;(std::counted_iterator)&lt;/small&gt;}}
{{cpp/iterator/counted_iterator/navbar}}
{{dcl begin}}
{{dcl|since=c++20|
friend constexpr counted_iterator operator+(
    std::iter_difference_t&lt;I&gt; n, const counted_iterator&amp; x )
        requires std::random_access_iterator&lt;I&gt;;
}}
{{dcl end}}

Returns an iterator adaptor which is advanced by {{c|n}}. The behavior is undefined if {{c|n}} is greater than the length recorded within {{c|x}} (i.e. if {{c|x + n}} result in undefined behavior).

{{cpp/hidden friend|std::counted_iterator&amp;lt;I&gt;}}

===Parameters===
{{par begin}}
{{par|n|the number of positions to increment the iterator}}
{{par|x|the iterator adaptor to increment}}
{{par end}}

===Return value===
An iterator adaptor equal to {{c|x + n}}.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;list&gt;
#include &lt;vector&gt;

int main()
{
    std::vector v{0, 1, 2, 3, 4, 5};
    std::counted_iterator&lt;std::vector&lt;int&gt;::iterator&gt; p{v.begin() + 1, 4};
    std::cout &lt;&lt; "*p:" &lt;&lt; *p &lt;&lt; ", count:" &lt;&lt; p.count() &lt;&lt; '\n';
    std::counted_iterator&lt;std::vector&lt;int&gt;::iterator&gt; q{2 + p};
    std::cout &lt;&lt; "*q:" &lt;&lt; *q &lt;&lt; ", count:" &lt;&lt; q.count() &lt;&lt; '\n';

    std::list l{6, 7, 8, 9};
    std::counted_iterator&lt;std::list&lt;int&gt;::iterator&gt; r{l.begin(), 3};
    std::cout &lt;&lt; "*r:" &lt;&lt; *r &lt;&lt; ", count:" &lt;&lt; r.count() &lt;&lt; '\n';
//  auto s{2 + r}; // error: the underlying iterator does
                   // not model std::random_access_iterator
}
|output=
*p:1, count:4
*q:3, count:2
*r:6, count:3
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/adaptor/dsc operator_arith|counted_iterator}}
{{dsc inc|cpp/iterator/adaptor/dsc operator-|counted_iterator}}
{{dsc inc|cpp/iterator/counted_iterator/dsc operator-2}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}