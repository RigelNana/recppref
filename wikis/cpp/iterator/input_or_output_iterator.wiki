{{cpp/title|input_or_output_iterator}}
{{cpp/iterator/navbar}}
{{ddcl|header=iterator|since=c++20|1=
template&lt; class I &gt;
    concept input_or_output_iterator =
        requires(I i) {
            { *i } -&gt; /*can-reference*/;
        } &amp;&amp;
        std::weakly_incrementable&lt;I&gt;;
}}

The {{tt|input_or_output_iterator}} concept forms the basis of the iterator concept taxonomy; every iterator type satisfies the {{tt|input_or_output_iterator}} requirements.

The exposition-only concept {{c|/*can-reference*/}} is satisfied if and only if the type is [[cpp/meta#Definitions|referenceable]]. &lt;!--{{cpp/concepts/equality preservation}}--&gt;

===Notes===
{{tt|input_or_output_iterator}} itself only specifies operations for dereferencing and incrementing an iterator. Most algorithms will require additional operations, for example:
* comparing iterators with sentinels (see {{lconcept|sentinel_for}});
* reading values from an iterator (see {{lconcept|indirectly_readable}} and {{lconcept|input_iterator}});
* writing values to an iterator (see {{lconcept|indirectly_writable}} and {{lconcept|output_iterator}});
* a richer set of iterator movements (see {{lconcept|forward_iterator}}, {{lconcept|bidirectional_iterator}}, {{lconcept|random_access_iterator}}).

Unlike the {{named req|Iterator}} requirements, the {{tt|input_or_output_iterator}} concept does not require copyability.

{{c/core|*i}} is required to be equality-preserving, although the increment operations required by {{lconcept|weakly_incrementable}} are not.

===Example===
A minimum iterator.
{{source|1=
#include &lt;cstddef&gt;
#include &lt;iterator&gt;

struct SimpleIterator
{
    using difference_type = std::ptrdiff_t;
    
    int operator*();
    
    SimpleIterator&amp; operator++();
    void operator++(int) { ++*this; }
};

static_assert(std::input_or_output_iterator&lt;SimpleIterator&gt;);
}}

{{langlinks|es|ja|zh}}