{{cpp/title|indirectly_movable_storable}}
{{cpp/iterator/navbar}}
{{ddcl|header=iterator|since=c++20|1=
template&lt; class In, class Out &gt;
concept indirectly_movable_storable =
    std::indirectly_movable&lt;In, Out&gt; &amp;&amp;
    std::indirectly_writable&lt;Out, std::iter_value_t&lt;In&gt;&gt; &amp;&amp;
    std::movable&lt;std::iter_value_t&lt;In&gt;&gt; &amp;&amp;
    std::constructible_from&lt;std::iter_value_t&lt;In&gt;, std::iter_rvalue_reference_t&lt;In&gt;&gt; &amp;&amp;
    std::assignable_from&lt;std::iter_value_t&lt;In&gt;&amp;, std::iter_rvalue_reference_t&lt;In&gt;&gt;;
}}

The {{tt|indirectly_movable_storable}} concept specifies the relationship between an {{lconcept|indirectly_readable}} type and an {{lconcept|indirectly_writable}} type. In addition to {{lconcept|indirectly_movable}}, this concept specifies that the move from the {{tt|indirectly_readable}} type can be performed via an intermediate object.

===Semantic requirements===
{{tt|In}} and {{tt|Out}} model {{c|std::indirectly_movable_storable&lt;In, Out&gt;}} only if given a dereferenceable value {{tt|i}} of type {{tt|In}}:
* After the definition {{c|std::iter_value_t&lt;In&gt; obj(ranges::iter_move(i));}}, {{tt|obj}} is equal to the value previously denoted by {{c|*i}}, and
* if {{c|std::iter_rvalue_reference_t&lt;In&gt;}} is an rvalue reference type, {{c|*i}} is placed in a valid but unspecified state after the initialization of {{tt|obj}}.

{{cpp/concepts/equality preservation}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc indirectly_movable}}
{{dsc inc|cpp/iterator/dsc indirectly_copyable_storable}}
{{dsc end}}

{{langlinks|es|ja|zh}}