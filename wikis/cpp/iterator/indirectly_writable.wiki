{{cpp/title|indirectly_writable}}
{{cpp/iterator/navbar}}
{{ddcl|header=iterator|since=c++20|1=
template&lt; class Out, class T &gt;
    concept indirectly_writable =
        requires(Out&amp;&amp; o, T&amp;&amp; t) {
            *o = std::forward&lt;T&gt;(t);
            *std::forward&lt;Out&gt;(o) = std::forward&lt;T&gt;(t);
            const_cast&lt;const std::iter_reference_t&lt;Out&gt;&amp;&amp;&gt;(*o) = std::forward&lt;T&gt;(t);
            const_cast&lt;const std::iter_reference_t&lt;Out&gt;&amp;&amp;&gt;(*std::forward&lt;Out&gt;(o)) =
                std::forward&lt;T&gt;(t);
        };
        /* none of the four expressions above are required to be equality-preserving */
}}

The concept {{c|indirectly_writable&lt;Out, T&gt;}} specifies the requirements for writing a value whose type and value category are encoded by {{tt|T}} into an iterator {{tt|Out}}'s referenced object.

===Semantic requirements===
Let {{tt|e}} be an expression such that {{c|decltype((e))}} is {{tt|T}}, and {{tt|o}} be a dereferenceable object of type {{tt|Out}}, then {{c|indirectly_writable&lt;Out, T&gt;}} is modeled only if:
* If {{c|std::indirectly_readable&lt;Out&gt;}} is modeled and {{c|std::iter_value_t&lt;Out&gt;}} is the same type as {{c|std::decay_t&lt;T&gt;}}, then {{c|*o}} after any above assignment is equal to the value of {{tt|e}} before the assignment.

{{tt|o}} is not required to be dereferenceable after evaluating any of the assignment expressions above. If {{tt|e}} is an xvalue, the resulting state of the object it denotes is valid but unspecified.

{{cpp/concepts/equality preservation|skip-requires=yes}}

===Notes===
The only valid use of {{c|operator*}} is on the left side of an assignment expression. Assignment through the same value of an indirectly writable type may happen only once.

The required expressions with {{tt|const_cast}} prevent {{lconcept|indirectly_readable}} objects with prvalue {{tt|reference}} types from satisfying the syntactic requirements of {{tt|indirectly_writable}} by accident, while permitting proxy references to continue to work as long as their constness is shallow. See [https://github.com/ericniebler/stl2/issues/381 Ranges TS issue 381].

{{langlinks|es|ja|zh}}