{{cpp/title|indirect_strict_weak_order}}
{{cpp/iterator/navbar}}
{{ddcl|header=iterator|since=c++20|1=
template&lt; class F, class I1, class I2 = I1 &gt;
concept indirect_strict_weak_order =
    std::indirectly_readable&lt;I1&gt; &amp;&amp;
    std::indirectly_readable&lt;I2&gt; &amp;&amp;
    std::copy_constructible&lt;F&gt; &amp;&amp;
    std::strict_weak_order
        &lt;F&amp;, /*indirect-value-t*/&lt;I1&gt;, /*indirect-value-t*/&lt;I2&gt;&gt; &amp;&amp;
    std::strict_weak_order
        &lt;F&amp;, /*indirect-value-t*/&lt;I1&gt;, std::iter_reference_t&lt;I2&gt;&gt; &amp;&amp;
    std::strict_weak_order
        &lt;F&amp;, std::iter_reference_t&lt;I1&gt;, /*indirect-value-t*/&lt;I2&gt;&gt; &amp;&amp;
    std::strict_weak_order
        &lt;F&amp;, std::iter_reference_t&lt;I1&gt;, std::iter_reference_t&lt;I2&gt;&gt;;
}}

The concept {{tt|indirect_strict_weak_order}} specifies requirements for algorithms that call strict weak orders as their arguments. The key difference between this concept and {{lc|std::strict_weak_order}} is that it is applied to the types that {{tt|I1}} and {{tt|I2}} references, rather than {{tt|I1}} and {{tt|I2}} themselves.

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P2609R3|std=C++20|before=some requirements were defined in terms of&lt;br&gt;{{c/core|std::iter_value_t&lt;I&gt;&amp;}} which mishandled projections&lt;br&gt;resulting in incompatibility with strict weak order {{c/core|F&amp;}}|after=defined in terms of&lt;br&gt;{{c/core|/*indirect-value-t*/&lt;I&gt;}} to&lt;br&gt;correctly handle such projections}}
{{dr list item|paper=P2997R1|std=C++20|before={{tt|indirect_strict_weak_order}} required {{c/core|F&amp;}} to satisfy&lt;br&gt;{{lconcept|strict_weak_order}} with {{c/core|std::iter_common_reference_t&lt;I&gt;}}|after=does not require}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}