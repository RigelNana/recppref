{{cpp/title|indirectly_readable_traits}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl|num=1|since=c++20|
template&lt; class I &gt;
struct indirectly_readable_traits {};
}}
{{dcl|num=2|since=c++20|
template&lt; class T &gt;
struct indirectly_readable_traits&lt;T*&gt; :
    /* cond-value-type */&lt;T&gt; {};
}}
{{dcl|num=3|since=c++20|1=
template&lt; class I &gt;
    requires std::is_array_v&lt;I&gt;
struct indirectly_readable_traits&lt;I&gt;;
{ using value_type = std::remove_cv_t&lt;std::remove_extent_t&lt;I&gt;&gt;; }
}}
{{dcl|num=4|since=c++20|
template&lt; class T &gt;
struct indirectly_readable_traits&lt;const T&gt; :
    indirectly_readable_traits&lt;T&gt; {};
}}
{{dcl|num=5|since=c++20|
template&lt; /* has-member-value-type */ T &gt;
struct indirectly_readable_traits&lt;T&gt; :
    /* cond-value-type */&lt;typename T::value_type&gt; {};
}}
{{dcl|num=6|since=c++20|
template&lt; /* has-member-element-type */ T &gt;
struct indirectly_readable_traits&lt;T&gt; :
    /* cond-value-type */&lt;typename T::element_type&gt; {};

}}
{{dcl|num=7|since=c++20|
template&lt; /* has-member-value-type */ T &gt;
    requires /* has-member-element-type */&lt;T&gt;
struct indirectly_readable_traits&lt;T&gt; {};

}}
{{dcl|num=8|since=c++20|
template&lt; /* has-member-value-type */ T &gt;
    requires /* has-member-element-type */&lt;T&gt; &amp;&amp;
             std::same_as&lt;std::remove_cv_t&lt;typename T::element_type&gt;,
                          std::remove_cv_t&lt;typename T::value_type&gt;&gt;
struct indirectly_readable_traits&lt;T&gt; :
    /* cond-value-type */&lt;typename T::value_type&gt; {};
}}
{{dcl h|Helper classes and concepts}}
{{dcl|num=1|notes={{mark expos}}|
template&lt; class &gt;
struct /* cond-value-type */ {};
}}
{{dcl|num=2|notes={{mark expos}}|1=
template&lt; class T &gt;
    requires std::is_object_v&lt;T&gt;
struct /* cond-value-type */ &lt;T&gt;
{ using value_type = std::remove_cv_t&lt;T&gt;; };
}}
{{dcl|num=3|notes={{mark expos}}|1=
template&lt; class T &gt;
concept /* has-member-value-type */ =
    requires { typename T::value_type; };
}}
{{dcl|num=4|notes={{mark expos}}|1=
template&lt; class T &gt;
concept /* has-member-element-type */ =
    requires { typename T::element_type; };
}}
{{dcl end}}

Computes the associated value type of the template argument. If the associated value type exists, it is represented by the nested type {{tt|value_type}}, otherwise {{tt|value_type}} is not defined. A program may specialize {{tt|indirectly_readable_traits}} for a {{lsd|cpp/language/type#Program-defined type}}.

===Explanation===
The specializations above can be informally described as below.

Given a type {{tt|T}}, its associated value type {{tt|V}} is determined as follows:
* If {{tt|T}} is const-qualified, {{tt|V}} is the associated value type of const-unqualified {{tt|T}}.
* Otherwise, if {{tt|T}} is an array type, {{tt|V}} is the cv-unqualified array element type.
* Otherwise, a conditional value type {{tt|C}} is determined first:
:* If {{tt|T}} is a pointer type, {{tt|C}} is the pointed-to type.
:* Otherwise, if {{tt|T}} has nested types {{tt|value_type}} and {{tt|element_type}}:
::* If these types are the same (not considering cv-qualification), {{tt|C}} is {{tt|typename T::value_type}}.
::* Otherwise, {{tt|C}} is undefined.
:* Otherwise, if {{tt|T}} has the nested type {{tt|value_type}} but not {{tt|element_type}}, {{tt|C}} is {{tt|typename T::value_type}}.
:* Otherwise, if {{tt|T}} has the nested type {{tt|element_type}} but not {{tt|value_type}}, {{tt|C}} is {{tt|typename T::element_type}}.
:* Otherwise, {{tt|C}} is undefined.
: Then {{tt|V}} is determined from {{tt|C}} as follows:
:* If {{tt|C}} is undefined, or {{tt|C}} is not an {{lsd|cpp/language/type#Object type}}, {{tt|V}} is undefined.
:* Otherwise, {{tt|V}} is cv-unqualified {{tt|C}}.

===Notes===
{{tt|value_type}} is intended for use with {{lconcept|indirectly_readable}} types such as iterators. It is not intended for use with ranges.

===Example===
{{example}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3446|std=C++20|before=specializations {{v|5,6}} were ambiguous for types having&lt;br&gt;both {{tt|value_type}} and {{tt|element_type}} nested types|after=added specialization {{v|8}}}}
{{dr list item|wg=lwg|dr=3541|std=C++20|before=LWG 3446 introduced hard error for ambiguous cases&lt;br&gt;that {{tt|value_type}} and {{tt|element_type}} are different|after=added specialization {{v|7}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc indirectly_readable}}
{{dsc inc|cpp/iterator/dsc iter_t}}
{{dsc inc|cpp/iterator/dsc iterator_traits}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}