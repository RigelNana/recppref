{{cpp/iterator/reverse_iterator/title|operator{{=}}}}
{{cpp/iterator/reverse_iterator/navbar}}
{{ddcla|constexpr=c++17|1=
template&lt; class U &gt; 
reverse_iterator&amp; operator=( const reverse_iterator&lt;U&gt;&amp; other );
}}

Assigns {{box|{{c/core|other.}}{{rlpst|/#current}}}} to {{rlpst|/#current}}.

{{rrev|since=c++20|
{{cpp/enable if|{{c|std::is_same_v&lt;U, Iter&gt;}} is {{c|false}} and both {{c|std::convertible_to&lt;const U&amp;, Iter&gt;}} and {{c|std::assignable_from&lt;Iter&amp;, const U&amp;&gt;}} are modeled}}.
}}

===Parameters===
{{par begin}}
{{par|other|iterator adaptor to assign}}
{{par end}}

===Return value===
{{c|*this}}

===Example===
{{example|code=
#include &lt;iostream&gt;
#include &lt;iterator&gt;

int main()
{
    const int a1[]{0, 1, 2};
    int a2[]{0, 1, 2, 3};
    short a3[]{40, 41, 42};
    
    std::reverse_iterator&lt;const int*&gt; it1{std::crbegin(a1)};
    it1 = std::reverse_iterator&lt;int*&gt;{std::rbegin(a2)};   // OK
//  it1 = std::reverse_iterator&lt;short*&gt;{std::rbegin(a3)}; // Compilation error:
                                                          // incompatible pointer types
    std::reverse_iterator&lt;const short*&gt; it2{nullptr};
    it2 = std::rbegin(a3); // OK
//  it2 = std::begin(a3);  // Compilation error: no viable operator= overload
    std::cout &lt;&lt; *it2 &lt;&lt; '\n';
}
|output=42
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=280|std=C++98|before=heterogeneous assignment was not allowed|after=allowed}}
{{dr list item|wg=lwg|dr=3435|std=C++20|before=the converting assignment operator was not constrained|after=constrained}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/adaptor/dsc constructor|reverse_iterator}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}