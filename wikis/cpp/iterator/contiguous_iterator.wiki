{{cpp/title|contiguous_iterator}}
{{cpp/iterator/navbar}}
{{ddcl|header=iterator|since=c++20|1=
template&lt; class I &gt;
    concept contiguous_iterator =
        std::random_access_iterator&lt;I&gt; &amp;&amp;
        std::derived_from&lt;/*ITER_CONCEPT*/&lt;I&gt;, std::contiguous_iterator_tag&gt; &amp;&amp;
        std::is_lvalue_reference_v&lt;std::iter_reference_t&lt;I&gt;&gt; &amp;&amp;
        std::same_as&lt;
            std::iter_value_t&lt;I&gt;, std::remove_cvref_t&lt;std::iter_reference_t&lt;I&gt;&gt;
        &gt; &amp;&amp;
        requires(const I&amp; i) {
            { std::to_address(i) } -&gt;
              std::same_as&lt;std::add_pointer_t&lt;std::iter_reference_t&lt;I&gt;&gt;&gt;;
        };
}}

The {{tt|contiguous_iterator}} concept refines {{lconcept|random_access_iterator}} by providing a guarantee the denoted elements are stored contiguously in the memory.

{{cpp/iterator/iter concept}}

===Semantic requirements===
Let {{tt|a}} and {{tt|b}} be dereferenceable iterators and {{tt|c}} be a non-dereferenceable iterator of type {{tt|I}} such that {{tt|b}} is reachable from {{tt|a}} and {{tt|c}} is reachable from {{tt|b}}. The type {{tt|I}} models {{tt|contiguous_iterator}} only if all the concepts it subsumes are modeled and:
* {{c|1=std::to_address(a) == std::addressof(*a)}},
* {{c|1=std::to_address(b) == std::to_address(a) + std::iter_difference_t&lt;I&gt;(b - a)}}, and
* {{c|1=std::to_address(c) == std::to_address(a) + std::iter_difference_t&lt;I&gt;(c - a)}}.

{{cpp/concepts/equality preservation}}
{{cpp/concepts/implicit expression variations}}

===Notes===
{{tt|contiguous_iterator}} is modeled by every pointer type to complete object type.

Iterator types in the standard library that are required to satisfy the {{named req|ContiguousIterator}} requirements in C++17 are also required to model {{tt|contiguous_iterator}} in C++20.

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc random_access_iterator}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}