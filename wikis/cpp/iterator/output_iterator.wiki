{{cpp/title|output_iterator}}
{{cpp/iterator/navbar}}
{{dcl begin}}
{{dcl header|iterator}}
{{dcl|since=c++20|1=
template&lt; class I, class T &gt;
    concept output_iterator =
        std::input_or_output_iterator&lt;I&gt; &amp;&amp;
        std::indirectly_writable&lt;I, T&gt; &amp;&amp;
        requires(I i, T&amp;&amp; t) {
            *i++ = std::forward&lt;T&gt;(t); /* not required to be equality-preserving */
        };
}}
{{dcl end}}

The {{tt|output_iterator}} concept is a refinement of {{lconcept|input_or_output_iterator}}, adding the requirement that it can be used to write values of type and value category encoded by {{tt|T}} (via {{lconcept|indirectly_writable}}). {{lconcept|equality_comparable}} is not required.

===Semantic requirements===
Let {{tt|E}} be an expression such that {{c|decltype((E))}} is {{tt|T}}, and {{tt|i}} be a dereferenceable object of type {{tt|I}}. {{co|std::output_iterator&lt;I, T&gt;}} is modeled only if all the concepts it subsumes are modeled, and {{c|1=*i++ = E;}} has effects equivalent to {{c|1=*i = E; ++i;}}.

{{cpp/concepts/equality preservation|skip-requires=yes}}

===Notes===
Unlike the {{named req|OutputIterator}} requirements, the {{tt|output_iterator}} concept does not require that the iterator category tag be defined. 

Algorithms on output iterators should be single pass.

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc input_or_output_iterator}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}