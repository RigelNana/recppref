{{cpp/named req/title|ForwardIterator}}
{{cpp/named req/navbar}}

A {{named req|ForwardIterator}} is a {{named req|Iterator}} that can read data from the pointed-to element.

Unlike {{named req|InputIterator}} and {{named req|OutputIterator}}, it can be used in multipass algorithms. 

If a {{named req|ForwardIterator}} {{c|it}} originates from a {{named req|Container}}, then {{c|it}}'s value type is the same as the container's, so dereferencing ({{c|*it}}) obtains the container's value type.

===Requirements===
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|X}}|A forward iterator type}}
{{dsc|{{tt|T}}|The [[cpp/iterator#Types and writability|value type]] of {{tt|X}} (i.e. {{c/core|std::iterator_traits&lt;X&gt;::value_type}})}}
{{dsc|{{tt|Ref}}|{{c/core|std::iterator_traits&lt;X&gt;::reference}}}}
{{dsc hitem|Value|Definition}}
{{dsc|{{c|i}}, {{c|j}}|Values of type {{tt|X}} or {{c/core|const X}}}}
{{dsc|{{c|r}}|A value of type {{tt|X&amp;}}}}
{{dsc end}}

{{tt|X}} satisfies {{named req/core|ForwardIterator}} if all following conditions are satisfied:
* {{tt|X}} satisfies {{named req|InputIterator}}.
* {{tt|X}} satisfies {{named req|DefaultConstructible}}.
* If {{tt|X}} is a [[cpp/iterator|mutable iterator]], {{tt|Ref}} is a reference to {{tt|T}}.
* If {{tt|X}} is a constant iterator, {{tt|Ref}} is a reference to {{c/core|const T}}.
* Objects of the type {{tt|X}} provide [[#Multi-pass guarantee|multi-pass guarantee]].
* If {{c|i}} and {{c|j}} are equal, then either {{c|i}} and {{c|j}} are both [[cpp/iterator#Dereferenceability and validity|dereferenceable]] or else neither is dereferenceable.
* If {{c|i}} and {{c|j}} are both dereferenceable, then {{c|1=i == j}} if and only if {{c|*i}} and {{c|*j}} are bound to the same object.
* The following expressions must be valid and have their specified effects:
{|table class="wikitable"
|-
!{{nbsp}}Expression{{nbsp}}
!Type
!Effects
|-
|{{c|r++}}
|convertible to {{c/core|const X&amp;}}{{nbsp}}
|Equivalent to {{c multi|1=X x = r;|2=++r;|3=return x;}}.
|-
|{{c|*i++}}
|{{tt|Ref}}
|
|-
|}

===Equality domain===
The {{rlp|InputIterator#Equality domain|domain}} of {{c|1===}} for forward iterators is that of iterators over the same [[cpp/iterator#Dereferenceability and validity|underlying sequence]].

{{rrev|since=c++14|
However, [[cpp/language/value initialization|value-initialized]] forward iterators can be compared, and must compare equal to other value-initialized iterators of the same type.

In other words, value-initialized forward iterators behave as if they refer past the end of the same empty sequence.
}}

===Multi-pass guarantee===
Two dereferenceable iterators {{c|a}} and {{c|b}} of type {{tt|X}} offer the ''multi-pass guarantee'' if all following conditions are satisfied:
* {{c|1=a == b}} implies {{c|1=++a == ++b}}.
* Any of the following conditions is satisfied:
:* {{tt|X}} is a pointer type.
:* The expression {{c|(void)++X(a), *a}} is equivalent to the expression {{c|*a}}.

{{rrev|since=c++20|
===Concept===
For the definition of {{lc|std::iterator_traits}}, the following exposition-only concept is defined.

{{dcl begin}}
{{dcl|1=
template&lt;class It&gt;
concept __LegacyForwardIterator&lt;!-- called cpp17-forward-iterator in the standard --&gt; =
    __LegacyInputIterator&lt;It&gt; &amp;&amp; std::constructible_from&lt;It&gt; &amp;&amp;
    std::is_reference_v&lt;std::iter_reference_t&lt;It&gt;&gt; &amp;&amp;
    std::same_as&lt;
        std::remove_cvref_t&lt;std::iter_reference_t&lt;It&gt;&gt;,
        typename std::indirectly_readable_traits&lt;It&gt;::value_type&gt; &amp;&amp;
    requires(It it) {
        {  it++ } -&gt; std::convertible_to&lt;const It&amp;&gt;;
        { *it++ } -&gt; std::same_as&lt;std::iter_reference_t&lt;It&gt;&gt;;
    };
}}
{{dcl end}}

where the exposition-only concept {{tt|__LegacyInputIterator&lt;T&gt;}} is described in {{rlp|InputIterator#Concept|LegacyInputIterator}}.
}}

===Notes===
Unlike the {{lc|std::forward_iterator}} concept, the {{named req/core|ForwardIterator}} requirements requires dereference to return a reference.

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=1212|paper=N3066|std=C++98|before=the type of {{c|*i++}} did not match the type of&lt;br&gt;{{c|*i--}} required by {{named req|BidirectionalIterator}}|after=changed the&lt;br&gt;type to {{tt|Ref}}}}
{{dr list item|wg=lwg|dr=1311|paper=N3066|std=C++98|before=“{{c|1=a == b}} implies {{c|1=++a == ++b}}” alone&lt;br&gt;did not offer multipass guarantee&lt;ref&gt;In the scenario where {{c|a}} and {{c|b}} use the same underlying iterator, evaluating the expression {{c|1=++a == ++b}} actually increments the underlying container twice, but the result is still {{c|true}}.&lt;/ref&gt;|after=also requires “{{c|1=a == b}}&lt;br&gt;implies {{c|1=++a != b}}”&lt;ref&gt;Formally also requires implying {{c|1=++b != a}}.&lt;/ref&gt;}}
{{dr list item|wg=lwg|dr=3798|std=C++20|before={{tt|__LegacyForwardIterator}} required&lt;br&gt;{{c/core|std::iter_reference_t&lt;It&gt;}} to be an lvalue reference type|after=also allows rvalue&lt;br&gt;reference types}}
{{dr list end}}
&lt;references/&gt;

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc forward_iterator}}
{{see_also_iterator_library}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}