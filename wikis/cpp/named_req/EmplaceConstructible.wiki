{{cpp/named req/title|EmplaceConstructible|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}

Specifies that an object of the type can be constructed from a given set of arguments in uninitialized storage by a given allocator.

===Requirements===

The type {{ttb|T}} is {{named req|EmplaceConstructible}} into the {{named req|Container}} {{ttb|X}} (whose {{tt|value_type}} is identical to {{tt|T}}) from the arguments {{ttb|args}} if, given
{{dsc begin}}
{{dsc | {{ttb|A}} | an allocator type}}
{{dsc | {{ttb|m}} | an lvalue of type {{ttb|A}} }}
{{dsc | {{ttb|p}} | the pointer of type {{ttb|T*}} prepared by the container }}
{{dsc | {{ttb|args}} | zero or more arguments }}
{{dsc end}}

where {{ttb|X::allocator_type}} is identical to {{c|std::allocator_traits&lt;A&gt;::rebind_alloc&lt;T&gt;}},

the following expression is well-formed:

{{source|
std::allocator_traits&lt;A&gt;::construct(m, p, args);
}}

If {{ttb|X}} is not allocator-aware or is a {{lc|std::basic_string}} specialization, the term is defined as if {{ttb|A}} were {{lc|std::allocator&lt;T&gt;}}, except that no allocator object needs to be created, and user-defined specializations of {{lc|std::allocator}} are not instantiated.

===Notes===
Although it is required that customized {{tt|construct}} is used when constructing elements of {{lc|std::basic_string}} until C++23, all implementations only used the default mechanism. The requirement is corrected by {{wg21|P1072R10}} to match existing practice.

===See also===
{{dsc begin}}
{{dsc | {{named req|CopyInsertable}} }}
{{dsc | {{named req|MoveInsertable}} }}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}