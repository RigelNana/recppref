{{cpp/named req/title|OutputIterator}}
{{cpp/named req/navbar}}

A {{named req|OutputIterator}} is a {{named req|Iterator}} that can write to the pointed-to element.

An example of a type that implements {{named req/core|OutputIterator}} is [[cpp/iterator/ostream_iterator|std::ostream_iterator]].

When {{named req|ForwardIterator}}, {{named req|BidirectionalIterator}}, or {{named req|RandomAccessIterator}} satisfies the {{named req/core|OutputIterator}} requirements in addition to its own requirements, it is described as '''mutable'''.

===Requirements===
The type {{c|X}} satisfies {{named req/core|OutputIterator}} if

* The type {{c|X}} satisfies {{named req|Iterator}}
* {{c|X}} is a class type or a pointer type

And, given
* {{c|o}}, a value of some type that is writable to the output iterator (there may be multiple types that are writable, e.g. if {{c|1= operator=}} may be a template. There is no notion of {{tt|value_type}} as for the input iterators)
* {{c|r}}, an lvalue of type {{c|X}},

The following expressions must be valid and have their specified effects
{|table class="wikitable"
|-
!Expression||Return||Equivalent expression||Pre-condition||Post-conditions||Notes
|-
|{{c|1=*r = o}}
|(not used)
|
|{{c|r}} is dereferenceable
|{{c|r}} is incrementable
|After this operation {{c|r}} is not required to be dereferenceable and any copies of the previous value of {{c|r}} are no longer required to be dereferenceable or incrementable.
|-
|{{c|++r}}
|{{c|X&amp;}}
|
|{{c|r}} is incrementable
|{{c|r}} and {{c|++r}} designate the same iterator object, {{c|r}} is dereferenceable or past-the-end
|After this operation {{c|r}} is not required to be incrementable and any copies of the previous value of {{c|r}} are no longer required to be dereferenceable or incrementable.
|-
|{{c|r++}}
|convertible to {{c|const X&amp;}}
|{{c|1=
X temp = r;
++r;
return temp;
}}
|
|
|
|-
|{{c|1=*r++ = o}}
|(not used)
|{{c|1=*r = o;
++r;}}
|
|
|
|}

===Notes===
The only valid use of {{c|operator*}} with an output iterator is on the left of an assignment: {{c|operator*}} may return a proxy object, which defines a member {{c|1= operator=}} (which may be a template).

Equality and inequality may not be defined for output iterators. Even if an {{c|1= operator==}} is defined, {{c|1= x == y}} need not imply {{c|1= ++x == ++y}}.

Assignment through the same value of an output iterator happens only once: algorithms on output iterators must be single-pass algorithms.

Assignment through an output iterator is expected to alternate with incrementing. Double-increment is undefined behavior (C++ standard currently claims that double increment is supported, contrary to the STL documentation; this is {{lwg|2035}}).

Pure output-only iterator is allowed to declare its {{c|iterator_traits&lt;X&gt;::value_type}}, {{c|iterator_traits&lt;X&gt;::difference_type}}, {{c|iterator_traits&lt;X&gt;::pointer}}, and {{c|iterator_traits&lt;X&gt;::reference}} to be {{c/core|void}} (and iterators such as {{lc|std::back_insert_iterator}} do just that{{rev inl|since=c++20| except for {{tt|difference_type}}, which is now defined to satisfy {{lc|std::output_iterator}}}}).

===Standard library===
The following standard library iterators are output iterators that are not forward iterators:
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc ostream_iterator}}
{{dsc inc|cpp/iterator/dsc ostreambuf_iterator}}
{{dsc inc|cpp/iterator/dsc insert_iterator}}
{{dsc inc|cpp/iterator/dsc back_insert_iterator}}
{{dsc inc|cpp/iterator/dsc front_insert_iterator}}
{{dsc end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc output_iterator}}
{{see_also_iterator_library}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}