{{cpp/named req/title|AccessorPolicy|notes={{mark since c++23}}}}
{{cpp/named req/navbar}}

{{named req|AccessorPolicy}} defines how elements are accessed from a given data handle to such elements and an index. It is used as a policy in {{c/core|std::mdspan}} to specify the access to a reference of an element using an underlying 1D index.

===Requirements===
A type {{tt|A}} satisfies {{named req/core|AccessorPolicy}} if it models {{lconcept|copyable}}, and the following are {{c|true}}:
* {{c|std::is_nothrow_move_constructible_v&lt;A&gt;}}
* {{c|std::is_nothrow_move_assignable_v&lt;A&gt;}}
* {{c|std::is_nothrow_swappable_v&lt;A&gt;}}

And, given the following types and values, the expressions shown in the table below are valid and have the indicated semantics:

====Legend====
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|A}}|an accessor policy type}}
{{dsc|{{tt|OP}}|an offset policy type}}
{{dsc hitem|Value|Definition}}
{{dsc|{{c|a}}|a value of type (possibly const-qualified) {{tt|A}}}}
{{dsc|{{c|p}}|a value of type (possibly const-qualified) {{tt|A::data_handle_type}}}}
{{dsc|{{c|i}}, {{c|j}}, {{c|n}}|values of type {{c/core|std::size_t}}}}
{{dsc end}}

====Member types====
{|class=wikitable
!Name||Type||Requirements
|-
|{{tt|A::element_type}}||''(unspecified)''||
* A complete object type that is not an abstract class type
|-
|{{tt|A::data_handle_type}}||''(unspecified)'' but the type need not be {{c/core|element_type*}}||
* Models {{lconcept|copyable}}
* The following conditions are all {{c|true}}:
:* {{c|std::is_nothrow_move_constructible_v&lt;typename A::data_handle_type&gt;}}
:* {{c|std::is_nothrow_move_assignable_v&lt;typename A::data_handle_type&gt;}}
:* {{c|std::is_nothrow_swappable_v&lt;typename A::data_handle_type&gt;}}
|-
|{{tt|A::reference}}||''(unspecified)'' but the type need not be {{c/core|element_type&amp;}}||
* {{c|std::common_reference_with&lt;typename A::reference&amp;&amp;, typename A::element_type&amp;&gt;}} is {{c|true}}
|-
|{{tt|A::offset_policy}}||{{tt|OP}}||
* Satisfies the requirements of {{named req/core|AccessorPolicy}}
* {{c|std::constructible_from&lt;OP, const A&amp;&gt;}} is {{c|true}}
* {{c/core|typename OP​::​element_type}} and {{c/core|typename A​::​element_type}} are the same type
|}

====Member functions====
{|class=wikitable
!Expression||Return type||Semantics
|-
|{{c|a.access(p, i)}}||{{c/core|typename A::reference}}||
* The expression is [[cpp/concepts#Equality_preservation|equality-preserving]].
|-
|{{c|a.offset(p, i)}}||{{c/core|typename A::offset_policy::data_handle_type}}||
* A value {{c|q}} such that for {{c|b}} being {{c|A::offset_policy(a)}}, and any integer {{c|n}} for which {{range|0|n}} is an accessible range&lt;ref group="note"&gt;A range of indices {{range|0|N}} is an ''accessible range'' of a given data handle and an accessor if, for each index in the range, the {{c|access}} member function produces a valid reference to an element.&lt;/ref&gt; of {{c|p}} and {{c|a}}.
:* {{range|0|n - i}} is an accessible range of {{c|q}} and {{c|b}}; and
:* {{c|b.access(q, j)}} provides access to the same element as {{c|a.access(p, i + j)}}, for every {{c|j}} in the range {{range|0|n - i}}.
* The expression is [[cpp/concepts#Equality_preservation|equality-preserving]].
|}
&lt;references group="note"/&gt;

===Standard library===
The following standard library types satisfy {{named req/core|AccessorPolicy}} requirements:
{{dsc begin}}
{{dsc inc|cpp/container/mdspan/dsc default_accessor}}
{{dsc inc|cpp/container/mdspan/dsc aligned_accessor}}
{{dsc namespace|std::linalg}}
{{dsc inc|cpp/numeric/linalg/dsc scaled_accessor}}
{{dsc inc|cpp/numeric/linalg/dsc conjugated_accessor}}
{{dsc end}}