{{cpp/named req/title|TriviallyCopyable|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}

{{cpp/named req/core cat note}}

===Requirements===
The following types are collectively called ''trivially copyable types'':
* {{rlp|ScalarType|scalar types}}
* [[cpp/language/classes#Trivially copyable class|trivially copyable class types]]
* arrays of such types
* cv-qualified versions of these types

===Notes===
In general, for any trivially copyable type {{tt|T}} and an object {{tt|obj1}} of {{tt|T}}, the underlying bytes of {{tt|obj1}} can be copied into an array of {{c/core|char}}, or {{c/core|unsigned char}}{{rev inl|since=c++17|, or {{ltt|cpp/types/byte|std::byte}}}} or into {{tt|obj2}}, a distinct object of {{tt|T}}. Neither {{tt|obj1}} nor {{tt|obj2}} may be a potentially-overlapping subobject.

If the underlying bytes of {{tt|obj1}} are copied into such an array, and then the resulting content is copied back into {{tt|obj1}}, {{tt|obj1}} will hold its original value. If the underlying bytes of {{tt|obj1}} are copied into {{tt|obj2}}, {{tt|obj2}} will hold {{tt|obj1}}'s value.

Underlying bytes can be copied by {{lc|std::memcpy}} or {{lc|std::memmove}}, as long as no living volatile object is accessed.

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1734|std=C++11|before=C++03 POD with deleted non-trivial assignment was not trivial|after=deleted ctors/operators allowed}}
{{dr list item|wg=cwg|dr=2094|std=C++11|before=Volatile scalar types are not trivially copyable ({{cwg|1746|-}})|after=made trivially copyable}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_trivially_copyable}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}