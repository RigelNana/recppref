{{cpp/named req/title|NullablePointer|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}

Specifies that the type is a pointer-like object which can be compared to {{lc|std::nullptr_t}} objects.

===Requirements===
The type must meet all of the following requirements:
* {{named req|EqualityComparable}}
* {{named req|DefaultConstructible}}
* {{named req|CopyConstructible}}
* {{named req|CopyAssignable}}
* {{named req|Swappable}}
* {{named req|Destructible}}

In addition, a value-initialized object of the type must produce a null value of that type. This null value shall only be equivalent to itself. Default initialization of the type may have an [[cpp/language/default initialization#Indeterminate and erroneous values|indeterminate]]{{rev inl|since=c++26| or erroneous}} value.

A value of the type must be {{lt|cpp/language/implicit conversion#Contextual conversions|contextually convertible}} to {{c/core|bool}}. The effect of this conversion returns {{c|false}} if the value is equivalent to its null value and {{c|true}} otherwise.

None of the operations that this type performs may throw exceptions.

The type must satisfy the following additional expressions, given two values {{c|p}} and {{c|q}} that are of the type, and that {{c|np}} is a value of {{lc|std::nullptr_t}} type (possibly const-qualified):

{{dsc begin}}
{{dsc hitem|Declaration|Effects}}
{{dsc|{{c|Type p(np);}}
{{c|1=Type p = np;}}|Afterwards, {{c|p}} is equivalent to {{c|nullptr}}}}
{{dsc hitem|Expression|Effects}}
{{dsc|{{c|Type(np)}}|A temporary object that is equivalent to {{c|nullptr}}}}
{{dsc|{{c|1=p = np }}|Must return a {{tt|Type&amp;}}, and afterwards, {{c|p}} is equivalent to {{c|nullptr}}}}
{{dsc|{{c|1=p != q}}|&lt;br&gt;
{{rrev multi|until1=c++20
|rev1=Type and value meet the {{named req|BooleanTestable}} requirements
|rev2={{c/core|1=decltype(p != q)}} models {{lconcept|boolean-testable}}
}}
The effect is {{c|1=!(p == q)}}
}}
{{dsc|{{c|1=p == np}}
{{c|1=np == p}}|&lt;br&gt;
{{rrev multi|until1=c++20
|rev1=Type and value of both expressions the {{named req|BooleanTestable}} requirements
|rev2={{c/core|1=decltype(p == np)}} and {{c/core|1=decltype(np == p)}} each model {{lconcept|boolean-testable}}
}}
The effect is {{c|1=(p == Type())}}}}
{{dsc|{{c|1=p != np}}
{{c|1=np != p}}|&lt;br&gt;
{{rrev multi|until1=c++20
|rev1=Type and value of both expressions the {{named req|BooleanTestable}} requirements
|rev2={{c/core|1=decltype(p != np)}} and {{c/core|1=decltype(np != p)}} each model {{lconcept|boolean-testable}}
}}
The effect is {{c|1=!(p == np)}}}}
{{dsc end}}

===Notes===
Note that dereferencing ({{c|operator*}} or {{c|operator-&gt;}}) is not required for a {{named req/core|NullablePointer}} type. A minimalistic type that satisfies these requirements is

{{source|1=
class handle
{
    int id = 0;
public:
    handle() = default;
    handle(std::nullptr_t) {}
    explicit operator bool() const { return id != 0; }
    friend bool operator==(handle l, handle r) { return l.id == r.id; }
    friend bool operator!=(handle l, handle r) { return !(l == r); }
    // or only a defaulted operator== (since C++20)
};
}}

===Standard library===
The following types satisfy {{named req/core|NullablePointer}}:
* {{lc|std::exception_ptr}}.

The following types must satisfy {{named req/core|NullablePointer}} in order to communicate with standard library components:

* The member types {{tt|X::pointer}}, {{tt|X::const_pointer}}, {{tt|X::void_pointer}} and {{tt|X::const_void_pointer}} of every {{named req|Allocator}} type {{tt|X}}.
* The member type {{tt|pointer}} of {{lc|std::unique_ptr}}.
{{rrev|since=c++23|
* The adapted pointer type of {{ltt|cpp/memory/inout_ptr_t|std::inout_ptr_t}} and {{ltt|cpp/memory/out_ptr_t|std::out_ptr_t}}.
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2114|paper=P2167R3|std=C++11|before=contextual convertibility to {{c/core|bool}} was too weak to reflect the expectation of implementations|after=requirements strengthened}}
{{dr list end}}

{{langlinks|es|ja|zh}}