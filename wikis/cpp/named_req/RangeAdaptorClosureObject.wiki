{{cpp/named req/title|RangeAdaptorClosureObject|notes={{mark since c++20}}}}
{{cpp/named req/navbar}}

''Range adaptor closure objects'' are {{named req|FunctionObject}}s that are callable via the pipe operator: if {{c|C}} is a range adaptor closure object and {{c|R}} is a {{lconcept|range}}, these two expressions are [[cpp/language/expressions#Expression-equivalence|equivalent]]:
{{source|1=
C(R)
R {{!}} C
}}

Two range adaptor closure objects can be chained by {{c|operator{{!}}}} to produce another range adaptor closure object: if {{c|C}} and {{c|D}} are range adaptor closure objects, then {{c|C {{!}} D}} produces a range adaptor closure object {{c|E}} with the following properties:

* {{c|E}} stores a copy of {{c|C}} and {{c|D}}, direct-non-list-initialized from {{c|std::forward&lt;decltype((C))&gt;(C)}} and {{c|std::forward&lt;decltype((D))&gt;(D)}} respectively. If such initialization is invalid, {{c|C {{!}} D}} is also invalid.
* Let {{c|c}} and {{c|d}} be the stored copies (with the same constness and value category as {{c|E}}), and {{c|R}} be a {{lconcept|range}} object, the following expressions are [[cpp/language/expressions#Expression-equivalence|equivalent]]:
{{source|1=
d(c(R))
R {{!}} c {{!}} d
E(R)
R {{!}} E // R {{!}} (C {{!}} D)
}}

Notes: {{c|operator()}} is unsupported for volatile-qualified or const-volatile-qualified version of range adaptor object closure types.

Objects whose type is the same as one of the following objects (ignoring cv-qualification) are range adaptor closure objects:
* unary range adaptor objects,
{{rrev|since=c++23|
* objects of user-defined types that meet [[cpp/ranges/range_adaptor_closure|the requirements of implementing a range adaptor closure object]],
}}
* the results of binding trailing arguments by range adaptor objects, and
* the results of chaining two range adaptor closure objects by {{c|operator{{!}}}}.

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc range_adaptor_closure}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}