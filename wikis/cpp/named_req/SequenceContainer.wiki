{{cpp/named req/title|SequenceContainer}}
{{cpp/named req/navbar}}

A {{named req|SequenceContainer}} is a {{named req|Container}} that stores objects of the same type in a linear arrangement.

===Requirements===
Given the following types and values:
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|C}}|a sequence container class}}
{{dsc|{{tt|T}}|the element type of {{tt|C}}}}
{{dsc|{{tt|A}}|the allocator type of {{tt|C}}:
* {{tt|C::allocator_type}} if it exists,
* otherwise {{c/core|std::allocator&lt;T&gt;}}}}
{{dsc|{{tt|R}} {{mark since c++23}}|a type that models {{lti|cpp/ranges/to#container compatible range|container-compatible-range}}{{sep}}{{tt|&lt;T&gt;}}}}
{{dsc|{{tt|Args}} {{mark since c++11}}|a template parameter pack}}
{{dsc|{{tt|Iter}}|{{tt|C::iterator}}}}
{{dsc|{{tt|Ref}}|{{tt|C::reference}}}}
{{dsc|{{tt|CRef}}|{{tt|C::const_reference}}}}
{{dsc hitem|Value|Definition}}
{{dsc|{{c|v}}|a value of type {{tt|C}}}}
{{dsc|{{c|cv}}|a value of type {{c/core|const C}}}}
{{dsc|{{c|i}}, {{c|j}}|{{named req|InputIterator}}s such that {{range|i|j}} is a [[cpp/iterator#Ranges|valid range]] and that the iterators refer to elements implicitly convertible to {{tt|C::value_type}}}}
{{dsc|{{c|rg}} {{mark since c++23}}|a value of type {{tt|R}}}}
{{dsc|{{c|il}} {{mark since c++11}}|a value of type {{c/core|std::initializer_list&lt;C::value_type&gt;}}}}
{{dsc|{{c|n}}|a value of type {{tt|C::size_type}}}}
{{dsc|{{c|p}}|a valid [[cpp/iterator|const iterator]] into {{c|v}}}}
{{dsc|{{c|q}}|a [[cpp/iterator#Dereferenceability and validity|valid dereferenceable]] const iterator into {{c|v}}}}
{{dsc|{{c|q1}}, {{c|q2}}|const iterators into {{c|v}} such that {{range|q1|q2}} is a valid range}}
{{dsc|{{c|t}}|{{rev inl|until=c++11|a value}}{{rev inl|since=c++11|an [[cpp/language/value category|lvalue]] or const rvalue}} of type {{tt|C::value_type}}}}
{{dsc|{{c|rv}} {{mark since c++11}}|a non-const rvalue of type {{tt|C::value_type}}}}
{{dsc|{{c|args}} {{mark since c++11}}|a function parameter pack with the pattern {{tt|Arg&amp;&amp;}}}}
{{dsc end}}

{{tt|C}} satisfies the requirements of {{named req/core|SequenceContainer}} if all following conditions are satisfied:
* {{tt|C}} satisfies the requirements of {{named req|Container}}.
* The following statements and expressions are well-formed and have the specified semantics:

&lt;div style="max-width: 100%; max-height: 80vh; overflow-y: scroll; margin: 1em 0;"&gt;
{|class=wikitable style="margin: 0;"
|-style="position: sticky; top: 0;"
!colspan=4 style="font-size: 16px; line-height: 16px;"|Basic operations&lt;br&gt;{{normal|{{small|(required for all sequence containers in the [[#Standard library|standard library]]{{rev inl|since=c++11| except {{lc|std::array}}}})}}}}

|-
!colspan=2|Statement
!colspan=2|{{nbsp|4}}Semantics&lt;ref&gt;For an expression whose effect is equivalent to some other operations, the conditions of the expressions inside those operations are inherited on top of the conditions listed in the table.&lt;/ref&gt;

|-
|rowspan=3 colspan=2|{{c|C c(n, t);}}
|Effect
|Constructs the sequence container holding {{c|n}} copies of {{c|t}}.
|-
|Precondition
|
{{rrev|since=c++11|
{{tt|T}} is {{named req|CopyInsertable}} into {{tt|C}}.
}}
|-
|Postcondition{{nbsp}}
|{{c|std::distance(c.begin(), c.end())}} is {{c|n}}.

|-
|rowspan=3 colspan=2|{{c|C c(i, j);}}
|Effect
|Constructs the sequence container equal, element-wise, to the range {{range|i|j}}.
* Each iterator in the range {{range|i|j}} is dereferenced exactly once.
|-
|Precondition
|
{{rrev|since=c++11|
{{tt|T}} is {{named req|EmplaceConstructible}} into {{tt|C}} from {{c|*i}}.
}}
|-
|Postcondition
|{{c|std::distance(c.begin(), c.end())}} is {{c|std::distance(i, j)}}.

|-
!Expression
!{{nbsp}}Type{{nbsp}}
!colspan=2|Semantics

|-
|rowspan=3|{{small|{{c|C(std::from_range, rg)}}}}&lt;br&gt;{{mark since c++23}}
|rowspan=3|{{tt|C}}
|Effect
|Constructs the sequence container equal, element-wise, to the range {{c|rg}}.
* Each iterator in the range {{c|rg}} is dereferenced exactly once.
|-
|Precondition
|{{tt|T}} is {{named req|EmplaceConstructible}} into {{tt|X}} from {{c|*ranges::begin(rg)}}.
|-
|Postcondition
|{{c|std::distance(begin(), end())}} is {{c|ranges::distance(rg)}}.
|-
|{{c|C(il)}}&lt;br&gt;{{mark since c++11}}
|{{tt|C}}
|colspan=2|Equivalent to {{c|C(il.begin(), il.end())}}.

|-
|rowspan=4|{{c|1=v = il}}&lt;br&gt;{{mark since c++11}}
|rowspan=4|{{tt|C&amp;}}
|Effect
|Assigns the range represented by {{c|il}} into {{c|v}}.&lt;ref&gt;{{lc|std::array}} supports assignment from a [[cpp/language/initialization|brace-enclosed initializer list]], but not from an {{lc|std::initializer_list}}.&lt;/ref&gt;
|-
|Return value
|{{c|*this}}
|-
|Precondition
|{{tt|T}} is {{named req|CopyInsertable}} into {{tt|C}} and {{named req|CopyAssignable}}.
|-
|Postcondition
|Existing elements of {{c|v}} are either destroyed or assigned to.

|-
|rowspan=3|{{c|v.emplace(p, args)}}&lt;br&gt;{{mark since c++11}}
|rowspan=3|{{tt|Iter}}{{nbsp}}
|Effect
|Insert an object of type {{tt|T}}, constructed with {{c|std::forward&lt;Args&gt;(args)...}} before {{c|p}}.
|-
|Return value
|An iterator that points to the new element constructed from {{c|args}} into {{c|v}}.
|-
|Precondition
|{{tt|T}} is {{named req|EmplaceConstructible}} into {{tt|C}} from {{c|args}}.

|-
|rowspan=3|{{c|v.insert(p, t)}}
|rowspan=3|{{tt|Iter}}
|Effect
|Inserts a copy of {{c|t}} before {{c|p}}.
|-
|Return value
|An iterator that points to the copy of {{c|t}} inserted into {{c|v}}.
|-
|Precondition
|
{{rrev|since=c++11|
{{tt|T}} is {{named req|CopyInsertable}} into {{tt|C}}.
}}

|-
|rowspan=3|{{c|v.insert(p, rv)}}&lt;br&gt;{{mark since c++11}}
|rowspan=3|{{tt|Iter}}
|Effect
|Inserts a copy of {{c|rv}} before {{c|p}}, possibly using move semantics.
|-
|Return value
|An iterator that points to the copy of {{c|rv}} inserted into {{c|v}}.
|-
|Precondition
|{{tt|T}} is {{named req|MoveInsertable}} into {{tt|C}}.

|-
|rowspan=3|{{c|v.insert(p, n, t)}}
|rowspan=3|{{tt|Iter}}
|Effect
|Inserts {{c|n}} copies of {{c|t}} before {{c|p}}.
|-
|Return value
|An iterator that points to the copy of the first element inserted into {{c|v}}, or {{c|p}} if {{c|n}} is {{c|0}}.
|-
|Precondition
|
{{rrev|since=c++11|
{{tt|T}} is {{named req|CopyInsertable}} into {{tt|C}} and {{named req|CopyAssignable}}.
}}

|-
|rowspan=3|{{c|v.insert(p, i, j)}}
|rowspan=3|{{tt|Iter}}
|Effect
|Inserts copies of elements in {{range|i|j}} before {{c|p}}.
* Each iterator in the range {{range|i|j}} is dereferenced exactly once.
|-
|Return value
|An iterator that points to the copy of the first element inserted into {{c|v}}, or {{c|p}} if {{c|1=i == j}} is {{c|true}}.
|-
|Precondition
|
{{rrev|since=c++11|
* {{tt|T}} is {{named req|EmplaceConstructible}} into {{tt|C}} from {{c|*i}}.
}}
* {{c|i}} and {{c|j}} are not in {{c|v}}.

|-
|rowspan=3|{{small|{{c|v.insert_range(p, rg)}}}}&lt;br&gt;{{mark since c++23}}
|rowspan=3|{{tt|Iter}}
|Effect
|Inserts copies of elements in {{c|rg}} before {{c|p}}.
* Each iterator in the range {{c|rg}} is dereferenced exactly once.
|-
|Return value
|An iterator that points to the copy of the first element inserted into {{c|v}}, or {{c|p}} if {{c|rg}} is empty.
|-
|Precondition
|
* {{tt|T}} is {{named req|EmplaceConstructible}} into {{tt|C}} from {{c|*ranges::begin(rg)}}.
* {{c|rg}} and {{c|v}} do not overlap.

|-
|{{c|v.insert(p, il)}}&lt;br&gt;{{mark since c++11}}
|{{tt|Iter}}
|colspan=2|Equivalent to {{c|v.insert(p, il.begin(), il.end())}}.

|-
|rowspan=2|{{c|v.erase(q)}}
|rowspan=2|{{tt|Iter}}
|Effect
|Erases the element pointed to by {{c|q}}.
|-
|Return value
|An iterator that points to the element immediately following {{c|q}} prior to the element being erased, or {{c|v.end()}} if no such element exists.

|-
|rowspan=2|{{c|v.erase(q1, q2)}}
|rowspan=2|{{tt|Iter}}
|Effect
|Erases elements in {{range|q1|q2}}.
|-
|Return value
|An iterator that points to the element pointed to by {{c|q2}} prior to any elements being erased, or {{c|v.end()}} if no such element exists.

|-
|rowspan=3|{{c|v.clear()}}
|rowspan=3|{{c/core|void}}
|Effect
|Destroys all elements in {{c|v}}.
* Invalidates all references, pointers, and iterators referring to the elements of {{c|v}} and may invalidate the past-the-end iterator.
|-
|Postcondition
|{{c|v.empty()}} is {{c|true}}.
|-
|Complexity
|Linear.

|-
|rowspan=2|{{c|v.assign(i, j)}}
|rowspan=2|{{c/core|void}}
|Effect
|Replaces elements in {{c|v}} with a copy of {{range|i|j}}.
* Invalidates all references, pointers and iterators referring to the elements of {{c|v}}.
* Each iterator in {{range|i|j}} is dereferenced exactly once.
|-
|Precondition
|
{{rrev|since=c++11|
* {{tt|T}} is {{named req|EmplaceConstructible}} into {{tt|C}} from {{c|*i}}.
* {{tt|T}} is assignable from {{c|*i}}.
}}
* {{c|i}} and {{c|j}} are not in {{c|v}}.

|-
|rowspan=2|{{c|v.assign_range(rg)}}&lt;br&gt;{{mark since c++23}}
|rowspan=2|{{c/core|void}}
|Effect
|Replaces elements in {{c|v}} with a copy of each element in {{c|rg}}.
* If {{box|{{co|std::assignable_from}}&lt;br&gt;{{nbspt|4}}{{co|&lt;T&amp;, ranges::range_reference_t&lt;R&gt;&gt;}}}} is not modeled, the program is ill-formed.
* Invalidates all references, pointers and iterators referring to the elements of {{c|v}}.
* Each iterator in the range {{c|rg}} is dereferenced exactly once.
|-
|Precondition
|
* {{tt|T}} is {{named req|EmplaceConstructible}} into {{tt|C}} from {{c|*ranges::begin(rg)}}.
* {{c|rg}} and {{c|v}} do not overlap.

|-
|{{c|v.assign(il)}}&lt;br&gt;{{mark since c++11}}
|{{c/core|void}}
|colspan=2|Equivalent to {{c|v.assign(il.begin(), il.end())}}.

|-
|rowspan=2|{{c|v.assign(n, t)}}
|rowspan=2|{{c/core|void}}
|Effect
|Replaces elements in {{c|v}} with {{c|n}} copies of {{c|t}}.
|-
|Precondition
|
{{rrev|since=c++11|
{{tt|T}} is {{named req|CopyInsertable}} into {{tt|C}} and {{named req|CopyAssignable}}.
}}

|-style="position: sticky; top: 0;"
!colspan=4 style="font-size: 16px; line-height: 16px;"|{{nbsp|4}}Extra operations&lt;ref&gt;All operations below{{rev inl|since=c++23| except {{tt|prepend_range}} and {{tt|append_range}}}} take amortized constant time.&lt;/ref&gt;&lt;br&gt;{{normal|{{small|(only required for specified sequence containers, omitting {{tt|std::}})}}}}

|-
!Expression
!{{nbsp}}Type{{nbsp}}
!colspan=2|Semantics

|-
|rowspan=2|{{c|v.front()}}
|rowspan=2|{{tt|Ref}}
|Containers
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}, {{lt|cpp/container/forward_list}}}}
|-
|Return value
|{{c|*v.begin()}}

|-
|rowspan=2|{{c|cv.front()}}
|rowspan=2|{{tt|CRef}}
|Containers
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}, {{lt|cpp/container/forward_list}}}}
|-
|Return value
|{{c|*cv.begin()}}

|-
|rowspan=2|{{c|v.back()}}
|rowspan=2|{{tt|Ref}}
|Containers
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}}}
|-
|colspan=2|Equivalent to {{c|1=auto tmp = v.end(); --tmp; return *tmp;}}&lt;ref&gt;In C++98, {{c|tmp}} was declared to have type {{tt|C::iterator}}.&lt;/ref&gt;.

|-
|rowspan=2|{{c|cv.back()}}
|rowspan=2|{{tt|CRef}}
|Containers
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}}}
|-
|colspan=2|Equivalent to {{c|1=auto tmp = cv.end(); --tmp; return *tmp;}}&lt;ref&gt;In C++98, {{c|tmp}} was declared to have type {{tt|C::const_iterator}}.&lt;/ref&gt;.

|-
|rowspan=4|{{c|v.emplace_front(args)}}&lt;br&gt;{{mark since c++11}}
|rowspan=4|{{c/core|void}}
|Containers
|{{tt|{{lt|cpp/container/deque}}, {{lt|cpp/container/list}}, {{lt|cpp/container/forward_list}}}}
|-
|Effect
|Prepends an object of type {{tt|T}} constructed with {{c|std::forward&lt;Args&gt;(args)...}}.
|-
|Return value
|{{c|v.front()}}
|-
|Precondition
|{{tt|T}} is {{named req|EmplaceConstructible}} into {{tt|C}} from {{c|args}}.

|-
|rowspan=4|{{c|v.emplace_back(args)}}&lt;br&gt;{{mark since c++11}}
|rowspan=4|{{c/core|void}}
|Containers
|{{tt|{{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}}}
|-
|Effect
|Appends an object of type {{tt|T}} constructed with {{c|std::forward&lt;Args&gt;(args)...}}.
|-
|Return value
|{{c|v.back()}}
|-
|Precondition
|{{tt|T}} is {{named req|EmplaceConstructible}} into {{tt|C}} from {{c|args}}.

|-
|rowspan=3|{{c|v.push_front(t)}}
|rowspan=3|{{c/core|void}}
|Containers
|{{tt|{{lt|cpp/container/deque}}, {{lt|cpp/container/list}}, {{lt|cpp/container/forward_list}}}}
|-
|Effect
|Prepends a copy of {{c|t}}.
|-
|Precondition
|
{{rrev|since=c++11|
{{tt|T}} is {{named req|CopyInsertable}} into {{tt|C}}.
}}

|-
|rowspan=3|{{c|v.push_front(rv)}}&lt;br&gt;{{mark since c++11}}
|rowspan=3|{{c/core|void}}
|Containers
|{{tt|{{lt|cpp/container/deque}}, {{lt|cpp/container/list}}, {{lt|cpp/container/forward_list}}}}
|-
|Effect
|Prepends a copy of {{c|rv}}, possibly using move semantics.
|-
|Precondition
|{{tt|T}} is {{named req|MoveInsertable}} into {{tt|C}}.

|-
|rowspan=3|{{c|v.prepend_range(rg)}}&lt;br&gt;{{mark since c++23}}
|rowspan=3|{{c/core|void}}
|Containers
|{{tt|{{lt|cpp/container/deque}}, {{lt|cpp/container/list}}, {{lt|cpp/container/forward_list}}}}
|-
|Effect
|Inserts&lt;ref name="range"&gt;Insertion order, relative to order of elements in {{c|rg}}, is non-reversing.&lt;/ref&gt; copies of elements in {{c|rg}} before {{c|v.begin()}}.
* Each iterator in the range {{c|rg}} is dereferenced exactly once.
|-
|Precondition
|{{tt|T}} is {{named req|EmplaceConstructible}} into {{tt|C}} from {{c|*ranges::begin(rg)}}.

|-
|rowspan=3|{{c|v.push_back(t)}}
|rowspan=3|{{c/core|void}}
|Containers
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}}}
|-
|Effect
|Appends a copy of {{c|t}}.
|-
|Precondition
|
{{rrev|since=c++11|
{{tt|T}} is {{named req|CopyInsertable}} into {{tt|C}}.
}}

|-
|rowspan=3|{{c|v.push_back(rv)}}&lt;br&gt;{{mark since c++11}}
|rowspan=3|{{c/core|void}}
|Containers
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}}}
|-
|Effect
|Appends a copy of {{c|rv}}, possibly using move semantics.
|-
|Precondition
|{{tt|T}} is {{named req|MoveInsertable}} into {{tt|C}}.

|-
|rowspan=3|{{c|v.append_range(rg)}}&lt;br&gt;{{mark since c++23}}
|rowspan=3|{{c/core|void}}
|Containers
|{{tt|{{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}}}
|-
|Effect
|Inserts&lt;ref name="range"/&gt; copies of elements in {{c|rg}} before {{c|v.end()}}.
* Each iterator in the range {{c|rg}} is dereferenced exactly once.
|-
|Precondition
|{{tt|T}} is {{named req|EmplaceConstructible}} into {{tt|C}} from {{c|*ranges::begin(rg)}}.

|-
|rowspan=3|{{c|v.pop_front()}}
|rowspan=3|{{c/core|void}}
|Containers
|{{tt|{{lt|cpp/container/deque}}, {{lt|cpp/container/list}}, {{lt|cpp/container/forward_list}}}}
|-
|Effect
|Destroys the first element.
|-
|Precondition
|{{c|a.empty()}} is {{c|false}}.

|-
|rowspan=3|{{c|v.pop_back()}}
|rowspan=3|{{c/core|void}}
|Containers
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}, {{lt|cpp/container/list}}}}
|-
|Effect
|Destroys the last element.
|-
|Precondition
|{{c|a.empty()}} is {{c|false}}.

|-
|rowspan=2|{{c|v[n]}}
|rowspan=2|{{tt|Ref}}
|Containers
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}}}
|-
|colspan=2|Equivalent to {{c|return *(v.begin() + n);}}.

|-
|rowspan=2|{{c|cv[n]}}
|rowspan=2|{{tt|CRef}}
|Containers
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}}}
|-
|colspan=2|Equivalent to {{c|return *(cv.begin() + n);}}.

|-
|rowspan=3|{{c|v.at(n)}}
|rowspan=3|{{tt|Ref}}
|Containers
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}}}
|-
|Return value
|{{c|*(v.begin() + n)}}
|-
|Exceptions
|Throws {{lc|std::out_of_range}} if {{c|1=n &gt;= v.size()}} is {{c|true}}.

|-
|rowspan=3|{{c|cv.at(n)}}
|rowspan=3|{{tt|CRef}}
|Containers
|{{tt|{{lt|cpp/string/basic_string}}, {{lt|cpp/container/array}}, {{lt|cpp/container/vector}}, {{lt|cpp/container/inplace_vector}}, {{lt|cpp/container/deque}}}}
|-
|Return value
|{{c|*(cv.begin() + n)}}
|-
|Exceptions
|Throws {{lc|std::out_of_range}} if {{c|1=n &gt;= cv.size()}} is {{c|true}}.

|-
!colspan=4|Notes
|-
|colspan=4|&lt;references/&gt;
|}
&lt;/div&gt;

Additionally, for every sequence container:
* A constructor template that takes two input iterators and the member function template overloads of {{tt|insert}}, {{tt|append}}, {{tt|assign}}, {{tt|replace}} that take two input iterators do not participate in overload resolution if the corresponding template argument does not satisfy {{named req|InputIterator}}.
{{rrev|since=c++17|
* A deduction guide that has either a {{named req|InputIterator}} or an {{tt|Allocator}} template parameter does not participate in overload resolution if the type that does not qualify as an input iterator or an allocator respectively is deduced for that parameter.
}}

===Standard library===
The following standard library string types and containers satisfy the {{named req/core|SequenceContainer}} requirements:
{{dsc begin}}
{{dsc inc|cpp/string/dsc basic_string}}
{{dsc inc|cpp/container/dsc array}}
{{dsc inc|cpp/container/dsc vector}}
{{dsc inc|cpp/container/dsc inplace_vector}}
{{dsc inc|cpp/container/dsc deque}}
{{dsc inc|cpp/container/dsc forward_list}}
{{dsc inc|cpp/container/dsc list}}
{{dsc end}}

====Usage notes====
{|class="wikitable" style="text-align: center;"
!Container
!Pros
!Cons
|-
|{{lc|std::vector}}
|Fast access, contiguous storage
|Mostly inefficient insertions/deletions
|-
|{{c/core|std::inplace_vector}}
|Fast access, inplace contiguous storage
|Fixed capacity and mostly inefficient insertions/deletions
|-
|{{lc|std::array}}
|Fast access, inplace contiguous storage
|Fixed number of elements and no insertion/deletion
|-
|{{lc|std::deque}}
|Fast access, efficient insertion/deletion at the beginning/end
|Inefficient insertion/deletion in the middle of the sequence
|-
|{{lc|std::list}}&lt;br&gt;{{lc|std::forward_list}}
|Efficient insertion/deletion in the middle of the sequence
|Access is mostly linear-time
|}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=139|std=C++98|before=the optional operations were not required to&lt;br&gt;be implemented for the designated containers|after=required with amortized time}}
{{dr list item|wg=lwg|dr=149|std=C++98|before={{c|v.insert(p, t)}} returned {{tt|Iter}} while&lt;br&gt;{{c|v.insert(p, n, t)}} and {{c|v.insert(p, n, t)}} returned {{c/core|void}}|after=they all return {{tt|Iter}}}}
{{dr list item|wg=lwg|dr=151|std=C++98|before={{c|q1}} was required to be dereferenceable&lt;ref&gt;It is a defect because it makes the behavior of {{c|v.erase(v.begin(), v.end())}} undefined is {{c|v}} is an empty container.&lt;/ref&gt;|after=it can be non-dereferenceable}}
{{dr list item|wg=lwg|dr=355|std=C++98|before=calling {{c|v.back()}} or {{c|v.pop_back()}} would&lt;br&gt;execute {{c|--v.end()}}, which is dangerous&lt;ref&gt;If the type of {{c|v.end()}} is a fundamental type, {{c|--v.end()}} is ill-formed. It is dangerous when the type of {{c|v}} is templated, in this case this bug can be difficult to be found.&lt;/ref&gt;|after=decrements a copy&lt;br&gt;of {{c|v.end()}} instead}}
{{dr list item|wg=lwg|dr=589|std=C++98|before=the elements that {{c|i}} and {{c|j}} refer to&lt;br&gt;might not be convertible to {{tt|C::value_type}}|after=they are implicitly&lt;br&gt;convertible to {{tt|C::value_type}}}}
{{dr list item|wg=lwg|dr=2194|std=C++11|before={{lc|std::queue}}, {{lc|std::priority_queue}} and&lt;br&gt;{{lc|std::stack}} were also {{named req/core|SequenceContainer}}s&lt;ref&gt;They were not documented as {{named req/core|SequenceContainer}}s in C++98.&lt;/ref&gt;|after=they are not {{named req/core|SequenceContainer}}s}}
{{dr list item|wg=lwg|dr=2231|std=C++11|before=the complexity requirement of {{c|v.clear()}}&lt;br&gt;was mistakenly omitted in C++11|after=complexity reaffirmed as linear}}
{{dr list item|wg=lwg|dr=3927|std=C++98|before={{c/core|operator[]}} had no implicit requirement|after=added the implicit requirement}}
{{dr list end}}
&lt;references/&gt;

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}