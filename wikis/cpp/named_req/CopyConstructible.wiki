{{cpp/named req/title|CopyConstructible}}
{{cpp/named req/navbar}}

Specifies that an instance of the type can be copy-constructed from an [[cpp/language/value category|lvalue expression]].

===Requirements===
The type {{tt|T}} satisfies {{named req/core|CopyConstructible}} if

* The type {{tt|T}} satisfies {{named req|MoveConstructible}}, and

Given
* {{c|v}}, an [[cpp/language/value_category#lvalue|lvalue]] expression of type {{tt|T}} or {{c/core|const T}} or an [[cpp/language/value category#rvalue|rvalue]] expression of type {{c/core|const T}},
* {{c|u}}, an arbitrary identifier.

The following expressions must be valid and have their specified effects:
{|table class=wikitable
|-
!Expression||Post-conditions
|-
|{{c|1=T u = v;}}
|The value of {{c|u}} is equivalent to the value of {{c|v}}.
The value of {{c|v}} is unchanged.
|-
|{{c|T(v)}}
|The value of {{c|T(v)}} is equivalent to the value of {{c|v}}.
The value of {{c|v}} is unchanged.
|}

{{rev begin}}
{{rev|until=c++11|
The expression {{c|v.~T()}} also must be valid, and, for lvalue {{c|v}}, the expression {{c|&amp;v}} must have the type {{tt|T*}} or {{c/core|const T*}} and must evaluate to the address of {{c|v}}.
}}
{{rev end}}

===Notes===
Until C++11, classes that overloaded {{c/core|operator&amp;}} were not {{named req/core|CopyConstructible}} and thus were not usable in the [[cpp/container|standard library containers]]. This is a design decision in C++98 (instead of a defect, see {{lwg|390}}).

Since C++11, the standard library uses {{lc|std::addressof}} whenever the address of an object is needed.

{{cot}}

Being a {{named req/core|CopyConstructible}} class implies {{lc|std::is_copy_constructible}} but not vice versa since {{lc|std::is_copy_constructible}} will only check for the ability to call the constructor with the correct arguments, and, e.g., not a {{named req|MoveConstructible}} requirement.

{{example
|code=
#include &lt;type_traits&gt;
#include &lt;utility&gt;

struct S
{
    S() = default;
    S(S&amp;&amp;) = delete;
    S(const S&amp;) = default;
};
static_assert(std::is_copy_constructible_v&lt;S&gt;);

int main()
{
    S s1;

    // Class `S` doesn't satisfy MoveConstructible requirement,
    // hence doesn't satisfy CopyConstructible requirement
    [[maybe_unused]] S s2{std::move(s1)}; // ill-formed, use of deleted function
}
}}
{{cob}}

===References===
{{cot}}
{{ref std c++23}}
{{ref std|section=16.4.4.2|title=Template argument requirements|id=utility.arg.requirements}}
{{ref std end}}
{{cob}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_copy_constructible}}
{{dsc inc|cpp/concepts/dsc copy_constructible}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}