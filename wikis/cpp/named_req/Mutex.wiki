{{cpp/named req/title|Mutex|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}

The {{named req|Mutex}} requirements extends the {{named req|Lockable}} requirements to include inter-thread synchronization.

===Requirements===
* {{named req|Lockable}}
* {{named req|DefaultConstructible}}
* {{named req|Destructible}}
* not copyable
* not movable

For an object {{ttb|m}} of {{named req/core|Mutex}} type:
* The expression {{c|m.lock()}} has the following properties
:* Behaves as an atomic operation.
:* Blocks the calling thread until exclusive ownership of the mutex can be obtained.
:* Prior {{c|m.unlock()}} operations on the same mutex ''synchronize-with'' this lock operation (equivalent to release-acquire {{lc|std::memory_order}}).
:* The behavior is undefined if the calling thread already owns the mutex (except if m is {{lc|std::recursive_mutex}} or {{lc|std::recursive_timed_mutex}}).
:* Exception of type {{lc|std::system_error}} may be thrown on errors, with the following error codes:
::* {{lc|std::errc::operation_not_permitted}} if the calling thread does not have required privileges.
::* {{lc|std::errc::resource_deadlock_would_occur}} if the implementation detects that this operation would lead to deadlock.
* The expression {{c|m.try_lock()}} has the following properties
:* Behaves as an atomic operation.
:* Attempts to obtain exclusive ownership of the mutex for the calling thread without blocking. If ownership is not obtained, returns immediately. The function is allowed to spuriously fail and return even if the mutex is not currently owned by another thread.
:* If {{tt|try_lock()}} succeeds, prior {{tt|unlock()}} operations on the same object ''synchronize-with'' this operation (equivalent to release-acquire {{lc|std::memory_order}}). {{tt|lock()}} does not synchronize with a failed {{tt|try_lock()}}.
:* Does not throw exceptions.
* The expression {{c|m.unlock()}} has the following properties
:* Behaves as an atomic operation.
:* Releases the calling thread's ownership of the mutex and ''synchronizes-with'' the subsequent successful lock operations on the same object.
:* The behavior is undefined if the calling thread does not own the mutex.
:* Does not throw exceptions.
* All lock and unlock operations on a single mutex occur in a single total order that can be viewed as [[cpp/atomic/memory_order#Modification_order|modification order]] of an atomic variable: the order is specific to this individual mutex.

===Standard library===
The following standard library types satisfy {{named req/core|Mutex}} requirements:
{{dsc begin}}
{{dsc inc|cpp/thread/dsc mutex}}
{{dsc inc|cpp/thread/dsc recursive_mutex}}
{{dsc inc|cpp/thread/dsc recursive_timed_mutex}}
{{dsc inc|cpp/thread/dsc shared_mutex}}
{{dsc inc|cpp/thread/dsc shared_timed_mutex}}
{{dsc inc|cpp/thread/dsc timed_mutex}}
{{dsc end}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2309|std=C++11|before={{tt|lock}} might throw {{lc|std::system_error}}&lt;br&gt;with error code {{lc|std::errc::device_or_resource_busy}}|after=not allowed}}
{{dr list end}}

===See also===
* [[cpp/thread|Thread support library]]
* {{named req|Lockable}}
* {{named req|TimedMutex}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}