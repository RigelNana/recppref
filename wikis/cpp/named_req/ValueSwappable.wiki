{{cpp/named req/title|ValueSwappable|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}
Two objects of this type can be dereferenced and the resulting values can be swapped using unqualified function call {{c|swap()}} in the context where both {{lc|std::swap}} and the user-defined {{c|swap()}}s are visible.

===Requirements===
A type T is {{named req/core|ValueSwappable}} if

# {{tt|T}} satisfies the {{named req|Iterator}} requirements.
# For any dereferenceable object {{tt|x}} of type {{tt|T}} (that is, any value other than the end iterator), {{tt|*x}} satisfies the {{named req|Swappable}} requirements.

Many standard library functions expect their arguments to satisfy {{named req/core|ValueSwappable}}, which means that any time the standard library performs a swap, it uses the equivalent of {{c|using std::swap; swap(*iter1, *iter2);}}.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;vector&gt;

class IntVector
{
    std::vector&lt;int&gt; v;
//  IntVector&amp; operator=(IntVector); // not assignable (C++98 way)
public:
    IntVector&amp; operator=(IntVector) = delete; // not assignable
    void swap(IntVector&amp; other)
    {
        v.swap(other.v);
    }
};

void swap(IntVector&amp; v1, IntVector&amp; v2)
{
    v1.swap(v2);
}

int main()
{
    IntVector v1, v2;    // IntVector is Swappable, but not MoveAssignable
    IntVector* p1 = &amp;v1;
    IntVector* p2 = &amp;v2; // IntVector* is ValueSwappable
    std::iter_swap(p1, p2); // OK: iter_swap requires ValueSwappable
//  std::swap(v1, v2); // compiler error! std::swap requires MoveAssignable
}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc indirectly_swappable}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}