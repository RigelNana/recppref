{{cpp/named req/title|MoveInsertable|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}

Specifies that an object of the type can be constructed into uninitialized storage from an rvalue of that type by a given allocator.

===Requirements===
Given the following types, values and expressions:
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|T}}|an object type}}
{{dsc|{{tt|A}}|an allocator type}}
{{dsc|{{tt|X}}|a container type satisfying all following conditions:
* {{tt|X::value_type}} is the same as {{tt|T}}.
* {{tt|X::allocator_type}} is the same as {{c/core|std::allocator_traits&lt;A&gt;::rebind_alloc&lt;T&gt;}}.
}}
{{dsc hitem|Value|Definition}}
{{dsc|{{c|m}}|an lvalue of type {{tt|A}}}}
{{dsc|{{c|p}}|a pointer of type {{tt|T*}}}}
{{dsc hitem|Expression|Definition}}
{{dsc|{{c|rv}}|an expression denoting an rvalue of type {{tt|T}}}}
{{dsc|{{c|expr}}|{{c|std::allocator_traits&lt;A&gt;::construct(m, p, rv)}}}}
{{dsc end}}

{{tt|T}} is {{named req/core|MoveInsertable}} into {{tt|X}} if all following conditions are satisfied:
* {{c|expr}} is well-formed.
* Right after the evaluation of {{c|expr}}, the value of {{c|*p}} is equivalent to the value of {{c|rv}} before the evaluation.

===Notes===
If {{tt|A}} is {{c/core|std::allocator&lt;T&gt;}}, then this will call placement {{c/core|new}}, as by {{rev inl|until=c++20|{{c|::new((void*)p) T(rv)}}}}{{rev inl|since=c++20|{{c|std::construct_at(p, rv)}}}}. This effectively requires {{tt|T}} to be move constructible.

If {{c/core|std::allocator&lt;T&gt;}} or a similar allocator is used, a class does not have to implement a {{lt|cpp/language/move constructor}} to satisfy this type requirement: a {{lt|cpp/language/copy constructor}} that takes a {{c/core|const T&amp;}} argument can bind rvalue expressions. If a {{named req/core|MoveInsertable}} class implements a move constructor, it may also implement [[cpp/utility/move|move semantics]] to take advantage of the fact that the value of {{tt|rv}} after construction is unspecified.

Although it is required that customized {{tt|construct}} is used when constructing elements of {{lc|std::basic_string}} until C++23, all implementations only used the default mechanism. The requirement is corrected by {{wg21|P1072R10}} to match existing practice.

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2177|std=C++11|before=evaluting {{c|expr}} did not have any postcondition|after=added}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc|{{named req|CopyInsertable}}}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}