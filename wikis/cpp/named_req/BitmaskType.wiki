{{cpp/named req/title|BitmaskType}}
{{cpp/named req/navbar}}

Defines a type that can be used to represent a set of constant values or any combination of those values. This trait is typically implemented by integer types, {{lc|std::bitset}}, or enumerations (scoped and unscoped) with additional operator overloads.

===Requirements===
The bitmask type supports a finite number of bitmask elements, which are distinct non-zero values of the bitmask type, such that, for any pair {{c|Ci}} and {{c|Cj}}, {{c|Ci &amp; Ci}} is nonzero and {{c|1=Ci &amp; Cj}} is zero. In addition, the value {{c|0}} is used to represent an empty bitmask, with no values set.

The bitwise operators {{c|operator&amp;}}, {{c|operator{{!}}}}, {{c|operator^}}, {{c|operator~}}, {{c|1=operator&amp;=}}, {{c|1=operator{{!}}=}}, and {{c|1=operator^=}} are defined for values of the bitmask type and have the same semantics as the corresponding built-in operators on unsigned integers would have if the bitmask elements were the distinct integer powers of two.

The following expressions are well-formed and have the following meaning for any {{named req/core|BitmaskType}}:

{{dsc begin}}
{{dsc|{{c|1=X {{!}}= Y}}|sets the value {{tt|Y}} in the object {{tt|X}}}}
{{dsc|{{c|1=X &amp;= ~Y}}|clears the value {{tt|Y}} in the object {{tt|X}}}}
{{dsc|{{c|X &amp; Y}}|nonzero result indicates that the value {{tt|Y}} is set in the object {{tt|X}}}}
{{dsc end}}

Each representable bitmask element is defined as a{{rev inl|since=c++17|n {{c/core|inline}}}} {{c/core|constexpr}} value of the bitmask type.

===Standard library===
The following standard library types satisfy {{named req/core|BitmaskType}}:
{{rrev|since=c++17|
* {{ltt|cpp/utility/chars_format|std::chars_format}}}}
* {{lc|std::ctype_base::mask}}
* {{lc|std::ios_base::fmtflags}}
* {{lc|std::ios_base::iostate}}
* {{lc|std::ios_base::openmode}}
{{rrev|since=c++11|
* {{ltt|cpp/regex/regex_traits#Member_types|std::regex_traits::char_class_type}}}}
{{rrev|since=c++11|
* {{lc|std::regex_constants::syntax_option_type}}}}
{{rrev|since=c++11|
* {{lc|std::regex_constants::match_flag_type}}}}
{{rrev|since=c++11|
* {{lc|std::launch}}}}
{{rrev|since=c++17|
* {{lc|std::filesystem::perms}}}}
{{rrev|since=c++17|
* {{ltt|cpp/filesystem/perm_options|std::filesystem::perm_options|std::filesystem::perm_options}}}}
{{rrev|since=c++17|
* {{lc|std::filesystem::copy_options}}}}
{{rrev|since=c++17|
* {{lc|std::filesystem::directory_options}}}}

Code that relies on some particular implementation option (e.g. {{c|1=int n = std::ios_base::hex}}) is non-portable because {{lc|std::ios_base::fmtflags}} is not necessarily implicitly convertible to {{c/core|int}}.

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}