{{cpp/named req/title|Container}}
{{cpp/named req/navbar}}

A {{named req/core|Container}} is an object used to store other objects and taking care of the management of the memory used by the objects it contains.

===Requirements===
Given the following types and values:
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|T}}|an object type}}
{{dsc|{{tt|C}}|a container class containing objects of type {{tt|T}}}}
{{dsc hitem|Value|Definition}}
{{dsc|{{c|u}}, {{c|v}}|values of type {{tt|C}} or {{c/core|const C}}}}
{{dsc|{{c|mv}}|a value of type {{tt|C}}}}
{{dsc|{{c|cv}}|a value of type {{c/core|const C}}}}
{{dsc|{{c|lhs}}, {{c|rhs}}|lvalues of type {{tt|C}}}}
{{dsc|{{c|i}}, {{c|j}}|values of type {{tt|C::iterator}} or {{c/core|const C::iterator}}}}
{{dsc end}}

{{tt|C}} satisfies the requirements of {{named req/core|Container}} if the following types, statements, and expressions are well-formed and have the specified semantics:

====Types====
{|class="wikitable"
!Type
!Definition
!Requirements
|-
|{{c/core|typename C::value_type}}
|{{tt|T}}
|{{tt|T}} is {{rev inl|until=c++11|{{named req|CopyConstructible}}}}{{rev inl|since=c++11|{{named req|Erasable}} from {{tt|C}}}}.
|-
|{{c/core|typename C::reference}}
|{{tt|T&amp;}}
|rowspan=2 {{n/a|No explicit requirement}}
|-
|{{c/core|typename C::const_reference}}
|{{c/core|const T&amp;}}
|-
|{{c/core|typename C::iterator}}
|an iterator type
|
* {{tt|C::iterator}} is a {{named req|ForwardIterator}}, and its [[cpp/iterator#Types and writability|value type]] is {{tt|T}}.
* {{tt|C::iterator}} is convertible to {{tt|C::const_iterator}}.
|-
|{{c/core|typename C::const_iterator}}
|a constant iterator type
|{{tt|C::const_iterator}} is a {{named req|ForwardIterator}}, and its [[cpp/iterator#Types and writability|value type]] is {{tt|T}}.
|-
|{{c/core|typename C::difference_type}}
|a signed integer type
|{{tt|C::difference_type}} is the same as the [[cpp/iterator#Types and writability|difference type]] of {{tt|C::iterator}} and {{tt|C::const_iterator}}.
|-
|{{c/core|typename C::size_type}}
|an unsigned integer type
|{{tt|C::size_type}} is large enough to represent all non-negative values of {{tt|C::difference_type}}.
|}

====Statements====
{|class="wikitable"
!Statement
!colspan=2|Semantics
!{{nbsp}}Complexity{{nbsp}}
|-
|{{c|C c;}}

{{c|1=C c = C();}}
|Postcondition{{nbsp}}
|{{c|c.empty()}} is {{c|true}}.
|constant
|-
|rowspan=2|{{c|C c(v);}}

{{c|1=C c = C(v);}}
|Precondition
|{{rrev|since=c++11|If {{c|v}} is not an rvalue of type {{tt|C}}, {{tt|T}} is {{named req|CopyInsertable}} into {{tt|C}}.}}
|rowspan=2|linear&lt;ref&gt;If {{c|v}} is an rvalue of type {{tt|C}}, and {{tt|C}} is not a specialization of {{lc|std::array}} or {{ltt std|cpp/container/inplace_vector}}, the complexity is constant.&lt;/ref&gt;
|-
|Postcondition
|
* If {{c|v}} is an lvalue, {{c|1=c == v}} is {{c|true}}.
* If {{c|v}} is an rvalue{{rev inl|since=c++11|, and {{c|c}} and {{c|v}} do not refer to the same object}}, {{c|c}} is equal to the value that {{c|v}} had before this construction.
|-
!colspan=4|Notes
|-
|colspan=4|&lt;references/&gt;
|}

====Expressions====
&lt;div style="max-height: 80vh; overflow-y: scroll;"&gt;
{|class="wikitable"
!Expression
!Type
!colspan=2 style="min-width: 480px;"|Semantics
!{{nbsp}}Complexity{{nbsp}}
|-
|{{c|C()}}
|{{tt|C}}
|Postcondition{{nbsp}}
|{{c|C().empty()}} is {{c|true}}.
|constant
|-
|rowspan=2|{{c|C(v)}}
|rowspan=2|{{tt|C}}
|Precondition
|{{rrev|since=c++11|If {{c|v}} is not an rvalue of type {{tt|C}}, {{tt|T}} is {{named req|CopyInsertable}} into {{tt|C}}.}}
|rowspan=2|constant&lt;ref&gt;If {{c|v}} is an rvalue of type {{tt|C}}, and {{tt|C}} is a specialization of {{lc|std::array}} or {{ltt std|cpp/container/inplace_vector}}, the complexity is linear.&lt;/ref&gt;
|-
|Postcondition
|
* If {{c|v}} is an lvalue, {{c|1=C(v) == v}} is {{c|true}}.
* If {{c|v}} is an rvalue{{rev inl|since=c++11|, and {{c|C(v)}} and {{c|v}} do not refer to the same object}}, {{c|C(v)}} is equal to the value that {{c|v}} had before this construction.
|-
|{{c|1=lhs = v}}
|{{tt|C&amp;}}
|Postcondition
|
* If {{c|v}} is an lvalue, {{c|1=lhs == v}} is {{c|true}}.
* If {{c|v}} is an rvalue{{rev inl|since=c++11|, and {{c|lv}} and {{c|v}} do not refer to the same object}}, {{c|lhs}} is equal to the value that {{c|v}} had before this assignment.
|linear
|-
|{{c|v.~C()}}
|{{c/core|void}}
|Effect
|Destroys all elements of {{c|v}} and deallocates all memory obtained.
|linear
|-
|{{c|mv.begin()}}
|{{tt|C::iterator}}
|Effect
|Returns an iterator pointing to the first element of {{c|mv}}.
|constant
|-
|{{c|cv.begin()}}
|{{tt|C::const_iterator}}
|Effect
|Returns an iterator pointing to the first element of {{c|cv}}.
|constant
|-
|{{c|mv.end()}}
|{{tt|C::iterator}}
|Effect
|Returns the past-the-end iterator of {{c|mv}}.
|constant
|-
|{{c|cv.end()}}
|{{tt|C::const_iterator}}
|Effect
|Returns the past-the-end iterator of {{c|cv}}.
|constant
|-
|{{c|v.cbegin()}}&lt;br&gt;{{mark since c++11}}
|{{tt|C::const_iterator}}
|Effect
|Returns {{c|const_cast&lt;const C&amp;&gt;(v).begin()}}.
|constant
|-
|{{c|v.cend()}}&lt;br&gt;{{mark since c++11}}
|{{tt|C::const_iterator}}
|Effect
|Returns {{c|const_cast&lt;const C&amp;&gt;(v).end()}}.
|constant
|-
|{{c|1=i &lt;=&gt; j}}&lt;br&gt;{{mark since c++20}}
|{{ltt std|cpp/utility/compare/strong_ordering}}{{nbsp|4}}
|Constraint
|This expression is only required to be well-formed if {{tt|C::iterator}} satisfies the random access iterator requirements.
|constant
|-
|{{c|1=u == v}}
|{{c/core|bool}}
|Effect
|Returns {{rev begin}}
{{rev|until=c++14|{{c multi|u.size() {{==}} v.size() &amp;&amp;|    std::equal(u.begin(),|         u.end(), v.begin())}}}}
{{rev|since=c++14|{{c multi|std::equal(u.begin(), u.end(),|           v.begin(), v.end())}}}}
{{rev end}}.
|linear&lt;ref&gt;If {{c|1=u.size() != v.size()}} is {{c|true}}, the complexity is constant.&lt;/ref&gt;
|-
|{{c|1=u != v}}
|
|Effect
|Equivalent to {{c|1=!(u == v)}}.
|-
|{{c|lhs.swap(rhs)}}

{{c|swap(lhs, rhs)}}
|{{c/core|void}}
|Effect
|Exchanges the contents of {{c|lhs}} and {{c|rhs}}.
|constant&lt;ref&gt;If {{tt|C}} is a specialization of {{lc|std::array}} or {{ltt std|cpp/container/inplace_vector}}, the complexity is linear.&lt;/ref&gt;
|-
|{{c|v.size()}}
|{{tt|C::size_type}}
|Effect
|Returns the number of elements&lt;ref&gt;The number of elements is defined by the rules of constructors, inserts, and erases. It is equal to the value of {{c|std::distance(v.begin(), v.end())}}.&lt;/ref&gt; of {{c|v}}.
|constant
|-
|{{c|v.max_size()}}
|{{tt|C::size_type}}
|Effect
|Returns the number of elements of the largest possible container of type {{tt|C}}.
|constant
|-
|{{c|v.empty()}}
|{{c/core|bool}}
|Effect
|Returns {{c|1=v.begin() == v.end()}}.
|constant
|-
!colspan=5|Optional container requirements{{anchor|Optional container requirements}}&lt;br&gt;{{normal|{{small|(only provided for some types of containers)}}}}
|-
|rowspan=2|{{c|1=u &lt;=&gt; v}}&lt;br&gt;{{mark since c++20}}
|rowspan=2|{{lti|cpp/standard library/synth-three-way|synth-three-way-result}}&lt;br&gt;{{nbspt|4}}{{c/core|&lt;C::value_type&gt;}}
|Precondition
|Either {{tt|T}} models {{lconcept|three_way_comparable}}, or {{c/core|operator&lt;}} is a total ordering relationship defined for values of type {{tt|T}} and {{c/core|const T}}.
|rowspan=2|linear
|-
|Effect
|Returns {{box|{{c/core|std::lexicographical_compare_three_way}}&lt;br&gt;{{nbspt|4}}{{c/core|(u.begin(), u.end(),}}&lt;br&gt;{{nbspt|5}}{{c/core|v.begin(), v.end(),}}&lt;br&gt;{{nbspt|5}}{{lti|cpp/standard library/synth-three-way}}{{sep}}{{c/core|)}}}}&lt;ref&gt;If the iterators passed to {{lc|std::lexicographical_compare_three_way}} are {{named req|ConstexprIterator}}s, the operation is implemented by {{c/core|constexpr}} functions.&lt;/ref&gt;.
|-
!colspan=5|Notes
|-
|colspan=5|&lt;references/&gt;
|}
&lt;/div&gt;

In the expressions {{c|1=i == j}}, {{c|1=i != j}}, {{c|i &lt; j}}, {{c|1=i &lt;= j}}, {{c|1=i &gt;= j}}, {{c|i &gt; j}} and {{c|i - j}}, if {{c|i}} and/or {{c|j}} are replaced by iterators of type {{tt|C::const_iterator}} pointing to the same element respectively, the semantics remain the same.

===Container data races===
See [[cpp/container#Thread safety|container thread safety]].

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=179|std=C++98|before={{tt|iterator}} and {{tt|const_iterator}} types might be incomparable|after=required to be comparable}}
{{dr list item|wg=lwg|dr=276|std=C++98|before={{tt|T}} was required to be {{named req|CopyAssignable}}|after={{tt|T}} is required to be&lt;br&gt;{{named req|CopyConstructible}}}}
{{dr list item|wg=lwg|dr=322|std=C++98|before=the value types of {{tt|iterator}} and {{tt|const_iterator}} were not specified|after=specified as {{tt|T}}}}
{{dr list item|wg=lwg|dr=774|std=C++98|before=there was no requirement on {{c|swap(a, b)}}|after=added}}
{{dr list item|wg=lwg|dr=883|std=C++98|before={{c|a.swap(b)}} was defined as {{c|swap(a, b)}},&lt;br&gt;resulted in circular definition|after=defined as exchanging&lt;br&gt;the values of {{c|a}} and {{c|b}}}}
{{dr list item|wg=lwg|dr=1319|std=C++98|before={{tt|iterator}} and {{tt|const_iterator}}&lt;br&gt;might not have multipass guarantee|after=they are required to satisfy&lt;br&gt;the requirements of&lt;br&gt;{{named req|ForwardIterator}}}}
{{dr list item|wg=lwg|dr=2114|paper=P2167R3|std=C++98|before=non-{{c/core|bool}} return types of some functions were allowed|after=disallowed}}
{{dr list item|wg=lwg|dr=2182|std=C++98|before=the types deonted by {{tt|reference}} and&lt;br&gt;{{tt|const_reference}} were poorly specified|after=improved wording}}
{{dr list item|wg=lwg|dr=2257|std=C++98|before=two containers required linear time to compare&lt;br&gt;equal even if they have different sizes|after=only requires constant&lt;br&gt;time in this case}}
{{dr list item|wg=lwg|dr=2263|std=C++11|before=the resolution of {{lwg|179}} was accidentally dropped in C++11|after=restored}}
{{dr list item|wg=lwg|dr=2839|std=C++11|before=self move assignment of standard containers was not allowed|after=allowed but the&lt;br&gt;result is unspecified}}
{{dr list item|paper=N3346|std=C++11|before={{tt|C::value_type}} was required to be {{named req|Destructible}}|after=required to be {{named req|Erasable}} from {{tt|C}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc see cpp|cpp/container|Containers library|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}