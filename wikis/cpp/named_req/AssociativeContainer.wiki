{{cpp/named req/title|AssociativeContainer}}
{{cpp/named req/navbar}}

An {{named req|AssociativeContainer}} is an ordered {{named req|Container}} that provides fast lookup of objects based on keys.

An associative container supports ''unique keys'' if it may contain at most one element for each key. Otherwise, it supports ''equivalent keys''.

===Requirements===
{{dsc begin}}
{{dsc h2|Legend}}
{{dsc|{{tt|X}}|An associative container class}}
{{dsc|{{tt|T}}|The element type of {{tt|X}}}}
{{dsc|{{tt|A}}|The allocator type of {{tt|X}}: {{tt|X::allocator_type}} if it exists, otherwise {{c/core|std::allocator&lt;X::value_type&gt;}}}}
{{dsc|{{c|a}}|A value of type {{tt|X}}}}
{{dsc|{{c|a2}}|A value of a type {{tt|Y}} whose [[cpp/container/node handle|node handles]] are compatible with {{tt|X}}}}
{{dsc|{{c|b}}|A value of type {{tt|X}} or {{c/core|const X}}}}
{{dsc|{{c|u}}|A name of a variable beging declared}}
{{dsc|{{c|a_uniq}}|A value of type {{tt|X}} when {{tt|X}} supports unique keys}}
{{dsc|{{c|a_eq}}|A value of type {{tt|X}} when {{tt|X}} supports equivalent keys}}
{{dsc|{{c|a_tran}}|A value of type {{tt|X}} or {{c/core|const X}} when type {{tt|X::key_compare::is_transparent}} exists}}
{{dsc|{{c|i}}, {{c|j}}|The {{named req|InputIterator}}s referring to elements implicitly convertible to {{tt|X::value_type}}}}
{{dsc|{{range|i|j}}|A valid range}}
{{dsc|{{c|rg}}&lt;br&gt;{{mark since c++23}}|A value of a type {{tt|R}} that models {{lti|cpp/ranges/to#container compatible range|container-compatible-range}}{{tt|&lt;value_type&gt;}}}}
{{dsc|{{c|p}}|A valid constant iterator to {{c|a}}}}
{{dsc|{{c|q}}|A valid dereferenceable constant iterator to {{c|a}}}}
{{dsc|{{c|r}}|A valid dereferenceable iterator to {{c|a}}}}
{{dsc|{{c|q1}}, {{c|q2}}|A valid range of const iterators in {{c|a}}}}
{{dsc|{{c|il}}|An object of type {{c/core|std::initializer_list&lt;X::value_type&gt;}}}}
{{dsc|{{c|t}}|A value of type {{tt|X::value_type}}}}
{{dsc|{{c|k}}|A value of type {{tt|X::key_type}}}}
{{dsc|{{c|c}}|A value of type {{tt|X::key_compare}} or {{c/core|const X::key_compare}}}}
{{dsc|{{c|kl}}|A value such that {{c|a}} is partitioned with respect to {{c|c(x, kl)}}, with {{c|x}} the key value of {{c|e}} and {{c|e}} in {{c|a}}}}
{{dsc|{{c|ku}}|A value such that {{c|a}} is partitioned with respect to {{c|!c(ku, x)}}, with {{c|x}} the key value of {{c|e}} and {{c|e}} in {{c|a}}}}
{{dsc|{{c|ke}}|A value such that {{c|a}} is partitioned with respect to {{c|c(x, ke)}} and {{c|!c(ke, x)}}, with {{c|c(x, ke)}} implying {{c|!c(ke, x)}} and with {{c|x}} the key value of {{c|e}} and {{c|e}} in {{c|a}}}}
{{dsc|{{c|kx}}&lt;br&gt;{{mark since c++23}}|A value such that:
* {{c|a}} is partitioned with respect to {{c|c(x, kx)}} and {{c|!c(kx, x)}}, with {{c|c(x, kx)}} implying {{c|!c(kx, x)}} and with {{c|x}} the key value of {{c|e}} and {{c|e}} in {{c|a}}, and
* {{c|kx}} is not convertible to either {{tt|X::iterator}} or {{tt|X::const_iterator}}}}
{{dsc|{{c|m}}|An allocator of a type convertible to {{tt|A}}}}
{{dsc|{{c|nh}}|A non-const rvalue of type {{tt|X::node_type}}}}&lt;!--NB: 'nh' is used in the table below (see N4950, e.g., § 24.2.7.1-84, p.893); it was accidentally dropped out of N4950 (C++23 final draft), but present in IS-C++20 text and should be restored in IS-C++23!--&gt;
{{dsc end}}

The type {{tt|X}} satisfies {{named req/core|AssociativeContainer}} if
* The type {{tt|X}} satisfies {{rev inl|until=c++11|{{named req|Container}}}}{{rev inl|since=c++11|{{named req|AllocatorAwareContainer}}}},
* Is parameterized on {{tt|Key}} and an ordering relation {{tt|Compare}} that induces a {{rlp|Compare|strict weak ordering}} on elements of {{tt|Key}}, and
** In addition, {{lc|std::map}} and {{lc|std::multimap}} associate an arbitrary ''mapped type'' {{tt|T}} with the {{tt|Key}}.
** The object of type {{tt|Compare}} is called the ''comparison object'' of a container of type {{tt|X}}.
* The following expressions must be valid and have their specified effects for all associative containers:

====Types====
{|class=wikitable 
!Name||Type||Requirements
|-
|{{tt|key_type}}
|{{tt|Key}}
|
|-
|{{tt|mapped_type}}
|{{tt|T}} (for {{lc|std::map}} and {{lc|std::multimap}} only)
|
|-
|{{tt|value_type}}
|
*{{tt|Key}} (for {{lc|std::set}} and {{lc|std::multiset}} only)
* {{c/core|std::pair&lt;const Key, T&gt;}}(for {{lc|std::map}} and {{lc|std::multimap}} only)

|{{named req|Erasable}} from {{tt|X}}
|-
|{{tt|key_compare}}
|{{tt|Compare}}
|{{named req|CopyConstructible}}
|-
|{{tt|value_compare}}
|
* same as {{tt|key_compare}} (for {{lc|std::set}} and {{lc|std::multiset}})
* an ordering relation on pairs induced by the first component (i.e. {{tt|Key}}) (for {{lc|std::map}} and {{lc|std::multimap}})

|{{named req|BinaryPredicate}}
|-
|{{tt|node_type}}
|A specialization of the [[cpp/container/node handle|node-handle class template]], such that the public nested types are the same types as the corresponding types in {{tt|X}}.
|
|}

====Member functions and operators====
&lt;div style="max-width: 100%; max-height: 90vh; overflow: scroll;"&gt;
{|class=wikitable style="font-size:0.9em"
!Expression||Result||Preconditions||Effects||Returns||Complexity
|-
|{{c|X(c)}}
|
|
|Constructs an empty container. Uses a copy of {{c|c}} as a comparison object
|
|Constant
|-
|{{c|1=X u = X();}}&lt;br&gt;{{c|X u;}}
|
|{{tt|key_compare}} meets the {{named req|DefaultConstructible}} requirements
|Constructs an empty container. Uses {{c|Compare()}} as a comparison object
|
|Constant
|-
|{{c|X(i, j, c)}}
|
|{{tt|value_type}} is {{named req|EmplaceConstructible}} into {{tt|X}} from {{c|*i}}
|Constructs an empty container and inserts elements from the range {{range|i|j}} into it; uses {{c|c}} as a comparison object
|
|rowspan="2"|{{c|N·log(N)}} in general, where {{tt|N}} has the value {{c|std::distance(i, j)}}; linear if {{range|i|j}} is sorted with respect to {{c|value_comp()}}
|-
|{{c|X(i, j)}}
|
|{{tt|key_compare}} meets the {{named req|DefaultConstructible}} requirements. {{tt|value_type}} is {{named req|EmplaceConstructible}} into {{tt|X}} from {{c|*i}}
|Constructs an empty container and inserts elements from the range {{range|i|j}} into it; uses {{c|Compare()}} as a comparison object
|
&lt;!--|{{c|N·log(N)}} in general, where {{tt|N}} has the value {{c|std::distance(i, j)}}; linear if {{range|i|j}} is sorted with respect to {{c|value_comp()}}--&gt;
|-
|{{c|X(from_range, rg, c)}}&lt;br&gt;{{mark since c++23}}
|
|{{tt|value_type}} is {{named req|EmplaceConstructible}} into {{tt|X}} from {{c|*ranges::begin(rg)}}
|Constructs an empty container and inserts each element from {{c|rg}} into it. Uses {{c|c}} as the comparison object
|
|rowspan="2"|{{c|N·log(N)}} in general, where {{tt|N}} has the value {{c|ranges::distance(rg)}}; linear if {{c|rg}} is sorted with respect to {{c|value_comp()}}
|-
|{{c|X(from_range, rg)}}&lt;br&gt;{{mark since c++23}}
|
|{{tt|key_compare}} meets the {{named req|DefaultConstructible}} requirements. {{tt|value_type}} is {{named req|EmplaceConstructible}} into {{tt|X}} from {{c|*ranges::begin(rg)}}
|Constructs an empty container and inserts each element from {{c|rg}} into it. Uses {{c|Compare()}} as the comparison object
|
&lt;!--|Same as {{c|X(std::from_range, rg, c)}}--&gt;
|-
|{{c|X(il, c)}}
|
|
|{{c|X(il.begin(), il.end(), c)}}
|
|
|-
|{{c|X(il)}}
|
|
|{{c|X(il.begin(), il.end())}}
|
|
|-
|{{c|1=a = il}}
|{{c|X&amp;}}
|{{tt|value_type}} is {{named req|CopyInsertable}} into {{tt|X}} and {{named req|CopyAssignable}}
|Assigns the range {{range|il.begin()|il.end()}} into {{c|a}}. All existing elements of {{c|a}} are either assigned to or destroyed
|
|{{c|N·log(N)}} in general, where {{tt|N}} has the value {{c|il.size() + a.size()}}; linear if {{range|il.begin()|il.end()}} is sorted with respect to {{c|value_comp()}}
|-
|{{c|b.key_comp()}}
|{{tt|X::key_compare}}
|
|
|The comparison object out of which {{c|b}} was constructed
|Constant
|-
|{{c|b.value_comp()}}
|{{tt|X::value_compare}}
|
|
|An object of {{tt|value_compare}} constructed out of the comparison object
|Constant
|-
|{{c|a_uniq.emplace(args)}}
|{{c multi
|std::pair&lt;
|  iterator,
|  bool&gt;
}}
|{{tt|value_type}} is {{named req|EmplaceConstructible}} into {{tt|X}} from {{c|args}}
|Inserts a {{tt|value_type}} object {{c|t}} constructed with {{c|std::forward&lt;Args&gt;(args)...}} if and only if there is no element in the container with key equivalent to the key of {{c|t}}
|The {{c/core|bool}} component of the returned pair is {{c|true}} if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of {{c|t}}
|Logarithmic
|-
|{{c|a_eq.emplace(args)}}
|{{tt|iterator}}
|{{tt|value_type}} is {{named req|EmplaceConstructible}} into {{tt|X}} from {{c|args}}
|Inserts a {{tt|value_type}} object {{c|t}} constructed with {{c|std::forward&lt;Args&gt;(args)...}}. If a range containing elements equivalent to {{c|t}} exists in {{c|a_eq}}, {{c|t}} is inserted at the end of that range
|An iterator pointing to the newly inserted element
|Logarithmic
|-
|{{c|a.emplace_hint(p, args)}}
|{{tt|iterator}}
|
|Equivalent to
{{c multi
|a.emplace(
|  std::forward&lt;Args&gt;(args)...)
}},
except that the element is inserted as close as possible to the position just prior to {{c|p}}
|An iterator pointing to the element with the key equivalent to the newly inserted element
|Logarithmic in general, but amortized constant if the element is inserted right before {{c|p}}
|-
|{{c|a_uniq.insert(t)}}
|{{c multi
|std::pair&lt;
|  iterator,
|  bool&gt;
}}
|If {{c|t}} is a non-const rvalue, {{tt|value_type}} is {{named req|MoveInsertable}} into {{tt|X}}; otherwise, {{tt|value_type}} is {{named req|CopyInsertable}} into {{tt|X}}
|Inserts {{c|t}} if and only if there is no element in the container with key equivalent to the key of {{c|t}}
|The {{c/core|bool}} component of the returned pair is {{c|true}} if and only if the insertion takes place, and the {{tt|iterator}} component of the pair points to the element with key equivalent to the key of {{c|t}}
|Logarithmic
|-
|{{c|a_eq.insert(t)}}
|{{tt|iterator}}
|If {{c|t}} is a non-const rvalue, {{tt|value_type}} is {{named req|MoveInsertable}} into {{tt|X}}; otherwise, {{tt|value_type}} is {{named req|CopyInsertable}} into {{tt|X}}
|Inserts {{c|t}} and returns the iterator pointing to the newly inserted element. If a range containing elements equivalent to {{c|t}} exists in {{c|a_eq}}, {{c|t}} is inserted at the end of that range
|
|Logarithmic
|-
|{{c|a.insert(p, t)}}
|{{tt|iterator}}
|If {{c|t}} is a non-const rvalue, {{tt|value_type}} is {{named req|MoveInsertable}} into {{tt|X}}; otherwise, {{tt|value_type}} is {{named req|CopyInsertable}} into {{tt|X}}
|Inserts {{c|t}} if and only if there is no element with key equivalent to the key of {{c|t}} in containers with unique keys; always inserts {{c|t}} in containers with equivalent keys. {{c|t}} is inserted as close as possible to the position just prior to {{c|p}}
|An iterator pointing to the element with key equivalent to the key of {{c|t}}
|Logarithmic in general, but amortized constant if {{c|t}} is inserted right before {{c|p}}
|-
|{{c|a.insert(i, j)}}
|{{c/core|void}}
|{{tt|value_type}} is {{named req|EmplaceConstructible}} into {{tt|X}} from {{c|*i}}. Neither {{c|i}} nor {{c|j}} are iterators into {{c|a}}
|Inserts each element from the range {{range|i|j}} if and only if there is no element with key equivalent to the key of that element in containers with unique keys; always inserts that element in containers with equivalent keys
|
|{{c|N·log(a.size() + N)}}, where {{tt|N}} has the value {{c|std::distance(i, j)}}
|-
|{{c|a.insert_range(rg)}}&lt;br&gt;{{mark since c++23}}
|{{c/core|void}}
|{{tt|value_type}} is {{named req|EmplaceConstructible}} into {{tt|X}} from {{c|*ranges::begin(rg)}}. {{c|rg}} and {{c|a}} do not overlap
|Inserts each element from {{c|rg}} if and only if there is no element with key equivalent to the key of that element in containers with unique keys; always inserts that element in containers with equivalent keys
|
|{{c|N·log(a.size() + N)}}, where {{tt|N}} has the value {{c|ranges::distance(rg)}}
|-
|{{c|a.insert(il)}}
|
|
|{{c|a.insert(il.begin(), il.end())}}
|
|
|-
|{{c|a_uniq.insert(nh)}}
|{{tt|insert_return_type}}
|{{c|nh}} is empty or
{{c multi
|a_uniq.get_allocator()
|{{==}}
|nh.get_allocator()
}}
is {{c|true}}
|If {{c|nh}} is empty, has no effect. Otherwise, inserts the element owned by {{c|nh}} if and only if there is no element in the container with a key equivalent to {{c|nh.key()}}
|If {{c|nh}} is empty, {{tt|inserted}} is {{c|false}}, {{tt|position}} is {{c|end()}}, and {{tt|node}} is empty. Otherwise if the insertion took place, {{tt|inserted}} is {{c|true}}, {{tt|position}} points to the inserted element, and {{tt|node}} is empty; if the insertion failed, {{tt|inserted}} is {{c|false}}, {{tt|node}} has the previous value of {{c|nh}}, and {{tt|position}} points to an element with a key equivalent to {{c|nh.key()}}
|Logarithmic
|-
|{{c|a_eq.insert(nh)}}
|{{tt|iterator}}
|{{c|nh}} is empty or
{{c multi
|a_eq.get_allocator()
|{{==}}
|nh.get_allocator()
}}
is {{c|true}}
|If {{c|nh}} is empty, has no effect and returns {{c|a_eq.end()}}. Otherwise, inserts the element owned by {{c|nh}} and returns an iterator pointing to the newly inserted element. If a range containing elements with keys equivalent to {{c|nh.key()}} exists in {{c|a_eq}}, the element is inserted at the end of that range. Ensures: {{c|nh}} is empty
|
|Logarithmic
|-
|{{c|a.insert(p, nh)}}
|{{tt|iterator}}
|{{c|nh}} is empty or
{{c multi
|a.get_allocator()
|{{==}}
|nh.get_allocator()
}}
is {{c|true}}
|If {{c|nh}} is empty, has no effect and returns {{c|a.end()}}. Otherwise, inserts the element owned by {{c|nh}} if and only if there is no element with key equivalent to {{c|nh.key()}} in containers with unique keys; always inserts the element owned by {{c|nh}} in containers with equivalent keys. The element is inserted as close as possible to the position just prior to {{c|p}}. Ensures: {{c|nh}} is empty if insertion succeeds, unchanged if insertion fails
|An iterator pointing to the element with key equivalent to {{c|nh.key()}}
|Logarithmic in general, but amortized constant if the element is inserted right before {{c|p}}
|-
|{{c|a.extract(k)}}
|{{tt|node_type}}
|
|Removes the first element in the container with key equivalent to {{c|k}}
|A {{tt|node_type}} owning the element if found, otherwise an empty {{tt|node_type}}
|{{c|log(a.size())}}
|-
|{{c|a_tran.extract(kx)}}&lt;br&gt;{{mark since c++23}}
|{{tt|node_type}}
|
|Removes the first element in the container with key {{c|r}} such that {{c|!c(r, kx) &amp;&amp; !c(kx, r)}} is {{c|true}}
|A {{tt|node_type}} owning the element if found, otherwise an empty {{tt|node_type}}
|{{c|log(a_tran.size())}}
|-
|{{c|a.extract(q)}}
|{{tt|node_type}}
|
|Removes the element pointed to by {{c|q}}
|A {{tt|node_type}} owning that element
|Amortized constant
|-
|{{c|a.merge(a2)}}
|{{c/core|void}}
|{{c multi
|a.get_allocator()
|{{==}}
|a2.get_allocator()
}}
|Attempts to extract each element in {{c|a2}} and insert it into {{c|a}} using the comparison object of {{c|a}}. In containers with unique keys, if there is an element in {{c|a}} with key equivalent to the key of an element from {{c|a2}}, then that element is not extracted from {{c|a2}}. Ensures: Pointers and references to the transferred elements of {{c|a2}} refer to those same elements but as members of {{c|a}}. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into {{c|a}}, not into {{c|a2}}. Throws: Nothing unless the comparison object throws
|
|{{c|N·log(a.size() + N)}}, where {{tt|N}} has the value {{c|a2.size()}}
|-
|{{c|a.erase(k)}}
|{{tt|size_type}}
|
|Erases all elements in the container with key equivalent to {{c|k}}
|The number of erased elements
|{{c multi
|log(a.size())
|+ a.count(k)
}}
|-
|{{c|a_tran.erase(kx)}}&lt;br&gt;{{mark since c++23}}
|{{tt|size_type}}
|
|Erases all elements in the container with key {{c|r}} such that {{c|!c(r, kx) &amp;&amp; !c(kx, r)}} is {{c|true}}
|The number of erased elements
|{{c multi
|log(a_tran.size())
|+ a_tran.count(kx)
}}
|-
|{{c|a.erase(q)}}
|{{tt|iterator}}
|
|Erases the element pointed to by {{c|q}}
|An iterator pointing to the element immediately following {{c|q}} prior to the element being erased. If no such element exists, returns {{c|a.end()}}
|Amortized constant
|-
|{{c|a.erase(r)}}
|{{tt|iterator}}
|
|Erases the element pointed to by {{c|r}}
|An iterator pointing to the element immediately following {{c|r}} prior to the element being erased. If no such element exists, returns {{c|a.end()}}
|Amortized constant
|-
|{{c|a.erase(q1, q2)}}
|{{tt|iterator}}
|
|Erases all the elements in the range&lt;br&gt;{{range|q1|q2}}
|An iterator pointing to the element pointed to by {{c|q2}} prior to any elements being erased. If no such element exists, {{c|a.end()}} is returned
|{{c|log(a.size()) + N}}, where {{tt|N}} has the value {{c|std::distance(q1, q2)}}
|-
|{{c|a.clear()}}
|
|
|{{c|a.erase(a.begin(), a.end())}}. Ensures: {{c|a.empty()}} is {{c|true}}
|
|Linear in {{c|a.size()}}
|-
|{{c|b.find(k)}}
|{{tt|iterator}}; {{tt|const_iterator}} for constant {{c|b}}
|
|
|An iterator pointing to an element with the key equivalent to {{c|k}}, or {{c|b.end()}} if such an element is not found
|Logarithmic
|-
|{{c|a_tran.find(ke)}}
|{{tt|iterator}}; {{tt|const_iterator}} for constant {{c|a_tran}}
|
|
|An iterator pointing to an element with key {{c|r}} such that
{{c multi|
!c(r, ke) &amp;&amp;|
!c(ke, r)}}
is {{c|true}}, or {{c|a_tran.end()}} if such an element is not found
|Logarithmic
|-
|{{c|b.count(k)}}
|{{tt|size_type}}
|
|
|The number of elements with key equivalent to {{c|k}}
|{{c multi
|log(b.size())
|+ b.count(k)
}}
|-
|{{c|a_tran.count(ke)}}
|{{tt|size_type}}
|
|
|The number of elements with key {{c|r}} such that
{{c multi|
!c(r, ke) &amp;&amp;|
!c(ke, r)}}
|{{c multi
|log(a_tran.size())
|+ a_tran.count(ke)
}}
|-
|{{c|b.contains(k)}}
|{{c/core|bool}}
|
|{{c|1=return b.find(k) != b.end();}}
|
|&lt;!--TODO: absent in 4950, present in IS C++20 Logarithmic--&gt;
|-
|{{c|a_tran.contains(ke)}}
|{{c/core|bool}}
|
|
{{c multi
|return
|  a_tran.find(ke) !{{=}}
|  a_tran.end();
}}
|
|&lt;!--TODO: absent in 4950, present in IS C++20 Logarithmic--&gt;
|-
|{{c|b.lower_bound(k)}}
|{{tt|iterator}}; {{tt|const_iterator}} for constant {{c|b}}
|
|
|An iterator pointing to the first element with key not less than {{c|k}}, or {{c|b.end()}} if such an element is not found
|Logarithmic
|-
|{{c|a_tran.lower_bound(kl)}}
|{{tt|iterator}}; {{tt|const_iterator}} for constant {{c|a_tran}}
|
|
|An iterator pointing to the first element with key {{c|r}} such that {{c|!c(r, kl)}}, or {{c|a_tran.end()}} if such an element is not found
|Logarithmic
|-
|{{c|b.upper_bound(k)}}
|{{tt|iterator}}; {{tt|const_iterator}} for constant {{c|b}}
|
|
|An iterator pointing to the first element with key greater than {{c|k}}, or {{c|b.end()}} if such an element is not found
|Logarithmic
|-
|{{c|a_tran.upper_bound(ku)}}
|{{tt|iterator}}; {{tt|const_iterator}} for constant {{c|a_tran}}
|
|
|An iterator pointing to the first element with key {{c|r}} such that {{c|c(ku, r)}}, or {{c|a_tran.end()}} if such an element is not found
|Logarithmic
|-
|{{c|b.equal_range(k)}}
|{{c multi
|std::pair&lt;
|  iterator,
|  iterator&gt;
}};
{{c multi
|std::pair&lt;
|  const_iterator,
|  const_iterator&gt;
}}
for constant {{c|b}}
|
|Equivalent to:
{{c multi
|return
|  std::make_pair(
|    b.lower_bound(k),
|    b.upper_bound(k));
}}
|
|Logarithmic
|-
|{{c|a_tran.equal_range(ke)}}
|{{c multi
|std::pair&lt;
|  iterator,
|  iterator&gt;
}};
{{c multi
|std::pair&lt;
|  const_iterator,
|  const_iterator&gt;
}}
for constant {{c|a_tran}}
|
|Equivalent to:
{{c multi
|return
|  std::make_pair(
|    a_tran.lower_bound(ke),
|    a_tran.upper_bound(ke));
}}
|
|Logarithmic
|-
|}
&lt;/div&gt;

====Iterators====
Iterators of associative containers satisfy the requirements of {{named req|BidirectionalIterator}}.

For associative containers where {{tt|value_type}} is the same as {{tt|key_type}}, both {{tt|iterator}} and {{tt|const_iterator}} are constant iterators. It is unspecified whether or not {{tt|iterator}} and {{tt|const_iterator}} are the same type.

Iterators of associative containers iterate through the containers in the non-descending order of keys where non-descending is defined by the comparison that was used to construct the containers. That is, given
* {{c|a}}, an associative container
* {{c|i}} and {{c|j}}, dereferenceable iterators to {{c|a}}.
If the distance from {{c|i}} to {{c|j}} is positive, then {{c|1=a.value_comp()(*j, *i) == false}}. Additionally, if {{c|a}} is an associative container with unique keys, the stronger condition {{c|1=a.value_comp()(*i, *j) != false}} holds.

{{todo|Finish requirements.}}

===Standard library===
The following standard library containers satisfy the {{named req/core|AssociativeContainer}} requirements:
{{dsc begin}}
{{dsc inc|cpp/container/dsc set}}
{{dsc inc|cpp/container/dsc multiset}}
{{dsc inc|cpp/container/dsc map}}
{{dsc inc|cpp/container/dsc multimap}}
{{dsc end}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=354|std=C++98|before={{tt|lower_bound}} and {{tt|upper_bound}} did not&lt;br&gt;return the end iterator if no element is found|after=they return the end&lt;br&gt;iterator in this case}}
{{dr list item|wg=lwg|dr=589|std=C++98|before=the elements that {{c|i}} and {{c|j}} refer&lt;br&gt;to had the type {{tt|X::value_type}}|after=the elements are implicitly&lt;br&gt;convertible to {{tt|X::value_type}}}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}