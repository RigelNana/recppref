{{cpp/named req/title|InputIterator}}
{{cpp/named req/navbar}}

A {{named req|InputIterator}} is a {{named req|Iterator}} that can read from the pointed-to element.  {{named req/core|InputIterator}}s only guarantee validity for single pass algorithms: once a {{named req/core|InputIterator}} {{c|i}} has been incremented, all copies of its previous value may be invalidated.

===Requirements===
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|X}}|An input iterator type}}
{{dsc|{{tt|T}}|The [[cpp/iterator#Types and writability|value type]] of {{tt|X}} (i.e. {{c/core|std::iterator_traits&lt;X&gt;::value_type}})}}
{{dsc|{{tt|R}}|{{c/core|std::iterator_traits&lt;X&gt;::reference}}}}
{{dsc hitem|Value|Definition}}
{{dsc|{{c|i}}, {{c|j}}|Values of type {{tt|X}} or {{c/core|const X}}}}
{{dsc|{{c|r}}|A value of type {{tt|X&amp;}}}}
{{dsc hitem|Other|Definition}}
{{dsc|{{tt|m}}|An identifier which possibly denotes a data member or member function}}
{{dsc end}}


{{tt|X}} satisfies {{named req/core|InputIterator}} if all following conditions are satisfied:
* {{tt|X}} satisfies {{named req|Iterator}}.
* {{tt|X}} satisfies {{named req|EqualityComparable}}.
* The following expressions are well-formed and have the specified semantics:
{|table class="wikitable"
|-
!{{nbsp}}Expression{{nbsp}}
!Type
!colspan=2|Semantics
|-
|rowspan=2|{{c|1=i != j}}
|rowspan=2|{{rev begin}}
{{rev|until=c++20|a type satisfying {{named req|BooleanTestable}}}}
{{rev|since=c++20|a type modeling {{lconcept|boolean-testable}}}}
{{rev end}}
|Precondition
|{{c|i}} and {{c|j}} are in the [[#Equality domain|domain]] of {{c|1===}}.
|-
|Effect
|Equivalent to {{c|1=!(i == j)}}.
|-
|rowspan=2|{{c|*i}}
|rowspan=2|{{tt|R}}, convertible to {{tt|T}}
|Precondition
|{{c|i}} is [[cpp/iterator#Dereferenceability and validity|dereferenceable]].
|-
|Effect
|
* The expression {{c|(void)*i, *i}} is equivalent to {{c|*i}}.
* If {{c|i}} and {{c|j}} are in the domain of {{c|1===}}, and {{c|1=i == j}}, then {{c|*i}} is equivalent to {{c|*j}}.
|-
|rowspan=2|{{c|i-&gt;m}}
|rowspan=2|
|Precondition
|{{c|i}} is dereferenceable.
|-
|Effect
|Equivalent to {{c|(*i).m}}.
|-
|rowspan=2|{{c|++r}}
|rowspan=2|{{tt|X&amp;}}
|Precondition
|{{c|r}} is dereferenceable.
|-
|Postcondition{{nbsp}}
|
* {{c|r}} is dereferenceable or {{c|r}} is past-the-end.
* Any copies of the previous value of {{c|r}} are no longer required to be either dereferenceable or to be in the domain of {{c|1===}}.
|-
|{{c|(void)r++}}
|
|Effect
|Equivalent to {{c|(void)++r}}.
|-
|{{c|*r++}}
|convertible to {{tt|T}}
|Effect
|Equivalent to {{c|1=T x = *r; ++r; return x;}}.
|}

===Equality domain===
The term ''the domain of {{c|1===}}'' is used in the ordinary mathematical sense to denote the set of values which can be compared using {{c|1===}}. This set can change over time.

Each algorithm places additional requirements on the equality domain for the iterator values it uses. These requirements can be inferred from the uses that algorithm makes of {{c|1===}} and {{c|1=!=}}.

===Notes===
For an input iterator {{tt|X}} that is not a {{named req|ForwardIterator}}, {{c/core|std::iterator_traits&lt;X&gt;::reference}} does not have to be a reference type: dereferencing an input iterator may return a proxy object or {{c/core|std::iterator_traits&lt;X&gt;::value_type}} itself by value (as in the case of {{ltt std|cpp/iterator/istreambuf_iterator}}).

{{rrev|since=c++20|
===Concept===
For the definition of {{lc|std::iterator_traits}}, the following exposition-only concept is defined.

{{dcl begin}}
{{dcl|1=
template&lt;class I&gt;
concept __LegacyInputIterator&lt;!-- called cpp17-input-iterator in the standard --&gt; =
__LegacyIterator&lt;I&gt; &amp;&amp; std::equality_comparable&lt;I&gt; &amp;&amp; requires(I i)
{
    typename std::incrementable_traits&lt;I&gt;::difference_type;
    typename std::indirectly_readable_traits&lt;I&gt;::value_type;
    typename std::common_reference_t&lt;std::iter_reference_t&lt;I&gt;&amp;&amp;,
                                     typename std::indirectly_readable_traits&lt;I&gt;::value_type&amp;&gt;;
    *i++;
    typename std::common_reference_t&lt;decltype(*i++)&amp;&amp;,
                                     typename std::indirectly_readable_traits&lt;I&gt;::value_type&amp;&gt;;
    requires std::signed_integral&lt;typename std::incrementable_traits&lt;I&gt;::difference_type&gt;;
};
}}
{{dcl end}}

where the exposition-only concept {{tt|__LegacyIterator}} is described in {{rlp|Iterator#Concept|LegacyIterator}}.
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=98|std=C++98|before=the return type of {{c|*i++}} was required to be {{tt|T}}|after=it can be any type convertible to {{tt|T}}}}
{{dr list item|wg=lwg|dr=2114|paper=P2167R3|std=C++98|before=convertibility to {{c/core|bool}} was too weak to&lt;br&gt;reflect the expectation of implementations|after=requirements strengthened}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc input_iterator}}
{{see_also_iterator_library}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}