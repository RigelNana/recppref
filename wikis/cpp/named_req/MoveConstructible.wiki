{{cpp/named req/title|MoveConstructible|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}

Specifies that an instance of the type can be constructed from an [[cpp/language/value_category|rvalue]] argument.

===Requirements===
The type {{tt|T}} satisfies {{named req/core|MoveConstructible}} if

Given
* {{tt|rv}}, an [[cpp/language/value_category|rvalue]] expression of type {{tt|T}},
* {{tt|u}}, an arbitrary identifier.

The following expressions must be valid and have their specified effects.

{|table class=wikitable
|-
!Expression||Post-conditions
|-
|{{c|1=T u = rv;}}
|The value of {{tt|u}} is equivalent to the value of {{tt|rv}} before the initialization.
The new value of {{tt|rv}} is unspecified.
|-
|{{c|T(rv)}}
|The value of {{tt|T(rv)}} is equivalent to the value of {{tt|rv}} before the initialization.
The new value of {{tt|rv}} is unspecified.
|}

===Notes===
A class does not have to implement a [[cpp/language/move constructor|move constructor]] to satisfy this type requirement: a [[cpp/language/copy constructor|copy constructor]] that takes a {{tt|const T&amp;}} argument can bind rvalue expressions.

If a {{named req/core|MoveConstructible}} class implements a move constructor, it may also implement [[cpp/utility/move|move semantics]] to take advantage of the fact that the value of {{tt|rv}} after construction is unspecified.

{{cot}}

Being a {{named req/core|MoveConstructible}} class implies {{lc|std::is_move_constructible}} but not vice versa since {{lc|std::is_move_constructible}} will only check for the ability to call the constructor with the correct arguments, not a post-condition value.

{{example
|code=
#include &lt;iostream&gt;

struct S
{
    int n;
    S(int in) : n{in} {}
    S(S&amp;&amp; other) { n = other.n + 1; }
};
static_assert(std::is_move_constructible_v&lt;S&gt;);

int main()
{
    S v{1};
    std::cout &lt;&lt; "v.n = " &lt;&lt; v.n &lt;&lt; '\n';
    S u = std::move(v);

    // Class `S` doesn't satisfy a MoveConstructible requirement
    // The value of `u` is NOT equivalent to the value of `v` before the `u` initialization
    std::cout &lt;&lt; "u.n = " &lt;&lt; u.n &lt;&lt; '\n';
}
|output=
v.n = 1
u.n = 2
}}
{{cob}}

===References===
{{cot}}
{{ref std c++23}}
{{ref std|section=16.4.4.2|title=Template argument requirements|id=utility.arg.requirements}}
{{ref std end}}
{{cob}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_move_constructible}}
{{dsc inc|cpp/concepts/dsc move_constructible}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}