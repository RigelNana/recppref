{{cpp/named req/title|TimedMutex|notes={{mark since c++11}}}}
{{cpp/named req/navbar}}

The {{named req|TimedMutex}} requirements extend the {{named req|TimedLockable}} requirements to include inter-thread synchronization.

===Requirements===
* {{named req|TimedLockable}}
* {{named req|Mutex}}

Additionally, for an object {{ttb|m}} of {{named req/core|TimedMutex}} type:
* The expression {{c|m.try_lock_for(duration)}} has the following properties
:* Behaves as an atomic operation.
:* Attempts to obtain exclusive ownership of the mutex within the duration specified by {{tt|duration}}. If {{tt|duration}} is less or equal {{tt|duration.zero()}}, attempts to obtain the ownership without blocking (as if by {{tt|try_lock()}}). Otherwise, this function blocks until the mutex is acquired or until the time specified by {{tt|duration}} passes. It returns within {{tt|duration}} only if it succeeds, but it is allowed to fail to acquire the mutex even if at some point in time during {{tt|duration}} it was not owned by another thread. In any case, it returns {{c|true}} if the mutex was acquired and {{c|false}} otherwise.
:* If {{tt|try_lock_for(duration)}} succeeds, prior {{tt|unlock()}} operations on the same object ''synchronize-with'' this operation (equivalent to release-acquire {{lc|std::memory_order}}).
:* The behavior is undefined if the calling thread already owns the mutex (except if m is {{lc|std::recursive_timed_mutex}}).
:* An exception may be thrown by clock, time point, or duration during the execution (clocks, time points, and durations provided by the standard library never throw).
* The expression {{c|m.try_lock_until(time_point)}} has the following properties
:* Behaves as an atomic operation.
:* Attempts to obtain exclusive ownership of the mutex within the time left until {{tt|time_point}}. If {{tt|time_point}} already passed, attempts to obtain the ownership without blocking (as if by {{tt|try_lock()}}). Otherwise, this function blocks until the mutex is acquired or until the time specified by {{tt|time_point}} passes. It returns before {{tt|time_point}} only if it succeeds, but it is allowed to fail to acquire the mutex even if at some point in time before {{tt|time_point}} it was not owned by another thread. In any case, it returns {{c|true}} if the mutex was acquired and {{c|false}} otherwise.
:* If {{tt|try_lock_until(time_point)}} succeeds, prior {{tt|unlock()}} operations on the same object ''synchronize-with'' this operation (equivalent to release-acquire {{lc|std::memory_order}}).
:* The behavior is undefined if the calling thread already owns the mutex (except if m is {{lc|std::recursive_timed_mutex}}).
:* An exception may be thrown by clock, time point, or duration during the execution (clocks, time points, and durations provided by the standard library never throw).

===Standard library===
The following standard library types satisfy {{named req/core|TimedMutex}} requirements:
{{dsc begin}}
{{dsc inc|cpp/thread/dsc recursive_timed_mutex}}
{{dsc inc|cpp/thread/dsc shared_timed_mutex}}
{{dsc inc|cpp/thread/dsc timed_mutex}}
{{dsc end}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2093|std=C++11|before=timeout-related exceptions were missing in the specification|after=mentioned}}
{{dr list end}}

===See also===
* [[cpp/thread|Thread support library]]
* {{named req|TimedLockable}}
* {{named req|Mutex}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}