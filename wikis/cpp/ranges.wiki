{{title|Ranges library {{mark since c++20}}}}
{{cpp/ranges/navbar}}

The ranges library is an extension and generalization of the algorithms and iterator libraries that makes them more powerful by making them composable and less error-prone.

The library creates and manipulates range ''views'', lightweight objects that indirectly represent iterable sequences (''ranges''). Ranges are an abstraction on top of
* {{range/core|begin|end}} &amp;ndash; iterator pairs, e.g. ranges made by implicit conversion from containers. All algorithms that take iterator pairs now have overloads that accept ranges (e.g. {{ltt|cpp/algorithm/ranges/sort|ranges::sort}})
* {{counted range/core|begin|size}} &amp;ndash; counted sequences, e.g. range returned by {{ltt|cpp/ranges/view_counted|views::counted}}
* {{range/core|begin|''predicate''}} &amp;ndash; conditionally-terminated sequences, e.g. range returned by {{ltt|cpp/ranges/take_while_view|views::take_while}}
* {{range/core|begin|..}} &amp;ndash; unbounded sequences, e.g. range returned by {{ltt|cpp/ranges/iota_view|views::iota}}

The ranges library includes [[cpp/algorithm/ranges|range algorithms]], which are applied to ranges eagerly, and {{lsd|#Range adaptors}}, which are applied to views lazily. Adaptors can be composed into pipelines, so that their actions take place as the view is iterated.

{{ddcl|header=ranges|since=c++20|1=
namespace std {
    namespace views = ranges::views;
}
}}

The namespace alias {{tt|std::views}} is provided as a shorthand for {{tt|std::ranges::views}}.

{{dsc begin}}
{{dsc namespace|std::ranges}}
{{dsc h2|Range access}}
{{dsc header|ranges}}
{{dsc header|iterator}}
{{dsc inc|cpp/ranges/dsc begin}}
{{dsc inc|cpp/ranges/dsc end}}
{{dsc inc|cpp/ranges/dsc cbegin}}
{{dsc inc|cpp/ranges/dsc cend}}
{{dsc inc|cpp/ranges/dsc rbegin}}
{{dsc inc|cpp/ranges/dsc rend}}
{{dsc inc|cpp/ranges/dsc crbegin}}
{{dsc inc|cpp/ranges/dsc crend}}
{{dsc inc|cpp/ranges/dsc size}}
{{dsc inc|cpp/ranges/dsc ssize}}
{{dsc inc|cpp/ranges/dsc empty}}
{{dsc inc|cpp/ranges/dsc data}}
{{dsc inc|cpp/ranges/dsc cdata}}
{{dsc h2|Range primitives}}
{{dsc header|ranges}}
{{dsc inc|cpp/ranges/dsc iterator_t}}
{{dsc inc|cpp/ranges/dsc range_size_t}}
{{dsc inc|cpp/ranges/dsc range_reference_t}}
{{dsc h2|Dangling iterator handling}}
{{dsc header|ranges}}
{{dsc inc|cpp/ranges/dsc dangling}}
{{dsc inc|cpp/ranges/dsc borrowed_iterator_t}}
{{dsc h2|Other utilities}}
{{dsc header|ranges}}
{{dsc inc|cpp/ranges/dsc elements_of}}
{{dsc h2|Range concepts}}
{{dsc header|ranges}}
{{dsc inc|cpp/ranges/dsc range}}
{{dsc inc|cpp/ranges/dsc borrowed_range}}
{{dsc inc|cpp/ranges/dsc sized_range}}
{{dsc inc|cpp/ranges/dsc view}}
{{dsc inc|cpp/ranges/dsc input_range}}
{{dsc inc|cpp/ranges/dsc output_range}}
{{dsc inc|cpp/ranges/dsc forward_range}}
{{dsc inc|cpp/ranges/dsc bidirectional_range}}
{{dsc inc|cpp/ranges/dsc random_access_range}}
{{dsc inc|cpp/ranges/dsc contiguous_range}}
{{dsc inc|cpp/ranges/dsc common_range}}
{{dsc inc|cpp/ranges/dsc viewable_range}}
{{dsc inc|cpp/ranges/dsc constant_range}}
{{dsc h2|Range conversions}}
{{dsc header|ranges}}
{{dsc inc|cpp/ranges/dsc to}}
{{dsc h2|Views}}
{{dsc header|ranges}}
{{dsc inc|cpp/ranges/dsc view_interface}}
{{dsc inc|cpp/ranges/dsc subrange}}
{{dsc end}}

===Range factories===
{{dsc begin}}
{{dsc header|ranges}}
{{dsc namespace|std::ranges}}
{{dsc inc|cpp/ranges/dsc empty_view}}
{{dsc inc|cpp/ranges/dsc single_view}}
{{dsc inc|cpp/ranges/dsc iota_view}}
{{dsc inc|cpp/ranges/dsc repeat_view}}
{{dsc inc|cpp/ranges/dsc basic_istream_view}}
{{dsc end}}

===Range adaptors===
{{dsc begin}}
{{dsc header|ranges}}
{{dsc namespace|std::ranges}}
{{dsc inc|cpp/ranges/dsc range_adaptor_closure}}
{{dsc inc|cpp/ranges/dsc all_view}}
{{dsc inc|cpp/ranges/dsc ref_view}}
{{dsc inc|cpp/ranges/dsc owning_view}}
{{dsc inc|cpp/ranges/dsc as_rvalue_view}}
{{dsc inc|cpp/ranges/dsc filter_view}}
{{dsc inc|cpp/ranges/dsc transform_view}}
{{dsc inc|cpp/ranges/dsc take_view}}
{{dsc inc|cpp/ranges/dsc take_while_view}}
{{dsc inc|cpp/ranges/dsc drop_view}}
{{dsc inc|cpp/ranges/dsc drop_while_view}}
{{dsc inc|cpp/ranges/dsc join_view}}
{{dsc inc|cpp/ranges/dsc join_with_view}}
{{dsc inc|cpp/ranges/dsc lazy_split_view}}
{{dsc inc|cpp/ranges/dsc split_view}}
{{dsc inc|cpp/ranges/dsc concat_view}}
{{dsc inc|cpp/ranges/dsc view_counted}}
{{dsc inc|cpp/ranges/dsc common_view}}
{{dsc inc|cpp/ranges/dsc reverse_view}}
{{dsc inc|cpp/ranges/dsc as_const_view}}
{{dsc inc|cpp/ranges/dsc elements_view}}
{{dsc inc|cpp/ranges/dsc keys_view}}
{{dsc inc|cpp/ranges/dsc values_view}}
{{dsc inc|cpp/ranges/dsc enumerate_view}}
{{dsc inc|cpp/ranges/dsc zip_view}}
{{dsc inc|cpp/ranges/dsc zip_transform_view}}
{{dsc inc|cpp/ranges/dsc adjacent_view}}
{{dsc inc|cpp/ranges/dsc adjacent_transform_view}}
{{dsc inc|cpp/ranges/dsc chunk_view}}
{{dsc inc|cpp/ranges/dsc slide_view}}
{{dsc inc|cpp/ranges/dsc chunk_by_view}}
{{dsc inc|cpp/ranges/dsc stride_view}}
{{dsc inc|cpp/ranges/dsc cartesian_product_view}}
{{dsc inc|cpp/ranges/dsc cache_latest_view}}
{{dsc end}}

{{anchor|Range generators}}
===Range generators {{mark since c++23}}===
{{dsc begin}}
{{dsc header|generator}}
{{dsc namespace|std}}
{{dsc inc|cpp/ranges/dsc generator}}
{{dsc end}}

===Helper items===

====Range adaptor objects====
See {{named req|RangeAdaptorObject}} (RAO).

====Range adaptor closure objects====
See {{named req|RangeAdaptorClosureObject}} (RACO).

====Customization point objects====
See {{rl|cpo|Customization point object}} (CPO).

====Assignable wrapper====
Some range adaptors wrap their elements or function objects with the {{rev inl|until=c++23|{{rli|copyable wrapper|copyable-box}}}}{{rev inl|since=c++23|{{rli|copyable wrapper|movable-box}}}}. The wrapper augments the wrapped object with assignability when needed.&lt;!--TODO: update the internal link to "movable_wrapper". --&gt;

====Non-propagating cache====
Some range adaptors are specified in terms of an exposition-only class template {{rli|non-propagating-cache}}, which behaves almost like {{c/core|std::optional&lt;T&gt;}} (see description for differences).

====Conditionally-{{tt|const}} type====
{{dcl begin}}
{{dcla|anchor=maybe-const|expos=yes|1=
template&lt; bool Const, class T &gt;
using /*maybe-const*/ = std::conditional_t&lt;Const, const T, T&gt;;
}}
{{dcl end}}

The alias template {{c/core|/*maybe-const*/}} is a shorthand used to conditionally apply a {{c/core|const}} qualifier to the type {{tt|T}}.

====Integer-like type helper templates====
{{dcl begin}}
{{dcla|num=1|anchor=make-signed-like-t|expos=yes|1=
template&lt; /*is-integer-like*/ T &gt;
using /*make-signed-like-t*/&lt;T&gt; = /* see description */;
}}
{{dcla|num=2|anchor=make-unsigned-like-t|expos=yes|1=
template&lt; /*is-integer-like*/ T &gt;
using /*make-unsigned-like-t*/&lt;T&gt; = /* see description */;
}}
{{dcla|num=3|anchor=to-unsigned-like|expos=yes|
template&lt; /*is-integer-like*/ T &gt;
/*make-unsigned-like-t*/&lt;T&gt; /*to-unsigned-like*/( T t )
{
    return static_cast&lt;/*make-unsigned-like-t*/&lt;T&gt;&gt;(t);
}
}}
{{dcl end}}

@1@ For an [[cpp/iterator/is-integer-like|integer-like type]] {{tt|T}}:
* If {{tt|T}} is an integer type, {{c/core|/*make-signed-like-t*/&lt;T&gt;}} is {{c/core|std::make_signed_t&lt;T&gt;}}.
* Otherwise, {{c/core|/*make-signed-like-t*/&lt;T&gt;}} is a corresponding unspecified signed-integer-like type of the same width as {{tt|T}}.

@2@ For an integer-like type {{tt|T}}:
* If {{tt|T}} is an integer type, {{c/core|/*make-unsigned-like-t*/&lt;T&gt;}} is {{c/core|std::make_unsigned_t&lt;T&gt;}}.
* Otherwise, {{c/core|/*make-signed-like-t*/&lt;T&gt;}} is a corresponding unspecified unsigned-integer-like type of the same width as {{tt|T}}.

@3@ Explicitly converts {{c|t}} to {{c/core|/*make-unsigned-like-t*/&lt;T&gt;}}.

====Customization point object helpers====
{{dcl begin}}
{{dcla|num=1|anchor=possibly-const-range|expos=yes|
template&lt; ranges::input_range R &gt;
constexpr auto&amp; /*possibly-const-range*/(R&amp; r) noexcept
{
    if constexpr (ranges::input_range&lt;const R&gt;)
        return const_cast&lt;const R&amp;&gt;(r);
    else
        return r;
}
}}
{{dcla|num=2|anchor=as-const-pointer|expos=yes|
template&lt; class T &gt;
constexpr auto /*as-const-pointer*/( const T* p ) noexcept
{
    return p;
}
}}
{{dcl end}}

Some range access customization point objects are specified in terms of these exposition-only function templates.

@1@ {{c/core|/*possibly-const-range*/}} returns the const-qualified version of {{c|r}} if {{c/core|const R}} models {{lconcept|input_range}}; otherwise, returns {{c|r}} without any casting.

@2@ {{c/core|/*as-const-pointer*/}} returns a pointer to object of constant type.

====Range adaptor helpers====
{{dcl begin}}
{{dcla|num=1|anchor=tuple-transform|expos=yes|
template&lt; class F, class Tuple &gt;
constexpr auto /*tuple-transform*/( F&amp;&amp; f, Tuple&amp;&amp; tuple )
{
    return std::apply([&amp;]&lt;class... Ts&gt;(Ts&amp;&amp;... args)
    {
        return std::tuple&lt;std::invoke_result_t&lt;F&amp;, Ts&gt;...&gt;
            (std::invoke(f, std::forward&lt;Ts&gt;(args))...);
    }, std::forward&lt;Tuple&gt;(tuple));
}
}}
{{dcla|num=2|anchor=tuple-for-each|expos=yes|
template&lt; class F, class Tuple &gt;
constexpr void /*tuple-for-each*/( F&amp;&amp; f, Tuple&amp;&amp; tuple )
{
    std::apply([&amp;]&lt;class... Ts&gt;(Ts&amp;&amp;... args)
    {
        (static_cast&lt;void&gt;(std::invoke(f, std::forward&lt;Ts&gt;(args))), ...);
    }, std::forward&lt;Tuple&gt;(tuple));
}
}}
{{dcla|num=3|anchor=as-lvalue|expos=yes|
template&lt; class T &gt;
constexpr T&amp; /*as-lvalue*/( T&amp;&amp; t )
{
    return static_cast&lt;T&amp;&gt;(t);
}
}}
{{dcl end}}

Some range adaptors are specified in terms of these exposition-only function templates.

@1@ {{c/core|/*tuple-transform*/}} returns a new tuple constructed by applying {{c|f}} to each element of {{c|tuple}}.
@2@ {{c/core|/*tuple-for-each*/}} applies {{c|f}} to each element of {{c|tuple}} and returns nothing.
@3@ {{c/core|/*as-lvalue*/}} forwards rvalue {{c|t}} as lvalue.

====Helper concepts====
Following exposition-only concepts are used for several types, but they are not parts of the interface of standard library.

{{dcl begin}}
{{dcla|num=1|anchor=simple-view|expos=yes|1=
template&lt; class R &gt;
concept /*simple-view*/ =
    ranges::view&lt;R&gt; &amp;&amp; ranges::range&lt;const R&gt; &amp;&amp;
    std::same_as&lt;ranges::iterator_t&lt;R&gt;, ranges::iterator_t&lt;const R&gt;&gt; &amp;&amp;
    std::same_as&lt;ranges::sentinel_t&lt;R&gt;, ranges::sentinel_t&lt;const R&gt;&gt;;
}}
{{dcla|num=2|anchor=has-arrow|expos=yes|1=
template&lt; class I &gt;
concept /*has-arrow*/ =
    ranges::input_iterator&lt;I&gt; &amp;&amp;
    (std::is_pointer_v&lt;I&gt; {{!!}} requires(I i) { i.operator-&gt;(); });
}}
{{dcla|num=3|anchor=different-from|expos=yes|1=
template&lt; class T, class U &gt;
concept /*different-from*/ =
    !std::same_as&lt;std::remove_cvref_t&lt;T&gt;, std::remove_cvref_t&lt;U&gt;&gt;;
}}
{{dcla|num=4|anchor=range-with-movable-references|expos=yes|1=
template&lt; class R &gt;
concept /*range-with-movable-references*/ =
    ranges::input_range&lt;R&gt; &amp;&amp;
    std::move_constructible&lt;ranges::range_reference_t&lt;R&gt;&gt; &amp;&amp;
    std::move_constructible&lt;ranges::range_rvalue_reference_t&lt;R&gt;&gt;;
}}
{{dcla|num=5|anchor=all-random-access|expos=yes|1=
template&lt; bool C, class... Views &gt;
concept /*all-random-access*/ =
    (ranges::random_access_range
         &lt;std::conditional_t&lt;C, const Views, Views&gt;&gt; &amp;&amp; ...);
}}
{{dcla|num=6|anchor=all-bidirectional|expos=yes|1=
template&lt; bool C, class... Views &gt;
concept /*all-bidirectional*/ =
    (ranges::bidirectional_range
         &lt;std::conditional_t&lt;C, const Views, Views&gt;&gt; &amp;&amp; ...);
}}
{{dcla|num=7|anchor=all-forward|expos=yes|1=
template&lt; bool C, class... Views &gt;
concept /*all-forward*/ =
    (ranges::forward_range
         &lt;std::conditional_t&lt;C, const Views, Views&gt;&gt; &amp;&amp; ...);
}}
{{dcl end}}

===Notes===
{{ftm begin|sort=1}}
{{ftm|value=202207L|std=C++23|__cpp_lib_generator|{{c/core|std::generator}} â€“ synchronous coroutine generator for ranges}}
{{ftm|value=201911L|std=C++20|__cpp_lib_ranges|rowspan="8"|Ranges library and [[cpp/algorithm/ranges|constrained algorithms]]}}
{{ftm|value=202106L|std=C++23|-|Non-[[cpp/concepts/default initializable|default-initializable]] [[cpp/ranges/view|view]]s|dr=20}}
{{ftm|value=202110L|std=C++23|-|[[cpp/ranges/view|View]]s with [[cpp/ranges/owning_view|ownership]]|dr=20}}
{{ftm|value=202202L|std=C++23|-|{{c/core|ranges::range_adaptor_closure}}}}
{{ftm|value=202207L|std=C++23|-|Relaxing {{lsd|#Range adaptors}} to allow for move-only types}}
{{ftm|value=202211L|std=C++23|-|Removing "poison pills" {{stddoc|p2602|(P2602)}} overloads in {{c/core|ranges::begin}} etc}}
{{ftm|value=202302L|std=C++23|-|Relaxing ranges to allow certain projections}}
{{ftm|value=202406L|std=C++26|-|Removing the common reference requirement from the indirectly invocable concepts|dr=20}}
{{ftm|value=202207L|std=C++23|__cpp_lib_ranges_as_const|{{c/core|std::const_iterator}}, {{c/core|ranges::as_const_view}}}}
{{ftm|value=202207L|std=C++23|__cpp_lib_ranges_as_rvalue|{{c/core|ranges::as_rvalue_view}}}}
{{ftm|value=202411L|std=C++26|__cpp_lib_ranges_cache_latest|{{c/core|ranges::cache_latest_view}}}}
{{ftm|value=202207L|std=C++23|__cpp_lib_ranges_cartesian_product|{{c/core|ranges::cartesian_product_view}}}}
{{ftm|value=202202L|std=C++23|__cpp_lib_ranges_chunk|{{c/core|ranges::chunk_view}}}}
{{ftm|value=202202L|std=C++23|__cpp_lib_ranges_chunk_by|{{c/core|ranges::chunk_by_view}}}}
{{ftm|value=202403L|std=C++26|__cpp_lib_ranges_concat|{{c/core|ranges::concat_view}}}}
{{ftm|value=202302L|std=C++23|__cpp_lib_ranges_enumerate|{{c/core|ranges::enumerate_view}}}}
{{ftm|value=202202L|std=C++23|__cpp_lib_ranges_join_with|{{c/core|ranges::join_with_view}}}}
{{ftm|value=202207L|std=C++23|__cpp_lib_ranges_repeat|{{c/core|ranges::repeat_view}}}}
{{ftm|value=202202L|std=C++23|__cpp_lib_ranges_slide|{{c/core|ranges::slide_view}}}}
{{ftm|value=202207L|std=C++23|__cpp_lib_ranges_stride|{{c/core|ranges::stride_view}}}}
{{ftm|value=202202L|std=C++23|__cpp_lib_ranges_to_container|{{c/core|ranges::to}}}}
{{ftm|value=202110L|std=C++23|__cpp_lib_ranges_zip|{{c/core|ranges::zip_view}},&lt;br&gt;{{c/core|ranges::zip_transform_view}},&lt;br&gt;{{c/core|ranges::adjacent_view}},&lt;br&gt;{{c/core|ranges::adjacent_transform_view}}}}
{{ftm end}}

===Example===
{{example|code=
#include &lt;iostream&gt;
#include &lt;ranges&gt;

int main()
{
    auto const ints = {0, 1, 2, 3, 4, 5};
    auto even = [](int i) { return 0 == i % 2; };
    auto square = [](int i) { return i * i; };
    
    // the "pipe" syntax of composing the views:
    for (int i : ints {{!}} std::views::filter(even) {{!}} std::views::transform(square))
        std::cout &lt;&lt; i &lt;&lt; ' ';
    
    std::cout &lt;&lt; '\n';
    
    // a traditional "functional" composing syntax:
    for (int i : std::views::transform(std::views::filter(ints, even), square))
        std::cout &lt;&lt; i &lt;&lt; ' ';
}
|output=
0 4 16
0 4 16
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3509|paper=P2281R1|std=C++20|before=it was unclear how range adaptor objects bound trailing arguments|after=they are bound&lt;br&gt;by value}}
{{dr list item|wg=lwg|dr=3948|std=C++23|before={{tti|possibly-const-range}} and {{tti|as-const-pointer}}&lt;br&gt;were not declared {{c/core|noexcept}}|after=declared {{c/core|noexcept}}}}
{{dr list item|wg=lwg|dr=4027|std=C++23|before={{tti|possibly-const-range}} would not add const-qualification&lt;br&gt;for ranges that has already modeled {{lconcept|constant_range}}|after=adds const-qualification&lt;br&gt;for such ranges}}
{{dr list end}}

===See also===
* [[cpp/iterator|Iterator library]]
* [[cpp/algorithm/ranges|Constrained algorithms]]

{{langlinks|es|ja|ru|zh}}