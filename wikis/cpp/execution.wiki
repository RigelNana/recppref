{{title|Execution library {{mark since c++26}}}}
{{cpp/execution/navbar}}

The Execution library provides a framework for managing asynchronous execution on generic execution resources.

The library aims to provide vocabulary types for asynchronous operations and to allow the construction of task execution graphs in a simple, composable way.

==Library-wide definitions==

* '''Sender''': A description of asynchronous work to be sent for execution. Produces an operation state (below).
:* Senders asynchronously “send” their results to listeners called “receivers” (below).
:* Senders can be composed into '''task graphs''' using generic algorithms.
:* '''Sender factories and adaptors''' are generic algorithms that capture common async patterns in objects satisfying the {{lc|sender}}&lt;!--{{lconcept|sender}}--&gt; concept.
* '''Receiver''': A generalized callback that consumes or “receives” the asynchronous results produced by a sender.
:* Receivers have three different “channels” through which a sender may propagate results: success, failure, and canceled, so-named “value”, “error”, and “stopped”.
:* Receivers provide an extensible execution environment: a set of key/value pairs that the consumer can use to parameterize the asynchronous operation.
* '''Operation State''': An object that contains the state needed by the asynchronous operation. 
:* A sender and receiver are connected when passed to the {{lc|std::execution::connect}} function.
:* The result of connecting a sender and a receiver is an operation state. 
:* Work is not enqueued for execution until “{{tt|start}}” is called on an operation state.
:* Once started, the operation state’s lifetime cannot end before the async operation is complete, and its address must be stable.
* '''Scheduler''': A lightweight handle to an execution context. 
:* An execution context is a source of asynchronous execution such as a thread pool or a GPU stream. 
:* A scheduler is a factory for a sender that completes its receiver from a thread of execution owned by the execution context.

==Library utilities==

===Concepts===
====Schedulers====
{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::execution}}
{{dsc inc|cpp/execution/dsc scheduler}}
{{dsc end}}

====Senders====
{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::execution}}
{{dsc inc|cpp/execution/dsc sender}}
{{dsc inc|cpp/execution/dsc sender_in}}
{{dsc inc|cpp/execution/dsc sender_to}}
{{dsc end}}

====Receivers====
{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::execution}}
{{dsc inc|cpp/execution/dsc receiver}}
{{dsc inc|cpp/execution/dsc receiver_of}}
{{dsc end}}

====Operation states====
{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::execution}}
{{dsc inc|cpp/execution/dsc operation_state}}
{{dsc end}}

===Utility components===
====Execution contexts====
{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::execution}}
{{dsc inc|cpp/execution/dsc run_loop}}
{{dsc end}}

====Execution domains====
{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::execution}}
{{dsc inc|cpp/execution/dsc default_domain}}
{{dsc inc|cpp/execution/dsc transform_sender}}
{{dsc inc|cpp/execution/dsc transform_env}}
{{dsc inc|cpp/execution/dsc apply_sender}}
{{dsc end}}

====Forward progress guarantee====
{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::execution}}
{{dsc inc|cpp/execution/dsc forward_progress_guarantee}}
{{dsc end}}

====Environments====
{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::execution}}
{{dsc inc|cpp/execution/dsc prop}}
{{dsc inc|cpp/execution/dsc env}}
{{dsc inc|cpp/execution/dsc get_env}}
{{dsc end}}

====Queries====
{{dsc begin}}
{{dsc header|execution}}
{{dsc inc|cpp/execution/dsc forwarding_query}}
{{dsc inc|cpp/execution/dsc get_allocator}}
{{dsc inc|cpp/execution/dsc get_stop_token}}
{{dsc inc|cpp/execution/dsc get_domain}}
{{dsc inc|cpp/execution/dsc get_scheduler}}
{{dsc inc|cpp/execution/dsc get_delegation_scheduler}}
{{dsc inc|cpp/execution/dsc get_completion_scheduler}}
{{dsc inc|cpp/execution/dsc get_forward_progress_guarantee}}
{{dsc end}}

====Completion signatures====
{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::execution}}
{{dsc inc|cpp/execution/dsc completion_signatures}}
{{dsc inc|cpp/execution/dsc get_completion_signatures}}
{{dsc inc|cpp/execution/dsc transform_completion_signatures}}
{{dsc inc|cpp/execution/dsc transform_completion_signatures_of}}
{{dsc inc|cpp/execution/dsc tag_of_t}}
{{dsc inc|cpp/execution/dsc value_types_of_t}}
{{dsc inc|cpp/execution/dsc error_types_of_t}}
{{dsc inc|cpp/execution/dsc sends_stopped}}
{{dsc end}}

====Coroutine utility====
{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::execution}}
{{dsc inc|cpp/execution/dsc as_awaitable}}
{{dsc inc|cpp/execution/dsc with_awaitable_senders}}
{{dsc end}}

===Core operations===
====Operation state====
{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::execution}}
{{dsc inc|cpp/execution/dsc connect}}
{{dsc inc|cpp/execution/dsc start}}
{{dsc end}}

====Completion functions====
These functions are called by senders to announce the completion of the work to their receivers.
{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::execution}}
{{dsc inc|cpp/execution/dsc set_value}}
{{dsc inc|cpp/execution/dsc set_error}}
{{dsc inc|cpp/execution/dsc set_stopped}}
{{dsc end}}

===Sender algorithms===
&lt;!--{{dsc namespace|std::execution}}--&gt;
{{todo|WIP update to current standard in progress}}

====Sender factories====
A sender factory is a function that returns a sender and whose parameters have types for which the {{lconcept|sender}} concept is {{c|false}}.

The following are sender factories:

{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::execution}}
{{dsc inc|cpp/execution/dsc just}}
{{dsc inc|cpp/execution/dsc just_error}}
{{dsc inc|cpp/execution/dsc just_stopped}}
{{dsc inc|cpp/execution/dsc read_env}}
{{dsc inc|cpp/execution/dsc schedule}}
{{dsc end}}

====Pipeable sender adaptors====
{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::execution}}
{{dsc inc|cpp/execution/dsc sender_adaptor_closure}}
{{dsc end}}

====Sender adaptors====
A sender adaptor is a function returning a sender whose parameters include at least one whose type satisfies the {{lconcept|sender}} concept, and for which the returned sender is a parent sender of the adaptor function's sender arguments.

The following are sender adaptors:
{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::execution}}
{{dsc inc|cpp/execution/dsc starts_on}}
{{dsc inc|cpp/execution/dsc continues_on}}
{{dsc inc|cpp/execution/dsc on}}
{{dsc inc|cpp/execution/dsc schedule_from}}
{{dsc inc|cpp/execution/dsc then}}
{{dsc inc|cpp/execution/dsc upon_error}}
{{dsc inc|cpp/execution/dsc upon_stopped}}
{{dsc inc|cpp/execution/dsc let_value}}
{{dsc inc|cpp/execution/dsc let_error}}
{{dsc inc|cpp/execution/dsc let_stopped}}
{{dsc inc|cpp/execution/dsc bulk}}
{{dsc inc|cpp/execution/dsc split}}
{{dsc inc|cpp/execution/dsc when_all}}
{{dsc inc|cpp/execution/dsc when_all_with_variant}}
{{dsc inc|cpp/execution/dsc into_variant}}
{{dsc inc|cpp/execution/dsc stopped_as_optional}}
{{dsc inc|cpp/execution/dsc stopped_as_error}}&lt;!--dropped
{{dsc inc|cpp/execution/dsc ensure_started}}
{{dsc inc|cpp/execution/dsc transfer}}--&gt;
{{dsc end}}

====Sender consumers====
A sender consumer is an algorithm that takes one or more senders as parameters and that does not return a sender.

{{dsc begin}}
{{dsc header|execution}}
{{dsc namespace|std::this_thread}}
{{dsc inc|cpp/thread/dsc sync_wait}}
{{dsc inc|cpp/thread/dsc sync_wait_with_variant}}
{{dsc end}}

===Example===
{{example
|A version of this example is available on [https://godbolt.org/z/vdxGsxsKd godbolt.org],  where it uses [https://github.com/NVIDIA/stdexec stdexec], an experimental reference implementation of {{lc|std::execution}}.
|code=
#include &lt;cstdio&gt;
#include &lt;execution&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;utility&gt;
using namespace std::literals;

int main()
{
    std::execution::run_loop loop;

    std::jthread worker([&amp;](std::stop_token st)
    {
        std::stop_callback cb{st, [&amp;]{ loop.finish(); }&lt;!----&gt;};
        loop.run();
    });
    
    std::execution::sender auto hello = std::execution::just("hello world"s);
    std::execution::sender auto print
        = std::move(hello)
        {{!}} std::execution::then([](std::string msg)
        {
            return std::puts(msg.c_str());
        });
    
    std::execution::scheduler auto io_thread = loop.get_scheduler();
    std::execution::sender auto work = std::execution::on(io_thread, std::move(print));
    
    auto [result] = std::this_thread::sync_wait(std::move(work)).value();
    
    return result;
}
|output=
hello world
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/thread/dsc async}}
{{dsc end}}

{{langlinks|es|zh}}