{{cpp/experimental/title|make_array}}
{{cpp/experimental/lib_extensions_2/navbar}}

{{dcl begin}}
{{dcl header|experimental/array}}
{{dcl|since=libfund_ts_2|1=
template&lt; class D = void, class... Types &gt;
constexpr std::array&lt;VT /* see below */, sizeof...(Types)&gt; make_array( Types&amp;&amp;... t );
}}
{{dcl end}}

Creates a {{lc|std::array}} whose size is equal to the number of arguments and whose elements are initialized from the corresponding arguments. Returns {{c|std::array&lt;VT, sizeof...(Types)&gt;{std::forward&lt;Types&gt;(t)...}}}.

If {{tt|D}} is {{c|void}}, then the deduced type {{tt|VT}} is {{c|std::common_type_t&lt;Types...&gt;}}. Otherwise, it is {{tt|D}}.

If {{tt|D}} is {{c|void}} and any of {{c|std::decay_t&lt;Types&gt;...}} is a specialization of {{lc|std::reference_wrapper}}, the program is ill-formed.

===Notes===
{{tt|make_array}} is removed in Library Fundamentals TS v3 because the [[cpp/container/array/deduction guides|deduction guide]] for {{tt|std::array}} and {{ltt|cpp/container/array/to_array|std::to_array}} have been already in C++20.

===Possible implementation===
{{eq fun|1=
namespace details
{
    template&lt;class&gt; struct is_ref_wrapper : std::false_type{};
    template&lt;class T&gt; struct is_ref_wrapper&lt;std::reference_wrapper&lt;T&gt;&gt; : std::true_type{};

    template&lt;class T&gt;
    using not_ref_wrapper = std::negation&lt;is_ref_wrapper&lt;std::decay_t&lt;T&gt;&gt;&gt;;

    template&lt;class D, class...&gt; struct return_type_helper { using type = D; };
    template&lt;class... Types&gt;
    struct return_type_helper&lt;void, Types...&gt; : std::common_type&lt;Types...&gt;
    {
        static_assert(std::conjunction_v&lt;not_ref_wrapper&lt;Types&gt;...&gt;,
                      "Types cannot contain reference_wrappers when D is void");
    };

    template&lt;class D, class... Types&gt;
    using return_type = std::array&lt;typename return_type_helper&lt;D, Types...&gt;::type,
                                   sizeof...(Types)&gt;;
}

template&lt;class D = void, class... Types&gt;
constexpr details::return_type&lt;D, Types...&gt; make_array(Types&amp;&amp;... t)
{
    return {std::forward&lt;Types&gt;(t)...};
}
}}

===Example===
{{example
|code=
#include &lt;experimental/array&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;

int main()
{
    auto arr = std::experimental::make_array(1, 2, 3, 4, 5);
    bool is_array_of_5_ints = std::is_same&lt;decltype(arr), std::array&lt;int, 5&gt;&gt;::value;
    std::cout &lt;&lt; "Returns an array of five ints? ";
    std::cout &lt;&lt; std::boolalpha &lt;&lt; is_array_of_5_ints &lt;&lt; '\n';
}
|output=
Returns an array of five ints? true
}}

===See also===
{{dsc begin}}
{{dsc see cpp|cpp/container/array/deduction_guides|nomono=true|{{tt|std::array}} deduction guides}}
{{dsc inc|cpp/experimental/dsc to array}}
{{dsc end}}

{{langlinks|ja|zh}}