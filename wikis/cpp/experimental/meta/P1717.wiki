{{title|Compiletime Metaprogramming in C++ in P1717R0}}
{{fmbox | class=noprint | style=font-size: 0.8em | text='''Info:''' this is not an experimental feature. Only an alternative-only paper {{mark since P1717}}.}}
{{cpp/experimental/navbar}}
===Introduction===
This is based on {{wg21|P0712}}.
 '''template'''&lt;'''typename'''... Types&gt;
 '''class''' tuple {
  '''consteval''' {
   '''int''' counter = 0;
   '''for'''... (meta::info type : '''reflexpr'''(Types)) {
    '''auto''' fragment = '''__fragment struct''' {
     '''typename'''(type) '''unqualid'''("element_", counter);
    };
    -&gt; fragment;
    ++counter;
   }
  }
 };
 tuple&lt;'''bool''', '''char''', '''int'''&gt; tup;

same as
 '''template'''&lt;'''typename'''... Types&gt;
 '''class''' tuple {
  '''bool''' element0;
  '''char''' element1;
  '''int''' element2;
 };


=====consteval{ ... }=====
the stuff filled in it is called metaprogram. It is executed where they appear in the translation unit.
=====typename( meta::info )=====
The typename of a reflection of a type can be gotten by typename operator.

=====unqualid=====
This operator makes a new unqualifiedid. It takes a few arguments, which are concatenated to form the new identifier. 
=====-&gt;fragment=====
This operator sends a request to the compiler. Compiler would inject the fragment.
=====__fragment=====
======Class fragments======
TODO:
======Namespace Fragments======
TODO:
======Enum Fragment======
TODO:
======Block Fragments======
TODO:
======Parameterizing Fragments======
TODO:
=====Nonlocal dependencies=====
TODO:
=====Parameter Injection=====
TODO:
=====Metaclasses=====
TODO:
===See also===
{{wg21|p1717r0}}