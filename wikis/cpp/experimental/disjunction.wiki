{{cpp/experimental/title|disjunction}}
{{cpp/experimental/lib extensions 2/navbar}}
{{fmbox|class=noprint|style=font-size: 0.8em|text='''Merged into ISO C++''' The functionality described on this page was merged into the mainline ISO C++ standard as of 2/2016, see  {{ltt|cpp/types/disjunction|std::disjunction}} {{mark since c++17}} }}
{{dcl begin}}
{{dcl header|experimental/type_traits}}
{{dcl|since=libfund_ts_2|1=
template&lt; class... B &gt;
struct disjunction;
}}
{{dcl end}}

Forms the [https://en.wikipedia.org/wiki/Logical_disjunction logical disjunction] of the type traits {{tt|B...}}, effectively performing a logical or on the sequence of traits.

The specialization {{c|std::experimental::disjunction&lt;B1, ..., BN&gt;}} has a public and unambiguous base that is 
* if {{c|1=sizeof...(B) == 0}}, {{c|std::false_type}}; otherwise
* the first type {{tt|Bi}} in {{tt|B1, ..., BN}} for which {{c|1=bool(Bi::value) == true}}, or {{tt|BN}} if there is no such type.

The member names of the base class, other than {{tt|disjunction}} and {{tt|operator{{=}}}}, are not hidden and are unambiguously available in {{tt|disjunction}}.

Disjunction is short-circuiting: if there is a template type argument {{tt|Bi}} with {{c|1=bool(Bi::value) != false}}, then instantiating {{c|disjunction&lt;B1, ..., BN&gt;::value}} does not require the instantiation of {{c|Bj::value}} for {{tt|j &gt; i}}.

===Template parameters===
{{par begin}}
{{par|B...|every template argument {{tt|Bi}} for which {{c|Bi::value}} is instantiated must be usable as a base class and define member {{tt|value}} that is convertible to {{c|bool}}}}
{{par end}}

=== Helper variable template ===
{{dcl begin}}
{{dcl|since=libfund_ts_2|1=
template&lt; class... B &gt;
constexpr bool disjunction_v = disjunction&lt;B...&gt;::value;
}}
{{dcl end}}

===Possible implementation===
{{eq fun
|1=
template&lt;class...&gt; struct disjunction : std::false_type {};
template&lt;class B1&gt; struct disjunction&lt;B1&gt; : B1 {};
template&lt;class B1, class... Bn&gt;
struct disjunction&lt;B1, Bn...&gt; 
    : std::conditional_t&lt;bool(B1::value), B1, disjunction&lt;Bn...&gt;&gt;  {};
}}

===Notes===
A specialization of {{tt|disjunction}} does not necessarily inherit from of either {{c|std::true_type}} or {{c|std::false_type}}: it simply inherits from the first {{tt|B}} whose {{tt|::value}}, explicitly converted to {{tt|bool}}, is true, or from the very last B when all of them convert to false. For example, {{c|disjunction&lt;std::integral_constant&lt;int, 2&gt;, std::integral_constant&lt;int, 4&gt;&gt;::value}} is {{c|2}}.

===Example===
{{example|code=
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc disjunction}}
{{dsc end}}