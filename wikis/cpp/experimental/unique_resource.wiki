{{cpp/experimental/title|unique_resource}}
{{cpp/experimental/unique_resource/navbar}}
{{ddcl|since=libfund_ts_3|header=experimental/scope|
template&lt; class R, class D &gt;
class unique_resource;
}}

{{tt|unique_resource}} is universal RAII wrapper for resource handles that owns and manages a resource through a handle and disposes of that resource when the {{tt|unique_resource}} is destroyed.

The resource is disposed of using the deleter of type {{tt|D}} when either of the following happens:
* the managing {{tt|unique_resource}} object is destroyed,
* the managing {{tt|unique_resource}} object is assigned from another resource via {{lc|operator{{=}}}} or {{lc|reset()}}.

Let type {{tt|RS}} be {{tt|R}} if {{tt|R}} is an object type, or {{c|std::reference_wrapper&lt;std::remove_reference_t&lt;R&gt;&gt;}} otherwise:
* {{tt|unique_resource}} effectively holds a subobject of type {{tt|RS}} which is or wraps the resource handle, a deleter of type {{tt|D}} and a {{c|bool}} flag indicating whether the wrapper is owning the resource.
* For explanatory purpose, the subobject of type {{tt|RS}} is called ''stored resource handle'', and the stored (if {{tt|R}} is an object type) or wrapped (if {{tt|R}} is a reference type) {{tt|R}} is called ''underlying resource handle''. These two terms are not used by the LFTS.

===Template parameters===
{{par begin}}
{{par|R|resource handle type}}
{{par|D|deleter type}}
{{par hreq}}
{{par req|{{tt|R}} shall be an object type or an lvalue reference to an object type. Let {{tt|UnrefR}} be {{c|std::remove_reference_t&lt;R&gt;}}, {{tt|UnrefR}} shall be {{named req|MoveConstructible}}, and if {{tt|UnrefR}} is not {{named req|CopyConstructible}}, {{c|std::is_nothrow_move_constructible_v&lt;UnrefR&gt;}} shall be {{c|true}}.}}
{{par req|{{tt|D}} shall be a {{named req|Destructible}} and {{named req|MoveConstructible}} {{named req|FunctionObject}} type, and if {{tt|D}} is not {{named req|CopyConstructible}}, {{c|std::is_nothrow_move_constructible_v&lt;D&gt;}} shall be {{c|true}}. Given an lvalue {{tt|d}} of type {{tt|D}} and an lvalue {{tt|r}} of type {{tt|UnrefR}}, the expression {{c|d(r)}} shall be well-formed.}}
{{par end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/experimental/unique_resource/dsc constructor}}
{{dsc inc|cpp/experimental/unique_resource/dsc destructor}}
{{dsc inc|cpp/experimental/unique_resource/dsc operator{{=}}}}

{{dsc h2|Modifiers}}
{{dsc inc|cpp/experimental/unique_resource/dsc release}}
{{dsc inc|cpp/experimental/unique_resource/dsc reset}}

{{dsc h2|Observers}}
{{dsc inc|cpp/experimental/unique_resource/dsc get}}
{{dsc inc|cpp/experimental/unique_resource/dsc get_deleter}}
{{dsc inc|cpp/experimental/unique_resource/dsc operator*}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/experimental/unique_resource/dsc make_unique_resource_checked}}
{{dsc end}}

==={{rl|deduction guides|Deduction guides}}===

===Notes===
Resource handle types satisfying {{named req|NullablePointer}} can also be managed by {{lc|std::unique_ptr}}. Unlike {{tt|unique_ptr}}, {{tt|unique_resource}} does not require {{named req|NullablePointer}}.

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/dsc unique_ptr}}
{{dsc end}}

{{langlinks|ja|ru|zh}}