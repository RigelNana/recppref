{{cpp/experimental/title|invocation_type|raw_invocation_type}}
{{cpp/experimental/lib_extensions/navbar}}

{{dcl begin}}
{{dcl header|experimental/type_traits}}
{{dcl|since=libfund_ts|num=1|
template&lt; class &gt;
struct raw_invocation_type; //undefined

template&lt; class Fn, class... ArgTypes &gt;
struct raw_invocation_type&lt;Fn(ArgTypes...)&gt;;
}}
{{dcl|since=libfund_ts|num=2|
template&lt; class &gt;
struct invocation_type; //undefined

template&lt; class Fn, class... ArgTypes &gt;
struct invocation_type&lt;Fn(ArgTypes...)&gt;;
}}
{{dcl end}}

Computes the ''invocation parameters'' when {{tt|Fn}} is called with the arguments {{tt|ArgTypes...}}, as in {{c|INVOKE(std::declval&lt;Fn&gt;(), std::declval&lt;ArgTypes&gt;()...)}}, where {{c|INVOKE}} is the operation defined in {{named req|Callable}}.

The ''invocation parameters'' of the expression {{c|INVOKE(f, t1, t2, ..., tN)}} is defined as follows, where {{tt|T1}} is the (possibly cv-qualified) type of {{tt|t1}} and {{tt|U1}} is {{tt|T1&amp;}} if {{tt|t1}} is an lvalue and {{tt|T1&amp;&amp;}} otherwise:

* If {{tt|f}} is a pointer to a member function of a class {{tt|T}}, then the invocation parameters are {{tt|U1}} followed by the parameters of {{tt|f}} matched by {{tt|t2, ..., tN}}.
* If {{tt|N {{==}} 1}} and {{tt|f}} is a pointer to member data of a class {{tt|T}}, then the invocation parameter is {{tt|U1}}.
* If {{tt|f}} is an object of class type, the invocation parameters are the parameters matching {{tt|t1, ..., tN}} of the best viable function for the arguments {{tt|t1, ..., tN}} among the function call operators and surrogate call functions of {{tt|f}}.
* In all other cases, the invocations parameters are the parameters of {{tt|f}} matching {{tt|t1, ..., tN}}.

If an argument {{tt|tI}} matches an ellipsis in the function's parameter list, the corresponding invocation parameter is the result of applying the default argument promotions to {{tt|tI}}.

{{tt|Fn}} and all types in {{tt|ArgTypes}} can be any complete type, array of unknown bound, or (possibly cv-qualified) {{tt|void}}.

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc|{{c|raw_invocation_type&lt;Fn(ArgTypes...)&gt;::type}}|{{c|R(T1, T2, ...)}}, where:
* {{tt|R}} is {{c|std::result_of_t&lt;Fn(ArgTypes...)&gt;}}.
* {{tt|T1, T2, ...}} are the ''invocation parameters'' of {{c|INVOKE(std::declval&lt;Fn&gt;(), std::declval&lt;ArgTypes&gt;()...)}} as defined above.
Only defined if {{tt|Fn}} can be called with the arguments {{tt|ArgTypes...}} in unevaluated context. }}
{{dsc|{{c|invocation_type&lt;Fn(ArgTypes...)&gt;::type}}|{{c|R(U1, U2, ...)}}, where
* {{tt|R}} is {{c|std::result_of_t&lt;Fn(ArgTypes...)&gt;}}.
* {{tt|T1, T2, ...}} are the ''invocation parameters'' of {{c|INVOKE(std::declval&lt;Fn&gt;(), std::declval&lt;ArgTypes&gt;()...)}} as defined above.
* {{tt|A1, A2, ...}} denotes {{tt|ArgTypes...}}
* {{tt|Ui}} is {{c|std::decay_t&lt;Ai&gt;}} if {{c|std::declval&lt;Ai&gt;()}} is an rvalue and {{tt|Ti}} otherwise.

Only defined if {{tt|Fn}} can be called with the arguments {{tt|ArgTypes...}} in unevaluated context. }}
{{dsc end}}

===Helper types===
{{dcl begin}}
{{dcl|since=libfund_ts|1=
template&lt; class T &gt;
using raw_invocation_type_t = typename raw_invocation_type&lt;T&gt;::type;
}}
{{dcl|since=libfund_ts|1=
template&lt; class T &gt;
using invocation_type_t = typename invocation_type&lt;T&gt;::type;
}}
{{dcl end}}

===Example===
{{example
|code=
|output=
}}

===See also===
{{dsc begin}}
{{dsc see cpp|cpp/experimental/reflect|Reflection TS|nomono=true}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}