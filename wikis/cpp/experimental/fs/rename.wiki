{{cpp/experimental/fs/title|rename}}
{{cpp/experimental/fs/navbar}}
{{dcl begin}}
{{dcl header|experimental/filesystem}}
{{dcl|since=fs_ts|1=
void rename( const path&amp; old_p, const path&amp; new_p );
void rename( const path&amp; old_p, const path&amp; new_p, std::error_code&amp; ec );
}}
{{dcl end}}

Moves or renames the filesystem object identified by {{c|old_p}} to {{c|new_p}} as if by the POSIX [https://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html rename]:

* If {{c|old_p}} is a non-directory file, then {{c|new_p}} must be one of:
:* the same file as {{c|old_p}} or a hardlink to it: nothing is done in this case.
:* existing non-directory file: {{c|new_p}} is first deleted, then, without allowing other processes to observe {{c|new_p}} as deleted, the pathname {{c|new_p}} is linked to the file and {{c|old_p}} is unlinked from the file. Write permissions are required to both the directory that contains {{c|old_p}} and the directory that contains {{c|new_p}}.
:* non-existing file in an existing directory: The pathname {{c|new_p}} is linked to the file and {{c|old_p}} is unlinked from the file. Write permissions are required to both the directory that contains {{c|old_p}} and the directory that contains {{c|new_p}}.
* If {{c|old_p}} is a directory, then {{c|new_p}} must be one of:
:* the same directory as {{c|old_p}} or a hardlink to it: nothing is done in this case.
:* existing directory: {{c|new_p}} is deleted if empty on POSIX systems, but this may be an error on other systems. If not an error, then {{c|new_p}} is first deleted, then, without allowing other processes to observe {{c|new_p}} as deleted, the pathname {{c|new_p}} is linked to the directory and {{c|old_p}} is unlinked from the directory. Write permissions are required to both the directory that contains {{c|old_p}} and the directory that contains {{c|new_p}}.
:* non-existing directory, not ending with a directory separator, and whose parent directory exists: The pathname {{c|new_p}} is linked to the directory and {{c|old_p}} is unlinked from the directory. Write permissions are required to both the directory that contains {{c|old_p}} and the directory that contains {{c|new_p}}.
* Symlinks are not followed: if {{c|old_p}} is a symlink, it is itself renamed, not its target. If {{c|new_p}} is an existing symlink, it is itself erased, not its target.

Rename fails if
* {{c|new_p}} ends with {{spar|dot}} or with {{spar|dot-dot}}.
* {{c|new_p}} names a non-existing directory ending with a directory separator.
* {{c|old_p}} is a directory which is an ancestor of {{c|new_p}}.

===Parameters===
{{par begin}}
{{par|old_p|path to move or rename}}
{{par|new_p|target path for the move/rename operation}}
{{par|ec|out-parameter for error reporting in the non-throwing overload}}
{{par end}}

===Return value===
(none)

===Exceptions===
{{cpp/experimental/fs/error_handling|old_p|new_p}}

===Example===
{{example
|code=
#include &lt;experimental/filesystem&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
namespace fs = std::experimental::filesystem;

int main()
{
    fs::path p = fs::current_path() / "sandbox";
    fs::create_directories(p/"from");
    std::ofstream(p/"from/file1.txt").put('a');
    fs::create_directory(p/"to");

//  fs::rename(p/"from/file1.txt", p/"to/"); // error: to is a directory
    fs::rename(p/"from/file1.txt", p/"to/file2.txt"); // OK
//  fs::rename(p/"from", p/"to"); // error: to is not empty
    fs::rename(p/"from", p/"to/subdir"); // OK

    fs::remove_all(p);
}
|output=
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/c/dsc rename}}
{{dsc inc|cpp/experimental/fs/dsc remove}}
{{dsc end}}