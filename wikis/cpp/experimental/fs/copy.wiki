{{cpp/experimental/fs/title|copy}}
{{cpp/experimental/fs/navbar}}
{{dcl begin}}
{{dcl header|experimental/filesystem}}
{{dcl|num=1|since=fs_ts|1=
void copy( const path&amp; from, const path&amp; to );
void copy( const path&amp; from, const path&amp; to, error_code&amp; ec );
}}
{{dcl|num=2|since=fs_ts|1=
void copy( const path&amp; from, const path&amp; to, copy_options options );
void copy( const path&amp; from, const path&amp; to, copy_options options, error_code&amp; ec );
}}
{{dcl end}}

Copies files and directories, with a variety of options:

@1@ The default, equivalent to {{v|2}} with {{tt|copy_options::none}} used as {{c|options}}.
@2@ Copies the file or directory {{c|from}} to file or directory {{c|to}}, using the copy options indicated by {{c|options}}. The behavior is undefined if there is more than one option in any of the {{rlp|copy_options}} option group present in {{c|options}} (even in the {{tt|copy_file}} group, which is not relevant to {{tt|copy}}).

The behavior is as follows:
* First, before doing anything else, obtains type and permissions of {{c|from}} by no more than single call to {{ltt|cpp/experimental/fs/status|status}} (or, if {{tt|copy_options::skip_symlinks}} or {{tt|copy_options::create_symlinks}} are present in {{c|options}}, by a call to {{tt|symlink_status}}). 
* If necessary, obtains the status of {{c|to}} the same way, by no more than a single status or symlink_status call.
* If {{c|from}} does not exist, reports an error.
* If {{c|from}} and {{c|to}} are the same file as determined by {{ltt|cpp/experimental/fs/equivalent|equivalent()}}, reports an error.
* If either {{c|from}} or {{c|to}} is not a regular file, a directory, or a symlink, as determined by {{ltt|cpp/experimental/fs/is_other|is_other}}, reports an error.
* If {{c|from}} is a directory, but {{c|to}} is a regular file, reports an error.
* If {{c|from}} is a symbolic link, then
:* If {{tt|copy_options::skip_symlink}} is present in {{c|options}}, does nothing.
:* Otherwise, if {{c|to}} does not exist and {{tt|copy_options::copy_symlinks}} is present in {{c|options}}, then behaves as if {{c|copy_symlink(from, to)}}.
:* Otherwise, reports an error.
* Otherwise, if {{c|from}} is a regular file, then
:* If {{tt|copy_options::directories_only}} is present in {{c|options}}, does nothing.
:* Otherwise, if {{tt|copy_options::create_symlinks}} is present in {{c|options}}, creates a symlink to {{c|to}}. Note: {{c|from}} must be an absolute path unless {{c|to}} is in the current directory.
:* Otherwise, if {{tt|copy_options::create_hard_links}} is present in {{c|options}}, creates a hard link to {{c|to}}.
:* Otherwise, if {{c|to}} is a directory, then behaves as if {{c|copy_file(from, to/from.filename(), options)}} (creates a copy of {{c|from}} as a file in the directory {{c|to}}).
:* Otherwise, behaves as if {{c|copy_file(from, to, options)}} (copies the file).
* Otherwise, if {{c|from}} is a directory and either {{c|options}} has {{tt|copy_options::recursive}} or is {{tt|copy_options::none}}.
:* If {{c|to}} does not exist, first executes {{c|create_directory(to, from)}} (creates the new directory with a copy of the old directory's attributes).
:* Then, whether {{c|to}} already existed or was just created, iterates over the files contained in {{c|from}} as if by {{c|for (const directory_entry&amp; x : directory_iterator(from))}} and for each directory entry, recursively calls {{c|copy(x.path(), to/x.path().filename(), options {{!}} unspecified)}}, where ''unspecified'' is a special bit that has no other effect when set in {{c|options}} (the sole purpose of setting this bit is to prevent recursive copying subdirectories if {{c|options}} is {{tt|copy_options::none}}).
* Otherwise does nothing.

===Parameters===
{{par begin}}
{{par|from|path to the source file, directory, or symlink}}
{{par|to|path to the target file, directory, or symlink}}
{{par|ec|out-parameter for error reporting in the non-throwing overload}}
{{par end}}

===Return value===
(none)

===Exceptions===
{{cpp/experimental/fs/error_handling|from|to}}

===Notes===
The default behavior when copying directories is the non-recursive copy: the files are copied, but not the subdirectories:
{{source|1=
// Given
// /dir1 contains /dir1/file1, /dir1/file2, /dir1/dir2
// and /dir1/dir2 contains /dir1/dir2/file3
// After
std::experimental::filesystem::copy("/dir1", "/dir3");
// /dir3 is created (with the attributes of /dir1)
// /dir1/file1 is copied to /dir3/file1
// /dir1/file2 is copied to /dir3/file2
}}

While with {{tt|copy_options::recursive}}, the subdirectories are also copied, with their content, recursively.
&lt;!-- unclear how that comes from the 15.3[fs.op.copy]/24, but that's what the TS says right after --&gt;
{{source|1=
// ...but after
std::experimental::filesystem::copy("/dir1", "/dir3", copy_options::recursive);
// /dir3 is created (with the attributes of /dir1)
// /dir1/file1 is copied to /dir3/file1
// /dir1/file2 is copied to /dir3/file2
// /dir3/dir2 is created (with the attributes of /dir1/dir2)
// /dir1/dir2/file3 is copied to /dir3/dir2/file3
}}

===Example===
{{cpp/experimental/fs/copy_example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/experimental/fs/dsc copy_options}}
{{dsc inc|cpp/experimental/fs/dsc copy_symlink}}
{{dsc inc|cpp/experimental/fs/dsc copy_file}}
{{dsc end}}