{{cpp/experimental/fs/path/title|concat|operator+{{=}}}}
{{cpp/experimental/fs/path/navbar}}
{{dcl begin}}
{{dcl|num=1|since=fs_ts|1=
path&amp; operator+=( const path&amp; p );
}}
{{dcl|num=2|since=fs_ts|1=
path&amp; operator+=( const string_type&amp; str );
}}
{{dcl|num=3|since=fs_ts|1=
path&amp; operator+=( const value_type* ptr );
}}
{{dcl|num=4|since=fs_ts|1=
path&amp; operator+=( value_type x );
}}
{{dcl|num=5|since=fs_ts|1=
template&lt; class Source &gt;
path&amp; operator+=( const Source&amp; source );
}}
{{dcl|num=6|since=fs_ts|1=
template&lt; class CharT &gt;
path&amp; operator+=( CharT x );
}}
{{dcl|num=7|since=fs_ts|1=
template&lt; class Source &gt;
path&amp; concat( const Source&amp; source );
}}
{{dcl|num=8|since=fs_ts|1=
template&lt; class InputIt &gt;
path&amp; concat( InputIterator first, InputIterator last );
}}
{{dcl end}}

Concatenates the current path and the argument.

@1@ Concatenates {{c|*this}} and {{c|p}} in such a way that {{rlp|native|native()}} of the result is exactly original {{rlp|native|native()}} concatenated with {{c|p.native()}}.
@2@ Same as {{v|1}}, except the resulting {{rlp|native|native()}} is a concatenation of the original {{rlp|native|native()}} and the string {{c|str}}.
@3@ Same as {{v|1}}, except the resulting {{rlp|native|native()}} is a concatenation of the original {{rlp|native|native()}} and the null-terminated string whose first character is pointed to by {{c|ptr}}.
@4@ Same as {{v|1}}, except the resulting {{rlp|native|native()}} is a concatenation of the original {{rlp|native|native()}} and the single character {{c|x}}.
@5@  Same as {{v|1}}, except the resulting {{rlp|native|native()}} is a concatenation of the original {{rlp|native|native()}} and the sequence (which may be in portable or native format) represented by {{c|source}}, which may be {{c|std::basic_string}}, null-terminated multicharacter string, or an input iterator pointing to a null-terminated multicharacter sequence.
@6@ Same as {{v|4}}, except that character conversion may be performed.
@7@ Same as {{v|5}}.
@8@ Same as {{v|5}}, except that the sequence is represented by any iterator pair that designates a multicharacter string.

===Parameters===
{{par begin}}
{{par|p|path to append}}
{{par|str|string to append}}
{{par|ptr|pointer to the beginning of a null-terminated string to append}}
{{par|x|single character to append}}
{{par|source|{{c|std::basic_string}}, null-terminated multicharacter string, or an input iterator pointing to a null-terminated multicharacter sequence, which represents a path name (either in portable or in native format)}}
{{par|first, last|pair of {{named req|InputIterator}}s that specify a multicharacter sequence that represents a path name}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req|The value type of {{tt|InputIt}} must be one of the encoded character types ({{c|char}}, {{c|wchar_t}}, {{c|char16_t}} and {{c|char32_t}}).}}
{{par req|{{tt|CharT}} must be one of the encoded character types ({{c|char}}, {{c|wchar_t}}, {{c|char16_t}} and {{c|char32_t}}).}}
{{par end}}

===Return value===
{{c|*this}}

===Exceptions===
{{cpp/experimental/fs/error_handling_exception_only}}

===Notes===
Unlike with {{lc|append()}} or {{lc|operator/{{=}}}}, additional directory separators are never introduced.

===Example===
{{example|code=
#include &lt;experimental/filesystem&gt;
#include &lt;iostream&gt;
namespace fs = std::experimental::filesystem;

int main()
{
    fs::path p1; // empty path
    p1 += "var"; // does not insert a separator
    std::cout &lt;&lt; "\"\" + \"var\" == " &lt;&lt; p1 &lt;&lt; '\n';
    p1 += "lib"; // does not insert a separator
    std::cout &lt;&lt; "\"\" + \"var\" + \"lib\" == " &lt;&lt; p1 &lt;&lt; '\n';
}
|output=
"" + "var" == "var"
"" + "var" + "lib" == "varlib"
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/experimental/fs/path/dsc append}}
{{dsc inc|cpp/experimental/fs/path/dsc operator/}}
{{dsc end}}