{{cpp/experimental/ranges/title|invoke}}
{{cpp/experimental/ranges/utility/navbar}}
{{ddcl|header=experimental/ranges/functional|since=ranges|1=
template&lt; class F, class... Args &gt;
std::result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt; invoke( F&amp;&amp; f, Args&amp;&amp;... args );
}}

Invoke the {{named req|Callable}} object {{c|f}} with the parameters {{c|args}}, and return the result, as if by {{c|return INVOKE(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);}}, where ''INVOKE(f, t1, t2, ..., tN)'' is defined as follows:
* if {{c|f}} is a [[cpp/language/pointer#Pointers_to_member_functions|pointer to member function]] of class {{tt|T}}:
:* If {{c|1=std::is_base_of&lt;T, std::decay_t&lt;decltype(t1)&gt;&gt;::value}} is {{c|true}}, then {{c|INVOKE(f, t1, t2, ..., tN)}} is equivalent to {{c|(t1.*f)(t2, ..., tN)}},
:* otherwise, {{c|INVOKE(f, t1, t2, ..., tN)}} is equivalent to {{c|((*t1).*f)(t2, ..., tN)}}.
* otherwise, if N == 1 and {{c|f}} is a [[cpp/language/pointer#Pointers_to_data_members|pointer to data member]] of class {{tt|T}}:
:* If {{c|1=std::is_base_of&lt;T, std::decay_t&lt;decltype(t1)&gt;&gt;::value}} is {{c|true}}, then {{c|INVOKE(f, t1)}} is equivalent to {{c|t1.*f}},
:* otherwise, then {{c|INVOKE(f, t1)}} is equivalent to {{c|(*t1).*f}}.
* otherwise, {{c|INVOKE(f, t1, t2, ..., tN)}} is equivalent to {{c|f(t1, t2, ..., tN)}} (that is, {{c|f}} is a {{named req|FunctionObject}}).

===Parameters===
{{par begin}}
{{par|f|{{named req|Callable}} object to be invoked}}
{{par|args|arguments to pass to {{c|f}}}}
{{par end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc invoke}}
{{dsc end}}

{{langlinks|zh}}