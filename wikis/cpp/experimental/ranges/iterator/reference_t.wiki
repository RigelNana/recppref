{{cpp/experimental/ranges/title|reference_t|rvalue_reference_t|iter_common_reference_t}}
{{cpp/experimental/ranges/iterator/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/iterator}}
{{dcl|notes={{mark expos}}|1=
template&lt; class T &gt;
concept bool /*dereferenceable*/ = requires(T&amp; t) { {*t} -&gt; auto&amp;&amp;; };
}}
{{dcl|num=1|since=ranges|1=
template&lt; /*dereferenceable*/ T &gt; 
using reference_t = decltype(*declval&lt;T&amp;&gt;());
}}
{{dcl|num=2|since=ranges|1=
template&lt; /*dereferenceable*/ T &gt;
    requires requires(T&amp; t) { { ranges::iter_move(t) } -&gt; auto&amp;&amp;; }
using rvalue_reference_t = decltype(ranges::iter_move(declval&lt;T&amp;&gt;()));
}}
{{dcl|num=3|since=ranges|1=
template&lt; Readable T &gt; 
using iter_common_reference_t = ranges::common_reference_t&lt;ranges::reference_t&lt;T&gt;,
                                                           ranges::value_type_t&lt;T&gt;&amp;&gt;;
}}
{{dcl end}}

@1@ Obtain the ''reference type'' of a dereferenceable type {{tt|T}}.
@2@ Obtain the ''rvalue reference type'' of a dereferenceable type {{tt|T}}, that is, the return type of {{lc|ranges::iter_move}}.
@3@ Compute a {{rconcept|Readable}} type's ''common reference type''. This is the common reference type of its reference type and an lvalue reference to its value type.

===Notes===
The {{c|-&gt; auto&amp;&amp;}} constraint checks that the type of the expression is not {{c|void}}.

{{langlinks|ja|zh}}