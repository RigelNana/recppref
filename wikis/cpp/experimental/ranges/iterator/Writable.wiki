{{cpp/experimental/ranges/title|Writable}}
{{cpp/experimental/ranges/iterator/navbar}}
{{ddcl|header=experimental/ranges/iterator|since=ranges|1=
template&lt; class Out, class T &gt;
concept bool Writable =
    requires(Out&amp;&amp; o, T&amp;&amp; t) {
        *o = std::forward&lt;T&gt;(t);
        *std::forward&lt;Out&gt;(o) = std::forward&lt;T&gt;(t);
        const_cast&lt;const ranges::reference_t&lt;Out&gt;&amp;&amp;&gt;(*o) =
            std::forward&lt;T&gt;(t); 
        const_cast&lt;const ranges::reference_t&lt;Out&gt;&amp;&amp;&gt;(*std::forward&lt;Out&gt;(o)) =
            std::forward&lt;T&gt;(t);
    };
    /* none of the four expressions above are required to be equality-preserving */
}}

The concept {{tt|Writable&lt;Out, T&gt;}} specifies the requirements for writing a value whose type and value category are encoded by {{tt|T}} into an iterator {{tt|Out}}'s referenced object.

Let {{tt|E}} be an expression such that {{c|decltype((E))}} is {{tt|T}}, and {{c|o}} be a dereferenceable object of type {{tt|Out}}, then {{tt|Writable&lt;Out, T&gt;}} is satisfied only if:
* If {{c|Readable&lt;Out&gt; &amp;&amp; Same&lt;ranges::value_type_t&lt;Out&gt;, std::decay_t&lt;T&gt;&gt;}} is satisfied, then {{c|*o}} after any above assignment is equal to the value of {{tt|E}} before the assignment.

{{c|o}} is not required to be dereferenceable after evaluating any of the assignment expressions above. If {{tt|E}} is an xvalue, the resulting state of the object it denotes is valid but unspecified.

{{cpp/experimental/ranges/equality preservation|skip-requires=yes}}

===Notes===
The only valid use of {{c|operator*}} is on the left side of an assignment expression. Assignment through the same value of a writable type may happen only once.

The required expressions with {{c/core|const_cast}} prevent {{rconcept|Readable}} objects with prvalue {{tt|reference}} types from satisfying the syntactic requirements of {{tt|Writable}} by accident, while permitting proxy references to continue to work as long as their constness is shallow. See [https://github.com/ericniebler/stl2/issues/381 Ranges TS issue 381].

{{langlinks|zh}}