{{cpp/experimental/ranges/title|RandomAccessIterator}}
{{cpp/experimental/ranges/iterator/navbar}}
{{ddcl|header=experimental/ranges/iterator|since=ranges|1=
template&lt; class I &gt;
concept bool RandomAccessIterator =
    BidirectionalIterator&lt;I&gt; &amp;&amp;
    DerivedFrom&lt;ranges::iterator_category_t&lt;I&gt;, ranges::random_access_iterator_tag&gt; &amp;&amp;
    StrictTotallyOrdered&lt;I&gt; &amp;&amp;
    SizedSentinel&lt;I, I&gt; &amp;&amp;
    requires(I i, const I j, const ranges::difference_type_t&lt;I&gt; n) {
        { i += n } -&gt; Same&lt;I&gt;&amp;;
        { j + n }  -&gt; Same&lt;I&gt;&amp;&amp;;
        { n + j }  -&gt; Same&lt;I&gt;&amp;&amp;;
        { i -= n } -&gt; Same&lt;I&gt;&amp;;
        { j - n }  -&gt; Same&lt;I&gt;&amp;&amp;;
        j[n];
        requires Same&lt;decltype(j[n]), ranges::reference_t&lt;I&gt;&gt;;
    };
}}

The concept {{tt|RandomAccessIterator&amp;lt;I&amp;gt;}} refines {{rconcept|BidirectionalIterator}} by adding support for constant time advancement with the {{tt|1=+=}}, {{tt|+}}, {{tt|1=-=}}, and {{tt|-}} operators, constant time computation of distance with {{tt|-}}, and array notation with subscripting.

Let {{tt|a}} and {{tt|b}} be valid iterators of type {{tt|I}} such that {{tt|b}} is reachable from {{tt|a}}, and let {{tt|n}} be a value of type {{c|ranges::difference_type_t&lt;I&gt;}} equal to {{c|b - a}}. {{tt|RandomAccessIterator&amp;lt;I&amp;gt;}} is satisfied only if:
* {{c|1=(a += n)}} is equal to {{c|b}}.
* {{c|1=std::addressof(a += n)}} is equal to {{c|std::addressof(a)}}.
* {{c|(a + n)}} is equal to {{c|1=(a += n)}}.
* {{c|(a + n)}} is equal to {{c|(n + a)}}.
* For any two positive integers {{tt|x}} and {{tt|y}}, if {{c|a + (x + y)}} is valid, then {{c|a + (x + y)}} is equal to {{c|(a + x) + y}}.
* {{c|a + 0}} is equal to {{c|a}}.
* If {{c|(a + (n - 1))}} is valid, then {{c|--b}} is equal to {{c|(a + (n - 1))}}.
* {{c|1=(b += -n)}} and {{c|1=(b -= n)}} are both equal to {{c|a}}.
* {{c|1=std::addressof(b -= n)}} is equal to {{c|std::addressof(b)}}.
* {{c|(b - n)}} is equal to {{c|1=(b -= n)}}.
* If {{c|b}} is dereferenceable, then {{c|a[n]}} is valid and is equal to {{c|*b}}.
* {{c|1=bool(a &lt;= b)}} is {{c|true}} &lt;!-- https://github.com/ericniebler/stl2/issues/502 --&gt;.

{{cpp/experimental/ranges/equality preservation}}
{{cpp/experimental/ranges/note implicit expression variations}}

{{langlinks|zh}}