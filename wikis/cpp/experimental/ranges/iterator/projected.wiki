{{cpp/experimental/ranges/title|projected}}
{{cpp/experimental/ranges/iterator/navbar}}
{{ddcl|since=ranges|header=experimental/ranges/iterator|1=
template&lt; Readable I, IndirectRegularUnaryInvocable&lt;I&gt; Proj &gt;
struct projected {
    using value_type =
        std::remove_cv_t&lt;std::remove_reference_t&lt;ranges::indirect_result_of_t&lt;Proj&amp;(I)&gt;&gt;&gt;;
    ranges::indirect_result_of_t&lt;Proj&amp;(I)&gt; operator*() const;
};

template&lt; WeaklyIncrementable I, class Proj &gt;
struct difference_type&lt;projected&lt;I, Proj&gt;&gt; {
    using type = ranges::difference_type_t&lt;I&gt;;
};
}}

The class template {{tt|projected}} bundles a {{rconcept|Readable}} type {{tt|I}} and a function {{tt|Proj}} into a new {{tt|Readable}} type whose {{tt|reference}} type is the result of applying {{tt|Proj}} to the {{tt|reference}} type of {{tt|I}}. It exists solely to ease constraint specification, and so its {{c|operator*()}} may not be actually defined.

{{langlinks|zh}}