{{cpp/experimental/ranges/title|dangling|safe_iterator_t}}
{{cpp/experimental/ranges/iterator/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/iterator}}
{{dcl|since=ranges|1=
template&lt; CopyConstructible T &gt;
class dangling {
public:
    dangling() requires DefaultConstructible&lt;T&gt;();
    dangling(T t);
    T get_unsafe() const;
};
}}
{{dcl|since=ranges|1=
template&lt; Range R &gt;
using safe_iterator_t = std::conditional_t&lt;std::is_lvalue_reference&lt;R&gt;::value,
                                           ranges::iterator_t&lt;R&gt;,
                                           ranges::dangling&lt;ranges::iterator_t&lt;R&gt;&gt;;
}}
{{dcl end}}

The class template {{tt|dangling}} is a simple wrapper around an object to indicate that the wrapped object may be ''dangling'', that is, it refers to another object whose lifetime may have ended.

The alias template {{tt|safe_iterator_t}} returns the iterator type of {{tt|R}}, wrapped in {{tt|dangling}} if the range was an rvalue range (as indicated by {{tt|R}} not being an lvalue reference type).

They are used by range algorithms that accept rvalue ranges and return iterators into them.

===Member functions===
{{member|{{small|std::experimental::ranges::dangling::}}dangling|2=
{{dcl begin}}
{{dcl|num=1|1=
dangling() requires DefaultConstructible&lt;T&gt;();
}}
{{dcl|num=2|1=
dangling(T t);
}}
{{dcl end}}
@1@ Default constructor. Value-initializes the wrapped object.
@2@ Initializes the wrapped object with {{tt|t}}. Note that this constructor defines an implicit conversion from {{tt|T}} to {{tt|dangling&lt;T&gt;}}.
}}

{{member|{{small|std::experimental::ranges::dangling::}}get_unsafe|2=
{{ddcl|
T get_unsafe() const;
}}
Returns a copy of the wrapped object.
}}

{{langlinks|zh}}