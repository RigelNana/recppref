{{cpp/experimental/ranges/title|WeaklyIncrementable}}
{{cpp/experimental/ranges/iterator/navbar}}
{{ddcl|header=experimental/ranges/iterator|since=ranges|1=
template&lt; class I &gt;
concept bool WeaklyIncrementable =
    Semiregular&lt;I&gt; &amp;&amp;
    requires(I i) {
        typename ranges::difference_type_t&lt;I&gt;;
        requires SignedIntegral&lt;ranges::difference_type_t&lt;I&gt;&gt;;
        { ++i } -&gt; Same&lt;I&gt;&amp;; /* not required to be equality preserving */
        i++; /* not required to be equality preserving */
    };
}}

The concept {{tt|WeaklyIncrementable&amp;lt;I&amp;gt;}} specifies the requirements on a type that can be incremented (with the pre- and post-increment operators). The increment operations need not be equality-preserving, and the type need not be {{rconcept|EqualityComparable}}.

Let {{c|i}} be an object of type {{tt|I}}. {{c|i}} is said to be ''incrementable'' if it is in the domain of both pre- and post-increment. {{tt|WeaklyIncrementable&amp;lt;I&amp;gt;}} is satisfied only if:
* {{c|++i}} and {{c|i++}} have the same domain;
* If {{c|i}} is incrementable, then:
** {{c|++i}} and {{c|i++}} both advance {{c|i}} to the next element; and
** {{c|++i}} refers to the same object as {{c|i}}.

{{cpp/experimental/ranges/equality preservation|skip-requires=yes}}

===Notes===
For {{tt|WeaklyIncrementable}} types, {{c|a}} equals {{c|b}} does not imply that {{c|++a}} equals {{c|++b}}. Algorithms on such types should be single pass and never attempt to pass through the same value twice.

{{langlinks|zh}}