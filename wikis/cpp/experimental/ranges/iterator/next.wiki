{{cpp/experimental/ranges/title|next}}
{{cpp/experimental/ranges/iterator/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/iterator}}
{{dcl|notes={{mark|customization point object}}|since=ranges|1=
namespace {
    constexpr /* unspecified */ next = /* unspecified */;
}
}}
{{dcl h|Call signature}}
{{dcl|num=1|
template&lt; Iterator I &gt;
constexpr I next( I i );
}}
{{dcl|num=2|
template&lt; Iterator I &gt;
constexpr I next( I i, ranges::difference_type_t&lt;I&gt; n );
}}
{{dcl|num=3|
template&lt; Iterator I, Sentinel&lt;I&gt; S &gt;
constexpr I next( I i, S bound );
}}
{{dcl|num=4|
template&lt; Iterator I, Sentinel&lt;I&gt; S &gt;
constexpr I next( I i, ranges::difference_type_t&lt;I&gt; n, S bound );
}}
{{dcl end}}

Advances the iterator {{c|i}} {{c|n}} times, or until {{c|bound}} is reached, whichever comes first, and returns the advanced iterator.

@1@ Equivalent to {{c|++i; return i;}}.
@2@ Equivalent to {{c|ranges::advance(i, n); return i;}}.
@3@ Equivalent to {{c|ranges::advance(i, bound); return i;}}.
@4@ Equivalent to {{c|ranges::advance(i, n, bound); return i;}}.

{{cpp/experimental/ranges/cpo}}

===Return value===
The advanced iterator.

===Notes===
Even though omitting {{c|n}} for overload {{v|2}} behaves as if {{c|n}} is 1, omitting {{c|n}} for overload {{v|4}} effectively behaves as if {{c|n}} is infinity (always advance to {{c|bound}}).

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc next}}
{{dsc inc|cpp/experimental/ranges/iterator/dsc advance}}
{{dsc inc|cpp/experimental/ranges/iterator/dsc prev}}
{{dsc inc|cpp/experimental/ranges/iterator/dsc distance}}
{{dsc end}}

{{langlinks|ja|zh}}