{{cpp/experimental/ranges/title|ForwardIterator}}
{{cpp/experimental/ranges/iterator/navbar}}
{{ddcl|header=experimental/ranges/iterator|since=ranges|1=
template&lt; class I &gt;
concept bool ForwardIterator =
    InputIterator&lt;I&gt; &amp;&amp;
    DerivedFrom&lt;ranges::iterator_category_t&lt;I&gt;, ranges::forward_iterator_tag&gt; &amp;&amp;
    Incrementable&lt;I&gt; &amp;&amp;
    Sentinel&lt;I, I&gt;;
}}

The concept {{tt|ForwardIterator&amp;lt;I&amp;gt;}} refines {{rconcept|InputIterator}} by adding equality comparison and the multi-pass guarantee.

The domain of {{tt|1===}} for forward iterators is that of iterators over the same underlying sequence, except that value-initialized iterators of the same type may be compared with each other and shall compare equal.

Pointers and references obtained from a forward iterator into a range {{range|i|s}} must remain valid while {{range|i|s}} continues to denote a range. 

Let {{tt|a}} and {{tt|b}} be two dereferenceable iterators of type {{tt|I}}. {{tt|ForwardIterator&amp;lt;I&amp;gt;}} is satisfied only if:
* {{c|1= a == b }} implies {{c|1= ++a == ++b}}; and
* The expression {{c|([](X x){ ++x; }(a), *a)}} is equivalent to {{c|*a}}, i.e., incrementing a copy of {{tt|a}} has no effect on the result of dereferencing {{tt|a}}.
This is known as the ''multi-pass guarantee''.

===Notes===
A forward iterator cannot be "stashing": it cannot return a reference to an object within itself, because such references would be invalidated by the destruction of the forward iterator.

{{langlinks|zh}}