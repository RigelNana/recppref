{{cpp/experimental/ranges/title|for_each}}
{{cpp/experimental/ranges/algorithm/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/algorithm}}
{{dcl|since=ranges|num=1|1=
template&lt; InputIterator I, Sentinel&lt;I&gt; S, class Proj = ranges::identity,
          IndirectUnaryInvocable&lt;projected&lt;I, Proj&gt;&gt; Fun &gt;
ranges::tagged_pair&lt;tag::in(I), tag::fun(Fun)&gt;
    for_each( I first, S last, Fun f, Proj proj = Proj{} );
}}
{{dcl|since=ranges|num=2|1=
template&lt; InputRange R, class Proj = ranges::identity,
          IndirectUnaryInvocable&lt;projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Fun &gt;
ranges::tagged_pair&lt;tag::in(ranges::safe_iterator_t&lt;R&gt;), tag::fun(Fun)&gt;
    for_each( R&amp;&amp; r, Fun f, Proj proj = Proj{} );
}}
{{dcl end}}

@1@ Invokes the given function object {{c|f}} to the result of invoking the projection {{c|proj}} on dereferencing every iterator in the range {{range|first|last}} (i.e.,{{c|ranges::invoke(f, ranges::invoke(proj, *i))}}), in order. 
@2@ Same as {{v|1}}, but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

For both overloads, if the iterator type is mutable, {{c|f}} may modify the elements of the range through the dereferenced iterator. If {{c|f}} returns a result, the result is ignored.

Unlike the rest of the algorithms, for_each is not allowed to make copies of the elements in the sequence even if they are trivially copyable.

Unlike {{lc|std::for_each}} (which requires only {{named req|MoveConstructible}}), these functions require {{tt|Fun}} to model {{rconcept|CopyConstructible}}.

{{cpp/experimental/ranges/algorithm/tparams}}

===Parameters===
{{par begin}}
{{par|first, last|the range to apply the function to}}
{{par|r|the range to apply the function to}}
{{par|f|callable object to be applied to each projected element in the range}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
A {{tt|tagged_pair}} object containing the following two members:
* The first member, with the tag {{tt|tag::in}}, is the past-the-end iterator of the source range (that is, an iterator of type {{tt|I}} that compares equal to the sentinel {{c|last}}).
* The second member, with the tag {{tt|tag::fun}}, is initialized from {{tt|std::move(f)}} (after all applications of the function object).

===Complexity===
Exactly {{c|last}} - {{c|first}} applications of {{c|f}} and {{c|proj}}.

===Possible implementation===
{{eq fun|1=
template&lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = ranges::identity,
         IndirectUnaryInvocable&lt;ranges::projected&lt;I, Proj&gt;&gt; Fun&gt;
auto for_each(I first, S last, Fun f, Proj proj = Proj{}) 
    -&gt; ranges::tagged_pair&lt;tag::in(I), tag::fun(Fun)&gt;
{
    for (; first != last; ++first)
        ranges::invoke(f, ranges::invoke(proj, *first));
    return {std::move(first), std::move(f)};
}
}}

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc transform}}
{{dsc inc|cpp/language/dsc range-for}}
{{dsc inc|cpp/algorithm/dsc for_each}}
{{dsc inc|cpp/algorithm/dsc for_each_n}}
{{dsc end}}

{{langlinks|ja|zh}}