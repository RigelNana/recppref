{{cpp/experimental/ranges/title|is_permutation}}
{{cpp/experimental/ranges/algorithm/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/algorithm}}
{{dcl|since=ranges|num=1|1=
template&lt; ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2, Sentinel&lt;I2&gt; S2,
          class Pred = ranges::equal_to&lt;&gt;, 
          class Proj1 = ranges::identity, class Proj2 = ranges::identity &gt;
    requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
bool is_permutation( I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{}, 
                     Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );
}}
{{dcl|since=ranges|num=2|1=
template&lt; ForwardRange R1, ForwardRange R2, class Pred = ranges::equal_to&lt;&gt;,
          class Proj1 = ranges::identity, class Proj2 = ranges::identity &gt;
    requires IndirectlyComparable&lt;ranges::iterator_t&lt;R1&gt;, ranges::iterator_t&lt;R2&gt;,
                                  Pred, Proj1, Proj2&gt;
bool is_permutation( R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = Pred{},
                     Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );
}}
{{dcl|since=ranges|num=3|notes={{mark deprecated}}|1=
template&lt; ForwardIterator I1, Sentinel&lt;I1&gt; S1, class I2,
          class Pred = ranges::equal_to&lt;&gt;, 
          class Proj1 = ranges::identity, class Proj2 = ranges::identity &gt;
    requires ForwardIterator&lt;std::decay_t&lt;I2&gt;&gt; &amp;&amp; !Range&lt;I2&gt; &amp;&amp;
             IndirectlyComparable&lt;I1, std::decay_t&lt;I2&gt;, Pred, Proj1, Proj2&gt;
bool is_permutation( I1 first1, S1 last1, I2&amp;&amp; first2_, Pred pred = Pred{},
                     Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );

}}
{{dcl|since=ranges|num=4|notes={{mark deprecated}}|1=
template&lt; ForwardRange R1, class I2, class Pred = ranges::equal_to&lt;&gt;,
          class Proj1 = ranges::identity, class Proj2 = ranges::identity &gt;
    requires ForwardIterator&lt;std::decay_t&lt;I2&gt;&gt; &amp;&amp; !Range&lt;I2&gt; &amp;&amp;
             IndirectlyComparable&lt;ranges::iterator_t&lt;R1&gt;, std::decay_t&lt;I2&gt;, Pred, Proj1, Proj2&gt;
bool is_permutation( R1&amp;&amp; r1, I2&amp;&amp; first2_, Pred pred = Pred{}, 
                     Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{} );
}}
{{dcl end}}

@1@ Returns {{c|true}} if there exists a permutation of the elements in range {{range|first1|last1}} that makes the range equal to {{range|first2|last2}}, and {{c|false}} otherwise.

@2@ Same as {{v|1}}, but uses {{c|r1}} as the first source range and {{c|r2}} as the second source range, as if using {{c|ranges::begin(r1)}} as {{c|first1}}, {{c|ranges::end(r1)}} as {{c|last1}}, {{c|ranges::begin(r2)}} as {{c|first2}}, and {{c|ranges::end(r2)}} as {{c|last2}}.

@3@ Same as {{v|1}}, except that {{c|first2}} is defined as if by {{c|std::decay_t&lt;I2&gt; first2 {{=}} std::forward&lt;I2&gt;(first2_);}} and {{c|last2}} is {{c|first2 + (last1 - first1)}}.

@4@ Same as {{v|3}}, but uses {{c|r1}} as the first source range, as if using {{c|ranges::begin(r1)}} as {{c|first1}} and {{c|ranges::end(r1)}} as {{c|last1}}. 

Two ranges are considered equal if they have the same number of elements and, for every iterator {{tt|i}} in the range {{range|first1|last1}}, {{c|ranges::invoke(pred, ranges::invoke(proj1, *i), ranges::invoke(proj2, *(first2 + (i - first1))))}} is {{c|true}}. 

{{cpp/experimental/ranges/algorithm/tparams}}

===Parameters===
{{par begin}}
{{par|first1, last1|the first range of the elements}}
{{par|r1|the first range of the elements}}
{{par|first2, last2|the second range of the elements}}
{{par|r2|the second range of the elements}}
{{par|first2_|the beginning of the second range of the elements}}
{{par|pred|predicate to apply to the projected elements}}
{{par|proj1|projection to apply to the elements in the first range}}
{{par|proj2|projection to apply to the elements in the second range}}
{{par end}}

===Return value===
{{c|true}} if the range {{range|first1|last1}} is a permutation of the range {{range|first2|last2}}.

===Complexity===
At most {{math|O(N&lt;sup&gt;2&lt;/sup&gt;)}} applications of the predicate and each projection, or exactly {{math|N}} if the sequences are already equal, where {{c|1=N = last1 - first1}}. 

However if {{c|SizedSentinel&lt;S1, I1&gt; &amp;&amp; SizedSentinel&lt;S2, I2&gt;}} is satisfied and {{c|last1 - first1 !{{=}} last2 - first2}}, no applications of the predicate and projections are made.

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc is_permutation}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc next_permutation}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc prev_permutation}}
{{dsc end}}