{{cpp/experimental/ranges/title|adjacent_find}}
{{cpp/experimental/ranges/algorithm/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/algorithm}}
{{dcl|since=ranges|num=1|1=
template&lt; ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = ranges::identity,
          IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; Pred = ranges::equal_to&lt;&gt; &gt;
I adjacent_find( I first, S last, Pred pred = Pred{}, Proj proj = Proj{} );
}}
{{dcl|since=ranges|num=2|1=

template&lt; ForwardRange R, class Proj = ranges::identity,
          IndirectRelation&lt;projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred = ranges::equal_to&lt;&gt; &gt;
ranges::safe_iterator_t&lt;R&gt; adjacent_find( R&amp;&amp; r, Pred pred = Pred{}, Proj proj = Proj{} );

}}
{{dcl end}}

@1@ Searches the range {{range|first|last}} for two consecutive identical elements. Elements are compared using {{c|pred}} after being projected with {{c|proj}}.
@2@ Same as {{v|1}}, but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/experimental/ranges/algorithm/tparams}}
===Parameters===
{{par begin}}
{{par|first, last|the range of elements to examine}}
{{par|r|the range of elements to examine}}
{{par|pred|predicate to use to compare the projected elements}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
An iterator to the first of the first pair of identical elements, that is, the first iterator {{tt|i}} such that both {{tt|i}} and {{tt|i + 1}} are in the range {{range|first|last}} and {{c|ranges::invoke(pred, ranges::invoke(proj, *i), ranges::invoke(proj, *(i + 1))) !{{=}} false}}.

If no such elements are found, an iterator that compares equal to {{c|last}} is returned.

===Complexity===
If the range is nonempty, exactly {{tt|min((result - first) + 1, (last - first) - 1)}} applications of the predicate where {{tt|result}} is the return value, and at most twice as many applications of the projection.

===Possible implementation===
{{eq fun
|1=
template&lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = ranges::identity,
         IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; Pred = ranges::equal_to&lt;&gt;&gt;
I adjacent_find(I first, S last, Pred pred = Pred{}, Proj proj = Proj{})
{
    if (first == last)
        return first;
    I next = first;
    ++next;
    while (next != last)
    {
        if (ranges::invoke(pred, ranges::invoke(proj, *first),
                                 ranges::invoke(proj, *next)))
            return first;
        ++next;
        ++first;
    }
    return next;
}
}}

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc adjacent_find}}
{{dsc inc|cpp/experimental/ranges/algorithm/dsc unique}}
{{dsc end}}