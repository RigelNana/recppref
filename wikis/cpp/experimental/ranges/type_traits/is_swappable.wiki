{{cpp/experimental/ranges/title|is_swappable_with|is_swappable|is_nothrow_swappable_with|is_nothrow_swappable}}
{{cpp/experimental/ranges/utility/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/type_traits}}
{{dcl|num=1|since=ranges|1=
template&lt; class T, class U &gt;
struct is_swappable_with;
}}
{{dcl|num=2|since=ranges|1=
template&lt; class T &gt;
struct is_swappable;
}}
{{dcl|num=3|since=ranges|1=
template&lt; class T, class U &gt;
struct is_nothrow_swappable_with;
}}
{{dcl|num=4|since=ranges|1=
template&lt; class T &gt;
struct is_nothrow_swappable;
}}
{{dcl end}}
@1@ If the expressions {{c|ranges::swap(std::declval&lt;T&gt;(), std::declval&lt;U&gt;())}} and {{c|ranges::swap(std::declval&lt;U&gt;(), std::declval&lt;T&gt;())}} are both well-formed when treated as an unevaluated operand, provides the member constant {{tt|value}} equal {{c|true}}. Otherwise, {{tt|value}} is {{c|false}}. [[cpp/language/access|Access checks]] are performed as if from a context unrelated to either type. 
@2@ If {{tt|T}} is not a referenceable type (i.e., possibly cv-qualified {{c|void}} or a function type with a ''cv-qualifier-seq'' or a ''ref-qualifier''), provides a member constant {{tt|value}} equal to {{c|false}}. Otherwise, provides a member constant {{tt|value}} equal to {{c|ranges::is_swappable_with&lt;T&amp;, T&amp;&gt;::value}}.
@3@ Same as {{v|1}}, but evaluations of both expressions from {{v|1}} are known not to throw exceptions.
@4@ Same as {{v|2}}, but uses {{c|is_nothrow_swappable_with}}.

{{tt|T}} and {{tt|U}} shall each be a complete type, (possibly cv-qualified) {{c|void}}, or an array of unknown bound. Otherwise, the behavior is undefined.

===Helper variable templates===
{{dcl begin}}
{{dcl|num=1|since=ranges|1=
template&lt; class T, class U &gt;
constexpr bool is_swappable_with_v = is_swappable_with&lt;T, U&gt;::value;
}}
{{dcl|num=2|since=ranges|1=
template&lt; class T &gt;
constexpr bool is_swappable_v = is_swappable&lt;T&gt;::value;
}}
{{dcl|num=3|since=ranges|1=
template&lt; class T, class U &gt;
constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with&lt;T, U&gt;::value;
}}
{{dcl|num=4|since=ranges|1=
template&lt; class T &gt;
constexpr bool is_nothrow_swappable_v = is_nothrow_swappable&lt;T&gt;::value;
}}
{{dcl end}}

{{cpp/types/integral_constant/inherit|{{tt|T}} is swappable with {{tt|U}}}}

===Notes===
This trait does not check anything outside the immediate context of the swap expressions: if the use of {{tt|T}} or {{tt|U}} would trigger template specializations, generation of implicitly-defined special member functions etc, and those have errors, the actual swap may not compile even if {{tt|ranges::is_swappable_with&lt;T,U&gt;::value}} compiles and evaluates to {{c|true}}.

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/experimental/ranges/concepts/dsc Swappable}}
{{dsc inc|cpp/types/dsc is_swappable}}
{{dsc end}}

{{langlinks|zh}}