{{cpp/experimental/ranges/title|common_type}}
{{cpp/experimental/ranges/utility/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/type_traits}}
{{dcl|since=ranges|1=
template&lt; class... T &gt;
struct common_type;
}}
{{dcl end}}

Determines the common type among all types {{tt|T...}}, that is the type all {{tt|T...}} can be implicitly converted to. If such a type exists (as determined according to the rules below), the member {{tt|type}} names that type. Otherwise, there is no member {{tt|type}}. The behavior is undefined if any of the types in {{tt|T...}} is an incomplete type other than (possibly cv-qualified) {{c|void}}. 

* If {{c|sizeof...(T)}} is zero, there is no member {{tt|type}}.
* If {{c|sizeof...(T)}} is one (i.e., {{tt|T...}} contains only one type {{tt|T0}}), the member {{tt|type}} names the same type as {{c|std::decay_t&lt;T0&gt;}}.
* If {{c|sizeof...(T)}} is two (i.e., {{tt|T...}} contains exactly two types {{tt|T1}} and {{tt|T2}}),
:* If applying {{lc|std::decay}} to at least one of {{tt|T1}} and {{tt|T2}} produces a different type, the member {{tt|type}} names the same type as {{c|ranges::common_type_t&lt;std::decay_t&lt;T1&gt;, std::decay_t&lt;T2&gt;&gt;}}, if it exists; if not, there is no member {{tt|type}};
:* Otherwise, (and unless there is a user specialization for {{c|ranges::common_type&lt;T1, T2&gt;}}), if {{c|std::common_type_t&lt;T1, T2&gt;}} is well-formed, then the member {{tt|type}} denotes that type;
:* Otherwise, the member {{tt|type}} denotes the type {{c|std::decay_t&lt;decltype(false ? std::declval&lt;const T1&amp;&gt;() : std::declval&lt;const T2&amp;&gt;())&gt;}}, if that conditional expression is well-formed; if not, there is no member {{tt|type}}.
* If {{c|sizeof...(T)}} is greater than two (i.e., {{tt|T...}} consists of the types {{tt|T1, T2, R...}}), then if {{c|ranges::common_type_t&lt;T1, T2&gt;}} exists, the member {{tt|type}} denotes {{c|ranges::common_type_t&lt;ranges::common_type_t&lt;T1, T2&gt;, R...&gt;}} if such a type exists. In all other cases, there is no member {{tt|type}}.

===Member types===
{{dsc begin}}
{{dsc hitem|Name|Definition}}
{{dsc|{{tt|type}}|the common type for all {{tt|T...}}}}
{{dsc end}}

===Helper types===
{{dcl begin}}
{{dcl|1=
template&lt; class... T &gt;
using common_type_t = typename common_type&lt;T...&gt;::type;
}}
{{dcl end}}

===Specializations===
Users may specialize {{tt|common_type}} for types {{tt|T1}} and {{tt|T2}} if
* At least one of {{tt|T1}} and {{tt|T2}} depends on a user-defined type, and
* {{lc|std::decay}} is an identity transformation for both {{tt|T1}} and {{tt|T2}}.

If such a specialization has a member named {{tt|type}}, it must be a public and unambiguous member type that names a cv-unqualified non-reference type to which both {{tt|T1}} and {{tt|T2}} are explicitly convertible. Additionally, {{c|ranges::common_type_t&lt;T1, T2&gt;}} and {{c|ranges::common_type_t&lt;T2, T1&gt;}} must denote the same type.

A program that adds {{tt|common_type}} specializations in violation of these rules has undefined behavior.

===Notes===
For arithmetic types not subject to promotion, the common type may be viewed as the type of the (possibly mixed-mode) arithmetic expression such as {{c|T0() + T1() + ... + Tn()}}.

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc common_type}}
{{dsc inc|cpp/experimental/ranges/type_traits/dsc common_reference}}
{{dsc end}}

{{langlinks|zh}}