{{cpp/experimental/ranges/title|Boolean}}
{{cpp/experimental/ranges/concepts/navbar}}
{{ddcl|header=experimental/ranges/concepts|since=ranges|1=
template&lt; class B &gt;
concept bool Boolean =
    Movable&lt;std::decay_t&lt;B&gt;&gt; &amp;&amp;
    requires(const std::remove_reference_t&lt;B&gt;&amp; b1,
             const std::remove_reference_t&lt;B&gt;&amp; b2, const bool a) {
        { b1 }       -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
        { !b1 }      -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
        { b1 &amp;&amp; a }  -&gt; Same&lt;bool&gt;&amp;&amp;;
        { b1 {{!!}} a }  -&gt; Same&lt;bool&gt;&amp;&amp;;
        { b1 &amp;&amp; b2 } -&gt; Same&lt;bool&gt;&amp;&amp;;
        { a &amp;&amp; b2  } -&gt; Same&lt;bool&gt;&amp;&amp;;
        { b1 {{!!}} b2 } -&gt; Same&lt;bool&gt;&amp;&amp;;
        { a {{!!}} b2  } -&gt; Same&lt;bool&gt;&amp;&amp;;
        { b1 == b2 } -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
        { b1 == a  } -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
        { a == b2  } -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
        { b1 != b2 } -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
        { b1 != a  } -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
        { a != b2  } -&gt; ConvertibleTo&lt;bool&gt;&amp;&amp;;
    };
}}
The concept {{tt|Boolean&amp;lt;B&gt;}} specifies the requirements for a type usable in Boolean contexts. For {{tt|Boolean}} to be satisfied, the logical operators must have the usual behavior (including short-circuiting). More precisely, given
* {{tt|b1}}, {{tt|b2}}, two lvalues of type {{c|const std::remove_reference_t&lt;B&gt;}},
{{tt|Boolean&amp;lt;B&gt;}} is satisfied only if:
* {{c|bool(b1) {{==}} !bool(!b1)}};
* {{c|b1 &amp;&amp; b2}}, {{c|b1 &amp;&amp; bool(b2)}} and {{c|bool(b1) &amp;&amp; b2}} are all equal to {{c|bool(b1) &amp;&amp; bool(b2)}} and have the same short-circuit evaluation;
* {{c|b1 {{!!}} b2}}, {{c|b1 {{!!}} bool(b2)}} and {{c|bool(b1) {{!!}} b2}} are all equal to {{c|bool(b1) {{!!}} bool(b2)}} and have the same short-circuit evaluation;
* {{c|1=bool(b1 == b2)}}, {{c|1=bool(b1 == bool(b2))}}, and {{c|1=bool(bool(b1) == b2)}} are all equal to {{c|1=(bool(b1) == bool(b2))}};
* {{c|1=bool(b1 != b2)}}, {{c|1=bool(b1 != bool(b2))}}, and {{c|1=bool(bool(b1) != b2)}} are all equal to {{c|1=(bool(b1) != bool(b2))}}.

{{cpp/experimental/ranges/equality preservation}}
{{cpp/experimental/ranges/note implicit expression variations}}

===Notes===
Examples of {{tt|Boolean}} types include {{c|bool}}, {{c|std::true_type}}, and {{c|std::bitset&lt;N&gt;::reference}}. Pointers are not {{tt|Boolean}} types.

{{cpp/experimental/ranges/note Same deduction}}

{{langlinks|zh}}