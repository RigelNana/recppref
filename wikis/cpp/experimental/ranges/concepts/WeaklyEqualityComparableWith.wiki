{{cpp/experimental/ranges/title|WeaklyEqualityComparableWith}}
{{cpp/experimental/ranges/concepts/navbar}}
{{ddcl|header=experimental/ranges/concepts|since=ranges|1=
template&lt; class T, class U &gt;
concept bool WeaklyEqualityComparableWith =
    requires(const std::remove_reference_t&lt;T&gt;&amp; t,
             const std::remove_reference_t&lt;U&gt;&amp; u) {
        { t == u } -&gt; Boolean&amp;&amp;;
        { t != u } -&gt; Boolean&amp;&amp;;
        { u == t } -&gt; Boolean&amp;&amp;;
        { u != t } -&gt; Boolean&amp;&amp;;
    };
}}

The concept {{tt|WeaklyEqualityComparableWith&lt;T, U&gt;}} specifies that an object of type {{tt|T}} and an object of type {{tt|U}} can be compared for equality with each other (in either order) using both {{tt|{{==}}}} and {{tt|!{{=}}}}, and the results of the comparisons are consistent. More formally, {{tt|WeaklyEqualityComparableWith&lt;T, U&gt;}} is satisfied only if given
* {{tt|t}}, an lvalue of type {{c|const std::remove_reference_t&lt;T&gt;}} and
* {{tt|u}}, an lvalue of type {{c|const std::remove_reference_t&lt;U&gt;}},
the following are true:
* {{c|t {{==}} u}}, {{c|u {{==}} t}}, {{c|t !{{=}} u}},{{c|u !{{=}} t}} have the same domain;
* {{c|1=bool(u == t) == bool(t == u)}};
* {{c|1=bool(t != u) == !bool(t == u)}}; and
* {{c|1=bool(u != t) == bool(t != u)}}.

{{cpp/experimental/ranges/equality preservation}}
{{cpp/experimental/ranges/note implicit expression variations}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/experimental/ranges/concepts/dsc EqualityComparable}}
{{dsc end}}

{{langlinks|zh}}