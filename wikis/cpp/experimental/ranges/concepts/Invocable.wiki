{{cpp/experimental/ranges/title|Invocable|RegularInvocable}}
{{cpp/experimental/ranges/concepts/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/concepts}}
{{dcl|since=ranges|1=
template&lt; class F, class... Args &gt;
concept bool Invocable =
    requires(F&amp;&amp; f, Args&amp;&amp;... args) {
        ranges::invoke(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); 
            /* not required to be equality preserving */
    };
}}
{{dcl|since=ranges|1=
template&lt; class F, class... Args &gt;
concept bool RegularInvocable = Invocable&lt;F, Args...&gt;;
}}
{{dcl end}}

The {{tt|Invocable}} concept specifies that a callable type {{tt|F}} can be called with a set of argument types {{tt|Args...}} using the function template {{lc|ranges::invoke}}.

The {{tt|RegularInvocable}} concept adds to the {{tt|Invocable}} concept by requiring the {{tt|invoke}} expression to be equality preserving and not modify either the function object or the arguments.

{{cpp/experimental/ranges/equality preservation}}

===Notes===
The distinction between {{tt|Invocable}} and {{tt|RegularInvocable}} is purely semantic.

A random number generator may satisfy {{tt|Invocable}} but cannot satisfy {{tt|RegularInvocable}} ([https://xkcd.com/221/ comical] [http://dilbert.com/strip/2001-10-25 ones] excluded). 

{{langlinks|zh}}