{{cpp/experimental/ranges/title|EqualityComparable|EqualityComparableWith}}
{{cpp/experimental/ranges/concepts/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/concepts}}
{{dcl|since=ranges|num=1|1=
template&lt; class T &gt;
concept bool EqualityComparable = WeaklyEqualityComparableWith&lt;T, T&gt;;
}}
{{dcl|since=ranges|num=2|1=
template&lt; class T, class U &gt;
concept bool EqualityComparableWith =
    EqualityComparable&lt;T&gt; &amp;&amp;
    EqualityComparable&lt;U&gt; &amp;&amp;
    CommonReference&lt;
        const std::remove_reference_t&lt;T&gt;&amp;,
        const std::remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
    EqualityComparable&lt;
        ranges::common_reference_t&lt;
            const std::remove_reference_t&lt;T&gt;&amp;,
            const std::remove_reference_t&lt;U&gt;&amp;&gt;&gt; &amp;&amp;
    WeaklyEqualityComparableWith&lt;T, U&gt;;
}}
{{dcl end}}

@1@ The concept {{tt|EqualityComparable&lt;T&gt;}} specifies that the comparison operators {{tt|1===}} and {{tt|1=!=}} on {{tt|T}} reflects equality: {{tt|1===}} yields {{c|true}} if and only if the operands are equal.

@@ {{tt|EqualityComparable&lt;T&gt;}} is satisfied only if, given objects {{tt|a}} and {{tt|b}} of type {{tt|T}}, {{c|1=bool(a == b)}} is {{c|true}} if and only if {{tt|a}} and {{tt|b}} are equal. Together with the requirement that {{c|1=a == b}} is equality preserving, this implies that {{tt|1===}} is symmetric and transitive, and further that {{tt|1===}} is reflexive for all objects {{tt|a}} that are equal to at least one other object.

@2@ The concept {{tt|EqualityComparableWith&lt;T, U&gt;}} specifies that the comparison operators {{tt|1===}} and {{tt|1=!=}} on (possibly mixed) {{tt|T}} and {{tt|U}} operands yield results consistent with equality. Comparing mixed operands yields results equivalent to comparing the operands converted to their common type.

@@ Formally, {{tt|EqualityComparableWith&lt;T, U&gt;}} is satisfied only if, given any lvalue {{tt|t}} of type {{c|const std::remove_reference_t&lt;T&gt;}} and any lvalue {{tt|u}} of type {{c|const std::remove_reference_t&lt;U&gt;}}, and let {{tt|C}} be {{c|ranges::common_reference_t&lt;const std::remove_reference_t&lt;T&gt;&amp;, const std::remove_reference_t&lt;U&gt;&amp;&gt;}}, {{c|1=bool(t == u) == bool(C(t) == C(u))}}.

{{cpp/experimental/ranges/equality preservation|skip-requires=yes}}
{{cpp/experimental/ranges/note implicit expression variations}}

{{langlinks|zh}}