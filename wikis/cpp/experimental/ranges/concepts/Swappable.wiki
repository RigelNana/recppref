{{cpp/experimental/ranges/title|Swappable|SwappableWith}}
{{cpp/experimental/ranges/concepts/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/concepts}}
{{dcl|num=1|since=ranges|1=
template&lt; class T &gt;
concept bool Swappable =
    requires(T&amp; a, T&amp; b) {
        ranges::swap(a, b);
    };
}}
{{dcl|num=2|since=ranges|1=
template&lt; class T, class U &gt;
concept bool SwappableWith =
    CommonReference&lt;
        const std::remove_reference_t&lt;T&gt;&amp;,
        const std::remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
    requires(T&amp;&amp; t, U&amp;&amp; u) {
        ranges::swap(std::forward&lt;T&gt;(t), std::forward&lt;T&gt;(t));
        ranges::swap(std::forward&lt;U&gt;(u), std::forward&lt;U&gt;(u));
        ranges::swap(std::forward&lt;T&gt;(t), std::forward&lt;U&gt;(u));
        ranges::swap(std::forward&lt;U&gt;(u), std::forward&lt;T&gt;(t));
    };
}}
{{dcl end}}
The concept {{tt|Swappable&lt;T&gt;}} specifies that lvalues of type {{tt|T}} are swappable.

The concept {{tt|SwappableWith&lt;T, U&gt;}} specifies that expressions of the type and value category encoded by {{tt|T}} and {{tt|U}} are swappable with each other. {{tt|SwappableWith&lt;T, U&gt;}} is satisfied only if a call to {{c|ranges::swap(t, u)}} exchanges the value of {{tt|t}} and {{tt|u}}, that is, given distinct objects {{tt|t2}} equal to {{tt|t}} and {{tt|u2}} equal to {{tt|u}}, after evaluating either {{c|ranges::swap(t, u)}} or {{c|ranges::swap(u, t)}}, {{tt|t2}} is equal to {{tt|u}} and {{tt|u2}} is equal to {{tt|t}}.

{{cpp/experimental/ranges/equality preservation}}

{{langlinks|zh}}