{{cpp/experimental/ranges/title|Relation}}
{{cpp/experimental/ranges/concepts/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/concepts}}
{{dcl|since=ranges|num=1|1=
template&lt; class R, class T, class U &gt;
concept bool Relation =
    Predicate&lt;R, T, T&gt; &amp;&amp;
    Predicate&lt;R, U, U&gt; &amp;&amp;
    CommonReference&lt;
        const std::remove_reference_t&lt;T&gt;&amp;,
        const std::remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
    Predicate&lt;R,
        ranges::common_reference_t&lt;
            const std::remove_reference_t&lt;T&gt;&amp;,
            const std::remove_reference_t&lt;U&gt;&amp;&gt;,
        ranges::common_reference_t&lt;
            const std::remove_reference_t&lt;T&gt;&amp;,
            const std::remove_reference_t&lt;U&gt;&amp;&gt;&gt; &amp;&amp;
    Predicate&lt;R, T, U&gt; &amp;&amp;
    Predicate&lt;R, U, T&gt;;
}}
{{dcl end}}

The concept {{tt|Relation&lt;R, T, U&gt;}} specifies that {{tt|R}} defines a binary relation over the set of expressions whose type and value category are those encoded by either {{tt|T}} or {{tt|U}}.

Given
* {{tt|r}}, an expression such that {{c|decltype((r))}} is {{tt|R}},
* {{tt|t}}, an expression such that {{c|decltype((t))}} is {{tt|T}},
* {{tt|u}}, an expression such that {{c|decltype((u))}} is {{tt|U}},

and let {{tt|C}} be {{c|ranges::common_reference_t&lt;const std::remove_reference_t&lt;T&gt;&amp;, const std::remove_reference_t&lt;U&gt;&amp;&gt;}},

then {{tt|Relation&lt;R, T, U&gt;}} is satisfied only if
* {{c|1=bool(r(t, u)) == bool(r(C(t), C(u)))}} and
* {{c|1=bool(r(u, t)) == bool(r(C(u), C(t)))}}.

{{langlinks|zh}}