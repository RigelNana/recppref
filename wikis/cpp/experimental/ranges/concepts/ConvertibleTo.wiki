{{cpp/experimental/ranges/title|ConvertibleTo}}
{{cpp/experimental/ranges/concepts/navbar}}
{{ddcl|header=experimental/ranges/concepts|since=ranges|1=
template&lt; class From, class To &gt;
concept bool ConvertibleTo =
    std::is_convertible&lt;From, To&gt;::value &amp;&amp;
    requires(From (&amp;f)()) {
        static_cast&lt;To&gt;(f());
    };
}}

The concept {{c|ConvertibleTo&lt;From, To&gt;}} specifies that an expression of the type and value category specified by {{tt|From}} can be implicitly and explicitly converted to the type {{tt|To}}, and the two forms of conversion are equivalent.

Specifically, {{c|ConvertibleTo&lt;From, To&gt;}} is satisfied only if, given the invented function
{{c|To test(From (&amp;f)()) { return f(); } }} and a function {{tt|f}} of type {{c|From ()}} such that the expression {{c|f()}} is equality-preserving (see below),
* Either 
** {{tt|To}} is neither an object type nor a reference-to-object type, or
** {{c|static_cast&lt;To&gt;(f())}} is equal to {{tt|test(f)}}, and

* One of the following is true:
** {{tt|From}} is not a reference-to-object type, or
** {{tt|From}} is an rvalue reference to a non-const-qualified type, and the resulting state of the object referenced by {{c|f()}} is valid but unspecified after either expression above; or
** the object referred to by {{tt|f()}} is not modified by either expression above.

There need not be any subsumption relationship between {{c|ConvertibleTo&lt;From, To&gt;}} and {{c|std::is_convertible&lt;From, To&gt;::value}}.

{{cpp/experimental/ranges/equality_preservation}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_convertible}}
{{dsc end}}

{{langlinks|zh}}