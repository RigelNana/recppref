{{cpp/experimental/ranges/title|StrictTotallyOrdered|StrictTotallyOrderedWith}}
{{cpp/experimental/ranges/concepts/navbar}}
{{dcl begin}}
{{dcl header|experimental/ranges/concepts}}
{{dcl|since=ranges|num=1|1=
template&lt; class T &gt;
concept bool StrictTotallyOrdered =
    EqualityComparable&lt;T&gt; &amp;&amp;
    requires(const std::remove_reference_t&lt;T&gt;&amp; a,
             const std::remove_reference_t&lt;T&gt;&amp; b) {
        { a &lt; b }  -&gt; Boolean&amp;&amp;;
        { a &gt; b }  -&gt; Boolean&amp;&amp;;
        { a &lt;= b } -&gt; Boolean&amp;&amp;;
        { a &gt;= b } -&gt; Boolean&amp;&amp;;
    };
}}
{{dcl|since=ranges|num=2|1=
template&lt; class T, class U &gt;
concept bool StrictTotallyOrderedWith =
    StrictTotallyOrdered&lt;T&gt; &amp;&amp;
    StrictTotallyOrdered&lt;U&gt; &amp;&amp;
    CommonReference&lt;
        const std::remove_reference_t&lt;T&gt;&amp;,
        const std::remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
    StrictTotallyOrdered&lt;
        ranges::common_reference_t&lt;
            const std::remove_reference_t&lt;T&gt;&amp;,
            const std::remove_reference_t&lt;U&gt;&amp;&gt;&gt; &amp;&amp;
    EqualityComparableWith&lt;T, U&gt; &amp;&amp;
    requires(const std::remove_reference_t&lt;T&gt;&amp; t,
             const std::remove_reference_t&lt;U&gt;&amp; u) {
        { t &lt; u }  -&gt; Boolean&amp;&amp;;
        { t &gt; u }  -&gt; Boolean&amp;&amp;;
        { t &lt;= u } -&gt; Boolean&amp;&amp;;
        { t &gt;= u } -&gt; Boolean&amp;&amp;;
        { u &lt; t }  -&gt; Boolean&amp;&amp;;
        { u &gt; t }  -&gt; Boolean&amp;&amp;;
        { u &lt;= t } -&gt; Boolean&amp;&amp;;
        { u &gt;= t } -&gt; Boolean&amp;&amp;;
    };
}}
{{dcl end}}

@1@ The concept {{tt|StrictTotallyOrdered&lt;T&gt;}} specifies that the comparison operators {{tt|1===,!=,&lt;,&gt;,&lt;=,&gt;=}} on {{tt|T}} yield results consistent with a [[enwiki:Total order#Strict total order|strict total order]] on {{tt|T}}.
{{tt|StrictTotallyOrdered&lt;T&gt;}} is satisfied only if, given lvalues {{tt|a}}, {{tt|b}} and {{tt|c}} of type {{c|const std::remove_reference_t&lt;T&gt;}}:
* Exactly one of {{c|bool(a &lt; b)}}, {{c|bool(a &gt; b)}} and {{c|bool(a {{==}} b)}} is {{c|true}};
* If {{c|bool(a &lt; b)}} and {{c|bool(b &lt; c)}} are both {{c|true}}, then {{c|bool(a &lt; c)}} is {{c|true}};
* {{c|1=bool(a &gt; b) == bool(b &lt; a)}}
* {{c|1=bool(a &gt;= b) == !bool(a &lt; b)}}
* {{c|1=bool(a &lt;= b) == !bool(b &lt; a)}}

@2@ The concept {{tt|StrictTotallyOrderedWith&lt;T, U&gt;}} specifies that the comparison operators {{tt|1===,!=,&lt;,&gt;,&lt;=,&gt;=}} on (possibly mixed) {{tt|T}} and {{tt|U}} operands yield results consistent with a strict total order. Comparing mixed operands yields results equivalent to comparing the operands converted to their common type.
Formally, {{tt|StrictTotallyOrderedWith&lt;T, U&gt;}} is satisfied only if, given any lvalue {{tt|t}} of type {{c|const std::remove_reference_t&lt;T&gt;}} and any lvalue {{tt|u}} of type {{c|const std::remove_reference_t&lt;U&gt;}}, and let {{tt|C}} be {{c|ranges::common_reference_t&lt;const std::remove_reference_t&lt;T&gt;&amp;, const std::remove_reference_t&lt;U&gt;&amp;&gt;}}:
* {{c|1=bool(t &lt; u) == bool(C(t) &lt; C(u))}}
* {{c|1=bool(t &gt; u) == bool(C(t) &gt; C(u))}}
* {{c|1=bool(t &lt;= u) == bool(C(t) &lt;= C(u))}}
* {{c|1=bool(t &gt;= u) == bool(C(t) &gt;= C(u))}}
* {{c|1=bool(u &lt; t) == bool(C(u) &lt; C(t))}}
* {{c|1=bool(u &gt; t) == bool(C(u) &gt; C(t))}}
* {{c|1=bool(u &lt;= t) == bool(C(u) &lt;= C(t))}}
* {{c|1=bool(u &gt;= t) == bool(C(u) &gt;= C(t))}}

{{cpp/experimental/ranges/equality preservation}}
{{cpp/experimental/ranges/note implicit expression variations}}

{{langlinks|zh}}