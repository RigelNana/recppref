{{cpp/experimental/ranges/title|Assignable}}
{{cpp/experimental/ranges/concepts/navbar}}
{{ddcl|header=experimental/ranges/concepts|since=ranges|1=
template&lt; class T, class U &gt;
concept bool Assignable =
    std::is_lvalue_reference&lt;T&gt;::value &amp;&amp;
    CommonReference&lt;
        const std::remove_reference_t&lt;T&gt;&amp;,
        const std::remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
    requires(T t, U&amp;&amp; u) {
        { t = std::forward&lt;U&gt;(u) } -&gt; Same&lt;T&gt;&amp;&amp;;
    };
}}
The concept {{tt|Assignable&lt;T, U&gt;}} specifies that an expression of the type and value category specified by {{tt|U}} can be assigned to an lvalue expression whose type is specified by {{tt|T}}.

Given
* {{tt|t}}, an lvalue of type {{c|std::remove_reference_t&lt;T&gt;}} that refers to an object {{tt|o}},
* {{tt|u}}, an expression such that {{c|decltype((u))}} is {{tt|U}},
* {{tt|u2}}, a distinct object that is equal to {{tt|u}},
{{tt|Assignable&lt;T, U&gt;}} is satisfied only if
* {{c|1=std::addressof(t = u) == std::addressof(o)}} (i.e., the assignment expression yields an lvalue referring to the left operand);
* After evaluating {{c|1=t = u}}:
** {{tt|t}} is equal to {{tt|u2}}, unless {{tt|u}} is a non-const xvalue that refers to {{tt|o}} (i.e., the assignment is a self-move-assignment),
** if {{tt|u}} is a glvalue:
*** If it is a non-const xvalue, the object to which it refers is in a valid but unspecified state;
*** Otherwise, the object it refers to is not modified;

There need not be any subsumption relationship between {{tt|Assignable&lt;T, U&gt;}} and {{c|std::is_lvalue_reference&lt;T&gt;::value}}.

{{cpp/experimental/ranges/equality preservation}}

===Notes===
{{cpp/experimental/ranges/note Same deduction}}

Assignment need not be a total function. In particular, if assigning to some object {{tt|x}} can cause some other object {{tt|y}} to be modified, then {{c|1=x = y}} is likely not in the domain of {{tt|1==}}. This typically happens if the right operand is owned directly or indirectly by the left operand (e.g., with smart pointers to nodes in a node-based data structure, or with something like {{c|std::vector&lt;std::any&gt;}}).

{{langlinks|zh}}