{{cpp/experimental/ranges/title|Common}}
{{cpp/experimental/ranges/concepts/navbar}}
{{ddcl|header=experimental/ranges/concepts|since=ranges|1=
template&lt; class T, class U &gt;
concept bool Common =
    Same&lt;ranges::common_type_t&lt;T, U&gt;, ranges::common_type_t&lt;U, T&gt;&gt; &amp;&amp;
    ConvertibleTo&lt;T, ranges::common_type_t&lt;T, U&gt;&gt; &amp;&amp;
    ConvertibleTo&lt;U, ranges::common_type_t&lt;T, U&gt;&gt; &amp;&amp;
    CommonReference&lt;
        std::add_lvalue_reference_t&lt;const T&gt;,
        std::add_lvalue_reference_t&lt;const U&gt;&gt; &amp;&amp;
    CommonReference&lt;
        std::add_lvalue_reference_t&lt;ranges::common_type_t&lt;T, U&gt;&gt;,
        ranges::common_reference_t&lt;
            std::add_lvalue_reference_t&lt;const T&gt;,
            std::add_lvalue_reference_t&lt;const U&gt;&gt;&gt;;
}}
The concept {{tt|Common&lt;T, U&gt;}} specifies that two types {{tt|T}} and {{tt|U}} share a ''common type'' (as computed by {{lc|ranges::common_type_t}}) to which both can be converted.

{{tt|Common&lt;T, U&gt;}} is satisfied only if, given expressions {{tt|t}} and {{tt|u}} such that {{c|decltype((t))}} is {{tt|T}} and {{c|decltype((u))}} is {{tt|U}},
* {{c|ranges::common_type_t&lt;T, U&gt;(t)}} is equal to {{c|ranges::common_type_t&lt;T, U&gt;(t)}} if and only if {{tt|t}} is an equality-preserving expression; and
* {{c|ranges::common_type_t&lt;T, U&gt;(u)}} is equal to {{c|ranges::common_type_t&lt;T, U&gt;(u)}} if and only if {{tt|u}} is an equality-preserving expression.

In other words, the conversion to the common type must not alter the equality-preservation property of the original expression.

{{cpp/experimental/ranges/equality preservation|skip-requires=yes}}

===See also ===
{{dsc begin}}
{{dsc inc|cpp/experimental/ranges/type_traits/dsc common_type}}
{{dsc inc|cpp/experimental/ranges/type_traits/dsc common_reference}}
{{dsc inc|cpp/experimental/ranges/concepts/dsc CommonReference}}
{{dsc end}}

{{langlinks|zh}}