{{cpp/experimental/title|not_fn}}
{{cpp/experimental/lib_extensions_2/navbar}}
{{fmbox | class=noprint | style=font-size: 0.8em | text='''Merged into ISO C++''' The functionality described on this page was merged into the mainline ISO C++ standard as of 3/2016, see  {{ltt|cpp/utility/functional/not_fn|std::not_fn}} {{mark since c++17}} }}
{{dcl begin}}
{{dcl header | experimental/functional }}
{{dcl | since=libfund_ts_2 |
template&lt; class F&gt;
/*unspecified*/ not_fn( F&amp;&amp; f );
}}
{{dcl end}}

Creates a forwarding call wrapper that returns the complement of the callable object it holds.

=== Parameters ===
{{par begin}}
{{par | f | the object from which the {{named req|Callable}} object held by the wrapper is constructed }}
{{par end}}

===Return value===
Let {{tt|FD}} be {{c|std::decay_t&lt;F&gt;}} and {{tt|fd}} be an lvalue of type {{tt|FD}} constructed from {{c|std::forward&lt;F&gt;(f)}}. 

{{tt|not_fn}} returns a forwarding call wrapper {{tt|fn}} of unspecified type such that {{c|fn(a1, a2, ..., aN)}} is equivalent to {{c|!INVOKE(fd, a1, ..., aN)}}, where {{tt|INVOKE}} is the operation described in {{named req|Callable}}.

The returned call wrapper is always {{named req|MoveConstructible}}, and is {{named req|CopyConstructible}} if FD is {{named req|CopyConstructible}}.

=== Remarks ===
If {{tt|fd}} is not {{named req|Callable}}, or {{c|std::is_constructible&lt;FD, F&gt;::value}} is not {{tt|true}}, the behavior is undefined.

=== Exceptions ===
Throws no exceptions, unless the construction of {{tt|fd}} throws.

=== Possible implementation ===
{{eq fun|1=
namespace detail {
    template&lt;class F&gt;
    struct not_fn_t {
        F f;
        template&lt;class... Args&gt;
        auto operator()(Args&amp;&amp;... args)
            noexcept(noexcept(!std::invoke(f, std::forward&lt;Args&gt;(args)...)))
            -&gt; decltype(!std::invoke(f, std::forward&lt;Args&gt;(args)...)) {
            return !std::invoke(f, std::forward&lt;Args&gt;(args)...);
        }

        // cv-qualified overload for QoI
        template&lt;class... Args&gt;
        auto operator()(Args&amp;&amp;... args) const
            noexcept(noexcept(!std::invoke(f, std::forward&lt;Args&gt;(args)...)))
            -&gt; decltype(!std::invoke(f, std::forward&lt;Args&gt;(args)...)) {
            return !std::invoke(f, std::forward&lt;Args&gt;(args)...);
        }

        template&lt;class... Args&gt;
        auto operator()(Args&amp;&amp;... args) volatile
            noexcept(noexcept(!std::invoke(f, std::forward&lt;Args&gt;(args)...)))
            -&gt; decltype(!std::invoke(f, std::forward&lt;Args&gt;(args)...)) {
            return !std::invoke(f, std::forward&lt;Args&gt;(args)...);
        }
        template&lt;class... Args&gt;
        auto operator()(Args&amp;&amp;... args) const volatile
            noexcept(noexcept(!std::invoke(f, std::forward&lt;Args&gt;(args)...)))
            -&gt; decltype(!std::invoke(f, std::forward&lt;Args&gt;(args)...)) {
            return !std::invoke(f, std::forward&lt;Args&gt;(args)...);
        }
    };
}

template&lt;class F&gt;
detail::not_fn_t&lt;std::decay_t&lt;F&gt;&gt; not_fn(F&amp;&amp; f) { return { std::forward&lt;F&gt;(f) }; }
}}

=== Notes ===
{{tt|not_fn}} is intended to replace the C++03-era negators {{lc|std::not1}} and {{lc|std::not2}}.

=== See also ===
{{dsc begin}}
{{dsc inc | cpp/utility/functional/dsc not_fn}}
{{dsc end}}

{{langlinks|zh}}