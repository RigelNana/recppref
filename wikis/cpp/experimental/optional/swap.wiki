{{cpp/experimental/optional/title|swap}}
{{cpp/experimental/optional/navbar}}
{{dcl begin}}
{{dcl|since=libfund_ts|1=
void swap( optional&amp; other ) noexcept(/* see below */);
}}
{{dcl end}}

Swaps the contents with those of {{c|other}}.

* If neither {{c|*this}} nor {{c|other}} contain a value, the function has no effect.

* If only one of {{c|*this}} and {{c|other}} contains a value (let's call this object {{tt|in}} and the other {{tt|un}}), the contained value of {{tt|un}} is [[cpp/language/direct_initialization|direct-initialized]] from {{c|std::move(*in)}}, followed by destruction of the contained value of {{tt|in}} as if by {{c|in.val-&gt;T::~T()}}. After this call, {{tt|in}} does not contain a value {{tt|un}} contains a value.

* If both {{c|*this}} and {{c|other}} contain values, the contained values are exchanged by calling {{c|using std::swap; swap(**this, *other)}}. {{tt|T}} lvalues must satisfy {{named req|Swappable}}.

===Parameters===
{{par begin}}
{{par|other|the {{tt|optional}} object to exchange the contents with}}
{{par end}}

===Return value===
(none)

===Exceptions===
{{noexcept|std::is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; 
           noexcept(swap(std::declval&lt;T&amp;&gt;(), std::declval&lt;T&amp;&gt;()))}}
&lt;!-- this is broken; see LWG 2561 --&gt;
In the case of thrown exception, the states of the contained values of {{c|*this}} and {{c|other}} are determined by the exception safety guarantees of {{tt|swap}} of type {{tt|T}} or {{tt|T}}'s move constructor, whichever is called. For both {{c|*this}} and {{c|other}}, if the object contained a value, it is left containing a value, and the other way round.

===See also===
{{dsc begin}}
{{dsc inc|cpp/experimental/optional/dsc swap2}}
{{dsc end}}