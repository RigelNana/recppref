{{cpp/experimental/unique_resource/title|reset}}
{{cpp/experimental/unique_resource/navbar}}

{{dcl begin}}
{{dcl|num=1|since=libfund_ts_3|
void reset() noexcept;
}}
{{dcl|num=2|since=libfund_ts_3|
template&lt; class RR &gt;
void reset( RR&amp;&amp; r );
}}
{{dcl end}}

@1@ Disposes the resource by calling the deleter with the underlying resource handle if the {{tt|unique_resource}} owns it. The {{tt|unique_resource}} does not own the resource after the call.
@2@ Replaces the resource by calling {{v|1}} and then assigns the stored resource handle with {{c|std::forward&lt;RR&gt;(r)}} if {{c|std::is_nothrow_assignable_v&lt;RS, RR&gt;}} is {{c|true}}, otherwise {{c|std::as_const(r)}}, where {{tt|RS}} is the type of stored resource handle. The {{tt|unique_resource}} owns the resource after the call.
@@ If copy-assignment of the store resource handle throws an exception, calls {{c|del_(r)}}, where {{tt|del}} is the deleter object.
@@ {{cpp/enable_if|the selected assignment expression assigning the stored resource handle is well-formed}}.
@@ The program is ill-formed if {{c|del_(r)}} is ill-formed.
@@ The behavior is undefined if {{c|del_(r)}} results in undefined behavior or throws an exception.

===Parameters===
{{par begin}}
{{par|r|resource handle for a new resource to manage}}
{{par end}}

===Return value===
(none)

===Exceptions===
@2@ Any exception thrown in assigning the stored resource handle.

===Notes===
The mechanism ensures no leaking of resources.

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/unique_ptr/dsc reset}}
{{dsc end}}

{{langlinks|ja|zh}}