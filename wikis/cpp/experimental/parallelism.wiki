{{title|Extensions for parallelism}}
{{cpp/experimental/parallelism/navbar}}

{{fmbox|class=noprint|style=font-size: 0.8em|text='''Merged into ISO C++''' The functionality described on this page was merged into the mainline ISO C++ standard (except for dynamic execution policy and {{tt|exception_list}}) as of 3/2016; see [[cpp/algorithm|the algorithm library]] {{mark since c++17}}}}

The C++ Extensions for Parallelism, ISO/IEC TS 19570:2015 defines the following new components for the C++ standard library:

===Execution policies===
The parallelism TS describes three execution policies: [[cpp/experimental/parallelism/execution policy#sequential|sequential]], [[cpp/experimental/parallelism/execution policy#parallel|parallel]], and [[cpp/experimental/parallelism/execution policy#parallel vector|parallel+vector]], and provides corresponding execution policy types and objects. Users may select an execution policy statically by invoking a parallel algorithm with the an execution policy object of the corresponding type, or dynamically by using the type-erasing {{tt|execution_policy}} class.

Implementations may define additional execution policies as an extension. The semantics of parallel algorithms invoked with an execution policy object of implementation-defined type is implementation-defined.

{{dsc begin}}
{{dsc header|experimental/execution_policy}}
{{dsc class|cpp/experimental/execution_policy_tag_t|title=sequential_execution_policy&lt;br/&gt;parallel_execution_policy&lt;br/&gt;parallel_vector_execution_policy|execution policy types}}
{{dsc const|cpp/experimental/execution_policy_tag|title=seq&lt;br/&gt;par&lt;br/&gt;par_vec|global execution policy objects}}
{{dsc class|cpp/experimental/execution_policy|dynamic execution policy}}
{{dsc tclass|cpp/experimental/is_execution_policy|test whether a class represents an execution policy}}
{{dsc end}}

===Exception lists===
{{dsc begin}}
{{dsc header|experimental/exception_list}}
{{dsc class|cpp/experimental/exception_list|exceptions raised during parallel executions}}
{{dsc end}}

===Parallelized versions of existing algorithms===
The TS provides [[cpp/experimental/parallelism/existing|parallelized versions]] of the following 69 algorithms from &lt;algorithm&gt;, &lt;numeric&gt; and &lt;memory&gt;:
{{collapse top|Standard library algorithms for which parallelized versions are provided}}
{{div col|3}}
* {{lc|std::adjacent_difference}}
* {{lc|std::adjacent_find}}
* {{lc|std::all_of}}
* {{lc|std::any_of}}
* {{lc|std::copy}}
* {{lc|std::copy_if}}
* {{lc|std::copy_n}}
* {{lc|std::count}}
* {{lc|std::count_if}}
* {{lc|std::equal}}
* {{lc|std::fill}}
* {{lc|std::fill_n}}
* {{lc|std::find}}
* {{lc|std::find_end}}
* {{lc|std::find_first_of}}
* {{lc|std::find_if}}
* {{lc|std::find_if_not}}
* {{lc|std::generate}}
* {{lc|std::generate_n}}
* {{lc|std::includes}}
* {{lc|std::inner_product}}
* {{lc|std::inplace_merge}}
* {{lc|std::is_heap}}
* {{lc|std::is_heap_until}}
* {{lc|std::is_partitioned}}
* {{lc|std::is_sorted}}
* {{lc|std::is_sorted_until}}
* {{lc|std::lexicographical_compare}}
* {{lc|std::max_element}}
* {{lc|std::merge}}
* {{lc|std::min_element}}
* {{lc|std::minmax_element}}
* {{lc|std::mismatch}}
* {{ltt|cpp/algorithm/move|std::move}}
* {{lc|std::none_of}}
* {{lc|std::nth_element}}
* {{lc|std::partial_sort}}
* {{lc|std::partial_sort_copy}}
* {{lc|std::partition}}
* {{lc|std::partition_copy}}
* {{ltt|cpp/algorithm/remove|std::remove}}
* {{lc|std::remove_copy}}
* {{lc|std::remove_copy_if}}
* {{lc|std::remove_if}}
* {{lc|std::replace}}
* {{lc|std::replace_copy}}
* {{lc|std::replace_copy_if}}
* {{lc|std::replace_if}}
* {{lc|std::reverse}}
* {{lc|std::reverse_copy}}
* {{lc|std::rotate}}
* {{lc|std::rotate_copy}}
* {{lc|std::search}}
* {{lc|std::search_n}}
* {{lc|std::set_difference}}
* {{lc|std::set_intersection}}
* {{lc|std::set_symmetric_difference}}
* {{lc|std::set_union}}
* {{lc|std::sort}}
* {{lc|std::stable_partition}}
* {{lc|std::stable_sort}}
* {{lc|std::swap_ranges}}
* {{lc|std::transform}}
* {{lc|std::uninitialized_copy}}
* {{lc|std::uninitialized_copy_n}}
* {{lc|std::uninitialized_fill}}
* {{lc|std::uninitialized_fill_n}}
* {{lc|std::unique}}
* {{lc|std::unique_copy}}
{{div col end}}
{{collapse bottom}}

===New algorithms===
{{dsc begin}}
{{dsc header|experimental/algorithm}}
{{dsc tfun|cpp/experimental/for_each|similar to {{lc|std::for_each}} except returns void}}
{{dsc tfun|cpp/experimental/for_each_n|applies a function object to the first n elements of a sequence}}
{{dsc header|experimental/numeric}}
{{dsc inc|cpp/experimental/parallelism/dsc reduce}}
{{dsc tfun|cpp/experimental/exclusive_scan|similar to {{lc|std::partial_sum}}, excludes the i{{sup|th}} input element from the i{{sup|th}} sum}}
{{dsc tfun|cpp/experimental/inclusive_scan|similar to {{lc|std::partial_sum}}, includes the i{{sup|th}} input element in the i{{sup|th}} sum}}
{{dsc inc|cpp/experimental/parallelism/dsc transform_reduce}}
{{dsc tfun|cpp/experimental/transform_exclusive_scan|applies a functor, then calculates exclusive scan}}
{{dsc tfun|cpp/experimental/transform_inclusive_scan|applies a functor, then calculates inclusive scan}}
{{dsc end}}

{{langlinks|zh}}