{{cpp/experimental/reflect/title|Object}}
{{cpp/experimental/reflect/navbar}}
{{ddcl | since=reflection_ts | header=experimental/reflect | 1=
template&lt; class T &gt;
concept Object = /* see below */;
}}

The {{tt|Object}} concept is satisfied if and only if {{tt|T}} is a meta-object type.

===Example===
{{example|code=
#include &lt;experimental/reflect&gt;

namespace reflect = std::experimental::reflect;

template&lt;reflect::Object M&gt;
struct meta_t {
    template&lt;reflect::Object M1&gt;
    friend constexpr bool operator==(meta_t, meta_t&lt;M1&gt;) noexcept
    {
        return reflect::reflects_same_v&lt;M, M1&gt;;
    }
    template&lt;reflect::Object M1&gt;
    friend constexpr bool operator!=(meta_t, meta_t&lt;M1&gt;) noexcept
    {
        return !reflect::reflects_same_v&lt;M, M1&gt;;
    }
};

template&lt;reflect::Object M&gt;
constexpr meta_t&lt;M&gt; meta{};

int main()
{
    static_assert(meta&lt;reflexpr(int)&gt; == meta&lt;reflexpr(signed int)&gt;, "");
    // meta&lt;int&gt;; // error: int is not a meta-object type
}
}}

{{langlinks|es|ja|ru|zh}}