{{cpp/experimental/propagate_const/title|propagate_const}}
{{cpp/experimental/lib extensions 2/propagate_const/navbar}}

{{dcl begin}}
{{dcl|num=1|since=libfund_ts_2|1= 
constexpr propagate_const() = default;
}}
{{dcl|num=2|since=libfund_ts_2|1= 
constexpr propagate_const( propagate_const&amp;&amp; p ) = default;
}}
{{dcl|num=3|since=libfund_ts_2|1= 
template&lt; class U &gt;
/* see below */ constexpr propagate_const( propagate_const&lt;U&gt;&amp;&amp; pu );
}}
{{dcl|num=4|since=libfund_ts_2|1= 
template&lt; class U &gt;
/* see below */ constexpr propagate_const( U&amp;&amp; u );
}}
{{dcl|num=5|since=libfund_ts_2|1= 
propagate_const( const propagate_const&amp; ) = delete;
}}
{{dcl end}}

Let {{tt|t_}} designate the private data member that is the wrapped pointer-like object.

@1@ Constructs a {{tt|propagate_const}}, default-initializing {{c|this-&gt;t_}}.

@2@ Explicitly defaulted move constructor that move constructs {{c|this-&gt;t_}} from {{c|p.t_}}.

@3@ Initializes {{c|this-&gt;t_}} as if by direct-non-list-initialization from the expression {{c|std::move(pu.t_)}}.&lt;br&gt;&lt;!--
--&gt;This constructor does not participate in overload resolution unless {{c|std::is_constructible&lt;T, U&gt;::value}} is {{c|true}}, and is {{tt|explicit}} if and only if {{c|std::is_convertible&lt;U, T&gt;::value}} is {{c|false}}.

@4@ Initializes {{c|this-&gt;t_}} as if by direct-non-list-initialization with the expression {{c|std::forward&lt;U&gt;(u)}}.&lt;br&gt;&lt;!--
--&gt;This constructor does not participate in overload resolution unless {{c|std::is_constructible&lt;T, U&gt;::value}} is {{c|true}} and {{c|std::decay_t&lt;U&gt;}} is not a specialization of {{tt|propagate_const}}. This constructor is {{tt|explicit}} if and only if {{c|std::is_convertible&lt;U, T&gt;::value}} is {{c|false}}.

@5@ Copy constructor is explicitly deleted. {{tt|propagate_const}} is non-copyable.

===Parameters===
{{par begin}}
{{par|p|another {{tt|propagate_const}} object to move from}}
{{par|pu|another {{tt|propagate_const}} object of a different specialization to move from}}
{{par|u|another object to initialize the contained pointer with}}
{{par end}}

===Notes===
In Library Fundamental TS v2 (based on C++14), {{v|4}} and {{v|5}} are typically implemented in {{tt|explicit}}/non-{{tt|explicit}} overload pairs. Since Library Fundamental TS v3 (based on C++20), they can be implemented in conditional {{tt|explicit}} specifiers.

{{langlinks|de|es|ja|ru|zh}}