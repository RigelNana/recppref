{{cpp/experimental/title|optional}}
{{cpp/experimental/optional/navbar}}
{{fmbox|class=noprint|style=font-size: 0.8em|text='''Merged into ISO C++''' The functionality described on this page was merged into the mainline ISO C++ standard as of 3/2016, see {{ltt|cpp/utility/optional|std::optional}} {{mark since c++17}}}}

{{ddcl|header=experimental/optional|since=libfund_ts|
template&lt; class T &gt;
class optional;
}}

The class template {{tt|std::experimental::optional}} manages an ''optional'' contained value, i.e. a value that may or may not be present.

A common use case for {{tt|optional}} is the return value of a function that may fail. As opposed to other approaches, such as {{c|std::pair&lt;T,bool&gt;}}, {{tt|optional}} handles expensive to construct objects well and is more readable, as the intent is expressed explicitly.

Any instance of {{tt|optional&lt;T&gt;}} at any given point in time either ''contains a value'' or ''does not contain a value''.

If an {{tt|optional&lt;T&gt;}} ''contains a value'', the value is guaranteed to be allocated as part of the {{tt|optional}} object footprint, i.e. no dynamic memory allocation ever takes place. Thus, an {{tt|optional}} object models an object, not a pointer, even though the {{lc|operator*()}} and {{lc|operator-&gt;()}} are defined.

When an object of type optional&lt;T&gt; is [[cpp/language/implicit_cast|contextually converted to bool]], the conversion returns {{c|true}} if the object ''contains a value'' and {{c|false}} if it ''does not contain a value''.

The {{tt|optional}} object ''contains a value'' in the following conditions:

* The object is initialized with a value of type {{tt|T}}.
* The object is assigned from another {{tt|optional}} that ''contains a value''.

The object ''does not contain a value'' in the following conditions:

* The object is default-initialized.
* The object is initialized with a value of {{lc|std::experimental::nullopt_t}} or an  {{tt|optional}} object that ''does not contain a value''.
* The object is assigned from a value of {{lc|std::experimental::nullopt_t}} or from an {{tt|optional}} that ''does not contain a value''.

===Template parameters===
{{par begin}}
{{par|T|the type of the value to manage initialization state for. The type must meet the requirements of {{named req|Destructible}}.}}
{{par end}}

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc|{{tt|value_type}}|{{tt|T}}}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/experimental/optional/dsc constructor}}
{{dsc inc|cpp/experimental/optional/dsc destructor}}
{{dsc inc|cpp/experimental/optional/dsc operator{{=}}}}

{{dsc h2|Observers}}
{{dsc inc|cpp/experimental/optional/dsc operator*}}
{{dsc inc|cpp/experimental/optional/dsc operator bool}}
{{dsc inc|cpp/experimental/optional/dsc value}}
{{dsc inc|cpp/experimental/optional/dsc value_or}}

{{dsc h2|Modifiers}}
{{dsc inc|cpp/experimental/optional/dsc swap}}
{{dsc inc|cpp/experimental/optional/dsc emplace}}
{{dsc end}}

===Member objects===
{{dsc begin}}
{{dsc hitem|Member name|Definition}}
{{dsc|{{tt|val}} {{mark|private}}|pointer to the contained value (which points at a data member of the same object), the name is for exposition only}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/experimental/optional/dsc operator_cmp}}
{{dsc inc|cpp/experimental/optional/dsc make_optional}}
{{dsc inc|cpp/experimental/optional/dsc swap2}}
{{dsc end}}

===Helper classes===
{{dsc begin}}
{{dsc inc|cpp/experimental/optional/dsc hash}}
{{dsc inc|cpp/experimental/optional/dsc nullopt_t}}
{{dsc inc|cpp/experimental/optional/dsc in_place_t}}
{{dsc inc|cpp/experimental/optional/dsc bad_optional_access}}
{{dsc end}}

===Helper objects===
{{dsc begin}}
{{dsc inc|cpp/experimental/optional/dsc nullopt}}
{{dsc inc|cpp/experimental/optional/dsc in_place}}
{{dsc end}}