{{cpp/experimental/title|where_expression}}
{{cpp/experimental/simd/where_expression/navbar}}

{{ddcl|header=experimental/simd|since=parallelism_ts_2|1=
template&lt; class M, class V &gt;
class where_expression;
}}

The class template {{tt|where_expression}} abstracts the notion of selected elements
of a given lvalue of arithmetic or data-parallel type. Selected elements are the elements of the lvalue (of type {{tt|V}}) for which the corresponding element of the mask (of type {{tt|M}}) is true. Operators applied to objects of type {{tt|where_expression&lt;M, V&gt;}} are applied only to selected elements. All other elements are left unchanged.

Use the {{rlpt|where}} function to construct {{tt|where_expression}} objects.

===Template parameters===
{{par begin}}
{{par|M|The mask type}}
{{par|V|The value type M applies on}}
{{par end}}

&lt;!--{{open range}} here is for fmt purposes only--&gt;
Valid combinations of {{open range plain|M|V}} are:
* {{open range plain|simd_mask&lt;T, Abi&gt;|simd&lt;T, Abi&gt;}},
* {{open range plain|simd_mask&lt;T, Abi&gt;|simd_mask&lt;T, Abi&gt;}},
* {{open range plain|bool|T}}.

===Member functions===
{{dsc begin}}
{{dsc mem fun|cpp/experimental/simd/where_expression/operator{{=}}|title=operator=|assigns to selected positions}}
{{dsc mem fun|cpp/experimental/simd/where_expression/compound_operators|title=operator+=&lt;br&gt;operator-=&lt;br&gt;operator*=&lt;br&gt;operator/=&lt;br&gt;operator%=&lt;br&gt;operator&amp;=&lt;br&gt;operator{{!}}=&lt;br&gt;operator^=&lt;br&gt;operator&lt;&lt;=&lt;br&gt;operator&gt;&gt;=|compound operators}}
{{dsc mem fun|cpp/experimental/simd/where_expression/inc|title=operator++&lt;br&gt;operator--|increment and decrement operators}}
{{dsc mem fun|cpp/experimental/simd/where_expression/copy_from|loads from address to selected positions}}
{{dsc end}}

===Example===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;experimental/simd&gt;
#include &lt;iostream&gt;
namespace stdx = std::experimental;

void print(auto const&amp; a)
{
    for (std::size_t i{}; i != std::size(a); ++i)
        std::cout &lt;&lt; a[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

template&lt;class A&gt;
stdx::simd&lt;int, A&gt; my_abs(stdx::simd&lt;int, A&gt; x)
{
    where(x &lt; 0, x) = -x;
    return x;
}

int main()
{
    const stdx::native_simd&lt;int&gt; a([](int i) { return i - 2; });
    print(a);
    const auto b = my_abs(a);
    print(b);
}
|p=true
|output=
-2 -1 0 1 
2 1 0 1 
}}

{{langlinks|zh}}