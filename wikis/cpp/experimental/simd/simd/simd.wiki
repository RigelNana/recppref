{{cpp/experimental/simd/title|simd}}
{{cpp/experimental/simd/simd/navbar}}
{{dcl begin}}
{{dcl|num=1|since=parallelism_ts_2|1=
simd() noexcept = default;
}}
{{dcl|num=2|since=parallelism_ts_2|1=
template&lt; class U &gt;
simd( U&amp;&amp; value ) noexcept;
}}
{{dcl|num=3|since=parallelism_ts_2|1=
template&lt; class U &gt;
simd( const simd&lt;U, simd_abi::fixed_size&lt;size()&gt;&gt;&amp; other ) noexcept;
}}
{{dcl|num=4|since=parallelism_ts_2|1=
template&lt; class G &gt;
explicit simd( G&amp;&amp; generator ) noexcept;
}}
{{dcl|num=5|since=parallelism_ts_2|1=
template&lt; class U, class Flags &gt;
simd( const U* mem, Flags flags );
}}
{{dcl|num=6|since=parallelism_ts_2|notes={{mark implicit}}|1=
simd( const simd&amp; other ) noexcept = default;
}}
{{dcl|num=7|since=parallelism_ts_2|notes={{mark implicit}}|1=
simd( simd&amp;&amp; other ) noexcept = default;
}}
{{dcl end}}

@1@ Constructs a {{tt|simd}} using {{lt|cpp/language/default initialization}} (constructed without initializer) or {{lt|cpp/language/value initialization}} (constructed with an empty initializer).
@2@ The broadcast constructor constructs a {{tt|simd}} with all values initialized to {{c|value}}. {{cpp/enable_if|the conversion from {{tt|U}} to {{tt|T}} is ''value-preserving'', or {{tt|U}} is either {{c/core|int}} or {{c/core|unsigned int}} if {{tt|T}} is an unsigned integral type}}.
@3@ Constructs a {{tt|simd}} where the i-th element is initialized to {{c|static_cast&lt;T&gt;(other[i])}} {{simd_for_all_i}}. {{cpp/enable_if|{{tt|Abi}} is {{c|simd_abi::fixed_size&lt;size()&gt;}} and the conversion from {{tt|U}} to {{tt|T}} is ''value-preserving'', and, if both {{tt|U}} and {{tt|T}} are integral, the integer conversion rank of {{tt|T}} is greater than the integer conversion rank of {{tt|U}}}}.
@4@ The generator constructor constructs a {{tt|simd}} where the i-th element is initialized to {{c|generator(std::integral_constant&lt;std::size_t, i&gt;())}}. {{cpp/enable_if|{{tt|simd(gen(std::integral_constant&lt;std::size_t, i&gt;()))}}}} is well-formed {{simd_for_all_i}}. The calls to {{c|generator}} are unsequenced with respect to each other. ''{{lt|cpp/algorithm/execution_policy_tag_t|Vectorization-unsafe}}'' standard library functions may not be invoked by {{c|generator}}.
@5@ The load constructor constructs a {{tt|simd}} where the i-th element is initialized to {{co|static_cast&lt;T&gt;(mem[i])}} {{simd_for_all_i}}.
@6,7@ Implicitly declared copy and move constructors. Constructs a {{tt|simd}} where each element is initialized from the values of the elements in {{c|other}}.

===Parameters===
{{par begin}}
{{par|value|the value used for initialization of all {{tt|simd}} elements}}
{{par|other|another {{tt|simd}} to copy from}}
{{par|generator|a function object used for initialization of each {{tt|simd}} element}}
{{par|mem|a pointer into an array where {{range|mem|mem + size()}} is a valid range}}
{{par|flags|if of type {{ltt|cpp/experimental/simd/vector_aligned|vector_aligned_tag}}, the load constructor may assume {{c|mem}} to point to storage aligned by {{ltt|cpp/experimental/simd/memory alignment|memory_alignment_v&lt;simd, U&gt;}}}}
{{par hreq}}
{{par req|The conversion from {{tt|U}} to {{tt|T}} must be ''value-preserving''. The broadcast constructor (2) additionally allows {{tt|U}} to be {{c/core|int}} or to be {{c/core|unsigned int}} if {{tt|T}} is an unsigned integral type.}}
{{par req|{{tt|is_simd_flag_type_v&lt;Flags&gt;}} must be {{c/core|true}}.}}
{{par end}}

===Example===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;experimental/simd&gt;
#include &lt;iostream&gt;
namespace stdx = std::experimental;

int main()
{
    stdx::native_simd&lt;int&gt; a; // uninitialized
    a = 1; // all elements set to 1
    stdx::native_simd&lt;int&gt; b([](int i) { return i; }); // {0, 1, 2, 3, ...}

    alignas(stdx::memory_alignment_v&lt;stdx::native_simd&lt;int&gt;&gt;)
        std::array&lt;int, stdx::native_simd&lt;int&gt;::size() * 2&gt; mem = {};
    for (std::size_t i = 0; i &lt; mem.size(); ++i)
        mem[i] = i &amp; 1;

    stdx::native_simd&lt;int&gt; c(&amp;mem[0], stdx::vector_aligned); // {0, 1, 0, 1, ...}
    stdx::native_simd&lt;int&gt; d(&amp;mem[1], stdx::element_aligned); // {1, 0, 1, 0, ...}

    auto sum = a + b + c + d;

    for (std::size_t i = 0; i &lt; sum.size(); ++i)
        std::cout &lt;&lt; sum[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|p=true
|output=
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/experimental/simd/simd/dsc copy_from}}
{{dsc end}}