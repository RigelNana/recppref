{{cpp/experimental/simd/title|copy_from}}
{{cpp/experimental/simd/simd/navbar}}
{{dcl begin}}
{{dcl|since=parallelism_ts_2|1=
template&lt; class U, class Flags &gt;
void copy_from( const U* mem, Flags flags );
}}
{{dcl end}}

The load function replaces all elements of a {{rlpt|/|simd}} such that the {{math|i}}{{sup|th}} element is assigned with {{c|static_cast&lt;T&gt;(mem[i])}} {{simd_for_all_i}}.

===Parameters===
{{par begin}}
{{par|mem|a pointer into an array where {{range|mem|mem + size()}} is a valid range}}
{{par|flags|if of type {{ltt|cpp/experimental/simd/vector_aligned|vector_aligned_tag}}, the load constructor may assume {{c|mem}} to point to storage aligned by {{ltt|cpp/experimental/simd/memory_alignment|memory_alignment_v&lt;simd, U&gt;}}}}
{{par hreq}}
{{par req|{{tt|U}} must be a ''vectorizable'' type.}}
{{par req|{{tt|is_simd_flag_type_v&lt;Flags&gt;}} must be {{c/core|true}}.}}
{{par end}}

===Example===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;experimental/simd&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
namespace stdx = std::experimental;

void print(auto const&amp; a)
{
    for (std::size_t i{}; i != std::size(a); ++i)
        std::cout &lt;&lt; a[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    alignas(stdx::memory_alignment_v&lt;stdx::native_simd&lt;int&gt;&gt;)
        std::array&lt;int, stdx::native_simd&lt;int&gt;::size() * 2&gt; mem = {};
    std::iota(mem.begin(), mem.end(), 0);
    print(mem);

    stdx::native_simd&lt;int&gt; a; // uninitialized

    a.copy_from(&amp;mem[0], stdx::vector_aligned);
    print(a);

    a.copy_from(&amp;mem[1], stdx::element_aligned); // vector_aligned would likely crash
    print(a);
}
|p=true
|output=
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
0 1 2 3 4 5 6 7
1 2 3 4 5 6 7 8
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/experimental/simd/dsc memory_alignment}}
{{dsc inc|cpp/experimental/simd/simd/dsc copy_to}}
{{dsc inc|cpp/experimental/simd/simd/dsc constructor}}
{{dsc end}}