{{cpp/experimental/simd/title|copy_to}}
{{cpp/experimental/simd/simd/navbar}}
{{dcl begin}}
{{dcl|since=parallelism_ts_2|1=
template&lt; class U, class Flags &gt;
void copy_to( U* mem, Flags flags );
}}
{{dcl end}}

The store function copies all elements of a {{ltt|cpp/experimental/simd/simd}} such that the i-th element is converted to {{tt|U}} and subsequently written to {{c|mem[i]}} {{simd_for_all_i}}.

===Parameters===
{{par begin}}
{{par|mem|a pointer into an array where {{range|mem|mem + size()}} is a valid range}}
{{par|flags|if of type {{ltt|cpp/experimental/simd/vector_aligned|vector_aligned_tag}}, the load constructor may assume {{c|mem}} to point to storage aligned by {{ltt|cpp/experimental/simd/memory_alignment|memory_alignment_v&lt;simd, U&gt;}}}}
{{par hreq}}
{{par req|{{tt|U}} must be a ''vectorizable'' type.}}
{{par req|{{tt|is_simd_flag_type_v&lt;Flags&gt;}} must be {{c/core|true}}.}}
{{par end}}

===Example===
{{example
|code=
#include &lt;experimental/simd&gt;
#include &lt;iostream&gt;
namespace stdx = std::experimental;
 
int main()
{
    alignas(stdx::memory_alignment_v&lt;stdx::native_simd&lt;int&gt;&gt;)
        std::array&lt;int, stdx::native_simd&lt;int&gt;::size()&gt; mem = {};
 
    stdx::native_simd&lt;int&gt; a = 7;
    a.copy_to(&amp;mem[0], stdx::vector_aligned);

    for (int e : mem)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|p=true
|output=
7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/experimental/simd/element aligned}}
{{dsc inc|cpp/experimental/simd/vector_aligned}}
{{dsc inc|cpp/experimental/simd/overaligned}}
{{dsc inc|cpp/experimental/simd/dsc memory_alignment}}
{{dsc inc|cpp/experimental/simd/simd/dsc copy_from}}
{{dsc end}}