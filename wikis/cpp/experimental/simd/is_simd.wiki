{{cpp/experimental/title|is_simd|is_simd_mask}}
{{cpp/experimental/simd/navbar}}

{{dcl begin}}
{{dcl header|experimental/simd}}
{{dcl|since=parallelism_ts_2|num=1|1=
template&lt; class T &gt;
struct is_simd;
}}
{{dcl|since=parallelism_ts_2|num=2|1=
template&lt; class T &gt;
struct is_simd_mask;
}}
{{dcl end}}

@1@ If {{tt|T}} is a specialization of the {{rlpt|simd}} class template, provides the member constant {{c|value}} equal {{c|true}}. For any other type, {{c|value}} is {{c|false}}.

@2@ If {{tt|T}} is a specialization of the {{rlpt|simd_mask}} class template, provides the member constant {{c|value}} equal {{c|true}}. For any other type, {{c|value}} is {{c|false}}.

===Template parameters===
{{par begin}}
{{par|T|a type to check}}
{{par end}}

===Helper variable template===
{{dcl begin}}
{{dcl|since=parallelism_ts_2|1=
template&lt; class T &gt;
constexpr bool is_simd_v = is_simd&lt;T&gt;::value;
}}
{{dcl|since=parallelism_ts_2|1=
template&lt; class T &gt;
constexpr bool is_simd_mask_v = is_simd_mask&lt;T&gt;::value;
}}
{{dcl end}}

{{cpp/types/integral_constant/inherit|{{tt|T}} is a {{rlpt|simd}}/{{rlpt|simd_mask}} type}}

===Notes===
{{c|is_simd_v&lt;T&gt;}} is necessary but not sufficient for testing whether {{tt|T}} can be used as a SIMD type. For example, {{c|is_simd_v&lt;simd&lt;bool&gt;&gt;}} is {{c|true}}, even though {{c|bool}} is not included in the permissible vectorizable types. The missing condition is {{c|std::is_constructible_v&lt;T&gt;}}, which is {{c|false}} for {{c|simd&lt;bool&gt;}}.

===Example===
{{example
|code=
#include &lt;experimental/simd&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;

namespace stdx = std::experimental;

template&lt;typename T&gt;
void test_simd(std::string_view type_name)
{
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; "Type: " &lt;&lt; type_name &lt;&lt; '\n'
              &lt;&lt; "  is_simd: " &lt;&lt; stdx::is_simd_v&lt;T&gt; &lt;&lt; '\n'
              &lt;&lt; "  is_constructible: " &lt;&lt; std::is_constructible_v&lt;T&gt; &lt;&lt; '\n';
}

template&lt;typename T&gt;
void test_simd_mask(std::string_view type_name)
{
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; "Type: " &lt;&lt; type_name &lt;&lt; '\n'
              &lt;&lt; "  is_simd_mask: " &lt;&lt; stdx::is_simd_mask_v&lt;T&gt; &lt;&lt; '\n'
              &lt;&lt; "  is_constructible: " &lt;&lt; std::is_constructible_v&lt;T&gt; &lt;&lt; "\n\n";
}

int main() 
{
    test_simd&lt;int&gt;("int");
    test_simd_mask&lt;int&gt;("int");

    test_simd&lt;stdx::simd&lt;float&gt;&gt;("simd&lt;float&gt;");
    test_simd_mask&lt;stdx::simd_mask&lt;float&gt;&gt;("simd_mask&lt;float&gt;");

    test_simd&lt;stdx::simd&lt;bool&gt;&gt;("simd&lt;bool&gt;");
    test_simd_mask&lt;stdx::simd_mask&lt;bool&gt;&gt;("simd_mask&lt;bool&gt;");
}
|output=
Type: int
  is_simd: false
  is_constructible: true
Type: int
  is_simd_mask: false
  is_constructible: true

Type: simd&lt;float&gt;
  is_simd: true
  is_constructible: true
Type: simd_mask&lt;float&gt;
  is_simd_mask: true
  is_constructible: true

Type: simd&lt;bool&gt;
  is_simd: true
  is_constructible: false
Type: simd_mask&lt;bool&gt;
  is_simd_mask: true
  is_constructible: false
}}

{{langlinks|ja|zh}}