{{cpp/experimental/title|n=simd_abi::|deduce}}
{{cpp/experimental/simd/navbar}}

{{ddcl|header=experimental/simd|since=parallelism_ts_2|
template&lt; class T, std::size_t N, class ...Abis &gt;
struct deduce;
}}

The type {{c|deduce&lt;T, N, Abis...&gt;::type}} is present if and only if:
* {{c|T}} is a vectorizable type,
* {{c|simd_abi::fixed_size&lt;N&gt;}} is supported, and
* every type in {{c|Abis...}} is an ABI tag.

Let {{tt|DA}} denote {{c|deduce&lt;T, N, Abis...&gt;::type}} when it presents, then
* {{c|1=simd_size_v&lt;T, DA&gt; == N}},
* {{c|simd&lt;T, DA&gt;}} is default constructible, i.e. it is supported,
* {{tt|DA}} is {{rlpt|scalar|simd_abi::scalar}} if {{c|1=N == 1}}, otherwise it is implementation-defined.

===Member types===
{{dsc begin}}
{{dsc hitem|Name|Definition}}
{{dsc|{{tt|type}}|an ABI tag type suitable for specified element type {{tt|T}} and size {{tt|N}}}}
{{dsc end}}

===Helper types===
{{ddcl|since=parallelism_ts_2|1=
template&lt; class T, std::size_t N, class ...Abis &gt;
using deduce_t = typename deduce&lt;T, N, Abis...&gt;::type;
}}

===Notes===
{{tt|simd_abi::deduce}} is SFINAE-friendly.

The ABI tag deduced via this facility is a Quality-of-Implementation feature. 
Implementations can base the choice on {{c|Abis...}}, but can also ignore the {{c|Abis...}} arguments. A simple implementation might simply return {{c|fixed_size&lt;N&gt;}} unconditionally. An optimized implementation might return an implementation-defined extended ABI tag for most inputs. Consequently, if you need an ABI tag for a certain number of elements, use {{rlpt|fixed_size}} if ABI stability is of concern, and prefer {{tt|deduce_t}} otherwise.

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/experimental/simd/dsc scalar}}
{{dsc inc|cpp/experimental/simd/dsc fixed_size}}
{{dsc inc|cpp/experimental/simd/dsc compatible}}
{{dsc inc|cpp/experimental/simd/dsc native}}
{{dsc end}}

{{langlinks|ja|zh}}