{{cpp/experimental/title|future}}
{{cpp/experimental/concurrency/future/navbar}}
{{dcl begin}}
{{dcl header|experimental/future}}
{{dcl|num=1|since=concurrency|
template&lt; class T &gt; class future;
}}
{{dcl|num=2|since=concurrency|
template&lt; class T &gt; class future&lt;T&amp;&gt;;
}}
{{dcl|num=3|since=concurrency|
template&lt;&gt; class future&lt;void&gt;;
}}
{{dcl end}}

The class template {{tt|std::experimental::future}} extends {{lc|std::future}} with the following operations:

* an ''unwrapping constructor'' from {{tt|future&lt;future&lt;T&gt;&gt;}};
* a member function {{tt|is_ready}} to query whether the associated shared state is ready; and
* a member function {{tt|then}} to attach a continuation to the future.

However, there is no interoperation between {{tt|std::experimental::future}} and {{lc|std::future}}.

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/experimental/future/dsc constructor}}
{{dsc inc|cpp/experimental/future/dsc is_ready}}
{{dsc inc|cpp/experimental/future/dsc then}}
{{dsc inc|cpp/experimental/future/dsc operator{{=}}}}
{{dsc end}}

{{identical|std::future|
===Member functions===
Note that {{tt|share()}} returns a {{lc|std::experimental::shared_future&lt;T&gt;}}. The behavior is otherwise identical.

{{dsc begin}}
{{dsc inc|cpp/thread/future/dsc destructor}}
{{dsc inc|cpp/thread/future/dsc share}}

{{dsc h2|Getting the result}}
{{dsc inc|cpp/thread/future/dsc get|future}}

{{dsc h2|State}}
{{dsc inc|cpp/thread/future/dsc valid|future}}
{{dsc inc|cpp/thread/future/dsc wait|future}}
{{dsc inc|cpp/thread/future/dsc wait_for|future}}
{{dsc inc|cpp/thread/future/dsc wait_until|future}}
{{dsc end}}
}}

===Example===
{{example
|code=
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/experimental/dsc shared_future}}
{{dsc end}}

{{langlinks|zh}}