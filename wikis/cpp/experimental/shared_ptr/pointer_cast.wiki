{{cpp/experimental/title|static_pointer_cast|dynamic_pointer_cast|const_pointer_cast| reinterpret_pointer_cast}}
{{cpp/experimental/shared_ptr/navbar}}
{{dcl begin}}
{{dcl|num=1|since=libfund_ts|1= 
template&lt; class T, class U &gt; 
std::experimental::shared_ptr&lt;T&gt;
    static_pointer_cast( const std::experimental::shared_ptr&lt;U&gt;&amp; r ) noexcept;
}}
{{dcl|num=2|since=libfund_ts|1= 
template&lt; class T, class U &gt; 
std::experimental::shared_ptr&lt;T&gt;
    dynamic_pointer_cast( const std::experimental::shared_ptr&lt;U&gt;&amp; r ) noexcept;
}}
{{dcl|num=3|since=libfund_ts|1= 
template&lt; class T, class U &gt; 
std::experimental::shared_ptr&lt;T&gt;
    const_pointer_cast( const std::experimental::shared_ptr&lt;U&gt;&amp; r ) noexcept;
}}
{{dcl|num=4|since=libfund_ts|1= 
template&lt; class T, class U &gt; 
std::experimental::shared_ptr&lt;T&gt;
    reinterpret_pointer_cast( const std::experimental::shared_ptr&lt;U&gt;&amp; r ) noexcept;
}}
{{dcl end}}

Creates a new instance of {{lc|std::experimental::shared_ptr}} whose stored pointer is obtained from {{c|r}}'s stored pointer using a cast expression. If {{c|r}} is empty, so is the new {{tt|shared_ptr}} (but its stored pointer is not necessarily null).

Otherwise, the new {{tt|shared_ptr}} will share ownership with {{c|r}}, except that it is empty if the {{tt|dynamic_cast}} performed by {{tt|dynamic_pointer_cast}} returns a null pointer.

Let {{tt|Y}} be {{c|typename std::experimental::shared_ptr&lt;T&gt;::element_type}}, then the resulting {{lc|std::experimental::shared_ptr}}'s stored pointer will be obtained by calling (in respective order):
@1@ {{c|static_cast&lt;Y*&gt;(r.get())}}.
@2@ {{c|dynamic_cast&lt;Y*&gt;(r.get())}} (if the result of the {{tt|dynamic_cast}} is a null pointer value, the returned {{tt|shared_ptr}} will be empty).
@3@ {{c|const_cast&lt;Y*&gt;(r.get())}}.
@4@ {{c|reinterpret_cast&lt;Y*&gt;(r.get())}}.

The behavior of these functions is undefined unless the corresponding cast from {{tt|U*}} to {{tt|T*}} is well formed:
@1@ The behavior is undefined unless {{c|static_cast&lt;T*&gt;((U*)nullptr)}} is well formed.
@2@ The behavior is undefined unless {{c|dynamic_cast&lt;T*&gt;((U*)nullptr)}} is well formed.
@3@ The behavior is undefined unless {{c|const_cast&lt;T*&gt;((U*)nullptr)}} is well formed.
@4@ The behavior is undefined unless {{c|reinterpret_cast&lt;T*&gt;((U*)nullptr)}} is well formed.

===Parameters===
{{par begin}}
{{par|r|the pointer to convert}}
{{par end}}

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/experimental/shared_ptr/dsc constructor}}
{{dsc inc|cpp/memory/shared_ptr/dsc pointer cast}}
{{dsc end}}