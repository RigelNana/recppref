{{cpp/experimental/shared_ptr/title|shared_ptr}}
{{cpp/experimental/shared_ptr/navbar}}
{{dcl begin}}
{{dcl|num=1|1= 
constexpr shared_ptr() noexcept;
}}
{{dcl|num=2|1= 
constexpr shared_ptr( std::nullptr_t ) noexcept;
}}
{{dcl|num=3|1= 
template&lt; class Y &gt; 
explicit shared_ptr( Y* ptr );
}}
{{dcl|num=4|1= 
template&lt; class Y, class Deleter &gt; 
shared_ptr( Y* ptr, Deleter d );
}}
{{dcl|num=5|1= 
template&lt; class Deleter &gt; 
shared_ptr( std::nullptr_t ptr, Deleter d );
}}
{{dcl|num=6|1= 
template&lt; class Y, class Deleter, class Alloc &gt; 
shared_ptr( Y* ptr, Deleter d, Alloc alloc );
}}
{{dcl|num=7|1= 
template&lt; class Deleter, class Alloc &gt; 
shared_ptr( std::nullptr_t ptr, Deleter d, Alloc alloc );
}}
{{dcl|num=8|1= 
template&lt; class Y &gt; 
shared_ptr( const shared_ptr&lt;Y&gt;&amp; r, element_type *ptr ) noexcept;
}}
{{dcl|num=9|1= 
shared_ptr( const shared_ptr&amp; r ) noexcept;
}}
{{dcl|num=9|1= 
template&lt; class Y &gt; 
shared_ptr( const shared_ptr&lt;Y&gt;&amp; r ) noexcept;
}}
{{dcl|num=10|1= 
shared_ptr( shared_ptr&amp;&amp; r ) noexcept;
}}
{{dcl|num=10|1= 
template&lt; class Y &gt; 
shared_ptr( shared_ptr&lt;Y&gt;&amp;&amp; r ) noexcept;
}}
{{dcl|num=11|1= 
template&lt; class Y &gt; 
explicit shared_ptr( const std::weak_ptr&lt;Y&gt;&amp; r );
}}
{{dcl|num=12|1= 
template&lt; class Y &gt; 
shared_ptr( std::auto_ptr&lt;Y&gt;&amp;&amp; r );
}}
{{dcl|num=13|1= 
template&lt; class Y, class Deleter &gt; 
shared_ptr( std::unique_ptr&lt;Y,Deleter&gt;&amp;&amp; r );
}}
{{dcl end}}

Constructs new {{tt|shared_ptr}} from a variety of pointer types that refer to an object to manage. 

For the purposes of the description below, a pointer type {{tt|Y*}} is said to be compatible with a pointer type {{tt|T*}} if either {{tt|Y*}} is convertible to {{tt|T*}} or {{tt|Y}} is the array type {{tt|U[N]}} and {{tt|T}} is {{tt|U cv []}} (where cv is some set of cv-qualifiers).

@1,2@ Constructs a {{tt|shared_ptr}} with no managed object, i.e. empty {{tt|shared_ptr}}.

@3-7@ Constructs a {{tt|shared_ptr}} with {{c|ptr}} as the pointer to the managed object. If {{tt|T}} is an array type {{tt|U[N]}}, {{tt|Y(*)[N]}} must be convertible to {{tt|T*}}. If {{tt|T}} is an array type {{tt|U[]}}, {{tt|Y(*)[]}} must be convertible to {{tt|T*}}. Otherwise, {{tt|Y*}} must be convertible to {{tt|T*}}. Additionally:

:@3@ Uses a [[cpp/language/delete|delete-expression]] ({{c|delete ptr}}, if {{tt|T}} is not an array type; {{c|delete[] ptr}} if {{tt|T}} is an array type) as the deleter. {{tt|Y}} must be a complete type. That delete expression must be well formed, have well-defined behavior and not throw any exceptions.

:@4,5@ Uses the specified deleter {{c|d}} as the deleter. The expression {{c|d(ptr)}} must be well formed, have well-defined behavior and not throw any exceptions. {{tt|Deleter}} must be {{named req|CopyConstructible}}, and its copy constructor and destructor must not throw exceptions.

:@6,7@ Same as {{v|4,5}}, but additionally uses a copy of {{c|alloc}} for allocation of data for internal use. {{tt|Alloc}} must be a {{named req|Allocator}}, and its copy constructor and destructor must not throw exceptions.

@8@ The ''aliasing constructor'': constructs a {{tt|shared_ptr}} which shares ownership information with {{c|r}}, but holds an unrelated and unmanaged pointer {{c|ptr}}. Even if this {{tt|shared_ptr}} is the last of the group to go out of scope, it will call the destructor for the object originally managed by {{c|r}}. However, calling {{tt|get()}} on this will always return a copy of {{c|ptr}}. It is the responsibility of the programmer to make sure that this {{c|ptr}} remains valid as long as this shared_ptr exists, such as in the typical use cases where {{c|ptr}} is a member of the object managed by {{c|r}} or is an alias (e.g., downcast) of {{c|r.get()}}.

@9@ Constructs a {{tt|shared_ptr}} which shares ownership of the object managed by {{c|r}}. If {{c|r}} manages no object, {{c|*this}} manages no object too. The template overload doesn't participate in overload resolution if {{tt|Y*}} is not ''compatible with'' {{tt|T*}}.

@10@ Move-constructs a {{tt|shared_ptr}} from {{c|r}}. After the construction, {{c|*this}} contains a copy of the previous state of {{c|r}}, {{c|r}} is empty. The template overload doesn't participate in overload resolution if {{tt|Y*}} is not ''compatible with'' {{tt|T*}}.

@11@ Constructs a {{tt|shared_ptr}} which shares ownership of the object managed by {{c|r}}. {{tt|Y*}} must be ''compatible with'' {{tt|T*}}. Note that {{c|r.lock()}} may be used for the same purpose: the difference is that this constructor throws an exception if the argument is empty, while {{c|weak_ptr&lt;T&gt;::lock()}} constructs an empty {{tt|shared_ptr}} in that case.

@12@ Constructs a {{tt|shared_ptr}} that stores and owns the object formerly owned by {{c|r}}. {{tt|Y*}} must be convertible to {{tt|T*}}. After construction, {{c|r}} is empty.

@13@ Constructs a {{tt|shared_ptr}} which manages the object currently managed by {{c|r}}. The deleter associated with {{c|r}} is stored for future deletion of the managed object. {{c|r}} manages no object after the call. This overload doesn't participate in overload resolution if {{tt|Y*}} is not ''compatible with'' {{tt|T*}}. &lt;br&gt; If {{tt|D}} is a reference type, equivalent to {{c|shared_ptr(r.release(), std::ref(r.get_deleter())}}. Otherwise, equivalent to {{c|shared_ptr(r.release(), r.get_deleter())}}.

===Notes===
When constructing a {{tt|shared_ptr}} from a raw pointer to an object of a type derived from {{lc|std::experimental::enable_shared_from_this}}, the constructors of {{tt|shared_ptr}} update the private {{tt|weak_ptr}} member of the {{lc|std::experimental::enable_shared_from_this}} base so that future calls to {{ltt|cpp/memory/enable_shared_from_this/shared_from_this|shared_from_this()}} would share ownership with the {{tt|shared_ptr}} created by this raw pointer constructor.

The raw pointer overloads assume ownership of the pointed-to object, and so constructing a {{tt|shared_ptr}} using the raw pointer overload for an object that is already managed by a {{tt|shared_ptr}} may lead to undefined behavior, even if the object is of a type derived from {{lc|std::experimental::enable_shared_from_this}}.

===Parameters===
{{par begin}}
{{par|ptr|a pointer to an object to manage}}
{{par|d|a deleter to use to destroy the object}}
{{par|alloc|an allocator to use for allocations of data for internal use}}
{{par|r|another smart pointer to share the ownership to or acquire the ownership from}}
{{par end}} 

===Exceptions===
@3@ {{lc|std::bad_alloc}} if required additional memory could not be obtained. May throw implementation-defined exception for other errors. The applicable delete-expression ({{c|delete ptr}} if {{tt|T}} is not an array type, {{c|delete[] ptr}} otherwise) is called if an exception occurs.

@4-7@ {{lc|std::bad_alloc}} if required additional memory could not be obtained. May throw implementation-defined exception for other errors. {{c|d(ptr)}} is called if an exception occurs.

@11@ {{lc|std::bad_weak_ptr}} if {{c|r.expired() {{==}} true}}. The constructor has no effect in this case.

@12@ {{lc|std::bad_alloc}} if required additional memory could not be obtained. May throw implementation-defined exception for other errors. This constructor has no effect if an exception occurs.

@13@ If an exception is thrown, the constructor has no effects.

===Example===
{{example
|code=
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/shared_ptr/dsc make_shared}}
{{dsc inc|cpp/memory/shared_ptr/dsc allocate_shared}}
{{dsc end}}