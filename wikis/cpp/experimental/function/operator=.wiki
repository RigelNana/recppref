{{cpp/experimental/function/title|operator{{=}}}}
{{cpp/experimental/lib extensions/pmr/navbar}}
{{dcl begin}}
{{dcl|num=1|since=libfund_ts|1=
function&amp; operator=( const function&amp; other );
}}
{{dcl|num=2|since=libfund_ts|1=
function&amp; operator=( function&amp;&amp; other );
}}
{{dcl|num=3|since=libfund_ts|1=
function&amp; operator=( std::nullptr_t ) noexcept;
}}
{{dcl|num=4|since=libfund_ts|1=
template&lt; class F &gt;
function&amp; operator=( F&amp;&amp; f );
}}
{{dcl rev multi|num=5
|since1=libfund_ts|dcl1=
template&lt; class F &gt;
function&amp; operator=( std::reference_wrapper&lt;F&gt; f );
|since2=libfund_ts_3|dcl2=
template&lt; class F &gt;
function&amp; operator=( std::reference_wrapper&lt;F&gt; f ) noexcept;
}}
{{dcl end}}

Assigns a new ''target'' to {{tt|std::experimental::function}}. In the description below, let {{c|ALLOCATOR_OF(f)}} be the allocator specified in the construction of {{c|f}}, or {{rev inl|until=libfund_ts_3|the value of {{c|std::experimental::pmr::get_default_resource()}}}}{{rev inl|since=libfund_ts_3|the default-constructed {{c|std::pmr::polymorphic_allocator&lt;&gt;}} value}} at the time of construction if no allocator was specified.&lt;!-- LWG 2527 --&gt;

@1@ Assigns a copy of ''target'' of {{c|other}}, as if by executing {{c|function(std::allocator_arg, ALLOCATOR_OF(*this), other).swap(*this);}}.

@2@ Moves the ''target'' of {{c|other}} to {{c|*this}}, as if by executing {{c|function(std::allocator_arg, ALLOCATOR_OF(*this), std::move(other)).swap(*this);}}. {{c|other}} is in a valid state with an unspecified value.

@3@ Destroys the ''target'' of {{c|*this}}. {{c|*this}} is ''empty'' after the call. The memory resource returned by {{tt|get_memory_resource()}} after the assignment is equivalent to the memory resource before the assignment, but the address may change.

@4@ Sets the ''target'' of {{c|*this}} to the callable {{c|f}}, as if by executing {{c|function(std::allocator_arg, ALLOCATOR_OF(*this),std::forward&lt;F&gt;(f)).swap(*this);}}. This operator does not participate in overload resolution unless {{c|f}} is {{named req|Callable}} for argument types {{tt|Args...}} and return type {{tt|R}}.

@5@ Sets the ''target'' of {{c|*this}} to a copy of {{c|f}}, as if by executing {{c|function(std::allocator_arg, ALLOCATOR_OF(*this), f).swap(*this);}}.

===Parameters===
{{par begin}}
{{par|other|another {{tt|std::experimental::function}} object to copy or move from}}
{{par|f|a callable to initialize the ''target'' with}}
{{par hreq}}
{{par req named|F|Callable}}
{{par end}}

===Return value===
{{c|*this}}

===Exceptions===
@1,2,4@ Exception thrown on needed allocation of the storage or initialization of the target of {{c|*this}}, if any.
@5@ (none)

===Notes===
The move assignment operator may need to allocate storage if {{rev inl|until=libfund_ts_3|{{c|1=get_memory_resource() != other.get_memory_resource()}}}}{{rev inl|since=libfund_ts_3|{{c|1=get_allocator() != other.get_allocator()}}}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}