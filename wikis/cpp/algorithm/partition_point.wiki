{{cpp/title|partition_point}}
{{cpp/algorithm/navbar}}
{{ddcl|header=algorithm|since=c++11|notes={{mark constexpr since c++20}}|
template&lt; class ForwardIt, class UnaryPred &gt;
ForwardIt partition_point( ForwardIt first, ForwardIt last, UnaryPred p );
}}

Examines the partitioned range {{range|first|last}} and locates the end of the first partition, that is, the first element that does not satisfy {{c|p}} or {{c|last}} if all elements satisfy {{c|p}}.

If the elements {{c|elem}} of {{range|first|last}} are not {{rlp|/#Requirements|partitioned}} with respect to the expression {{c|bool(p(elem))}}, the behavior is undefined.

===Parameters===
{{par begin}}
{{par|first, last|the partitioned range of elements to examine}}
{{par pred1|p|for the elements found in the beginning of the range|p1=ForwardIt}}
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req named|UnaryPred|Predicate}}
{{par end}}

===Return value===
The iterator past the end of the first partition within {{range|first|last}} or {{c|last}} if all elements satisfy {{c|p}}.

===Complexity===
Given {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first, last)}}, performs {{mathjax-or|\(\scriptsize O(log(N))\)|O(log(N))}} applications of the predicate {{c|p}}.

===Notes===
This algorithm is a more general form of {{lc|std::lower_bound}}, which can be expressed in terms of {{tt|std::partition_point}} with the predicate {{c|[&amp;](const auto&amp; e) { return e &lt; value; });}}.

===Possible implementation===
{{eq fun|1=
template&lt;class ForwardIt, class UnaryPred&gt;
constexpr //&lt; since C++20
ForwardIt partition_point(ForwardIt first, ForwardIt last, UnaryPred p)
{
    for (auto length = std::distance(first, last); 0 &lt; length; )
    {
        auto half = length / 2;
        auto middle = std::next(first, half);
        if (p(*middle))
        {
            first = std::next(middle);
            length -= (half + 1);
        }
        else
            length = half;
    }
    
    return first;
}
}}

===Example===
{{example
|
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

auto print_seq = [](auto rem, auto first, auto last)
{
    for (std::cout &lt;&lt; rem; first != last; std::cout &lt;&lt; *first++ &lt;&lt; ' ') {}
    std::cout &lt;&lt; '\n';
};

int main()
{
    std::array v{1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    auto is_even = [](int i) { return i % 2 == 0; };
    
    std::partition(v.begin(), v.end(), is_even);
    print_seq("After partitioning, v: ", v.cbegin(), v.cend());
    
    const auto pp = std::partition_point(v.cbegin(), v.cend(), is_even);
    const auto i = std::distance(v.cbegin(), pp);
    std::cout &lt;&lt; "Partition point is at " &lt;&lt; i &lt;&lt; "; v[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; *pp &lt;&lt; '\n';
    
    print_seq("First partition (all even elements): ", v.cbegin(), pp);
    print_seq("Second partition (all odd elements): ", pp, v.cend());
}
|p=true
|output=
After partitioning, v: 8 2 6 4 5 3 7 1 9
Partition point is at 4; v[4] = 5
First partition (all even elements): 8 2 6 4
Second partition (all odd elements): 5 3 7 1 9
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc find}}
{{dsc inc|cpp/algorithm/dsc is_sorted}}
{{dsc inc|cpp/algorithm/dsc lower_bound}}
{{dsc inc|cpp/algorithm/ranges/dsc partition_point}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}