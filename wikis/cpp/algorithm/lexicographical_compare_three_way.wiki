{{cpp/title|lexicographical_compare_three_way}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|since=c++20|num=1|
template&lt; class InputIt1, class InputIt2, class Cmp &gt;
constexpr auto lexicographical_compare_three_way
    ( InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
      Cmp comp ) -&gt; decltype(comp(*first1, *first2));
}}
{{dcl|since=c++20|num=2|
template&lt; class InputIt1, class InputIt2 &gt;
constexpr auto lexicographical_compare_three_way
    ( InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2 );
}}
{{dcl end}}

Lexicographically compares two ranges {{range|first1|last1}} and {{range|first2|last2}} using three-way comparison and produces a result of the strongest applicable comparison category type.

@1@ Returns the order between the first non-equivalent pair of elements according to {{c|comp}} in both ranges if any, otherwise (if one ranges is equivalent to the prefix of another according to {{c|comp}}), returns the order between the length of both ranges.

@2@ Equivalent to {{c multi|return std::lexicographical_compare_three_way(|    first1, last1, first2, last2, std::compare_three_way());}}

If the return type is not one of the three comparison category types, the program is ill-formed:
* {{ltt std|cpp/utility/compare/strong_ordering}}
* {{ltt std|cpp/utility/compare/weak_ordering}}
* {{ltt std|cpp/utility/compare/partial_ordering}}

===Parameters===
{{par begin}}
{{par|first1, last1|the first range of elements to examine}}
{{par|first2, last2|the second range of elements to examine}}
{{par|comp|a function object}}
{{par hreq}}
{{par req named|InputIt1, InputIt2|InputIterator}}
{{par end}}

===Return value===
The value of a comparison category type specified above.

===Complexity===
Given {{mathjax-or|\(\scriptsize N_1\)|N{{su|b=1}}}} as {{c|std::distance(first1, last1)}} and {{mathjax-or|\(\scriptsize N_2\)|N{{su|b=2}}}} as {{c|std::distance(first2, last2)}}:

@1@ At most {{mathjax-or|\(\scriptsize \min(N_1,N_2)\)|min({{su|b=1}},N{{su|b=2}})}} applications of {{c|comp}}.

@2@ At most {{mathjax-or|\(\scriptsize \min(N_1,N_2)\)|min(N{{su|b=1}},N{{su|b=2}})}} applications of {{c|std::compare_three_way()}}.

===Possible implementation===
{{eq fun|1=
template&lt;class I1, class I2, class Cmp&gt;
constexpr auto lexicographical_compare_three_way(I1 f1, I1 l1, I2 f2, I2 l2, Cmp comp)
    -&gt; decltype(comp(*f1, *f2))
{
    using ret_t = decltype(comp(*f1, *f2));
    static_assert(std::disjunction_v&lt;
                      std::is_same&lt;ret_t, std::strong_ordering&gt;,
                      std::is_same&lt;ret_t, std::weak_ordering&gt;,
                      std::is_same&lt;ret_t, std::partial_ordering&gt;&gt;,
                  "The return type must be a comparison category type.");
    
    bool exhaust1 = (f1 == l1);
    bool exhaust2 = (f2 == l2);
    for (; !exhaust1 &amp;&amp; !exhaust2; exhaust1 = (++f1 == l1), exhaust2 = (++f2 == l2))
        if (auto c = comp(*f1, *f2); c != 0)
            return c;
    
    return !exhaust1 ? std::strong_ordering::greater:
           !exhaust2 ? std::strong_ordering::less:
                       std::strong_ordering::equal;
}
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#include &lt;compare&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;
#include &lt;utility&gt;

using namespace std::literals;

void show_result(std::string_view s1, std::string_view s2, std::strong_ordering o)
{
    std::cout &lt;&lt; std::quoted(s1) &lt;&lt; " is ";
    std::is_lt(o) ? std::cout &lt;&lt; "less than ":
    std::is_gt(o) ? std::cout &lt;&lt; "greater than ":
                    std::cout &lt;&lt; "equal to ";
    std::cout &lt;&lt; std::quoted(s2) &lt;&lt; '\n';
}

std::strong_ordering cmp_icase(unsigned char x, unsigned char y)
{
    return std::toupper(x) &lt;=&gt; std::toupper(y);
};
    
int main()
{
    for (const auto&amp; [s1, s2] :
    {
        std::pair{"one"sv, "ONE"sv}, {"two"sv, "four"sv}, {"three"sv, "two"sv}
    })
    {
        const auto res = std::lexicographical_compare_three_way(
            s1.cbegin(), s1.cend(), s2.cbegin(), s2.cend(), cmp_icase);
        show_result(s1, s2, res);
    }
}
|output=
"one" is equal to "ONE"
"two" is greater than "four"
"three" is less than "two"
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3410|std=C++20|before=extraneous comparisons between iterators were required|after=such requirement removed}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc lexicographical_compare}}
{{dsc inc|cpp/utility/compare/dsc compare_three_way}}
{{dsc inc|cpp/algorithm/ranges/dsc lexicographical_compare}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}