{{cpp/title|fill_n}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl rev begin|num=1}}
{{dcla|anchor=1|constexpr=c++20|until=c++26|
template&lt; class OutputIt, class Size, class T &gt;
OutputIt fill_n( OutputIt first, Size count, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class OutputIt, class Size,
          class T = typename std::iterator_traits
                        &lt;OutputIt&gt;::value_type &gt;
constexpr OutputIt fill_n( OutputIt first, Size count,
                           const T&amp; value );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++17|until=c++26|
template&lt; class ExecutionPolicy,
          class ForwardIt, class Size, class T &gt;
ForwardIt fill_n( ExecutionPolicy&amp;&amp; policy,
                  ForwardIt first, Size count, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class ExecutionPolicy,
          class ForwardIt, class Size,
          class T = typename std::iterator_traits
                        &lt;OutputIt&gt;::value_type &gt;
ForwardIt fill_n( ExecutionPolicy&amp;&amp; policy,
                  ForwardIt first, Size count, const T&amp; value );
}}
{{dcl rev end}}
{{dcl end}}

@1@ Assigns the given {{c|value}} to the first {{c|count}} elements in the range beginning at {{c|first}} if {{c|count &gt; 0}}. Does nothing otherwise.

@2@ Same as {{v|1}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition}}

If any of the following conditions is satisfied, the program is ill-formed:
* {{c|value}} is not [[cpp/iterator#Types and writability|writable]] to {{c|first}}.
* {{tt|Size}} is not [[cpp/language/implicit cast|convertible]] to an [[cpp/language/type|integral type]].

===Parameters===
{{par begin}}
{{par|first|the beginning of the range of elements to modify}}
{{par|count|number of elements to modify}}
{{par|value|the value to be assigned}}
{{par exec pol}}
{{par hreq}}
{{par req named|OutputIt|OutputIterator}}
{{par req named|ForwardIt|ForwardIterator}}
{{par end}}

===Return value===
Iterator one past the last element assigned if {{c|count &gt; 0}}, {{c|first}} otherwise.

===Complexity===
Exactly {{c|std::max(0, count)}} assignments.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=yes}}

===Possible implementation===
{{eq impl|ver1=1|title1=fill_n|1=
template&lt;class OutputIt, class Size,
         class T = typename std::iterator_traits&lt;OutputIt&gt;::value_type&gt;
OutputIt fill_n(OutputIt first, Size count, const T&amp; value)
{
    for (Size i = 0; i &lt; count; i++)
        *first++ = value;
    return first;
}
}}

===Notes===
{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms {{vl|1,2}}}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; v1{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    // replace values of the first 5 elements with -1
    std::fill_n(v1.begin(), 5, -1);

    std::copy_n(v1.cbegin(), v1.size(), std::ostream_iterator&lt;int&gt;(std::cout, " "));
    std::cout &lt;&lt; '\n';

    std::vector&lt;std::complex&lt;double&gt;&gt; nums{&lt;!----&gt;{1, 3}, {2, 2}, {4, 8}&lt;!----&gt;};
    #ifdef __cpp_lib_algorithm_default_value_type
        std::fill_n(nums.begin(), 2, {4, 2});
    #else
        std::fill_n(nums.begin(), 2, std::complex&lt;double&gt;{4, 2});
    #endif
    std::copy_n(nums.cbegin(), nums.size(),
                std::ostream_iterator&lt;std::complex&lt;double&gt;&gt;(std::cout, " "));
    std::cout &lt;&lt; '\n';
}
|output=
-1 -1 -1 -1 -1 5 6 7 8 9
(4,2) (4,2) (4,8)
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=283|std=C++98|before={{tt|T}} was required to be {{named req|CopyAssignable}}, but&lt;br&gt;{{tt|T}} is not always writable to {{tt|OutputIt}}&lt;!-- No ForwardIt here because this DR targets C++98 --&gt;|after=required to be writable instead}}
{{dr list item|wg=lwg|dr=426|std=C++98|before=the complexity requirement was “exactly {{c|count}}&lt;br&gt;assignments”, which is broken if {{c|count}} is negative|after=no assignment if&lt;br&gt;{{c|count}} is non-positive}}
{{dr list item|wg=lwg|dr=865|std=C++98|before=the location of the first element following&lt;br&gt;the filling range was not returned|after=returned}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc fill}}
{{dsc inc|cpp/algorithm/ranges/dsc fill_n}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}