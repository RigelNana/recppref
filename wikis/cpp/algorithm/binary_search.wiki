{{cpp/title|binary_search}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl rev begin|num=1}}
{{dcla|anchor=1|constexpr=c++20|until=c++26|
template&lt; class ForwardIt, class T &gt;
bool binary_search( ForwardIt first, ForwardIt last,
                    const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class ForwardIt, class T = typename std::iterator_traits
                                         &lt;ForwardIt&gt;::value_type &gt;
constexpr bool binary_search( ForwardIt first, ForwardIt last,
                              const T&amp; value );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcla|anchor=2|constexpr=c++20|until=c++26|
template&lt; class ForwardIt, class T, class Compare &gt;
bool binary_search( ForwardIt first, ForwardIt last,
                    const T&amp; value, Compare comp );
}}
{{dcl|since=c++26|1=
template&lt; class ForwardIt, class T = typename std::iterator_traits
                                         &lt;ForwardIt&gt;::value_type,
          class Compare &gt;
constexpr bool binary_search( ForwardIt first, ForwardIt last,
                              const T&amp; value, Compare comp );
}}
{{dcl rev end}}
{{dcl end}}

Checks if an element equivalent to {{c|value}} appears within the partitioned range {{range|first|last}}.

@1@ The equivalence is checked using {{c/core|operator&lt;}}:
{{rev begin}}
{{rev|until=c++20|
If {{c|!bool(*iter &lt; value) &amp;&amp; !bool(value &lt; *iter)}} is {{c|true}} for some iterator {{c|iter}} in {{range|first|last}}, returns {{c|true}}. Otherwise returns {{c|false}}.

If any of the following conditions is satisfied, the behavior is undefined:
* For any element {{c|elem}} of {{range|first|last}}, {{c|bool(elem &lt; value)}} does not imply {{c|!bool(value &lt; elem)}}.
* The elements {{c|elem}} of {{range|first|last}} are not {{rlp|/#Requirements|partitioned}} with respect to expressions {{c|bool(elem &lt; value)}} and {{c|!bool(value &lt; elem)}}.
}}
{{rev|since=c++20|
Equivalent to {{c|std::binary_search(first, last, value, std::less{})}}.
}}
{{rev end}}

@2@ The equivalence is checked using {{c|comp}}:
@@ If {{c|!bool(comp(*iter, value)) &amp;&amp; !bool(comp(value, *iter))}} is {{c|true}} for some iterator {{c|iter}} in {{range|first|last}}, returns {{c|true}}. Otherwise returns {{c|false}}.
@@ If any of the following conditions is satisfied, the behavior is undefined:
* For any element {{c|elem}} of {{range|first|last}}, {{c|bool(comp(elem, value))}} does not imply {{c|!bool(comp(value, elem))}}.
* The elements {{c|elem}} of {{range|first|last}} are not {{rlp|/#Requirements|partitioned}} with respect to expressions {{c|bool(comp(elem, value))}} and {{c|!bool(comp(value, elem))}}.

===Parameters===
{{par begin}}
{{par|first, last|the partitioned range of elements to examine}}
{{par|value|value to compare the elements to}}
{{par pred2|comp|if the first argument is ordered before the second|bidirectional=true|t1=T|p2=ForwardIt}} 
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req named|Compare|BinaryPredicate|notes=It is not required to satisfy {{named req|Compare}}.}}
{{par end}}

===Return value===
{{c|true}} if an element equivalent to {{c|value}} is found, {{c|false}} otherwise.

===Complexity===
Given {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first, last)}}:

@1@ At most {{mathjax-or|\(\scriptsize \log_{2}(N)+O(1)\)|log{{su|b=2}}(N)+O(1)}} comparisons with {{c|value}} using {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}}.

@2@ At most {{mathjax-or|\(\scriptsize \log_{2}(N)+O(1)\)|log{{su|b=2}}(N)+O(1)}} applications of the comparator {{c|comp}}.

However, if {{tt|ForwardIt}} is not a {{named req|RandomAccessIterator}}, the number of iterator increments is linear in {{mathjax-or|\(\scriptsize N\)|N}}.

===Notes===
Although {{tt|std::binary_search}} only requires {{range|first|last}} to be partitioned, this algorithm is usually used in the case where {{range|first|last}} is sorted, so that the binary search is valid for any {{c|value}}.

{{tt|std::binary_search}} only checks whether an equivalent element exists. To obtain an iterator to that element (if exists), {{lc|std::lower_bound}} should be used instead.

{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms {{vl|1,2}}}}

===Possible implementation===
See also the implementations in [https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L2236 libstdc++] and [https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L4320 libc++].
{{eq impl
|title1=binary_search (1)|ver1=1|1=
template&lt;class ForwardIt, class T = typename std::iterator_traits&lt;ForwardIt&gt;::value_type&gt;
bool binary_search(ForwardIt first, ForwardIt last, const T&amp; value)
{
    return std::binary_search(first, last, value, std::less{});
}
|title2=binary_search (2)|ver2=2|2=
template&lt;class ForwardIt, class T = typename std::iterator_traits&lt;ForwardIt&gt;::value_type,
         class Compare&gt;
bool binary_search(ForwardIt first, ForwardIt last, const T&amp; value, Compare comp)
{
    first = std::lower_bound(first, last, value, comp);
    return (!(first == last) and !(comp(value, *first)));
}
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    const auto haystack = {1, 3, 4, 5, 9};
    
    for (const auto needle : {1, 2, 3})
    {
        std::cout &lt;&lt; "Searching for " &lt;&lt; needle &lt;&lt; '\n';
        if (std::binary_search(haystack.begin(), haystack.end(), needle))
            std::cout &lt;&lt; "Found " &lt;&lt; needle &lt;&lt; '\n';
        else
            std::cout &lt;&lt; "Not found!\n";
    }

    using CD = std::complex&lt;double&gt;;
    std::vector&lt;CD&gt; nums{&lt;!----&gt;{1, 1}, {2, 3}, {4, 2}, {4, 3}&lt;!----&gt;};
    auto cmpz = [](CD x, CD y){ return abs(x) &lt; abs(y); };
    #ifdef __cpp_lib_algorithm_default_value_type
        assert(std::binary_search(nums.cbegin(), nums.cend(), {4, 2}, cmpz));
    #else
        assert(std::binary_search(nums.cbegin(), nums.cend(), CD{4, 2}, cmpz));
    #endif
}
|output=
Searching for 1
Found 1
Searching for 2
Not found!
Searching for 3
Found 3
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=270|std=C++98|before={{tt|Compare}} was required to satisfy {{named req|Compare}} and {{tt|T}} was required&lt;br&gt;to be {{named req|LessThanComparable}} (strict weak ordering required)|after=only a partitioning is required;&lt;br&gt;heterogeneous comparisons permitted}}
{{dr list item|wg=lwg|dr=787|std=C++98|before=at most {{mathjax-or|\(\scriptsize \log_{2}(N)+2\)|log{{su|b=2}}(N)+2}} comparisons were allowed|after=corrected to {{mathjax-or|\(\scriptsize \log_{2}(N)+O(1)\)|log{{su|b=2}}(N)+O(1)}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc equal_range}}
{{dsc inc|cpp/algorithm/dsc lower_bound}}
{{dsc inc|cpp/algorithm/dsc upper_bound}}
{{dsc inc|cpp/algorithm/ranges/dsc binary_search}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}