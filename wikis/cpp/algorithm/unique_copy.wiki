{{cpp/title|unique_copy}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|num=1|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class OutputIt &gt;
OutputIt unique_copy( InputIt first, InputIt last, OutputIt d_first );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt1, class ForwardIt2 &gt;
ForwardIt2 unique_copy( ExecutionPolicy&amp;&amp; policy, ForwardIt1 first,
                        ForwardIt1 last, ForwardIt2 d_first );
}}
{{dcl|num=3|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class OutputIt, class BinaryPred &gt;
OutputIt unique_copy( InputIt first, InputIt last,
                      OutputIt d_first, BinaryPred p );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt1,
          class ForwardIt2, class BinaryPred &gt;
ForwardIt2 unique_copy( ExecutionPolicy&amp;&amp; policy,
                        ForwardIt1 first, ForwardIt1 last,
                        ForwardIt2 d_first, BinaryPred p );
}}
{{dcl end}}

Copies the elements from the range {{range|first|last}}, to another range beginning at {{c|d_first}} in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.

@1@ Elements are compared using {{c/core|1=operator==}}.
@@ If {{c/core|1=operator==}} does not establish an {{enwiki|equivalence relation}}, the behavior is undefined.

@3@ Elements are compared using the given binary predicate {{c|p}}.
@@ If {{c|p}} does not establish an equivalence relation, the behavior is undefined.

@2,4@ Same as {{v|1,3}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

If {{rev inl|until=c++20|{{c|1=*d_first = *first}} is invalid}}{{rev inl|since=c++20|{{c|*first}} is not [[cpp/iterator#Types and writability|writable]] to {{c|d_first}}}}, the program is ill-formed.

If source and destination ranges overlap, the behavior is undefined.

Given {{tt|T}} as the value type of {{tt|InputIt}}, if overload {{v|1}} or {{v|3}} does '''not''' satisfy all of the following conditions, the behavior is undefined:
{{rev begin}}
{{rev|until=c++20|
* {{tt|InputIt}} meets the requirements of {{named req|ForwardIterator}}.
}}
{{rev|since=c++20|
* {{tt|InputIt}} models {{lconcept|forward_iterator}}.
}}
{{rev end}}
* {{tt|T}} is both {{named req|CopyConstructible}} and {{named req|CopyAssignable}}.
* All following conditions are satisfied:
:* {{tt|OutputIt}} meets the requirements of {{named req|ForwardIterator}}.
:* The value type of {{tt|OutputIt}} is also {{tt|T}}.
:* {{tt|T}} is {{named req|CopyAssignable}}.

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to process}}
{{par|d_first|the beginning of the destination range}}
{{par exec pol}}
{{par pred2 eq|p|p1=InputIt}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|OutputIt|OutputIterator}}
{{par req named|ForwardIt1, ForwardIt2|ForwardIterator}}
{{par end}}

===Return value===
Output iterator to the element past the last written element.

===Complexity===
Given {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first, last)}}:
@1,2@ Exactly {{mathjax-or|\(\scriptsize max(0,N-1)\)|max(0,N-1)}} comparisons using {{c/core|1=operator==}}.
@3,4@ Exactly {{mathjax-or|\(\scriptsize max(0,N-1)\)|max(0,N-1)}} applications of the predicate {{c|p}}.

For overloads {{v|2,4}}, there may be a performance cost if the value type of {{tt|ForwardIt1}} is not both {{named req|CopyConstructible}} and {{named req|CopyAssignable}}.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===Possible implementation===
See also the implementations in [https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L1046 libstdc++] and [https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L2177 libc++].

===Notes===
If {{tt|InputIt}} satisfies {{named req|ForwardIterator}}, this function rereads the input in order to detect duplicates.

Otherwise, if {{tt|OutputIt}} satisfies {{named req|ForwardIterator}}, and the value type of {{tt|InputIt}} is the same as that of {{tt|OutputIt}}, this function compare {{c|*d_first}} to {{c|*first}}.

Otherwise, this function compares {{c|*first}} to a local element copy.

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;

int main()
{
    std::string s1 {"A string with mmmany letters!"};
    std::cout &lt;&lt; "Before: " &lt;&lt; s1 &lt;&lt; '\n';

    std::string s2;
    std::unique_copy(s1.begin(), s1.end(), std::back_inserter(s2),
                     [](char c1, char c2) { return c1 == 'm' &amp;&amp; 'm' == c2; });

    std::cout &lt;&lt; "After:  " &lt;&lt; s2 &lt;&lt; '\n';
}
|output=
Before: A string with mmmany letters!
After:  A string with many letters!
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=239|std=C++98|before=the predicate was applied {{c|std::distance(first, last)}} times|after=applied one time fewer&lt;br&gt;(for non-empty ranges)}}
{{dr list item|wg=lwg|dr=241|std=C++98|before=the value type of {{tt|InputIt}} was not required to be {{named req|CopyConstructible}}|after=conditionally required}}
{{dr list item|wg=lwg|dr=538|std=C++98|before=the value type of {{tt|InputIt}} was not required to be {{named req|CopyAssignable}}|after=conditionally required}}
{{dr list item|wg=lwg|dr=2439|std=C++98|before=the value type of {{tt|InputIt}} was not required to be&lt;br&gt;{{named req|CopyConstructible}} if {{tt|OutputIt}} is a {{named req|ForwardIterator}}|after=conditionally required}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc adjacent_find}}
{{dsc inc|cpp/algorithm/dsc unique}}
{{dsc inc|cpp/algorithm/dsc copy}}
{{dsc inc|cpp/algorithm/ranges/dsc unique_copy}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}