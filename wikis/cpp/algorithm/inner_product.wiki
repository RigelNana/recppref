{{cpp/title|inner_product}}
{{cpp/algorithm/numeric/navbar}}
{{dcl begin}}
{{dcl header|numeric}}
{{dcla|num=1|constexpr=c++20|
template&lt; class InputIt1, class InputIt2, class T &gt;
T inner_product( InputIt1 first1, InputIt1 last1,
                 InputIt2 first2, T init );
}}
{{dcla|num=2|constexpr=c++20|
template&lt; class InputIt1, class InputIt2, class T,
          class BinaryOp1, class BinaryOp2 &gt;
T inner_product( InputIt1 first1, InputIt1 last1,
                 InputIt2 first2, T init,
                 BinaryOp1 op1, BinaryOp2 op2 );
}}
{{dcl end}}

Computes inner product (i.e. sum of products) or performs ordered map/reduce operation on the range {{range|first1|last1}} and the range of {{c|std::distance(first1, last1)}} elements beginning at {{c|first2}}. 

@1@ Initializes the accumulator {{c|acc}} (of type {{tt|T}}) with the initial value {{c|init}} and then  modifies it with the expression {{rev inl|until=c++20|{{c|1=acc = acc + (*i1) * (*i2)}}}}{{rev inl|since=c++20|{{c|1=acc = std::move(acc) + (*i1) * (*i2)}}}} for every iterator {{c|i1}} in the range {{range|first1|last1}} in order and its corresponding iterator {{c|i2}} in the range beginning at {{c|first2}}. For built-in meaning of + and *, this computes inner product of the two ranges.

@2@ Initializes the accumulator {{c|acc}} (of type {{tt|T}}) with the initial value {{c|init}} and then  modifies it with the expression {{rev inl|until=c++20|{{c|1=acc = op1(acc, op2(*i1, *i2))}}}}{{rev inl|since=c++20|{{c|1=acc = op1(std::move(acc), op2(*i1, *i2))}}}} for every iterator {{c|i1}} in the range {{range|first1|last1}} in order and its corresponding iterator {{c|i2}} in the range beginning at {{c|first2}}.

Given {{c|last2}} as the {{c|std::distance(first1, last1)}}{{su|b=th}} next iterator of {{c|first2}}, if any of the following conditions is satisfied, the behavior is undefined:
* {{tt|T}} is not {{named req|CopyConstructible}}.
* {{tt|T}} is not {{named req|CopyAssignable}}.
* {{c|op1}} or {{c|op2}} modifies any element of {{range|first1|last1}} or {{range|first2|last2}}.
* {{c|op1}} or {{c|op2}} invalidates any iterator or subrange in {{closed range|first1|last1}} or {{closed range|first2|last2}}.

===Parameters===
{{par begin}}
{{par|first1, last1|the first range of elements}}
{{par|first2|the beginning of the second range of elements}}
{{par|init|initial value of the sum of the products}}
{{par op2|op1|This "sum" function takes a value returned by {{c|op2}} and the current value of the accumulator and produces a new value to be stored in the accumulator.|t1=T|t2=Type3|rt=T}}
{{par op2|op2|This "product" function takes one value from each range and produces a new value.|p1=InputIt1|p2=InputIt2|rt=Type3}}
{{par hreq}}
{{par req named|InputIt1, InputIt2|InputIterator}}
{{par end}}

===Return value===
{{c|acc}} after all modifications.

===Possible implementation===
{{eq impl
|title1=inner_product (1)|ver1=1|1=
template&lt;class InputIt1, class InputIt2, class T&gt;
constexpr // since C++20
T inner_product(InputIt1 first1, InputIt1 last1, InputIt2 first2, T init)
{
    while (first1 != last1)
    {
        init = std::move(init) + (*first1) * (*first2); // std::move since C++20
        ++first1;
        ++first2;
    }
    
    return init;
}
|title2=inner_product (2)|ver2=2|2=
template&lt;class InputIt1, class InputIt2, class T,
         class BinaryOp1, class BinaryOp2&gt;
constexpr // since C++20
T inner_product(InputIt1 first1, InputIt1 last1, InputIt2 first2, T init,
                BinaryOp1 op1, BinaryOp2 op2)
{
    while (first1 != last1)
    {
        init = op1(std::move(init), op2(*first1, *first2)); // std::move since C++20
        ++first1;
        ++first2;
    }
    
    return init;
}
}}

===Notes===
The parallelizable version of this algorithm, {{lc|std::transform_reduce}}, requires {{c|op1}} and {{c|op2}} to be commutative and associative, but {{tt|std::inner_product}} makes no such requirement, and always performs the operations in the order given.

===Example===
{{example
|
|code=
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; a{0, 1, 2, 3, 4};
    std::vector&lt;int&gt; b{5, 4, 2, 3, 1};
    
    int r1 = std::inner_product(a.begin(), a.end(), b.begin(), 0);
    std::cout &lt;&lt; "Inner product of a and b: " &lt;&lt; r1 &lt;&lt; '\n';
    
    int r2 = std::inner_product(a.begin(), a.end(), b.begin(), 0,
                                std::plus&lt;&gt;(), std::equal_to&lt;&gt;());
    std::cout &lt;&lt; "Number of pairwise matches between a and b: " &lt;&lt;  r2 &lt;&lt; '\n';
}
|output=
Inner product of a and b: 21
Number of pairwise matches between a and b: 2
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=242|std=C++98|before={{c|op1}} and {{c|op2}} could not have side effects|after=they cannot modify the ranges involved}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc transform_reduce}}
{{dsc inc|cpp/algorithm/dsc accumulate}}
{{dsc inc|cpp/algorithm/dsc partial_sum}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}