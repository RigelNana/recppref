{{cpp/title|adjacent_find}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcla|num=1|notes={{mark constexpr since c++20}}|
template&lt; class ForwardIt &gt;
ForwardIt adjacent_find( ForwardIt first, ForwardIt last );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt &gt;
ForwardIt adjacent_find( ExecutionPolicy&amp;&amp; policy,
                         ForwardIt first, ForwardIt last );
}}
{{dcla|num=3|notes={{mark constexpr since c++20}}|
template&lt; class ForwardIt, class BinaryPred &gt;
ForwardIt adjacent_find( ForwardIt first, ForwardIt last,
                         BinaryPred p );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt, class BinaryPred &gt;
ForwardIt adjacent_find( ExecutionPolicy&amp;&amp; policy,
                         ForwardIt first, ForwardIt last,
                         BinaryPred p );
}}
{{dcl end}}

Searches the range {{range|first|last}} for two consecutive equal elements.

@1@ Elements are compared using {{c/core|1=operator==}}.

@3@ Elements are compared using the given binary predicate {{c|p}}.

@2,4@ Same as {{v|1,3}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition|plural=true}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to examine}}
{{par exec pol}}
{{par pred2 eq|p|p1=ForwardIt}}
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req named|BinaryPred|BinaryPredicate}}
{{par end}}

===Return value===
An iterator to the first of the first pair of identical elements, that is, the first iterator {{c|it}} such that {{c|1=*it == *(it + 1)}} for {{v|1,2}} or {{c|1=p(*it, *(it + 1)) != false}} for {{v|3,4}}.

If no such elements are found, {{c|last}} is returned.

===Complexity===
Given {{c|result}} as the return value of {{tt|adjacent_find}}, {{mathjax-or|\(\scriptsize M\)|M}} as {{c|std::distance(first, result)}} and {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first, last)}}:
@1@ Exactly {{mathjax-or|\(\scriptsize \min(M+1,N-1)\)|min(M+1,N-1)}} comparisons using {{c/core|1=operator==}}.
@2@ {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} comparisons using {{c/core|1=operator==}}.
@3@ Exactly {{mathjax-or|\(\scriptsize \min(M+1,N-1)\)|min(M+1,N-1)}} applications of the predicate {{c|p}}.
@4@ {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} applications of the predicate {{c|p}}.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===Possible implementation===
{{eq impl
|title1=adjacent_find (1)|ver1=1|1=
template&lt;class ForwardIt&gt;
ForwardIt adjacent_find(ForwardIt first, ForwardIt last)
{
    if (first == last)
        return last;
    
    ForwardIt next = first;
    ++next;
    
    for (; next != last; ++next, ++first)
        if (*first == *next)
            return first;
    
    return last;
}
|title2=adjacent_find (3)|ver2=3|2=
template&lt;class ForwardIt, class BinaryPred&gt;
ForwardIt adjacent_find(ForwardIt first, ForwardIt last, BinaryPred p)
{
    if (first == last)
        return last;
    
    ForwardIt next = first;
    ++next;
    
    for (; next != last; ++next, ++first)
        if (p(*first, *next))
            return first;
    
    return last;
}
}}

===Example===
{{example
|
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; v1{0, 1, 2, 3, 40, 40, 41, 41, 5};
    
    auto i1 = std::adjacent_find(v1.begin(), v1.end());
    
    if (i1 == v1.end())
        std::cout &lt;&lt; "No matching adjacent elements\n";
    else
        std::cout &lt;&lt; "The first adjacent pair of equal elements is at "
                  &lt;&lt; std::distance(v1.begin(), i1) &lt;&lt; ", *i1 = "
                  &lt;&lt; *i1 &lt;&lt; '\n';
    
    auto i2 = std::adjacent_find(v1.begin(), v1.end(), std::greater&lt;int&gt;());
    if (i2 == v1.end())
        std::cout &lt;&lt; "The entire vector is sorted in ascending order\n";
    else
        std::cout &lt;&lt; "The last element in the non-decreasing subsequence is at "
                  &lt;&lt; std::distance(v1.begin(), i2) &lt;&lt; ", *i2 = " &lt;&lt; *i2 &lt;&lt; '\n';
}
|output=
The first adjacent pair of equal elements is at 4, *i1 = 40
The last element in the non-decreasing subsequence is at 7, *i2 = 41
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=240|std=C++98|before=the predicate was applied {{c|std::find}}&lt;br&gt;{{c|(first, last, value) - first}} times&lt;br&gt;for {{v|1,3}}, where {{c|value}} was never defined|after=applied {{c|std::min(}}&lt;br&gt;{{c|(result - first) + 1, }}&lt;br&gt;{{c|(last - first) - 1)}} times}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc unique}}
{{dsc inc|cpp/algorithm/ranges/dsc adjacent_find}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}