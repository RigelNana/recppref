{{cpp/title|transform_reduce}}
{{cpp/algorithm/numeric/navbar}}
{{dcl begin}}
{{dcl header|numeric}}
{{dcl|num=1|since=c++17|notes={{mark constexpr since c++20}}|
template&lt; class InputIt1, class InputIt2, class T &gt;
T transform_reduce( InputIt1 first1, InputIt1 last1,
                    InputIt2 first2, T init );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2, class T &gt;
T transform_reduce( ExecutionPolicy&amp;&amp; policy,
                    ForwardIt1 first1, ForwardIt1 last1,
                    ForwardIt2 first2, T init );
}}
{{dcl|num=3|since=c++17|notes={{mark constexpr since c++20}}|
template&lt; class InputIt1, class InputIt2, class T,
          class BinaryOp1, class BinaryOp2 &gt;
T transform_reduce( InputIt1 first1, InputIt1 last1,
                    InputIt2 first2, T init,
                    BinaryOp1 reduce, BinaryOp2 transform );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2, class T,
          class BinaryOp1, class BinaryOp2 &gt;
T transform_reduce( ExecutionPolicy&amp;&amp; policy,
                    ForwardIt1 first1, ForwardIt1 last1,
                    ForwardIt2 first2, T init,
                    BinaryOp1 reduce, BinaryOp2 transform );
}}
{{dcl|num=5|since=c++17|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class T,
          class BinaryOp, class UnaryOp &gt;
T transform_reduce( InputIt first, InputIt last, T init,
                    BinaryOp reduce, UnaryOp transform );
}}
{{dcl|num=6|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt, class T,
          class BinaryOp, class UnaryOp &gt;
T transform_reduce( ExecutionPolicy&amp;&amp; policy,
                    ForwardIt first, ForwardIt last, T init,
                    BinaryOp reduce, UnaryOp transform );
}}
{{dcl end}}

@1@ Equivalent to {{c multi|transform_reduce(first1, last1, first2, init,|                 std::plus&lt;&gt;(), std::multiplies&lt;&gt;())}}, effectively parallelized version of the default {{lc|std::inner_product}}.

@3@ Applies {{c|transform}} to each pair of elements from the ranges {{range|first1|last1}} and the range of {{c|std::distance(first1, last1)}} elements starting from {{c|first2}} and reduces the results (possibly permuted and aggregated in unspecified manner) along with the initial value {{c|init}} over {{c|reduce}}.
@@ The result is non-deterministic if the {{c|reduce}} is not associative or not commutative (such as floating-point addition).
@@ If any of the following values is not convertible to {{tt|T}}, the program is ill-formed:
* {{c|reduce(init, init)}}
* {{c|reduce(init, transform(*first1, *first2))}}
* {{c|reduce(transform(*first1, *first2), init)}}
* {{c|reduce(transform(*first1, *first2), transform(*first1, *first2))}}
@@ Given {{c|last2}} as the {{c|std::distance(first1, last1)}}{{su|b=th}} next iterator of {{c|first2}}, if any of the following conditions is satisfied, the behavior is undefined:
* {{tt|T}} is not {{named req|MoveConstructible}}.
* {{c|transform}} or {{c|reduce}} modifies any element of {{range|first1|last1}} or {{range|first2|last2}}.
* {{c|transform}} or {{c|reduce}} invalidates any iterator or subrange of {{closed range|first1|last1}} or {{closed range|first2|last2}}.

@5@ Applies {{c|transform}} to each element in the range {{range|first|last}} and reduces the results (possibly permuted and aggregated in unspecified manner) along with the initial value {{c|init}} over {{c|reduce}}.
@@ The result is non-deterministic if the {{c|reduce}} is not associative or not commutative (such as floating-point addition).
@@ If any of the following values is not convertible to {{tt|T}}, the program is ill-formed:
* {{c|reduce(init, init)}}
* {{c|reduce(init, transform(*first))}}
* {{c|reduce(transform(*first), init)}}
* {{c|reduce(transform(*first), transform(*first))}}
@@ If any of the following conditions is satisfied, the behavior is undefined:
* {{tt|T}} is not {{named req|MoveConstructible}}.
* {{c|transform}} or {{c|reduce}} modifies any element of {{range|first|last}}.
* {{c|transform}} or {{c|reduce}} invalidates any iterator or subrange of {{closed range|first|last}}.

@2,4,6@ Same as {{v|1,3,5}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

===Parameters===
{{par begin}}
{{par|first1, last1|the range of elements to be taken as the left operand of {{c|transform}}}}
{{par|first2|the start of range of elements to be taken as the right operand of {{c|transform}}}}
{{par|first, last|the range of elements to be taken as the operand of {{c|transform}}}}
{{par|init|the initial value of the generalized sum}}
{{par exec pol}}
{{par|reduce|binary {{named req|FunctionObject}} that will be applied in unspecified order to the results of {{c|transform}}, the results of other {{c|reduce}} and {{c|init}}.}}
{{par|transform|unary or binary {{named req|FunctionObject}} that will be applied to each element of the input range(s). The return type must be acceptable as input to {{c|reduce}}.}}
{{par hreq}}
{{par req named|InputIt1, InputIt2, InputIt|InputIterator}}
{{par req named|ForwardIt1, ForwardIt2, ForwardIt|ForwardIterator}}
{{par end}}

===Return value===
@1,2@ The generalized sum of {{c|init}} and {{c|values}} over {{c|std::plus&lt;&gt;()}}, where {{c|values}} are the values transformed by {{c|std::multiplies&lt;&gt;()}}, each value is transformed from a pair of elements from the two input ranges.

@3,4@ The generalized sum of {{c|init}} and {{c|values}} over {{c|reduce}}, where {{c|values}} are the values transformed by {{c|transform}}, each value is transformed from a pair of elements from the two input ranges.

@5,6@ The generalized sum of {{c|init}} and {{c|values}} over {{c|reduce}}, where {{c|values}} are the values transformed by {{c|transform}}, each value is transformed from an element from the input range.

The ''generalized sum'' of a group of elements over an binary operation {{c|binary_op}} is defined as follows:
* If the group only has one element, the sum is the value of the element.
* Otherwise, performs the following operations in order:
# Takes any two elements {{c|elem1}} and {{c|elem2}} from the group.
# Calculates {{c|binary_op(elem1, elem2)}} and puts the result back to the group.
# Repeats steps 1 and 2 until there is only one element in the group.

===Complexity===
Given {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first1, last1)}} (or {{c|std::distance(first, last)}} for overloads {{v|5,6}}):

@1,2@ {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} applications of {{c|std::plus&lt;&gt;()}} and {{c|std::multiplies&lt;&gt;()}} respectively.

@3-6@ {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} applications of {{c|reduce}} and {{c|transform}} respectively.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior}}

===Notes===
{{c|transform}} is never applied to {{c|init}}.

If {{c|1=first == last}} or {{c|1=first1 == last1}}, {{c|init}} is returned, unmodified.

===Example===
{{example|{{tt|transform_reduce}} can be used to parallelize {{lc|std::inner_product}}. Some systems may need additional support to get advantages of parallel execution. E.g., on GNU/Linux, the {{enwiki|Threading Building Blocks|Intel TBB}} be installed and {{c|-ltbb}} option be provided to gcc/clang compiler.
|code=
#if PARALLEL
#include &lt;execution&gt;
#define PAR std::execution::par,
#else
#define PAR
#endif

#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;locale&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

// to parallelize non-associate accumulative operation, you'd better choose
// transform_reduce instead of reduce; e.g., a + b * b != b + a * a
void print_sum_squared(long const num)
{
    std::cout.imbue(std::locale{"en_US.UTF8"});
    std::cout &lt;&lt; "num = " &lt;&lt; num &lt;&lt; '\n';
    
    // create an immutable vector filled with pattern: 1,2,3,4, 1,2,3,4 ...
    const std::vector&lt;long&gt; v{[n = num * 4] {
        std::vector&lt;long&gt; v;
        v.reserve(n);
        std::generate_n(std::back_inserter(v), n,
            [i = 0]() mutable { return 1 + i++ % 4; });
        return v;
    }()};

    auto squared_sum = [](auto sum, auto val) { return sum + val * val; };
    
    auto sum1 = std::accumulate(v.cbegin(), v.cend(), 0L, squared_sum);
    std::cout &lt;&lt; "accumulate(): " &lt;&lt; sum1 &lt;&lt; '\n';
    
    auto sum2 = std::reduce(PAR v.cbegin(), v.cend(), 0L, squared_sum);
    std::cout &lt;&lt; "reduce(): " &lt;&lt; sum2 &lt;&lt; '\n';
    
    auto sum3 = std::transform_reduce(PAR v.cbegin(), v.cend(), 0L, std::plus{},
                                      [](auto val) { return val * val; });
    std::cout &lt;&lt; "transform_reduce(): " &lt;&lt; sum3 &lt;&lt; "\n\n";
}

int main()
{
    print_sum_squared(1);
    print_sum_squared(1'000);
    print_sum_squared(1'000'000);
}
|p=true
|output=
num = 1
accumulate(): 30
reduce(): 30
transform_reduce(): 30

num = 1,000
accumulate(): 30,000
reduce(): -7,025,681,278,312,630,348
transform_reduce(): 30,000

num = 1,000,000
accumulate(): 30,000,000
reduce(): -5,314,886,882,370,003,032
transform_reduce(): 30,000,000

// Compile-options for parallel execution on POSIX:
// g++ -O2 -std=c++17 -Wall -Wextra -pedantic -DPARALLEL ./example.cpp -ltbb -o tr; ./tr
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc accumulate}}
{{dsc inc|cpp/algorithm/dsc transform}}
{{dsc inc|cpp/algorithm/dsc reduce}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}