{{cpp/title|move_backward}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcla|anchor=no|since=c++11|constexpr=c++20|
template&lt; class BidirIt1, class BidirIt2 &gt;
BidirIt2 move_backward( BidirIt1 first, BidirIt1 last, BidirIt2 d_last );
}}
{{dcl end}}

Moves the elements from the range {{range|first|last}}, to another range ending at {{c|d_last}}. The elements are moved in reverse order (the last element is moved first), but their relative order is preserved.

If {{c|d_last}} is within {{range|first|last|left=(|right=]}}, the behavior is undefined. In this case, {{rlpt|move|std::move}} may be used instead.

===Parameters===
{{par begin}}
{{par|first, last|the range of the elements to move}}
{{par|d_last|end of the destination range}}
{{par hreq}}
{{par req named|BidirIt1, BidirIt2|BidirectionalIterator}}
{{par end}}

===Return value===
Iterator in the destination range, pointing at the last element moved.

===Complexity===
Exactly {{c|std::distance(first, last)}} move assignments.

===Possible implementation===
{{eq fun|1=
template&lt;class BidirIt1, class BidirIt2&gt;
BidirIt2 move_backward(BidirIt1 first, BidirIt1 last, BidirIt2 d_last)
{
    while (first != last)
        *(--d_last) = std::move(*(--last));
    
    return d_last;
}
}}

===Notes===
When moving overlapping ranges, {{rlpt|move|std::move}} is appropriate when moving to the left (beginning of the destination range is outside the source range) while {{tt|std::move_backward}} is appropriate when moving to the right (end of the destination range is outside the source range).

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

using container = std::vector&lt;std::string&gt;;

void print(std::string_view comment, const container&amp; src, const container&amp; dst = {})
{
    auto prn = [](std::string_view name, const container&amp; cont)
    {
        std::cout &lt;&lt; name;
        for (const auto &amp;s : cont)
            std::cout &lt;&lt; (s.empty() ? "∙" : s.data()) &lt;&lt; ' ';
        std::cout &lt;&lt; '\n';
    };
    std::cout &lt;&lt; comment &lt;&lt; '\n';
    prn("src: ", src);
    if (dst.empty())
        return;
    prn("dst: ", dst);
}

int main()
{
    container src{"foo", "bar", "baz"};
    container dst{"qux", "quux", "quuz", "corge"};
    print("Non-overlapping case; before move_backward:", src, dst);
    std::move_backward(src.begin(), src.end(), dst.end());
    print("After:", src, dst);
    
    src = {"snap", "crackle", "pop", "lock", "drop"};
    print("Overlapping case; before move_backward:", src);
    std::move_backward(src.begin(), std::next(src.begin(), 3), src.end());
    print("After:", src);
}
|output=
Non-overlapping case; before move_backward:
src: foo bar baz
dst: qux quux quuz corge
After:
src: ∙ ∙ ∙
dst: qux foo bar baz
Overlapping case; before move_backward:
src: snap crackle pop lock drop
After:
src: ∙ ∙ snap crackle pop
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc move}}
{{dsc inc|cpp/algorithm/ranges/dsc move_backward}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}