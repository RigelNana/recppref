{{cpp/title|reverse}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|num=1|notes={{mark constexpr since c++20}}|
template&lt; class BidirIt &gt;
void reverse( BidirIt first, BidirIt last );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class BidirIt &gt;
void reverse( ExecutionPolicy&amp;&amp; policy, BidirIt first, BidirIt last );
}}
{{dcl end}}

@1@ Reverses the order of the elements in the range {{range|first|last}}.
@@ Behaves as if applying {{lc|std::iter_swap}} to every pair of iterators {{c|first + i}} and {{c|(last - i) - 1}} for each integer {{c|i}} in {{range|0|std::distance(first, last) / 2}}.

@2@ Same as {{v|1}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition}}

If {{rev inl|until=c++20|{{c|*first}} is not {{named req|Swappable}}}}{{rev inl|since=c++20|{{tt|BidirIt}} is not {{named req|ValueSwappable}}}}, the behavior is undefined.

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to reverse}}
{{par exec pol}}
{{par hreq}}
{{par req named|BidirIt|BidirectionalIterator}}
{{par end}}

===Complexity===
Exactly {{c|std::distance(first, last) / 2}} swaps.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=yes}}

===Possible implementation===
See also the implementations in [https://github.com/gcc-mirror/gcc/blob/14d8a5ae472ca5743016f37da2dd4770d83dea21/libstdc%2B%2B-v3/include/bits/stl_algo.h#L1087-L1152 libstdc++], [https://github.com/llvm/llvm-project/blob/6adbc83ee9e46b476e0f75d5671c3a21f675a936/libcxx/include/__algorithm/reverse.h libc++], and [https://github.com/microsoft/STL/blob/472161105d596192194d4715ccad307c6c163b4a/stl/inc/xutility#L5335-L5370 MSVC STL].
{{eq fun|1=
template&lt;class BidirIt&gt;
constexpr // since C++20
void reverse(BidirIt first, BidirIt last)
{
    using iter_cat = typename std::iterator_traits&lt;BidirIt&gt;::iterator_category;
    
    // Tag dispatch, e.g. calling reverse_impl(first, last, iter_cat()),
    // can be used in C++14 and earlier modes.
    if constexpr (std::is_base_of_v&lt;std::random_access_iterator_tag, iter_cat&gt;)
    {
        if (first == last)
            return;
        
        for (--last; first &lt; last; (void)++first, --last)
            std::iter_swap(first, last);
    }
    else
        while (first != last &amp;&amp; first != --last)
            std::iter_swap(first++, last);
}
}}

===Notes===
{{cpp/algorithm/notes swap vectorization}}

===Example===
{{example
|
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

void println(auto rem, auto const&amp; v)
{
    for (std::cout &lt;&lt; rem; auto e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    std::vector&lt;int&gt; v {1, 2, 3};
    std::reverse(v.begin(), v.end());
    println("after reverse, v = ", v);
    
    int a[] = {4, 5, 6, 7};
    std::reverse(std::begin(a), std::end(a));
    println("after reverse, a = ", a);
}
|output=
after reverse, v = 3 2 1
after reverse, a = 7 6 5 4
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=223|std=C++98|before={{lc|std::swap}} was applied to each pair of iterators|after=applies {{lc|std::iter_swap}} instead}}
{{dr list item|wg=lwg|dr=2039|std=C++98|before={{lc|std::iter_swap}} was also applied when {{c|i}}&lt;br&gt;equals {{c|std::distance(first, last) / 2}}|after=not applied}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc reverse_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc reverse}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}