{{cpp/ranges/title|remove|remove_if}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl rev begin|num=1}}
{{dcla|anchor=1|since=c++20|until=c++26|1=
template&lt; std::permutable I, std::sentinel_for&lt;I&gt; S,
          class T, class Proj = std::identity &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr ranges::subrange&lt;I&gt;
    remove( I first, S last, const T&amp; value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; std::permutable I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;I, Proj&gt; &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr ranges::subrange&lt;I&gt;
    remove( I first, S last, const T&amp; value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::forward_range R,
          class T, class Proj = std::identity &gt;
requires std::permutable&lt;ranges::iterator_t&lt;R&gt;&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    remove( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::forward_range R,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt; &gt;
requires std::permutable&lt;ranges::iterator_t&lt;R&gt;&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    remove( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcla|num=3|since=c++20|1=
template&lt; std::permutable I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr ranges::subrange&lt;I&gt;
    remove_if( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|num=4|since=c++20|1=
template&lt; ranges::forward_range R,
          class Proj = std::identity,
          std::indirect_unary_predicate
              &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
requires std::permutable&lt;ranges::iterator_t&lt;R&gt;&gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    remove_if( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcl end}}

Removes all elements satisfying specific criteria from the range {{range|first|last}} and returns a subrange {{range|ret|last}}, where {{c|ret}} is a past-the-end iterator for the new end of the range.

@1@ Removes all elements that are equal to {{c|value}}, using {{c|1=std::invoke(proj, *i) == value}} to compare.
@3@ Removes all elements for which {{c|std::invoke(pred, std::invoke(proj, *i))}} returns {{c|true}}.
@2,4@ Same as {{v|1,3}}, but uses {{c|r}} as the range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

Removing is done by shifting (by means of move assignment) the elements in the range in such a way that the elements that are not to be removed appear in the beginning of the range. Relative order of the elements that remain is preserved and the ''physical'' size of the container is unchanged. Iterators pointing to an element between the new ''logical'' end and the ''physical'' end of the range are still dereferenceable, but the elements themselves have unspecified values (as per {{named req|MoveAssignable}} post-condition).

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to process}}
{{par|r|the range of elements to process}}
{{par|value|the value of elements to remove}}
{{par|pred|predicate to apply to the projected elements}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
{{c|{ret, last} }}, where {{range|first|ret}} is the resulting subrange after removal, and the elements in subrange {{range|ret|last}} are all in valid but unspecified state, i.e. {{range|ret|last}} is the subrange to be erased.

===Complexity===
Exactly {{c|N}} applications of the corresponding predicate and any projection, where {{c|1=N = ranges::distance(first, last)}}, and {{c|N - 1}} move operations at worst.

===Notes===
A call to {{tt|ranges::remove}} is typically followed by a call to a container's {{tt|erase}} member function, which erases the unspecified values and reduces the ''physical'' size of the container to match its new ''logical'' size. These two invocations together constitute a so-called {{enwiki|Erase-remove idiom}}, which can be achieved by the free function {{lc|std::erase}} that has [[cpp/container#Non-member function table|overloads]] for all standard ''sequence'' containers, or {{lc|std::erase_if}} that has [[cpp/container#Non-member function table|overloads]] for ''all'' standard containers.

The similarly-named container [[cpp/container#Member function table|member functions]] {{l2tt|cpp/container/list/remove}}, {{l2tt|cpp/container/list/remove|remove_if}}, {{l2tt|cpp/container/forward_list/remove}}, and {{l2tt|cpp/container/forward_list/remove|remove_if}} erase the removed elements.

These algorithms usually cannot be used with associative containers such as {{lc|std::set}} and {{lc|std::map}} because their iterator types do not dereference to {{named req|MoveAssignable}} types (the keys in these containers are not modifiable).

Because {{tt|ranges::remove}} takes {{c|value}} by reference, it can have unexpected behavior if it is a reference to an element of the range {{range|first|last}}.

===Possible implementation===
{{eq impl|title1=remove|ver1=1|1=
struct remove_fn
{
    template&lt;std::permutable I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             class T = std::projected_value_t&lt;I, Proj&gt;&gt;
    requires std::indirect_binary_predicate
                 &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
    constexpr ranges::subrange&lt;I&gt;
        operator()(I first, S last, const T&amp; value, Proj proj = {}) const
    {
        first = ranges::find(std::move(first), last, value, proj);
        if (first != last)
        {
            for (I i{std::next(first)}; i != last; ++i)
                if (value != std::invoke(proj, *i))
                {
                    *first = ranges::iter_move(i);
                    ++first;
                }
        }
        return {first, last};
    }
    
    template&lt;ranges::forward_range R, class Proj = std::identity,
             class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt;
    requires std::permutable&lt;ranges::iterator_t&lt;R&gt;&gt; &amp;&amp;
             std::indirect_binary_predicate
                 &lt;ranges::equal_to,
                  std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
    constexpr ranges::borrowed_subrange_t&lt;R&gt;
        operator()(R&amp;&amp; r, const T&amp; value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), value, std::move(proj));
    }
};

inline constexpr remove_fn remove {};
|title2=remove_if|ver2=3|2=
struct remove_if_fn
{
    template&lt;std::permutable I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr ranges::subrange&lt;I&gt;
        operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        first = ranges::find_if(std::move(first), last, pred, proj);
        if (first != last)
        {
            for (I i{std::next(first)}; i != last; ++i)
                if (!std::invoke(pred, std::invoke(proj, *i)))
                {
                    *first = ranges::iter_move(i);
                    ++first;
                }
        }
        return {first, last};
    }
    
    template&lt;ranges::forward_range R, class Proj = std::identity,
             std::indirect_unary_predicate
                 &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires std::permutable&lt;ranges::iterator_t&lt;R&gt;&gt;
    constexpr ranges::borrowed_subrange_t&lt;R&gt;
        operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), pred, std::move(proj));
    }
};

inline constexpr remove_if_fn remove_if {};
}}

===Notes===
{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms {{vl|1,2}}}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;cctype&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

int main()
{
    std::string v1{"No - Diagnostic - Required"};
    std::cout &lt;&lt; std::quoted(v1) &lt;&lt; " (v1, size: " &lt;&lt; v1.size() &lt;&lt; ")\n";
    const auto ret = std::ranges::remove(v1, ' ');
    std::cout &lt;&lt; std::quoted(v1) &lt;&lt; " (v1 after `remove`, size: " &lt;&lt; v1.size() &lt;&lt; ")\n";
    std::cout &lt;&lt; ' ' &lt;&lt; std::string(std::distance(v1.begin(), ret.begin()), '^') &lt;&lt; '\n';
    v1.erase(ret.begin(), ret.end());
    std::cout &lt;&lt; std::quoted(v1) &lt;&lt; " (v1 after `erase`, size: " &lt;&lt; v1.size() &lt;&lt; ")\n\n";
    
    // remove_if with custom unary predicate:
    auto rm = [](char c) { return !std::isupper(c); };
    std::string v2{"Substitution Failure Is Not An Error"};
    std::cout &lt;&lt; std::quoted(v2) &lt;&lt; " (v2, size: " &lt;&lt; v2.size() &lt;&lt; ")\n";
    const auto [first, last] = std::ranges::remove_if(v2, rm);
    std::cout &lt;&lt; std::quoted(v2) &lt;&lt; " (v2 after `remove_if`, size: " &lt;&lt; v2.size() &lt;&lt; ")\n";
    std::cout &lt;&lt; ' ' &lt;&lt; std::string(std::distance(v2.begin(), first), '^') &lt;&lt; '\n';
    v2.erase(first, last);
    std::cout &lt;&lt; std::quoted(v2) &lt;&lt; " (v2 after `erase`, size: " &lt;&lt; v2.size() &lt;&lt; ")\n\n";
    
    // creating a view into a container that is modified by `remove_if`:
    for (std::string s : {"Small Object Optimization", "Non-Type Template Parameter"})
        std::cout &lt;&lt; std::quoted(s) &lt;&lt; " =&gt; "
            &lt;&lt; std::string_view{begin(s), std::ranges::remove_if(s, rm).begin()} &lt;&lt; '\n';

    std::vector&lt;std::complex&lt;double&gt;&gt; nums{&lt;!----&gt;{2, 2}, {1, 3}, {4, 8}&lt;!----&gt;};
    #ifdef __cpp_lib_algorithm_default_value_type
        auto e = std::ranges::remove(nums, {1, 3}); // T gets deduced
    #else
        auto e = std::ranges::remove(nums, std::complex&lt;double&gt;{1, 3});
    #endif
    nums.erase(e.begin(), e.end());
    assert((nums == std::vector&lt;std::complex&lt;double&gt;&gt;{&lt;!----&gt;{2, 2}, {4, 8}&lt;!----&gt;}));
}
|p=true
|output=
"No _ Diagnostic _ Required" (v1, size: 26)
"No_Diagnostic_Requiredired" (v1 after `remove`, size: 26)
 ^^^^^^^^^^^^^^^^^^^^^^
"No_Diagnostic_Required" (v1 after `erase`, size: 22)

"Substitution Failure Is Not An Error" (v2, size: 36)
"SFINAEtution Failure Is Not An Error" (v2 after `remove_if`, size: 36)
 ^^^^^^
"SFINAE" (v2 after `erase`, size: 6)

"Small Object Optimization" =&gt; SOO
"Non-Type Template Parameter" =&gt; NTTP
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc remove_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc unique}}
{{dsc inc|cpp/algorithm/dsc remove}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}