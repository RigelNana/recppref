{{cpp/ranges/title|fill}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl rev begin|num=1}}
{{dcla|anchor=1|since=c++20|until=c++26|
template&lt; class T, std::output_iterator&lt;const T&amp;&gt; O, std::sentinel_for&lt;O&gt; S &gt;
constexpr O fill( O first, S last, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class O, std::sentinel_for&lt;O&gt; S, class T = std::iter_value_t&lt;O&gt; &gt;
requires std::output_iterator&lt;O, const T&amp;&gt;
constexpr O fill( O first, S last, const T&amp; value );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++20|until=c++26|
template&lt; class T, ranges::output_range&lt;const T&amp;&gt; R &gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt; fill( R&amp;&amp; r, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class R, class T = ranges::range_value_t&lt;R&gt; &gt;
requires ranges::output_range&lt;R, const T&amp;&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt; fill( R&amp;&amp; r, const T&amp; value );
}}
{{dcl end}}

@1@ Assigns the given {{c|value}} to the elements in the range {{range|first|last}}.
@2@ Same as {{v|1}}, but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to modify}}
{{par|r|the range of elements to modify}}
{{par|value|the value to be assigned}}
{{par end}}

===Return value===
An output iterator that compares equal to {{c|last}}.

===Complexity===
Exactly {{c|last - first}} assignments.

===Possible implementation===
{{eq fun|1=
struct fill_fn
{
    template&lt;class O, std::sentinel_for&lt;O&gt; S, class T = std::iter_value_t&lt;O&gt;&gt;
    requires std::output_iterator&lt;O, const T&amp;&gt;
    constexpr O operator()(O first, S last, const T&amp; value) const
    {
        while (first != last)
            *first++ = value;
        
        return first;
    }

    template&lt;class R, class T = ranges::range_value_t&lt;R&gt;&gt;
    requires ranges::output_range&lt;R, const T&amp;&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt; operator()(R&amp;&amp; r, const T&amp; value) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), value);
    }
};

inline constexpr fill_fn fill;
}}

===Notes===
{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms {{vl|1,2}}}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

void println(const auto&amp; seq)
{
    for (const auto&amp; e : seq)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5};

    // set all elements to -1 using overload (1)
    std::ranges::fill(v.begin(), v.end(), -1);
    println(v);

    // set all element to 10 using overload (2)
    std::ranges::fill(v, 10);
    println(v);

    std::vector&lt;std::complex&lt;double&gt;&gt; nums{&lt;!----&gt;{1, 3}, {2, 2}, {4, 8}&lt;!----&gt;};
    println(nums);
    #ifdef __cpp_lib_algorithm_default_value_type
        std::ranges::fill(nums, {4, 2}); // T gets deduced
    #else
        std::ranges::fill(nums, std::complex&lt;double&gt;{4, 2});
    #endif
    println(nums);
}
|output=
-1 -1 -1 -1 -1 -1
10 10 10 10 10 10
(1,3) (2,2) (4,8)
(4,2) (4,2) (4,2)
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc fill_n}}
{{dsc inc|cpp/algorithm/ranges/dsc copy}}
{{dsc inc|cpp/algorithm/ranges/dsc generate}}
{{dsc inc|cpp/algorithm/ranges/dsc transform}}
{{dsc inc|cpp/numeric/random/ranges/dsc generate_random}}
{{dsc inc|cpp/algorithm/dsc fill}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}