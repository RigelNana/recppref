{{cpp/ranges/title|reverse_copy|reverse_copy_result}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl|num=1|since=c++20|1=
template&lt; std::bidirectional_iterator I, std::sentinel_for&lt;I&gt; S,
          std::weakly_incrementable O &gt;
requires std::indirectly_copyable&lt;I, O&gt;
constexpr reverse_copy_result&lt;I, O&gt;
    reverse_copy( I first, S last, O result );
}}
{{dcl|num=2|since=c++20|1=
template&lt; ranges::bidirectional_range R, std::weakly_incrementable O &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt;
constexpr reverse_copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    reverse_copy( R&amp;&amp; r, O result );
}}
{{dcl h|Helper types}}
{{dcl|num=3|since=c++20|1=
template&lt; class I, class O &gt;
using reverse_copy_result = ranges::in_out_result&lt;I, O&gt;;
}}
{{dcl end}}

@1@ Copies the elements from the source range {{range|first|last}} to the destination range {{range|result|result + N}}, where {{tt|N}} is {{c|ranges::distance(first, last)}}, in such a way that the elements in the new range are in reverse order. Behaves as if by executing the assignment {{c|1=*(result + N - 1 - i) = *(first + i)}} once for each integer {{tt|i}} in {{range|0|N}}. The behavior is undefined if the source and destination ranges overlap.

@2@ Same as {{v|1}}, but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to copy}}
{{par|r|the range of elements to copy}}
{{par|result|the beginning of the destination range.}}
{{par end}}

===Return value===
{{c|1={last, result + N} }}.

===Complexity===
Exactly {{tt|N}} assignments.

===Notes===
Implementations (e.g. [https://github.com/microsoft/STL/blob/main/stl/src/vector_algorithms.cpp MSVC STL]) may enable vectorization when the both iterator types model {{lconcept|contiguous_iterator}} and have the same value type, and the value type is {{named req|TriviallyCopyable}}.

===Possible implementation===
See also the implementations in [https://github.com/microsoft/STL/blob/472161105d596192194d4715ccad307c6c163b4a/stl/inc/algorithm#L4245-L4323 MSVC STL] and [https://github.com/gcc-mirror/gcc/blob/14d8a5ae472ca5743016f37da2dd4770d83dea21/libstdc%2B%2B-v3/include/bits/ranges_algo.h#L1330-L1359 libstdc++].
{{eq fun|1=
struct reverse_copy_fn
{
    template&lt;std::bidirectional_iterator I, std::sentinel_for&lt;I&gt; S,
             std::weakly_incrementable O&gt;
    requires std::indirectly_copyable&lt;I, O&gt;
    constexpr ranges::reverse_copy_result&lt;I, O&gt;
        operator()(I first, S last, O result) const
    {
        auto ret = ranges::next(first, last);
        for (; last != first; *result = *--last, ++result);
        return {std::move(ret), std::move(result)};
    }

    template&lt;ranges::bidirectional_range R, std::weakly_incrementable O&gt;
    requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt;
    constexpr ranges::reverse_copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
        operator()(R&amp;&amp; r, O result) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(result));
    }
};

inline constexpr reverse_copy_fn reverse_copy {};
}}

===Example===
{{example|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::string x {"12345"}, y(x.size(), ' ');
    std::cout &lt;&lt; x &lt;&lt; " → ";
    std::ranges::reverse_copy(x.begin(), x.end(), y.begin());
    std::cout &lt;&lt; y &lt;&lt; " → ";
    std::ranges::reverse_copy(y, x.begin());
    std::cout &lt;&lt; x &lt;&lt; '\n';
}
|output=
12345 → 54321 → 12345
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc reverse}}
{{dsc inc|cpp/algorithm/dsc reverse_copy}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}