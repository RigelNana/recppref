{{cpp/ranges/title|prev_permutation|prev_permutation_result}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl|num=1|since=c++20|1=
template&lt; std::bidirectional_iterator I, std::sentinel_for&lt;I&gt; S,
          class Comp = ranges::less, class Proj = std::identity &gt;
requires std::sortable&lt;I, Comp, Proj&gt;
constexpr prev_permutation_result&lt;I&gt;
    prev_permutation( I first, S last, Comp comp = {}, Proj proj = {} );
}}
{{dcl|num=2|since=c++20|1=
template&lt; ranges::bidirectional_range R, class Comp = ranges::less,
          class Proj = std::identity &gt;
requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
constexpr prev_permutation_result&lt;ranges::borrowed_iterator_t&lt;R&gt;&gt;
    prev_permutation( R&amp;&amp; r, Comp comp = {}, Proj proj = {} );
}}
{{dcl h|Helper type}}
{{dcl|since=c++20|num=3|1=
template&lt; class I &gt;
using prev_permutation_result = ranges::in_found_result&lt;I&gt;;
}}
{{dcl end}}

@1@ Transforms the range {{range|first|last}} into the previous {{enwiki|permutation}}, where the set of all permutations is ordered {{enwiki|Lexicographic order|lexicographically}} with respect to binary comparison function object {{c|comp}} and projection function object {{c|proj}}.
@@ Returns:
* {{c|{last, true}&lt;!----&gt;}} if "previous" permutation exists. Otherwise,
* {{c|{last, false}&lt;!----&gt;}}, and transforms the range into the (lexicographically) last permutation, as if by
{{source|
ranges::sort(first, last, comp, proj);
ranges::reverse(first, last);
}}

@2@ Same as {{v|1}}, but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}}, and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to "permute"}}
{{par|r|the range of elements to "permute"}}
{{par|comp|comparison function object which returns {{c|true}} if the first argument is less than the second}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
@1@ {{c|ranges::prev_permutation_result&lt;I&gt;{last, true}&lt;!----&gt;}} if the new permutation is lexicographically less than the old one. {{c|ranges::prev_permutation_result&lt;I&gt;{last, false}&lt;!----&gt;}} if the first permutation was reached and the range was reset to the last permutation.

@2@ Same as {{v|1}} except that the return type is {{c|ranges::prev_permutation_result&lt;ranges::borrowed_iterator_t&lt;R&gt;&gt;}}.

===Exceptions===
Any exceptions thrown from iterator operations or the element swap.

===Complexity===
At most {{mathjax-or|\(\scriptsize N/2\)|N / 2}} swaps, where {{mathjax-or|\(\scriptsize N\)|N}} is {{c|ranges::distance(first, last)}} in case {{v|1}} or {{c|ranges::distance(r)}} in case {{v|2}}. Averaged over the entire sequence of permutations, typical implementations use about 3 comparisons and 1.5 swaps per call.

===Notes===
{{cpp/algorithm/notes swap vectorization}}

===Possible implementation===
{{eq fun|1=
struct prev_permutation_fn
{
    template&lt;std::bidirectional_iterator I, std::sentinel_for&lt;I&gt; S,
             class Comp = ranges::less, class Proj = std::identity&gt;
    requires std::sortable&lt;I, Comp, Proj&gt;
    constexpr ranges::prev_permutation_result&lt;I&gt;
        operator()(I first, S last, Comp comp = {}, Proj proj = {}) const
    {
        // check that the sequence has at least two elements
        if (first == last)
            return {std::move(first), false};
        auto i{first};
        ++i;
        if (i == last)
            return {std::move(i), false};
        auto i_last{ranges::next(first, last)};
        i = i_last;
        --i;
        // main "permutating" loop
        for (;;)
        {
            auto i1{i};
            --i;
            if (std::invoke(comp, std::invoke(proj, *i1), std::invoke(proj, *i)))
            {
                auto j{i_last};
                while (!std::invoke(comp, std::invoke(proj, *--j), std::invoke(proj, *i)))
                    ;
                ranges::iter_swap(i, j);
                ranges::reverse(i1, last);
                return {std::move(i_last), true};
            }
            // permutation "space" is exhausted
            if (i == first)
            {
                ranges::reverse(first, last);
                return {std::move(i_last), false};
            }
        }
    }

    template&lt;ranges::bidirectional_range R, class Comp = ranges::less,
             class Proj = std::identity&gt;
    requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
    constexpr ranges::prev_permutation_result&lt;ranges::borrowed_iterator_t&lt;R&gt;&gt;
        operator()(R&amp;&amp; r, Comp comp = {}, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r),
                       std::move(comp), std::move(proj));
    }
};

inline constexpr prev_permutation_fn prev_permutation {};
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;compare&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

struct S
{
    char c{};
    int i{};
    auto operator&lt;=&gt;(const S&amp;) const = default;
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const S&amp; s)
    {
        return os &lt;&lt; "{'" &lt;&lt; s.c &lt;&lt; "', " &lt;&lt; s.i &lt;&lt; "}";
    }
};

auto print = [](auto const&amp; v, char term = ' ')
{
    std::cout &lt;&lt; "{ ";
    for (const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '}' &lt;&lt; term;
};

int main()
{
    std::cout &lt;&lt; "Generate all permutations (iterators case):\n";
    std::string s{"cba"};
    do print(s);
    while (std::ranges::prev_permutation(s.begin(), s.end()).found);

    std::cout &lt;&lt; "\nGenerate all permutations (range case):\n";
    std::array a{'c', 'b', 'a'};
    do print(a);
    while (std::ranges::prev_permutation(a).found);

    std::cout &lt;&lt; "\nGenerate all permutations using comparator:\n";
    using namespace std::literals;
    std::array z{"▁"s, "▄"s, "█"s};
    do print(z);
    while (std::ranges::prev_permutation(z, std::greater()).found);

    std::cout &lt;&lt; "\nGenerate all permutations using projection:\n";
    std::array&lt;S, 3&gt; r{S{'C',1}, S{'B',2}, S{'A',3}&lt;!----&gt;};
    do print(r, '\n');
    while (std::ranges::prev_permutation(r, {}, &amp;S::c).found);
}
|output=
Generate all permutations (iterators case):
{ c b a } { c a b } { b c a } { b a c } { a c b } { a b c }
Generate all permutations (range case):
{ c b a } { c a b } { b c a } { b a c } { a c b } { a b c }
Generate all permutations using comparator:
{ ▁ ▄ █ } { ▁ █ ▄ } { ▄ ▁ █ } { ▄ █ ▁ } { █ ▁ ▄ } { █ ▄ ▁ }
Generate all permutations using projection:
{ {'C', 1} {'B', 2} {'A', 3} }
{ {'C', 1} {'A', 3} {'B', 2} }
{ {'B', 2} {'C', 1} {'A', 3} }
{ {'B', 2} {'A', 3} {'C', 1} }
{ {'A', 3} {'C', 1} {'B', 2} }
{ {'A', 3} {'B', 2} {'C', 1} }
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc next_permutation}}
{{dsc inc|cpp/algorithm/ranges/dsc is_permutation}}
{{dsc inc|cpp/algorithm/dsc next_permutation}}
{{dsc inc|cpp/algorithm/dsc prev_permutation}}
{{dsc inc|cpp/algorithm/dsc is_permutation}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}