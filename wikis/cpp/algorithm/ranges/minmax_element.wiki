{{cpp/ranges/title|minmax_element|minmax_element_result}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl|since=c++20|num=1|1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
          std::indirect_strict_weak_order&lt;std::projected&lt;I, Proj&gt;&gt; Comp = ranges::less &gt;
constexpr minmax_element_result&lt;I&gt;
    minmax_element( I first, S last, Comp comp = {}, Proj proj = {} );
}}
{{dcl|since=c++20|num=2|1=
template&lt; ranges::forward_range R, class Proj = std::identity,
          std::indirect_strict_weak_order&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less &gt;
constexpr minmax_element_result&lt;ranges::borrowed_iterator_t&lt;R&gt;&gt;
    minmax_element( R&amp;&amp; r, Comp comp = {}, Proj proj = {} );
}}
{{dcl h|Helper types}}
{{dcl|since=c++20|num=3|1=
template&lt; class I &gt;
using minmax_element_result = ranges::min_max_result&lt;I&gt;;
}}
{{dcl end}}

@1@ Finds the smallest and largest elements in the range {{range|first|last}}.
@2@ Same as {{v|1}}, but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|iterator-sentinel pair denoting the range to examine}}
{{par|r|the range to examine}}
{{par|comp|comparison to apply to the projected elements}}
{{par|proj|projection to apply to the elements.}}
{{par end}}

===Return value===
An object consisting of an iterator to the smallest element as the first element and an iterator to the greatest element as the second. Returns {{c|{first, first} }} if the range is empty. If several elements are equivalent to the smallest element, the iterator to the first such element is returned. If several elements are equivalent to the largest element, the iterator to the last such element is returned.

===Complexity===
At most {{c|std::max(std::floor(1.5 * (N âˆ’ 1)), 0.0)}} applications of the comparison and twice as many applications of the projection, where {{c|1=N = ranges::distance(first, last)}}.

===Possible implementation===
{{eq fun
|1=
struct minmax_element_fn
{
    template&lt;std::forward_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirect_strict_weak_order&lt;std::projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
    constexpr ranges::minmax_element_result&lt;I&gt;
        operator()(I first, S last, Comp comp = {}, Proj proj = {}) const
    {
        auto min = first, max = first;

        if (first == last {{!!}} ++first == last)
            return {min, max};

        if (std::invoke(comp, std::invoke(proj, *first),
                              std::invoke(proj, *min)))
            min = first;
        else
            max = first;

        while (++first != last)
        {
            auto i = first;
            if (++first == last)
            {
                if (std::invoke(comp, std::invoke(proj, *i),
                                      std::invoke(proj, *min)))
                    min = i;
                else if (!(std::invoke(comp, std::invoke(proj, *i),
                                             std::invoke(proj, *max))))
                    max = i;
                break;
            }
            else
            {
                if (std::invoke(comp, std::invoke(proj, *first),
                                      std::invoke(proj, *i)))
                {
                  if (std::invoke(comp, std::invoke(proj, *first),
                                        std::invoke(proj, *min)))
                      min = first;
                  if (!(std::invoke(comp, std::invoke(proj, *i),
                                          std::invoke(proj, *max))))
                      max = i;
                }
                else
                {
                    if (std::invoke(comp, std::invoke(proj, *i),
                                          std::invoke(proj, *min)))
                        min = i;
                    if (!(std::invoke(comp, std::invoke(proj, *first),
                                            std::invoke(proj, *max))))
                        max = first;
                }
            }
        }
        return {min, max};
    }

    template&lt;ranges::forward_range R, class Proj = std::identity,
             std::indirect_strict_weak_order&lt;
                 std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;
    constexpr ranges::minmax_element_result&lt;ranges::borrowed_iterator_t&lt;R&gt;&gt;
        operator()(R&amp;&amp; r, Comp comp = {}, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::ref(comp), std::ref(proj));
    }
};

inline constexpr minmax_element_fn minmax_element;
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
namespace ranges = std::ranges;
 
int main()
{
    const auto v = {3, 9, 1, 4, 1, 2, 5, 9};
    const auto [min, max] = ranges::minmax_element(v);
    std::cout
        &lt;&lt; "min = " &lt;&lt; *min &lt;&lt; ", at [" &lt;&lt; ranges::distance(v.begin(), min) &lt;&lt; "]\n"
        &lt;&lt; "max = " &lt;&lt; *max &lt;&lt; ", at [" &lt;&lt; ranges::distance(v.begin(), max) &lt;&lt; "]\n";
}
|output=
min = 1, at [2]
max = 9, at [7]
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc min_element}}
{{dsc inc|cpp/algorithm/ranges/dsc max_element}}
{{dsc inc|cpp/algorithm/ranges/dsc minmax}}
{{dsc inc|cpp/algorithm/dsc minmax_element}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}