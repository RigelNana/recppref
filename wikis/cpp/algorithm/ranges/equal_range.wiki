{{cpp/ranges/title|equal_range}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl rev begin|num=1}}
{{dcla|anchor=1|since=c++20|until=c++26|1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
          class T, class Proj = std::identity,
          std::indirect_strict_weak_order
              &lt;const T*, std::projected&lt;I, Proj&gt;&gt; Comp = ranges::less &gt;
constexpr ranges::subrange&lt;I&gt; equal_range( I first, S last, const T&amp; value,
                                           Comp comp = {}, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;I, Proj&gt;,
          std::indirect_strict_weak_order
              &lt;const T*, std::projected&lt;I, Proj&gt;&gt; Comp = ranges::less &gt;
constexpr ranges::subrange&lt;I&gt; equal_range( I first, S last, const T&amp; value,
                                           Comp comp = {}, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::forward_range R,
          class T, class Proj = std::identity,
          std::indirect_strict_weak_order
              &lt;const T*, std::projected&lt;ranges::iterator_t&lt;R&gt;,
                                        Proj&gt;&gt; Comp = ranges::less &gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    equal_range( R&amp;&amp; r, const T&amp; value, Comp comp = {}, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::forward_range R,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
          std::indirect_strict_weak_order
              &lt;const T*, std::projected&lt;ranges::iterator_t&lt;R&gt;,
                                        Proj&gt;&gt; Comp = ranges::less &gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    equal_range( R&amp;&amp; r, const T&amp; value, Comp comp = {}, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl end}}

@1@ Returns a view containing all elements equivalent to {{c|value}} in the range {{range|first|last}}.

The range {{range|first|last}} must be at least partially ordered with respect to {{c|value}}, i.e. it must satisfy all of the following requirements:
* partitioned with respect to {{c|element &lt; value}} or {{c|comp(element, value)}} (that is, all elements for which the expression is {{c|true}} precedes all elements for which the expression is {{c|false}}).
* partitioned with respect to {{c|!(value &lt; element)}} or {{c|!comp(value, element)}}.
* for all elements, if {{c|element &lt; value}} or {{c|comp(element, value)}} is {{c|true}} then {{c|!(value &lt; element)}} or {{c|!comp(value, element)}} is also {{c|true}}.
A fully-sorted range meets these criteria.

The returned view is constructed from two iterators, one pointing to the first element that is ''not less'' than {{c|value}} and another pointing to the first element ''greater'' than {{c|value}}. The first iterator may be alternatively obtained with {{lc|std::ranges::lower_bound()}}, the second - with {{lc|std::ranges::upper_bound()}}.

@2@ Same as {{v|1}}, but uses {{c|r}} as the source range, as if using the range {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to examine}}
{{par|r|the range of the elements to examine}}
{{par|value|value to compare the elements to}}
{{par|comp|if the first argument is ''less'' than (i.e. is ordered before) the second}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
{{lc|std::ranges::subrange}} containing a pair of iterators defining the wanted range, the first pointing to the first element that is ''not less'' than {{c|value}} and the second pointing to the first element ''greater'' than {{c|value}}. 

If there are no elements ''not less'' than {{c|value}}, the last iterator (iterator that is equal to {{c|last}} or {{c|ranges::end(r)}}) is returned as the first element. Similarly if there are no elements ''greater'' than {{c|value}}, the last iterator is returned as the second element.

===Complexity===
The number of comparisons performed is logarithmic in the distance between {{c|first}} and {{c|last}} (at most {{math|2 * log{{su|b=2}}(last - first) + O(1)}} comparisons). However, for an iterator that does not model {{lconcept|random_access_iterator}}, the number of iterator increments is linear.

===Possible implementation===
{{eq fun|1=
struct equal_range_fn
{
    template&lt;std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity, class T = std::projected_value_t&lt;I, Proj&gt;,
             std::indirect_strict_weak_order
                 &lt;const T*, std::projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;
    constexpr ranges::subrange&lt;I&gt;
        operator()(I first, S last, const T&amp; value, Comp comp = {}, Proj proj = {}) const
    {
        return ranges::subrange
        (
            ranges::lower_bound(first, last, value, std::ref(comp), std::ref(proj)),
            ranges::upper_bound(first, last, value, std::ref(comp), std::ref(proj))
        );
    }
 
    template&lt;ranges::forward_range R, class Proj = std::identity,
             class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
             std::indirect_strict_weak_order
                 &lt;const T*, std::projected&lt;ranges::iterator_t&lt;R&gt;,
                                           Proj&gt;&gt; Comp = ranges::less&gt;
    constexpr ranges::borrowed_subrange_t&lt;R&gt;
        operator()(R&amp;&amp; r, const T&amp; value, Comp comp = {}, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), value,
                       std::ref(comp), std::ref(proj));
    }
};
 
inline constexpr equal_range_fn equal_range;
}}

===Notes===
{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms {{vl|1,2}}}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;compare&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct S
{
    int number {};
    char name {};
    // note: name is ignored by these comparison operators
    friend bool operator== (const S s1, const S s2) { return s1.number == s2.number; }
    friend auto operator&lt;=&gt;(const S s1, const S s2) { return s1.number &lt;=&gt; s2.number; }
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, S o)
    {
        return os &lt;&lt; '{' &lt;&lt; o.number &lt;&lt; ", '" &lt;&lt; o.name &lt;&lt; "'}";
    }
};

void println(auto rem, const auto&amp; v)
{
    for (std::cout &lt;&lt; rem; const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    // note: not ordered, only partitioned w.r.t. S defined below
    std::vector&lt;S&gt; vec
    {
        {1,'A'}, {2,'B'}, {2,'C'}, {2,'D'}, {4, 'D'}, {4,'G'}, {3,'F'}
    };
    
    const S value{2, '?'};
    
    namespace ranges = std::ranges;
    
    auto a = ranges::equal_range(vec, value);
    println("1. ", a);
    
    auto b = ranges::equal_range(vec.begin(), vec.end(), value);
    println("2. ", b);
    
    auto c = ranges::equal_range(vec, 'D', ranges::less {}, &amp;S::name);
    println("3. ", c);
    
    auto d = ranges::equal_range(vec.begin(), vec.end(), 'D', ranges::less {}, &amp;S::name);
    println("4. ", d);

    using CD = std::complex&lt;double&gt;;
    std::vector&lt;CD&gt; nums{&lt;!----&gt;{1, 0}, {2, 2}, {2, 1}, {3, 0}, {3, 1}&lt;!----&gt;};
    auto cmpz = [](CD x, CD y) { return x.real() &lt; y.real(); };
    #ifdef __cpp_lib_algorithm_default_value_type
        auto p3 = ranges::equal_range(nums, {2, 0}, cmpz);
    #else
        auto p3 = ranges::equal_range(nums, CD{2, 0}, cmpz);
    #endif
    println("5. ", p3);
}
|output=
1. {2, 'B'} {2, 'C'} {2, 'D'}
2. {2, 'B'} {2, 'C'} {2, 'D'}
3. {2, 'D'} {4, 'D'}
4. {2, 'D'} {4, 'D'}
5. (2,2) (2,1)
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc lower_bound}}
{{dsc inc|cpp/algorithm/ranges/dsc upper_bound}}
{{dsc inc|cpp/algorithm/ranges/dsc binary_search}}
{{dsc inc|cpp/algorithm/ranges/dsc partition}}
{{dsc inc|cpp/algorithm/ranges/dsc equal}}
{{dsc inc|cpp/algorithm/dsc equal_range}}
{{dsc end}}

{{langlinks|es|ja|zh}}