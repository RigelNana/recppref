{{cpp/ranges/title|partial_sort_copy|partial_sort_copy_result}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl|num=1|since=c++20|1=
template&lt; std::input_iterator I1, std::sentinel_for&lt;I1&gt; S1,
          std::random_access_iterator I2, std::sentinel_for&lt;I2&gt; S2,
          class Comp = ranges::less, class Proj1 = std::identity,
          class Proj2 = std::identity &gt;
requires std::indirectly_copyable&lt;I1, I2&gt; &amp;&amp;
         std::sortable&lt;I2, Comp, Proj2&gt; &amp;&amp;
         std::indirect_strict_weak_order&lt;Comp, std::projected&lt;I1, Proj1&gt;,
             std::projected&lt;I2, Proj2&gt;&gt;
constexpr partial_sort_copy_result&lt;I1, I2&gt;
    partial_sort_copy( I1 first, S1 last, I2 result_first, S2 result_last,
                       Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {} );
}}
{{dcl|num=2|since=c++20|1=
template&lt; ranges::input_range R1, ranges::random_access_range R2,
          class Comp = ranges::less, class Proj1 = std::identity,
          class Proj2 = std::identity &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R1&gt;, ranges::iterator_t&lt;R2&gt;&gt; &amp;&amp;
         std::sortable&lt;ranges::iterator_t&lt;R2&gt;, Comp, Proj2&gt; &amp;&amp;
         std::indirect_strict_weak_order&lt;Comp, std::projected&lt;ranges::iterator_t&lt;R1&gt;,
             Proj1&gt;, std::projected&lt;ranges::iterator_t&lt;R2&gt;, Proj2&gt;&gt;
constexpr partial_sort_copy_result&lt;ranges::borrowed_iterator_t&lt;R1&gt;,
                                   ranges::borrowed_iterator_t&lt;R2&gt;&gt;
    partial_sort_copy( R1&amp;&amp; r, R2&amp;&amp; result_r,
                       Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {} );
}}
{{dcl h|Helper types}}
{{dcl|num=3|since=c++20|1=
template&lt; class I, class O &gt;
using partial_sort_copy_result = ranges::in_out_result&lt;I, O&gt;;
}}
{{dcl end}}

Copies the first {{c|N}} elements from the source range {{range|first|last}}, as if it was partially sorted with respect to {{c|comp}} and {{c|proj1}}, into the destination range {{range|result_first|result_first + N}}, where {{mathjax-or|1=\(\scriptsize N = \min{(L_1, L_2)}\)|2=N = min(L₁, L₂)}}, {{mathjax-or|\(\scriptsize L_1\)|L₁}} is equal to {{c|ranges::distance(first, last)}}, and {{mathjax-or|\(\scriptsize L_2\)|L₂}} is equal to {{c|ranges::distance(result_first, result_last)}}.

The order of equal elements is ''not'' guaranteed to be preserved.

@1@ The source range elements are projected using the function object {{c|proj1}}, and the destination elements are projected using the function object {{c|proj2}}.

@2@ Same as {{v|1}}, but uses {{c|r}} as the source range and {{c|result_r}} as the destination range, as if using {{c|ranges::begin(r)}} as {{c|first}}, {{c|ranges::end(r)}} as {{c|last}}, {{c|ranges::begin(result_r)}} as {{c|result_first}}, and {{c|ranges::end(result_r)}} as {{c|result_last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|iterator-sentinel defining the source range to copy from}}
{{par|r|the source range to copy from}}
{{par|result_first, result_last|iterator-sentinel defining the destination range}}
{{par|result_r|the destination range}}
{{par|comp|comparison to apply to the projected elements}}
{{par|proj1|projection to apply to the elements of source range}}
{{par|proj2|projection to apply to the elements of destination range}}
{{par end}}

===Return value===
An object equal to {{c|{last, result_first + N} }}.

===Complexity===
At most {{mathjax-or|\(\scriptsize L_1 \cdot \log{(N)}\)|L₁•log(N)}} comparisons and {{mathjax-or|\(\scriptsize 2 \cdot L_1 \cdot \log{(N)}\)|2•L₁•log(N)}} projections.

===Possible implementation===
{{eq fun|1=
struct partial_sort_copy_fn
{
    template&lt;std::input_iterator I1, std::sentinel_for&lt;I1&gt; S1,
             std::random_access_iterator I2, std::sentinel_for&lt;I2&gt; S2,
             class Comp = ranges::less, class Proj1 = std::identity,
             class Proj2 = std::identity&gt;
    requires std::indirectly_copyable&lt;I1, I2&gt; &amp;&amp; std::sortable&lt;I2, Comp, Proj2&gt; &amp;&amp;
             std::indirect_strict_weak_order&lt;Comp, std::projected&lt;I1, Proj1&gt;,
             std::projected&lt;I2, Proj2&gt;&gt;
    constexpr ranges::partial_sort_copy_result&lt;I1, I2&gt;
        operator()(I1 first, S1 last, I2 result_first, S2 result_last,
                   Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const
    {
        if (result_first == result_last)
            return {std::move(ranges::next(std::move(first), std::move(last))),
                    std::move(result_first)};

        auto out_last{result_first};
        // copy first N elements
        for (; !(first == last or out_last == result_last); ++out_last, ++first)
            *out_last = *first;

        // convert N copied elements into a max-heap
        ranges::make_heap(result_first, out_last, comp, proj2);

        // process the rest of the input range (if any), preserving the heap property
        for (; first != last; ++first)
        {
            if (std::invoke(comp, std::invoke(proj1, *first),
                                  std::invoke(proj2, *result_first)))
            {
                // pop out the biggest item and push in a newly found smaller one
                ranges::pop_heap(result_first, out_last, comp, proj2);
                *(out_last - 1) = *first;
                ranges::push_heap(result_first, out_last, comp, proj2);
            }
        }

        // first N elements in the output range is still
        // a heap - convert it into a sorted range
        ranges::sort_heap(result_first, out_last, comp, proj2);

        return {std::move(first), std::move(out_last)};
    }

    template&lt;ranges::input_range R1, ranges::random_access_range R2,
             class Comp = ranges::less, class Proj1 = std::identity,
             class Proj2 = std::identity&gt;
    requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R1&gt;, ranges::iterator_t&lt;R2&gt;&gt; &amp;&amp;
             std::sortable&lt;ranges::iterator_t&lt;R2&gt;, Comp, Proj2&gt; &amp;&amp;
             std::indirect_strict_weak_order&lt;Comp, std::projected&lt;ranges::iterator_t&lt;R1&gt;,
             Proj1&gt;, std::projected&lt;ranges::iterator_t&lt;R2&gt;, Proj2&gt;&gt;
    constexpr ranges::partial_sort_copy_result&lt;ranges::borrowed_iterator_t&lt;R1&gt;,
              ranges::borrowed_iterator_t&lt;R2&gt;&gt;
        operator()(R1&amp;&amp; r, R2&amp;&amp; result_r, Comp comp = {},
                   Proj1 proj1 = {}, Proj2 proj2 = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r),
                       ranges::begin(result_r), ranges::end(result_r),
                       std::move(comp), std::move(proj1), std::move(proj2));
    }
};

inline constexpr partial_sort_copy_fn partial_sort_copy {};
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;forward_list&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

void print(std::string_view rem, std::ranges::input_range auto const&amp; v)
{
    for (std::cout &lt;&lt; rem; const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    const std::forward_list source{4, 2, 5, 1, 3};

    print("Write to the smaller vector in ascending order: ", "");

    std::vector dest1{10, 11, 12};
    print("const source list: ", source);
    print("destination range: ", dest1);
    std::ranges::partial_sort_copy(source, dest1);
    print("partial_sort_copy: ", dest1);

    print("Write to the larger vector in descending order:", "");

    std::vector dest2{10, 11, 12, 13, 14, 15, 16};
    print("const source list: ", source);
    print("destination range: ", dest2);
    std::ranges::partial_sort_copy(source, dest2, std::greater{});
    print("partial_sort_copy: ", dest2);
}
|output=
Write to the smaller vector in ascending order:
const source list: 4 2 5 1 3
destination range: 10 11 12
partial_sort_copy: 1 2 3
Write to the larger vector in descending order:
const source list: 4 2 5 1 3
destination range: 10 11 12 13 14 15 16
partial_sort_copy: 5 4 3 2 1 15 16
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc partial_sort}}
{{dsc inc|cpp/algorithm/ranges/dsc sort}}
{{dsc inc|cpp/algorithm/ranges/dsc stable_sort}}
{{dsc inc|cpp/algorithm/ranges/dsc sort_heap}}
{{dsc inc|cpp/algorithm/ranges/dsc make_heap}}
{{dsc inc|cpp/algorithm/ranges/dsc push_heap}}
{{dsc inc|cpp/algorithm/ranges/dsc pop_heap}}
{{dsc inc|cpp/algorithm/dsc partial_sort_copy}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}