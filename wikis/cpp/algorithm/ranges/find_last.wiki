{{cpp/ranges/title|find_last|find_last_if|find_last_if_not}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl rev multi|num=1|anchor=1|since1=c++23|until1=c++26|dcl1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
          class T,
          class Proj = std::identity &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr ranges::subrange&lt;I&gt;
    find_last( I first, S last, const T&amp; value, Proj proj = {} );
|dcl2=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;I, Proj&gt; &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr ranges::subrange&lt;I&gt;
    find_last( I first, S last, const T&amp; value, Proj proj = {} );
}}
{{dcl rev multi|num=2|since1=c++23|until1=c++26|dcl1=
template&lt; ranges::forward_range R,
          class T,
          class Proj = std::identity &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    find_last( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
|dcl2=
template&lt; ranges::forward_range R,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;iterator_t&lt;R&gt;, Proj&gt; &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    find_last( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
}}
{{dcla|since=c++23|num=3|1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr ranges::subrange&lt;I&gt;
    find_last_if( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++23|num=4|1=
template&lt; ranges::forward_range R,
          class Proj = std::identity,
          std::indirect_unary_predicate
              &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    find_last_if( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcla|since=c++23|num=5|1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr ranges::subrange&lt;I&gt;
    find_last_if_not( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++23|num=6|1=
template&lt; ranges::forward_range R,
          class Proj = std::identity,
          std::indirect_unary_predicate
              &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    find_last_if_not( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcl end}}

Returns the last element in the range {{range|first|last}} that satisfies specific criteria:
@1@ {{tt|find_last}} searches for an element equal to {{c|value}}.

@3@ {{tt|find_last_if}} searches for the last element in the range {{range|first|last}} for which predicate {{c|pred}} returns {{c|true}}.

@5@ {{tt|find_last_if_not}} searches for the last element in the range {{range|first|last}} for which predicate {{c|pred}} returns {{c|false}}.

@2,4,6@ Same as {{v|1,3,5}}, but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to examine}}
{{par|r|the range of the elements to examine}}
{{par|value|value to compare the elements to}}
{{par|pred|predicate to apply to the projected elements}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
@1,3,5@ Let {{c|i}} be the last iterator in the range {{range|first|last}} for which {{c|E}} is {{c|true}}.
@@ Returns {{c|ranges::subrange&lt;I&gt;{i, last}&lt;!----&gt;}}, or {{c|ranges::subrange&lt;I&gt;{last, last}&lt;!----&gt;}} if no such iterator is found.
:@1@ {{c|E}} is {{c|1=bool(std::invoke(proj, *i) == value)}}.
:@3@ {{c|E}} is {{c|bool(std::invoke(pred, std::invoke(proj, *i)))}}.
:@5@ {{c|E}} is {{c|bool(!std::invoke(pred, std::invoke(proj, *i)))}}.

@2,4,6@ Same as {{v|1,3,5}} but the return type is {{c|ranges::borrowed_subrange_t&lt;I&gt;}}.

===Complexity===
At most {{c|last - first}} applications of the predicate and projection.

===Notes===
{{tt|ranges::find_last}}, {{tt|ranges::find_last_if}}, {{tt|ranges::find_last_if_not}} have better efficiency on common implementations if {{tt|I}} models {{lconcept|bidirectional_iterator}} or (better) {{lconcept|random_access_iterator}}.

{{ftm begin}}
{{ftm|std=C++23|value=202207L|__cpp_lib_ranges_find_last|{{tt|ranges::find_last}},&lt;br&gt;{{tt|ranges::find_last_if}},&lt;br&gt;{{tt|ranges::find_last_if_not}}}}
{{ftm|__cpp_lib_algorithm_default_value_type|value=202403L|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms {{vl|1,2}}}}
{{ftm end}}

===Possible implementation===
These implementations only show the slower algorithm used when {{c|I}} models {{lconcept|forward_iterator}}.
{{eq impl
|title1=find_last (1,2)|ver1=1|1=
struct find_last_fn
{
    template&lt;std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity,
             class T = std::projected_value_t&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;
    requires std::indirect_binary_predicate
                 &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
    constexpr ranges::subrange&lt;I&gt;
        operator()(I first, S last, const T &amp;value, Proj proj = {}) const
    {
        // Note: if I is mere forward_iterator, we may only go from begin to end.
        std::optional&lt;I&gt; found;
        for (; first != last; ++first)
            if (std::invoke(proj, *first) == value)
                found = first;
        
        if (!found)
            return {first, first};
        
        return {*found, std::ranges::next(*found, last)};
    }
    
    template&lt;ranges::forward_range R,
             class Proj = std::identity,
             class T = std::projected_value_t&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;
    requires std::indirect_binary_predicate
                 &lt;ranges::equal_to,
                  std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
    constexpr ranges::borrowed_subrange_t&lt;R&gt;
        operator()(R&amp;&amp; r, const T &amp;value, Proj proj = {}) const
    {
        return this-&gt;operator()(ranges::begin(r), ranges::end(r), value, std::ref(proj));
    }
};

inline constexpr find_last_fn find_last;
|title2=find_last_if (3,4)|ver2=3|2=
struct find_last_if_fn
{
    template&lt;std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr ranges::subrange&lt;I&gt;
        operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        // Note: if I is mere forward_iterator, we may only go from begin to end.
        std::optional&lt;I&gt; found;
        for (; first != last; ++first)
            if (std::invoke(pred, std::invoke(proj, *first)))
                found = first;
        
        if (!found)
            return {first, first};
        
        return {*found, std::ranges::next(*found, last)};
    }
    
    template&lt;ranges::forward_range R, class Proj = std::identity,
             std::indirect_unary_predicate
                 &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    constexpr ranges::borrowed_subrange_t&lt;R&gt;
        operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return this-&gt;operator()(ranges::begin(r), ranges::end(r),
                                std::ref(pred), std::ref(proj));
    }
};

inline constexpr find_last_if_fn find_last_if;
|title3=find_last_if_not (5,6)|ver3=5|3=
struct find_last_if_not_fn
{
    template&lt;std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr ranges::subrange&lt;I&gt;
        operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        // Note: if I is mere forward_iterator, we may only go from begin to end.
        std::optional&lt;I&gt; found;
        for (; first != last; ++first)
            if (!std::invoke(pred, std::invoke(proj, *first)))
                found = first;
        
        if (!found)
            return {first, first};
        
        return {*found, std::ranges::next(*found, last)};
    }
    
    template&lt;ranges::forward_range R, class Proj = std::identity,
             std::indirect_unary_predicate
                 &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    constexpr ranges::borrowed_subrange_t&lt;R&gt;
        operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return this-&gt;operator()(ranges::begin(r), ranges::end(r),
                                std::ref(pred), std::ref(proj));
    }
};

inline constexpr find_last_if_not_fn find_last_if_not;
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;forward_list&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;

int main()
{
    namespace ranges = std::ranges;
    
    constexpr static auto v = {1, 2, 3, 1, 2, 3, 1, 2};
    
    {
        constexpr auto i1 = ranges::find_last(v.begin(), v.end(), 3);
        constexpr auto i2 = ranges::find_last(v, 3);
        static_assert(ranges::distance(v.begin(), i1.begin()) == 5);
        static_assert(ranges::distance(v.begin(), i2.begin()) == 5);
    }
    {
        constexpr auto i1 = ranges::find_last(v.begin(), v.end(), -3);
        constexpr auto i2 = ranges::find_last(v, -3);
        static_assert(i1.begin() == v.end());
        static_assert(i2.begin() == v.end());
    }
    
    auto abs = [](int x) { return x &lt; 0 ? -x : x; };
    
    {
        auto pred = [](int x) { return x == 3; };
        constexpr auto i1 = ranges::find_last_if(v.begin(), v.end(), pred, abs);
        constexpr auto i2 = ranges::find_last_if(v, pred, abs);
        static_assert(ranges::distance(v.begin(), i1.begin()) == 5);
        static_assert(ranges::distance(v.begin(), i2.begin()) == 5);
    }
    {
        auto pred = [](int x) { return x == -3; };
        constexpr auto i1 = ranges::find_last_if(v.begin(), v.end(), pred, abs);
        constexpr auto i2 = ranges::find_last_if(v, pred, abs);
        static_assert(i1.begin() == v.end());
        static_assert(i2.begin() == v.end());
    }
    
    {
        auto pred = [](int x) { return x == 1 or x == 2; };
        constexpr auto i1 = ranges::find_last_if_not(v.begin(), v.end(), pred, abs);
        constexpr auto i2 = ranges::find_last_if_not(v, pred, abs);
        static_assert(ranges::distance(v.begin(), i1.begin()) == 5);
        static_assert(ranges::distance(v.begin(), i2.begin()) == 5);
    }
    {
        auto pred = [](int x) { return x == 1 or x == 2 or x == 3; };
        constexpr auto i1 = ranges::find_last_if_not(v.begin(), v.end(), pred, abs);
        constexpr auto i2 = ranges::find_last_if_not(v, pred, abs);
        static_assert(i1.begin() == v.end());
        static_assert(i2.begin() == v.end());
    }
    
    using P = std::pair&lt;std::string_view, int&gt;;
    std::forward_list&lt;P&gt; list
    {
        {"one", 1}, {"two", 2}, {"three", 3},
        {"one", 4}, {"two", 5}, {"three", 6},
    };
    auto cmp_one = [](const std::string_view &amp;s) { return s == "one"; };
    
    // find latest element that satisfy the comparator, and projecting pair::first
    const auto subrange = ranges::find_last_if(list, cmp_one, &amp;P::first);
    
    std::cout &lt;&lt; "The found element and the tail after it are:\n";
    for (P const&amp; e : subrange)
        std::cout &lt;&lt; '{' &lt;&lt; std::quoted(e.first) &lt;&lt; ", " &lt;&lt; e.second &lt;&lt; "} ";
    std::cout &lt;&lt; '\n';
    
#if __cpp_lib_algorithm_default_value_type
    const auto i3 = ranges::find_last(list, {"three", 3}); // (2) C++26
#else
    const auto i3 = ranges::find_last(list, P{"three", 3}); // (2) C++23
#endif
    assert(i3.begin()-&gt;first == "three" &amp;&amp; i3.begin()-&gt;second == 3);
}
|output=
The found element and the tail after it are:
{"one", 4} {"two", 5} {"three", 6}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc find_end}}
{{dsc inc|cpp/algorithm/ranges/dsc find}}
{{dsc inc|cpp/algorithm/ranges/dsc search}}
{{dsc inc|cpp/algorithm/ranges/dsc includes}}
{{dsc inc|cpp/algorithm/ranges/dsc binary_search}}
{{dsc inc|cpp/algorithm/ranges/dsc contains}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}