{{cpp/ranges/title|partition_point}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl|num=1|since=c++20|1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr I
    partition_point( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|num=2|since=c++20|1=
template&lt; ranges::forward_range R,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    partition_point( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcl end}}

Examines the partitioned (as if by {{lc|ranges::partition}}) range {{range|first|last}} or {{c|r}} and locates the end of the first partition, that is, the projected element that does not satisfy {{c|pred}} or {{c|last}} if all projected elements satisfy {{c|pred}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|iterator-sentinel defining the partially-ordered range to examine}}
{{par|r|the partially-ordered range to examine}}
{{par|pred|predicate to apply to the projected elements}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
The iterator past the end of the first partition within {{range|first|last}} or the iterator equal to {{c|last}} if all projected elements satisfy {{c|pred}}.

===Complexity===
Given {{c|1=N = ranges::distance(first, last)}}, performs {{math|O(log N)}} applications of the predicate {{c|pred}} and projection {{c|proj}}.

However, if sentinels don't model {{c|std::sized_sentinel_for&lt;I&gt;}}, the number of iterator increments is {{math|O(N)}}.

===Notes===
This algorithm is a more general form of {{tt|ranges::lower_bound}}, which can be expressed in terms of {{tt|ranges::partition_point}} with the predicate {{c|[&amp;](auto const&amp; e) { return std::invoke(pred, e, value); });}}.

===Example===
{{example|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

auto print_seq = [](auto rem, auto first, auto last)
{
    for (std::cout &lt;&lt; rem; first != last; std::cout &lt;&lt; *first++ &lt;&lt; ' ') {}
    std::cout &lt;&lt; '\n';
};

int main()
{
    std::array v {1, 2, 3, 4, 5, 6, 7, 8, 9};

    auto is_even = [](int i) { return i % 2 == 0; };

    std::ranges::partition(v, is_even);
    print_seq("After partitioning, v: ", v.cbegin(), v.cend());

    const auto pp = std::ranges::partition_point(v, is_even);
    const auto i = std::ranges::distance(v.cbegin(), pp);
    std::cout &lt;&lt; "Partition point is at " &lt;&lt; i &lt;&lt; "; v[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; *pp &lt;&lt; '\n';

    print_seq("First partition (all even elements): ", v.cbegin(), pp);
    print_seq("Second partition (all odd elements): ", pp, v.cend());
}
|p=true
|output=
After partitioning, v: 2 4 6 8 5 3 7 1 9
Partition point is at 4; v[4] = 5
First partition (all even elements): 2 4 6 8
Second partition (all odd elements): 5 3 7 1 9
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc is_sorted}}
{{dsc inc|cpp/algorithm/ranges/dsc lower_bound}}
{{dsc inc|cpp/algorithm/dsc partition_point}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}