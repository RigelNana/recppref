{{cpp/ranges/title|next_permutation|next_permutation_result}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl|num=1|since=c++20|1=
template&lt; std::bidirectional_iterator I, std::sentinel_for&lt;I&gt; S,
          class Comp = ranges::less, class Proj = std::identity &gt;
requires std::sortable&lt;I, Comp, Proj&gt;
constexpr next_permutation_result&lt;I&gt;
    next_permutation( I first, S last, Comp comp = {}, Proj proj = {} );
}}
{{dcl|num=2|since=c++20|1=
template&lt; ranges::bidirectional_range R, class Comp = ranges::less,
          class Proj = std::identity &gt;
requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
constexpr next_permutation_result&lt;ranges::borrowed_iterator_t&lt;R&gt;&gt;
    next_permutation( R&amp;&amp; r, Comp comp = {}, Proj proj = {} );
}}
{{dcl h|Helper type}}
{{dcl|since=c++20|num=3|1=
template&lt; class I &gt;
using next_permutation_result = ranges::in_found_result&lt;I&gt;;
}}
{{dcl end}}

@1@ Transforms the range {{range|first|last}} into the next {{enwiki|permutation}}, where the set of all permutations is ordered ''lexicographically'' with respect to binary comparison function object {{c|comp}} and projection function object {{c|proj}}. Returns {{c|{last, true} }} if such a ''"next permutation"'' exists; otherwise transforms the range into the lexicographically first permutation as if by {{c|ranges::sort(first, last, comp, proj)}}, and returns {{c|{last, false} }}.

@2@ Same as {{v|1}}, but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}}, and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to ''permute''}}
{{par|r|the range of elements to ''permute''}}
{{par|comp|comparison function object which returns {{c|true}} if the first argument is ''less'' than the second}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
@1@ {{c|ranges::next_permutation_result&lt;I&gt;{last, true} }} if the new permutation is lexicographically ''greater'' than the old one. {{c|ranges::next_permutation_result&lt;I&gt;{last, false} }} if the last permutation was reached and the range was reset to the first permutation.

@2@ Same as {{v|1}} except that the return type is {{c|ranges::next_permutation_result&lt;ranges::borrowed_iterator_t&lt;R&gt;&gt;}}.

===Exceptions===
Any exceptions thrown from iterator operations or the element swap.

===Complexity===
At most {{mathjax-or|\(\scriptsize N/2\)|N / 2}} swaps, where {{mathjax-or|\(\scriptsize N\)|N}} is {{c|ranges::distance(first, last)}} in case {{v|1}} or {{c|ranges::distance(r)}} in case {{v|2}}. Averaged over the entire sequence of permutations, typical implementations use about 3 comparisons and 1.5 swaps per call.

===Notes===
{{cpp/algorithm/notes swap vectorization}}

===Possible implementation===
{{eq fun|1=
struct next_permutation_fn
{
    template&lt;std::bidirectional_iterator I, std::sentinel_for&lt;I&gt; S,
             class Comp = ranges::less, class Proj = std::identity&gt;
    requires std::sortable&lt;I, Comp, Proj&gt;
    constexpr ranges::next_permutation_result&lt;I&gt;
        operator()(I first, S last, Comp comp = {}, Proj proj = {}) const
    {
        // check that the sequence has at least two elements
        if (first == last)
            return {std::move(first), false};
        I i_last{ranges::next(first, last)};
        I i{i_last};
        if (first == --i)
            return {std::move(i_last), false};
        // main "permutating" loop
        for (;;)
        {
            I i1{i};
            if (std::invoke(comp, std::invoke(proj, *--i), std::invoke(proj, *i1)))
            {
                I j{i_last};
                while (!std::invoke(comp, std::invoke(proj, *i), std::invoke(proj, *--j)))
                {}
                std::iter_swap(i, j);
                std::reverse(i1, i_last);
                return {std::move(i_last), true};
            }
            // permutation "space" is exhausted
            if (i == first)
            {
                std::reverse(first, i_last);
                return {std::move(i_last), false};
            }
        }
    }

    template&lt;ranges::bidirectional_range R, class Comp = ranges::less,
             class Proj = std::identity&gt;
    requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
    constexpr ranges::next_permutation_result&lt;ranges::borrowed_iterator_t&lt;R&gt;&gt;
        operator()(R&amp;&amp; r, Comp comp = {}, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r),
                       std::move(comp), std::move(proj));
    }
};

inline constexpr next_permutation_fn next_permutation {};
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;compare&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

struct S
{
    char c;
    int i;
    auto operator&lt;=&gt;(const S&amp;) const = default;
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const S&amp; s)
    {
        return os &lt;&lt; "{'" &lt;&lt; s.c &lt;&lt; "', " &lt;&lt; s.i &lt;&lt; "}";
    }
};

auto print = [](auto const&amp; v, char term = ' ')
{
    std::cout &lt;&lt; "{ ";
    for (const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '}' &lt;&lt; term;
};

int main()
{
    std::cout &lt;&lt; "Generate all permutations (iterators case):\n";
    std::string s{"abc"};
    do
    {
        print(s);
    }
    while (std::ranges::next_permutation(s.begin(), s.end()).found);

    std::cout &lt;&lt; "\n" "Generate all permutations (range case):\n";
    std::array a{'a', 'b', 'c'};
    do
    {
        print(a);
    }
    while (std::ranges::next_permutation(a).found);

    std::cout &lt;&lt; "\n" "Generate all permutations using comparator:\n";
    using namespace std::literals;
    std::array z{"█"s, "▄"s, "▁"s};
    do
    {
        print(z);
    }
    while (std::ranges::next_permutation(z, std::greater()).found);

    std::cout &lt;&lt; "\n" "Generate all permutations using projection:\n";
    std::array&lt;S, 3&gt; r{S{'A',3}, S{'B',2}, S{'C',1}&lt;!----&gt;};
    do
    {
        print(r, '\n');
    }
    while (std::ranges::next_permutation(r, {}, &amp;S::c).found);
}
|output=
Generate all permutations (iterators case):
{ a b c } { a c b } { b a c } { b c a } { c a b } { c b a }
Generate all permutations (range case):
{ a b c } { a c b } { b a c } { b c a } { c a b } { c b a }
Generate all permutations using comparator:
{ █ ▄ ▁ } { █ ▁ ▄ } { ▄ █ ▁ } { ▄ ▁ █ } { ▁ █ ▄ } { ▁ ▄ █ }
Generate all permutations using projection:
{ {'A', 3} {'B', 2} {'C', 1} }
{ {'A', 3} {'C', 1} {'B', 2} }
{ {'B', 2} {'A', 3} {'C', 1} }
{ {'B', 2} {'C', 1} {'A', 3} }
{ {'C', 1} {'A', 3} {'B', 2} }
{ {'C', 1} {'B', 2} {'A', 3} }
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc prev_permutation}}
{{dsc inc|cpp/algorithm/ranges/dsc is_permutation}}
{{dsc inc|cpp/algorithm/dsc next_permutation}}
{{dsc inc|cpp/algorithm/dsc prev_permutation}}
{{dsc inc|cpp/algorithm/dsc is_permutation}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}