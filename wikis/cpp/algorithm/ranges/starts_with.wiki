{{cpp/ranges/title|starts_with}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl|num=1|since=c++23|1=
template&lt; std::input_iterator I1, std::sentinel_for&lt;I1&gt; S1,
          std::input_iterator I2, std::sentinel_for&lt;I2&gt; S2,
          class Pred = ranges::equal_to,
          class Proj1 = std::identity, class Proj2 = std::identity &gt;
requires std::indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
constexpr bool
    starts_with( I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {} );
}}
{{dcl|num=2|since=c++23|1=
template&lt; ranges::input_range R1, ranges::input_range R2,
          class Pred = ranges::equal_to,
          class Proj1 = std::identity, class Proj2 = std::identity &gt;
requires std::indirectly_comparable&lt;ranges::iterator_t&lt;R1&gt;,
                                    ranges::iterator_t&lt;R2&gt;,
                                    Pred, Proj1, Proj2&gt;
constexpr bool
    starts_with( R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {} );
}}
{{dcl end}}

Checks whether the second range matches the prefix of the first range.

@1@ Let {{tt|N1}} and {{tt|N2}} denote the size of ranges {{range|first1|last1}} and {{range|first2|last2}} respectively. If {{c|N1 &lt; N2}}, returns {{c|false}}. Otherwise, returns {{c|true}} only if every element in the range {{range|first2|last2}} is equal to the corresponding element in {{range|first1|first1 + N2}}. Comparison is done by applying the binary predicate {{c|pred}} to elements in two ranges projected by {{c|proj1}} and {{c|proj2}} respectively.

@2@ Same as {{v|1}}, but uses {{c|r1}} and {{c|r2}} as the source ranges, as if using {{c|ranges::begin(r1)}} as {{c|first1}}, {{c|ranges:begin(r2)}} as {{c|first2}}, {{c|ranges::end(r1)}} as {{c|last1}}, and {{c|ranges::end(r2)}} as {{c|last2}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first1, last1|the range of elements to examine}}
{{par|r1|the range of elements to examine}}
{{par|first2, last2|the range of elements to be used as the prefix}}
{{par|r2|the range of elements to be used as the prefix}}
{{par|pred|the binary predicate that compares the projected elements}}
{{par|proj1|the projection to apply to the elements of the range to examine}}
{{par|proj2|the projection to apply to the elements of the range to be used as the prefix}}
{{par end}}

===Return value===
{{c|true}} if the second range matches the prefix of the first range, {{c|false}} otherwise.

===Complexity===
Linear: at most {{c|min(N1, N2)}} applications of the predicate and both projections.

===Possible implementation===
{{eq fun|1=
struct starts_with_fn
{
    template&lt;std::input_iterator I1, std::sentinel_for&lt;I1&gt; S1,
             std::input_iterator I2, std::sentinel_for&lt;I2&gt; S2,
             class Pred = ranges::equal_to,
             class Proj1 = std::identity, class Proj2 = std::identity&gt;
    requires std::indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
    constexpr bool operator()(I1 first1, S1 last1, I2 first2, S2 last2,
                              Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const
    {
        return ranges::mismatch(std::move(first1), last1, std::move(first2), last2,
                                std::move(pred), std::move(proj1), std::move(proj2)
                               ).in2 == last2;
    }

    template&lt;ranges::input_range R1, ranges::input_range R2,
             class Pred = ranges::equal_to,
             class Proj1 = std::identity, class Proj2 = std::identity&gt;
    requires std::indirectly_comparable&lt;ranges::iterator_t&lt;R1&gt;,
                                        ranges::iterator_t&lt;R2&gt;,
                                        Pred, Proj1, Proj2&gt;
    constexpr bool operator()(R1&amp;&amp; r1, R2&amp;&amp; r2,
                              Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {}) const
    {
        return (*this)(ranges::begin(r1), ranges::end(r1),
                       ranges::begin(r2), ranges::end(r2),
                       std::move(pred), std::move(proj1), std::move(proj2));
    }
};

inline constexpr starts_with_fn starts_with {};
}}

===Notes===
{{feature test macro|__cpp_lib_ranges_starts_ends_with|std=C++23|value=202106L|{{tt|std::ranges::starts_with}}, {{lc|std::ranges::ends_with}}}}

===Example===
{{example|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;string_view&gt;

int main()
{
    using namespace std::literals;

    constexpr auto ascii_upper = [](char8_t c)
    {
        return u8'a' &lt;= c &amp;&amp; c &lt;= u8'z' ? static_cast&lt;char8_t&gt;(c + u8'A' - u8'a') : c;
    };

    constexpr auto cmp_ignore_case = [=](char8_t x, char8_t y)
    {
        return ascii_upper(x) == ascii_upper(y);
    };

    static_assert(std::ranges::starts_with("const_cast", "const"sv));
    static_assert(std::ranges::starts_with("constexpr", "const"sv));
    static_assert(!std::ranges::starts_with("volatile", "const"sv));

    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; std::ranges::starts_with(u8"Constantinopolis", u8"constant"sv,
                                          {}, ascii_upper, ascii_upper) &lt;&lt; ' '
              &lt;&lt; std::ranges::starts_with(u8"Istanbul", u8"constant"sv,
                                          {}, ascii_upper, ascii_upper) &lt;&lt; ' '
              &lt;&lt; std::ranges::starts_with(u8"Metropolis", u8"metro"sv,
                                          cmp_ignore_case) &lt;&lt; ' '
              &lt;&lt; std::ranges::starts_with(u8"Acropolis", u8"metro"sv,
                                          cmp_ignore_case) &lt;&lt; '\n';

    constexpr static auto v = { 1, 3, 5, 7, 9 };
    constexpr auto odd = [](int x) { return x % 2; };
    static_assert(std::ranges::starts_with(v, std::views::iota(1)
                                            {{!}} std::views::filter(odd)
                                            {{!}} std::views::take(3)));
}
|output=true false true false
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc ends_with}}
{{dsc inc|cpp/algorithm/ranges/dsc mismatch}}
{{dsc inc|cpp/string/basic_string/dsc starts_with}}
{{dsc inc|cpp/string/basic_string_view/dsc starts_with}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}