{{cpp/ranges/title|stable_partition}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcla|anchor=no|num=1|since=c++20|constexpr=c++26|1=
template&lt; std::bidirectional_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
requires std::permutable&lt;I&gt;
ranges::subrange&lt;I&gt;
    stable_partition( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcla|anchor=no|num=2|since=c++20|constexpr=c++26|1=
template&lt; ranges::bidirectional_range R, class Proj = std::identity,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
requires std::permutable&lt;ranges::iterator_t&lt;R&gt;&gt;
ranges::borrowed_subrange_t&lt;R&gt;
    stable_partition( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcl end}}

@1@ Reorders the elements in the range {{range|first|last}} in such a way that the projection {{c|proj}} of all elements for which the predicate {{c|pred}} returns {{c|true}} precede the projection {{c|proj}} of elements for which predicate {{c|pred}} returns {{c|false}}. The algorithms is ''stable'', i.e. the relative order of elements is ''preserved''.

@2@ Same as {{v|1}}, but uses {{c|r}} as the range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to reorder}}
{{par|r|the range of elements to reorder}}
{{par|pred|predicate to apply to the projected elements}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
@1@ An object equal to {{c|{pivot, last}&lt;!----&gt;}}, where {{tt|pivot}} is an iterator to the first element of the second group.
@2@ Same as {{v|1}} if {{c|r}} is an lvalue or of a {{lconcept|borrowed_range}} type. Otherwise returns {{lc|std::ranges::dangling}}.

===Complexity===
Given {{c|1= N = ranges::distance(first, last)}}, the complexity is at worst {{mathjax-or|\(\scriptsize N\cdot\log{(N)}\)|N¬∑log(N)}} swaps, and only {{mathjax-or|\(\scriptsize \mathcal{O}(N)\)|ùìû(N)}} swaps in case an extra memory buffer is used. Exactly {{mathjax-or|\(\scriptsize N\)|N}} applications of the predicate {{c|pred}} and projection {{c|proj}}.

===Notes===
This function attempts to allocate a temporary buffer. If the allocation fails, the less efficient algorithm is chosen.

{{feature test macro|__cpp_lib_constexpr_algorithms|{{c/core|constexpr}} stable sorting|value=202306L|std=C++26}}

===Possible implementation===
This implementation does not use extra memory buffer and as such can be less efficient. See also the implementation in [https://github.com/microsoft/STL/blob/e745bad3b1d05b5b19ec652d68abb37865ffa454/stl/inc/algorithm#L5358-L5555 MSVC STL] and [https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/ranges_algo.h#L2365-L2394 libstdc++].
{{eq fun|1=
struct stable_partition_fn
{
    template&lt;std::bidirectional_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires std::permutable&lt;I&gt;
    constexpr ranges::subrange&lt;I&gt;
        operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        first = ranges::find_if_not(first, last, pred, proj);
        I mid = first;
        while (mid != last)
        {
            mid = ranges::find_if(mid, last, pred, proj);
            if (mid == last)
                break;
            I last2 = ranges::find_if_not(mid, last, pred, proj);
            ranges::rotate(first, mid, last2);
            first = ranges::next(first, ranges::distance(mid, last2));
            mid = last2;
        }
        return {std::move(first), std::move(mid)};
    }

    template&lt;ranges::bidirectional_range R, class Proj = std::identity,
             std::indirect_unary_predicate&lt;
                 std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires std::permutable&lt;ranges::iterator_t&lt;R&gt;&gt;
    constexpr ranges::borrowed_subrange_t&lt;R&gt;
        operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(pred), std::move(proj));
    }
};

inline constexpr stable_partition_fn stable_partition {};
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

namespace rng = std::ranges;

template&lt;std::permutable I, std::sentinel_for&lt;I&gt; S&gt;
constexpr void stable_sort(I first, S last)
{
    if (first == last)
        return;

    auto pivot = *rng::next(first, rng::distance(first, last) / 2, last);
    auto left = [pivot](const auto&amp; em) { return em &lt; pivot; };
    auto tail1 = rng::stable_partition(first, last, left);
    auto right = [pivot](const auto&amp; em) { return !(pivot &lt; em); };
    auto tail2 = rng::stable_partition(tail1, right);

    stable_sort(first, tail1.begin());
    stable_sort(tail2.begin(), tail2.end());
}

void print(const auto rem, auto first, auto last, bool end = true)
{
    std::cout &lt;&lt; rem;
    for (; first != last; ++first)
        std::cout &lt;&lt; *first &lt;&lt; ' ';
    std::cout &lt;&lt; (end ? "\n" : "");
}

int main()
{
    const auto original = {9, 6, 5, 2, 3, 1, 7, 8};

    std::vector&lt;int&gt; vi {};
    auto even = [](int x) { return 0 == (x % 2); };

    print("Original vector:\t", original.begin(), original.end(), "\n");

    vi = original;
    const auto ret1 = rng::stable_partition(vi, even);
    print("Stable partitioned:\t", vi.begin(), ret1.begin(), 0);
    print("‚îÇ ", ret1.begin(), ret1.end());

    vi = original;
    const auto ret2 = rng::partition(vi, even);
    print("Partitioned:\t\t", vi.begin(), ret2.begin(), 0);
    print("‚îÇ ", ret2.begin(), ret2.end());


    vi = {16, 30, 44, 30, 15, 24, 10, 18, 12, 35};
    print("Unsorted vector: ", vi.begin(), vi.end());

    stable_sort(rng::begin(vi), rng::end(vi));
    print("Sorted vector:   ", vi.begin(), vi.end());
}
|p=true &lt;!-- the order of elements after applying the `partition` (as opposed to `stable_partition`) is not (fully) specified --&gt;
|output=
Original vector:        9 6 5 2 3 1 7 8
Stable partitioned:     6 2 8 ‚îÇ 9 5 3 1 7
Partitioned:            8 6 2 ‚îÇ 5 3 1 7 9
Unsorted vector: 16 30 44 30 15 24 10 18 12 35
Sorted vector:   10 12 15 16 18 24 30 30 35 44
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc partition}}
{{dsc inc|cpp/algorithm/ranges/dsc partition_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc is_partitioned}}
{{dsc inc|cpp/algorithm/dsc stable_partition}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}