{{cpp/ranges/title|search}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl|num=1|since=c++20|1=
template&lt; std::forward_iterator I1, std::sentinel_for&lt;I1&gt; S1,
          std::forward_iterator I2, std::sentinel_for&lt;I2&gt; S2,
          class Pred = ranges::equal_to,
          class Proj1 = std::identity,
          class Proj2 = std::identity &gt;
requires std::indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
constexpr ranges::subrange&lt;I1&gt;
    search( I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
            Proj1 proj1 = {}, Proj2 proj2 = {} );
}}
{{dcl|num=2|since=c++20|1=
template&lt; ranges::forward_range R1, ranges::forward_range R2,
          class Pred = ranges::equal_to,
          class Proj1 = std::identity,
          class Proj2 = std::identity&gt;
requires std::indirectly_comparable&lt;ranges::iterator_t&lt;R1&gt;,
                                    ranges::iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
constexpr ranges::borrowed_subrange_t&lt;R1&gt;
    search( R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {}, Proj1 proj1 = {}, Proj2 proj2 = {} );
}}
{{dcl end}}

@1@ Searches for the ''first'' occurrence of the sequence of elements {{range|first2|last2}} in the range {{range|first1|last1}}. Elements are compared using binary predicate {{c|pred}} after being projected with {{c|proj2}} and {{c|proj1}}, respectively.

@2@ Same as {{v|1}}, but uses {{c|r1}} as the first source range and {{c|r2}} as the second source range, as if using {{c|ranges::begin(r1)}} as {{c|first1}}, {{c|ranges::end(r1)}} as {{c|last1}}, {{c|ranges::begin(r2)}} as {{c|first2}}, and {{c|ranges::end(r2)}} as {{c|last2}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first1, last1|the range of elements to examine (aka ''haystack'')}}
{{par|first2, last2|the range of elements to search for (aka ''needle'')}}
{{par|r1|the range of elements to examine (aka ''haystack'')}}
{{par|r2|the range of elements to search for (aka ''needle'')}}
{{par|pred|binary predicate to apply to the projected elements}}
{{par|proj1|projection to apply to the elements in the first range}}
{{par|proj2|projection to apply to the elements in the second range}}
{{par end}}

===Return value===
@1@ Returns a {{c|ranges::subrange}} value that is the first occurrence of the sequence {{range|first2|last2}} (aka ''needle'') in the range {{range|first1|last1}} (aka ''haystack''), after application of the projections {{c|proj1}} and {{c|proj2}} to the elements of both sequences respectively with consequencing application of the binary predicate {{c|pred}} to compare projected elements.
If no such occurrence is found, {{c|ranges::subrange{last1, last1} }} is returned.
If the range to search for (aka ''needle'') is empty, that is {{c|1=first2 == last2}}, then the {{c|ranges::subrange{first1, first1} }} is returned.
@2@ Same as {{v|1}} but the return type is {{c|ranges::borrowed_subrange_t&lt;R1&gt;}}.

===Complexity===
At most {{tt|S * N}} applications of the corresponding predicate and each projection, where &lt;br&gt;
{{v|1}} {{c|1=S = ranges::distance(first2, last2)}} and {{c|1=N = ranges::distance(first1, last1)}}; &lt;br&gt;
{{v|2}} {{c|1=S = ranges::distance(r2)}} and {{c|1=N = ranges::distance(r1)}}.

===Possible implementation===
{{eq fun| 1=
struct search_fn
{
    template&lt;std::forward_iterator I1, std::sentinel_for&lt;I1&gt; S1,
             std::forward_iterator I2, std::sentinel_for&lt;I2&gt; S2,
             class Pred = ranges::equal_to,
             class Proj1 = std::identity,
             class Proj2 = std::identity&gt;
    requires std::indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
    constexpr ranges::subrange&lt;I1&gt;
        operator()(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                   Proj1 proj1 = {}, Proj2 proj2 = {}) const
    {
        for (;; ++first1)
        {
            I1 it1 = first1;
            for (I2 it2 = first2;; ++it1, ++it2)
            {
                if (it2 == last2)
                    return {first1, it1};
                if (it1 == last1)
                    return {it1, it1};
                if (!std::invoke(pred, std::invoke(proj1, *it1), std::invoke(proj2, *it2)))
                    break;
            }
        }
    }

    template&lt;ranges::forward_range R1, ranges::forward_range R2,
             class Pred = ranges::equal_to,
             class Proj1 = std::identity,
             class Proj2 = std::identity&gt;
    requires std::indirectly_comparable&lt;ranges::iterator_t&lt;R1&gt;,
                                        ranges::iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
    constexpr ranges::borrowed_subrange_t&lt;R1&gt;
        operator()(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                   Proj1 proj1 = {}, Proj2 proj2 = {}) const
    {
        return (*this)(ranges::begin(r1), ranges::end(r1),
                       ranges::begin(r2), ranges::end(r2),
                       std::move(pred), std::move(proj1), std::move(proj2));
    }
};

inline constexpr search_fn search {};
}}

===Example===
{{example|code=
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string_view&gt;

using namespace std::literals;

void print(int id, const auto&amp; haystack, const auto&amp; needle, const auto&amp; found)
{
    std::cout &lt;&lt; id &lt;&lt; ") search(\"" &lt;&lt; haystack &lt;&lt; "\", \"" &lt;&lt; needle &lt;&lt; "\"); ";
    const auto first = std::distance(haystack.begin(), found.begin());
    const auto last = std::distance(haystack.begin(), found.end());
    if (found.empty())
        std::cout &lt;&lt; "not found;";
    else
    {
        std::cout &lt;&lt; "found: \"";
        for (const auto x : found)
            std::cout &lt;&lt; x;
        std::cout &lt;&lt; "\";";
    }
    std::cout &lt;&lt; " subrange: {" &lt;&lt; first &lt;&lt; ", " &lt;&lt; last &lt;&lt; "}\n";
}

int main()
{
    constexpr auto haystack {"abcd abcd"sv};
    constexpr auto needle {"bcd"sv};

    // the search uses iterator pairs begin()/end():
    constexpr auto found1 = std::ranges::search(
        haystack.begin(), haystack.end(),
        needle.begin(), needle.end());
    print(1, haystack, needle, found1);

    // the search uses ranges r1, r2:
    constexpr auto found2 = std::ranges::search(haystack, needle);
    print(2, haystack, needle, found2);

    // 'needle' range is empty:
    constexpr auto none {""sv};
    constexpr auto found3 = std::ranges::search(haystack, none);
    print(3, haystack, none, found3);

    // 'needle' will not be found:
    constexpr auto awl {"efg"sv};
    constexpr auto found4 = std::ranges::search(haystack, awl);
    print(4, haystack, awl, found4);

    // the search uses custom comparator and projections:
    constexpr auto bodkin {"234"sv};
    auto found5 = std::ranges::search(haystack, bodkin,
        [](const int x, const int y) { return x == y; }, // pred
        [](const int x) { return std::toupper(x); }, // proj1
        [](const int y) { return y + 'A' - '1'; }); // proj2
    print(5, haystack, bodkin, found5);
}
|output=
1) search("abcd abcd", "bcd"); found: "bcd"; subrange: {1, 4}
2) search("abcd abcd", "bcd"); found: "bcd"; subrange: {1, 4}
3) search("abcd abcd", ""); not found; subrange: {0, 0}
4) search("abcd abcd", "efg"); not found; subrange: {9, 9}
5) search("abcd abcd", "234"); found: "bcd"; subrange: {1, 4}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc adjacent_find}}
{{dsc inc|cpp/algorithm/ranges/dsc find}}
{{dsc inc|cpp/algorithm/ranges/dsc find_end}}
{{dsc inc|cpp/algorithm/ranges/dsc find_first_of}}
{{dsc inc|cpp/algorithm/ranges/dsc contains}}
{{dsc inc|cpp/algorithm/ranges/dsc includes}}
{{dsc inc|cpp/algorithm/ranges/dsc mismatch}}
{{dsc inc|cpp/algorithm/ranges/dsc search_n}}
{{dsc inc|cpp/algorithm/dsc search}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}