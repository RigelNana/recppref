{{cpp/ranges/title|fill_n}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl rev begin}}
{{dcl|since=c++20|until=c++26|
template&lt; class T, std::output_iterator&lt;const T&amp;&gt; O &gt;
constexpr O fill_n( O first, std::iter_difference_t&lt;O&gt; n, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class O, class T = std::iter_value_t&lt;O&gt; &gt;
requires std::output_iterator&lt;O, const T&amp;&gt;
constexpr O fill_n( O first, std::iter_difference_t&lt;O&gt; n, const T&amp; value );
}}
{{dcl rev end}}
{{dcl end}}

Assigns the given {{c|value}} to all elements in the range {{range|first|first + n}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first|the beginning of the range of elements to modify}}
{{par|n|number of elements to modify}}
{{par|value|the value to be assigned}}
{{par end}}

===Return value===
An output iterator that compares equal to {{c|first + n}}.

===Complexity===
Exactly {{c|n}} assignments.

===Possible implementation===
{{eq fun|1=
struct fill_n_fn
{
    template&lt;class O, class T = std::iter_value_t&lt;O&gt;&gt;
    requires std::output_iterator&lt;O, const T&amp;&gt;
    constexpr O operator()(O first, std::iter_difference_t&lt;O&gt; n, const T&amp; value) const
    {
        for (std::iter_difference_t&lt;O&gt; i {}; i != n; ++first, ++i)
            *first = value;
        return first;
    }
};

inline constexpr fill_n_fn fill_n {};
}}

===Notes===
{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

void println(const auto&amp; v)
{
    for (const auto&amp; elem : v)
        std::cout &lt;&lt; ' ' &lt;&lt; elem;
    std::cout &lt;&lt; '\n';
}

int main()
{
    constexpr auto n{8};
    
    std::vector&lt;std::string&gt; v(n, "▓▓░░");
    println(v);
    
    std::ranges::fill_n(v.begin(), n, "░░▓▓");
    println(v);

    std::vector&lt;std::complex&lt;double&gt;&gt; nums{&lt;!----&gt;{1, 3}, {2, 2}, {4, 8}&lt;!----&gt;};
    println(nums);
    #ifdef __cpp_lib_algorithm_default_value_type
        std::ranges::fill_n(nums.begin(), 2, {4, 2});
    #else
        std::ranges::fill_n(nums.begin(), 2, std::complex&lt;double&gt;{4, 2});
    #endif
    println(nums);
}
|output=&lt;nowiki/&gt;
 ▓▓░░ ▓▓░░ ▓▓░░ ▓▓░░ ▓▓░░ ▓▓░░ ▓▓░░ ▓▓░░
 ░░▓▓ ░░▓▓ ░░▓▓ ░░▓▓ ░░▓▓ ░░▓▓ ░░▓▓ ░░▓▓
 (1,3) (2,2) (4,8)
 (4,2) (4,2) (4,8)
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc fill}}
{{dsc inc|cpp/algorithm/ranges/dsc copy_n}}
{{dsc inc|cpp/algorithm/ranges/dsc generate}}
{{dsc inc|cpp/algorithm/ranges/dsc transform}}
{{dsc inc|cpp/numeric/random/ranges/dsc generate_random}}
{{dsc inc|cpp/algorithm/dsc fill_n}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}