{{cpp/ranges/title|for_each|for_each_result}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl|num=1|since=c++20|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
          std::indirectly_unary_invocable&lt;std::projected&lt;I, Proj&gt;&gt; Fun &gt;
constexpr for_each_result&lt;I, Fun&gt;
    for_each( I first, S last, Fun f, Proj proj = {} );
}}
{{dcl|num=2|since=c++20|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          std::indirectly_unary_invocable&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Fun &gt;
constexpr for_each_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, Fun&gt;
    for_each( R&amp;&amp; r, Fun f, Proj proj = {} );
}}
{{dcl h|Helper types}}
{{dcl|num=3|since=c++20|1=
template&lt; class I, class F &gt;
using for_each_result = ranges::in_fun_result&lt;I, F&gt;;
}}
{{dcl end}}

@1@ Applies the given function object {{c|f}} to the result of the value projected by each iterator in the range {{range|first|last}}, in order. 
@2@ Same as {{v|1}}, but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

For both overloads, if the iterator type is mutable, {{c|f}} may modify the elements of the range through the dereferenced iterator. If {{c|f}} returns a result, the result is ignored.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|iterator-sentinel pair denoting the range to apply the function to}}
{{par|r|the range of elements to apply the function to}}
{{par|f|the function to apply to the projected range}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
{{c|{std::ranges::next(std::move(first), last), std::move(f)} }}

===Complexity===
Exactly {{c|last - first}} applications of {{c|f}} and {{c|proj}}.

===Possible implementation===
{{eq fun|1=
struct for_each_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirectly_unary_invocable&lt;std::projected&lt;I, Proj&gt;&gt; Fun&gt;
    constexpr ranges::for_each_result&lt;I, Fun&gt;
        operator()(I first, S last, Fun f, Proj proj = {}) const
    {
        for (; first != last; ++first)
            std::invoke(f, std::invoke(proj, *first));
        return {std::move(first), std::move(f)};
    }
  
    template&lt;ranges::input_range R, class Proj = std::identity,
             std::indirectly_unary_invocable&lt;std::projected&lt;ranges::iterator_t&lt;R&gt;,
             Proj&gt;&gt; Fun&gt;
    constexpr ranges::for_each_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, Fun&gt;
        operator()(R&amp;&amp; r, Fun f, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(f), std::ref(proj));
    }
};

inline constexpr for_each_fn for_each;
}}

===Example===
{{example
|The following example uses a [[cpp/language/lambda|lambda expression]] to increment all of the elements of a vector and then uses an overloaded {{tt|operator()}} in a functor to compute their sum. Note that to compute the sum, it is recommended to use the dedicated algorithm {{lc|std::accumulate}}.
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

struct Sum
{
    void operator()(int n) { sum += n; }
    int sum {0};
};

int main()
{
    std::vector&lt;int&gt; nums {3, 4, 2, 8, 15, 267};

    auto print = [](const auto&amp; n) { std::cout &lt;&lt; ' ' &lt;&lt; n; };

    namespace ranges = std::ranges;
    std::cout &lt;&lt; "before:";
    ranges::for_each(std::as_const(nums), print);
    print('\n');

    ranges::for_each(nums, [](int&amp; n) { ++n; });

    // calls Sum::operator() for each number
    auto [i, s] = ranges::for_each(nums.begin(), nums.end(), Sum());
    assert(i == nums.end());

    std::cout &lt;&lt; "after: ";
    ranges::for_each(nums.cbegin(), nums.cend(), print);

    std::cout &lt;&lt; "\n" "sum: " &lt;&lt; s.sum &lt;&lt; '\n';

    using pair = std::pair&lt;int, std::string&gt;; 
    std::vector&lt;pair&gt; pairs {{1,"one"}, {2,"two"}, {3,"tree"}};

    std::cout &lt;&lt; "project the pair::first: ";
    ranges::for_each(pairs, print, [](const pair&amp; p) { return p.first; });

    std::cout &lt;&lt; "\n" "project the pair::second:";
    ranges::for_each(pairs, print, &amp;pair::second);
    print('\n');
}
|output=
before: 3 4 2 8 15 267 
after:  4 5 3 9 16 268
sum: 305
project the pair::first:  1 2 3
project the pair::second: one two tree
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc range-for}}
{{dsc inc|cpp/algorithm/ranges/dsc transform}}
{{dsc inc|cpp/algorithm/ranges/dsc for_each_n}}
{{dsc inc|cpp/algorithm/dsc for_each}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}