{{cpp/ranges/title|unique}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl|num=1|since=c++20|1=
template&lt; std::permutable I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
          std::indirect_equivalence_relation&lt;std::projected&lt;I, Proj&gt;&gt;
              C = ranges::equal_to &gt;
constexpr ranges::subrange&lt;I&gt;
    unique( I first, S last, C comp = {}, Proj proj = {} );
}}
{{dcl|num=2|since=c++20|1=
template&lt; ranges::forward_range R, class Proj = std::identity,
          std::indirect_equivalence_relation&lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt;
              C = ranges::equal_to &gt;
requires std::permutable&lt;ranges::iterator_t&lt;R&gt;&gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    unique( R&amp;&amp; r, C comp = {}, Proj proj = {} );
}}
{{dcl end}}

@1@ Eliminates all except the first element from every consecutive group of equivalent elements from the range {{range|first|last}} and returns a subrange {{range|ret|last}}, where {{tt|ret}} is a past-the-end iterator for the new end of the range.

@@ Two consecutive elements {{tt|*(i - 1)}} and {{tt|*i}} are considered equivalent if {{c|1=std::invoke(comp, std::invoke(proj, *(i - 1)), std::invoke(proj, *i)) == true}}, where {{tt|i}} is an iterator in the range {{range|first + 1|last}}.

@2@ Same as {{v|1}}, but uses {{c|r}} as the range, as if using {{c|ranges::begin(r)}} as {{c|first}}, and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to process}}
{{par|r|the range of elements to process}}
{{par|comp|the binary predicate to compare the projected elements}}
{{par|proj|the projection to apply to the elements}}
{{par end}}

===Return value===
Returns {{c|{ret, last} }}, where {{tt|ret}} is a past-the-end iterator for the new end of the range.

===Complexity===
For nonempty ranges, exactly {{c|ranges::distance(first, last) - 1}} applications of the corresponding predicate {{c|comp}} and no more that twice as many applications of any projection {{c|proj}}.

===Notes===
Removing is done by shifting (by means of move assignment) the elements in the range in such a way that the elements that are not to be removed appear in the beginning of the range. Relative order of the elements that remain is preserved and the ''physical'' size of the container is unchanged. Iterators in {{range|ret|last}} (if any) are still dereferenceable, but the elements themselves have unspecified values (as per {{named req|MoveAssignable}} post-condition).

A call to {{tt|ranges::unique}} is sometimes followed by a call to a container’s {{tt|erase}} member function, which erases the unspecified values and reduces the ''physical'' size of the container to match its new ''logical'' size. These two invocations together model the [[enwiki:Erase-remove_idiom|''Erase–remove'' idiom]].

===Possible implementation===
{{eq fun|1=
struct unique_fn
{
    template&lt;std::permutable I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirect_equivalence_relation&lt;std::projected&lt;I, Proj&gt;&gt;
                 C = ranges::equal_to&gt;
    constexpr ranges::subrange&lt;I&gt;
        operator()(I first, S last, C comp = {}, Proj proj = {}) const
    {
        first = ranges::adjacent_find(first, last, comp, proj);
        if (first == last)
            return {first, first};
        auto i {first};
        ++first;
        while (++first != last)
            if (!std::invoke(comp, std::invoke(proj, *i), std::invoke(proj, *first)))
                *++i = ranges::iter_move(first);
        return {++i, first};
    }

    template&lt;ranges::forward_range R, class Proj = std::identity,
             std::indirect_equivalence_relation&lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt;
                 C = ranges::equal_to&gt;
    requires std::permutable&lt;ranges::iterator_t&lt;R&gt;&gt;
    constexpr ranges::borrowed_subrange_t&lt;R&gt;
        operator()(R&amp;&amp; r, C comp = {}, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r),
                       std::move(comp), std::move(proj));
    }
};

inline constexpr unique_fn unique {};
}}

===Example===
{{example|code=
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct id {
    int i;
    explicit id(int i) : i {i} {}
};

void print(id i, const auto&amp; v)
{
    std::cout &lt;&lt; i.i &lt;&lt; ") ";
    std::ranges::for_each(v, [](auto const&amp; e) { std::cout &lt;&lt; e &lt;&lt; ' '; });
    std::cout &lt;&lt; '\n';
}

int main()
{
    // a vector containing several duplicated elements
    std::vector&lt;int&gt; v {1, 2, 1, 1, 3, 3, 3, 4, 5, 4};

    print(id {1}, v);

    // remove consecutive (adjacent) duplicates
    const auto ret = std::ranges::unique(v);
    // v now holds {1 2 1 3 4 5 4 x x x}, where 'x' is indeterminate
    v.erase(ret.begin(), ret.end());
    print(id {2}, v);

    // sort followed by unique, to remove all duplicates
    std::ranges::sort(v); // {1 1 2 3 4 4 5}
    print(id {3}, v);

    const auto [first, last] = std::ranges::unique(v.begin(), v.end());
    // v now holds {1 2 3 4 5 x x}, where 'x' is indeterminate
    v.erase(first, last);
    print(id {4}, v);

    // unique with custom comparison and projection
    std::vector&lt;std::complex&lt;int&gt;&gt; vc { {1, 1}, {-1, 2}, {-2, 3}, {2, 4}, {-3, 5} };
    print(id {5}, vc);

    const auto ret2 = std::ranges::unique(vc,
        // consider two complex nums equal if their real parts are equal by module:
        [](int x, int y) { return std::abs(x) == std::abs(y); }, // comp
        [](std::complex&lt;int&gt; z) { return z.real(); }             // proj
    );
    vc.erase(ret2.begin(), ret2.end());
    print(id {6}, vc);
}
|output=
1) 1 2 1 1 3 3 3 4 5 4
2) 1 2 1 3 4 5 4
3) 1 1 2 3 4 4 5
4) 1 2 3 4 5
5) (1,1) (-1,2) (-2,3) (2,4) (-3,5)
6) (1,1) (-2,3) (-3,5)
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc unique_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc adjacent_find}}
{{dsc inc|cpp/algorithm/ranges/dsc remove}}
{{dsc inc|cpp/algorithm/dsc unique}}
{{dsc inc|cpp/container/dsc unique|list}}
{{dsc inc|cpp/container/dsc unique|forward_list}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}