{{cpp/ranges/title|search_n}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl rev begin|num=1}}
{{dcl|since=c++20|until=c++26|1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S, class T,
          class Pred = ranges::equal_to, class Proj = std::identity &gt;
requires std::indirectly_comparable&lt;I, const T*, Pred, Proj&gt;
constexpr ranges::subrange&lt;I&gt;
    search_n( I first, S last, std::iter_difference_t&lt;I&gt; count,
              const T&amp; value, Pred pred = {}, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
          class Pred = ranges::equal_to, class Proj = std::identity,
          class T = std::projected_value_t&lt;I, Proj&gt; &gt;
requires std::indirectly_comparable&lt;I, const T*, Pred, Proj&gt;
constexpr ranges::subrange&lt;I&gt;
    search_n( I first, S last, std::iter_difference_t&lt;I&gt; count,
              const T&amp; value, Pred pred = {}, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::forward_range R, class T,
          class Pred = ranges::equal_to, class Proj = std::identity &gt;
requires std::indirectly_comparable
    &lt;ranges::iterator_t&lt;R&gt;, const T*, Pred, Proj&gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    search_n( R&amp;&amp; r, ranges::range_difference_t&lt;R&gt; count,
              const T&amp; value, Pred pred = {}, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::forward_range R,
          class Pred = ranges::equal_to, class Proj = std::identity,
          class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt; &gt;
requires std::indirectly_comparable
    &lt;ranges::iterator_t&lt;R&gt;, const T*, Pred, Proj&gt;
constexpr ranges::borrowed_subrange_t&lt;R&gt;
    search_n( R&amp;&amp; r, ranges::range_difference_t&lt;R&gt; count,
              const T&amp; value, Pred pred = {}, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl end}}

@1@ Searches the range {{range|first|last}} for the ''first'' sequence of {{c|count}} elements whose projected values are each equal to the given {{c|value}} according to the binary predicate {{c|pred}}.
@2@ Same as {{v|1}}, but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to examine (aka ''haystack'')}}
{{par|r|the range of elements to examine (aka ''haystack'')}}
{{par|count|the length of the sequence to search for}}
{{par|value|the value to search for (aka ''needle'')}}
{{par|pred|the binary predicate that compares the projected elements with {{c|value}}}}
{{par|proj|the projection to apply to the elements of the range to examine}}
{{par end}}

===Return value===
@1@ Returns {{c|std::ranges::subrange}} object that contains a pair of iterators in the range {{range|first|last}} that designate the found subsequence.
If no such subsequence is found, returns {{c|std::ranges::subrange{last, last} }}.
If {{c|1=count &lt;= 0}}, returns {{c|std::ranges::subrange{first, first} }}.
@2@ Same as {{v|1}} but the return type is {{c|ranges::borrowed_subrange_t&lt;R&gt;}}.

===Complexity===
Linear: at most {{c|ranges::distance(first, last)}} applications of the predicate and the projection.

===Notes===
An implementation can improve efficiency of the search ''in average'' if the iterators model {{c|std::random_access_iterator}}.

{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms}}

===Possible implementation===
{{eq fun|1=
struct search_n_fn
{
    template&lt;std::forward_iterator I, std::sentinel_for&lt;I&gt; S,
             class Pred = ranges::equal_to, class Proj = std::identity,
             class T = std::projected_value_t&lt;I, Proj&gt;&gt;
    requires std::indirectly_comparable&lt;I, const T*, Pred, Proj&gt;
    constexpr ranges::subrange&lt;I&gt;
        operator()(I first, S last, std::iter_difference_t&lt;I&gt; count,
                   const T&amp; value, Pred pred = {}, Proj proj = {}) const
    {
        if (count &lt;= 0)
            return {first, first};
        for (; first != last; ++first)
            if (std::invoke(pred, std::invoke(proj, *first), value))
            {
                I start = first;
                std::iter_difference_t&lt;I&gt; n{1};
                for (;;)
                {
                    if (n++ == count)
                        return {start, std::next(first)}; // found
                    if (++first == last)
                        return {first, first}; // not found
                    if (!std::invoke(pred, std::invoke(proj, *first), value))
                        break; // not equ to value
                }
            }
        return {first, first};
    }
    
    template&lt;ranges::forward_range R,
             class Pred = ranges::equal_to, class Proj = std::identity,
             class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt;
    requires std::indirectly_comparable&lt;ranges::iterator_t&lt;R&gt;, const T*, Pred, Proj&gt;
    constexpr ranges::borrowed_subrange_t&lt;R&gt;
        operator()(R&amp;&amp; r, ranges::range_difference_t&lt;R&gt; count,
                   const T&amp; value, Pred pred = {}, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r),
                       std::move(count), value,
                       std::move(pred), std::move(proj));
    }
};

inline constexpr search_n_fn search_n {};
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main()
{
    namespace ranges = std::ranges;

    static constexpr auto nums = {1, 2, 2, 3, 4, 1, 2, 2, 2, 1};
    constexpr int count{3};
    constexpr int value{2};
    typedef int count_t, value_t;
    
    constexpr auto result1 = ranges::search_n
    (
        nums.begin(), nums.end(), count, value
    );
    static_assert // found
    (
        result1.size() == count &amp;&amp;
        std::distance(nums.begin(), result1.begin()) == 6 &amp;&amp;
        std::distance(nums.begin(), result1.end()) == 9
    );
    
    constexpr auto result2 = ranges::search_n(nums, count, value);
    static_assert // found
    (
        result2.size() == count &amp;&amp;
        std::distance(nums.begin(), result2.begin()) == 6 &amp;&amp;
        std::distance(nums.begin(), result2.end()) == 9
    );
    
    constexpr auto result3 = ranges::search_n(nums, count, value_t{5});
    static_assert // not found
    (
        result3.size() == 0 &amp;&amp;
        result3.begin() == result3.end() &amp;&amp;
        result3.end() == nums.end()
    );
    
    constexpr auto result4 = ranges::search_n(nums, count_t{0}, value_t{1});
    static_assert // not found
    (
        result4.size() == 0 &amp;&amp;
        result4.begin() == result4.end() &amp;&amp;
        result4.end() == nums.begin()
    );
    
    constexpr char symbol{'B'};
    auto to_ascii = [](const int z) -&gt; char { return 'A' + z - 1; };
    auto is_equ = [](const char x, const char y) { return x == y; };
    
    std::cout &lt;&lt; "Find a sub-sequence " &lt;&lt; std::string(count, symbol) &lt;&lt; " in the ";
    std::ranges::transform(nums, std::ostream_iterator&lt;char&gt;(std::cout, ""), to_ascii);
    std::cout &lt;&lt; '\n';
    
    auto result5 = ranges::search_n(nums, count, symbol, is_equ, to_ascii);
    if (not result5.empty())
        std::cout &lt;&lt; "Found at position "
                  &lt;&lt; ranges::distance(nums.begin(), result5.begin()) &lt;&lt; '\n';

    std::vector&lt;std::complex&lt;double&gt;&gt; nums2{&lt;!----&gt;{4, 2}, {4, 2}, {1, 3}&lt;!----&gt;};
    #ifdef __cpp_lib_algorithm_default_value_type
        auto it = ranges::search_n(nums2, 2, {4, 2});
    #else
        auto it = ranges::search_n(nums2, 2, std::complex&lt;double&gt;{4, 2});
    #endif
    assert(it.size() == 2);
}
|output=
Find a sub-sequence BBB in the ABBCDABBBA
Found at position 6
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc adjacent_find}}
{{dsc inc|cpp/algorithm/ranges/dsc find}}
{{dsc inc|cpp/algorithm/ranges/dsc find_end}}
{{dsc inc|cpp/algorithm/ranges/dsc find_first_of}}
{{dsc inc|cpp/algorithm/ranges/dsc includes}}
{{dsc inc|cpp/algorithm/ranges/dsc mismatch}}
{{dsc inc|cpp/algorithm/ranges/dsc search}}
{{dsc inc|cpp/algorithm/dsc search_n}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}