{{cpp/ranges/title|stable_sort}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcla|anchor=no|num=1|since=c++20|constexpr=c++26|1=
template&lt; std::random_access_iterator I, std::sentinel_for&lt;I&gt; S,
          class Comp = ranges::less, class Proj = std::identity &gt;
requires std::sortable&lt;I, Comp, Proj&gt;
    I stable_sort( I first, S last, Comp comp = {}, Proj proj = {} );
}}
{{dcla|anchor=no|num=2|since=c++20|constexpr=c++26|1=
template&lt; ranges::random_access_range R, class Comp = ranges::less,
          class Proj = std::identity &gt;
requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
ranges::borrowed_iterator_t&lt;R&gt;
    stable_sort( R&amp;&amp; r, Comp comp = {}, Proj proj = {} );
}}
{{dcl end}}

Sorts the elements in the range {{range|first|last}} in non-descending order. The order of equivalent elements is ''stable'', i.e. guaranteed to be preserved.

A sequence is sorted with respect to a comparator {{c|comp}} if for any iterator {{tt|it}} pointing to the sequence and any non-negative integer {{tt|n}} such that {{tt|it + n}} is a valid iterator pointing to an element of the sequence, {{c|std::invoke(comp, std::invoke(proj, *(it + n)), std::invoke(proj, *it)}} evaluates to {{c|false}}.

@1@ Elements are compared using the given binary comparison function {{c|comp}}.
@2@ Same as {{v|1}}, but uses {{c|r}} as the range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|iterator-sentinel defining the range to sort}}
{{par|r|the range to sort}}
{{par|comp|comparison to apply to the projected elements}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
An iterator equal to {{c|last}}.

===Complexity===
{{mathjax-or|\(\scriptsize N\cdot\log{(N)}\)|N&amp;middot;log(N)}} comparisons, if extra memory is available; where {{mathjax-or|\(\scriptsize N\)|N}} is {{c|ranges::distance(first, last)}}. {{mathjax-or|\(\scriptsize N\cdot\log^2{(N)}\)|N&amp;middot;log&amp;sup2;(N)}} comparisons otherwise. Twice as many projections as the number of comparisons in both cases.

===Notes===
{{feature test macro|__cpp_lib_constexpr_algorithms|{{c/core|constexpr}} stable sorting|value=202306L|std=C++26}}

===Possible implementation===
This implementation only shows the slower algorithm used when no additional memory is available. See also implementation in [https://github.com/microsoft/STL/blob/e745bad3b1d05b5b19ec652d68abb37865ffa454/stl/inc/algorithm#L7842-L8094 MSVC STL] and [https://github.com/gcc-mirror/gcc/blob/54258e22b0846aaa6bd3265f592feb161eecda75/libstdc%2B%2B-v3/include/bits/ranges_algo.h#L1836-L1862 libstdc++].
{{eq fun|1=
struct stable_sort_fn
{
    template&lt;std::random_access_iterator I, std::sentinel_for&lt;I&gt; S,
             class Comp = ranges::less, class Proj = std::identity&gt;
    requires std::sortable&lt;I, Comp, Proj&gt;
    constexpr //&lt; since C++26
    I operator()(I first, S last, Comp comp = {}, Proj proj = {}) const
    {
        auto count = ranges::distance(first, last);
        auto mid = first + count / 2;
        auto last_it = first + count;

        if (count &lt;= 1)
            return last_it;

        (*this)(first, mid, std::ref(comp), std::ref(proj));
        (*this)(mid, last_it, std::ref(comp), std::ref(proj));

        ranges::inplace_merge(first, mid, last_it);

        return last_it;
    }

    template&lt;ranges::random_access_range R, class Comp = ranges::less,
             class Proj = std::identity&gt;
    requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
    constexpr //&lt; since C++26
    ranges::borrowed_iterator_t&lt;R&gt; operator()(R&amp;&amp; r, Comp comp = {}, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(comp), std::move(proj));
    }
};

inline constexpr stable_sort_fn stable_sort {};
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;

void print(auto const&amp; seq)
{
    for (auto const&amp; elem : seq)
        std::cout &lt;&lt; elem &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

struct Particle
{
    std::string name; double mass; // MeV
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Particle const&amp; p)
    {
        return os &lt;&lt; '\n' &lt;&lt; std::left &lt;&lt; std::setw(8) &lt;&lt; p.name &lt;&lt; " : " &lt;&lt; p.mass;
    }
};

int main()
{
    std::array s {5, 7, 4, 2, 8, 6, 1, 9, 0, 3};

    // sort using the default operator&lt;
    std::ranges::stable_sort(s);
    print(s);

    // sort using a standard library compare function object
    std::ranges::stable_sort(s, std::ranges::greater());
    print(s);

    // sort using a custom function object
    struct
    {
        bool operator()(int a, int b) const
        {
            return a &lt; b;
        }
    } customLess;
    std::ranges::stable_sort(s.begin(), s.end(), customLess);
    print(s);

    // sort using a lambda expression
    std::ranges::stable_sort(s, [](int a, int b) { return a &gt; b; });
    print(s);

    // sort with projection
    Particle particles[]
    {
        {"Electron", 0.511}, {"Muon", 105.66}, {"Tau", 1776.86},
        {"Positron", 0.511}, {"Proton", 938.27}, {"Neutron", 939.57}
    };
    print(particles);
    std::ranges::stable_sort(particles, {}, &amp;Particle::name); //&lt; sort by name
    print(particles);
    std::ranges::stable_sort(particles, {}, &amp;Particle::mass); //&lt; sort by mass
    print(particles);
}
|output=
0 1 2 3 4 5 6 7 8 9
9 8 7 6 5 4 3 2 1 0
0 1 2 3 4 5 6 7 8 9
9 8 7 6 5 4 3 2 1 0

Electron : 0.511
Muon     : 105.66
Tau      : 1776.86
Positron : 0.511
Proton   : 938.27
Neutron  : 939.57

Electron : 0.511
Muon     : 105.66
Neutron  : 939.57
Positron : 0.511
Proton   : 938.27
Tau      : 1776.86

Electron : 0.511
Positron : 0.511
Muon     : 105.66
Proton   : 938.27
Neutron  : 939.57
Tau      : 1776.86
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc sort}}
{{dsc inc|cpp/algorithm/ranges/dsc partial_sort}}
{{dsc inc|cpp/algorithm/ranges/dsc stable_partition}}
{{dsc inc|cpp/algorithm/dsc stable_sort}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}