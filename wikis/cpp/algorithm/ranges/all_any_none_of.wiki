{{cpp/ranges/title|all_of|any_of|none_of}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcla|since=c++20|num=1|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr bool all_of( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++20|num=2|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;,Proj&gt;&gt; Pred &gt;
constexpr bool all_of( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcla|since=c++20|num=3|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr bool any_of( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++20|num=4|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;,Proj&gt;&gt; Pred &gt;
constexpr bool any_of( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcla|since=c++20|num=5|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr bool none_of( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++20|num=6|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;,Proj&gt;&gt; Pred &gt;
constexpr bool none_of( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcl end}}

@1@ Checks if unary predicate {{c|pred}} returns {{c|false}} for at least one element in the range {{range|first|last}} (after projecting with the projection {{c|proj}}).

@3@ Checks if unary predicate {{c|pred}} returns {{c|true}} for at least one element in the range {{range|first|last}} (after projecting with the projection {{c|proj}}).

@5@ Checks if unary predicate {{c|pred}} returns {{c|true}} for none of the elements in the range {{range|first|last}} (after projecting with the projection {{c|proj}}).

@2,4,6@ Same as {{v|1,3,5}}, but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|the range of the elements to examine}}
{{par|r|the range of the elements to examine}}
{{par|pred|predicate to apply to the projected elements}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
@1,2@ {{c|true}} if {{c|1=std::invoke(pred, std::invoke(proj, *i)) != false}} for every iterator {{c|i}} in the range, {{c|false}} otherwise. Returns {{c|true}} if the range is empty.

@3,4@ {{c|true}} if {{c|1=std::invoke(pred, std::invoke(proj, *i)) != false}} for at least one iterator {{c|i}} in the range, {{c|false}} otherwise. Returns {{c|false}} if the range is empty.

@5,6@ {{c|true}} if {{c|1=std::invoke(pred, std::invoke(proj, *i)) == false}} for every iterator {{c|i}} in the range, {{c|false}} otherwise. Returns {{c|true}} if the range is empty.

{{cpp/algorithm/truth table all any none}}

===Complexity===
At most {{c|last - first}} applications of the predicate and the projection.

===Possible implementation===
{{eq impl
|title1=all_of (1,2)|ver1=1|1=
struct all_of_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        return ranges::find_if_not(first, last, std::ref(pred), std::ref(proj)) == last;
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity,
             std::indirect_unary_predicate&lt;
                 std::projected&lt;ranges::iterator_t&lt;R&gt;,Proj&gt;&gt; Pred&gt;
    constexpr bool operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return operator()(ranges::begin(r), ranges::end(r),
                          std::ref(pred), std::ref(proj));
    }
};

inline constexpr all_of_fn all_of;
|title2=any_of (3,4)|ver2=3|2=
struct any_of_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        return ranges::find_if(first, last, std::ref(pred), std::ref(proj)) != last;
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity,
             std::indirect_unary_predicate&lt;
                 std::projected&lt;ranges::iterator_t&lt;R&gt;,Proj&gt;&gt; Pred&gt;
    constexpr bool operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return operator()(ranges::begin(r), ranges::end(r),
                          std::ref(pred), std::ref(proj));
    }
};

inline constexpr any_of_fn any_of;
|title3=none_of (5,6)|ver3=5|3=
struct none_of_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr bool operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        return ranges::find_if(first, last, std::ref(pred), std::ref(proj)) == last;
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity,
             std::indirect_unary_predicate&lt;
                 std::projected&lt;ranges::iterator_t&lt;R&gt;,Proj&gt;&gt; Pred&gt;
    constexpr bool operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return operator()(ranges::begin(r), ranges::end(r),
                          std::ref(pred), std::ref(proj));
    }
};

inline constexpr none_of_fn none_of;
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

namespace ranges = std::ranges;

constexpr bool some_of(auto&amp;&amp; r, auto&amp;&amp; pred) // some but not all
{
    return not (ranges::all_of(r, pred) or ranges::none_of(r, pred));
}

constexpr auto w = {1, 2, 3};
static_assert(!some_of(w, [](int x) { return x &lt; 1; }));
static_assert( some_of(w, [](int x) { return x &lt; 2; }));
static_assert(!some_of(w, [](int x) { return x &lt; 4; }));

int main()
{
    std::vector&lt;int&gt; v(10, 2);
    std::partial_sum(v.cbegin(), v.cend(), v.begin());
    std::cout &lt;&lt; "Among the numbers: ";
    ranges::copy(v, std::ostream_iterator&lt;int&gt;(std::cout, " "));
    std::cout &lt;&lt; '\n';
    
    if (ranges::all_of(v.cbegin(), v.cend(), [](int i) { return i % 2 == 0; }))
        std::cout &lt;&lt; "All numbers are even\n";
    
    if (ranges::none_of(v, std::bind(std::modulus&lt;int&gt;(), std::placeholders::_1, 2)))
        std::cout &lt;&lt; "None of them are odd\n";
    
    auto DivisibleBy = [](int d)
    {
        return [d](int m) { return m % d == 0; };
    };
    
    if (ranges::any_of(v, DivisibleBy(7)))
        std::cout &lt;&lt; "At least one number is divisible by 7\n";
}
|output=
Among the numbers: 2 4 6 8 10 12 14 16 18 20
All numbers are even
None of them are odd
At least one number is divisible by 7
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc all_any_none_of}}
{{dsc end}}

{{langlinks|es|ja|zh}}