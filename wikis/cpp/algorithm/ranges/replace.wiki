{{cpp/ranges/title|replace|replace_if}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl rev begin|num=1}}
{{dcla|anchor=1|since=c++20|until=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class T1, class T2, class Proj = std::identity &gt;
requires std::indirectly_writable&lt;I, const T2&amp;&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T1*&gt;
constexpr I replace( I first, S last, const T1&amp; old_value,
                     const T2&amp; new_value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          class T1 = std::projected_value_t&lt;I, Proj&gt;, class T2 = T1 &gt;
requires std::indirectly_writable&lt;I, const T2&amp;&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T1*&gt;
constexpr I replace( I first, S last, const T1&amp; old_value,
                     const T2&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::input_range R,
          class T1, class T2, class Proj = std::identity &gt;
requires std::indirectly_writable&lt;ranges::iterator_t&lt;R&gt;, const T2&amp;&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    replace( R&amp;&amp; r, const T1&amp; old_value,
             const T2&amp; new_value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::input_range R,
          class Proj = std::identity,
          class T1 = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
          class T2 = T1 &gt;
requires std::indirectly_writable&lt;ranges::iterator_t&lt;R&gt;, const T2&amp;&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    replace( R&amp;&amp; r, const T1&amp; old_value,
             const T2&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=3}}
{{dcla|anchor=3|since=c++20|until=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class T, class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
requires std::indirectly_writable&lt;I, const T&amp;&gt;
constexpr I replace_if( I first, S last, Pred pred,
                        const T&amp; new_value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;I, Proj&gt;,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
requires std::indirectly_writable&lt;I, const T&amp;&gt;
constexpr I replace_if( I first, S last, Pred pred,
                        const T&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=4}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::input_range R, class T, class Proj = std::identity,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
requires std::indirectly_writable&lt;ranges::iterator_t&lt;R&gt;, const T&amp;&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    replace_if( R&amp;&amp; r, Pred pred, const T&amp; new_value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
requires std::indirectly_writable&lt;ranges::iterator_t&lt;R&gt;, const T&amp;&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    replace_if( R&amp;&amp; r, Pred pred, const T&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl end}}

Replaces all elements satisfying specific criteria with {{c|new_value}} in the range {{range|first|last}}.

@1@ Replaces all elements that are equal to {{c|old_value}}, using {{c|1=std::invoke(proj, *i) == old_value}} to compare.
@3@ Replaces all elements for which the predicate {{c|pred}} evaluates to {{c|true}}, where evaluating expression is {{c|std::invoke(pred, std::invoke(proj, *i))}}.
@2,4@ Same as {{v|1,3}}, but uses {{c|r}} as the range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}

{{par|first, last|the range of elements to process}}
{{par|r|the range of elements to process}}
{{par|old_value|the value of elements to replace}}
{{par|new_value|the value to use as a replacement}}
{{par|pred|predicate to apply to the projected elements}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
An iterator equal to {{c|last}}.

===Complexity===
Exactly {{c|ranges::distance(first, last)}} applications of the corresponding predicate {{c|comp}} and any projection {{c|proj}}.

===Notes===
Because the algorithm takes {{c|old_value}} and {{c|new_value}} by reference, it may have unexpected behavior if either is a reference to an element of the range {{range|first|last}}.

{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms {{vl|1-4}}}}

===Possible implementation===
{{eq impl|
|title1=replace|ver1=1|1=
struct replace_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             class T1 = std::projected_value_t&lt;I, Proj&gt;, class T2 = T1&gt;
    requires std::indirectly_writable&lt;I, const T2&amp;&gt; &amp;&amp; 
             std::indirect_binary_predicate
                 &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T1*&gt;
    constexpr I operator()(I first, S last, const T1&amp; old_value,
                           const T2&amp; new_value, Proj proj = {}) const
    {
        for (; first != last; ++first)
            if (old_value == std::invoke(proj, *first))
                *first = new_value;
        return first;
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity
             class T1 = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
             class T2 = T1&gt;
    requires std::indirectly_writable&lt;ranges::iterator_t&lt;R&gt;, const T2&amp;&gt; &amp;&amp;
             std::indirect_binary_predicate&lt;ranges::equal_to,
             std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, const T1&amp; old_value,
                   const T2&amp; new_value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), old_value,
                       new_value, std::move(proj));
    }
};

inline constexpr replace_fn replace {};
|title2=replace_if|ver2=3|2=
struct replace_if_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity, class T = std::projected_value_t&lt;I, Proj&gt;,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires std::indirectly_writable&lt;I, const T&amp;&gt;
    constexpr I operator()(I first, S last, Pred pred,
                           const T&amp; new_value, Proj proj = {}) const
    {
        for (; first != last; ++first)
            if (!!std::invoke(pred, std::invoke(proj, *first)))
                *first = new_value;
        return std::move(first);
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity,
             class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;
             std::indirect_unary_predicate
                 &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires std::indirectly_writable&lt;ranges::iterator_t&lt;R&gt;, const T&amp;&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, Pred pred, const T&amp; new_value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(pred),
                       new_value, std::move(proj));
    }
};

inline constexpr replace_if_fn replace_if {};
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;

void println(const auto&amp; v)
{
    for (const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    namespace ranges = std::ranges;

    std::array p{1, 6, 1, 6, 1, 6};
    println(p);
    ranges::replace(p, 6, 9);
    println(p);
    
    std::array q{1, 2, 3, 6, 7, 8, 4, 5};
    println(q);
    ranges::replace_if(q, [](int x) { return 5 &lt; x; }, 5);
    println(q);

    std::array&lt;std::complex&lt;double&gt;, 2&gt; nums{&lt;!----&gt;{&lt;!----&gt;{1, 3}, {1, 3}&lt;!----&gt;}&lt;!----&gt;};
    println(nums);
    #ifdef __cpp_lib_algorithm_default_value_type
        ranges::replace(nums, {1, 3}, {4, 2});
    #else
        ranges::replace(nums, std::complex&lt;double&gt;{1, 3}, std::complex&lt;double&gt;{4, 2});
    #endif
    println(nums);
}
|output=
1 6 1 6 1 6
1 9 1 9 1 9
1 2 3 6 7 8 4 5
1 2 3 5 5 5 4 5
(1,3) (1,3)
(4,2) (4,2)
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc replace_copy}}
{{dsc inc|cpp/algorithm/dsc replace}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}