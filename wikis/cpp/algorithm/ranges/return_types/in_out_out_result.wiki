{{cpp/ranges/title|in_out_out_result}}
{{cpp/algorithm/ranges/return_types/navbar}}

{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|since=c++20|1=
template&lt; class I, class O1, class O2 &gt;
struct in_out_out_result;
}}
{{dcl end}}

{{tt|ranges::in_out_out_result}} is a class template that provides a way to store three iterators as a single unit.

{{cpp/algorithm/ranges/return_types/general_description}}

===Template parameters===
{{par begin}}
{{par|I, O1, O2|the types of the objects that the {{tt|ranges::in_out_out_result}} stores.}}
{{par end}}

===Data members===
{{dsc begin}}
{{dsc hitem|Member name|Definition}}
{{dsc mem obj|in|nolink=true|a value (that is supposed to be an iterator) of type {{tt|I}}.}}
{{dsc mem obj|out1|nolink=true|a value (that is supposed to be an iterator) of type {{tt|O1}}.}}
{{dsc mem obj|out2|nolink=true|a value (that is supposed to be an iterator) of type {{tt|O2}}.}}
{{dsc end}}

All these members are declared with {{attr|no_unique_address}} attribute.

===Member functions===
{{member|{{small|std::ranges::in_out_out_result::}}operator in_out_out_result&lt;II, OO1, OO2&gt;|2=
{{dcl begin}}
{{dcl|num=1 |1=
template&lt;class II, class OO1, class OO2&gt;
requires std::convertible_to&lt;const I&amp;, II&gt; &amp;&amp;
         std::convertible_to&lt;const O1&amp;, OO1&gt; &amp;&amp;
         std::convertible_to&lt;const O2&amp;, OO2&gt;
constexpr operator in_out_out_result&lt;II, OO1, OO2&gt;() const &amp;;
}}
{{dcl|num=2|1=
template&lt;class II, class OO1, class OO2&gt;
requires std::convertible_to&lt;I, II&gt; &amp;&amp;
         std::convertible_to&lt;O1, OO1&gt; &amp;&amp;
         std::convertible_to&lt;O2, OO2&gt;
constexpr operator in_out_out_result&lt;II, OO1, OO2&gt;() &amp;&amp;;
}}
{{dcl end}}
Converts {{c|*this}} to the result by constructing every data member of the result from the corresponding member of {{c|*this}}.
@1@ Equivalent to {{c|return {in, out1, out2};}}.
@2@ Equivalent to {{c|return {std::move(in), std::move(out1), std::move(out2)};}}.
}}

===Standard library===
The following standard library functions use {{tt|ranges::in_out_out_result}} as the return type:

{{dsc begin}}
{{dsc h2|Algorithm functions}}
{{dsc inc|cpp/algorithm/ranges/dsc partition_copy}}
{{dsc end}}

=== Synopsis ===
{{source|1=
namespace std::ranges
{
    template&lt;class I, class O1, class O2&gt;
    struct in_out_out_result
    {
        [[no_unique_address]] I  in;
        [[no_unique_address]] O1 out1;
        [[no_unique_address]] O2 out2;
      
        template&lt;class II, class OO1, class OO2&gt;
        requires std::convertible_to&lt;const I&amp;, II&gt; &amp;&amp;
                 std::convertible_to&lt;const O1&amp;, OO1&gt; &amp;&amp;
                 std::convertible_to&lt;const O2&amp;, OO2&gt;
        constexpr operator in_out_out_result&lt;II, OO1, OO2&gt;() const &amp;
        {
            return {in, out1, out2};
        }
      
        template&lt;class II, class OO1, class OO2&gt;
        requires std::convertible_to&lt;I, II&gt; &amp;&amp;
                 std::convertible_to&lt;O1, OO1&gt; &amp;&amp;
                 std::convertible_to&lt;O2, OO2&gt;
        constexpr operator in_out_out_result&lt;II, OO1, OO2&gt;() &amp;&amp;
        {
            return {std::move(in), std::move(out1), std::move(out2)};
        }
    };
}
}}

===Notes===
{{cpp/algorithm/ranges/notes return_types}}

===Example===
{{example|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;cctype&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;ranges&gt;
#include &lt;string_view&gt;

void print(std::string_view rem, auto first, auto last)
{
    for (std::cout &lt;&lt; rem &lt;&lt; ": { "; first != last; ++first)
        std::cout &lt;&lt; *first &lt;&lt; ' ';
    std::cout &lt;&lt; "}\n";
}

int main()
{
    constexpr std::string_view in {"TvEeNcStOoRr"};
    std::array&lt;char, in.size()&gt; o1, o2;

    const auto result = std::ranges::partition_copy(in, o1.begin(), o2.begin(),
        [](char c) { return std::isupper(c); });

    print("in", in.begin(), result.in);
    print("o1", o1.begin(), result.out1);
    print("o2", o2.begin(), result.out2);
}
|output=
in: { T v E e N c S t O o R r }
o1: { T E N S O R }
o2: { v e c t o r }
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/dsc pair}}
{{dsc inc|cpp/utility/dsc tuple}}
{{dsc end}}

{{langlinks|cs|de|es|fr|it|ja|ko|pl|pt|ru|zh}}