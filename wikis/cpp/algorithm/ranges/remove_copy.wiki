{{cpp/ranges/title|remove_copy|remove_copy_if|remove_copy_result|remove_copy_if_result}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl rev begin|num=1}}
{{dcla|anchor=1|since=c++20|until=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          std::weakly_incrementable O, class T, class Proj = std::identity &gt;
requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr remove_copy_result&lt;I, O&gt;
    remove_copy( I first, S last, O result, const T&amp; value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          std::weakly_incrementable O, class Proj = std::identity,
          class T = std::projected_value_t&lt;I, Proj&gt; &gt;
requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr remove_copy_result&lt;I, O&gt;
    remove_copy( I first, S last, O result, const T&amp; value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::input_range R, 
          std::weakly_incrementable O, class T, class Proj = std::identity &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr remove_copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    remove_copy( R&amp;&amp; r, O result, const T&amp; value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::input_range R, 
          std::weakly_incrementable O, class Proj = std::identity,
          class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt; &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr remove_copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    remove_copy( R&amp;&amp; r, O result, const T&amp; value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcla|num=3|since=c++20|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          std::weakly_incrementable O, class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
requires std::indirectly_copyable&lt;I, O&gt;
constexpr remove_copy_if_result&lt;I, O&gt;
    remove_copy_if( I first, S last, O result, Pred pred, Proj proj = {} );
}}
{{dcl|num=4|since=c++20|1=
template&lt; ranges::input_range R,
          std::weakly_incrementable O, class Proj = std::identity,
          std::indirect_unary_predicate&lt;
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt;
constexpr remove_copy_if_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    remove_copy_if( R&amp;&amp; r, O result, Pred pred, Proj proj = {} );
}}
{{dcl h|Helper types}}
{{dcl|num=5|since=c++20|1=
template&lt; class I, class O &gt;
using remove_copy_result = ranges::in_out_result&lt;I, O&gt;;
}}
{{dcl|num=6|since=c++20|1=
template&lt; class I, class O &gt;
using remove_copy_if_result = ranges::in_out_result&lt;I, O&gt;;
}}
{{dcl end}}

Copies elements from the source range {{range|first|last}}, to the destination range beginning at {{c|result}}, omitting the elements which (after being projected by {{c|proj}}) satisfy specific criteria. The behavior is undefined if the source and destination ranges overlap.

@1@ Ignores all elements that are equal to {{c|value}}.

@3@ Ignores all elements for which predicate {{c|pred}} returns {{c|true}}.

@2,4@ Same as {{v|1,3}}, but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}}, and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|the source range of elements}}
{{par|r|the source range of elements}}
{{par|result|the beginning of the destination range}}
{{par|value|the value of the elements '''not''' to copy}}
{{par|comp|the binary predicate to compare the projected elements}}
{{par|proj|the projection to apply to the elements}}
{{par end}}

===Return value===
{{c|{last, result + N} }}, where {{c|N}} is the number of elements copied.

===Complexity===
Exactly {{c|ranges::distance(first, last)}} applications of the corresponding predicate {{c|comp}} and any projection {{c|proj}}.

===Notes===
The algorithm is stable, i.e. preserves the relative order of the copied elements.

{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms {{vl|1,2}}}}

===Possible implementation===
{{eq impl|title1=remove_copy|ver1=1|1=
struct remove_copy_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             std::weakly_incrementable O, class Proj = std::identity,
             class T = std::projected_value_t&lt;I, Proj&gt;&gt;
    requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp;
             std::indirect_binary_predicate&lt;ranges::equal_to,
                                            std::projected&lt;I, Proj&gt;, const T*&gt;
    constexpr ranges::remove_copy_result&lt;I, O&gt;
        operator()(I first, S last, O result, const T&amp; value, Proj proj = {}) const
    {
        for (; !(first == last); ++first)
            if (value != std::invoke(proj, *first))
            {
                *result = *first;
                ++result;
            }
        return {std::move(first), std::move(result)};
    }
    
    template&lt;ranges::input_range R, 
             std::weakly_incrementable O, class Proj = std::identity,
             class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt;
    requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
             std::indirect_binary_predicate&lt;ranges::equal_to,
             std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
    constexpr ranges::remove_copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
        operator()(R&amp;&amp; r, O result, const T&amp; value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(result), value,
                       std::move(proj));
    }
};

inline constexpr remove_copy_fn remove_copy {};
|title2=remove_copy_if|ver2=3|2=
struct remove_copy_if_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, std::weakly_incrementable O,
             class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires std::indirectly_copyable&lt;I, O&gt;
    constexpr ranges::remove_copy_if_result&lt;I, O&gt;
        operator()(I first, S last, O result, Pred pred, Proj proj = {}) const
    {
        for (; first != last; ++first)
            if (false == std::invoke(pred, std::invoke(proj, *first)))
            {
                *result = *first;
                ++result;
            }
        return {std::move(first), std::move(result)};
    }
    
    template&lt;ranges::input_range R, std::weakly_incrementable O,
             class Proj = std::identity,
             std::indirect_unary_predicate&lt;
                 std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt;
    constexpr ranges::remove_copy_if_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
        operator()(R&amp;&amp; r, O result, Pred pred, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(result),
                       std::move(pred), std::move(proj));
    }
};

inline constexpr remove_copy_if_fn remove_copy_if {};
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;complex&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

void println(const auto rem, const auto&amp; v)
{
    std::cout &lt;&lt; rem &lt;&lt; ' ';
    for (const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    // Filter out the hash symbol from the given string.
    const std::string_view str{"#Small #Buffer #Optimization"};
    std::cout &lt;&lt; "before: " &lt;&lt; std::quoted(str) &lt;&lt; '\n';
    
    std::cout &lt;&lt; "after:  \"";
    std::ranges::remove_copy(str.begin(), str.end(),
                             std::ostream_iterator&lt;char&gt;(std::cout), '#');
    std::cout &lt;&lt; "\"\n";
    
    // Copy only the complex numbers with positive imaginary part.
    using Ci = std::complex&lt;int&gt;;
    constexpr std::array&lt;Ci, 5&gt; source
    {
        Ci{1, 0}, Ci{0, 1}, Ci{2, -1}, Ci{3, 2}, Ci{4, -3}
    };
    std::vector&lt;std::complex&lt;int&gt;&gt; target;
    
    std::ranges::remove_copy_if
    (
        source,
        std::back_inserter(target),
        [](int imag) { return imag &lt;= 0; },
        [](Ci z) { return z.imag(); }
    );
    
    println("source:", source);
    println("target:", target);

    std::vector&lt;std::complex&lt;float&gt;&gt; nums{&lt;!----&gt;{2, 2}, {1, 3}, {4, 8}, {1, 3}&lt;!----&gt;};
    std::vector&lt;std::complex&lt;double&gt;&gt; outs;
    #ifdef __cpp_lib_algorithm_default_value_type
        std::remove_copy(nums.cbegin(), nums.cend(), std::back_inserter(outs),
                         {1, 3}); // T gets deduced to std::complex&lt;float&gt;
    #else
        std::remove_copy(nums.cbegin(), nums.cend(), std::back_inserter(outs),
                         std::complex&lt;float&gt;{1, 3});
    #endif
    println("nums:  ", nums);
    println("outs:  ", outs);
}
|output=
before: "#Small #Buffer #Optimization"
after:  "Small Buffer Optimization"
source: (1,0) (0,1) (2,-1) (3,2) (4,-3)
target: (0,1) (3,2)
nums:   (2,2) (1,3) (4,8) (1,3)
outs:   (2,2) (4,8)
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc remove}}
{{dsc inc|cpp/algorithm/ranges/dsc copy}}
{{dsc inc|cpp/algorithm/ranges/dsc copy_n}}
{{dsc inc|cpp/algorithm/ranges/dsc copy_backward}}
{{dsc inc|cpp/algorithm/ranges/dsc replace_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc reverse_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc rotate_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc unique_copy}}
{{dsc inc|cpp/algorithm/dsc remove_copy}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}