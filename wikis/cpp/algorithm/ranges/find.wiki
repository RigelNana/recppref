{{cpp/ranges/title|find|find_if|find_if_not}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl rev begin|num=1}}
{{dcla|anchor=1|since=c++20|until=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class T, class Proj = std::identity &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr I find( I first, S last, const T&amp; value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;I, Proj&gt; &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
constexpr I find( I first, S last, const T&amp; value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::input_range R, class T, class Proj = std::identity &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    find( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt; &gt;
requires std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    find( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcla|since=c++20|num=3|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr I find_if( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++20|num=4|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          std::indirect_unary_predicate
              &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    find_if( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcla|since=c++20|num=5|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
constexpr I find_if_not( I first, S last, Pred pred, Proj proj = {} );
}}
{{dcl|since=c++20|num=6|1=
template&lt; ranges::input_range R, class Proj = std::identity,
          std::indirect_unary_predicate
              &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    find_if_not( R&amp;&amp; r, Pred pred, Proj proj = {} );
}}
{{dcl end}}

Returns the first element in the range {{range|first|last}} that satisfies specific criteria:
@1@ {{tt|find}} searches for an element equal to {{c|value}}.

@3@ {{tt|find_if}} searches for an element for which predicate {{c|pred}} returns {{c|true}}.

@5@ {{tt|find_if_not}} searches for an element for which predicate {{c|pred}} returns {{c|false}}.
@2,4,6@ Same as {{v|1,3,5}}, but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to examine}}
{{par|r|the range of the elements to examine}}
{{par|value|value to compare the elements to}}
{{par|pred|predicate to apply to the projected elements}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
Iterator to the first element satisfying the condition or iterator equal to {{c|last}} if no such element is found.

===Complexity===
At most {{c|last - first}} applications of the predicate and projection.

===Possible implementation===
{{eq impl|title1=find|ver1=1|1=
struct find_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity,
             class T = std::projected_value_t&lt;I, Proj&gt;&gt;
    requires std::indirect_binary_predicate
                 &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T*&gt;
    constexpr I operator()(I first, S last, const T&amp; value, Proj proj = {}) const
    {
        for (; first != last; ++first)
            if (std::invoke(proj, *first) == value)
                return first;
        return first;
    }
    
    template&lt;ranges::input_range R, class T, class Proj = std::identity&gt;
    requires std::indirect_binary_predicate&lt;ranges::equal_to,
                 std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, const T&amp; value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), value, std::ref(proj));
    }
};

inline constexpr find_fn find;
|title2=find_if|ver2=3|2=
struct find_if_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr I operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        for (; first != last; ++first)
            if (std::invoke(pred, std::invoke(proj, *first)))
                return first;
        return first;
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity,
             std::indirect_unary_predicate
                 &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::ref(pred), std::ref(proj));
    }
};

inline constexpr find_if_fn find_if;
|title3=find_if_not|ver3=5|3=
struct find_if_not_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S, class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    constexpr I operator()(I first, S last, Pred pred, Proj proj = {}) const
    {
        for (; first != last; ++first)
            if (!std::invoke(pred, std::invoke(proj, *first)))
                return first;
        return first;
    }
    
    template&lt;ranges::input_range R, class Proj = std::identity,
             std::indirect_unary_predicate
                 &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, Pred pred, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::ref(pred), std::ref(proj));
    }
};

inline constexpr find_if_not_fn find_if_not;
}}

===Notes===
{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms {{vl|1,2}}}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;format&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

void projector_example()
{
    struct folk_info
    {
        unsigned uid;
        std::string name, position;
    };
    
    std::vector&lt;folk_info&gt; folks
    {
        {0, "Ana", "dev"},
        {1, "Bob", "devops"},
        {2, "Eve", "ops"}
    };
    
    const auto who{"Eve"};
    if (auto it = std::ranges::find(folks, who, &amp;folk_info::name); it != folks.end())
        std::cout &lt;&lt; std::format("Profile:\n"
                                 "    UID: {}\n"
                                 "    Name: {}\n"
                                 "    Position: {}\n\n",
                                 it-&gt;uid, it-&gt;name, it-&gt;position);
}

int main()
{
    namespace ranges = std::ranges;
    
    projector_example();
    
    const int n1 = 3;
    const int n2 = 5;
    const auto v = {4, 1, 3, 2};
    
    if (ranges::find(v, n1) != v.end())
        std::cout &lt;&lt; "v contains: " &lt;&lt; n1 &lt;&lt; '\n';
    else
        std::cout &lt;&lt; "v does not contain: " &lt;&lt; n1 &lt;&lt; '\n';
    
    if (ranges::find(v.begin(), v.end(), n2) != v.end())
        std::cout &lt;&lt; "v contains: " &lt;&lt; n2 &lt;&lt; '\n';
    else
        std::cout &lt;&lt; "v does not contain: " &lt;&lt; n2 &lt;&lt; '\n';
    
    auto is_even = [](int x) { return x % 2 == 0; };
    
    if (auto result = ranges::find_if(v.begin(), v.end(), is_even); result != v.end())
        std::cout &lt;&lt; "First even element in v: " &lt;&lt; *result &lt;&lt; '\n';
    else
        std::cout &lt;&lt; "No even elements in v\n";
    
    if (auto result = ranges::find_if_not(v, is_even); result != v.end())
        std::cout &lt;&lt; "First odd element in v: " &lt;&lt; *result &lt;&lt; '\n';
    else
        std::cout &lt;&lt; "No odd elements in v\n";
    
    auto divides_13 = [](int x) { return x % 13 == 0; };
    
    if (auto result = ranges::find_if(v, divides_13); result != v.end())
        std::cout &lt;&lt; "First element divisible by 13 in v: " &lt;&lt; *result &lt;&lt; '\n';
    else
        std::cout &lt;&lt; "No elements in v are divisible by 13\n";
    
    if (auto result = ranges::find_if_not(v.begin(), v.end(), divides_13);
        result != v.end())
        std::cout &lt;&lt; "First element indivisible by 13 in v: " &lt;&lt; *result &lt;&lt; '\n';
    else
        std::cout &lt;&lt; "All elements in v are divisible by 13\n";

    std::vector&lt;std::complex&lt;double&gt;&gt; nums{&lt;!----&gt;{4, 2}&lt;!----&gt;};
    #ifdef __cpp_lib_algorithm_default_value_type
        // T gets deduced in (2) making list-initialization possible
        const auto it = ranges::find(nums, {4, 2});
    #else
        const auto it = ranges::find(nums, std::complex&lt;double&gt;{4, 2});
    #endif
    assert(it == nums.begin());
}
|output=
Profile:
    UID: 2
    Name: Eve
    Position: ops

v contains: 3
v does not contain: 5
First even element in v: 4
First odd element in v: 1
No elements in v are divisible by 13
First element indivisible by 13 in v: 4
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc adjacent_find}}
{{dsc inc|cpp/algorithm/ranges/dsc find_end}}
{{dsc inc|cpp/algorithm/ranges/dsc find_first_of}}
{{dsc inc|cpp/algorithm/ranges/dsc mismatch}}
{{dsc inc|cpp/algorithm/ranges/dsc search}}
{{dsc inc|cpp/algorithm/dsc find}}
{{dsc end}}

{{langlinks|es|ja|zh}}