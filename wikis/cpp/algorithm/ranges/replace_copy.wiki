{{cpp/ranges/title|replace_copy|replace_copy_if|replace_copy_result|replace_copy_if_result}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl rev begin|num=1}}
{{dcla|anchor=1|since=c++20|until=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S, class T1, class T2,
          std::output_iterator&lt;const T2&amp;&gt; O, class Proj = std::identity &gt;
requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T1*&gt;
constexpr replace_copy_result&lt;I, O&gt;
    replace_copy( I first, S last, O result, const T1&amp; old_value,
                  const T2&amp; new_value, Proj proj = {} );
}}
{{dcla|since=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class O, class Proj = std::identity,
          class T1 = std::projected_value_t&lt;I, Proj&gt;,
          class T2 = std::iter_value_t&lt;O&gt; &gt;
requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T1*&gt; &amp;&amp;
         std::output_iterator&lt;O, const T2&amp;&gt;
constexpr replace_copy_result&lt;I, O&gt;
    replace_copy( I first, S last, O result, const T1&amp; old_value,
                  const T2&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::input_range R, class T1, class T2,
          std::output_iterator&lt;const T2&amp;&gt; O, class Proj = std::identity &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;
constexpr replace_copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    replace_copy( R&amp;&amp; r, O result, const T1&amp; old_value,
                  const T2&amp; new_value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::input_range R,
          class O, class Proj = std::identity,
          class T1 = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
          class T2 = std::iter_value_t&lt;O&gt; &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
         std::indirect_binary_predicate
             &lt;ranges::equal_to,
              std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt; &amp;&amp;
         std::output_iterator&lt;O, const T2&amp;&gt;
constexpr replace_copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    replace_copy( R&amp;&amp; r, O result, const T1&amp; old_value,
                  const T2&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=3}}
{{dcla|anchor=3|since=c++20|until=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class T, std::output_iterator&lt;const T&amp;&gt; O,
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
requires std::indirectly_copyable&lt;I, O&gt;
constexpr replace_copy_if_result&lt;I, O&gt;
    replace_copy_if( I first, S last, O result, Pred pred,
                     const T&amp; new_value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class O, class T = std::iter_value_t&lt;O&gt;
          class Proj = std::identity,
          std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred &gt;
requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp; std::output_iterator&lt;O, const T&amp;&gt;
constexpr replace_copy_if_result&lt;I, O&gt;
    replace_copy_if( I first, S last, O result, Pred pred,
                     const T&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl rev begin|num=4}}
{{dcl|since=c++20|until=c++26|1=
template&lt; ranges::input_range R,
          class T, std::output_iterator&lt;const T&amp;&gt; O,
          class Proj = std::identity,
          std::indirect_unary_predicate
              &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt;
constexpr replace_copy_if_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    replace_copy_if( R&amp;&amp; r, O result, Pred pred,
                     const T&amp; new_value, Proj proj = {} );
}}
{{dcl|since=c++26|1=
template&lt; ranges::input_range R,
          class O, class T = std::iter_value_t&lt;O&gt;
          class Proj = std::identity,
          std::indirect_unary_predicate
              &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred &gt;
requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
         std::output_iterator&lt;O, const T&amp;&gt;
constexpr replace_copy_if_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
    replace_copy_if( R&amp;&amp; r, O result, Pred pred,
                     const T&amp; new_value, Proj proj = {} );
}}
{{dcl rev end}}
{{dcl h|Helper types}}
{{dcl|num=5|since=c++20|1=
template&lt; class I, class O &gt;
using replace_copy_result = ranges::in_out_result&lt;I, O&gt;;
}}
{{dcl|num=6|since=c++20|1=
template&lt; class I, class O &gt;
using replace_copy_if_result = ranges::in_out_result&lt;I, O&gt;;
}}
{{dcl end}}

Copies the elements from the source range {{range|first|last}} to the destination range beginning at {{c|result}}, replacing all elements satisfying specific criteria with {{c|new_value}}. The behavior is undefined if the source and destination ranges overlap.

@1@ Replaces all elements that are equal to {{c|old_value}}, using {{c|1=std::invoke(proj, *(first + (i - result))) == old_value}} to compare.

@3@ Replaces all elements for which the predicate {{c|pred}} evaluates to {{c|true}}, where the evaluating expression is {{c|1=std::invoke(pred, std::invoke(proj, *(first + (i - result))))}}.

@2,4@ Same as {{v|1,3}}, but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}}, and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}

{{par|first, last|the range of elements to copy}}
{{par|r|the range of elements to copy}}
{{par|result|the beginning of the destination range}}
{{par|old_value|the value of elements to replace}}
{{par|new_value|the value to use as a replacement}}
{{par|pred|predicate to apply to the projected elements}}
{{par|proj|projection to apply to the elements.}}
{{par end}}

===Return value===
{{c|1= {last, result + N} }}, where
@1,3@ {{c|1=N = ranges::distance(first, last)}};
@2,4@ {{c|1=N = ranges::distance(r)}}.

===Complexity===
Exactly {{c|N}} applications of the corresponding predicate {{c|comp}} and any projection {{c|proj}}.

===Possible implementation===
{{eq impl|title1=replace_copy (1,2)|ver1=1|1=
struct replace_copy_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             class O, class Proj = std::identity,
             class T1 = std::projected_value_t&lt;I, Proj&gt;,
             class T2 = std::iter_value_t&lt;O&gt;&gt;
    requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp;
             std::indirect_binary_predicate
                 &lt;ranges::equal_to, std::projected&lt;I, Proj&gt;, const T1*&gt; &amp;&amp;
             std::output_iterator&lt;O, const T2&amp;&gt;
    constexpr ranges::replace_copy_result&lt;I, O&gt;
        operator()(I first, S last, O result, const T1&amp; old_value,
                   const T2&amp; new_value, Proj proj = {}) const
    {
        for (; first != last; ++first, ++result)
            *result = (std::invoke(proj, *first) == old_value) ? new_value : *first;
        return {std::move(first), std::move(result)};
    }
    
    template&lt;ranges::input_range R, class O, class Proj = std::identity,
             class T1 = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
             class T2 = std::iter_value_t&lt;O&gt;&gt;
    requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
             std::indirect_binary_predicate
                 &lt;ranges::equal_to,
                  std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;
    constexpr ranges::replace_copy_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
        operator()(R&amp;&amp; r, O result, const T1&amp; old_value,
                   const T2&amp; new_value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(result),
                       old_value, new_value, std::move(proj));
    }
};

inline constexpr replace_copy_fn replace_copy {};
|title2=replace_copy_if (3,4)|ver2=3|2=
struct replace_copy_if_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             class O, class T = std::iter_value_t&lt;O&gt;
             class Proj = std::identity,
             std::indirect_unary_predicate&lt;std::projected&lt;I, Proj&gt;&gt; Pred&gt;
    requires std::indirectly_copyable&lt;I, O&gt; &amp;&amp; std::output_iterator&lt;O, const T&amp;&gt;
    constexpr ranges::replace_copy_if_result&lt;I, O&gt;
        operator()(I first, S last, O result, Pred pred,
                   const T&amp; new_value, Proj proj = {}) const
    {
        for (; first != last; ++first, ++result)
             *result = std::invoke(pred, std::invoke(proj, *first)) ? new_value : *first;
        return {std::move(first), std::move(result)};
    }
    
    template&lt;ranges::input_range R, class O, class T = std::iter_value_t&lt;O&gt;
             class Proj = std::identity,
             std::indirect_unary_predicate
                 &lt;std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;
    requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt; &amp;&amp;
             std::output_iterator&lt;O, const T&amp;&gt;
    constexpr ranges::replace_copy_if_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;
        operator()(R&amp;&amp; r, O result, Pred pred,
                   const T&amp; new_value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(result),
                       std::move(pred), new_value, std::move(proj));
    }
};

inline constexpr replace_copy_if_fn replace_copy_if {};
}}

===Notes===
{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|list-initialization]] for algorithms {{vl|1-4}}}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

void println(const auto rem, const auto&amp; v)
{
    for (std::cout &lt;&lt; rem &lt;&lt; ": "; const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{    
    std::vector&lt;int&gt; o;
    
    std::array p{1, 6, 1, 6, 1, 6};
    o.resize(p.size());
    println("p", p);
    std::ranges::replace_copy(p, o.begin(), 6, 9);
    println("o", o);
    
    std::array q{1, 2, 3, 6, 7, 8, 4, 5};
    o.resize(q.size());
    println("q", q);
    std::ranges::replace_copy_if(q, o.begin(), [](int x) { return 5 &lt; x; }, 5);
    println("o", o);

    std::vector&lt;std::complex&lt;short&gt;&gt; r{{1, 3}, {2, 2}, {4, 8}};
    std::vector&lt;std::complex&lt;float&gt;&gt; s(r.size());
    println("r", r);
    #ifdef __cpp_lib_algorithm_default_value_type
        std::ranges::replace_copy(r, s.begin(),
                                  {1, 3}, // T1 gets deduced
                                  {2.2, 4.8}); // T2 gets deduced
    #else
        std::ranges::replace_copy(r, s.begin(),
                                  std::complex&lt;short&gt;{1, 3},
                                  std::complex&lt;float&gt;{2.2, 4.8});
    #endif
    println("s", s);

    std::vector&lt;std::complex&lt;double&gt;&gt; b{{1, 3}, {2, 2}, {4, 8}},
                                      d(b.size());
    println("b", b);
    #ifdef __cpp_lib_algorithm_default_value_type
        std::ranges::replace_copy_if(b, d.begin(),
            [](std::complex&lt;double&gt; z){ return std::abs(z) &lt; 5; },
            {4, 2}); // Possible, since the T is deduced.
    #else
        std::ranges::replace_copy_if(b, d.begin(),
            [](std::complex&lt;double&gt; z){ return std::abs(z) &lt; 5; },
            std::complex&lt;double&gt;{4, 2});
    #endif
    println("d", d);
}
|output=
p: 1 6 1 6 1 6
o: 1 9 1 9 1 9
q: 1 2 3 6 7 8 4 5
o: 1 2 3 5 5 5 4 5
r: (1,3) (2,2) (4,8)
s: (2.2,4.8) (2,2) (4,8)
b: (1,3) (2,2) (4,8)
d: (4,2) (4,2) (4,8)
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc replace}}
{{dsc inc|cpp/algorithm/dsc replace_copy}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}