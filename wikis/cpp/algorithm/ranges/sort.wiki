{{cpp/ranges/title|sort}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl|since=c++20|num=1|1=
template&lt; std::random_access_iterator I, std::sentinel_for&lt;I&gt; S,
          class Comp = ranges::less, class Proj = std::identity &gt;
requires std::sortable&lt;I, Comp, Proj&gt;
constexpr I 
    sort( I first, S last, Comp comp = {}, Proj proj = {} );
}}
{{dcl|since=c++20|num=2|1=
template&lt; ranges::random_access_range R, class Comp = ranges::less,
          class Proj = std::identity &gt;
requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
constexpr ranges::borrowed_iterator_t&lt;R&gt;
    sort( R&amp;&amp; r, Comp comp = {}, Proj proj = {} );
}}
{{dcl end}}

Sorts the elements in the range {{range|first|last}} in non-descending order. The order of equivalent elements is not guaranteed to be preserved.

A sequence is sorted with respect to a comparator {{c|comp}} if for any iterator {{tt|it}} pointing to the sequence and any non-negative integer {{tt|n}} such that {{tt|it + n}} is a valid iterator pointing to an element of the sequence, {{c|std::invoke(comp, std::invoke(proj, *(it + n)), std::invoke(proj, *it))}} evaluates to {{c|false}}.

@1@ Elements are compared using the given binary comparison function {{c|comp}}.
@2@ Same as {{v|1}}, but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|iterator-sentinel defining the range to sort}}
{{par|r|the range to sort}}
{{par|comp|comparison to apply to the projected elements}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
An iterator equal to {{c|last}}.

===Complexity===
{{mathjax-or|\(\scriptsize \mathcal{O}(N\cdot\log{(N)})\)|ùìû(N&amp;middot;log(N))}} comparisons and projections, where {{c|1=N = ranges::distance(first, last)}}.

===Possible implementation===
Note that typical implementations use {{enwiki|Introsort}}. See also the implementation in [https://github.com/microsoft/STL/blob/e745bad3b1d05b5b19ec652d68abb37865ffa454/stl/inc/algorithm#L7575-L7641 MSVC STL] and [https://github.com/gcc-mirror/gcc/blob/54258e22b0846aaa6bd3265f592feb161eecda75/libstdc%2B%2B-v3/include/bits/ranges_algo.h#L1808-L1834 libstdc++].
{{eq fun|1=
struct sort_fn
{
    template&lt;std::random_access_iterator I, std::sentinel_for&lt;I&gt; S,
             class Comp = ranges::less, class Proj = std::identity&gt;
    requires std::sortable&lt;I, Comp, Proj&gt;
    constexpr I
        operator()(I first, S last, Comp comp = {}, Proj proj = {}) const
    {
        if (first == last)
            return first;
&lt;!--    
        const auto pivot = *ranges::next(first, ranges::distance(first, last) / 2, last);
        
        auto tail1 = ranges::partition(first, last, [&amp;pivot, &amp;comp, &amp;proj](const auto&amp; em) {
            return std::invoke(comp, std::invoke(proj, em), std::invoke(proj, pivot)); });
        auto tail2 = ranges::partition(tail1, [&amp;pivot, &amp;comp, &amp;proj](const auto&amp; em) { 
            return !std::invoke(comp, std::invoke(proj, pivot), std::invoke(proj, em)); });
        
        (*this)(first, tail1.begin(), std::ref(comp), std::ref(proj));
        (*this)(tail2, std::ref(comp), std::ref(proj));
        
        return {ranges::next(first, last)};
--&gt;

        I last_iter = ranges::next(first, last);
        ranges::make_heap(first, last_iter, std::ref(comp), std::ref(proj));
        ranges::sort_heap(first, last_iter, std::ref(comp), std::ref(proj));
        
        return last_iter;
    }
    
    template&lt;ranges::random_access_range R, class Comp = ranges::less,
             class Proj = std::identity&gt;
    requires std::sortable&lt;ranges::iterator_t&lt;R&gt;, Comp, Proj&gt;
    constexpr ranges::borrowed_iterator_t&lt;R&gt;
        operator()(R&amp;&amp; r, Comp comp = {}, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(comp), std::move(proj));
    }
};

inline constexpr sort_fn sort {};
}}

===Notes===
{{lc|std::sort}} uses {{lc|std::iter_swap}} to swap elements, whereas {{tt|ranges::sort}} instead uses {{lc|ranges::iter_swap}} (which performs ADL for {{tt|iter_swap}}, unlike {{lc|std::iter_swap}})

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;

void print(auto comment, auto const&amp; seq, char term = ' ')
{
    for (std::cout &lt;&lt; comment &lt;&lt; '\n'; auto const&amp; elem : seq)
        std::cout &lt;&lt; elem &lt;&lt; term;
    std::cout &lt;&lt; '\n';
}

struct Particle
{
    std::string name; double mass; // MeV
    template&lt;class Os&gt; friend
    Os&amp; operator&lt;&lt;(Os&amp; os, Particle const&amp; p)
    {
        return os &lt;&lt; std::left &lt;&lt; std::setw(8) &lt;&lt; p.name &lt;&lt; " : " &lt;&lt; p.mass &lt;&lt; ' ';
    }
};

int main()
{
    std::array s {5, 7, 4, 2, 8, 6, 1, 9, 0, 3};

    namespace ranges = std::ranges;

    ranges::sort(s);
    print("Sort using the default operator&lt;", s);

    ranges::sort(s, ranges::greater());
    print("Sort using a standard library compare function object", s);

    struct
    {
        bool operator()(int a, int b) const { return a &lt; b; }
    } customLess;
    ranges::sort(s.begin(), s.end(), customLess);
    print("Sort using a custom function object", s);

    ranges::sort(s, [](int a, int b) { return a &gt; b; });
    print("Sort using a lambda expression", s);

    Particle particles[]
    {
        {"Electron", 0.511}, {"Muon", 105.66}, {"Tau", 1776.86},
        {"Positron", 0.511}, {"Proton", 938.27}, {"Neutron", 939.57}
    };
    ranges::sort(particles, {}, &amp;Particle::name);
    print("\nSort by name using a projection", particles, '\n');
    ranges::sort(particles, {}, &amp;Particle::mass);
    print("Sort by mass using a projection", particles, '\n');
}
|output=
Sort using the default operator&lt;
0 1 2 3 4 5 6 7 8 9
Sort using a standard library compare function object
9 8 7 6 5 4 3 2 1 0
Sort using a custom function object
0 1 2 3 4 5 6 7 8 9
Sort using a lambda expression
9 8 7 6 5 4 3 2 1 0

Sort by name using a projection
Electron : 0.511
Muon     : 105.66
Neutron  : 939.57
Positron : 0.511
Proton   : 938.27
Tau      : 1776.86

Sort by mass using a projection
Electron : 0.511
Positron : 0.511
Muon     : 105.66
Proton   : 938.27
Neutron  : 939.57
Tau      : 1776.86
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc partial_sort}}
{{dsc inc|cpp/algorithm/ranges/dsc stable_sort}}
{{dsc inc|cpp/algorithm/ranges/dsc partition}}
{{dsc inc|cpp/algorithm/dsc sort}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}