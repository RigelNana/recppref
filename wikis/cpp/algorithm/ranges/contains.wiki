{{cpp/ranges/title|contains|contains_subrange}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl rev multi|num=1|anchor=1|since1=c++23|until1=c++26|dcl1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class T,
          class Proj = std::identity &gt;
requires std::indirect_binary_predicate&lt;ranges::equal_to, std::projected&lt;I, Proj&gt;,
                                        const T*&gt;
constexpr bool contains( I first, S last, const T&amp; value, Proj proj = {} );
|dcl2=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;I, Proj&gt; &gt;
requires std::indirect_binary_predicate&lt;ranges::equal_to, std::projected&lt;I, Proj&gt;,
                                        const T*&gt;
constexpr bool contains( I first, S last, const T&amp; value, Proj proj = {} );
}}
{{dcl rev multi|num=2|since1=c++23|until1=c++26|dcl1=
template&lt; ranges::input_range R,
          class T,
          class Proj = std::identity &gt;
requires std::indirect_binary_predicate&lt;ranges::equal_to,
                                        std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
                                        const T*&gt;
constexpr bool contains( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
|dcl2=
template&lt; ranges::input_range R,
          class Proj = std::identity,
          class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt; &gt;
requires std::indirect_binary_predicate&lt;ranges::equal_to,
                                        std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
                                        const T*&gt;
constexpr bool contains( R&amp;&amp; r, const T&amp; value, Proj proj = {} );
}}
{{dcla|since=c++23|num=3|1=
template&lt; std::forward_iterator I1, std::sentinel_for&lt;I1&gt; S1,
          std::forward_iterator I2, std::sentinel_for&lt;I2&gt; S2,
          class Pred = ranges::equal_to,
          class Proj1 = std::identity, class Proj2 = std::identity &gt;
requires std::indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
constexpr bool contains_subrange( I1 first1, S1 last1, I2 first2, S2 last2,
                                  Pred pred = {},
                                  Proj1 proj1 = {}, Proj2 proj2 = {} );
}}
{{dcl|since=c++23|num=4|1=
template&lt; ranges::forward_range R1, ranges::forward_range R2,
          class Pred = ranges::equal_to,
          class Proj1 = std::identity, class Proj2 = std::identity &gt;
requires std::indirectly_comparable&lt;ranges::iterator_t&lt;R1&gt;,
                                    ranges::iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
constexpr bool contains_subrange( R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},
                                  Proj1 proj1 = {}, Proj2 proj2 = {} );
}}
{{dcl end}}

@1@ Search-based algorithm that checks whether or not a given range contains a value with iterator-sentinel pairs.
@2@ Same as {{v|1}} but uses {{c|r}} as the source range, as if using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.
@3@ Search-based algorithm that checks whether or not a given range is a subrange of another range with iterator-sentinel pairs.
@4@ Same as {{v|3}} but uses {{c|r1}} as the first source range and {{c|r2}} as the second source range, as if using {{c|ranges::begin(r1)}} as {{c|first1}}, {{c|ranges::end(r1)}} as {{c|last1}}, {{c|ranges::begin(r2)}} as {{c|first2}}, and {{c|ranges::end(r2)}} as {{c|last2}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to examine}}
{{par|r|the range of the elements to examine}}
{{par|value|value to compare the elements to}}
{{par|pred|predicate to apply to the projected elements}}
{{par|proj|projection to apply to the elements}}
{{par end}}

===Return value===
@1,2@: {{c|1=ranges::find(std::move(first), last, value, proj) != last}}

@3,4@: {{c|1=first2 == last2 {{!!}} !ranges::search(first1, last1, first2, last2, pred, proj1, proj2).empty()}}

===Complexity===
At most {{c|last - first}} applications of the predicate and projection.

===Notes===
Up until C++20, we've had to write {{c|1= std::ranges::find(r, value) != std::ranges::end(r)}} to determine if a single value is inside a range. And to check if a range contains a subrange of interest, we use {{c|1= not std::ranges::search(haystack, needle).empty()}}. While this is accurate, it isn't necessarily convenient, and it hardly expresses intent (especially in the latter case). Being able to say {{c|std::ranges::contains(r, value)}} addresses both of these points.

{{tt|ranges::contains_subrange}}, same as {{lc|ranges::search}}, but as opposed to {{lc|std::search}}, provides no access to {{named req|Searcher}}s (such as [[cpp/utility/functional#Searchers|Boyer-Moore]]).

{{ftm begin}}
{{ftm|__cpp_lib_ranges_contains|value=202207L|std=C++23|{{ttt|std::ranges::contains}} and {{ttt|ranges::contains_subrange}}}}
{{ftm|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms {{vl|1,2}}}}
{{ftm end}}

===Possible implementation===
{{eq impl
|title1=contains (1,2)|ver1=1|1=
struct __contains_fn
{
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             class Proj = std::identity,
             class T = std::projected_value_t&lt;I, Proj&gt;&gt;
    requires std::indirect_binary_predicate&lt;ranges::equal_to, std::projected&lt;I, Proj&gt;,
                                            const T*&gt;
    constexpr bool operator()(I first, S last, const T&amp; value, Proj proj = {}) const
    {
        return ranges::find(std::move(first), last, value, proj) != last;
    }

    template&lt;ranges::input_range R,
             class Proj = std::identity,
             class T = std::projected_value_t&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt;
    requires std::indirect_binary_predicate&lt;ranges::equal_to,
                                            std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;,
                                            const T*&gt;
    constexpr bool operator()(R&amp;&amp; r, const T&amp; value, Proj proj = {}) const
    {
        return (*this)(ranges::begin(r), ranges::end(r), std::move(value), proj);
    }
};

inline constexpr __contains_fn contains {};
|title2=contains_subrange (3,4)|ver2=3|2=
struct __contains_subrange_fn
{
    template&lt;std::forward_iterator I1, std::sentinel_for&lt;I1&gt; S1,
             std::forward_iterator I2, std::sentinel_for&lt;I2&gt; S2,
             class Pred = ranges::equal_to,
             class Proj1 = std::identity, class Proj2 = std::identity&gt;
    requires std::indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
    constexpr bool operator()(I1 first1, S1 last1,
                              I2 first2, S2 last2,
                              Pred pred = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {}) const
    {
        return (first2 == last2) {{!!}}
               !ranges::search(first1, last1, first2, last2, pred, proj1, proj2).empty();
    }

    template&lt;ranges::forward_range R1, ranges::forward_range R2,
             class Pred = ranges::equal_to,
             class Proj1 = std::identity, class Proj2 = std::identity&gt;
    requires std::indirectly_comparable&lt;ranges::iterator_t&lt;R1&gt;,
                                        ranges::iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;
    constexpr bool operator()(R1&amp;&amp; r1, R2&amp;&amp; r2,
                              Pred pred = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {}) const
    {
        return (*this)(ranges::begin(r1), ranges::end(r1),
                       ranges::begin(r2), ranges::end(r2), std::move(pred),
                       std::move(proj1), std::move(proj2));
    }
};

inline constexpr __contains_subrange_fn contains_subrange {};
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;complex&gt;

namespace ranges = std::ranges;

int main()
{
    constexpr auto haystack = std::array{3, 1, 4, 1, 5};
    constexpr auto needle = std::array{1, 4, 1};
    constexpr auto bodkin = std::array{2, 5, 2};

    static_assert(
        ranges::contains(haystack, 4) &amp;&amp;
       !ranges::contains(haystack, 6) &amp;&amp;
        ranges::contains_subrange(haystack, needle) &amp;&amp;
       !ranges::contains_subrange(haystack, bodkin)
    );

    constexpr std::array&lt;std::complex&lt;double&gt;, 3&gt; nums{&lt;!----&gt;{&lt;!----&gt;{1, 2}, {3, 4}, {5, 6}&lt;!----&gt;}&lt;!----&gt;};
    #ifdef __cpp_lib_algorithm_default_value_type
        static_assert(ranges::contains(nums, {3, 4}));
    #else
        static_assert(ranges::contains(nums, std::complex&lt;double&gt;{3, 4}));
    #endif
}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc find}}
{{dsc inc|cpp/algorithm/ranges/dsc search}}
{{dsc inc|cpp/algorithm/ranges/dsc binary_search}}
{{dsc inc|cpp/algorithm/ranges/dsc includes}}
{{dsc inc|cpp/algorithm/ranges/dsc all_any_none_of}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}