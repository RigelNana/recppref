{{cpp/ranges/title|fold_left_first_with_iter|fold_left_first_with_iter_result}}
{{cpp/algorithm/ranges/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl h|Call signature}}
{{dcl|num=1|since=c++23|1=
template&lt; std::input_iterator I, std::sentinel_for&lt;I&gt; S,
          /*indirectly-binary-left-foldable*/&lt;std::iter_value_t&lt;I&gt;, I&gt; F &gt;
requires std::constructible_from&lt;
             std::iter_value_t&lt;I&gt;, std::iter_reference_t&lt;I&gt;&gt;
constexpr /* see description */
    fold_left_first_with_iter( I first, S last, F f );
}}
{{dcl|num=2|since=c++23|1=
template&lt; ranges::input_range R,
          /*indirectly-binary-left-foldable*/&lt;
              ranges::range_value_t&lt;R&gt;, ranges::iterator_t&lt;R&gt;&gt; F &gt;
requires std::constructible_from&lt;
             ranges::range_value_t&lt;R&gt;, ranges::range_reference_t&lt;R&gt;&gt;
constexpr /* see description */
    fold_left_first_with_iter( R&amp;&amp; r, F f );
}}
{{dcl h|Helper concepts}}
{{dcl|num=3|notes={{mark expos}}|1=
template&lt; class F, class T, class I &gt;
concept /*indirectly-binary-left-foldable*/ = /* see description */;
}}
{{dcl h|Helper class template}}
{{dcl|num=4|since=c++23|1=
template&lt; class I, class T &gt;
using fold_left_first_with_iter_result = ranges::in_value_result&lt;I, T&gt;;
}}
{{dcl end}}

Left-{{enwiki|Fold (higher-order function)|folds}} the elements of given range, that is, returns the result of evaluation of the chain expression:&lt;br&gt;{{tt|f(f(f(f(x{{sub|1}}, x{{sub|2}}), x{{sub|3}}), ...), x{{sub|n}})}}, where {{tt|x{{sub|1}}}}, {{tt|x{{sub|2}}}}, ..., {{tt|x{{sub|n}}}} are elements of the range.

Informally, {{tt|ranges::fold_left_first_with_iter}} behaves like {{lc|std::accumulate}}'s overload that accepts a binary predicate, except that the {{c|*first}} is used internally as an initial element.

The behavior is undefined if {{range|first|last}} is not a valid range.

@1@ The range is {{range|first|last}}.

@2@ Same as {{v|1}}, except that uses {{c|r}} as the range, as if by using {{c|ranges::begin(r)}} as {{c|first}} and {{c|ranges::end(r)}} as {{c|last}}.

{{ranges_fold_algos_helper_concepts}}
&lt;!----&gt;
@4@ The return type alias. See "{{ls|#Return value}}" section for details.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to fold}}
{{par|r|the range of elements to fold}}
{{par|f|the binary function object}}
{{par end}}

===Return value===
Let {{c|U}} be {{c|decltype(ranges::fold_left(std::move(first), last, std::iter_value_t&lt;I&gt;(*first), f))}}.

@1@ An object of type {{c|ranges::fold_left_first_with_iter_result&lt;I, std::optional&lt;U&gt;&gt;}}.
* The member {{c|ranges::in_value_result::in}} holds an iterator to the end of the range.
* The member {{c|ranges::in_value_result::value}} holds the result of the left-{{enwiki|Fold (higher-order function)|fold}} of given range over {{c|f}}.
If the range is empty, the return value is {{c|{std::move(first), std::optional&lt;U&gt;()}&lt;!----&gt;}}.

@2@ Same as {{v|1}} except that the return type is {{c|ranges::fold_left_first_with_iter_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, std::optional&lt;U&gt;&gt;}}.

===Possible implementations===
{{eq fun
|1=
class fold_left_first_with_iter_fn
{
    template&lt;class O, class I, class S, class F&gt;
    constexpr auto impl(I&amp;&amp; first, S&amp;&amp; last, F f) const
    {
        using U = decltype(
            ranges::fold_left(std::move(first), last, std::iter_value_t&lt;I&gt;(*first), f)
        );
        using Ret = ranges::fold_left_first_with_iter_result&lt;O, std::optional&lt;U&gt;&gt;;
        if (first == last)
            return Ret{std::move(first), std::optional&lt;U&gt;()};
        std::optional&lt;U&gt; init(std::in_place, *first);
        for (++first; first != last; ++first)
            *init = std::invoke(f, std::move(*init), *first);
        return Ret{std::move(first), std::move(init)};
    }

public:
    template&lt;std::input_iterator I, std::sentinel_for&lt;I&gt; S,
             /*indirectly-binary-left-foldable*/&lt;std::iter_value_t&lt;I&gt;, I&gt; F&gt;
    requires std::constructible_from&lt;std::iter_value_t&lt;I&gt;, std::iter_reference_t&lt;I&gt;&gt;
    constexpr auto operator()(I first, S last, F f) const
    {
        return impl&lt;I&gt;(std::move(first), std::move(last), std::ref(f));
    }

    template&lt;ranges::input_range R, /*indirectly-binary-left-foldable*/&lt;
        ranges::range_value_t&lt;R&gt;, ranges::iterator_t&lt;R&gt;&gt; F&gt;
    requires
        std::constructible_from&lt;ranges::range_value_t&lt;R&gt;, ranges::range_reference_t&lt;R&gt;&gt;
    constexpr auto operator()(R&amp;&amp; r, F f) const
    {
        return impl&lt;ranges::borrowed_iterator_t&lt;R&gt;&gt;(
            ranges::begin(r), ranges::end(r), std::ref(f)
        );
    }
};

inline constexpr fold_left_first_with_iter_fn fold_left_first_with_iter;
}}

===Complexity===
Exactly {{c|ranges::distance(first, last) - 1}} (assuming the range is not empty) applications of the function object {{c|f}}.

===Notes===
{{ranges_fold_algos_table}}

{{feature test macro|__cpp_lib_ranges_fold|std=C++23|value=202207L|{{tt|std::ranges}} [[cpp/algorithm/ranges#Constrained fold operations|fold algorithms]]}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

int main()
{
    std::vector v{1, 2, 3, 4, 5, 6, 7, 8};

    auto sum = std::ranges::fold_left_first_with_iter
    (
        v.begin(), v.end(), std::plus&lt;int&gt;()
    );
    std::cout &lt;&lt; "sum: " &lt;&lt; sum.value.value() &lt;&lt; '\n';
    assert(sum.in == v.end());

    auto mul = std::ranges::fold_left_first_with_iter(v, std::multiplies&lt;int&gt;());
    std::cout &lt;&lt; "mul: " &lt;&lt; mul.value.value() &lt;&lt; '\n';
    assert(mul.in == v.end());

    // get the product of the std::pair::second of all pairs in the vector:
    std::vector&lt;std::pair&lt;char, float&gt;&gt; data {{'A', 2.f}, {'B', 3.f}, {'C', 7.f}};
    auto sec = std::ranges::fold_left_first_with_iter
    (
        data {{!}} std::ranges::views::values, std::multiplies&lt;&gt;()
    );
    std::cout &lt;&lt; "sec: " &lt;&lt; sec.value.value() &lt;&lt; '\n';

    // use a program defined function object (lambda-expression):
    auto lambda = [](int x, int y) { return x + y + 2; };
    auto val = std::ranges::fold_left_first_with_iter(v, lambda);
    std::cout &lt;&lt; "val: " &lt;&lt; val.value.value() &lt;&lt; '\n';
    assert(val.in == v.end());
}
|output=
sum: 36
mul: 40320
sec: 42
val: 50
}}

===References===
{{ref std c++23}}
{{ref std|title=Fold|id=alg.fold|section=27.6.18}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/ranges/dsc fold_left}}
{{dsc inc|cpp/algorithm/ranges/dsc fold_left_first}}
{{dsc inc|cpp/algorithm/ranges/dsc fold_right}}
{{dsc inc|cpp/algorithm/ranges/dsc fold_right_last}}
{{dsc inc|cpp/algorithm/ranges/dsc fold_left_with_iter}}
{{dsc inc|cpp/algorithm/dsc accumulate}}
{{dsc inc|cpp/algorithm/dsc reduce}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pl|pt|ru|zh}}