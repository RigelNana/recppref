{{cpp/title|prev_permutation}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|num=1|notes={{mark constexpr since c++20}}|
template&lt; class BidirIt &gt;
bool prev_permutation( BidirIt first, BidirIt last );
}}
{{dcl|num=2|notes={{mark constexpr since c++20}}|
template&lt; class BidirIt, class Compare &gt;
bool prev_permutation( BidirIt first, BidirIt last, Compare comp );
}}
{{dcl end}}

Transforms the range {{range|first|last}} into the previous {{enwiki|permutation}}. Returns {{c|true}} if such permutation exists, otherwise transforms the range into the last permutation (as if by {{lc|std::sort}} followed by {{lc|std::reverse}}) and returns {{c|false}}.

@1@ The set of all permutations is ordered lexicographically with respect to {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}}.

@2@ The set of all permutations is ordered lexicographically with respect to {{c|comp}}.

If {{rev inl|until=c++11|the type of {{c|*first}} is not {{named req|Swappable}}}}{{rev inl|since=c++11|{{tt|BidirIt}} is not {{named req|ValueSwappable}}}}, the behavior is undefined.

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to permute}}
{{par cmp|comp|p1=BidirIt}}
{{par hreq}}
{{par req named|BidirIt|BidirectionalIterator|ValueSwappable}}
{{par end}}

===Return value===
{{c|true}} if the new permutation precedes the old in lexicographical order. {{c|false}} if the first permutation was reached and the range was reset to the last permutation.

===Exceptions===
Any exceptions thrown from iterator operations or the element swap.

===Complexity===
Given {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first, last)}}:

@1,2@ At most {{mathjax-or|\(\scriptsize \frac{N}{2}\)|{{mfrac|N|2}}}} swaps.

===Possible implementation===
{{eq fun
|1=
template&lt;class BidirIt&gt;
bool prev_permutation(BidirIt first, BidirIt last)
{
    if (first == last)
        return false;
    BidirIt i = last;
    if (first == --i)
        return false;
    
    while (1)
    {
        BidirIt i1, i2;
        
        i1 = i;
        if (*i1 &lt; *--i)
        {
            i2 = last;
            while (!(*--i2 &lt; *i))
                ;
            std::iter_swap(i, i2);
            std::reverse(i1, last);
            return true;
        }
        
        if (i == first)
        {
            std::reverse(first, last);
            return false;
        }
    }
}
}}

===Notes===
Averaged over the entire sequence of permutations, typical implementations use about 3 comparisons and 1.5 swaps per call.

{{cpp/algorithm/notes swap vectorization}}

===Example===
{{example
|The following code prints all six permutations of the string {{c/core|"cab"}} in reverse order.
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::string s = "cab";
    
    do
    {
        std::cout &lt;&lt; s &lt;&lt; ' ';
    }
    while (std::prev_permutation(s.begin(), s.end()));
    
    std::cout &lt;&lt; s &lt;&lt; '\n';
}
|output=
cab bca bac acb abc cba
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc is_permutation}}
{{dsc inc|cpp/algorithm/dsc next_permutation}}
{{dsc inc|cpp/algorithm/ranges/dsc prev_permutation}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}