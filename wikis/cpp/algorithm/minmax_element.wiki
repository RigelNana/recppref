{{cpp/title|minmax_element}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcla|num=1|since=c++11|notes={{mark constexpr since c++17}}|
template&lt; class ForwardIt &gt;
std::pair&lt;ForwardIt, ForwardIt&gt;
    minmax_element( ForwardIt first, ForwardIt last );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt &gt;
std::pair&lt;ForwardIt, ForwardIt&gt;
    minmax_element( ExecutionPolicy&amp;&amp; policy,
                    ForwardIt first, ForwardIt last );
}}
{{dcla|num=3|since=c++11|notes={{mark constexpr since c++17}}|
template&lt; class ForwardIt, class Compare &gt;
std::pair&lt;ForwardIt, ForwardIt&gt;
    minmax_element( ForwardIt first, ForwardIt last, Compare comp );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt, class Compare &gt;
std::pair&lt;ForwardIt, ForwardIt&gt;
    minmax_element( ExecutionPolicy&amp;&amp; policy,
                    ForwardIt first, ForwardIt last, Compare comp );
}}
{{dcl end}}

Finds the smallest and greatest element in the range {{range|first|last}}.

@1@ Elements are compared using {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}}.

@3@ Elements are compared using the comparison function {{c|comp}}.

@2,4@ Same as {{v|1,3}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

===Parameters===
{{par begin}}
{{par|first, last|forward iterators defining the range to examine}}
{{par exec pol}}
{{par cmp|cmp|p1=ForwardIt}}
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par end}}

===Return value===
a pair consisting of an iterator to the smallest element as the first element and an iterator to the greatest element as the second. Returns {{c|std::make_pair(first, first)}} if the range is empty. If several elements are equivalent to the smallest element, the iterator to the first such element is returned. If several elements are equivalent to the largest element, the iterator to the last such element is returned.

===Complexity===
Given {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first, last)}}:

@1,2@ At most {{mathjax-or|\(\scriptsize \max(\left\lfloor \frac{3}{2}(N-1) \right\rfloor, 0)\)|max(⌊{{mfrac|3|2}}(N-1)⌋,0)}} comparisons using {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}}.

@3,4@ At most {{mathjax-or|\(\scriptsize \max(\left\lfloor \frac{3}{2}(N-1) \right\rfloor, 0)\)|max(⌊{{mfrac|3|2}}(N-1)⌋,0)}} applications of the comparison function {{c|comp}}.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===Possible implementation===
{{eq impl
|title1=minmax_element|ver1=1|1=
template&lt;class ForwardIt&gt;
std::pair&lt;ForwardIt, ForwardIt&gt;
    minmax_element(ForwardIt first, ForwardIt last)
{
    using value_type = typename std::iterator_traits&lt;ForwardIt&gt;::value_type;
    return std::minmax_element(first, last, std::less&lt;value_type&gt;());
}
|title2=minmax_element|ver2=3|2=
template&lt;class ForwardIt, class Compare&gt;
std::pair&lt;ForwardIt, ForwardIt&gt;
    minmax_element(ForwardIt first, ForwardIt last, Compare comp)
{
    auto min = first, max = first;
    
    if (first == last {{!!}} ++first == last)
        return {min, max};
    
    if (comp(*first, *min))
        min = first;
    else
        max = first;
    
    while (++first != last)
    {
        auto i = first;
        if (++first == last)
        {
            if (comp(*i, *min))
                min = i;
            else if (!(comp(*i, *max)))
                max = i;
            break;
        }
        else
        {
            if (comp(*first, *i))
            {
                if (comp(*first, *min))
                    min = first;
                if (!(comp(*i, *max)))
                    max = i;
            }
            else
            {
                if (comp(*i, *min))
                    min = i;
                if (!(comp(*first, *max)))
                    max = first;
            }
        }
    }
    return {min, max};
}
}}

===Notes===
This algorithm is different from {{c|std::make_pair(std::min_element(), std::max_element())}}, not only in efficiency, but also in that this algorithm finds the ''last'' biggest element while {{lc|std::max_element}} finds the ''first'' biggest element.

===Example===
{{example
|
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
 
int main()
{
    const auto v = {3, 9, 1, 4, 2, 5, 9};
    const auto [min, max] = std::minmax_element(begin(v), end(v));

    std::cout &lt;&lt; "min = " &lt;&lt; *min &lt;&lt; ", max = " &lt;&lt; *max &lt;&lt; '\n';
}
|output=
min = 1, max = 9
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc min_element}}
{{dsc inc|cpp/algorithm/dsc max_element}}
{{dsc inc|cpp/algorithm/ranges/dsc minmax_element}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}