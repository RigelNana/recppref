{{cpp/title|inplace_merge}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcla|num=1|constexpr=c++26|
template&lt; class BidirIt &gt;
void inplace_merge( BidirIt first, BidirIt middle, BidirIt last );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class BidirIt &gt;
void inplace_merge( ExecutionPolicy&amp;&amp; policy,
                    BidirIt first, BidirIt middle, BidirIt last );
}}
{{dcla|num=3|constexpr=c++26|
template&lt; class BidirIt, class Compare &gt;
void inplace_merge( BidirIt first, BidirIt middle, BidirIt last,
                    Compare comp );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy, class BidirIt, class Compare &gt;
void inplace_merge( ExecutionPolicy&amp;&amp; policy,
                    BidirIt first, BidirIt middle, BidirIt last,
                    Compare comp );
}}
{{dcl end}}

Merges two consecutive sorted ranges {{range|first|middle}} and {{range|middle|last}} into one sorted range {{range|first|last}}.

@1@ If {{range|first|middle}} or {{range|middle|last}} is not {{rlp|/#Requirements|sorted}} with respect to {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}}, the behavior is undefined.

@3@ If {{range|first|middle}} or {{range|middle|last}} is not sorted with respect to {{c|comp}}, the behavior is undefined.

@2,4@ Same as {{v|1,3}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

This merge function is stable, which means that for equivalent elements in the original two ranges, the elements from the first range (preserving their original order) precede the elements from the second range (preserving their original order).

If any of the following conditions is satisfied, the behavior is undefined:
* {{range|first|middle}} or {{range|middle|last}} is not a [[cpp/iterator#Ranges|valid range]].
{{rev begin}}
{{rev|until=c++11|
* The type of {{c|*first}} is not {{named req|Swappable}}.
}}
{{rev|since=c++11|
* {{tt|BiditIt}} is not {{named req|ValueSwappable}}.
* The type of {{c|*first}} is not {{named req|MoveConstructible}}.
* The type of {{c|*first}} is not {{named req|MoveAssignable}}.
}}
{{rev end}}

===Parameters===
{{par begin}}
{{par|first|the beginning of the first sorted range}}
{{par|middle|the end of the first sorted range and the beginning of the second}}
{{par|last|the end of the second sorted range}}
{{par exec pol}}
{{par cmp ord|comp|p1=BidirIt}}
{{par hreq}}
{{par req named|BidirIt|BidirectionalIterator}}
{{par req named|Compare|Compare}}
{{par end}}

===Complexity===
Given {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first, last)}}:

@1@ Exactly {{mathjax-or|\(\scriptsize N-1\)|N-1}} comparisons using {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}} if enough additional memory is available, {{mathjax-or|\(\scriptsize O(N \cdot \log(N))\)|O(N⋅log(N))}} comparisons otherwise.

@2@ {{mathjax-or|\(\scriptsize O(N \cdot \log(N))\)|O(N⋅log(N))}} comparisons using {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}}.

@3@ Exactly {{mathjax-or|\(\scriptsize N-1\)|N-1}} applications of the comparison function {{c|comp}} if enough additional memory is available, {{mathjax-or|\(\scriptsize O(N \cdot \log(N))\)|O(N⋅log(N))}} applications otherwise.

@4@ {{mathjax-or|\(\scriptsize O(N \cdot \log(N))\)|O(N⋅log(N))}} applications of the comparison function {{c|comp}}.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===Possible implementation===
See the implementations in [https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L2508 libstdc++] and [https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L4452 libc++].

===Notes===
This function attempts to allocate a temporary buffer. If the allocation fails, the less efficient algorithm is chosen.

{{feature test macro|__cpp_lib_constexpr_algorithms|{{c/core|constexpr}} inplace merging {{vl|1}}, {{vl|3}}|value=202306L|std=C++26}}

===Example===
{{example
|The following code is an implementation of merge sort.
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

template&lt;class Iter&gt;
void merge_sort(Iter first, Iter last)
{
    if (last - first &gt; 1)
    {
        Iter middle = first + (last - first) / 2;
        merge_sort(first, middle);
        merge_sort(middle, last);
        std::inplace_merge(first, middle, last);
    }
}

int main()
{
    std::vector&lt;int&gt; v{8, 2, -2, 0, 11, 11, 1, 7, 3};
    merge_sort(v.begin(), v.end());
    for (const auto&amp; n : v)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
-2 0 1 2 3 7 8 11 11
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc merge}}
{{dsc inc|cpp/algorithm/dsc sort}}
{{dsc inc|cpp/algorithm/dsc stable_sort}}
{{dsc inc|cpp/algorithm/ranges/dsc inplace_merge}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}