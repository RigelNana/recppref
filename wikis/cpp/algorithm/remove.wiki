{{cpp/title|remove|remove_if}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl rev begin|num=1}}
{{dcla|anchor=1|constexpr=c++20|until=c++26|
template&lt; class ForwardIt, class T &gt;
ForwardIt remove( ForwardIt first, ForwardIt last, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class ForwardIt, class T = typename std::iterator_traits
                                         &lt;ForwardIt&gt;::value_type &gt;
constexpr ForwardIt remove( ForwardIt first, ForwardIt last,
                            const T&amp; value );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++17|until=c++26|
template&lt; class ExecutionPolicy, class ForwardIt, class T &gt;
ForwardIt remove( ExecutionPolicy&amp;&amp; policy,
                  ForwardIt first, ForwardIt last, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class ExecutionPolicy, class ForwardIt,
          class T = typename std::iterator_traits
                        &lt;ForwardIt&gt;::value_type &gt;
ForwardIt remove( ExecutionPolicy&amp;&amp; policy,
                  ForwardIt first, ForwardIt last, const T&amp; value );
}}
{{dcl rev end}}
{{dcla|num=3|constexpr=c++20|
template&lt; class ForwardIt, class UnaryPred &gt;
ForwardIt remove_if( ForwardIt first, ForwardIt last, UnaryPred p );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt, class UnaryPred &gt;
ForwardIt remove_if( ExecutionPolicy&amp;&amp; policy,
                     ForwardIt first, ForwardIt last, UnaryPred p );
}}
{{dcl end}}

Removes all elements satisfying specific criteria from the range {{range|first|last}} and returns a past-the-end iterator for the new end of the range.

@1@ Removes all elements that are equal to {{c|value}} (using {{c/core|1=operator==}}).

@3@ Removes all elements for which predicate {{c|p}} returns {{c|true}}.

@2,4@ Same as {{v|1,3}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}


{{rev begin}}
{{rev|until=c++11|
If the [[cpp/iterator#Types and writability|value type]] of {{tt|ForwardIt}} is not {{named req|CopyAssignable}}, the behavior is undefined.
}}
{{rev|since=c++11|
If the type of {{c|*first}} is not {{named req|MoveAssignable}}, the behavior is undefined.
}}
{{rev end}}

===Explanation===
Removing is done by shifting the elements in the range in such a way that the elements that are not to be removed appear in the beginning of the range.
* Shifting is done by {{rev inl|until=c++11|{{lt|cpp/language/copy assignment}}}}{{rev inl|since=c++11|{{lt|cpp/language/move assignment}}}}.
* The removing operation is stable: the relative order of the elements not to be removed stays the same.
* The underlying sequence of {{range|first|last}} is not shortened by the removing operation. Given {{c|result}} as the returned iterator:
:* All iterators in {{range|result|last}} are still [[cpp/iterator#Dereferenceability and validity|dereferenceable]].
{{rrev|since=c++11|
:* Each element of {{range|result|last}} has a valid but unspecified state, because move assignment can eliminate elements by moving from elements that were originally in that range.
}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to process}}
{{par|value|the value of elements to remove}}
{{par exec pol}}
{{par pred1|p|if the element should be removed|p1=ForwardIt}}
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req named|UnaryPredicate|Predicate}}
{{par end}}

===Return value===
Past-the-end iterator for the new range of values (if this is not {{c|end}}, then it points to an unspecified value, and so do iterators to any values between this iterator and {{c|end}}).

===Complexity===
Given {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first, last)}}:
@1,2@ Exactly {{mathjax-or|\(\scriptsize N\)|N}} comparisons using {{c/core|1=operator==}}.
@3,4@ Exactly {{mathjax-or|\(\scriptsize N\)|N}} applications of the predicate {{c|p}}.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===Possible implementation===
{{eq impl
|title1=remove (1)|ver1=1|1=
template&lt;class ForwardIt, class T = typename std::iterator_traits&lt;ForwardIt&gt;::value_type&gt;
ForwardIt remove(ForwardIt first, ForwardIt last, const T&amp; value)
{
    first = std::find(first, last, value);
    if (first != last)
        for (ForwardIt i = first; ++i != last;)
            if (!(*i == value))
                *first++ = std::move(*i);
    return first;
}
|title2=remove_if (3)|ver2=3|2=
template&lt;class ForwardIt, class UnaryPred&gt;
ForwardIt remove_if(ForwardIt first, ForwardIt last, UnaryPred p)
{
    first = std::find_if(first, last, p);
    if (first != last)
        for (ForwardIt i = first; ++i != last;)
            if (!p(*i))
                *first++ = std::move(*i);
    return first;
}
}}

===Notes===
A call to {{tt|remove}} is typically followed by a call to a container's {{tt|erase}} member function to actually remove elements from the container. These two invocations together constitute a so-called {{enwiki|Erase-remove idiom}}.

{{rrev|since=c++20|
The same effect can also be achieved by the following non-member functions:
* {{lc|std::erase}}, which has [[cpp/container#Non-member function table|overloads]] for all standard sequence containers.
* {{lc|std::erase_if}}, which has [[cpp/container#Non-member function table|overloads]] for all standard containers.
}}

The similarly-named container [[cpp/container#Member function table|member functions]] {{l2tt|cpp/container/list/remove}}, {{l2tt|cpp/container/list/remove|remove_if}}, {{l2tt|cpp/container/forward_list/remove}}, and {{l2tt|cpp/container/forward_list/remove|remove_if}} erase the removed elements.

These algorithms cannot be used with associative containers such as {{lc|std::set}} and {{lc|std::map}} because their iterator types do not dereference to {{named req|MoveAssignable}} types (the keys in these containers are not modifiable).

The standard library also defines an overload of {{ltt std|cpp/io/c/remove}} in {{header|cstdio}}, which takes a {{c/core|const char*}} and is used to delete files.

Because {{tt|std::remove}} takes {{c|value}} by reference, it can have unexpected behavior if it is a reference to an element of the range {{range|first|last}}.

{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms {{vl|1,2}}}}

===Example===
{{example
|The following code removes all spaces from a string by shifting all non-space characters to the left and then erasing the extra. This is an example of {{enwiki|Erase-remove idiom}}.
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

int main()
{
    std::string str1{"Text with some   spaces"};
    
    auto noSpaceEnd = std::remove(str1.begin(), str1.end(), ' ');
    
    // The spaces are removed from the string only logically.
    // Note, we use view, the original string is still not shrunk:
    std::cout &lt;&lt; std::string_view(str1.begin(), noSpaceEnd) 
              &lt;&lt; " size: " &lt;&lt; str1.size() &lt;&lt; '\n';
    
    str1.erase(noSpaceEnd, str1.end());
    
    // The spaces are removed from the string physically.
    std::cout &lt;&lt; str1 &lt;&lt; " size: " &lt;&lt; str1.size() &lt;&lt; '\n';
    
    std::string str2 = "Text\n with\tsome \t  whitespaces\n\n";
    str2.erase(std::remove_if(str2.begin(), 
                              str2.end(),
                              [](unsigned char x) { return std::isspace(x); }),
               str2.end());
    std::cout &lt;&lt; str2 &lt;&lt; '\n';

    std::vector&lt;std::complex&lt;double&gt;&gt; nums{&lt;!----&gt;{2, 2}, {1, 3}, {4, 8}&lt;!----&gt;};
    #ifdef __cpp_lib_algorithm_default_value_type
        nums.erase(std::remove(nums.begin(), nums.end(), {1, 3}), nums.end());
    #else
        nums.erase(std::remove(nums.begin(), nums.end(), std::complex&lt;double&gt;{1, 3}),
                   nums.end());
    #endif
    assert((nums == std::vector&lt;std::complex&lt;double&gt;&gt;{&lt;!----&gt;{2, 2}, {4, 8}&lt;!----&gt;}));
}
|output=
Textwithsomespaces size: 23
Textwithsomespaces size: 18
Textwithsomewhitespaces
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=283|std=C++98|before={{tt|T}} was required to be {{named req|EqualityComparable}}, but&lt;br&gt;the value type of {{tt|ForwardIt}} is not always {{tt|T}}|after=required the value type of {{tt|ForwardIt}}&lt;br&gt;to be {{named req|CopyAssignable}} instead}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc remove_copy}}
{{dsc inc|cpp/algorithm/dsc unique}}
{{dsc inc|cpp/algorithm/ranges/dsc remove}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}