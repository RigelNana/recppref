{{cpp/title|copy|copy_if}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcla|num=1|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class OutputIt &gt;
OutputIt copy( InputIt first, InputIt last,
               OutputIt d_first );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2 &gt;
ForwardIt2 copy( ExecutionPolicy&amp;&amp; policy,
                 ForwardIt1 first, ForwardIt1 last,
                 ForwardIt2 d_first );
}}
{{dcla|num=3|since=c++11|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class OutputIt, class UnaryPred &gt;
OutputIt copy_if( InputIt first, InputIt last,
                  OutputIt d_first, UnaryPred pred );
}}
{{dcl|num=4|since=c++17|1=
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2, class UnaryPred &gt;
ForwardIt2 copy_if( ExecutionPolicy&amp;&amp; policy,
                    ForwardIt1 first, ForwardIt1 last,
                    ForwardIt2 d_first, UnaryPred pred );
}}
{{dcl end}}

Copies the elements in the range, defined by {{range|first|last}}, to another range beginning at {{c|d_first}} (copy destination range).

@1@ Copies all elements in the range {{range|first|last}} starting from {{c|first}} and proceeding to {{c|last}}.
@@ If {{c|d_first}} is in {{range|first|last}}, the behavior is undefined. In this case, {{lc|std::copy_backward}} may be used instead.

@2@ Copies the elements, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition}}
@@ If {{range|first|last}} and the copy destination range overlaps, the behavior is undefined.

@3@ Only copies the elements for which the predicate {{c|pred}} returns {{c|true}}. This copy algorithm is stable: the relative order of the elements that are copied is preserved.
@@ If {{range|first|last}} and the copy destination range overlaps, the behavior is undefined.

@4@ Same as {{v|3}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to copy}}
{{par|d_first|the beginning of the destination range}}
{{par exec pol}}
{{par pred1|pred|value=true|for the required elements|p1=InputIt}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|OutputIt|OutputIterator}}
{{par req named|ForwardIt1, ForwardIt2|ForwardIterator}}
{{par req named|UnaryPred|Predicate}}
{{par end}}

===Return value===
Output iterator to the element in the destination range, one past the last element copied.

===Complexity===
Given {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first, last)}}:
@1,2@ Exactly {{mathjax-or|\(\scriptsize N\)|N}} assignments.
@3,4@ Exactly {{mathjax-or|\(\scriptsize N\)|N}} applications of the predicate {{c|pred}}, and at most {{mathjax-or|\(\scriptsize N\)|N}} assignments.

For the overloads with an {{tt|ExecutionPolicy}}, there may be a performance cost if {{tt|ForwardIt1}}'s value type is not {{named req|MoveConstructible}}.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===Possible implementation===
{{eq impl
|title1=copy (1)|ver1=1|1=
template&lt;class InputIt, class OutputIt&gt;
OutputIt copy(InputIt first, InputIt last,
              OutputIt d_first)
{
    for (; first != last; (void)++first, (void)++d_first)
        *d_first = *first;
    
    return d_first;
}
|title2=copy_if (3)|ver2=3|2=
template&lt;class InputIt, class OutputIt, class UnaryPred&gt;
OutputIt copy_if(InputIt first, InputIt last,
                 OutputIt d_first, UnaryPred pred)
{
    for (; first != last; (void)++first)
        if (pred(*first))
        {
            *d_first = *first;
            (void)++d_first;
        }
    
    return d_first;
}
}}

===Notes===
In practice, implementations of {{tt|std::copy}} avoid multiple assignments and use bulk copy functions such as {{lc|std::memmove}} if the value type is {{named req|TriviallyCopyable}} and the iterator types satisfy {{named req|ContiguousIterator}}.

When copying overlapping ranges, {{tt|std::copy}} is appropriate when copying to the left (beginning of the destination range is outside the source range) while {{tt|std::copy_backward}} is appropriate when copying to the right (end of the destination range is outside the source range).

===Example===
{{example
|The following code uses {{tt|std::copy}} to both copy the contents of one {{lc|std::vector}} to another and to display the resulting {{lc|std::vector}}.
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; from_vector(10);
    std::iota(from_vector.begin(), from_vector.end(), 0);
    
    std::vector&lt;int&gt; to_vector;
    std::copy(from_vector.begin(), from_vector.end(),
              std::back_inserter(to_vector));
// or, alternatively,
//  std::vector&lt;int&gt; to_vector(from_vector.size());
//  std::copy(from_vector.begin(), from_vector.end(), to_vector.begin());
// either way is equivalent to
//  std::vector&lt;int&gt; to_vector = from_vector;
    
    std::cout &lt;&lt; "to_vector contains: ";
    
    std::copy(to_vector.begin(), to_vector.end(),
              std::ostream_iterator&lt;int&gt;(std::cout, " "));
    std::cout &lt;&lt; '\n';
    
    std::cout &lt;&lt; "odd numbers in to_vector are: ";
    
    std::copy_if(to_vector.begin(), to_vector.end(),
                 std::ostream_iterator&lt;int&gt;(std::cout, " "),
                 [](int x) { return x % 2 != 0; });
    std::cout &lt;&lt; '\n';
    
    std::cout &lt;&lt; "to_vector contains these multiples of 3: ";
    
    to_vector.clear();
    std::copy_if(from_vector.begin(), from_vector.end(),
                 std::back_inserter(to_vector),
                 [](int x) { return x % 3 == 0; });
    
    for (const int x : to_vector)
        std::cout &lt;&lt; x &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|p=true
|output=
to_vector contains: 0 1 2 3 4 5 6 7 8 9
odd numbers in to_vector are: 1 3 5 7 9
to_vector contains these multiples of 3: 0 3 6 9
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2039|std=C++11|before=the return value of {{tt|std::copy_if}} was not specified|after=specified}}
{{dr list item|wg=lwg|dr=2044|std=C++11|before=the stability of {{tt|std::copy_if}} was not defined|after=defined}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc copy_backward}}
{{dsc inc|cpp/algorithm/dsc reverse_copy}}
{{dsc inc|cpp/algorithm/dsc copy_n}}
{{dsc inc|cpp/algorithm/dsc fill}}
{{dsc inc|cpp/algorithm/dsc remove_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc copy}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}