{{cpp/title|stable_partition}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcla|num=1|constexpr=c++26|
template&lt; class BidirIt, class UnaryPred &gt;
BidirIt stable_partition( BidirIt first, BidirIt last, UnaryPred p );
}}
{{dcl|since=c++17|num=2|
template&lt; class ExecutionPolicy, class BidirIt, class UnaryPred &gt;
BidirIt stable_partition( ExecutionPolicy&amp;&amp; policy,
                          BidirIt first, BidirIt last, UnaryPred p );
}}
{{dcl end}}

@1@ Reorders the elements in the range {{range|first|last}} in such a way that all elements for which the predicate {{c|p}} returns {{c|true}} precede the elements for which predicate {{c|p}} returns {{c|false}}. Relative order of the elements is preserved.

@2@ Same as {{v|1}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition}}

If any of the following conditions is satisfied, the behavior is undefined:
{{rev begin}}
{{rev|until=c++11|
* The type of {{c|*first}} is not {{named req|Swappable}}.
}}
{{rev|since=c++11|
* {{tt|BidirIt}} is not {{named req|ValueSwappable}}.
* The type of {{c|*first}} is not {{named req|MoveConstructible}}.
* The type of {{c|*first}} is not {{named req|MoveAssignable}}.
}}
{{rev end}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to reorder}}
{{par exec pol}}
{{par pred1|p|if the element should be ordered before other elements|p1=BidirIt}}
{{par hreq}}
{{par req named|BidirIt|BidirectionalIterator}}
{{par req named|UnaryPred|Predicate}}
{{par end}}

===Return value===
Iterator to the first element of the second group.

===Complexity===
Given {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first, last)}}:

@1@ Exactly {{mathjax-or|\(\scriptsize N\)|N}} applications of {{c|p}}.
@@ {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} swaps if there is enough extra memory, otherwise at most {{mathjax-or|\(\scriptsize N \cdot log_{2}(N)\)|N⋅log{{su|b=2}}(N)}} swaps.

@2@ {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} applications of {{c|p}}.
@@ {{mathjax-or|\(\scriptsize N \cdot log(N)\)|N⋅log(N)}} swaps.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=yes}}

===Notes===
This function attempts to allocate a temporary buffer. If the allocation fails, the less efficient algorithm is chosen.

Implementations in [https://github.com/llvm/llvm-project/blob/eda14ebf6a43d9ada6a2be3d1b06b8b6036eb774/libcxx/include/__algorithm/stable_partition.h#L316 libc++] and [https://github.com/gcc-mirror/gcc/blob/d2a499a9881c7c079d2a722b57c7fcf022a864dd/libstdc%2B%2B-v3/include/bits/stl_algo.h#L1608 libstdc++] also accept ranges denoted by {{named req|ForwardIterator}}s as an extension.

{{feature test macro|__cpp_lib_constexpr_algorithms|{{c/core|constexpr}} stable sorting {{vl|1}}|value=202306L|std=C++26}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; v{0, 0, 3, -1, 2, 4, 5, 0, 7};
    std::stable_partition(v.begin(), v.end(), [](int n) { return n &gt; 0; });
    for (int n : v)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
3 2 4 5 7 0 0 -1 0
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2150|std=C++98|before={{tt|std::stable_partition}} was only required to place one&lt;br&gt;element satisfying {{c|p}} before one element not satisfying {{c|p}}|after=corrected the&lt;br&gt;requirement}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc partition}}
{{dsc inc|cpp/algorithm/ranges/dsc stable_partition}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}