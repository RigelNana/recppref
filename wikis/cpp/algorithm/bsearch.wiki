{{cpp/title|bsearch}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|cstdlib}}
{{dcl|num=1|
void* bsearch( const void* key, const void* ptr, std::size_t count,
               std::size_t size, /* c-compare-pred */* comp );
void* bsearch( const void* key, const void* ptr, std::size_t count,
               std::size_t size, /* compare-pred */* comp );
}}
{{dcl|num=2|notes={{mark expos}}|1=
extern "C" using /* c-compare-pred */ = int(const void*, const void*);
extern "C++" using /* compare-pred */ = int(const void*, const void*);
}}
{{dcl end}}

Finds an element equal to element pointed to by {{c|key}} in an array pointed to by {{c|ptr}}. The array contains {{c|count}} elements of {{c|size}} bytes each and must be partitioned with respect to the object pointed to by {{c|key}}, that is, all the elements that compare less than must appear before all the elements that compare equal to, and those must appear before all the elements that compare greater than the key object. A fully sorted array satisfies these requirements. The elements are compared using function pointed to by {{c|comp}}. 

The behavior is undefined if the array is not already partitioned in ascending order with respect to key, according to the same criterion that {{c|comp}} uses.

If the array contains several elements that {{c|comp}} would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result.

===Parameters===
{{par begin}}
{{par|key|pointer to the element to search for}}
{{par|ptr|pointer to the array to examine}}
{{par|count|number of element in the array}}
{{par|size|size of each element in the array in bytes}}
{{par ccmp|comp|{{c|key}} is passed as the first argument, an element from the array as the second.}}
{{par end}}

===Return value===
Pointer to the found element or null pointer if the element has not been found.

===Notes===
Despite the name, neither C nor POSIX standards require this function to be implemented using binary search or make any complexity guarantees.

The two overloads provided by the C++ standard library are distinct because the types of the parameter {{c|comp}} are distinct ({{ls|cpp/language#language linkage}} is part of its type).

===Example===
{{example
|
|code=
#include &lt;array&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;

template&lt;typename T&gt;
int compare(const void *a, const void *b)
{
    const auto &amp;arg1 = *(static_cast&lt;const T*&gt;(a));
    const auto &amp;arg2 = *(static_cast&lt;const T*&gt;(b));
    const auto cmp = arg1 &lt;=&gt; arg2;
    return cmp &lt; 0 ? -1
        :  cmp &gt; 0 ? +1
        :  0;
}

int main()
{
    std::array arr{1, 2, 3, 4, 5, 6, 7, 8};
    
    for (const int key : {4, 8, 9})
    {
        const int* p = static_cast&lt;int*&gt;(
            std::bsearch(&amp;key,
                arr.data(),
                arr.size(),
                sizeof(decltype(arr)::value_type),
                compare&lt;int&gt;));
        
        std::cout &lt;&lt; "value " &lt;&lt; key;
        if (p)
            std::cout &lt;&lt; " found at position " &lt;&lt; (p - arr.data()) &lt;&lt; '\n';
        else
            std::cout &lt;&lt; " not found\n";
    }
}
|output=
value 4 found at position 3
value 8 found at position 7
value 9 not found
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc qsort}}
{{dsc inc|cpp/algorithm/dsc equal_range}}
{{dsc see c|c/algorithm/bsearch}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}