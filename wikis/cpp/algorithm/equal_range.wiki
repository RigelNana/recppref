{{cpp/title|equal_range}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl rev begin|num=1}}
{{dcla|anchor=1|constexpr=c++20|until=c++26|
template&lt; class ForwardIt, class T &gt;
std::pair&lt;ForwardIt, ForwardIt&gt; 
    equal_range( ForwardIt first, ForwardIt last, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class ForwardIt, class T = typename std::iterator_traits
                                         &lt;ForwardIt&gt;::value_type &gt;
constexpr std::pair&lt;ForwardIt, ForwardIt&gt; 
    equal_range( ForwardIt first, ForwardIt last, const T&amp; value );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcla|anchor=2|constexpr=c++20|until=c++26|
template&lt; class ForwardIt, class T, class Compare &gt;
std::pair&lt;ForwardIt, ForwardIt&gt; 
    equal_range( ForwardIt first, ForwardIt last,
                 const T&amp; value, Compare comp );
}}
{{dcl|since=c++26|1=
template&lt; class ForwardIt, class T = typename std::iterator_traits
                                         &lt;ForwardIt&gt;::value_type,
          class Compare &gt;
constexpr std::pair&lt;ForwardIt, ForwardIt&gt; 
    equal_range( ForwardIt first, ForwardIt last,
                 const T&amp; value, Compare comp );
}}
{{dcl end}}

Returns a range containing all elements equivalent to {{c|value}} in the partitioned range {{range|first|last}}.

@1@ The equivalence is checked using {{c/core|operator&lt;}}:
{{rev begin}}
{{rev|until=c++20|
Returns the results of {{c|std::lower_bound(first, last, value)}} and {{c|std::upper_bound(first, last, value)}}.

If any of the following conditions is satisfied, the behavior is undefined:
* For any element {{c|elem}} of {{range|first|last}}, {{c|bool(elem &lt; value)}} does not imply {{c|!bool(value &lt; elem)}}.
* The elements {{c|elem}} of {{range|first|last}} are not {{rlp|/#Requirements|partitioned}} with respect to expressions {{c|bool(elem &lt; value)}} and {{c|!bool(value &lt; elem)}}.
}}
{{rev|since=c++20|
Equivalent to {{c|std::equal_range(first, last, value, std::less{})}}.
}}
{{rev end}}

@2@ The equivalence is checked using {{c|comp}}:
@@ Returns the results of {{c|std::lower_bound(first, last, value, comp)}} and {{c|std::upper_bound(first, last, value, comp)}}.
@@ If any of the following conditions is satisfied, the behavior is undefined:
* For any element {{c|elem}} of {{range|first|last}}, {{c|bool(comp(elem, value))}} does not imply {{c|!bool(comp(value, elem))}}.
* The elements {{c|elem}} of {{range|first|last}} are not {{rlp|/#Requirements|partitioned}} with respect to expressions {{c|bool(comp(elem, value))}} and {{c|!bool(comp(value, elem))}}.

===Parameters===
{{par begin}}
{{par|first, last|the partitioned range of elements to examine}}
{{par|value|value to compare the elements to}}
{{par pred2|comp|if the first argument is ordered before the second|bidirectional=true|t1=T|p2=ForwardIt}} 
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req named|Compare|BinaryPredicate|notes=It is not required to satisfy {{named req|Compare}}.}}
{{par end}}

===Return value===
A {{lc|std::pair}} containing a pair of iterators, where
* {{tt|first}} is an iterator to the first element of the range {{range|first|last}} not ordered before {{c|value}} (or {{c|last}} if no such element is found), and
* {{tt|second}} is an iterator to the first element of the range {{range|first|last}} ordered after {{c|value}} (or {{c|last}} if no such element is found).

===Complexity===
Given {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first, last)}}:

@1@ At most {{mathjax-or|\(\scriptsize 2\log_{2}(N)+O(1)\)|2log{{su|b=2}}(N)+O(1)}} comparisons with {{c|value}} using {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}}.

@2@ At most {{mathjax-or|\(\scriptsize 2\log_{2}(N)+O(1)\)|2log{{su|b=2}}(N)+O(1)}} applications of the comparator {{c|comp}}.

However, if {{tt|ForwardIt}} is not a {{named req|RandomAccessIterator}}, the number of iterator increments is linear in {{mathjax-or|\(\scriptsize N\)|N}}. Notably, {{lc|std::set}} and {{lc|std::multiset}} iterators are not random access, and so their member functions {{lc|std::set::equal_range}} (resp. {{lc|std::multiset::equal_range}}) should be preferred.

===Notes===
Although {{tt|std::equal_range}} only requires {{range|first|last}} to be partitioned, this algorithm is usually used in the case where {{range|first|last}} is sorted, so that the binary search is valid for any {{c|value}}.

On top of the requirements of {{lc|std::lower_bound}} and {{lc|std::upper_bound}}, {{tt|std::equal_range}} also requires {{c/core|operator&lt;}} or {{c|comp}} to be asymmetric (i.e., {{c|a &lt; b}} and {{c|b &lt; a}} always have different results).

Therefore, the intermediate results of binary search can be shared by {{lc|std::lower_bound}} and {{lc|std::upper_bound}}. For example, the result of the {{lc|std::lower_bound}} call can be used as the argument of {{tt|first}} in the {{lc|std::upper_bound}} call.

{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms {{vl|1,2}}}}

===Possible implementation===
{{eq impl|title1=equal_range (1)|ver1=1|1=
template&lt;class ForwardIt,
         class T = typename std::iterator_traits&lt;ForwardIt&gt;::value_type&gt;
constexpr std::pair&lt;ForwardIt, ForwardIt&gt; 
    equal_range(ForwardIt first, ForwardIt last, const T&amp; value)
{
    return std::equal_range(first, last, value, std::less{});
}
|title2=equal_range (2)|ver2=2|2=
template&lt;class ForwardIt,
         class T = typename std::iterator_traits&lt;ForwardIt&gt;::value_type,
         class Compare&gt;
constexpr std::pair&lt;ForwardIt, ForwardIt&gt;
    equal_range(ForwardIt first, ForwardIt last, const T&amp; value, Compare comp)
{
    return std::make_pair(std::lower_bound(first, last, value, comp),
                          std::upper_bound(first, last, value, comp));
}
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct S
{
    int number;
    char name;
    // note: name is ignored by this comparison operator
    bool operator&lt;(const S&amp; s) const { return number &lt; s.number; }
};

struct Comp
{
    bool operator()(const S&amp; s, int i) const { return s.number &lt; i; }
    bool operator()(int i, const S&amp; s) const { return i &lt; s.number; }
};

int main()
{
    // note: not ordered, only partitioned w.r.t. S defined below
    const std::vector&lt;S&gt; vec{&lt;!----&gt;{1, 'A'}, {2, 'B'}, {2, 'C'},
                             {2, 'D'}, {4, 'G'}, {3, 'F'}&lt;!----&gt;};
    const S value{2, '?'};
    
    std::cout &lt;&lt; "Compare using S::operator&lt;(): ";
    const auto p = std::equal_range(vec.begin(), vec.end(), value);
    
    for (auto it = p.first; it != p.second; ++it)
        std::cout &lt;&lt; it-&gt;name &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
    
    std::cout &lt;&lt; "Using heterogeneous comparison: ";
    const auto p2 = std::equal_range(vec.begin(), vec.end(), 2, Comp{});
    
    for (auto it = p2.first; it != p2.second; ++it)
        std::cout &lt;&lt; it-&gt;name &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    using CD = std::complex&lt;double&gt;;
    std::vector&lt;CD&gt; nums{&lt;!----&gt;{1, 0}, {2, 2}, {2, 1}, {3, 0}, {3, 1}&lt;!----&gt;};
    auto cmpz = [](CD x, CD y) { return x.real() &lt; y.real(); };
    #ifdef __cpp_lib_algorithm_default_value_type
        auto p3 = std::equal_range(nums.cbegin(), nums.cend(), {2, 0}, cmpz);
    #else
        auto p3 = std::equal_range(nums.cbegin(), nums.cend(), CD{2, 0}, cmpz);
    #endif

    for (auto it = p3.first; it != p3.second; ++it)
        std::cout &lt;&lt; *it &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
Compare using S::operator&lt;(): B C D 
Using heterogeneous comparison: B C D
(2,2) (2, 1)
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=270|std=C++98|before={{tt|Compare}} was required to satisfy {{named req|Compare}} and {{tt|T}} was required&lt;br&gt;to be {{named req|LessThanComparable}} (strict weak ordering required)|after=only a partitioning is required;&lt;br&gt;heterogeneous comparisons permitted}}
{{dr list item|wg=lwg|dr=384|std=C++98|before=at most {{mathjax-or|\(\scriptsize 2\log_{2}(N)+1\)|2log{{su|b=2}}(N)+1}} comparisons&lt;br&gt;were allowed, which is not implementable&lt;ref&gt;Applying {{tt|equal_range}} to a single-element range requires 2 comparisons, but at most 1 comparison is allowed by the complexity requirement.&lt;/ref&gt;|after=corrected to {{mathjax-or|\(\scriptsize 2\log_{2}(N)+O(1)\)|2log{{su|b=2}}(N)+O(1)}}}}
{{dr list end}}
&lt;references/&gt;

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc lower_bound}}
{{dsc inc|cpp/algorithm/dsc upper_bound}}
{{dsc inc|cpp/algorithm/dsc binary_search}}
{{dsc inc|cpp/algorithm/dsc partition}}
{{dsc inc|cpp/algorithm/dsc equal}}
{{dsc inc|cpp/container/dsc equal_range|set}}
{{dsc inc|cpp/container/dsc equal_range|multiset}}
{{dsc inc|cpp/algorithm/ranges/dsc equal_range}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}