{{cpp/title|next_permutation}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|num=1|notes={{mark constexpr since c++20}}|
template&lt; class BidirIt &gt;
bool next_permutation( BidirIt first, BidirIt last );
}}
{{dcl|num=2|notes={{mark constexpr since c++20}}|
template&lt; class BidirIt, class Compare &gt;
bool next_permutation( BidirIt first, BidirIt last, Compare comp );
}}
{{dcl end}}

Permutes the range {{range|first|last}} into the next {{enwiki|permutation}}. Returns {{c|true}} if such a “next permutation” exists; otherwise transforms the range into the lexicographically first permutation (as if by {{lc|std::sort}}) and returns {{c|false}}.

@1@ The set of all permutations is ordered lexicographically with respect to {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}}.

@2@ The set of all permutations is ordered lexicographically with respect to {{c|comp}}.

If {{rev inl|until=c++11|the type of {{c|*first}} is not {{named req|Swappable}}}}{{rev inl|since=c++11|{{tt|BidirIt}} is not {{named req|ValueSwappable}}}}, the behavior is undefined.

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to permute}}
{{par cmp|comp|p1=BidirIt}}
{{par hreq}}
{{par req named|BidirIt|BidirectionalIterator}}
{{par end}}

===Return value===
{{c|true}} if the new permutation is lexicographically greater than the old. {{c|false}} if the last permutation was reached and the range was reset to the first permutation.

===Complexity===
Given {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first, last)}}:

@1,2@ At most {{mathjax-or|\(\scriptsize \frac{N}{2}\)|{{mfrac|N|2}}}} swaps.

===Exceptions===
Any exceptions thrown from iterator operations or the element swap.

===Possible implementation===
{{eq fun
|1=
template&lt;class BidirIt&gt;
bool next_permutation(BidirIt first, BidirIt last)
{
    auto r_first = std::make_reverse_iterator(last);
    auto r_last = std::make_reverse_iterator(first);
    auto left = std::is_sorted_until(r_first, r_last);
    
    if (left != r_last)
    {
        auto right = std::upper_bound(r_first, left, *left);
        std::iter_swap(left, right);
    }
    
    std::reverse(left.base(), last);
    return left != r_last;
}
}}

===Notes===
Averaged over the entire sequence of permutations, typical implementations use about 3 comparisons and 1.5 swaps per call.

{{cpp/algorithm/notes swap vectorization}}

===Example===
{{example
|The following code prints all three permutations of the string {{c/core|"aba"}}.
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::string s = "aba";
    
    do
    {
        std::cout &lt;&lt; s &lt;&lt; '\n';
    }
    while (std::next_permutation(s.begin(), s.end()));
    
    std::cout &lt;&lt; s &lt;&lt; '\n';
}
|output=
aba
baa
aab
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc is_permutation}}
{{dsc inc|cpp/algorithm/dsc prev_permutation}}
{{dsc inc|cpp/algorithm/ranges/dsc next_permutation}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}