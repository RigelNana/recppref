{{cpp/title|partition_copy}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcla|num=1|since=c++11|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class OutputIt1,
          class OutputIt2, class UnaryPred &gt;
std::pair&lt;OutputIt1, OutputIt2&gt;
    partition_copy( InputIt first, InputIt last,
                    OutputIt1 d_first_true, OutputIt2 d_first_false,
                    UnaryPred p );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt1, class ForwardIt2,
          class ForwardIt3, class UnaryPred &gt;
std::pair&lt;ForwardIt2, ForwardIt3&gt;
    partition_copy( ExecutionPolicy&amp;&amp; policy,
                    ForwardIt1 first, ForwardIt1 last,
                    ForwardIt2 d_first_true, ForwardIt3 d_first_false,
                    UnaryPred p );
}}
{{dcl end}}

@1@ Copies the elements from the range {{range|first|last}} to two different ranges depending on the value returned by the predicate {{c|p}}.
* The elements that satisfy the predicate {{c|p}} are copied to the range beginning at {{c|d_first_true}}.
* The rest of the elements are copied to the range beginning at {{c|d_first_false}}.

@2@ Same as {{v|1}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition}}

If {{c|*first}} is not [[cpp/iterator#Types and writability|writable]] to {{c|d_first_true}} or {{c|d_first_false}}, the program is ill-formed.

Among the input range and the two output ranges, if any two ranges overlap, the behavior is undefined.

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to copy from}}
{{par|d_first_true|the beginning of the output range for the elements that satisfy {{c|p}}}}
{{par|d_first_false|the beginning of the output range for the elements that do not satisfy {{c|p}}}}
{{par exec pol}}
{{par pred1|p|if the element should be placed in d_first_true|p1=InputIt}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|OutputIt1, OutputIt2|OutputIterator}}
{{par req named|ForwardIt1, ForwardIt2, ForwardIt3|ForwardIterator}}
{{par req named|UnaryPred|Predicate}}
{{par end}}

===Return value===
A {{lc|std::pair}} constructed from the iterator to the end of the {{c|d_first_true}} range and the iterator to the end of the {{c|d_first_false}} range.

===Complexity===
Exactly {{c|std::distance(first, last)}} applications of {{c|p}}.

For the overload {{v|2}}, there may be a performance cost if {{tt|ForwardIt}}'s value type is not {{named req|CopyConstructible}}.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=yes}}

===Possible implementation===
{{eq impl|title1=partition_copy (1)|ver1=1|1=
template&lt;class InputIt, class OutputIt1,
         class OutputIt2, class UnaryPred&gt;
constexpr //&lt; since C++20
std::pair&lt;OutputIt1, OutputIt2&gt;
    partition_copy(InputIt first, InputIt last,
                   OutputIt1 d_first_true, OutputIt2 d_first_false,
                   UnaryPred p)
{
    for (; first != last; ++first)
    {
        if (p(*first))
        {
            *d_first_true = *first;
            ++d_first_true;
        }
        else
        {
            *d_first_false = *first;
            ++d_first_false;
        }
    }
    
    return std::pair&lt;OutputIt1, OutputIt2&gt;(d_first_true, d_first_false);
}
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;

void print(auto rem, const auto&amp; v)
{
    for (std::cout &lt;&lt; rem; const auto&amp; x : v)
        std::cout &lt;&lt; x &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    int arr[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int true_arr[5] = {0};
    int false_arr[5] = {0};
    
    std::partition_copy(std::begin(arr), std::end(arr),
                        std::begin(true_arr), std::begin(false_arr),
                        [](int i) { return 4 &lt; i; });
    
    print("true_arr:  ", true_arr);
    print("false_arr: ", false_arr);
}
|output=
true_arr:  5 6 7 8 9
false_arr: 0 1 2 3 4
}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P0896R4|std=C++11&lt;br&gt;C++17|before=1. the value type of {{tt|InputIt}} (C++11)/{{tt|ForwardIt1}} (C++17)&lt;br&gt;{{nbsp|4}}was required to be {{named req|CopyAssignable}}&lt;br&gt;2. the two output ranges could overlap|after=1. not required&lt;br&gt;2. the behavior is&lt;br&gt;{{nbsp|4}}undefined in this case}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc partition}}
{{dsc inc|cpp/algorithm/dsc stable_partition}}
{{dsc inc|cpp/algorithm/dsc copy}}
{{dsc inc|cpp/algorithm/dsc remove_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc partition_copy}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}