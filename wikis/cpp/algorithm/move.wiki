{{cpp/title|move}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|num=1|since=c++11|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class OutputIt &gt;
OutputIt move( InputIt first, InputIt last,
               OutputIt d_first );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt1, class ForwardIt2 &gt;
ForwardIt2 move( ExecutionPolicy&amp;&amp; policy,
                 ForwardIt1 first, ForwardIt1 last,
                 ForwardIt2 d_first );
}}
{{dcl end}}

@1@ Moves the elements in the range {{range|first|last}}, to another range beginning at {{c|d_first}}, starting from first and proceeding to {{c|last}}. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.

@2@ Same as {{v|1}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition}}

If {{c|d_first}} is within the range {{range|first|last}}, the behavior is undefined. In this case, {{lc|std::move_backward}} may be used instead.

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to move}}
{{par|d_first|the beginning of the destination range}}
{{par exec pol}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|OutputIt|OutputIterator}}
{{par req named|ForwardIt1, ForwardIt2|ForwardIterator}}
{{par end}}

===Return value===
The iterator to the element past the last element moved.

===Complexity===
Exactly {{c|std::distance(first, last)}} move assignments.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=yes}}

===Possible implementation===
{{eq fun|1=
template&lt;class InputIt, class OutputIt&gt;
OutputIt move(InputIt first, InputIt last, OutputIt d_first)
{
    for (; first != last; ++d_first, ++first)
        *d_first = std::move(*first);
    
    return d_first;
}
}}

===Notes===
When moving overlapping ranges, {{tt|std::move}} is appropriate when moving to the left (beginning of the destination range is outside the source range) while {{lc|std::move_backward}} is appropriate when moving to the right (end of the destination range is outside the source range).

===Example===
The following code moves thread objects (which themselves are not copyable) from one container to another.

{{example
|code=
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;list&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

void f(int n)
{
    std::this_thread::sleep_for(std::chrono::seconds(n));
    std::cout &lt;&lt; "thread " &lt;&lt; n &lt;&lt; " ended" &lt;&lt; std::endl;
}

int main()
{
    std::vector&lt;std::jthread&gt; v;
    v.emplace_back(f, 1);
    v.emplace_back(f, 2);
    v.emplace_back(f, 3);
    std::list&lt;std::jthread&gt; l;
    
    // copy() would not compile, because std::jthread is noncopyable
    std::move(v.begin(), v.end(), std::back_inserter(l));
}
|output=
thread 1 ended
thread 2 ended
thread 3 ended
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc move_backward}}
{{dsc inc|cpp/utility/dsc move}}
{{dsc inc|cpp/algorithm/ranges/dsc move}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}