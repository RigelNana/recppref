{{cpp/title|iota}}
{{cpp/algorithm/numeric/navbar}}
{{ddcl|header=numeric|since=c++11|notes={{mark constexpr since c++20}}|
template&lt; class ForwardIt, class T &gt;
void iota( ForwardIt first, ForwardIt last, T value );
}}

Fills the range {{range|first|last}} with sequentially increasing values, starting with {{c|value}} and repetitively evaluating {{c|++value}}.

Equivalent operation (assuming {{c|++value}} returns the incremented value):
{{source|1=
*first   = value;
*++first = ++value;
*++first = ++value;
*++first = ++value;
// repeats until “last” is reached
}}

If any of the following conditions is satisfied, the program is ill-formed:
* {{tt|T}} is not convertible to the [[cpp/iterator#Types and writability|value type]] of {{tt|ForwardIt}}.
* The expression {{c|++val}} is ill-formed, where {{c|val}} is a variable of type {{tt|T}}.

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to fill with sequentially increasing values starting with {{c|value}}}}
{{par|value|initial value to store}}
{{par end}}

===Complexity===
Exactly {{c|std::distance(first, last)}} increments and assignments.

===Possible implementation===
{{eq fun
|1=
template&lt;class ForwardIt, class T&gt;
constexpr // since C++20
void iota(ForwardIt first, ForwardIt last, T value)
{
    for (; first != last; ++first, ++value)
        *first = value;
}
}}

===Notes===
The function is named after the integer function &lt;span style="font-size: 1.5em"&gt;⍳&lt;/span&gt; &lt;!-- ⍳ : U+2373 APL FUNCTIONAL SYMBOL IOTA --&gt; from the programming language {{enwiki|APL (programming language)|APL}}. It was one of the [https://web.archive.org/web/20220816102741/http://www.martinbroadhurst.com/stl/iota.html STL components] that were not included in C++98, but made it into the standard library in C++11.

===Example===
{{example
|The following example applies {{lc|std::shuffle}} to a {{lc|std::vector|vector}} of {{lc|std::list}}s' iterators. {{tt|std::iota}} is used to populate containers.
|code=
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;numeric&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

class BigData // inefficient to copy
{
    int data[1024]; /* some raw data */
public:
    explicit BigData(int i = 0) { data[0] = i; /* ... */ }
    operator int() const { return data[0]; }
    BigData&amp; operator=(int i) { data[0] = i; return *this; }
    /* ... */
};

int main()
{
    std::list&lt;BigData&gt; l(10);
    std::iota(l.begin(), l.end(), -4);
    
    std::vector&lt;std::list&lt;BigData&gt;::iterator&gt; v(l.size());
    std::iota(v.begin(), v.end(), l.begin());
    // Vector of iterators (to original data) is used to avoid expensive copying,
    // and because std::shuffle (below) cannot be applied to a std::list directly.
    
    std::shuffle(v.begin(), v.end(), std::mt19937{std::random_device{}()});
    
    std::cout &lt;&lt; "Original contents of the list l:\t";
    for (const auto&amp; n : l)
        std::cout &lt;&lt; std::setw(2) &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
    
    std::cout &lt;&lt; "Contents of l, viewed via shuffled v:\t";
    for (const auto i : v)
        std::cout &lt;&lt; std::setw(2) &lt;&lt; *i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|p=true
|output=
Original contents of the list l:	-4 -3 -2 -1  0  1  2  3  4  5
Contents of l, viewed via shuffled v:	-1  5 -4  0  2  1  4 -2  3 -3
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc iota_view}}
{{dsc inc|cpp/algorithm/dsc fill}}
{{dsc inc|cpp/algorithm/ranges/dsc fill}}
{{dsc inc|cpp/algorithm/dsc generate}}
{{dsc inc|cpp/algorithm/ranges/dsc generate}}
{{dsc inc|cpp/algorithm/ranges/dsc iota}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}