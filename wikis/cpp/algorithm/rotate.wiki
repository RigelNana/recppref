{{cpp/title|rotate}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|num=1|notes={{mark constexpr since c++20}}|
template&lt; class ForwardIt &gt;
ForwardIt rotate( ForwardIt first, ForwardIt middle, ForwardIt last );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt &gt;
ForwardIt rotate( ExecutionPolicy&amp;&amp; policy,
                  ForwardIt first, ForwardIt middle, ForwardIt last );
}}
{{dcl end}}

@1@ Performs a left rotation on a range of elements. 
@@ Specifically, {{tt|std::rotate}} swaps the elements in the range {{range|first|last}} in such a way that the elements in {{range|first|middle}} are placed after the elements in {{range|middle|last}} while the orders of the elements in both ranges are preserved.

@2@ Same as {{v|1}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition}}

If any of the following conditions is satisfied, the behavior is undefined:
* {{range|first|middle}} or {{range|middle|last}} is not a [[cpp/iterator#Ranges|valid range]].
{{rev begin}}
{{rev|until=c++11|
* The type of {{c|*first}} is not {{named req|Swappable}}.
}}
{{rev|since=c++11|
* {{tt|ForwardIt}} is not {{named req|ValueSwappable}}.
* The type of {{c|*first}} is not {{named req|MoveConstructible}}.
* The type of {{c|*first}} is not {{named req|MoveAssignable}}.
}}
{{rev end}}

===Parameters===
{{par begin}}
{{par|first|the beginning of the original range}}
{{par|middle|the element that should appear at the beginning of the rotated range}}
{{par|last|the end of the original range}}
{{par exec pol}}
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par end}}

===Return value===
The iterator to the element originally referenced by {{c|*first}}, i.e. the {{c|std::distance(middle, last)}}{{su|b=th}} next iterator of {{c|first}}.

===Complexity===
At most {{c|std::distance(first, last)}} swaps.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=yes}}

===Possible implementation===
See also the implementations in [https://github.com/gcc-mirror/gcc/blob/14d8a5ae472ca5743016f37da2dd4770d83dea21/libstdc%2B%2B-v3/include/bits/stl_algo.h#L1213-L1416 libstdc++], [https://github.com/llvm/llvm-project/tree/6adbc83ee9e46b476e0f75d5671c3a21f675a936/libcxx/include/__algorithm/rotate.h libc++], and [https://github.com/microsoft/STL/blob/472161105d596192194d4715ccad307c6c163b4a/stl/inc/xutility#L5392-L5446 MSVC STL].
{{eq fun|1=
template&lt;class ForwardIt&gt;
constexpr // since C++20
ForwardIt rotate(ForwardIt first, ForwardIt middle, ForwardIt last)
{
    if (first == middle)
        return last;
    
    if (middle == last)
        return first;
    
    ForwardIt write = first;
    ForwardIt next_read = first; // read position for when “read” hits “last”
    
    for (ForwardIt read = middle; read != last; ++write, ++read)
    {
        if (write == next_read)
            next_read = read; // track where “first” went
        std::iter_swap(write, read);
    }
    
    // rotate the remaining sequence into place
    rotate(write, next_read, last);
    return write;
}
}}

===Notes===
{{tt|std::rotate}} has better efficiency on common implementations if {{tt|ForwardIt}} satisfies {{named req|BidirectionalIterator}} or (better) {{named req|RandomAccessIterator}}.

{{cpp/algorithm/notes swap vectorization}}

===Example===
{{example
|{{tt|std::rotate}} is a common building block in many algorithms. This example demonstrates {{enwiki|insertion sort}}.
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto print = [](const auto remark, const auto&amp; v)
{
    std::cout &lt;&lt; remark;
    for (auto n : v)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
};

int main()
{
    std::vector&lt;int&gt; v{2, 4, 2, 0, 5, 10, 7, 3, 7, 1};
    print("before sort:\t\t", v);
    
    // insertion sort
    for (auto i = v.begin(); i != v.end(); ++i)
        std::rotate(std::upper_bound(v.begin(), i, *i), i, i + 1);
    print("after sort:\t\t", v);
    
    // simple rotation to the left
    std::rotate(v.begin(), v.begin() + 1, v.end());
    print("simple rotate left:\t", v);
    
    // simple rotation to the right
    std::rotate(v.rbegin(), v.rbegin() + 1, v.rend());
    print("simple rotate right:\t", v);
}
|std=c++14
|output=
before sort:		2 4 2 0 5 10 7 3 7 1
after sort:		0 1 2 2 3 4 5 7 7 10
simple rotate left:	1 2 2 3 4 5 7 7 10 0
simple rotate right:	0 1 2 2 3 4 5 7 7 10
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=488|std=C++98|before=the new location of the element pointed by {{c|first}} was not returned|after=returned}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc rotate_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc rotate}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}