{{cpp/title|remove_copy|remove_copy_if}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl rev begin|num=1}}
{{dcla|anchor=1|constexpr=c++20|until=c++26|
template&lt; class InputIt, class OutputIt, class T &gt;
OutputIt remove_copy( InputIt first, InputIt last,
                      OutputIt d_first, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class InputIt, class OutputIt,
          class T = typename std::iterator_traits
                        &lt;InputIt&gt;::value_type &gt;
constexpr OutputIt remove_copy( InputIt first, InputIt last,
                                OutputIt d_first, const T&amp; value );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++17|until=c++26|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2, class T &gt;
ForwardIt2 remove_copy( ExecutionPolicy&amp;&amp; policy,
                        ForwardIt1 first, ForwardIt1 last,
                        ForwardIt2 d_first, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2,
          class T = typename std::iterator_traits
                        &lt;ForwardIt1&gt;::value_type &gt;
ForwardIt2 remove_copy( ExecutionPolicy&amp;&amp; policy,
                        ForwardIt1 first, ForwardIt1 last,
                        ForwardIt2 d_first, const T&amp; value );
}}
{{dcl rev end}}
{{dcla|num=3|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class OutputIt, class UnaryPred &gt;
OutputIt remove_copy_if( InputIt first, InputIt last,
                         OutputIt d_first, UnaryPred p );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2, class UnaryPred &gt;
ForwardIt2 remove_copy_if( ExecutionPolicy&amp;&amp; policy,
                           ForwardIt1 first, ForwardIt1 last,
                           ForwardIt2 d_first, UnaryPred p );
}}
{{dcl end}}

Copies elements from the range {{range|first|last}}, to another range beginning at {{c|d_first}}, omitting the elements which satisfy specific criteria.

@1@ Ignores all elements that are equal to {{c|value}} (using {{c/core|1=operator==}}).

@3@ Ignores all elements for which predicate {{c|p}} returns {{c|true}}.

@2,4@ Same as {{v|1,3}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

If {{rev inl|until=c++20|{{c|1=*d_first = *first}} is invalid}}{{rev inl|since=c++20|{{c|*first}} is not [[cpp/iterator#Types and writability|writable]] to {{c|d_first}}}}, the program is ill-formed.

If source and destination ranges overlap, the behavior is undefined.

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to copy}}
{{par|d_first|the beginning of the destination range}}
{{par|value|the value of the elements not to copy}}
{{par exec pol}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|OutputIt|OutputIterator}}
{{par req named|ForwardIt1, ForwardIt2|ForwardIterator}}
{{par req named|UnaryPred|Predicate}}
{{par end}}

===Return value===
Iterator to the element past the last element copied.

===Complexity===
Given {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first, last)}}:
@1,2@ Exactly {{mathjax-or|\(\scriptsize N\)|N}} comparisons with {{c|value}} using {{c/core|1=operator==}}.
@3,4@ Exactly {{mathjax-or|\(\scriptsize N\)|N}} applications of the predicate {{c|p}}.

For the overloads with an ExecutionPolicy, there may be a performance cost if {{tt|ForwardIt1}}'s {{tt|value_type}} is not {{named req|MoveConstructible}}.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===Possible implementation===
{{eq impl|title1=remove_copy (1)|ver1=1|1=
template&lt;class InputIt, class OutputIt,
         class T = typename std::iterator_traits&lt;InputIt&gt;::value_type&gt;
constexpr OutputIt remove_copy(InputIt first, InputIt last,
                               OutputIt d_first, const T&amp; value)
{
    for (; first != last; ++first)
        if (!(*first == value))
            *d_first++ = *first;
    return d_first;
}
|title2=remove_copy_if (3)|ver2=3|2=
template&lt;class InputIt, class OutputIt, class UnaryPred&gt;
constexpr OutputIt remove_copy_if(InputIt first, InputIt last,
                                  OutputIt d_first, UnaryPred p)
{
    for (; first != last; ++first)
        if (!p(*first))
            *d_first++ = *first;
    return d_first;
}
}}

===Notes===
{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms {{vl|1,2}}}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;complex&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main()
{
    // Erase the hash characters '#' on the fly.
    std::string str = "#Return #Value #Optimization";
    std::cout &lt;&lt; "before: " &lt;&lt; std::quoted(str) &lt;&lt; '\n';

    std::cout &lt;&lt; "after:  \"";
    std::remove_copy(str.begin(), str.end(),
                     std::ostream_iterator&lt;char&gt;(std::cout), '#');
    std::cout &lt;&lt; "\"\n";

    // Erase {1, 3} value on the fly.
    std::vector&lt;std::complex&lt;double&gt;&gt; nums{&lt;!----&gt;{2, 2}, {1, 3}, {4, 8}, {1, 3}&lt;!----&gt;};
    std::remove_copy(nums.begin(), nums.end(),
                     std::ostream_iterator&lt;std::complex&lt;double&gt;&gt;(std::cout),
    #ifdef __cpp_lib_algorithm_default_value_type
                     {1, 3}); // T gets deduced
    #else
                     std::complex&lt;double&gt;{1, 3});
    #endif
}
|output=
before: "#Return #Value #Optimization"
after:  "Return Value Optimization"
(2,2)(4,8)
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=779|std=C++98|before={{tt|T}} was required to be {{named req|EqualityComparable}}, but&lt;br&gt;the value type of {{tt|ForwardIt}} is not always {{tt|T}}|after=required {{c|1=*d_first = *first}}&lt;br&gt;to be valid instead}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc remove}}
{{dsc inc|cpp/algorithm/dsc copy}}
{{dsc inc|cpp/algorithm/dsc partition_copy}}
{{dsc inc|cpp/algorithm/ranges/dsc remove_copy}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}