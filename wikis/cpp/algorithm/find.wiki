{{cpp/title|find|find_if|find_if_not}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl rev begin|num=1}}
{{dcla|anchor=1|constexpr=c++20|until=c++26|
template&lt; class InputIt, class T &gt;
InputIt find( InputIt first, InputIt last, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class InputIt, class T = typename std::iterator_traits
                                       &lt;InputIt&gt;::value_type &gt;
constexpr InputIt find( InputIt first, InputIt last, const T&amp; value );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|since=c++17|until=c++26|
template&lt; class ExecutionPolicy, class ForwardIt, class T &gt;
ForwardIt find( ExecutionPolicy&amp;&amp; policy,
                ForwardIt first, ForwardIt last, const T&amp; value );
}}
{{dcl|since=c++26|1=
template&lt; class ExecutionPolicy,
          class ForwardIt, class T = typename std::iterator_traits
                                         &lt;ForwardIt&gt;::value_type &gt;
ForwardIt find( ExecutionPolicy&amp;&amp; policy,
                ForwardIt first, ForwardIt last, const T&amp; value );
}}
{{dcl rev end}}
{{dcla|num=3|constexpr=c++20|
template&lt; class InputIt, class UnaryPred &gt;
InputIt find_if( InputIt first, InputIt last, UnaryPred p );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt, class UnaryPred &gt;
ForwardIt find_if( ExecutionPolicy&amp;&amp; policy,
                   ForwardIt first, ForwardIt last, UnaryPred p );
}}
{{dcla|num=5|since=c++11|constexpr=c++20|
template&lt; class InputIt, class UnaryPred &gt;
InputIt find_if_not( InputIt first, InputIt last, UnaryPred q );
}}
{{dcl|num=6|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt, class UnaryPred &gt;
ForwardIt find_if_not( ExecutionPolicy&amp;&amp; policy,
                       ForwardIt first, ForwardIt last, UnaryPred q );
}}
{{dcl end}}

Returns an iterator to the first element in the range {{range|first|last}} that satisfies specific criteria (or {{c|last}} if there is no such iterator).

@1@ {{tt|find}} searches for an element equal to {{c|value}} (using {{tt|1=operator==}}).

@3@ {{tt|find_if}} searches for an element for which predicate {{c|p}} returns {{c|true}}.

@5@ {{tt|find_if_not}} searches for an element for which predicate {{c|q}} returns {{c|false}}.

@2,4,6@ Same as {{v|1,3,5}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to examine}}
{{par|value|value to compare the elements to}}
{{par exec pol}}
{{par pred1|p|value=true|for the required element|p1=InputIt}}
{{par pred1|q|value=false|for the required element|p1=InputIt}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req named|UnaryPredicate|Predicate}}
{{par end}}

===Return value===
The first iterator {{c|it}} in the [[cpp/iterator#Ranges|range]] {{range|first|last}} satisfying the following condition or {{c|last}} if there is no such iterator:
@1,2@ {{c|1=*it == value}} is {{c|true}}.
@3,4@ {{c|1=p(*it)}} is {{c|true}}.
@5,6@ {{c|1=q(*it)}} is {{c|false}}.

===Complexity===
Given {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first, last)}}:
@1,2@ At most {{mathjax-or|\(\scriptsize N\)|N}} comparisons with {{c|value}} using {{tt|1=operator==}}.
@3,4@ At most {{mathjax-or|\(\scriptsize N\)|N}} applications of the predicate {{c|p}}.
@5,6@ At most {{mathjax-or|\(\scriptsize N\)|N}} applications of the predicate {{c|q}}.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior}}

===Possible implementation===
{{eq impl
|title1=find|ver1=1|1=
template&lt;class InputIt, class T = typename std::iterator_traits&lt;InputIt&gt;::value_type&gt;
constexpr InputIt find(InputIt first, InputIt last, const T&amp; value)
{
    for (; first != last; ++first)
        if (*first == value)
            return first;
    
    return last;
}
|title2=find_if|ver2=3|2=
template&lt;class InputIt, class UnaryPred&gt;
constexpr InputIt find_if(InputIt first, InputIt last, UnaryPred p)
{
    for (; first != last; ++first)
        if (p(*first))
            return first;
    
    return last;
}
|title3=find_if_not|ver3=5|3=
template&lt;class InputIt, class UnaryPred&gt;
constexpr InputIt find_if_not(InputIt first, InputIt last, UnaryPred q)
{
    for (; first != last; ++first)
        if (!q(*first))
            return first;
    
    return last;
}
}}

===Notes===
If C++11 is not available, an equivalent to {{tt|std::find_if_not}} is to use {{tt|std::find_if}} with the negated predicate.
{{eq fun|1=
template&lt;class InputIt, class UnaryPred&gt;
InputIt find_if_not(InputIt first, InputIt last, UnaryPred q)
{
    return std::find_if(first, last, std::not1(q));
}
}}

{{feature test macro|__cpp_lib_algorithm_default_value_type|value=202403|std=C++26|[[cpp/language/list initialization|List-initialization]] for algorithms {{vl|1,2}}}}

===Example===
{{example
|The following example finds numbers in given sequences.
|code=
#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;initializer_list&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

bool is_even(int i)
{
    return i % 2 == 0;
}

void example_contains()
{
    const auto haystack = {1, 2, 3, 4};

    for (const int needle : {3, 5})
        if (std::find(haystack.begin(), haystack.end(), needle) == haystack.end())
            std::cout &lt;&lt; "haystack does not contain " &lt;&lt; needle &lt;&lt; '\n';
        else
            std::cout &lt;&lt; "haystack contains " &lt;&lt; needle &lt;&lt; '\n';
}

void example_predicate()
{
    for (const auto&amp; haystack : {std::array{3, 1, 4}, {1, 3, 5}&lt;!----&gt;})
    {
        const auto it = std::find_if(haystack.begin(), haystack.end(), is_even);
        if (it != haystack.end())
            std::cout &lt;&lt; "haystack contains an even number " &lt;&lt; *it &lt;&lt; '\n';
        else
            std::cout &lt;&lt; "haystack does not contain even numbers\n";
    }
}

void example_list_init()
{
    std::vector&lt;std::complex&lt;double&gt;&gt; haystack{&lt;!----&gt;{4.0, 2.0}&lt;!----&gt;};
#ifdef __cpp_lib_algorithm_default_value_type
    // T gets deduced making list-initialization possible
    const auto it = std::find(haystack.begin(), haystack.end(), {4.0, 2.0});
#else
    const auto it = std::find(haystack.begin(), haystack.end(), std::complex{4.0, 2.0});
#endif
    assert(it == haystack.begin());  
}

int main()
{
    example_contains();
    example_predicate();
    example_list_init();
}
|output=
haystack contains 3
haystack does not contain 5
haystack contains an even number 4
haystack does not contain even numbers
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=283|std=C++98|before={{tt|T}} was required to be {{named req|EqualityComparable}}, but&lt;br&gt;the value type of {{tt|InputIt}} might not be {{tt|T}}|after=removed the requirement}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc adjacent_find}}
{{dsc inc|cpp/algorithm/dsc find_end}}
{{dsc inc|cpp/algorithm/dsc find_first_of}}
{{dsc inc|cpp/algorithm/dsc mismatch}}
{{dsc inc|cpp/algorithm/dsc search}}
{{dsc inc|cpp/algorithm/ranges/dsc find}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}