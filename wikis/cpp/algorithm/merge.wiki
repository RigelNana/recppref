{{cpp/title|merge}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcla|num=1|notes={{mark constexpr since c++20}}|
template&lt; class InputIt1, class InputIt2, class OutputIt &gt;
OutputIt merge( InputIt1 first1, InputIt1 last1,
                InputIt2 first2, InputIt2 last2,
                OutputIt d_first );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2, class ForwardIt3 &gt;
ForwardIt3 merge( ExecutionPolicy&amp;&amp; policy,
                  ForwardIt1 first1, ForwardIt1 last1,
                  ForwardIt2 first2, ForwardIt2 last2,
                  ForwardIt3 d_first );
}}
{{dcla|num=3|notes={{mark constexpr since c++20}}|
template&lt; class InputIt1, class InputIt2,
          class OutputIt, class Compare &gt;
OutputIt merge( InputIt1 first1, InputIt1 last1,
                InputIt2 first2, InputIt2 last2,
                OutputIt d_first, Compare comp );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2,
          class ForwardIt3, class Compare &gt;
ForwardIt3 merge( ExecutionPolicy&amp;&amp; policy,
                  ForwardIt1 first1, ForwardIt1 last1,
                  ForwardIt2 first2, ForwardIt2 last2,
                  ForwardIt3 d_first, Compare comp );
}}
{{dcl end}}

Merges two sorted ranges {{range|first1|last1}} and {{range|first2|last2}} into one sorted range beginning at {{c|d_first}}.

@1@ If {{range|first1|last1}} or {{range|first2|last2}} is not {{rlp|/#Requirements|sorted}} with respect to {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}}, the behavior is undefined.

@3@ If {{range|first1|last1}} or {{range|first2|last2}} is not sorted with respect to {{c|comp}}, the behavior is undefined.

@2,4@ Same as {{v|1,3}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

This merge function is stable, which means that for equivalent elements in the original two ranges, the elements from the first range (preserving their original order) precede the elements from the second range (preserving their original order).

If the output range overlaps with {{range|first1|last1}} or {{range|first2|last2}}, the behavior is undefined.

===Parameters===
{{par begin}}
{{par|first1, last1|the first range of elements to merge}}
{{par|first2, last2|the second range of elements to merge}}
{{par|d_first|the beginning of the destination range}}
{{par exec pol}}
{{par cmp ord|comp|p1=InputIt1|p2=InputIt2}}
{{par hreq}}
{{par req named|InputIt1, InputIt2|InputIterator}}
{{par req named|ForwardIt1, ForwardIt2, ForwardIt3|ForwardIterator}}
{{par req named|OutputIt|OutputIterator}}
{{par req named|Compare|Compare}}
{{par end}}

===Return value===
An output iterator to element past the last element copied.

===Complexity===
Given {{mathjax-or|\(\scriptsize N_1\)|N{{su|b=1}}}} as {{c|std::distance(first1, last1)}} and {{mathjax-or|\(\scriptsize N_2\)|N{{su|b=2}}}} as {{c|std::distance(first2, last2)}}:

@1@ At most {{mathjax-or|\(\scriptsize N_1+N_2-1\)|N{{su|b=1}}+N{{su|b=2}}-1}} comparisons using {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}}.

@2@ {{mathjax-or|\(\scriptsize O(N_1+N_2)\)|O(N{{su|b=1}}+N{{su|b=2}})}} comparisons using {{rev inl|until=c++20|{{c/core|operator&lt;}}}}{{rev inl|since=c++20|{{c|std::less{}&lt;!----&gt;}}}}.

@3@ At most {{mathjax-or|\(\scriptsize N_1+N_2-1\)|N{{su|b=1}}+N{{su|b=2}}-1}} applications of the comparison function {{c|comp}}.

@4@ {{mathjax-or|\(\scriptsize O(N_1+N_2)\)|O(N{{su|b=1}}+N{{su|b=2}})}} applications of the comparison function {{c|comp}}.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===Possible implementation===
See also the implementations in [https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L4856 libstdc++] and [https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L4348 libc++].
{{eq impl
|title1=merge (1)|ver1=1|1=
template&lt;class InputIt1, class InputIt2, class OutputIt&gt;
OutputIt merge(InputIt1 first1, InputIt1 last1,
               InputIt2 first2, InputIt2 last2,
               OutputIt d_first)
{
    for (; first1 != last1; ++d_first)
    {
        if (first2 == last2)
            return std::copy(first1, last1, d_first);
        
        if (*first2 &lt; *first1)
        {
            *d_first = *first2;
            ++first2;
        }
        else
        {
            *d_first = *first1;
            ++first1;
        }
    }
    return std::copy(first2, last2, d_first);
}
|title2=merge (3)|ver2=3|2=
template&lt;class InputIt1, class InputIt2,
         class OutputIt, class Compare&gt;
OutputIt merge(InputIt1 first1, InputIt1 last1,
               InputIt2 first2, InputIt2 last2,
               OutputIt d_first, Compare comp)
{
    for (; first1 != last1; ++d_first)
    {
        if (first2 == last2)
            return std::copy(first1, last1, d_first);
        
        if (comp(*first2, *first1))
        {
            *d_first = *first2;
            ++first2;
        }
        else
        {
            *d_first = *first1;
            ++first1;
        }
    }
    return std::copy(first2, last2, d_first);
}
}}

===Notes===
This algorithm performs a similar task as {{c|std::set_union}} does. Both consume two sorted input ranges and produce a sorted output with elements from both inputs. The difference between these two algorithms is with handling values from both input ranges which compare equivalent (see notes on {{named req|LessThanComparable}}). If any equivalent values appeared {{c|n}} times in the first range and {{c|m}} times in the second, {{tt|std::merge}} would output all {{c|n + m}} occurrences whereas {{tt|std::set_union}} would output {{c|std::max(n, m)}} ones only. So {{tt|std::merge}} outputs exactly {{c|std::distance(first1, last1) + std::distance(first2, last2)}} values and {{tt|std::set_union}} may produce fewer.

===Example===
{{example
|
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

auto print = [](const auto rem, const auto&amp; v)
{
    std::cout &lt;&lt; rem;
    std::copy(v.begin(), v.end(), std::ostream_iterator&lt;int&gt;(std::cout, " "));
    std::cout &lt;&lt; '\n';
};

int main()
{
    // fill the vectors with random numbers
    std::random_device rd;
    std::mt19937 mt(rd());
    std::uniform_int_distribution&lt;&gt; dis(0, 9);
    
    std::vector&lt;int&gt; v1(10), v2(10);
    std::generate(v1.begin(), v1.end(), std::bind(dis, std::ref(mt)));
    std::generate(v2.begin(), v2.end(), std::bind(dis, std::ref(mt)));
    
    print("Originally:\nv1: ", v1);
    print("v2: ", v2);
    
    std::sort(v1.begin(), v1.end());
    std::sort(v2.begin(), v2.end());
    
    print("After sorting:\nv1: ", v1);
    print("v2: ", v2);
    
    // merge
    std::vector&lt;int&gt; dst;
    std::merge(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(dst));
    
    print("After merging:\ndst: ", dst);
}
|p=true
|output=
Originally:
v1: 2 6 5 7 4 2 2 6 7 0
v2: 8 3 2 5 0 1 9 6 5 0
After sorting:
v1: 0 2 2 2 4 5 6 6 7 7
v2: 0 0 1 2 3 5 5 6 8 9
After merging:
dst: 0 0 0 1 2 2 2 2 3 4 5 5 5 6 6 6 7 7 8 9
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=780|std=C++98|before=the merge operation was not defined|after=defined}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc inplace_merge}}
{{dsc inc|cpp/algorithm/dsc is_sorted}}
{{dsc inc|cpp/algorithm/dsc set_union}}
{{dsc inc|cpp/algorithm/dsc sort}}
{{dsc inc|cpp/algorithm/dsc stable_sort}}
{{dsc inc|cpp/algorithm/ranges/dsc merge}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}