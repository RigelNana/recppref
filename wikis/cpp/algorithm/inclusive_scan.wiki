{{cpp/title|inclusive_scan}}
{{cpp/algorithm/numeric/navbar}}
{{dcl begin}}
{{dcl header|numeric}}
{{dcla|anchor=no|num=1|since=c++17|constexpr=c++20|
template&lt; class InputIt, class OutputIt &gt;
OutputIt inclusive_scan( InputIt first, InputIt last,
                         OutputIt d_first );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2 &gt;
ForwardIt2 inclusive_scan( ExecutionPolicy&amp;&amp; policy,
                           ForwardIt1 first, ForwardIt1 last,
                           ForwardIt2 d_first );
}}
{{dcla|anchor=no|num=3|since=c++17|constexpr=c++20|
template&lt; class InputIt, class OutputIt, class BinaryOp &gt;
OutputIt inclusive_scan( InputIt first, InputIt last,
                         OutputIt d_first, BinaryOp op );
}}
{{dcl|num=4|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2, class BinaryOp &gt;
ForwardIt2 inclusive_scan( ExecutionPolicy&amp;&amp; policy,
                           ForwardIt1 first, ForwardIt1 last,
                           ForwardIt2 d_first, BinaryOp op );
}}
{{dcla|anchor=no|num=5|since=c++17|constexpr=c++20|
template&lt; class InputIt, class OutputIt,
          class BinaryOp, class T &gt;
OutputIt inclusive_scan( InputIt first, InputIt last,
                         OutputIt d_first, BinaryOp op, T init );
}}
{{dcl|num=6|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt1, class ForwardIt2,
          class BinaryOp, class T &gt;
ForwardIt2 inclusive_scan( ExecutionPolicy&amp;&amp; policy,
                           ForwardIt1 first, ForwardIt1 last,
                           ForwardIt2 d_first, BinaryOp op, T init );
}}
{{dcl end}}

@1@ Equivalent to {{c|inclusive_scan(first, last, d_first, std::plus&lt;&gt;()}}.

@3@ Computes the inclusive prefix sum using {{c|op}}.
@@ For each integer {{c|i}} in {{range|0|std::distance(first, last)}}, performs the following operations in order:
# Creates a sequence which is formed by the elements of {{closed range|first|iter}} in order, where {{c|iter}} is the next {{c|i}}{{su|b=th}} iterator of {{c|first}}.
# Computes the generalized noncommutative sum of the sequence over {{c|op}}.
# Assigns the result to {{c|*dest}}, where {{c|dest}} is the next {{c|i}}{{su|b=th}} iterator of {{c|d_first}}.

@5@ Same as {{v|3}}, but each sequence created is formed by {{c|init}} followed by the elements of {{closed range|first|iter}} in order.

@2,4,6@ Same as {{v|1,3,5}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition|plural=yes}}

The ''generalized, noncommutative sum'' of a sequence of elements over a binary operation {{c|binary_op}} is defined as follows:
* If the sequence only has one element, the sum is the value of the element.
* Otherwise, performs the following operations in order:
# Selects any two adjacent elements {{c|elem1}} and {{c|elem2}} from the sequence.
# Calculates {{c|binary_op(elem1, elem2)}} and replaces the two elements in the sequence with the result.
# Repeats steps 1 and 2 until there is only one element in the sequence.


Given {{c|binary_op}} as the actual binary operation:

* The result is non-deterministic if the {{c|binary_op}} is not associative (such as floating-point addition).

* For overloads {{v|1-4}}, if {{c|binary_op(*first, *first)}} is not convertible to the [[cpp/iterator#Types and writability|value type]] of {{c/core|decltype(first)}}, the program is ill-formed.

* For overloads {{v|5,6}}, if any of the following values is not convertible to {{tt|T}}, the program is ill-formed:
:* {{c|binary_op(init, *first)}}
:* {{c|binary_op(init, init)}}
:* {{c|binary_op(*first, *first)}}

* If any of the following conditions is satisfied, the behavior is undefined:
:* For overloads {{v|1-4}}, the value type of {{c/core|decltype(first)}} is not {{named req|MoveConstructible}}.
:* For overloads {{v|5,6}}, {{tt|T}} is not {{named req|MoveConstructible}}.
:* {{c|binary_op}} modifies any element of {{range|first|last}}.
:* {{c|binary_op}} invalidates any iterator or subrange of {{closed range|first|last}}.

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to sum}}
{{par|d_first|the beginning of the destination range; may be equal to {{c|first}}}}
{{par exec pol}}
{{par|init|the initial value}}
{{par|op|binary {{named req|FunctionObject}} that will be applied in to the result of dereferencing the input iterators, the results of other {{c|op}}, and {{c|init}} (if provided)}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|OutputIt|OutputIterator}}
{{par req named|ForwardIt1, ForwardIt2|ForwardIterator}}
{{par end}}

===Return value===
Iterator to the element past the last element written.

===Complexity===
Given {{mathjax-or|\(\scriptsize N\)|N}} as {{c|std::distance(first, last)}}:

@1,2@ {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} applications of {{c|std::plus&lt;&gt;()}}.

@3-6@ {{mathjax-or|\(\scriptsize O(N)\)|O(N)}} applications of {{c|op}}.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=no}}

===Example===
{{cpp/algorithm/scan example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc adjacent_difference}}
{{dsc inc|cpp/algorithm/dsc accumulate}}
{{dsc inc|cpp/algorithm/dsc partial_sum}}
{{dsc inc|cpp/algorithm/dsc transform_inclusive_scan}}
{{dsc inc|cpp/algorithm/dsc exclusive_scan}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}