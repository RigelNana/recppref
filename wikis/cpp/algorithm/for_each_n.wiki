{{cpp/title|for_each_n}}
{{cpp/algorithm/navbar}}
{{dcl begin}}
{{dcl header|algorithm}}
{{dcl|num=1|since=c++17|notes={{mark constexpr since c++20}}|
template&lt; class InputIt, class Size, class UnaryFunc &gt;
InputIt for_each_n( InputIt first, Size n, UnaryFunc f );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt, class Size, class UnaryFunc &gt;
ForwardIt for_each_n( ExecutionPolicy&amp;&amp; policy,
                      ForwardIt first, Size n, UnaryFunc f );
}}
{{dcl end}}

Applies the given function object {{c|f}} to the result of dereferencing every iterator in the range {{range|first|first + n}}. If {{c|f}} returns a result, the result is ignored.

@1@ {{c|f}} is applied in order starting from {{c|first}}.
@@ If {{tt|UnaryFunc}} is not {{named req|MoveConstructible}}, the behavior is undefined.

@2@ {{c|f}} might not be applied in order. The algorithm is executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition}}
@@ If {{tt|UnaryFunc}} is not {{named req|CopyConstructible}}, the behavior is undefined.

If {{c|1=n &gt;= 0}} is not {{c|true}}, the behavior is undefined.

If the iterator type ({{tt|InputIt}}/{{tt|ForwardIt}}) is mutable, {{c|f}} may modify the elements of the range through the dereferenced iterator.

Unlike the rest of the parallel algorithms, {{tt|for_each_n}} is not allowed to make copies of the elements in the sequence even if they are {{named req|TriviallyCopyable}}.

===Parameters===
{{par begin}}
{{par|first|the beginning of the range to apply the function to}}
{{par|n|the number of elements to apply the function to}}
{{par exec pol}}
{{par opf|f|to be applied to the result of dereferencing every iterator in the range {{range|first|first + n}}|p1=InputIt}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req|{{tt|Size}} must be convertible to an integral type.}}
{{par end}}

===Return value===
An iterator equal to {{c|first + n}}, or more formally, to {{c|std::advance(first, n)}}.

===Complexity===
Exactly {{c|n}} applications of {{c|f}}.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=yes}}

===Possible implementation===
See also the implementation in [https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/pstl/algorithm_impl.h#L82 libstdc++], [https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L896 libc++] and [https://github.com/microsoft/STL/blob/ff83542af4b683fb2f2dea1423fd6c50fe3e13b0/stl/inc/algorithm#L246 MSVC stdlib].
{{eq fun|1=
template&lt;class InputIt, class Size, class UnaryFunc&gt;
InputIt for_each_n(InputIt first, Size n, UnaryFunc f)
{
    for (Size i = 0; i &lt; n; ++first, (void) ++i)
        f(*first);
    
    return first;
}
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

void println(auto const&amp; v)
{
    for (auto count{v.size()}; const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; (--count ? ", " : "\n");
}

int main()
{
    std::vector&lt;int&gt; vi{1, 2, 3, 4, 5};
    println(vi);
    
    std::for_each_n(vi.begin(), 3, [](auto&amp; n) { n *= 2; });
    println(vi);
}
|output=
1, 2, 3, 4, 5
2, 4, 6, 4, 5
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc transform}}
{{dsc inc|cpp/language/dsc range-for}}
{{dsc inc|cpp/algorithm/dsc for_each}}
{{dsc inc|cpp/algorithm/ranges/dsc for_each_n}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}