{{cpp/memory/inout_ptr_t/title|inout_ptr_t}}
{{cpp/memory/inout_ptr_t/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++23|
explicit inout_ptr_t( Smart &amp;sp, Args... args );
}}
{{dcl|num=2|since=c++23|1=
inout_ptr_t( const inout_ptr_t&amp; ) = delete;
}}
{{dcl end}}

@1@ Creates an {{tt|inout_ptr_t}}. Adapts {{c|sp}} as if binds it to the {{c|Smart&amp;}} member, captures every argument {{tt|t}} in {{c|args...}} as if initializes the corresponding member of type {{tt|T}} in {{tt|Args...}} with {{c|std::forward&lt;T&gt;(t)}}, then initializes the stored {{tt|Pointer}} with {{c|sp}} if {{tt|Smart}} is a pointer type, otherwise, initializes it with {{c|sp.get()}}. {{c|sp.release()}} may be called if {{tt|Smart}} is not a pointer type, in which case it will not be called again within the destructor.

@2@ Copy constructor is explicitly deleted. {{tt|inout_ptr_t}} is neither copyable nor movable.

===Parameters===
{{par begin}}
{{par|sp|the object (typically a smart pointer) to adapt}}
{{par|args...|the arguments used for resetting to capture}}
{{par end}}

===Return value===
(none)

{{cpp/impldef exception}}

===Notes===
If {{tt|Smart}} is not a pointer type and {{c|sp.release()}} is not called by the constructor, it may be called by the destructor before resetting {{c|sp}}.

Every argument in {{c|args...}} is moved into the created {{tt|inout_ptr_t}} if it is of an object type, or transferred into the created {{tt|inout_ptr_t}} as-is if it is of a reference type.

The constructor of {{tt|inout_ptr_t}} is allowed to throw exceptions. For example, when {{c|sp}} is an intrusive pointer with a control block, the allocation for the new control block may be performed within the constructor rather than the destructor.

===Example===
{{example}}

{{langlinks|es|ja|ru|zh}}