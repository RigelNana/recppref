{{title|{{small|operator}} new{{small|, operator}} new[]}}
{{cpp/memory/new/navbar}}
{{dcl begin}}
{{dcl header|new}}
{{dcl h|Replaceable allocation functions}}
{{dcla|num=1|
void* operator new  ( std::size_t count );
}}
{{dcla|num=2|
void* operator new[]( std::size_t count );
}}
{{dcla|num=3|since=c++17|
void* operator new  ( std::size_t count, std::align_val_t al );
}}
{{dcla|num=4|since=c++17|
void* operator new[]( std::size_t count, std::align_val_t al );
}}
{{dcl h|Replaceable non-throwing allocation functions}}
{{dcla|num=5|noexcept=c++11|
void* operator new  ( std::size_t count, const std::nothrow_t&amp; tag );
}}
{{dcla|num=6|noexcept=c++11|
void* operator new[]( std::size_t count, const std::nothrow_t&amp; tag );
}}
{{dcla|num=7|since=c++17|
void* operator new  ( std::size_t count, std::align_val_t al,
                      const std::nothrow_t&amp; tag ) noexcept;
}}
{{dcla|num=8|since=c++17|
void* operator new[]( std::size_t count, std::align_val_t al,
                      const std::nothrow_t&amp; tag ) noexcept;
}}
{{dcl h|Non-allocating placement allocation functions}}
{{dcla|num=9|noexcept=c++11|constexpr=c++26|
void* operator new  ( std::size_t count, void* ptr );
}}
{{dcla|num=10|noexcept=c++11|constexpr=c++26|
void* operator new[]( std::size_t count, void* ptr );
}}
{{dcl h|User-defined placement allocation functions}}
{{dcla|num=11|
void* operator new  ( std::size_t count, /* args... */ );
}}
{{dcla|num=12|
void* operator new[]( std::size_t count, /* args... */ );
}}
{{dcla|num=13|since=c++17|
void* operator new  ( std::size_t count,
                      std::align_val_t al, /* args... */ );
}}
{{dcla|num=14|since=c++17|
void* operator new[]( std::size_t count,
                      std::align_val_t al, /* args... */ );
}}
{{dcl h|Class-specific allocation functions}}
{{dcla|num=15|
void* T::operator new  ( std::size_t count );
}}
{{dcla|num=16|
void* T::operator new[]( std::size_t count );
}}
{{dcla|num=17|since=c++17|
void* T::operator new  ( std::size_t count, std::align_val_t al );
}}
{{dcla|num=18|since=c++17|
void* T::operator new[]( std::size_t count, std::align_val_t al );
}}
{{dcl h|Class-specific placement allocation functions}}
{{dcla|num=19|
void* T::operator new  ( std::size_t count, /* args... */ );
}}
{{dcla|num=20|
void* T::operator new[]( std::size_t count, /* args... */ );
}}
{{dcla|num=21|since=c++17|
void* T::operator new  ( std::size_t count,
                         std::align_val_t al, /* args... */ );
}}
{{dcla|num=22|since=c++17|
void* T::operator new[]( std::size_t count,
                         std::align_val_t al, /* args... */ );
}}
{{dcl end}}

Attempts to allocate requested number of bytes, and the allocation request can fail (even if the requested number of bytes is zero). These allocation functions are called by [[cpp/language/new|{{c/core|new}} expressions]] to allocate memory in which new object would then be initialized. They may also be called using regular function call syntax.

@1@ Called by {{c/core|new}} to allocate storage required for a single object.
@@ The standard library implementation allocates {{c|count}} bytes from free store.
@@ In case of failure, the standard library implementation calls the function pointer returned by {{lc|std::get_new_handler}} and repeats allocation attempts until new handler does not return or becomes a null pointer, at which time it throws {{lc|std::bad_alloc}}.
@@ This function is required to return a pointer suitably aligned to point to an object of the requested size.

@2@ Called by {{c/core|new[]}} to allocate all storage required for an array (including possible {{c/core|new}} expression overhead).
@@ The standard library implementation calls version {{v|1}}.

@3@ Called by {{c/core|new}} to allocate storage required for a single object whose alignment requirement exceeds {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}}.

@4@ Called by {{c/core|new[]}} to allocate all storage required for an array of objects whose alignment requirement exceeds {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}}.

@5@ Called by the non-throwing {{c/core|new}}.
@@ The standard library implementation calls the version {{v|1}} and returns a null pointer on failure instead of propagating the exception.

@6@ Called by the non-throwing {{c/core|new[]}}.
@@ The standard library implementation calls the version {{v|2}} and returns a null pointer on failure instead of propagating the exception.

@7@ Called by the non-throwing {{c/core|new}} when the object's alignment requirement exceeds {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}}.
@@ The standard library implementation calls the version {{v|3}} and returns a null pointer on failure instead of propagating the exception.

@8@ Called by the non-throwing {{c/core|new[]}} when the alignment requirement of array elements exceeds {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}}.
@@ The standard library implementation calls the version {{v|4}} and returns a null pointer on failure instead of propagating the exception.

@9@ Called by the standard [[cpp/language/new#Placement new|placement {{c/core|new}}]].
@@ The standard library implementation performs no action and returns {{c|ptr}} unmodified.
@@ If this function is called through placement {{c/core|new}} and {{c|ptr}} is a null pointer, the behavior is undefined.&lt;!-- CWG 1748 --&gt;

@10@ Called by the standard placement {{c/core|new[]}}.
@@ The standard library implementation performs no action and returns {{c|ptr}} unmodified.
@@ If this function is called through placement {{c/core|new[]}} and {{c|ptr}} is a null pointer, the behavior is undefined.&lt;!-- CWG 1748 --&gt;

@11@ If defined, called by the custom placement {{c/core|new}} with the matching signature.
@@ If a class-specific version {{v|19}} is defined, it is called in preference to {{v|11}}.
@@ If neither {{v|11}} nor {{v|19}} is provided by the user, the placement {{c/core|new}} is ill-formed.

@12@ If defined, called by the custom placement {{c/core|new[]}} with the matching signature.
@@ If a class-specific version {{v|20}} is defined, it is called in preference to {{v|12}}.
@@ If neither {{v|12}} nor {{v|20}} is provided by the user, the placement {{c/core|new[]}} is ill-formed.

@13@ If defined, called by the custom placement {{c/core|new}} with the matching signature if the object's alignment requirement exceeds {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}}.
@@ If a class-specific version is defined ({{v|15}} or {{v|17}}), it is called instead.
@@ If neither class-specific nor global alignment-aware (this one) placement form is provided, alignment-unaware placement form {{v|11}} is looked up instead.

@14@ If defined, called by the custom placement {{c/core|new[]}} with the matching signature if the element's alignment requirement exceeds {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}}.
@@ If a class-specific version ({{v|16}} or {{v|18}}) is defined, it is called instead.
@@ If neither class-specific nor global alignment-aware (this one) placement form is provided, alignment-unaware placement form {{v|12}} is looked up instead.

@15@ If defined, called by {{c/core|new}} if allocating an object of type {{tt|T}}.

@16@ If defined, called by {{c/core|new[]}} if allocating an array of objects of type {{tt|T}}.

@17@ If defined, called by {{c/core|new}} if allocating an object of type {{tt|T}} if its alignment requirement exceeds {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}}.
@@ If this overload is not provided, but alignment-unaware member form {{v|15}} is, alignment-unaware member overload is called instead.

@18@ If defined, called by {{c/core|new[]}} if allocating an array of objects of type {{tt|T}} if its alignment requirement exceeds {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}}.
@@ If this overload is not provided, but alignment-unaware member form {{v|16}} is, alignment-unaware member overload is called instead.

@19@ If defined, called by the custom placement {{c/core|new}} with the matching signature if allocating an object of type {{tt|T}}.

@20@ If defined, called by the custom placement {{c/core|new[]}} with the matching signature if allocating an array of objects of type {{tt|T}}.

@21@ If defined, called by the custom placement {{c/core|new}} with the matching signature if allocating an object of type {{tt|T}} if its alignment requirement exceeds {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}}.
@@ If this overload is not provided, but alignment-unaware member form {{v|19}} is, alignment-unaware member overload is called instead.

@22@ If defined, called by the custom placement {{c/core|new[]}} with the matching signature if allocating an array of objects of type {{tt|T}} if its alignment requirement exceeds {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}}.
@@ If this overload is not provided, but alignment-unaware member form {{v|20}} is, alignment-unaware member overload is called instead.

===Parameters===
{{par begin}}
{{par|count|number of bytes to allocate}}
{{par|ptr|pointer to a memory area to initialize the object at}}
{{par|tag|disambiguation tag used to select non-throwing overloads}}
{{par|al|alignment to use, invalid value leads to undefined behavior}}
{{par end}}

===Return value===
@1-4@ If the allocation succeeds, a non-null pointer {{c|p0}} which points to suitably aligned memory of size at least {{c|size}} and is different from any previously returned value {{c|p1}}, unless that value {{c|p1}} was subsequently passed to a replaceable {{rlp|operator delete|deallocation function}}; if the allocation fails, does not return (an exception is thrown, see below).

@5-8@ Same as {{vl|1-4}}, but returns a null pointer if the allocation fails.

@9,10@ {{c|ptr}}

@11-22@ Same as {{vl|1-4}} if the function does not return on allocation failure, otherwise same as {{vl|5-8}}.

===Exceptions===
@1-4@ Throws an exception of a type that would match a handler of type {{lc|std::bad_alloc}} on failure to allocate memory.

@11-22@ Same as {{vl|1-4}} if the function does not return on allocation failure, otherwise same as {{vl|5-8}}.

===Global replacements===
The versions {{vl|1-4}} are implicitly declared in each translation unit even if the {{header|new}} header is not included. Versions {{vl|1-8}} are ''replaceable'': a user-provided non-member function with the same signature defined anywhere in the program, in any source file, replaces the default version. Its declaration does not need to be visible.

The program is ill-formed, no diagnostic required if more than one replacement is provided in the program for any of the replaceable allocation function, or if a replacement is declared with the [[cpp/language/inline|{{c/core|inline}} specifier]]&lt;!-- LWG 2340 --&gt;. The program is ill-formed if a replacement is defined in namespace other than global namespace, or if it is defined as a static non-member function at global scope.

The standard library implementations of the nothrow versions {{vl|5-8}} directly calls the corresponding throwing versions {{vl|1-4}}. The standard library implementation of the throwing array versions {{vl|2,4}} directly calls the corresponding single-object version {{vl|1,3}}. Thus, replacing the throwing single object allocation functions is sufficient to handle all allocations.

{{rrev|since=c++26|
On [[cpp/freestanding|freestanding implementations]], it is implementation-defined whether the default versions of {{vl|1-8}} satisfy the behaviors required above. Freestanding implementations are recommended that if any of these default versions meet the requirements of a hosted implementation, they all should.
}}

{{cpp/memory/new/minimal replacement example}}

Overloads of {{tt|operator new}} and {{tt|operator new[]}} with additional user-defined parameters ("placement forms", versions {{vl|11-14}}) may be declared at global scope as usual, and are called by the matching [[cpp/language/new#Placement new|placement forms]] of {{c/core|new}} expressions.

The standard library's non-allocating placement forms of {{tt|operator new}} {{vl|9,10}} cannot be replaced and can only be customized if the placement {{c/core|new}} expression did not use the {{c/core|::new}} syntax, by providing a class-specific placement {{c/core|new}} {{vl|19,20}} with matching signature: {{c/core|void* T::operator new(std::size_t, void*)}} or {{c/core|void* T::operator new[](std::size_t, void*)}}.

{{rrev|since=c++14|
The placement form {{c/core|void* operator new(std::size_t, std::size_t)}} is not allowed because the matching signature of the deallocation function, {{c/core|void operator delete(void*, std::size_t)}}, is a usual (not placement) deallocation function.
}}

===Class-specific overloads===
Both single-object and array allocation functions may be defined as public static member functions of a class (versions {{vl|15-18}}). If defined, these allocation functions are called by {{c/core|new}} expressions to allocate memory for single objects and arrays of this class, unless the {{c/core|new}} expression used the form {{c/core|::new}} which bypasses class-scope lookup. The keyword {{ltt|cpp/keyword/static}} is optional for these functions: whether used or not, the allocation function is a static member function.

The {{c/core|new}} expression looks for appropriate allocation function's name firstly in the class scope, and after that in the global scope. Note, that as per [[cpp/language/lookup|name lookup rules]], any allocation functions declared in class scope hides all global allocation functions for the {{c/core|new}} expressions that attempt to allocate objects of this class.

{{rrev|since=c++17|
When allocating objects and arrays of objects whose alignment exceeds {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}}, overload resolution is performed twice: first, for alignment-aware function signatures, then for alignment-unaware function signatures. This means that if a class with extended alignment has an alignment-unaware class-specific allocation function, it is the function that will be called, not the global alignment-aware allocation function. This is intentional: the class member is expected to know best how to handle that class.
}}

{{rrev|since=c++20|
When allocating objects and arrays of objects whose alignment does not exceed {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}}, overload resolution is performed twice: first, for alignment-unaware function signatures, then for alignment-aware function signatures.
}}

{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;

// class-specific allocation functions
struct X
{
    static void* operator new(std::size_t count)
    {
        std::cout &lt;&lt; "custom new for size " &lt;&lt; count &lt;&lt; '\n';
        return ::operator new(count);
    }
    
    static void* operator new[](std::size_t count)
    {
        std::cout &lt;&lt; "custom new[] for size " &lt;&lt; count &lt;&lt; '\n';
        return ::operator new[](count);
    }
};

int main()
{
    X* p1 = new X;
    delete p1;
    X* p2 = new X[10];
    delete[] p2;
}
|p=true
|output=
custom new for size 1
custom new[] for size 10
}}

Overloads of {{tt|operator new}} and {{tt|operator new[]}} with additional user-defined parameters ("placement forms"), may also be defined as class members {{vl|19-22}}). When the placement {{c/core|new}} expression with the matching signature looks for the corresponding allocation function to call, it begins at class scope before examining the global scope, and if the class-specific placement {{c/core|new}} is provided, it is called.

{{rrev|since=c++17|
When allocating objects and arrays of objects whose alignment exceeds {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}}, overload resolution for placement forms is performed twice just as for regular forms: first, for alignment-aware function signatures, then for alignment-unaware function signatures.
}}

{{rrev|since=c++20|
When allocating objects and arrays of objects whose alignment does not exceed {{c|__STDCPP_DEFAULT_NEW_ALIGNMENT__}}, overload resolution for placement forms is performed twice just as for regular forms: first, for alignment-unaware function signatures, then for alignment-aware function signatures.
}}

{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

struct X
{
    X() { throw std::runtime_error(""); }
    
    // custom placement new
    static void* operator new(std::size_t count, bool b)
    {
        std::cout &lt;&lt; "custom placement new called, b = " &lt;&lt; b &lt;&lt; '\n';
        return ::operator new(count);
    }
    
    // custom placement delete
    static void operator delete(void* ptr, bool b)
    {
        std::cout &lt;&lt; "custom placement delete called, b = " &lt;&lt; b &lt;&lt; '\n';
        ::operator delete(ptr);
    }
};

int main()
{
    try
    {
        [[maybe_unused]] X* p1 = new (true) X;
    }
    catch (const std::exception&amp;)
    {}
}
|output=
custom placement new called, b = 1
custom placement delete called, b = 1
}}

If class-level {{tt|operator new}} is a template function, it must have the return type of {{c/core|void*}}, the first argument {{lc|std::size_t}}, and it must have two or more parameters. In other words, only placement forms can be templates.

===Notes===
Even though the non-allocating placement {{c/core|new}} {{vl|9,10}} cannot be replaced, a function with the same signature may be defined at class scope as described above. In addition, global overloads that look like placement {{c/core|new}} but take a non-void pointer type as the second argument are allowed, so the code that wants to ensure that the true placement {{c/core|new}} is called (e.g. {{lc|std::allocator::construct}}), must use {{c/core|::new}} and also cast the pointer to {{c/core|void*}}.

If the behavior of a deallocation function does not satisfy the default constraints, the behavior is undefined.

{{cpp/memory/thread safety note}}

It is unspecified whether library versions of {{tt|operator new}} make any calls to {{lc|std::malloc}}{{rev inl|since=c++17| or {{lc|std::aligned_alloc}}}}.

For loading a large file, file mapping via OS-specific functions, e.g., {{posix|mmap}} on POSIX or {{tt|CreateFileMapping}}([https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga {{tt|A}}]/[https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-createfilemappingw {{tt|W}}]) along with [https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile {{tt|MapViewOfFile}}] on Windows, is preferable to allocating a buffer for file reading.

{{ftm begin}}
{{ftm|__cpp_lib_freestanding_operator_new|rowspan=2|value=202306L|std=C++26|freestanding support for replaceable {{c/core|operator new}}&lt;ref&gt;Formally, this macro expands to {{c|202306L}} if all the default versions of the replaceable global allocation functions meet the requirements of a hosted implementation.&lt;/ref&gt;}}
{{ftm|-|value=0|std=C++26|no freestanding support}}
{{ftm|__cpp_lib_constexpr_new|value=202406L|std=C++26|{{c/core|constexpr}} placement {{c/core|new}} and {{c/core|new[]}}}}
{{ftm end}}
&lt;references/&gt;

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=521|std=C++98|before=any class derived from {{lc|std::bad_alloc}} could be thrown,&lt;br&gt;even if the {{lc|std::bad_alloc}} base is ambiguous or inaccessible|after=the exception thrown should match&lt;br&gt;a handler of type {{lc|std::bad_alloc}}}}
{{dr list item|wg=lwg|dr=9|std=C++98|before=multiple calls for allocating zero&lt;br&gt;bytes could yield the same pointer|after=only allowed if all such previously&lt;br&gt;yielded pointers have been&lt;br&gt;passed to deallocation functions}}
{{dr list item|wg=lwg|dr=206|std=C++98|before=replacing the replaceable allocation functions did&lt;br&gt;not affect the default behaviors of the corresponding&lt;br&gt;replaceable non-throwing allocation functions|after=the default behaviors&lt;br&gt;change accordingly}}
{{dr list item|wg=lwg|dr=404|std=C++98|before=replacements of the replaceable allocation&lt;br&gt;functions could be declared {{c/core|inline}}|after=prohibited, no diagnostic required}}
{{dr list end}}

===References===
{{ref std c++23}}
{{ref std|section=17.7|title=Dynamic memory management|id=support.dynamic}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=17.6|title=Dynamic memory management|id=support.dynamic}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=21.6|title=Dynamic memory management|id=support.dynamic}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=18.6|title=Dynamic memory management|id=support.dynamic}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=18.6|title=Dynamic memory management|id=support.dynamic}}
{{ref std end}}
{{ref std c++03}}
{{ref std|section=18.4|title=Dynamic memory management|id=lib.support.dynamic}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=18.4|title=Dynamic memory management|id=lib.support.dynamic}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/coroutine/generator/promise_type/dsc operator new}}
{{dsc inc|cpp/memory/new/dsc operator_delete}}
{{dsc inc|cpp/memory/new/dsc get_new_handler}}
{{dsc inc|cpp/memory/new/dsc set_new_handler}}
{{dsc inc|cpp/memory/dsc get_temporary_buffer}}
{{dsc inc|cpp/memory/c/dsc malloc}}
{{dsc inc|cpp/memory/c/dsc aligned_alloc}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}