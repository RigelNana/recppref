{{cpp/title|static_pointer_cast|dynamic_pointer_cast|const_pointer_cast|reinterpret_pointer_cast}}
{{cpp/memory/shared_ptr/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcla|num=1|since=c++11|1=
template&lt; class T, class U &gt;
std::shared_ptr&lt;T&gt; static_pointer_cast( const std::shared_ptr&lt;U&gt;&amp; r ) noexcept;
}}
{{dcl|num=2|since=c++20|1=
template&lt; class T, class U &gt;
std::shared_ptr&lt;T&gt; static_pointer_cast( std::shared_ptr&lt;U&gt;&amp;&amp; r ) noexcept;
}}
{{dcla|num=3|since=c++11|1=
template&lt; class T, class U &gt;
std::shared_ptr&lt;T&gt; dynamic_pointer_cast( const std::shared_ptr&lt;U&gt;&amp; r ) noexcept;
}}
{{dcl|num=4|since=c++20|1=
template&lt; class T, class U &gt;
std::shared_ptr&lt;T&gt; dynamic_pointer_cast( std::shared_ptr&lt;U&gt;&amp;&amp; r ) noexcept;
}}
{{dcla|num=5|since=c++11|1=
template&lt; class T, class U &gt;
std::shared_ptr&lt;T&gt; const_pointer_cast( const std::shared_ptr&lt;U&gt;&amp; r ) noexcept;
}}
{{dcl|num=6|since=c++20|1=
template&lt; class T, class U &gt;
std::shared_ptr&lt;T&gt; const_pointer_cast( std::shared_ptr&lt;U&gt;&amp;&amp; r ) noexcept;
}}
{{dcla|num=7|since=c++17|1=
template&lt; class T, class U &gt;
std::shared_ptr&lt;T&gt; reinterpret_pointer_cast( const std::shared_ptr&lt;U&gt;&amp; r ) noexcept;
}}
{{dcl|num=8|since=c++20|1=
template&lt; class T, class U &gt;
std::shared_ptr&lt;T&gt; reinterpret_pointer_cast( std::shared_ptr&lt;U&gt;&amp;&amp; r ) noexcept;
}}
{{dcl end}}
Creates a new instance of {{lc|std::shared_ptr}} whose stored pointer is obtained from {{c|r}}'s stored pointer using a cast expression.

If {{c|r}} is empty, so is the new {{tt|shared_ptr}} (but its stored pointer is not necessarily null). Otherwise, the new {{tt|shared_ptr}} will share ownership with the initial value of {{c|r}}, except that it is empty if the {{tt|dynamic_cast}} performed by {{tt|dynamic_pointer_cast}} returns a null pointer.

Let {{tt|Y}} be {{c|typename std::shared_ptr&lt;T&gt;::element_type}}, then the resulting {{lc|std::shared_ptr}}'s stored pointer will be obtained by evaluating, respectively:

@1,2@ {{c|static_cast&lt;Y*&gt;(r.get())}}
@3,4@ {{c|dynamic_cast&lt;Y*&gt;(r.get())}}. If the result of the {{tt|dynamic_cast}} is a null pointer value, the returned {{tt|shared_ptr}} will be empty.
@5,6@ {{c|const_cast&lt;Y*&gt;(r.get())}}
@7,8@ {{c|reinterpret_cast&lt;Y*&gt;(r.get())}}

The behavior of these functions is undefined unless the corresponding cast from {{tt|U*}} to {{tt|T*}} is well formed:

@1,2@ The behavior is undefined unless {{c|static_cast&lt;T*&gt;((U*)nullptr)}} is well formed.
@3,4@ The behavior is undefined unless {{c|dynamic_cast&lt;T*&gt;((U*)nullptr)}} is well formed.
@5,6@ The behavior is undefined unless {{c|const_cast&lt;T*&gt;((U*)nullptr)}} is well formed.
@7,8@ The behavior is undefined unless {{c|reinterpret_cast&lt;T*&gt;((U*)nullptr)}} is well formed.

{{rrev|since=c++20|
After calling the rvalue overloads {{v|2,4,6,8}}, {{c|r}} is empty and {{c|r.get() {{==}} nullptr}}, except that {{c|r}} is not modified for {{tt|dynamic_pointer_cast}} {{v|4}} if the {{c|dynamic_cast}} fails.
}}

===Parameters===
{{par begin}}
{{par|r|the pointer to convert}}
{{par end}}

===Notes===
The expressions {{c|std::shared_ptr&lt;T&gt;(static_cast&lt;T*&gt;(r.get()))}}, {{c|std::shared_ptr&lt;T&gt;(dynamic_cast&lt;T*&gt;(r.get()))}} and {{c|std::shared_ptr&lt;T&gt;(const_cast&lt;T*&gt;(r.get()))}} might seem to have the same effect, but they all will likely result in undefined behavior, attempting to delete the same object twice!

===Possible implementation===
{{eq impl
|title1=static_pointer_cast|ver1=1|1=
template&lt;class T, class U&gt;
std::shared_ptr&lt;T&gt; static_pointer_cast(const std::shared_ptr&lt;U&gt;&amp; r) noexcept
{
    auto p = static_cast&lt;typename std::shared_ptr&lt;T&gt;::element_type*&gt;(r.get());
    return std::shared_ptr&lt;T&gt;{r, p};
}
|title2=dynamic_pointer_cast|ver2=3|2=
template&lt;class T, class U&gt;
std::shared_ptr&lt;T&gt; dynamic_pointer_cast(const std::shared_ptr&lt;U&gt;&amp; r) noexcept
{
    if (auto p = dynamic_cast&lt;typename std::shared_ptr&lt;T&gt;::element_type*&gt;(r.get()))
        return std::shared_ptr&lt;T&gt;{r, p};
    else
        return std::shared_ptr&lt;T&gt;{};
}
|title3=const_pointer_cast|ver3=5|3=
template&lt;class T, class U&gt;
std::shared_ptr&lt;T&gt; const_pointer_cast(const std::shared_ptr&lt;U&gt;&amp; r) noexcept
{
    auto p = const_cast&lt;typename std::shared_ptr&lt;T&gt;::element_type*&gt;(r.get());
    return std::shared_ptr&lt;T&gt;{r, p};
}
|title4=reinterpret_pointer_cast|ver4=7|4=
template&lt;class T, class U&gt;
std::shared_ptr&lt;T&gt; reinterpret_pointer_cast(const std::shared_ptr&lt;U&gt;&amp; r) noexcept
{
    auto p = reinterpret_cast&lt;typename std::shared_ptr&lt;T&gt;::element_type*&gt;(r.get());
    return std::shared_ptr&lt;T&gt;{r, p};
}
}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;
 
class Base
{
public:
    int a;
    virtual void f() const { std::cout &lt;&lt; "I am base!\n"; }
    virtual ~Base() {}
};
 
class Derived : public Base
{
public:
    void f() const override { std::cout &lt;&lt; "I am derived!\n"; }
    ~Derived() {}
};

int main()
{
    auto basePtr = std::make_shared&lt;Base&gt;();
    std::cout &lt;&lt; "Base pointer says: ";
    basePtr-&gt;f();
    
    auto derivedPtr = std::make_shared&lt;Derived&gt;();
    std::cout &lt;&lt; "Derived pointer says: ";
    derivedPtr-&gt;f();
    
    // static_pointer_cast to go up class hierarchy
    basePtr = std::static_pointer_cast&lt;Base&gt;(derivedPtr);
    std::cout &lt;&lt; "Base pointer to derived says: ";
    basePtr-&gt;f();
    
    // dynamic_pointer_cast to go down/across class hierarchy
    auto downcastedPtr = std::dynamic_pointer_cast&lt;Derived&gt;(basePtr);
    if (downcastedPtr)
    {
        std::cout &lt;&lt; "Downcasted pointer says: ";
        downcastedPtr-&gt;f();
    }
    
    // All pointers to derived share ownership
    std::cout &lt;&lt; "Pointers to underlying derived: "
              &lt;&lt; derivedPtr.use_count()
              &lt;&lt; '\n';
}
|output=
Base pointer says: I am base!
Derived pointer says: I am derived!
Base pointer to derived says: I am derived!
Downcasted pointer says: I am derived!
Pointers to underlying derived: 3
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/shared_ptr/dsc constructor}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}