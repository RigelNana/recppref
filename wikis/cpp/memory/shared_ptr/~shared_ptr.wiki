{{cpp/memory/shared_ptr/title|~shared_ptr}}
{{cpp/memory/shared_ptr/navbar}}
{{ddcl|
~shared_ptr();
}}

If {{c|*this}} owns an object and it is the last {{tt|shared_ptr}} owning it, the object is destroyed through the owned deleter. 

After the destruction, the smart pointers that shared ownership with {{c|*this}}, if any, will report a {{lc|use_count()}} that is one less than its previous value.

===Notes===
Unlike {{lc|std::unique_ptr}}, the deleter of {{lc|std::shared_ptr}} is invoked even if the managed pointer is null.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;

struct S
{
    S() { std::cout &lt;&lt; "S::S()\n"; }
    ~S() { std::cout &lt;&lt; "S::~S()\n"; }
    struct Deleter
    {
        void operator()(S* s) const
        {
            std::cout &lt;&lt; "S::Deleter()\n";
            delete s;
        }
    };
};

int main()
{
    auto sp = std::shared_ptr&lt;S&gt;{new S, S::Deleter{}&lt;!----&gt;};

    auto use_count = [&amp;sp](char c)
    {
        std::cout &lt;&lt; c &lt;&lt; ") use_count(): " &lt;&lt; sp.use_count() &lt;&lt; '\n';
    };

    use_count('A');
    {
        auto sp2 = sp;
        use_count('B');
        {
            auto sp3 = sp;
            use_count('C');
        }
        use_count('D');
    }
    use_count('E');

//  sp.reset();
//  use_count('F'); // would print "F) use_count(): 0"
}
|output=
S::S()
A) use_count(): 1
B) use_count(): 2
C) use_count(): 3
D) use_count(): 2
E) use_count(): 1
S::Deleter()
S::~S()
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/weak_ptr/dsc destructor}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}