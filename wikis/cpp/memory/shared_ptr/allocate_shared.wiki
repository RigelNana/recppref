{{cpp/title|allocate_shared|allocate_shared_for_overwrite}}
{{cpp/memory/shared_ptr/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcl|num=1|since=c++11|notes={{mark|T is non-array}}|
template&lt; class T, class Alloc, class... Args &gt;
shared_ptr&lt;T&gt; allocate_shared( const Alloc&amp; alloc, Args&amp;&amp;... args );
}}
{{dcl|num=2|since=c++20|notes={{mark|T is U[]}}|
template&lt; class T, class Alloc &gt;
shared_ptr&lt;T&gt; allocate_shared( const Alloc&amp; alloc, std::size_t N );
}}
{{dcl|num=3|since=c++20|notes={{mark|T is U[N]}}|
template&lt; class T, class Alloc &gt;
shared_ptr&lt;T&gt; allocate_shared( const Alloc&amp; alloc );
}}
{{dcl|num=4|since=c++20|notes={{mark|T is U[]}}|
template&lt; class T, class Alloc &gt;
shared_ptr&lt;T&gt; allocate_shared( const Alloc&amp; alloc, std::size_t N,
                               const std::remove_extent_t&lt;T&gt;&amp; u );
}}
{{dcl|num=5|since=c++20|notes={{mark|T is U[N]}}|
template&lt; class T, class Alloc &gt;
shared_ptr&lt;T&gt; allocate_shared( const Alloc&amp; alloc,
                               const std::remove_extent_t&lt;T&gt;&amp; u );
}}
{{dcla|num=6|since=c++20|notes={{mark|T is not U[]}}|
template&lt; class T, class Alloc &gt;
shared_ptr&lt;T&gt; allocate_shared_for_overwrite( const Alloc&amp; alloc );
}}
{{dcl|num=7|since=c++20|notes={{mark|T is U[]}}|
template&lt; class T, class Alloc &gt;
shared_ptr&lt;T&gt; allocate_shared_for_overwrite( const Alloc&amp; alloc, std::size_t N );
}}
{{dcl end}}

@1@ Constructs an object of type {{tt|T}} and wraps it in a {{lc|std::shared_ptr}} using {{c|args}} as the parameter list for the constructor of {{tt|T}}. The object is constructed as if by the expression {{rev inl|until=c++20|{{c|::new (pv) T(v)}}}}{{rev inl|since=c++20|{{c|std::allocator_traits&lt;A2&gt;::construct(a, pv, v)}}}}, where {{tt|pv}} is an internal {{c|void*}} pointer to storage suitable to hold an object of type {{tt|T}} and {{tt|a}} is a copy of the allocator rebound to {{c|std::remove_cv_t&lt;T&gt;}}. The storage is typically larger than {{tt|sizeof(T)}} in order to use one allocation for both the control block of the shared pointer and the {{tt|T}} object. The {{lc|std::shared_ptr}} constructor called by this function enables {{tt|shared_from_this}} with a pointer to the newly constructed object of type {{tt|T}}. All memory allocation is done using a copy of {{c|alloc}}, which must satisfy the {{named req|Allocator}} requirements. {{cpp/enable_if|T is not an array type}}.
@2,3@ Same as {{v|1}}, but the object constructed is a possibly-multidimensional array whose every non-array element is initialized as if by the expression {{c|std::allocator_traits&lt;A2&gt;::construct(a2, pv)}} where {{tt|a2}} of type {{tt|A2}} is the copy of the allocator rebound to manage objects of type {{c|std::remove_cv_t&lt;std::remove_all_extents_t&lt;T&gt;&gt;}}. The overload {{v|2}} creates an array of size {{c|N}} along its first dimension. The array elements are initialized in ascending order of their addresses, and when their lifetime ends are destroyed in the reverse order of their original construction.
@4,5@ Same as {{v|2,3}}, but the elements of the array are initialized from the default value {{c|u}}. If {{c|std::remove_extent_t&lt;T&gt;}} is not itself an array type, then this is performed as if by the same allocator expression as in {{v|1}}, except that the allocator is rebound to the {{c|std::remove_cv_t&lt;std::remove_all_extents_t&lt;T&gt;&gt;}}. Otherwise, this is performed as if by initializing every non-array element of the (possibly multidimensional) array with the corresponding element from {{c|u}} using the same allocator expression as in {{v|1}}, except that the allocator is rebound to the type {{c|std::remove_cv_t&lt;std::remove_all_extents_t&lt;T&gt;&gt;}}. The overload {{v|4}} creates an array of size {{c|N}} along the first dimension. The array elements are initialized in ascending order of their addresses, and when their lifetime ends are destroyed in the reverse order of their original construction.
@6@ Same as {{v|1}} if {{tt|T}} is not an array type and {{v|3}} if {{tt|T}} is {{tt|U[N]}}, except that the created object is [[cpp/language/default_initialization|default-initialized]].
@7@ Same as {{v|2}}, except that the individual array elements are [[cpp/language/default_initialization|default-initialized]].

For {{tt|allocate_shared}}, the object {{rev inl|since=c++20|(or the individual array elements for {{v|2-5}})}} are destroyed via the expression {{c|std::allocator_traits&lt;A2&gt;::destroy(a, p)}}, where {{tt|p}} is a pointer to the object and {{tt|a}} is a copy of the allocator passed to {{tt|allocate_shared}}, rebound to the type of the object being destroyed.

{{rrev|since=c++20|
For {{tt|allocate_shared_for_overwrite}}, the object (or individual elements if {{tt|T}} is an array type) will be destroyed by {{c|p-&gt;~X()}}, where {{tt|p}} is a pointer to the object and {{tt|X}} is its type.
}}

===Parameters===
{{par begin}}
{{par|alloc|the {{named req|Allocator}} to use}}
{{par|args...|list of arguments with which an instance of {{tt|T}} will be constructed}}
{{par|N|array size to use}}
{{par|u|the initial value to initialize every element of the array}}
{{par end}}

===Return value===
{{lc|std::shared_ptr}} of an instance of type {{tt|T}}.

===Exceptions===
Can throw the exceptions thrown from {{c|Alloc::allocate()}} or from the constructor of {{tt|T}}. If an exception is thrown, {{v|1}} has no effect. {{rev inl|since=c++20|If an exception is thrown during the construction of the array, already-initialized elements are destroyed in reverse order}}.

===Notes===
Like {{lc|std::make_shared}}, this function typically performs only one allocation, and places both the {{tt|T}} object and the control block in the allocated memory block (the standard recommends but does not require this, all known implementations do this). A copy of {{c|alloc}} is stored as part of the control block so that it can be used to deallocate it once both shared and weak reference counts reach zero.

Unlike the {{tt|std::shared_ptr}} {{rlpt|shared_ptr|constructors}}, {{tt|std::allocate_shared}} does not accept a separate custom deleter: the supplied allocator is used for destruction of the control block and the {{tt|T}} object, and for deallocation of their shared memory block.

{{rrev|until=c++20|
{{lc|std::shared_ptr}} supports array types (as of C++17), but {{tt|std::allocate_shared}} does not. This functionality is supported by [https://www.boost.org/doc/libs/1_66_0/libs/smart_ptr/doc/html/smart_ptr.html#make_shared {{tt|boost::allocate_shared}}].
}}

{{cpp/memory/shared ptr/enabling shared from this|plural=yes}}

{{feature test macro|__cpp_lib_smart_ptr_for_overwrite|Smart pointer creation with default initialization ({{tt|std::allocate_shared_for_overwrite}}, {{lc|std::make_shared_for_overwrite}}, {{lc|std::make_unique_for_overwrite}}); overloads {{vl|6,7}}|value=202002L|std=C++20}}

===Example===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;memory_resource&gt;
#include &lt;vector&gt;

class Value
{
    int i;

public:
    Value(int i) : i(i) { std::cout &lt;&lt; "Value(), i = " &lt;&lt; i &lt;&lt; '\n'; }
    ~Value() { std::cout &lt;&lt; "~Value(), i = " &lt;&lt; i &lt;&lt; '\n'; }
    void print() const { std::cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; '\n'; }
};

int main()
{
    // Create a polymorphic allocator using the monotonic buffer resource
    std::byte buffer[sizeof(Value) * 8];
    std::pmr::monotonic_buffer_resource resource(buffer, sizeof(buffer));
    std::pmr::polymorphic_allocator&lt;Value&gt; allocator(&amp;resource);

    std::vector&lt;std::shared_ptr&lt;Value&gt;&gt; v;

    for (int i{}; i != 4; ++i)
        // Use std::allocate_shared with the custom allocator
        v.emplace_back(std::allocate_shared&lt;Value&gt;(allocator, i));

    for (const auto&amp; sp : v)
        sp-&gt;print();

} //&lt; All shared pointers will automatically clean up when they go out of scope.
|output=
Value(), i = 0
Value(), i = 1
Value(), i = 2
Value(), i = 3
i = 0
i = 1
i = 2
i = 3
~Value(), i = 0
~Value(), i = 1
~Value(), i = 2
~Value(), i = 3
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/shared_ptr/dsc constructor}}
{{dsc inc|cpp/memory/shared_ptr/dsc make_shared}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}