{{cpp/title|atomic_...{{dsc small|&lt;std::shared_ptr&gt;}}}}
{{cpp/memory/shared_ptr/navbar}}

{{dcl begin}}
{{dcl header|memory}}
{{dcl|num=1|since=c++11|deprecated=c++20|until=c++26|1= 
template&lt; class T &gt;
bool atomic_is_lock_free( const std::shared_ptr&lt;T&gt;* p );
}}
{{dcl|num=2|since=c++11|deprecated=c++20|until=c++26|1= 
template&lt; class T &gt;
std::shared_ptr&lt;T&gt; atomic_load( const std::shared_ptr&lt;T&gt;* p );
}}
{{dcl|num=3|since=c++11|deprecated=c++20|until=c++26|1= 
template&lt; class T &gt;
std::shared_ptr&lt;T&gt; atomic_load_explicit
    ( const std::shared_ptr&lt;T&gt;* p, std::memory_order mo );
}}
{{dcl|num=4|since=c++11|deprecated=c++20|until=c++26|1= 
template&lt; class T &gt;
void atomic_store( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt; r );
}}
{{dcl|num=5|since=c++11|deprecated=c++20|until=c++26|1= 
template&lt; class T &gt;
void atomic_store_explicit
    ( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt; r,
      std::memory_order mo );
}}
{{dcl|num=6|since=c++11|deprecated=c++20|until=c++26|1= 
template&lt; class T &gt;
std::shared_ptr&lt;T&gt; atomic_exchange
    ( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt; r );
}}
{{dcl|num=7|since=c++11|deprecated=c++20|until=c++26|1= 
template&lt; class T &gt;
std::shared_ptr&lt;T&gt; atomic_exchange_explicit
    ( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt; r,
      std::memory_order mo );
}}
{{dcl|num=8|since=c++11|deprecated=c++20|until=c++26|1= 
template&lt; class T &gt;
bool atomic_compare_exchange_weak
    ( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt;* expected,
      std::shared_ptr&lt;T&gt; desired );
}}
{{dcl|num=9|since=c++11|deprecated=c++20|until=c++26|1= 
template&lt; class T &gt;
bool atomic_compare_exchange_strong
    ( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt;* expected,
      std::shared_ptr&lt;T&gt; desired );
}}
{{dcl|num=10|since=c++11|deprecated=c++20|until=c++26|1= 
template&lt; class T &gt;
bool atomic_compare_exchange_strong_explicit
    ( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt;* expected,
      std::shared_ptr&lt;T&gt; desired,
      std::memory_order success, std::memory_order failure );
}}
{{dcl|num=11|since=c++11|deprecated=c++20|until=c++26|1= 
template&lt; class T &gt;
bool atomic_compare_exchange_weak_explicit
    ( std::shared_ptr&lt;T&gt;* p, std::shared_ptr&lt;T&gt;* expected,
      std::shared_ptr&lt;T&gt; desired,
      std::memory_order success, std::memory_order failure );
}}
{{dcl end}}

If multiple threads of execution access the same {{lc|std::shared_ptr}} object without synchronization and any of those accesses uses a non-const member function of {{tt|shared_ptr}} then a data race will occur unless all such access is performed through these functions, which are overloads of the corresponding atomic access functions ({{lc|std::atomic_load}}, {{lc|std::atomic_store}}, etc.).

Note that the control block of a {{tt|shared_ptr}} is thread-safe: different {{lc|std::shared_ptr}} objects can be accessed using mutable operations, such as {{c/core|1=operator=}} or {{tt|reset}}, simultaneously by multiple threads, even when these instances are copies, and share the same control block internally.

@1@ Determines whether atomic access to the shared pointer pointed-to by {{c|p}} is lock-free.

@2@ Equivalent to {{c|atomic_load_explicit(p, std::memory_order_seq_cst)}}.

@3@ Returns the shared pointer pointed-to by {{c|p}}.
@@ As with the non-specialized {{lc|std::atomic_load_explicit}}, if {{c|mo}} is {{c|std::memory_order_release}} or {{c|std::memory_order_acq_rel}}, the behavior is undefined.

@4@ Equivalent to {{c|atomic_store_explicit(p, r, std::memory_order_seq_cst)}}.

@5@ Stores the shared pointer {{c|r}} in the shared pointer pointed-to by {{c|p}} atomically, {{lt|cpp/language/as if}} by {{c|p-&gt;swap(r)}}.
@@ As with the non-specialized {{lc|std::atomic_store_explicit}}, if {{c|mo}} is {{c|std::memory_order_acquire}} or {{c|std::memory_order_acq_rel}}, the behavior is undefined.

@6@ Equivalent to {{c|atomic_exchange_explicit(p, r, std::memory_order_seq_cst)}}.

@7@ Stores the shared pointer {{c|r}} in the shared pointer pointed to by {{c|p}} and returns the value formerly pointed-to by {{c|p}}, atomically, {{lt|cpp/language/as if}} by {{c|p-&gt;swap(r)}} and returns a copy of {{c|r}} after the swap.

@8@ Equivalent to
@@ {{c multi
|atomic_compare_exchange_weak_explicit
|    (p, expected, desired, std::memory_order_seq_cst,
|                           std::memory_order_seq_cst)}}.

@9@ Equivalent to
@@ {{c multi
|atomic_compare_exchange_strong_explicit
|    (p, expected, desired, std::memory_order_seq_cst,
|                           std::memory_order_seq_cst)}}.

@10,11@ Compares the shared pointers pointed-to by {{c|p}} and {{c|expected}}.
* If they are equivalent (store the same pointer value, and either share ownership of the same object or are both empty), assigns {{c|desired}} into {{c|*p}} using the memory ordering constraints specified by {{c|success}} and returns {{c|true}}.
* If they are not equivalent, assigns {{c|*p}} into {{c|*expected}} using the memory ordering constraints specified by {{c|failure}} and returns {{c|false}}.
@@ {{tt|atomic_compare_exchange_weak_explicit}} may fail spuriously.
@@ If {{c|expected}} is a null pointer, or {{c|failure}} is {{c|std::memory_order_release}} or {{c|std::memory_order_acq_rel}}, the behavior is undefined.

If {{c|p}} is a null pointer, the behaviors of these functions are all undefined.

===Parameters===
{{par begin}}
{{par|p, expected|a pointer to a {{lc|std::shared_ptr}}}}
{{par|r, desired|a {{lc|std::shared_ptr}}}}
{{par|mo, success, failure|memory ordering selectors of type {{lc|std::memory_order}}}}
{{par end}}

===Exceptions===
These functions do not throw exceptions.

===Return value===
@1@ {{c|true}} if atomic access is implemented using lock-free instructions.
@2,3@ A copy of the pointed-to shared pointer.
@4,5@ (none)
@6,7@ A copy of the formerly pointed-to shared pointer.
@8-11@ {{c|true}} if the shared pointers were equivalent and the exchange was performed, {{c|false}} otherwise.

===Notes===
These functions are typically implemented using mutexes, stored in a global hash table where the pointer value is used as the key.

The [[cpp/experimental/concurrency|Concurrency TS]] offers atomic smart pointer classes {{tt|atomic_shared_ptr}} and {{tt|atomic_weak_ptr}} as a replacement for the use of these functions.

{{rrev multi|since1=c++20|until1=c++26|rev1=
These functions were deprecated in favor of the specializations of the {{lc|std::atomic}} template: {{c/core|std::atomic&lt;std::shared_ptr&gt;}} and {{c/core|std::atomic&lt;std::weak_ptr&gt;}}.
|rev2=
These functions were removed in favor of the specializations of the {{lc|std::atomic}} template: {{c/core|std::atomic&lt;std::shared_ptr&gt;}} and {{c/core|std::atomic&lt;std::weak_ptr&gt;}}.
}}

===Example===
{{example}} &lt;!-- adapt from http://stackoverflow.com/a/16617935/273767 --&gt;

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2172|std=C++11|before={{c|expected}} could be a null pointer|after=the behavior is undefined in this case}}
{{dr list item|wg=lwg|dr=2980|std=C++11|before=empty {{tt|shared_ptr}}s were never equivalent|after=equivalent if they store the same pointer value}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/atomic/dsc atomic_is_lock_free}}
{{dsc inc|cpp/atomic/dsc atomic_store}}
{{dsc inc|cpp/atomic/dsc atomic_load}}
{{dsc inc|cpp/atomic/dsc atomic_exchange}}
{{dsc inc|cpp/atomic/dsc atomic_compare_exchange}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}