{{cpp/title|atomic{{petty|&lt;std::shared_ptr&gt;}}}}
{{cpp/memory/shared_ptr/navbar}}
{{ddcl|header=memory|since=c++20|1=
template&lt; class T &gt;
struct std::atomic&lt;std::shared_ptr&lt;T&gt;&gt;;
}}

The partial template specialization of {{lc|std::atomic}} for {{c|std::shared_ptr&lt;T&gt;}} allows users to manipulate {{tt|shared_ptr}} objects atomically.

If multiple threads of execution access the same {{lc|std::shared_ptr}} object without synchronization and any of those accesses uses a non-const member function of {{lc|shared_ptr}} then a data race will occur unless all such access is performed through an instance of {{c|std::atomic&lt;std::shared_ptr&gt;}} (or, deprecated as of C++20, through the [[cpp/memory/shared_ptr/atomic|standalone functions]] for atomic access to {{lc|std::shared_ptr}}).

Associated {{tt|use_count}} increments are guaranteed to be part of the atomic operation. Associated {{tt|use_count}} decrements are sequenced after the atomic operation, but are not required to be part of it, except for the {{tt|use_count}} change when overriding {{c|expected}} in a failed CAS. Any associated deletion and deallocation are sequenced after the atomic update step and are not part of the atomic operation.

Note that the control block of a {{tt|shared_ptr}} is thread-safe: different non-atomic {{lc|std::shared_ptr}} objects can be accessed using mutable operations, such as {{c|1=operator=}} or {{c|reset}}, simultaneously by multiple threads, even when these instances are copies, and share the same control block internally.

The type T may be an incomplete type.

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc|{{tt|value_type}}|{{c|std::shared_ptr&lt;T&gt;}}}}
{{dsc end}}

===Member functions===
All non-specialized {{lc|std::atomic}} functions are also provided by this specialization, and no additional member functions.

{{member|{{small|atomic&lt;shared_ptr&lt;T&gt;&gt;::}}atomic|2=
{{dcl begin}}
{{dcl|num=1|1=
constexpr atomic() noexcept = default;
}}
{{dcl|num=2|1=
constexpr atomic( std::nullptr_t ) noexcept : atomic() {}
}}
{{dcl|num=3|1=
atomic( std::shared_ptr&lt;T&gt; desired ) noexcept;
}}
{{dcl|num=4|1=
atomic( const atomic&amp; ) = delete;
}}
{{dcl end}}
@1,2@ Initializes the underlying {{c|shared_ptr&lt;T&gt;}} to the null value.
@3@ Initializes the underlying {{c|shared_ptr&lt;T&gt;}} to a copy of {{c|desired}}. As with any {{lc|std::atomic}} type, initialization is not an atomic operation.
@4@ Atomic types are not copy/move constructible.
}}

{{member|1={{small|atomic&lt;shared_ptr&lt;T&gt;&gt;::}}operator=|2=
{{dcl begin}}
{{dcl|num=1|1=
void operator=( const atomic&amp; ) = delete;
}}
{{dcl|num=2|1=
void operator=( std::shared_ptr&lt;T&gt; desired ) noexcept;
}}
{{dcl|num=3|1=
void operator=( std::nullptr_t ) noexcept;
}}
{{dcl end}}
@1@ Atomic types are not copy/move assignable.
@2@ Value assignment, equivalent to {{c|store(desired)}}.
@3@ Resets the atomic shared pointer to null pointer value. Equivalent to {{c|store(nullptr);}}.
}}

{{member|{{small|atomic&lt;shared_ptr&lt;T&gt;&gt;::}}is_lock_free|2=
{{dcl begin}}
{{dcl|1=
bool is_lock_free() const noexcept;
}}
{{dcl end}}
Returns {{c|true}} if the atomic operations on all objects of this type are lock-free, {{c|false}} otherwise.
}}

{{member|{{small|atomic&lt;shared_ptr&lt;T&gt;&gt;::}}store|2=
{{dcl begin}}
{{dcl|1=
void store( std::shared_ptr&lt;T&gt; desired,
            std::memory_order order = std::memory_order_seq_cst ) noexcept;
}}
{{dcl end}}
Atomically replaces the value of {{c|*this}} with the value of {{c|desired}} as if by {{c|p.swap(desired)}} where {{c|p}} is the underlying {{c|std::shared_ptr&lt;T&gt;}}. Memory is ordered according to {{c|order}}. The behavior is undefined if {{c|order}} is {{lc|std::memory_order_consume}}, {{lc|std::memory_order_acquire}}, or {{lc|std::memory_order_acq_rel}}.
}}

{{member|{{small|atomic&lt;shared_ptr&lt;T&gt;&gt;::}}load|2=
{{dcl begin}}
{{dcl|1=
std::shared_ptr&lt;T&gt; load( std::memory_order order = std::memory_order_seq_cst ) const noexcept;
}}
{{dcl end}}
Atomically returns a copy of the underlying shared pointer. Memory is ordered according to {{c|order}}. The behavior is undefined if {{c|order}} is {{lc|std::memory_order_release}} or {{lc|std::memory_order_acq_rel}}.
}}

{{member|{{small|atomic&lt;shared_ptr&lt;T&gt;&gt;::}}operator std::shared_ptr&lt;T&gt;|2=
{{dcl begin}}
{{dcl|1=
operator std::shared_ptr&lt;T&gt;() const noexcept;
}}
{{dcl end}}
Equivalent to {{c|return load();}}.
}}

{{member|{{small|atomic&lt;shared_ptr&lt;T&gt;&gt;::}}exchange|2=
{{dcl begin}}
{{dcl|1=
std::shared_ptr&lt;T&gt; exchange( std::shared_ptr&lt;T&gt; desired,
                             std::memory_order order = std::memory_order_seq_cst ) noexcept;

}}
{{dcl end}}
Atomically replaces the underlying {{c|std::shared_ptr&lt;T&gt;}} with {{c|desired}} as if by {{c|p.swap(desired)}} where {{c|p}} is the underlying {{c|std::shared_ptr&lt;T&gt;}} and returns a copy of the value that {{c|p}} had immediately before the swap. Memory is ordered according to {{c|order}}. This is an atomic read-modify-write operation.
}}

{{member|{{small|atomic&lt;shared_ptr&lt;T&gt;&gt;::}}compare_exchange_weak, compare_exchange_strong|2=
{{dcl begin}}
{{dcl|num=1|1=
bool compare_exchange_strong( std::shared_ptr&lt;T&gt;&amp; expected, std::shared_ptr&lt;T&gt; desired,
                              std::memory_order success, std::memory_order failure ) noexcept;
}}
{{dcl|num=2|1=
bool compare_exchange_weak( std::shared_ptr&lt;T&gt;&amp; expected, std::shared_ptr&lt;T&gt; desired,
                            std::memory_order success, std::memory_order failure ) noexcept;
}}
{{dcl|num=3|1=
bool compare_exchange_strong( std::shared_ptr&lt;T&gt;&amp; expected, std::shared_ptr&lt;T&gt; desired,
                              std::memory_order order = std::memory_order_seq_cst ) noexcept;
}}
{{dcl|num=4|1=
bool compare_exchange_weak( std::shared_ptr&lt;T&gt;&amp; expected, std::shared_ptr&lt;T&gt; desired,
                            std::memory_order order = std::memory_order_seq_cst ) noexcept;
}}
{{dcl end}}
@1@ If the underlying {{c|std::shared_ptr&lt;T&gt;}} stores the same {{c|T*}} as {{c|expected}} and shares ownership with it, or if both underlying and {{c|expected}} are empty, assigns from {{c|desired}} to the underlying {{c|std::shared_ptr&lt;T&gt;}}, returns {{c|true}}, and orders memory according to {{c|success}}, otherwise assigns from the underlying {{c|std::shared_ptr&lt;T&gt;}} to {{c|expected}}, returns {{c|false}}, and orders memory according to {{c|failure}}. The behavior is undefined if {{c|failure}} is {{lc|std::memory_order_release}} or {{lc|std::memory_order_acq_rel}}. On success, the operation is an atomic read-modify-write operation on {{c|*this}} and {{c|expected}} is not accessed after the atomic update. On failure, the operation is an atomic load operation on {{c|*this}} and {{c|expected}} is updated with the existing value read from the atomic object. This update to {{c|expected}}'s {{tt|use_count}} is part of this atomic operation, although the write itself (and any subsequent deallocation/destruction) is not required to be.
@2@ Same as {{v|1}}, but may also fail spuriously.
@3@ Equivalent to: {{c|return compare_exchange_strong(expected, desired, order, fail_order);}}, where {{tt|fail_order}} is the same as {{c|order}} except that {{lc|std::memory_order_acq_rel}} is replaced by {{lc|std::memory_order_acquire}} and {{lc|std::memory_order_release}} is replaced by {{lc|std::memory_order_relaxed}}.
@4@ Equivalent to: {{c|return compare_exchange_weak(expected, desired, order, fail_order);}}, where {{tt|fail_order}} is the same as {{c|order}} except that {{lc|std::memory_order_acq_rel}} is replaced by {{lc|std::memory_order_acquire}} and {{lc|std::memory_order_release}} is replaced by {{lc|std::memory_order_relaxed}}.
}}

{{member|{{small|atomic&lt;shared_ptr&lt;T&gt;&gt;::}}wait|2=
{{dcl begin}}
{{dcl|1=
void wait( std::shared_ptr&lt;T&gt; old,
           std::memory_order order = std::memory_order_seq_cst ) const noexcept;
}}
{{dcl end}}

Performs an atomic waiting operation.

Compares {{c|load(order)}} with {{c|old}} and if they are equivalent then blocks until {{c|*this}} is notified by {{tt|notify_one()}} or {{tt|notify_all()}}. This is repeated until {{c|load(order)}} changes. This function is guaranteed to return only if value has changed, even if underlying implementation unblocks spuriously.

Memory is ordered according to {{c|order}}. The behavior is undefined if {{c|order}} is {{lc|std::memory_order_release}} or {{lc|std::memory_order_acq_rel}}.

Notes: two {{tt|shared_ptr}}s are equivalent if they store the same pointer and either share ownership or are both empty.
}}

{{member|{{small|atomic&lt;shared_ptr&lt;T&gt;&gt;::}}notify_one|2=
{{dcl begin}}
{{dcl|1=
void notify_one() noexcept;
}}
{{dcl end}}

Performs an atomic notifying operation.

If there is a thread blocked in atomic waiting operations (i.e. {{tt|wait()}}) on {{c|*this}}, then unblocks at least one such thread; otherwise does nothing.
}}

{{member|{{small|atomic&lt;shared_ptr&lt;T&gt;&gt;::}}notify_all|2=
{{dcl begin}}
{{dcl|1=
void notify_all() noexcept;
}}
{{dcl end}}

Performs an atomic notifying operation.

Unblocks all threads blocked in atomic waiting operations (i.e. {{tt|wait()}}) on {{c|*this}}, if there are any; otherwise does nothing.
}}

===Member constants===
The only standard {{lc|std::atomic}} member constant {{tt|is_always_lock_free}} is also provided by this specialization.

{{member|{{small|atomic&lt;shared_ptr&lt;T&gt;&gt;::}}is_always_lock_free|2=
{{dcl begin}}
{{dcl|1=
static constexpr bool is_always_lock_free = /*implementation-defined*/;
}}
{{dcl end}}
}}

===Notes===
{{feature test macro|__cpp_lib_atomic_shared_ptr|{{ttt|std::atomic&lt;std::shared_ptr&gt;}}|value=201711L|std=C++20}}

===Example===
{{example
|code=
|output=
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3661|std=C++20|before={{tt|atomic&lt;shared_ptr&lt;T&gt;&gt;}} was not constant-initializable from {{c|nullptr}}|after=made constant-initializable}}
{{dr list item|wg=lwg|dr=3893|std=C++20|before={{wg21|LWG3661}} made {{tt|atomic&lt;shared_ptr&lt;T&gt;&gt;}} not assignable from {{tt|nullptr_t}}|after=assignability restored}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/atomic/dsc atomic}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}