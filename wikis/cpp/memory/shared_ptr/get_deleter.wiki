{{cpp/title|get_deleter}}
{{cpp/memory/shared_ptr/navbar}}
{{ddcl|header=memory|since=c++11|
template&lt; class Deleter, class T &gt;
Deleter* get_deleter( const std::shared_ptr&lt;T&gt;&amp; p ) noexcept;
}}

Access to the {{c|p}}'s deleter. If the shared pointer {{c|p}} owns a deleter of type cv-unqualified {{tt|Deleter}} (e.g. if it was created with one of the constructors that take a deleter as a parameter), then returns a pointer to the deleter. Otherwise, returns a null pointer.

===Parameters===
{{par begin}}
{{par|p|a shared pointer whose deleter needs to be accessed}}
{{par end}}

===Return value===
A pointer to the owned deleter or {{ltt|cpp/language/nullptr}}. The returned pointer is valid at least as long as there remains at least one {{lc|std::shared_ptr|shared_ptr}} instance that owns it.

===Notes===
The returned pointer may outlive the last {{lc|std::shared_ptr|shared_ptr}} if, for example, {{lc|std::weak_ptr}}s remain and the implementation doesn't destroy the deleter until the entire control block is destroyed.

===Example===
{{example
|Demonstrates that {{lc|std::shared_ptr}} deleter is independent of the {{lc|std::shared_ptr|shared_ptr}}'s type.
|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;

struct Foo { int i; };
void foo_deleter(Foo* p)
{
    std::cout &lt;&lt; "foo_deleter called!\n";
    delete p;
}

int main()
{
    std::shared_ptr&lt;int&gt; aptr;

    {
        // create a shared_ptr that owns a Foo and a deleter
        auto foo_p = new Foo;
        std::shared_ptr&lt;Foo&gt; r(foo_p, foo_deleter);
        aptr = std::shared_ptr&lt;int&gt;(r, &amp;r-&gt;i); // aliasing ctor
        // aptr is now pointing to an int, but managing the whole Foo
    } // r gets destroyed (deleter not called)

    // obtain pointer to the deleter:
    if (auto del_p = std::get_deleter&lt;void(*)(Foo*)&gt;(aptr))
    {
        std::cout &lt;&lt; "shared_ptr&lt;int&gt; owns a deleter\n";
        if (*del_p == foo_deleter)
            std::cout &lt;&lt; "...and it equals &amp;foo_deleter\n";
    }
    else
        std::cout &lt;&lt; "The deleter of shared_ptr&lt;int&gt; is null!\n";
} // deleter called here
|output=
shared_ptr&lt;int&gt; owns a deleter
...and it equals &amp;foo_deleter
foo_deleter called!
}}

===See also===
{{dsc begin}}
{{dsc mem ctor|cpp/memory/shared_ptr/shared_ptr|{{lc|std::shared_ptr}} constructors}}
{{dsc inc|cpp/memory/unique_ptr/dsc get_deleter}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}