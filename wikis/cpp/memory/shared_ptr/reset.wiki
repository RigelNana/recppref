{{cpp/memory/shared_ptr/title|reset}}
{{cpp/memory/shared_ptr/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++11|
void reset() noexcept;
}}
{{dcl|num=2|since=c++11|
template&lt; class Y &gt; 
void reset( Y* ptr );
}}
{{dcl|num=3|since=c++11|
template&lt; class Y, class Deleter &gt; 
void reset( Y* ptr, Deleter d );
}}
{{dcl|num=4|since=c++11|
template&lt; class Y, class Deleter, class Alloc &gt; 
void reset( Y* ptr, Deleter d, Alloc alloc );
}}
{{dcl end}}

Replaces the managed object with an object pointed to by {{c|ptr}}. Optional deleter {{c|d}} can be supplied, which is later used to destroy the new object when no {{tt|shared_ptr}} objects own it. By default, {{ltt|cpp/language/delete}} expression is used as deleter. Proper {{ltt|cpp/language/delete}} expression corresponding to the supplied type is always selected, this is the reason why the function is implemented as template using a separate parameter {{tt|Y}}.

If {{c|*this}} already owns an object and it is the last {{tt|shared_ptr}} owning it, the object is destroyed through the owned deleter.

If the object pointed to by {{c|ptr}} is already owned, the function generally results in undefined behavior.

@1@ Releases the ownership of the managed object, if any. After the call, {{c|*this}} manages no object. Equivalent to {{c|shared_ptr().swap(*this);}}.

@2-4@ Replaces the managed object with an object pointed to by {{c|ptr}}. {{tt|Y}} must be a complete type and implicitly convertible to {{tt|T}}. Additionally:

:@2@ Uses the delete expression as the deleter. A valid delete expression must be available, i.e. {{c|delete ptr}} must be well formed, have well-defined behavior and not throw any exceptions. Equivalent to {{c|shared_ptr&lt;T&gt;(ptr).swap(*this);}}.

:@3@ Uses the specified deleter {{c|d}} as the deleter. {{tt|Deleter}} must be callable for the type {{tt|T}}, i.e. {{c|d(ptr)}} must be well formed, have well-defined behavior and not throw any exceptions. {{tt|Deleter}} must be {{named req|CopyConstructible}}, and its copy constructor and destructor must not throw exceptions. Equivalent to {{c|shared_ptr&lt;T&gt;(ptr, d).swap(*this);}}.

:@4@ Same as {{v|3}}, but additionally uses a copy of {{c|alloc}} for allocation of data for internal use. {{tt|Alloc}} must be an {{named req|Allocator}}. The copy constructor and destructor must not throw exceptions. Equivalent to {{c|shared_ptr&lt;T&gt;(ptr, d, alloc).swap(*this);}}.

===Parameters===
{{par begin}}
{{par|ptr|pointer to an object to acquire ownership of}}
{{par|d|deleter to store for deletion of the object}}
{{par|alloc|allocator to use for internal allocations}}
{{par end}} 

===Return value===
(none)

===Exceptions===
@2@ {{lc|std::bad_alloc}} if required additional memory could not be obtained. May throw implementation-defined exception for other errors. {{c|delete ptr}} is called if an exception occurs.

@3,4@ {{lc|std::bad_alloc}} if required additional memory could not be obtained. May throw implementation-defined exception for other errors. {{c|d(ptr)}} is called if an exception occurs.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;

struct Foo
{
    Foo(int n = 0) noexcept : bar(n)
    {
        std::cout &lt;&lt; "Foo::Foo(), bar = " &lt;&lt; bar &lt;&lt; " @ " &lt;&lt; this &lt;&lt; '\n';
    }
    ~Foo()
    {
        std::cout &lt;&lt; "Foo::~Foo(), bar = " &lt;&lt; bar &lt;&lt; " @ " &lt;&lt; this &lt;&lt; '\n';
    }
    int getBar() const noexcept { return bar; }
private:
    int bar;
};

int main()
{
    std::cout &lt;&lt; "1) unique ownership\n";
    {
        std::shared_ptr&lt;Foo&gt; sptr = std::make_shared&lt;Foo&gt;(100);

        std::cout &lt;&lt; "Foo::bar = " &lt;&lt; sptr-&gt;getBar() &lt;&lt; ", use_count() = "
                  &lt;&lt; sptr.use_count() &lt;&lt; '\n';

        // Reset the shared_ptr without handing it a fresh instance of Foo.
        // The old instance will be destroyed after this call.
        std::cout &lt;&lt; "call sptr.reset()...\n";
        sptr.reset(); // calls Foo's destructor here
        std::cout &lt;&lt; "After reset(): use_count() = " &lt;&lt; sptr.use_count()
                  &lt;&lt; ", sptr = " &lt;&lt; sptr &lt;&lt; '\n';
    }   // No call to Foo's destructor, it was done earlier in reset().

    std::cout &lt;&lt; "\n2) unique ownership\n";
    {
        std::shared_ptr&lt;Foo&gt; sptr = std::make_shared&lt;Foo&gt;(200);

        std::cout &lt;&lt; "Foo::bar = " &lt;&lt; sptr-&gt;getBar() &lt;&lt; ", use_count() = "
                  &lt;&lt; sptr.use_count() &lt;&lt; '\n';

        // Reset the shared_ptr, hand it a fresh instance of Foo.
        // The old instance will be destroyed after this call.
        std::cout &lt;&lt; "call sptr.reset()...\n";
        sptr.reset(new Foo{222});
        std::cout &lt;&lt; "After reset(): use_count() = " &lt;&lt; sptr.use_count()
                  &lt;&lt; ", sptr = " &lt;&lt; sptr &lt;&lt; "\nLeaving the scope...\n";
    }   // Calls Foo's destructor.

    std::cout &lt;&lt; "\n3) multiple ownership\n";
    {
        std::shared_ptr&lt;Foo&gt; sptr1 = std::make_shared&lt;Foo&gt;(300);
        std::shared_ptr&lt;Foo&gt; sptr2 = sptr1;
        std::shared_ptr&lt;Foo&gt; sptr3 = sptr2;

        std::cout &lt;&lt; "Foo::bar = " &lt;&lt; sptr1-&gt;getBar() &lt;&lt; ", use_count() = "
                  &lt;&lt; sptr1.use_count() &lt;&lt; '\n';

        // Reset the shared_ptr sptr1, hand it a fresh instance of Foo.
        // The old instance will stay shared between sptr2 and sptr3.
        std::cout &lt;&lt; "call sptr1.reset()...\n";
        sptr1.reset(new Foo{333});

        std::cout &lt;&lt; "After reset():\n"
                  &lt;&lt; "sptr1.use_count() = " &lt;&lt; sptr1.use_count()
                  &lt;&lt; ", sptr1 @ " &lt;&lt; sptr1 &lt;&lt; '\n'
                  &lt;&lt; "sptr2.use_count() = " &lt;&lt; sptr2.use_count()
                  &lt;&lt; ", sptr2 @ " &lt;&lt; sptr2 &lt;&lt; '\n'
                  &lt;&lt; "sptr3.use_count() = " &lt;&lt; sptr3.use_count()
                  &lt;&lt; ", sptr3 @ " &lt;&lt; sptr3 &lt;&lt; '\n'
                  &lt;&lt; "Leaving the scope...\n";
    }   // Calls two destructors of: 1) Foo owned by sptr1,
        // 2) Foo shared between sptr2/sptr3.
}
|p=true
|output=
1) unique ownership
Foo::Foo(), bar = 100 @ 0x23c5040
Foo::bar = 100, use_count() = 1
call sptr.reset()...
Foo::~Foo(), bar = 100 @ 0x23c5040
After reset(): use_count() = 0, sptr = 0

2) unique ownership
Foo::Foo(), bar = 200 @ 0x23c5040
Foo::bar = 200, use_count() = 1
call sptr.reset()...
Foo::Foo(), bar = 222 @ 0x23c5050
Foo::~Foo(), bar = 200 @ 0x23c5040
After reset(): use_count() = 1, sptr = 0x23c5050
Leaving the scope...
Foo::~Foo(), bar = 222 @ 0x23c5050

3) multiple ownership
Foo::Foo(), bar = 300 @ 0x23c5080
Foo::bar = 300, use_count() = 3
call sptr1.reset()...
Foo::Foo(), bar = 333 @ 0x23c5050
After reset():
sptr1.use_count() = 1, sptr1 @ 0x23c5050
sptr2.use_count() = 2, sptr2 @ 0x23c5080
sptr3.use_count() = 2, sptr3 @ 0x23c5080
Leaving the scope...
Foo::~Foo(), bar = 300 @ 0x23c5080
Foo::~Foo(), bar = 333 @ 0x23c5050
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/shared_ptr/dsc constructor}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}