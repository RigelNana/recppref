{{cpp/title|destroy}}
{{cpp/memory/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcl rev multi|num=1
|since1=c++17|dcl1=
template&lt; class ForwardIt &gt;
void destroy( ForwardIt first, ForwardIt last );
|since2=c++20|dcl2=
template&lt; class ForwardIt &gt;
constexpr void destroy( ForwardIt first, ForwardIt last );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy, class ForwardIt &gt;
void destroy( ExecutionPolicy&amp;&amp; policy, ForwardIt first, ForwardIt last );
}}
{{dcl end}}
@1@ Destroys the  objects in the range {{range|first|last}}, as if by
{{source|1=
for (; first != last; ++first)
    std::destroy_at(std::addressof(*first));
}}

@2@ Same as {{v|1}}, but executed according to {{c|policy}}. {{cpp/algorithm/parallel overload precondition}}

===Parameters===
{{par begin}}
{{par|first, last|the range of elements to destroy}}
{{par exec pol}}
{{par hreq}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req|No increment, assignment, comparison, or indirection through valid instances of {{tt|ForwardIt}} may throw exceptions.}}
{{par end}}

===Return value===
(none)

===Complexity===
Linear in the distance between {{c|first}} and {{c|last}}.

===Exceptions===
{{cpp/algorithm/parallel_exceptions_reporting_behavior|singular=yes}}

===Possible implementation===
{{eq fun|1=
template&lt;class ForwardIt&gt;
constexpr // since C++20
void destroy(ForwardIt first, ForwardIt last)
{
    for (; first != last; ++first)
        std::destroy_at(std::addressof(*first));
}
}}

===Example===
{{cpp/memory/destroy example|destroy}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/dsc destroy_n}}
{{dsc inc|cpp/memory/dsc destroy_at}}
{{dsc inc|cpp/memory/ranges/dsc destroy}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}