{{cpp/title|allocator_traits}}
{{cpp/memory/allocator_traits/navbar}}

{{ddcl|header=memory|since=c++11|
template&lt; class Alloc &gt;
struct allocator_traits;
}}

The {{tt|allocator_traits}} class template provides the standardized way to access various properties of {{named req|Allocator}}s. The standard containers and other standard library components access allocators through this template, which makes it possible to use any class type as an allocator, as long as the user-provided specialization of {{tt|std::allocator_traits}} implements all required functionality.

{{rrev|since=c++23|
A program that declares an explicit or partial specialization of {{tt|std::allocator_traits}} is ill-formed, no diagnostic required.
}}

The default, non-specialized, {{tt|std::allocator_traits}} contains the following members:

===Member types===
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|allocator_type}}|{{tt|Alloc}}}}
{{dsc|{{tt|value_type}}|{{tt|Alloc::value_type}}}}
{{dsc|{{tt|pointer}}|{{tt|Alloc::pointer}} if present, otherwise {{tt|value_type*}}}}
{{dsc|{{tt|const_pointer}}|{{tt|Alloc::const_pointer}} if present, otherwise {{c/core|std::pointer_traits&lt;pointer&gt;::rebind&lt;const value_type&gt;}}}}
{{dsc|{{tt|void_pointer}}|{{tt|Alloc::void_pointer}} if present, otherwise {{c/core|std::pointer_traits&lt;pointer&gt;::rebind&lt;void&gt;}}}}
{{dsc|{{tt|const_void_pointer}}|{{tt|Alloc::const_void_pointer}} if present, otherwise {{c/core|std::pointer_traits&lt;pointer&gt;::rebind&lt;const void&gt;}}}}
{{dsc|{{tt|difference_type}}|{{tt|Alloc::difference_type}} if present, otherwise {{c/core|std::pointer_traits&lt;pointer&gt;::difference_type}}}}
{{dsc|{{tt|size_type}}|{{tt|Alloc::size_type}} if present, otherwise {{c/core|std::make_unsigned&lt;difference_type&gt;::type}}}}
{{dsc|{{tt|propagate_on_container_copy_assignment}}|{{tt|Alloc::propagate_on_container_copy_assignment}} if present, otherwise {{lc|std::false_type}}}}
{{dsc|{{tt|propagate_on_container_move_assignment}}|{{tt|Alloc::propagate_on_container_move_assignment}} if present, otherwise {{lc|std::false_type}}}}
{{dsc|{{tt|propagate_on_container_swap}}|{{tt|Alloc::propagate_on_container_swap}} if present, otherwise {{lc|std::false_type}}}}
{{dsc|{{tt|is_always_equal}}&lt;!-- LWG2108 --&gt;|{{tt|Alloc::is_always_equal}} if present, otherwise {{c/core|std::is_empty&lt;Alloc&gt;::type}}}}
{{dsc end}}

===Member alias templates===
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|rebind_alloc&lt;T&gt;}}|{{tt|Alloc::rebind&lt;T&gt;::other}} if present, otherwise {{tt|SomeAllocator&lt;T, Args&gt;}} if this {{tt|Alloc}} is of the form {{c/core|SomeAllocator&lt;U, Args&gt;}}, where {{c/core|Args}} is zero or more [[cpp/language/template parameters|type arguments]]}}
{{dsc|{{tt|rebind_traits&lt;T&gt;}}|{{c/core|std::allocator_traits&lt;rebind_alloc&lt;T&gt;&gt;}}}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/memory/allocator_traits/dsc allocate}}
{{dsc inc|cpp/memory/allocator_traits/dsc allocate_at_least}}
{{dsc inc|cpp/memory/allocator_traits/dsc deallocate}}
{{dsc inc|cpp/memory/allocator_traits/dsc construct}}
{{dsc inc|cpp/memory/allocator_traits/dsc destroy}}
{{dsc inc|cpp/memory/allocator_traits/dsc max_size}}
{{dsc inc|cpp/memory/allocator_traits/dsc select_on_container_copy_construction}}
{{dsc end}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|std=C++11|dr=2108|before=there was no way to show an allocator is stateless|after={{tt|is_always_equal}} provided}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc named req|cpp/named req/AllocatorAwareContainer|container using allocator; associated traits (e.g. [[#Member types|{{tt|propagate_on_container_swap}}]]) usage|notes={{mark c++11}}}}
{{dsc inc|cpp/memory/dsc allocator}}
{{dsc inc|cpp/memory/dsc scoped_allocator_adaptor}}
{{dsc inc|cpp/memory/dsc pointer_traits}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}