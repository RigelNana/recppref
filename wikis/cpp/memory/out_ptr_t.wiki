{{cpp/title|out_ptr_t}}
{{cpp/memory/out_ptr_t/navbar}}
{{ddcl|header=memory|since=c++23|
template&lt; class Smart, class Pointer, class... Args &gt;
class out_ptr_t;
}}

{{tt|out_ptr_t}} is used to adapt types such as smart pointers for foreign functions that output their results via a {{tt|Pointer*}} (usually {{tt|T**}} for some object type {{tt|T}}) or {{c/core|void**}} parameter.

{{tt|out_ptr_t}} captures additional arguments on construction, provides storage for the result to which such an aforementioned foreign function writes, and finally resets the adapted {{tt|Smart}} object with the result and the captured arguments when it is destroyed.

{{tt|out_ptr_t}} behaves as if it holds following non-static data members:
* a {{tt|Smart&amp;}} reference, which is bound to the adapted object on construction,
* for every {{tt|T}} in {{tt|Args...}}, a member of type {{tt|T}}, which is an argument captured on construction and used for resetting while destruction, and
* a member subobject that suitable for storing a {{tt|Pointer}} within it and providing a {{c/core|void*}} object, where the {{tt|Pointer}} or {{c/core|void*}} object is generally exposed to a foreign function for re-initialization.

Users can control whether each argument for resetting is captured by copy or by reference, by specifying an object type or a reference type in {{tt|Args...}} respectively.

===Template parameters===
{{par begin}}
{{par|Smart|the type of the object (typically a smart pointer) to adapt}}
{{par|Pointer|type of the object (typically a raw pointer) to which a foreign function writes its result}}
{{par|Args...|type of captured arguments used for resetting the adapted object}}
{{par hreq}}
{{par req named|Pointer|NullablePointer}}
{{par req|The program is ill-formed if {{tt|Smart}} is a {{lc|std::shared_ptr}} specialization and {{c|1=sizeof...(Args) == 0}}.}}
{{par end}}

===Specializations===
Unlike most class templates in the standard library, [[cpp/language/type#Program-defined type|program-defined specializations]] of {{tt|out_ptr_t}} that depend on at least one {{lsd|cpp/language/type#Program-defined type}} need not meet the requirements for the primary template.

This license allows a program-defined specialization to expose the raw pointer stored within a non-standard smart pointer to foreign functions.

===Member functions===
{{dsc begin}}
{{dsc mem ctor|cpp/memory/out_ptr_t/out_ptr_t|notes={{mark c++23}}|constructs an {{tt|out_ptr_t}}}}
{{dsc mem fun|operator{{=}}|nolink=true|notes={{cmark deleted}}{{mark c++23}}|{{tt|out_ptr_t}} is not assignable}}
{{dsc mem dtor|cpp/memory/out_ptr_t/~out_ptr_t|notes={{mark c++23}}|resets the adapted smart pointer}}
{{dsc mem fun|cpp/memory/out_ptr_t/operator ptr|title=operator Pointer*&lt;br&gt;operator void**|notes={{mark c++23}}|converts the {{tt|out_ptr_t}} to the address of the storage for output}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/memory/out_ptr_t/dsc out_ptr}}
{{dsc end}}

===Notes===
{{tt|out_ptr_t}} expects that the foreign functions do not used the value of the pointed-to {{tt|Pointer}}, and only re-initialize it. The value of the smart pointer before adaption is not used.

The typical usage of {{tt|out_ptr_t}} is creating its temporary objects by {{lc|std::out_ptr}}, which resets the adapted smart pointer immediately. E.g. given a setter function and a smart pointer of appropriate type declared with {{c|int foreign_setter(T**);}} and {{c|std::unique_ptr&lt;T, D&gt; up;}} respectively,
{{source|1=
int foreign_setter(T**);
std::unique_ptr&lt;T, D&gt; up;

if (int ec = foreign_setter(std::out_ptr(up)))
    return ec;
}}
is roughly equivalent to
{{source|1=
int foreign_setter(T**);
std::unique_ptr&lt;T, D&gt; up;
T* raw_p{};

int ec = foreign_setter(&amp;raw_p);
up.reset(raw_p);
if (ec != 0)
    return ec;
}}

It is not recommended to create an {{tt|out_ptr_t}} object of a {{lt|cpp/language/storage duration}} other than automatic storage duration, because such code is likely to produce dangling references and result in undefined behavior on destruction.

{{tt|out_ptr_t}} forbids the usage that would reset a {{lc|std::shared_ptr}} without specifying a deleter, because it would call {{lc|std::shared_ptr::reset}} and replace a custom deleter later.

Captured arguments are typically packed into a {{c/core|std::tuple&lt;Args...&gt;}}. Implementations may use different mechanism to provide the {{tt|Pointer}} or {{c/core|void*}} object they need hold.

{{ftm begin|sort=yes}}
{{ftm|std=C++23|value=202106L|__cpp_lib_out_ptr|rowspan="2"|{{tt|std::out_ptr}}, {{lc|std::inout_ptr}}}}
{{ftm|std=C++26|value=202311L|-|freestanding {{tt|std::out_ptr}} and {{lc|std::inout_ptr}}}}
{{ftm end}}

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/dsc inout_ptr_t}}
{{dsc inc|cpp/memory/dsc unique_ptr}}
{{dsc inc|cpp/memory/dsc shared_ptr}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}