{{cpp/memory/polymorphic_allocator/title|construct}}
{{cpp/memory/polymorphic_allocator/navbar}}
{{dcl begin}}
{{dcl|since=c++17|num=1|
template&lt; class U, class... Args &gt;
void construct( U* p, Args&amp;&amp;... args );
}}
{{dcl|since=c++17|until=c++20|num=2|
template&lt; class T1, class T2, class... Args1, class... Args2 &gt;
void construct( std::pair&lt;T1, T2&gt;* p,
                std::piecewise_construct_t,
                std::tuple&lt;Args1...&gt; x,
                std::tuple&lt;Args2...&gt; y );
}}
{{dcl|since=c++17|until=c++20|num=3|
template&lt; class T1, class T2 &gt;
void construct( std::pair&lt;T1, T2&gt;* p );
}}
{{dcl|since=c++17|until=c++20|num=4|
template&lt; class T1, class T2, class U, class V &gt;
void construct( std::pair&lt;T1, T2&gt;* p, U&amp;&amp; x, V&amp;&amp; y );
}}
{{dcl|since=c++17|until=c++20|num=5|
template&lt; class T1, class T2, class U, class V &gt;
void construct( std::pair&lt;T1, T2&gt;* p, const std::pair&lt;U, V&gt;&amp; xy );
}}
{{dcl|since=c++17|until=c++20|num=6|
template&lt; class T1, class T2, class U, class V &gt;
void construct( std::pair&lt;T1, T2&gt;* p, std::pair&lt;U, V&gt;&amp;&amp; xy );
}}
{{dcl|num=7|since=c++17|until=c++20|
template&lt; class T1, class T2, class NonPair &gt;
void construct( std::pair&lt;T1, T2&gt;* p, NonPair&amp;&amp; non_pair );
}}
{{dcl end}}

Constructs an object in allocated, but not initialized storage pointed to by {{c|p}} the provided constructor arguments. If the object is of type that itself uses allocators, or if it is std::pair, passes {{c|*this}} down to the constructed object.

@1@ Creates an object of the given type {{tt|U}} by means of [[cpp/memory/uses_allocator#Uses-allocator_construction|uses-allocator construction]] at the uninitialized memory location indicated by {{spar|p}}, using {{c|*this}} as the allocator. {{rev inl|until=c++20|{{cpp/enable if|{{tt|U}} is not a specialization of {{lc|std::pair}}}}.}}

{{rrev|until=c++20|
@2@ First, if either {{tt|T1}} or {{tt|T2}} is allocator-aware, modifies the tuples {{c|x}} and {{c|y}} to include {{tt|this-&gt;resource()}}, resulting in the two new tuples {{tt|xprime}} and {{tt|yprime}}, according to the following three rules:
:@2a@ if {{tt|T1}} is not allocator-aware ({{c|1=std::uses_allocator&lt;T1, polymorphic_allocator&gt;::value==false}}) and {{c|1=std::is_constructible&lt;T1, Args1...&gt;::value==true}}, then {{tt|xprime}} is {{c|x}}, unmodified.
:@2b@ if {{tt|T1}} is allocator-aware ({{c|1=std::uses_allocator&lt;T1, polymorphic_allocator&gt;::value==true}}), and its constructor takes an allocator tag ({{c|1=std::is_constructible&lt;T1, std::allocator_arg_t, polymorphic_allocator, Args1...&gt;::value==true}}, then {{tt|xprime}} is
{{c|std::tuple_cat(std::make_tuple(std::allocator_arg, *this), std::move(x))}}.
:@2c@ if {{tt|T1}} is allocator-aware ({{c|1=std::uses_allocator&lt;T1, polymorphic_allocator&gt;::value==true}}), and its constructor takes the allocator as the last argument ({{c|1=std::is_constructible&lt;T1, Args1..., polymorphic_allocator&gt;::value==true}}), then {{tt|xprime}} is  {{c|std::tuple_cat(std::move(x), std::make_tuple(*this))}}.
:@2d@ Otherwise, the program is ill-formed.
@@Same rules apply to {{tt|T2}} and the replacement of {{c|y}} with {{tt|yprime}}.
@@Once {{tt|xprime}} and {{tt|yprime}} are constructed, constructs the pair {{c|p}} in allocated storage as if by {{c|::new((void *) p) pair&lt;T1, T2&gt;(std::piecewise_construct, std::move(xprime), std::move(yprime));}}.
@3@ Equivalent to {{c|construct(p, std::piecewise_construct, std::tuple&lt;&gt;(), std::tuple&lt;&gt;())}}, that is, passes the memory resource on to the pair's member types if they accept them.
@4@ Equivalent to
{{source|1=
construct(p, std::piecewise_construct, std::forward_as_tuple(std::forward&lt;U&gt;(x)),
                                       std::forward_as_tuple(std::forward&lt;V&gt;(y)))
}}
@5@ Equivalent to
{{source|1=
construct(p, std::piecewise_construct, std::forward_as_tuple(xy.first),
                                       std::forward_as_tuple(xy.second))
}}
@6@ Equivalent to
{{source|1=
construct(p, std::piecewise_construct, std::forward_as_tuple(std::forward&lt;U&gt;(xy.first)),
                                       std::forward_as_tuple(std::forward&lt;V&gt;(xy.second)))
}}
@7@ {{cpp/enable_if|given the exposition-only function template
{{source|template&lt; class A, class B &gt;
void /*deduce-as-pair*/( const std::pair&lt;A, B&gt;&amp; );
}}
, {{c|/*deduce-as-pair*/(non_pair)}} is ill-formed when considered as an unevaluated operand}}. Equivalent to
{{source|1=
construct&lt;T1, T2, T1, T2&gt;(p, std::forward&lt;NonPair&gt;(non_pair));
}}
}}

===Parameters===
{{par begin}}
{{par|p|pointer to allocated, but not initialized storage}}
{{par|args...|the constructor arguments to pass to the constructor of {{tt|T}}}}
{{par|x|the constructor arguments to pass to the constructor of {{tt|T1}}}}
{{par|y|the constructor arguments to pass to the constructor of {{tt|T2}}}}
{{par|xy|the pair whose two members are the constructor arguments for {{tt|T1}} and {{tt|T2}}}}
{{par|non_pair|non-{{tt|pair}} argument to convert to {{tt|pair}} for further construction}}
{{par end}}

===Return value===
(none)

===Notes===
This function is called (through {{lc|std::allocator_traits}}) by any allocator-aware object, such as {{lc|std::pmr::vector}} (or another {{lc|std::vector}} that was given a {{tt|std::pmr::polymorphic_allocator}} as the allocator to use).

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2969|std=C++17|before=uses-allocator construction passed {{tt|resource()}}|after=passes {{c|*this}}}}
{{dr list item|wg=lwg|dr=2975|std=C++17|before=first overload is mistakenly used for pair construction in some cases|after=constrained to not accept pairs}}
{{dr list item|wg=lwg|dr=3525|std=C++17|before=no overload could handle non-{{tt|pair}} types convertible to {{tt|pair}}|after=reconstructing overload added}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/allocator_traits/dsc construct}}
{{dsc inc|cpp/memory/allocator/dsc construct}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}