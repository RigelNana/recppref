{{cpp/title|assume_aligned}}
{{cpp/memory/navbar}}
{{ddcl|header=memory|since=c++20|1=
template&lt; std::size_t N, class T &gt;
constexpr T* assume_aligned( T* ptr );
}}

Informs the implementation that the object {{c|ptr}} points to is aligned to at least {{tt|N}}. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of {{tt|assume_aligned}}.

{{tt|N}} must be a power of 2. The behavior is undefined if {{c|ptr}} does not point to an object of type {{tt|T}} (ignoring cv-qualification at every level), or if the object's alignment is not at least {{tt|N}}.

===Return value===
{{c|ptr}}.

===Exceptions===
Throws nothing.

===Notes===
To ensure that the program benefits from the optimizations enabled by {{tt|assume_aligned}}, it is important to access the object via its return value:

{{source|1=
void f(int* p)
{
    int* p1 = std::assume_aligned&lt;256&gt;(p);
    // Use p1, not p, to ensure benefit from the alignment assumption.
    // However, the program has undefined behavior if p is not aligned
    // regardless of whether p1 is used.
}
}}

It is up to the program to ensure that the alignment assumption actually holds. A call to {{tt|assume_aligned}} does not cause the compiler to verify or enforce this.

{{feature test macro|__cpp_lib_assume_aligned|{{tt|std::assume_aligned}}|value=201811L|std=C++20}}

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc alignof}}
{{dsc inc|cpp/language/dsc alignas}}
{{dsc inc|cpp/types/dsc aligned_storage}}
{{dsc inc|cpp/memory/dsc align}}
{{dsc inc|cpp/language/attributes/dsc assume}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}