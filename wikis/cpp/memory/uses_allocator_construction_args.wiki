{{cpp/title|uses_allocator_construction_args}}
{{cpp/memory/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcl h|{{tt|T}} is not a specialization of {{lc|std::pair}}}}
{{dcl|num=1|since=c++20|
template&lt; class T, class Alloc, class... Args &gt;
constexpr auto uses_allocator_construction_args( const Alloc&amp; alloc,
    Args&amp;&amp;... args ) noexcept;
}}
{{dcl h|{{tt|T}} is a specialization of {{lc|std::pair}}}}
{{dcl|num=2|since=c++20|
template&lt; class T, class Alloc, class Tuple1, class Tuple2 &gt;
constexpr auto uses_allocator_construction_args( const Alloc&amp; alloc,
    std::piecewise_construct_t, Tuple1&amp;&amp; x, Tuple2&amp;&amp; y ) noexcept;
}}
{{dcl|num=3|since=c++20|
template&lt; class T, class Alloc &gt;
constexpr auto uses_allocator_construction_args( const Alloc&amp; alloc ) noexcept;
}}
{{dcl|num=4|since=c++20|
template&lt; class T, class Alloc, class U, class V &gt;
constexpr auto uses_allocator_construction_args( const Alloc&amp; alloc,
    U&amp;&amp; u, V&amp;&amp; v ) noexcept;
}}
{{dcl|num=5|since=c++23|
template&lt; class T, class Alloc, class U, class V &gt;
constexpr auto uses_allocator_construction_args( const Alloc&amp; alloc,
    std::pair&lt;U, V&gt;&amp; pr ) noexcept;
}}
{{dcl|num=6|since=c++20|
template&lt; class T, class Alloc, class U, class V &gt;
constexpr auto uses_allocator_construction_args( const Alloc&amp; alloc,
    const std::pair&lt;U, V&gt;&amp; pr ) noexcept;
}}
{{dcl|num=7|since=c++20|
template&lt; class T, class Alloc, class U, class V &gt;
constexpr auto uses_allocator_construction_args( const Alloc&amp; alloc,
    std::pair&lt;U, V&gt;&amp;&amp; pr ) noexcept;
}}
{{dcl|num=8|since=c++23|
template&lt; class T, class Alloc, class U, class V &gt;
constexpr auto uses_allocator_construction_args( const Alloc&amp; alloc,
    const std::pair&lt;U, V&gt;&amp;&amp; pr ) noexcept;
}}
{{dcl|num=9|since=c++20|
template&lt; class T, class Alloc, class NonPair &gt;
constexpr auto uses_allocator_construction_args( const Alloc&amp; alloc,
    NonPair&amp;&amp; non_pair ) noexcept;
}}
{{dcl end}}

Prepares the argument list needed to create an object of the given type {{tt|T}} by means of {{rlp|uses_allocator|uses-allocator construction}}.

@1@ {{cpp/enable if|{{tt|T}} is not a specialization of {{lc|std::pair}}}}. Returns {{lc|std::tuple}} determined as follows:
&lt;!----&gt;
* If {{c|std::uses_allocator_v&lt;T, Alloc&gt;}} is {{c|false}} and {{c|std::is_constructible_v&lt;T, Args...&gt;}} is {{c|true}}, returns {{c|std::forward_as_tuple(std::forward&lt;Args&gt;(args)...)}}.
* Otherwise, if {{c|std::uses_allocator_v&lt;T, Alloc&gt;}} is {{c|true}} and {{c|std::is_constructible_v&lt;T, std::allocator_arg_t, const Alloc&amp;, Args...&gt;}} is {{c|true}}, returns&lt;br&gt;{{c multi
|std::tuple&lt;std::allocator_arg_t, const Alloc&amp;, Args&amp;&amp;...&gt;(std::allocator_arg, alloc,
|                                                          std::forward&lt;Args&gt;(args)...)}}.
* Otherwise, if {{c|std::uses_allocator_v&lt;T, Alloc&gt;}} is {{c|true}} and {{c|std::is_constructible_v&lt;T, Args..., const Alloc&amp;&gt;}} is {{c|true}}, returns {{c|std::forward_as_tuple(std::forward&lt;Args&gt;(args)..., alloc)}}.
* Otherwise, the program is ill-formed.
@2@ {{cpp/enable if|{{tt|T}} is a specialization of {{lc|std::pair}}}}. For {{tt|T}} that is {{c|std::pair&lt;T1, T2&gt;}}, equivalent to 
{{source|1=
return std::make_tuple(std::piecewise_construct,
    std::apply([&amp;alloc](auto&amp;&amp;... args1)
        {
            return std::uses_allocator_construction_args&lt;T1&gt;(alloc,
                       std::forward&lt;decltype(args1)&gt;(args1)...);
        }, std::forward&lt;Tuple1&gt;(x)
    ),
    std::apply([&amp;alloc](auto&amp;&amp;... args2)
        {
            return std::uses_allocator_construction_args&lt;T2&gt;(alloc,
                       std::forward&lt;decltype(args2)&gt;(args2)...);
        }, std::forward&lt;Tuple2&gt;(y)
    )
);
}}
@3@ {{cpp/enable if|{{tt|T}} is a specialization of {{lc|std::pair}}}}. Equivalent to
{{source|1=
return std::uses_allocator_construction_args&lt;T&gt;(alloc,
    std::piecewise_construct, std::tuple&lt;&gt;{}, std::tuple&lt;&gt;{}
);
}}
@4@ {{cpp/enable if|{{tt|T}} is a specialization of {{lc|std::pair}}}}. Equivalent to
{{source|1=
return std::uses_allocator_construction_args&lt;T&gt;(alloc,
    std::piecewise_construct,
    std::forward_as_tuple(std::forward&lt;U&gt;(u)),
    std::forward_as_tuple(std::forward&lt;V&gt;(v))
);
}}
@5,6@ {{cpp/enable if|{{tt|T}} is a specialization of {{lc|std::pair}}}}. Equivalent to
{{source|1=
return std::uses_allocator_construction_args&lt;T&gt;(alloc,
    std::piecewise_construct,
    std::forward_as_tuple(pr.first),
    std::forward_as_tuple(pr.second)
);
}}
@7,8@ {{cpp/enable if|{{tt|T}} is a specialization of {{lc|std::pair}}}}. Equivalent to
{{source|1=
return std::uses_allocator_construction_args&lt;T&gt;(alloc,
    std::piecewise_construct,
    std::forward_as_tuple(std::get&lt;0&gt;(std::move(pr))),
    std::forward_as_tuple(std::get&lt;1&gt;(std::move(pr)))
);
}}
@9@ {{cpp/enable_if|{{tt|T}} is a specialization of {{lc|std::pair}}, and given the exposition-only function template
{{source|template&lt;class A, class B&gt;
void /*deduce-as-pair*/(const std::pair&lt;A, B&gt;&amp;);
}}
, {{c|/*deduce-as-pair*/(non_pair)}} is ill-formed when considered as an unevaluated operand}}.&lt;br&gt;&lt;!--
--&gt;Let the exposition-only class {{tt|''pair-constructor''}} be defined as
{{source|1=
class /*pair-constructor*/
{
    const Alloc&amp; alloc_; // exposition only
    NonPair&amp;     u_;     // exposition only

    constexpr reconstruct(const std::remove_cv&lt;T&gt;&amp; p) const // exposition only
    {
        return std::make_obj_using_allocator&lt;std::remove_cv&lt;T&gt;&gt;(alloc_, p);
    }

    constexpr reconstruct(std::remove_cv&lt;T&gt;&amp;&amp; p) const // exposition only
    {
        return std::make_obj_using_allocator&lt;std::remove_cv&lt;T&gt;&gt;(alloc_, std::move(p));
    }

public:
    constexpr operator std::remove_cv&lt;T&gt;() const
    {
        return reconstruct(std::forward&lt;NonPair&gt;(u_));
    }
};
}}
This overload is equivalent to {{c|return std::make_tuple(pair_construction);}}, where {{tt|pair_construction}} is a value of type {{tt|''pair-constructor''}} whose {{tt|''alloc_''}} and {{tt|''u_''}} members are {{tt|alloc}} and {{tt|non_pair}} respectively.

===Parameters===
{{par begin}}
{{par|alloc|the allocator to use}}
{{par|args|the arguments to pass to {{tt|T}}'s constructor}}
{{par|x|tuple of arguments to pass to the constructors of {{tt|T}}'s {{tt|first}} data member}}
{{par|y|tuple of arguments to pass to the constructors of {{tt|T}}'s {{tt|second}} data member}}
{{par|u|single argument to pass to the constructor of {{tt|T}}'s {{tt|first}} data member}}
{{par|v|single argument to pass to the constructor of {{tt|T}}'s {{tt|second}} data member}}
{{par|pr|a pair whose {{tt|first}} data member will be passed to the constructor of {{tt|T}}'s {{tt|first}} data member and {{tt|second}} data member will be passed to the constructor of {{tt|T}}'s {{tt|second}} data member}}
{{par|non_pair|single argument to convert to a {{lc|std::pair}} for further construction}}
{{par end}}

===Return value===
{{lc|std::tuple}} of arguments suitable for passing to the constructor of {{tt|T}}.

===Notes===
The overloads {{v|2-9}} provide allocator propagation into {{lc|std::pair}}, which supports neither leading-allocator nor trailing-allocator calling conventions (unlike, e.g. {{lc|std::tuple}}, which uses leading-allocator convention).

When used in uses-allocator construction, the conversion function of {{tt|''pair-constructor''}} converts the provided argument to {{lc|std::pair}} at first, and then constructs the result from that {{lc|std::pair}} by uses-allocator construction.

===Example===
{{example}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3525|std=C++20|before=no overload could handle non-{{tt|pair}} types convertible to {{tt|pair}}|after=reconstructing overload added}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/dsc uses_allocator}}
{{dsc inc|cpp/memory/dsc make_obj_using_allocator}}
{{dsc inc|cpp/memory/dsc uninitialized_construct_using_allocator}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}