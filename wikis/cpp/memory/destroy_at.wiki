{{cpp/title|destroy_at}}
{{cpp/memory/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcl rev multi
|since1=c++17|dcl1=  
template&lt; class T &gt;
void destroy_at( T* p );
|since2=c++20|dcl2=  
template&lt; class T &gt;
constexpr void destroy_at( T* p );
}}
{{dcl end}}

If {{tt|T}} is not an array type, calls the destructor of the object pointed to by {{c|p}}, as if by {{c|p-&gt;~T()}}. 

If {{tt|T}} is an array type, {{rev inl|until=c++20|the program is ill-formed}}{{rev inl|since=c++20|recursively destroys elements of {{c|*p}} in order, as if by calling {{c|std::destroy(std::begin(*p), std::end(*p))}}}}.

===Parameters===
{{par begin}}
{{par|p|a pointer to the object to be destroyed}}
{{par end}}

===Return value===
(none)

===Possible implementation===
{{eq fun|1=
template&lt;class T&gt;
constexpr void destroy_at(T* p) 
{
    if constexpr (std::is_array_v&lt;T&gt;)
        for (auto &amp;elem : *p)
            (destroy_at)(std::addressof(elem));
    else
        p-&gt;~T(); 
}
// C++17 version:
// template&lt;class T&gt; void destroy_at(T* p) { p-&gt;~T(); }
}}

===Notes===
{{tt|destroy_at}} deduces the type of object to be destroyed and hence avoids writing it explicitly in the destructor call.

{{rrev|since=c++20|
When {{tt|destroy_at}} is called in the evaluation of some [[cpp/language/constant expression|constant expression]] {{c|e}}, the argument {{c|p}} must point to an object whose lifetime began within the evaluation of {{c|e}}.
}}

===Example===
{{cpp/memory/destroy example|destroy_at}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/dsc destroy}}
{{dsc inc|cpp/memory/dsc destroy_n}}
{{dsc inc|cpp/memory/dsc construct_at}}
{{dsc inc|cpp/memory/ranges/dsc destroy_at}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}