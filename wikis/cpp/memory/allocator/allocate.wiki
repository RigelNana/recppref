{{cpp/memory/allocator/title|allocate}}
{{cpp/memory/allocator/navbar}}
{{dcl begin}}
{{dcl rev begin|num=1}}
{{dcl|until=c++17|1=
pointer allocate( size_type n, const void* hint = 0 );
}}
{{dcl|since=c++17|deprecated=yes|removed=c++20|1=
T* allocate( std::size_t n, const void* hint );
}}
{{dcl rev end}}
{{dcl rev multi|num=2|since1=c++17|dcl1=
T* allocate( std::size_t n );
|since2=c++20|dcl2=
constexpr T* allocate( std::size_t n );
}}
{{dcl end}}

Allocates {{c|n * sizeof(T)}} bytes of uninitialized storage by calling {{c|::operator new(std::size_t)}} {{rev inl|since=c++17|or {{c|::operator new(std::size_t, std::align_val_t)}}}}, but it is unspecified when and how this function is called. The pointer {{c|hint}} may be used to provide locality of reference: the allocator, if supported by the implementation, will attempt to allocate the new memory block as close as possible to {{c|hint}}.

Then, this function creates an array of type {{tt|T[n]}} in the storage and starts its lifetime, but does not start lifetime of any of its elements.

Use of this function is ill-formed if {{tt|T}} is an [[cpp/language/type#Incomplete type|incomplete type]]. &lt;!--LWG3307--&gt;

{{rrev|since=c++20|
In order to use this function in a constant expression, the allocated storage must be deallocated within the evaluation of the same expression.
}}

===Parameters===
{{par begin}}
{{par|n|the number of objects to allocate storage for}}
{{par|hint|pointer to a nearby memory location}}
{{par end}}

===Return value===
Pointer to the first element of an array of {{c|n}} objects of type {{tt|T}} whose elements have not been constructed yet.

===Exceptions===
{{rrev|since=c++11|
Throws {{lc|std::bad_array_new_length}} if {{c|std::numeric_limits&lt;std::size_t&gt;::max() / sizeof(T) &lt; n}}.
}}
Throws {{lc|std::bad_alloc}} if allocation fails.

===Notes===
The "unspecified when and how" wording makes it possible to [[cpp/language/new#Allocation|combine or optimize away heap allocations]] made by the standard library containers, even though such optimizations are disallowed for direct calls to {{tt|::operator new}}. For example, this is implemented by libc++ ([https://github.com/llvm-mirror/libcxx/blob/master@%7B2017-02-09%7D/include/memory#L1766-L1772] and [https://github.com/llvm-mirror/libcxx/blob/master@%7B2017-02-09%7D/include/new#L211-L217]).

After calling {{tt|allocate()}} and before construction of elements, pointer arithmetic of {{tt|T*}} is well-defined within the allocated array, but the behavior is undefined if elements are accessed.

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=578|std=C++98|before={{c|hint}} was required to be either {{c|0}} or a&lt;br&gt;pointer previously returned from {{tt|allocate()}}&lt;br&gt;and not yet passed to {{lc|deallocate()}}|after=not required}}
{{dr list item|wg=lwg|dr=3190|std=C++11|before={{tt|allocate()}} might allocate storage of wrong size|after=throws {{lc|std::bad_array_new_length}} instead}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/allocator_traits/dsc allocate}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}