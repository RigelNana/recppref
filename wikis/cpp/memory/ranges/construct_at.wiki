{{cpp/ranges/title|construct_at}}
{{cpp/memory/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcl h|Call signature}}
{{dcl|since=c++20|
template&lt; class T, class... Args &gt;
constexpr T* construct_at( T* location, Args&amp;&amp;... args );
}}
{{dcl end}}

Creates a {{tt|T}} object initialized with the arguments in {{c|args}} at given address {{c|location}}.

Equivalent to {{box|
{{c/core|if constexpr (std::is_array_v&lt;T&gt;)}}&lt;br&gt;
{{nbspt|4}}{{c/core|return ::new (}}{{lti|cpp/memory/voidify}}{{sep}}{{c/core|(*location)) T[1]();}}&lt;br&gt;
{{c/core|else}}&lt;br&gt;
{{nbspt|4}}{{c/core|return ::new (}}{{lti|cpp/memory/voidify}}{{sep}}{{c/core|(*location)) T(std::forward&lt;Args&gt;(args)...);}}
}}{{rev inl|until=c++26|, except that {{tt|construct_at}} may be used in evaluation of {{lt|cpp/language/constant expression}}s}}.

When {{tt|construct_at}} is called in the evaluation of some constant expression {{c|expr}}, {{c|location}} must point to either a storage obtained by {{c/core|std::allocator&lt;T&gt;::allocate}} or an object whose lifetime began within the evaluation of {{c|expr}}.

{{cpp/enable if|all following conditions are satisfied}}:
* {{c|std::is_unbounded_array_v&lt;T&gt;}} is {{c|false}}.
* {{c|::new(std::declval&lt;void*&gt;()) T(std::declval&lt;Args&gt;()...)}} is well-formed when treated as an [[cpp/language/expressions#Potentially-evaluated expressions|unevaluated operand]].

If {{c|std::is_array_v&lt;T&gt;}} is {{c|true}} and {{c|sizeof...(Args)}} is nonzero, the program is ill-formed.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|location|pointer to the uninitialized storage on which a {{tt|T}} object will be constructed}}
{{par|args...|arguments used for initialization}}
{{par end}}

===Return value===
{{c|location}}

===Notes===
{{tt|std::ranges::construct_at}} behaves exactly same as {{lc|std::construct_at}}, except that it is invisible to argument-dependent lookup.

===Example===
{{example|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;

struct S
{
    int x;
    float y;
    double z;
    
    S(int x, float y, double z) : x{x}, y{y}, z{z} { std::cout &lt;&lt; "S::S();\n"; }
    
    ~S() { std::cout &lt;&lt; "S::~S();\n"; }
    
    void print() const
    {
        std::cout &lt;&lt; "S { x=" &lt;&lt; x &lt;&lt; "; y=" &lt;&lt; y &lt;&lt; "; z=" &lt;&lt; z &lt;&lt; "; };\n";
    }
};

int main()
{
    alignas(S) unsigned char buf[sizeof(S)];
    
    S* ptr = std::ranges::construct_at(reinterpret_cast&lt;S*&gt;(buf), 42, 2.71828f, 3.1415);
    ptr-&gt;print();
    
    std::ranges::destroy_at(ptr);
}
|output=
S::S();
S { x=42; y=2.71828; z=3.1415; };
S::~S();
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3436|std=C++20|before={{tt|construct_at}} could not create objects of array types|after=can value-initialize bounded arrays}}
{{dr list item|wg=lwg|dr=3870|std=C++20|before={{tt|construct_at}} could create objects of cv-qualified types|after=only cv-unqualified types are permitted}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/ranges/dsc destroy_at}}
{{dsc inc|cpp/memory/dsc construct_at}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}