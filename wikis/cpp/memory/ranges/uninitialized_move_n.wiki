{{cpp/ranges/title|uninitialized_move_n|uninitialized_move_n_result}}
{{cpp/memory/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcl h|Call signature}}
{{dcla|num=1|since=c++20|constexpr=c++26|
template&lt; std::input_iterator I,
          no-throw-forward-iterator O, no-throw-sentinel-for&lt;O&gt; S &gt;
    requires std::constructible_from&lt;std::iter_value_t&lt;O&gt;,
                                     std::iter_rvalue_reference_t&lt;I&gt;&gt;
uninitialized_move_n_result&lt;I, O&gt;
    uninitialized_move_n( I ifirst, std::iter_difference_t&lt;I&gt; count,
                          O ofirst, S olast );
}}
{{dcl h|Helper types}}
{{dcl|num=2|since=c++20|1=
template&lt; class I, class O &gt;
using uninitialized_move_n_result = ranges::in_out_result&lt;I, O&gt;;
}}
{{dcl end}}

Let {{mathjax-or|\(\scriptsize N\)|N}} be {{c|ranges::min(count, ranges::distance(ofirst, olast))}}.

Copies {{mathjax-or|\(\scriptsize N\)|N}} elements from the range beginning at {{c|ifirst}} (using move semantics if supported) to an uninitialized memory area {{range|ofirst|olast}} as if by
{{c multi|
auto ret {{=}} ranges::uninitialized_move(std::counted_iterator(std::move(ifirst), count),|
                                      std::default_sentinel, ofirst, olast);|
return {std::move(ret.in).base(), ret.out};
}}

If an exception is thrown during the initialization then the objects that already constructed in {{range|ofirst|olast}} are destroyed in an unspecified order. Also, the objects in the input range beginning at {{c|ifirst}}, that were already moved, are left in a valid but unspecified state.

If {{range|ofirst|olast}} overlaps with {{counted range|ifirst|count}}, the behavior is undefined.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|ifirst|the beginning of the input range of elements to move from}}
{{par|ofirst, olast|iterator-sentinel pair denoting the output range of elements to initialize}}
{{par|n|the number of elements to move}}
{{par end}}

===Return value===
As described above.

===Complexity===
{{mathjax-or|\(\scriptsize\mathcal{O}(N)\)|ùìû(N)}}.

===Exceptions===
Any exception thrown on construction of the elements in the destination range.

===Notes===
An implementation may improve the efficiency of the {{tt|ranges::uninitialized_move_n}}, e.g. by using {{lc|ranges::copy_n}}, if the value type of the output range is {{named req|TrivialType}}.

{{feature test macro|__cpp_lib_raw_memory_algorithms|std=C++26|value=202411L|{{c/core|constexpr}} for [[cpp/memory#Uninitialized memory algorithms|specialized memory algorithms]], {{vl|1}}}}

===Possible implementation===
{{eq fun|1=
struct uninitialized_move_n_fn
{
    template&lt;std::input_iterator I,
             no-throw-forward-iterator O, no-throw-sentinel-for&lt;O&gt; S&gt;
        requires std::constructible_from&lt;std::iter_value_t&lt;O&gt;,
                                         std::iter_rvalue_reference_t&lt;I&gt;&gt;
    constexpr ranges::uninitialized_move_n_result&lt;I, O&gt;
        operator()(I ifirst, std::iter_difference_t&lt;I&gt; count, O ofirst, S olast) const
    {
        auto iter = std::counted_iterator(std::move(ifirst), count);
        auto ret = ranges::uninitialized_move(iter, std::default_sentinel, ofirst, olast);
        return {std::move(ret.in).base(), ret.out};
    }
};

inline constexpr uninitialized_move_n_fn uninitialized_move_n{};
}}

===Example===
{{example
|code=
#include &lt;cstdlib&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

void print(auto rem, auto first, auto last)
{
    for (std::cout &lt;&lt; rem; first != last; ++first)
        std::cout &lt;&lt; std::quoted(*first) &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    std::string in[]{ "No", "Diagnostic", "Required", };
    print("initially, in: ", std::begin(in), std::end(in));

    if (
        constexpr auto sz = std::size(in);
        void* out = std::aligned_alloc(alignof(std::string), sizeof(std::string) * sz)
    )
    {
        try
        {
            auto first{static_cast&lt;std::string*&gt;(out)};
            auto last{first + sz};
            std::ranges::uninitialized_move_n(std::begin(in), sz, first, last);

            print("after move, in: ", std::begin(in), std::end(in));
            print("after move, out: ", first, last);

            std::ranges::destroy(first, last);
        }
        catch (...)
        {
            std::cout &lt;&lt; "Exception!\n";
        }
        std::free(out);
    }
}
|p=true &lt;!-- the result of move is unspecified --&gt;
|output=
initially, in: "No" "Diagnostic" "Required"
after move, in: "" "" ""
after move, out: "No" "Diagnostic" "Required"
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3870|std=C++20|before=this algorithm might create objects on a {{c/core|const}} storage|after=kept disallowed}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/ranges/dsc uninitialized_move}}
{{dsc inc|cpp/memory/dsc uninitialized_move_n}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}