{{cpp/ranges/title|destroy_at}}
{{cpp/memory/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcl h|Call signature}}
{{dcl|since=c++20|
template&lt; std::destructible T &gt;
constexpr void destroy_at( T* p ) noexcept;
}}
{{dcl end}}

If {{tt|T}} is not an array type, calls the destructor of the object pointed to by {{c|p}}, as if by {{tt|p-&gt;~T()}}. Otherwise, recursively destroys elements of {{c|*p}} in order, as if by calling {{c|std::destroy(std::begin(*p), std::end(*p))}}.

{{cpp/ranges/niebloid}}

===Parameters===
{{par begin}}
{{par|p|a pointer to the object to be destroyed}}
{{par end}}

===Return value===
(none)

===Possible implementation===
{{eq fun|1=
struct destroy_at_fn
{
    template&lt;std::destructible T&gt;
    constexpr void operator()(T *p) const noexcept
    {
        if constexpr (std::is_array_v&lt;T&gt;)
            for (auto &amp;elem : *p)
                operator()(std::addressof(elem));
        else
            p-&gt;~T();
    }
};

inline constexpr destroy_at_fn destroy_at{};
}}

===Notes===
{{tt|destroy_at}} deduces the type of object to be destroyed and hence avoids writing it explicitly in the destructor call.

When {{tt|destroy_at}} is called in the evaluation of some [[cpp/language/constant expression|constant expression]] {{c|e}}, the argument {{c|p}} must point to an object whose lifetime began within the evaluation of {{c|e}}.

===Example===
{{cpp/memory/destroy example|ranges::destroy_at}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/ranges/dsc destroy}}
{{dsc inc|cpp/memory/ranges/dsc destroy_n}}
{{dsc inc|cpp/memory/ranges/dsc construct_at}}
{{dsc inc|cpp/memory/dsc destroy_at}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}