{{cpp/memory/pmr/title|polymorphic_allocator}}
{{cpp/memory/polymorphic_allocator/navbar}}
{{dcl begin}}
{{dcl header|memory_resource}}
{{dcl rev multi
|since1=c++17|dcl1=
template&lt; class T &gt;
class polymorphic_allocator;
|since2=c++20|dcl2=
template&lt; class T = std::byte &gt;
class polymorphic_allocator;
}}
{{dcl end}}

The class template {{tt|std::pmr::polymorphic_allocator}} is an {{named req|Allocator}} which exhibits different allocation behavior depending upon the {{lc|std::pmr::memory_resource}} from which it is constructed. Since {{tt|memory_resource}} uses runtime polymorphism to manage allocations, different container instances with {{tt|polymorphic_allocator}} as their static allocator type are interoperable, but can behave as if they had different allocator types.

All specializations of {{tt|polymorphic_allocator}} meet the {{lsd|cpp/named req/Allocator#Allocator completeness requirements}}.&lt;!-- LWG 3037 --&gt;

The {{tt|polymorphic_allocator::construct}} member function does {{lsd|cpp/memory/uses allocator#Uses-allocator construction}}, so that the elements of a container using a {{tt|polymorphic_allocator}} will use that same allocator for their own allocations. For example, a {{c|std::pmr::vector&lt;std::pmr::string&gt;}} will use the same {{tt|memory_resource}} for the {{tt|vector}}'s storage and each {{tt|string}}'s storage.

For non-polymorphic allocators, similar propagation can be achieved with the help of {{lc|std::scoped_allocator_adaptor}}.

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|definition}}
{{dsc|{{tt|value_type}}|{{tt|T}}}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc constructor}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc destructor}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc operator{{=}}}}

{{dsc h2|Public member functions}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc allocate}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc deallocate}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc construct}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc destroy}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc allocate_bytes}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc deallocate_bytes}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc allocate_object}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc deallocate_object}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc new_object}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc delete_object}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc select_on_container_copy_construction}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc resource}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/memory/polymorphic_allocator/dsc operator eq}}
{{dsc end}}

===Notes===
{{tt|polymorphic_allocator}} does not propagate on container copy assignment, move assignment, or swap. As a result, move assignment of a {{tt|polymorphic_allocator}}-using container can throw, and swapping two {{tt|polymorphic_allocator}}-using containers whose allocators do not compare equal results in undefined behavior.

{{feature test macro|__cpp_lib_polymorphic_allocator|{{tt|std::pmr::polymorphic_allocator&lt;&gt;}} as a vocabulary type|value=201902L|std=C++20}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/dsc memory_resource}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}