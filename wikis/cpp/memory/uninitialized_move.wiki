{{cpp/title|uninitialized_move}}
{{cpp/memory/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcla|num=1|since=c++17|constexpr=c++26|
template&lt; class InputIt, class NoThrowForwardIt &gt;
NoThrowForwardIt uninitialized_move( InputIt first, InputIt last,
                                     NoThrowForwardIt d_first );
}}
{{dcl|num=2|since=c++17|
template&lt; class ExecutionPolicy,
          class ForwardIt, class NoThrowForwardIt &gt;
NoThrowForwardIt uninitialized_move( ExecutionPolicy&amp;&amp; policy,
                                     ForwardIt first, ForwardIt last,
                                     NoThrowForwardIt d_first );}}
{{dcl end}}

@1@ Copies the elements from {{range|first|last}} (using move semantics if supported) to an uninitialized memory area beginning at {{c|d_first}} as if by
{{box|
{{c/core|1=for (; first != last; ++d_first, (void) ++first)}}&lt;br&gt;
{{nbspt|4}}{{c/core|::new (}}{{rlpi|voidify}}{{c/core|(*d_first))}}&lt;br&gt;
{{nbspt|8}}{{c/core|typename std::iterator_traits&lt;NoThrowForwardIt&gt;::value_type(/* value */);}}&lt;br&gt;
{{c/core|return d_first;}}
}}
@@ where {{c|/* value */}} is {{c|std::move(*first)}} if {{c|*first}} is of an lvalue reference type, or {{c|*first}} otherwise.
@@ If an exception is thrown during the initialization, some objects in {{range|first|last}} are left in a valid but unspecified state, and the objects already constructed are destroyed in an unspecified order.

@2@ Same as {{v|1}}, but executed according to {{c|policy}}.
@@ {{cpp/algorithm/parallel overload precondition}}


{{rrev|since=c++20|
If {{counted range|d_first|std::distance(first, last)}} overlaps with {{range|first|last}}, the behavior is undefined.
}}

===Parameters===
{{par begin}}
{{par|first, last|the range of the elements to move}}
{{par|d_first|the beginning of the destination range}}
{{par exec pol}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par req named|ForwardIt|ForwardIterator}}
{{par req named|NoThrowForwardIt|ForwardIterator}}
{{par req|No increment, assignment, comparison, or indirection through valid instances of {{tt|NoThrowForwardIt}} may throw exceptions.}}
{{par end}}

===Return value===
As described above.

===Complexity===
Linear in the distance between {{c|first}} and {{c|last}}.

===Exceptions===
{{cpp/algorithm/parallel exceptions reporting behavior|singular=yes}}

===Notes===
When the input iterator deferences to an rvalue, the behavior of {{tt|std::uninitialized_move}} is same as {{lc|std::uninitialized_copy}}.

{{feature test macro|__cpp_lib_raw_memory_algorithms|std=C++26|value=202411L|{{c/core|constexpr}} for [[cpp/memory#Uninitialized memory algorithms|specialized memory algorithms]], {{vl|1}}}}

===Possible implementation===
{{eq fun|1=
template&lt;class InputIt, class NoThrowForwardIt&gt;
constexpr NoThrowForwardIt uninitialized_move(InputIt first, InputIt last,
                                              NoThrowForwardIt d_first)
{
    using ValueType = typename std::iterator_traits&lt;NoThrowForwardIt&gt;::value_type;
    auto current = d_first;
    try
    {
        for (; first != last; ++first, (void) ++current)
        {
            auto addr = static_cast&lt;void*&gt;(std::addressof(*current));
            if constexpr (std::is_lvalue_reference_v&lt;decltype(*first)&gt;)
                ::new (addr) ValueType(std::move(*first));
            else
                ::new (addr) ValueType(*first);
        }
        return current;
    }
    catch (...)
    {
        std::destroy(d_first, current);
        throw;
    }
}
}}

===Example===
{{example|code=
#include &lt;cstdlib&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

void print(auto rem, auto first, auto last)
{
    for (std::cout &lt;&lt; rem; first != last; ++first)
        std::cout &lt;&lt; std::quoted(*first) &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    std::string in[]{"Home", "Work!"};
    print("initially, in: ", std::begin(in), std::end(in));
    
    if (
        constexpr auto sz = std::size(in);
        void* out = std::aligned_alloc(alignof(std::string), sizeof(std::string) * sz))
    {
        try
        {
            auto first{static_cast&lt;std::string*&gt;(out)};
            auto last{first + sz};
            std::uninitialized_move(std::begin(in), std::end(in), first);
            
            print("after move, in: ", std::begin(in), std::end(in));
            print("after move, out: ", first, last);
            
            std::destroy(first, last);
        }
        catch (...)
        {
            std::cout &lt;&lt; "Exception!\n";
        }
        std::free(out);
    }
}
|p=true&lt;!-- move results are indeterminate --&gt;
|output=
initially, in: "Home" "Work!"
after move, in: "" ""
after move, out: "Home" "Work!"
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3870|std=C++20|before=this algorithm might create objects on a {{c/core|const}} storage|after=kept disallowed}}
{{dr list item|wg=lwg|dr=3918|std=C++17|before=additional temporary materialization was required&lt;br&gt;when the input iterator deferences to a prvalue|after=copies the element in this case}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/dsc uninitialized_copy}}
{{dsc inc|cpp/memory/dsc uninitialized_move_n}}
{{dsc inc|cpp/memory/ranges/dsc uninitialized_move}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}