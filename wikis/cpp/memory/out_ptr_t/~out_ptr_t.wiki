{{cpp/memory/out_ptr_t/title|~out_ptr_t}}
{{cpp/memory/out_ptr_t/navbar}}
{{ddcl | since=c++23 |
~out_ptr_t();
}}

Resets the adapted {{tt|Smart}} object by the value of modified {{tt|Pointer}} object (or the {{c|void*}} object if {{c|operator void**()}} has been called) and the captured arguments.

Let
* {{tt|s}} denotes the adapted {{tt|Smart}} object,
* {{tt|args...}} denotes the captured arguments,
* {{tt|p}} denotes the value of stored {{tt|Pointer}}, or {{c|static_cast&lt;Pointer&gt;(*operator void**())}} if {{c|operator void**}} has been called,
* {{tt|SP}} be
** {{c|Smart::pointer}}, if it is valid and denotes a type, otherwise,
** {{c|Smart::element_type*}}, if {{c|Smart::element_type}} is valid and denotes a type, otherwise,
** {{c|std::pointer_traits&lt;Smart&gt;::element_type*}}, if {{c|std::pointer_traits&lt;Smart&gt;::element_type}} is valid and denotes a type, otherwise,
** {{tt|Pointer}}.

If {{c|s.reset(static_cast&lt;SP&gt;(p), std::forward&lt;Args&gt;(args)...)}} is well-formed, the destructor performs
:{{c|if (p) s.reset(static_cast&lt;SP&gt;(p), std::forward&lt;Args&gt;(args)...);}},
otherwise, if {{c|std::is_constructible_v&lt;Smart, SP, Args...&gt;}} is {{c|true}}, the destructor performs
:{{c|1=if (p) s = Smart(static_cast&lt;SP&gt;(p), std::forward&lt;Args&gt;(args)...);}},
otherwise, the program is ill-formed.

===Notes===
If {{tt|Smart}} is a {{lc|std::shared_ptr}} specialization, the implementation may allocate the storage for the new control block on construction, in order to leave non-throwing works to the destructor.

Arguments captured by value are destroyed after resetting.

{{langlinks|es|ja|ru|zh}}