{{cpp/memory/out_ptr_t/title|out_ptr_t}}
{{cpp/memory/out_ptr_t/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++23|
explicit out_ptr_t( Smart &amp;sp, Args... args );
}}
{{dcl|num=2|since=c++23|1=
out_ptr_t( const out_ptr_t&amp; ) = delete;
}}
{{dcl end}}

@1@ Creates an {{tt|out_ptr_t}}. Adapts {{c|sp}} as if binds it to the {{c|Smart&amp;}} member, captures every argument {{tt|t}} in {{c|args...}} as if initializes the corresponding member of type {{tt|T}} in {{tt|Args...}} with {{c|std::forward&lt;T&gt;(t)}}, then value-initializes the stored {{tt|Pointer}}.&lt;br&gt;
Then calls {{c|sp.reset()}} if the expression is well-formed; otherwise, calls {{c|1=sp = Smart()}} if {{c|std::is_default_constructible_v&lt;Smart&gt;}} is {{c|true}}. The program is ill-formed if both resetting operations are ill-formed.

@2@ Copy constructor is explicitly deleted. {{tt|out_ptr_t}} is neither copyable nor movable.

===Parameters===
{{par begin}}
{{par|sp|the object (typically a smart pointer) to adapt}}
{{par|args...|the arguments used for resetting to capture}}
{{par end}}

===Return value===
(none)

{{cpp/impldef exception}}

===Notes===
After construction, the {{tt|Pointer}} or {{c|void*}} object pointed by the return value of either conversion function is equal to {{c|nullptr}}.

Every argument in {{c|args...}} is moved into the created {{tt|out_ptr_t}} if it is of an object type, or transferred into the created {{tt|out_ptr_t}} as-is if it is of a reference type.

The constructor of {{tt|out_ptr_t}} is allowed to throw exceptions. For example, when {{c|sp}} is a {{lc|std::shared_ptr}}, the allocation for the new control block may be performed within the constructor rather than the destructor.

===Example===
{{example}}

{{langlinks|es|ja|ru|zh}}