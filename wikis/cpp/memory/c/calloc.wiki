{{cpp/title|calloc}}
{{cpp/memory/navbar}}
{{ddcl|header=cstdlib|
void* calloc( std::size_t num, std::size_t size );
}}

Allocates memory for an array of {{c|num}} objects of size {{c|size}}, initializes it to all bits zero ([[cpp/language/object#Object creation|implicitly creating]] objects in the destination area).

If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.

If {{c|size}} is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage).

{{cpp/memory/thread_safety_note}}

===Parameters===
{{par begin}}
{{par|num|number of objects}}
{{par|size|size of each object}}
{{par end}}

===Return value===
On success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with {{lc|std::free()}} or {{lc|std::realloc()}}.

On failure, returns a null pointer.

===Notes===
Due to the alignment requirements, the number of allocated bytes is not necessarily equal to {{c|num * size}}.

Initialization to all bits zero does not guarantee that a floating-point or a pointer would be initialized to 0.0 and the null pointer value, respectively (although that is true on all common platforms).

Originally (in C89), support for zero size was added to accommodate code such as 
{{source|1=
OBJ *p = calloc(0, sizeof(OBJ)); // "zero-length" placeholder
...
while (1)
{ 
    p = realloc(p, c * sizeof(OBJ)); // reallocations until size settles
    ... // code that may change c or break out of loop
}
}}

===Example===
{{example
|code=
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;

int main()
{
    int* p1 = (int*)std::calloc(4, sizeof(int)); // allocate and zero out an array of 4 int
    int* p2 = (int*)std::calloc(1, sizeof(int[4])); // same, naming the array type directly
    int* p3 = (int*)std::calloc(4, sizeof *p3); // same, without repeating the type name

    if (p2)
        for (int n = 0; n &lt; 4; ++n) // print the array
            std::cout &lt;&lt; "p2[" &lt;&lt; n &lt;&lt; "] == " &lt;&lt; p2[n] &lt;&lt; '\n';

    std::free(p1);
    std::free(p2);
    std::free(p3);
}
|output=
p2[0] == 0
p2[1] == 0
p2[2] == 0
p2[3] == 0
}}

===See also===
{{dsc begin}}
{{dsc see c|c/memory/calloc}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pl|pt|ru|zh}}