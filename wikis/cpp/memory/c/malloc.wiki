{{cpp/title|malloc}}
{{cpp/memory/navbar}}
{{ddcl|header=cstdlib|
void* malloc( std::size_t size );
}}

Allocates {{c|size}} bytes of uninitialized storage.

If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any scalar type (at least as strictly as {{lc|std::max_align_t}}) ([[cpp/language/object#Object creation|implicitly creating]] objects in the destination area).

If {{c|size}} is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to {{lc|std::free}}).

{{cpp/memory/thread_safety_note}}

===Parameters===
{{par begin}}
{{par|size|number of bytes to allocate}}
{{par end}}

===Return value===
On success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with {{lc|std::free()}} or {{lc|std::realloc()}}.

On failure, returns a null pointer.

===Notes===
This function does not call constructors or initialize memory in any way. There are no ready-to-use smart pointers that could guarantee that the matching deallocation function is called. The preferred method of memory allocation in C++ is using RAII-ready functions {{lc|std::make_unique}}, {{lc|std::make_shared}}, container constructors, etc, and, in low-level library code, [[cpp/language/new|new-expression]].

For loading a large file, file mapping via OS-specific functions, e.g. [https://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html {{tt|mmap}}] on POSIX or {{tt|CreateFileMapping}}([https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga {{tt|A}}]/[https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-createfilemappingw {{tt|W}}]) along with [https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile {{tt|MapViewOfFile}}] on Windows, is preferable to allocating a buffer for file reading.

===Example===
{{example
|code=
#include &lt;cstdlib&gt; 
#include &lt;iostream&gt;   
#include &lt;memory&gt;
#include &lt;string&gt;

int main() 
{
    constexpr std::size_t size = 4;
    if (auto ptr = reinterpret_cast&lt;std::string*&gt;(std::malloc(size * sizeof(std::string))))
    {
        try
        {
            for (std::size_t i = 0; i &lt; size; ++i)
                std::construct_at(ptr + i, 5, 'a' + i);
            for (std::size_t i = 0; i &lt; size; ++i)
                std::cout &lt;&lt; "ptr[" &lt;&lt; i &lt;&lt; "] == " &lt;&lt; ptr[i] &lt;&lt; '\n';
            std::destroy_n(ptr, size);
        }
        catch (...) {}
        std::free(ptr);
    }
}
|output=
p[0] == aaaaa
p[1] == bbbbb
p[2] == ccccc
p[3] == ddddd
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/new/dsc operator_new}}
{{dsc inc|cpp/memory/dsc get_temporary_buffer}}
{{dsc see c|c/memory/malloc}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pl|pt|ru|zh}}