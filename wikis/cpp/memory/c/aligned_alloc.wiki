{{cpp/title|aligned_alloc}}
{{cpp/memory/navbar}}
{{ddcl|header=cstdlib|since=c++17|
void* aligned_alloc( std::size_t alignment, std::size_t size );
}}

Allocate {{c|size}} bytes of uninitialized storage whose alignment is specified by {{c|alignment}} ([[cpp/language/object#Object creation|implicitly creating]] objects in the destination area). The {{c|size}} parameter must be an integral multiple of {{c|alignment}}.

{{cpp/memory/thread_safety_note}}

===Parameters===
{{par begin}}
{{par|alignment|specifies the alignment. Must be a valid alignment supported by the implementation.}}
{{par|size|number of bytes to allocate. An integral multiple of {{c|alignment}}.}}
{{par end}}

===Return value===
On success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with {{lc|std::free}} or {{lc|std::realloc}}.

On failure, returns a null pointer.

===Notes===
Passing a {{c|size}} which is not an integral multiple of {{c|alignment}} or an {{c|alignment}} which is not valid or not supported by the implementation causes the function to fail and return a null pointer (C11, as published, specified undefined behavior in this case, this was corrected by {{stddoc|summary.htm#dr_460|DR460|lang=c}}).

As an example of the "supported by the implementation" requirement, POSIX function [https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html {{tt|posix_memalign}}] accepts any {{c|alignment}} that is a power of two and a multiple of {{c|sizeof(void*)}}, and POSIX-based implementations of {{tt|aligned_alloc}} inherit this requirements.

Fundamental alignments are always supported. If {{c|alignment}} is a power of two and not greater than {{c|alignof(std::max_align_t)}}, {{tt|aligned_alloc}} may simply call {{lc|std::malloc}}.

Regular {{lc|std::malloc}} aligns memory suitable for any object type with a fundamental alignment.  This function is useful for over-aligned allocations, such as to {{enwiki|Streaming SIMD Extensions|SSE}}, cache line, or {{enwiki|Page (computer memory)#Multiple page sizes|VM page}} boundary.

This function is not supported in Microsoft C Runtime library because its implementation of {{lc|std::free}} is [https://learn.microsoft.com/en-us/cpp/standard-library/cstdlib#remarks-6 unable to handle aligned allocations] of any kind. Instead, MS CRT provides [https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/aligned-malloc {{tt|_aligned_malloc}}] (to be freed with [https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/aligned-free {{tt|_aligned_free}}]).

===Example===
{{example|code=
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
 
int main()
{
    int* p1 = static_cast&lt;int*&gt;(std::malloc(10 * sizeof *p1));
    std::printf("default-aligned address:   %p\n", static_cast&lt;void*&gt;(p1));
    std::free(p1);
 
    int* p2 = static_cast&lt;int*&gt;(std::aligned_alloc(1024, 1024));
    std::printf("1024-byte aligned address: %p\n", static_cast&lt;void*&gt;(p2));
    std::free(p2);
}
|p=true
|output=
default-aligned address:   0x2221c20
1024-byte aligned address: 0x2222400
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc aligned_storage}}
{{dsc see c|c/memory/aligned_alloc}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}