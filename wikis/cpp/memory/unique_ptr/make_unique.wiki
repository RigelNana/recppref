{{cpp/title|make_unique|make_unique_for_overwrite}}
{{cpp/memory/unique_ptr/navbar}}
{{dcl begin}}
{{dcl header|memory}}
{{dcl rev multi|num=1|anchor=1
|since1=c++14|notes1={{mark|only for non-array types}}|dcl1=
template&lt; class T, class... Args &gt;
unique_ptr&lt;T&gt; make_unique( Args&amp;&amp;... args );
|since2=c++23&lt;!--P2273R3--&gt;|notes2={{mark|only for non-array types}}|dcl2=
template&lt; class T, class... Args &gt;
constexpr unique_ptr&lt;T&gt; make_unique( Args&amp;&amp;... args );
}}
{{dcl rev multi|num=2
|since1=c++14|notes1={{mark|only for array types with unknown bound}}|dcl1=
template&lt; class T &gt;
unique_ptr&lt;T&gt; make_unique( std::size_t size );
|since2=c++23&lt;!--P2273R3--&gt;|notes2={{mark|only for array types with unknown bound}}|dcl2=
template&lt; class T &gt;
constexpr unique_ptr&lt;T&gt; make_unique( std::size_t size );
}}
{{dcl|num=3|since=c++14|notes={{mark|only for array types with known bound}}|1=
template&lt; class T, class... Args &gt;
/* unspecified */ make_unique( Args&amp;&amp;... args ) = delete;
}}
{{dcl rev multi|num=4|anchor=4
|since1=c++20|notes1={{mark|only for non-array types}}|dcl1=
template&lt; class T &gt;
unique_ptr&lt;T&gt; make_unique_for_overwrite();
|since2=c++23&lt;!--P2273R3--&gt;|notes2={{mark|only for non-array types}}|dcl2=
template&lt; class T &gt;
constexpr unique_ptr&lt;T&gt; make_unique_for_overwrite();
}}
{{dcl rev multi|num=5
|since1=c++20|notes1={{mark|only for array types with unknown bound}}|dcl1=
template&lt; class T &gt;
unique_ptr&lt;T&gt; make_unique_for_overwrite( std::size_t size );
|since2=c++23&lt;!--P2273R3--&gt;|notes2={{mark|only for array types with unknown bound}}|dcl2=
template&lt; class T &gt;
constexpr unique_ptr&lt;T&gt; make_unique_for_overwrite( std::size_t size );
}}
{{dcl|num=6|since=c++20|notes={{mark|only for array types with known bound}}|1=
template&lt; class T, class... Args &gt;
/* unspecified */ make_unique_for_overwrite( Args&amp;&amp;... args ) = delete;
}}
{{dcl end}}

Constructs an object of type {{tt|T}} and wraps it in a {{lc|std::unique_ptr}}.

@1@ Constructs a non-array type {{tt|T}}. The arguments {{c|args}} are passed to the constructor of {{tt|T}}. {{cpp/enable_if|{{tt|T}} is not an array type}}. The function is equivalent to:
{{source|unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...))}}

@2@ Constructs an array of the given dynamic size. The array elements are [[cpp/language/value_initialization|value-initialized]]. {{cpp/enable_if|{{tt|T}} is an array of unknown bound}}. The function is equivalent to:
{{source|unique_ptr&lt;T&gt;(new std::remove_extent_t&lt;T&gt;[size]())}}

@3,6@ Construction of arrays of known bound is disallowed.

@4@ Same as {{v|1}}, except that the object is [[cpp/language/default_initialization|default-initialized]]. {{cpp/enable_if|{{tt|T}} is not an array type}}. The function is equivalent to:
{{source|unique_ptr&lt;T&gt;(new T)}}

@5@ Same as {{v|2}}, except that the array is default-initialized. {{cpp/enable_if|{{tt|T}} is an array of unknown bound}}. The function is equivalent to:
{{source|unique_ptr&lt;T&gt;(new std::remove_extent_t&lt;T&gt;[size])}}

===Parameters===
{{par begin}}
{{par|args|list of arguments with which an instance of {{tt|T}} will be constructed}}
{{par|size|the length of the array to construct}}
{{par end}}

===Return value===
{{lc|std::unique_ptr}} of an instance of type {{tt|T}}.

===Exceptions===
May throw {{lc|std::bad_alloc}} or any exception thrown by the constructor of {{tt|T}}. If an exception is thrown, this function has no effect.

===Possible Implementation===
{{eq impl
|title1=make_unique {{v|1-3}}|ver1=1|1=
// C++14 make_unique
namespace detail
{
    template&lt;class&gt;
    constexpr bool is_unbounded_array_v = false;
    template&lt;class T&gt;
    constexpr bool is_unbounded_array_v&lt;T[]&gt; = true;

    template&lt;class&gt;
    constexpr bool is_bounded_array_v = false;
    template&lt;class T, std::size_t N&gt;
    constexpr bool is_bounded_array_v&lt;T[N]&gt; = true;
} // namespace detail

template&lt;class T, class... Args&gt;
std::enable_if_t&lt;!std::is_array&lt;T&gt;::value, std::unique_ptr&lt;T&gt;&gt;
make_unique(Args&amp;&amp;... args)
{
    return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));
}

template&lt;class T&gt;
std::enable_if_t&lt;detail::is_unbounded_array_v&lt;T&gt;, std::unique_ptr&lt;T&gt;&gt;
make_unique(std::size_t n)
{
    return std::unique_ptr&lt;T&gt;(new std::remove_extent_t&lt;T&gt;[n]());
}

template&lt;class T, class... Args&gt;
std::enable_if_t&lt;detail::is_bounded_array_v&lt;T&gt;&gt; make_unique(Args&amp;&amp;...) = delete;
|title2=make_unique_for_overwrite {{v|4-6}}|ver2=4|2=
// C++20 make_unique_for_overwrite
template&lt;class T&gt;
    requires (!std::is_array_v&lt;T&gt;)
std::unique_ptr&lt;T&gt; make_unique_for_overwrite()
{
    return std::unique_ptr&lt;T&gt;(new T);
}

template&lt;class T&gt;
    requires std::is_unbounded_array_v&lt;T&gt;
std::unique_ptr&lt;T&gt; make_unique_for_overwrite(std::size_t n)
{
    return std::unique_ptr&lt;T&gt;(new std::remove_extent_t&lt;T&gt;[n]);
}

template&lt;class T, class... Args&gt;
    requires std::is_bounded_array_v&lt;T&gt;
void make_unique_for_overwrite(Args&amp;&amp;...) = delete;
}}

===Notes===
Unlike {{lc|std::make_shared}} (which has {{lc|std::allocate_shared}}), {{tt|std::make_unique}} does not have an allocator-aware counterpart. {{tt|allocate_unique}} proposed in {{wg21|P0211}} would be required to invent the deleter type {{tt|D}} for the {{c|std::unique_ptr&lt;T,D&gt;}} it returns which would contain an allocator object and invoke both {{tt|destroy}} and {{tt|deallocate}} in its {{c|operator()}}.

{{ftm begin|std=1|comment=1}}
{{ftm|std=C++14|value=201304L|__cpp_lib_make_unique|{{tt|std::make_unique}}; overload {{v|1|1}}}}
{{ftm|std=C++20|value=202002L|__cpp_lib_smart_ptr_for_overwrite|Smart pointer creation with default initialization ({{lc|std::allocate_shared_for_overwrite}}, {{lc|std::make_shared_for_overwrite}}, {{tt|std::make_unique_for_overwrite}}); overloads {{v|4-6|4}}}}
{{ftm|std=C++23|value=202202L|__cpp_lib_constexpr_memory|{{tt|constexpr}} for overloads {{v|1,2,4,5|1}}}}
{{ftm end}}

===Example===
{{todo|add more {{c|make_unique_for_overwrite()}} demos}}
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;utility&gt;

struct Vec3
{
    int x, y, z;

    // Following constructor is no longer needed since C++20.
    Vec3(int x = 0, int y = 0, int z = 0) noexcept : x(x), y(y), z(z) {}

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vec3&amp; v)
    {
        return os &lt;&lt; "{ x=" &lt;&lt; v.x &lt;&lt; ", y=" &lt;&lt; v.y &lt;&lt; ", z=" &lt;&lt; v.z &lt;&lt; " }";
    }
};

// Output Fibonacci numbers to an output iterator.
template&lt;typename OutputIt&gt;
OutputIt fibonacci(OutputIt first, OutputIt last)
{
    for (int a = 0, b = 1; first != last; ++first)
    {
        *first = b;
        b += std::exchange(a, b);
    }
    return first;
}

int main()
{
    // Use the default constructor.
    std::unique_ptr&lt;Vec3&gt; v1 = std::make_unique&lt;Vec3&gt;();
    // Use the constructor that matches these arguments.
    std::unique_ptr&lt;Vec3&gt; v2 = std::make_unique&lt;Vec3&gt;(0, 1, 2);
    // Create a unique_ptr to an array of 5 elements.
    std::unique_ptr&lt;Vec3[]&gt; v3 = std::make_unique&lt;Vec3[]&gt;(5);

    // Create a unique_ptr to an uninitialized array of 10 integers,
    // then populate it with Fibonacci numbers.
    std::unique_ptr&lt;int[]&gt; i1 = std::make_unique_for_overwrite&lt;int[]&gt;(10);
    fibonacci(i1.get(), i1.get() + 10);

    std::cout &lt;&lt; "make_unique&lt;Vec3&gt;():      " &lt;&lt; *v1 &lt;&lt; '\n'
              &lt;&lt; "make_unique&lt;Vec3&gt;(0,1,2): " &lt;&lt; *v2 &lt;&lt; '\n'
              &lt;&lt; "make_unique&lt;Vec3[]&gt;(5):   ";
    for (std::size_t i = 0; i &lt; 5; ++i)
        std::cout &lt;&lt; std::setw(i ? 30 : 0) &lt;&lt; v3[i] &lt;&lt; '\n';
    std::cout &lt;&lt; '\n';

    std::cout &lt;&lt; "make_unique_for_overwrite&lt;int[]&gt;(10), fibonacci(...): [" &lt;&lt; i1[0];
    for (std::size_t i = 1; i &lt; 10; ++i)
        std::cout &lt;&lt; ", " &lt;&lt; i1[i];
    std::cout &lt;&lt; "]\n";
}
|output=
make_unique&lt;Vec3&gt;():      { x=0, y=0, z=0 }
make_unique&lt;Vec3&gt;(0,1,2): { x=0, y=1, z=2 }
make_unique&lt;Vec3[]&gt;(5):   { x=0, y=0, z=0 }
                          { x=0, y=0, z=0 }
                          { x=0, y=0, z=0 }
                          { x=0, y=0, z=0 }
                          { x=0, y=0, z=0 }

make_unique_for_overwrite&lt;int[]&gt;(10), fibonacci(...): [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/unique_ptr/dsc constructor}}
{{dsc inc|cpp/memory/shared_ptr/dsc make_shared}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}