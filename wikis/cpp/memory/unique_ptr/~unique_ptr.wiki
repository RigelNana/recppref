{{cpp/memory/unique_ptr/title|~unique_ptr}}
{{cpp/memory/unique_ptr/navbar}}
{{ddcl|since=c++11|notes={{mark|constexpr since C++23}}|
~unique_ptr();
}}
If {{lc|get()}} {{tt|1= == }} {{c|nullptr}} there are no effects. Otherwise, the owned object is destroyed via {{lc|get_deleter()}}{{tt|(}}{{lc|get()}}{{tt|)}}.

Requires that {{tt|get_deleter()(get())}} does not throw exceptions.

===Notes===
Although {{tt|std::unique_ptr&lt;T&gt;}} with the default deleter may be constructed with [[cpp/language/incomplete_type|incomplete type]] {{tt|T}}, the type {{tt|T}} must be complete at the point of code where the destructor is called.

===Example===
{{example
|The following program demonstrates usage of a custom deleter.
|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;
 
int main () 
{
    auto deleter = [](int* ptr)
    {
        std::cout &lt;&lt; "[deleter called]\n";
        delete ptr;
    };
 
    std::unique_ptr&lt;int, decltype(deleter)&gt; uniq(new int, deleter);
    std::cout &lt;&lt; (uniq ? "not empty\n" : "empty\n");
    uniq.reset();
    std::cout &lt;&lt; (uniq ? "not empty\n" : "empty\n");
}
|output=
not empty
[deleter called]
empty
}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}