{{cpp/memory/unique_ptr/title|unique_ptr}}
{{cpp/memory/unique_ptr/navbar}}
{{dcl begin}}
{{dcl h|members of the primary template, unique_ptr&lt;T&gt;}}
{{dcl|num=1|
constexpr unique_ptr() noexcept;
constexpr unique_ptr( std::nullptr_t ) noexcept;
}}
{{dcla|num=2|constexpr=c++23|
explicit unique_ptr( pointer p ) noexcept;
}}
{{dcla|num=3|constexpr=c++23|
unique_ptr( pointer p, /* see below */ d1 ) noexcept;
}}
{{dcla|num=4|constexpr=c++23|
unique_ptr( pointer p, /* see below */ d2 ) noexcept;
}}
{{dcla|num=5|constexpr=c++23|
unique_ptr( unique_ptr&amp;&amp; u ) noexcept;
}}
{{dcla|num=6|constexpr=c++23|
template&lt; class U, class E &gt;
unique_ptr( unique_ptr&lt;U, E&gt;&amp;&amp; u ) noexcept;
}}
{{dcl|num=7|1=
unique_ptr( const unique_ptr&amp; ) = delete;
}}
{{dcl|num=8|removed=c++17|
template&lt; class U &gt;
unique_ptr( std::auto_ptr&lt;U&gt;&amp;&amp; u ) noexcept;
}}
{{dcl h|members of the specialization for arrays, unique_ptr&lt;T[]&gt;}}
{{dcl|num=1|
constexpr unique_ptr() noexcept;
constexpr unique_ptr( std::nullptr_t ) noexcept;
}}
{{dcla|num=2|anchor=no|constexpr=c++23|
template&lt; class U &gt;
explicit unique_ptr( U p ) noexcept;
}}
{{dcla|num=3|anchor=no|constexpr=c++23|
template&lt; class U &gt;
unique_ptr( U p, /* see below */ d1 ) noexcept;
}}
{{dcla|num=4|anchor=no|constexpr=c++23|
template&lt; class U &gt;
unique_ptr( U p, /* see below */ d2 ) noexcept;
}}
{{dcla|num=5|anchor=no|constexpr=c++23|
unique_ptr( unique_ptr&amp;&amp; u ) noexcept;
}}
{{dcla|num=6|anchor=no|constexpr=c++23|
template&lt; class U, class E &gt;
unique_ptr( unique_ptr&lt;U, E&gt;&amp;&amp; u ) noexcept;
}}
{{dcl|num=7|1=
unique_ptr( const unique_ptr&amp; ) = delete;
}}
{{dcl end}}

@1@ Constructs a {{tt|std::unique_ptr}} that owns nothing. Value-initializes the stored pointer and the stored deleter. Requires that {{tt|Deleter}} is {{named req|DefaultConstructible}} and that construction does not throw an exception. {{cpp/enable if|plural=yes|{{c|std::is_default_constructible&lt;Deleter&gt;::value}} is {{c|true}} and {{c|Deleter}} is not a pointer type}}.

@2@ Constructs a {{tt|std::unique_ptr}} which owns {{c|p}}, initializing the stored pointer with {{c|p}} and value-initializing the stored deleter. Requires that {{tt|Deleter}} is {{named req|DefaultConstructible}} and that construction does not throw an exception. {{cpp/enable if|{{c|std::is_default_constructible&lt;Deleter&gt;::value}} is {{c|true}} and {{c|Deleter}} is not a pointer type}}.
{{rrev|since=c++17|
This constructor is not selected by [[cpp/language/class template argument deduction|class template argument deduction]].
}}

@3,4@ Constructs a {{tt|std::unique_ptr}} object which owns {{c|p}}, initializing the stored pointer with {{c|p}} and initializing a deleter {{tt|D}} as below (depends upon whether {{tt|D}} is a reference type).

:@a@ If {{tt|D}} is non-reference type {{c|A}}, then the signatures are:
{{dcl begin}}
{{dcl|num=1|unique_ptr(pointer p, const A&amp; d) noexcept;|notes=(requires that {{tt|Deleter}} is nothrow-{{named req|CopyConstructible}})}}
{{dcl|num=2|unique_ptr(pointer p, A&amp;&amp; d) noexcept;|notes=(requires that {{tt|Deleter}} is nothrow-{{named req|MoveConstructible}})}}
{{dcl end}}

:@b@ If {{tt|D}} is an lvalue-reference type {{c|A&amp;}}, then the signatures are:
{{dcl begin}}
{{dcl|num=1|unique_ptr(pointer p, A&amp; d) noexcept;}}
{{dcl|num=2|1=unique_ptr(pointer p, A&amp;&amp; d) = delete;}}
{{dcl end}}

:@c@ If {{tt|D}} is an lvalue-reference type {{c/core|const A&amp;}}, then the signatures are:
{{dcl begin}}
{{dcl|num=1|unique_ptr(pointer p, const A&amp; d) noexcept;}}
{{dcl|num=2|1=unique_ptr(pointer p, const A&amp;&amp; d) = delete;}}
{{dcl end}}
@@ In all cases the deleter is initialized from {{c|std::forward&lt;decltype(d)&gt;(d)}}. {{cpp/enable if|plural=yes|{{c|std::is_constructible&lt;D, decltype(d)&gt;::value}} is {{c|true}}}}.
{{rrev|since=c++17|
These two constructors are not selected by [[cpp/language/class template argument deduction|class template argument deduction]].
}}

@2-4@ In the specialization for arrays behave the same as the constructors that take a pointer parameter in the primary template except that they additionally do not participate in overload resolution unless one of the following is true:
* {{tt|U}} is the same type as {{tt|pointer}}, or
* {{tt|U}} is {{lc|std::nullptr_t}}, or
* {{tt|pointer}} is the same type as {{tt|element_type*}} and {{tt|U}} is some pointer type {{tt|V*}} such that {{tt|V(*)[]}} is implicitly convertible to {{tt|element_type(*)[]}}.

@5@ Constructs a {{tt|unique_ptr}} by transferring ownership from {{c|u}} to {{c|*this}} and stores the null pointer in {{c|u}}. This constructor only participates in overload resolution if {{c|std::is_move_constructible&lt;Deleter&gt;::value}} is {{c|true}}&lt;!--LWG 2899--&gt;. If {{tt|Deleter}} is not a reference type, requires that it is nothrow-{{named req|MoveConstructible}} (if {{tt|Deleter}} is a reference, {{tt|get_deleter()}} and {{tt|u.get_deleter()}} after move construction reference the same value).

@6@ Constructs a {{tt|unique_ptr}} by transferring ownership from {{c|u}} to {{c|*this}}, where {{c|u}} is constructed with a specified deleter ({{tt|E}}). It depends upon whether {{tt|E}} is a reference type, as following:
:@a@ if {{tt|E}} is a reference type, this deleter is copy constructed from {{c|u}}'s deleter (requires that this construction does not throw),
:@b@ if {{tt|E}} is a non-reference type, this deleter is move constructed from {{c|u}}'s deleter (requires that this construction does not throw).
@@ This constructor only participates in overload resolution if all of the following is true:
:@a@ {{c|unique_ptr&lt;U, E&gt;::pointer}} is implicitly convertible to {{tt|pointer}},
:@b@ U is not an array type,
:@c@ either {{tt|Deleter}} is a reference type and {{tt|E}} is the same type as {{tt|Deleter}}, or {{tt|Deleter}} is not a reference type and {{tt|E}} is implicitly convertible to {{tt|Deleter}}.

@6@ In the specialization for arrays behaves the same as in the primary template, except that it will only participate in overload resolution if all of the following is true:
* {{tt|U}} is an array type,
* {{tt|pointer}} is the same type as {{tt|element_type*}},
* {{c|unique_ptr&lt;U,E&gt;::pointer}} is the same type as {{c|unique_ptr&lt;U,E&gt;::element_type*}},
* {{c|unique_ptr&lt;U,E&gt;::element_type(*)[]}} is convertible to {{tt|element_type(*)[]}},
* either {{tt|Deleter}} is a reference type and {{tt|E}} is the same type as {{tt|Deleter}}, or {{tt|Deleter}} is not a reference type and {{tt|E}} is implicitly convertible to {{tt|Deleter}}.

@7@ Copy constructor is explicitly deleted.

@8@ Constructs a {{tt|unique_ptr}} where the stored pointer is initialized with {{ltf|cpp/memory/auto_ptr/release|u.release}} and the stored deleter is value-initialized. This constructor only participates in overload resolution if {{tt|U*}} is implicitly convertible to {{tt|T*}} and {{tt|Deleter}} is the same type as {{c|std::default_delete&lt;T&gt;}}.

===Parameters===
{{par begin}}
{{par|p|a pointer to an object to manage}}
{{par|d1, d2|a deleter to use to destroy the object}}
{{par|u|another smart pointer to acquire the ownership from}}
{{par end}}

===Notes===
{{rrev|since=c++14|
Instead of using the overload {{v|2}} together with new, it is often a better idea to use {{lc|std::make_unique|std::make_unique&lt;T&gt;}}.
}}

{{c|std::unique_ptr&lt;Derived&gt;}} is implicitly convertible to {{c|std::unique_ptr&lt;Base&gt;}} through the overload {{v|6}} (because both the managed pointer and {{lc|std::default_delete}} are implicitly convertible).

Because the default constructor is {{c/core|constexpr}}, static unique_ptrs are initialized as part of [[cpp/language/initialization#Non-local_variables|static non-local initialization]], before any dynamic non-local initialization begins. This makes it safe to use a unique_ptr in a constructor of any static object.

{{rrev|since=c++17|There is no [[cpp/language/class template argument deduction|class template argument deduction]] from pointer type because it is impossible to distinguish a pointer obtained from array and non-array forms of {{c/core|new}}.}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;

struct Foo // object to manage
{
    Foo() { std::cout &lt;&lt; "Foo ctor\n"; }
    Foo(const Foo&amp;) { std::cout &lt;&lt; "Foo copy ctor\n"; }
    Foo(Foo&amp;&amp;) { std::cout &lt;&lt; "Foo move ctor\n"; }
    ~Foo() { std::cout &lt;&lt; "~Foo dtor\n"; }
};

struct D // deleter
{
    D() {};
    D(const D&amp;) { std::cout &lt;&lt; "D copy ctor\n"; }
    D(D&amp;) { std::cout &lt;&lt; "D non-const copy ctor\n"; }
    D(D&amp;&amp;) { std::cout &lt;&lt; "D move ctor \n"; }
    void operator()(Foo* p) const
    {
        std::cout &lt;&lt; "D is deleting a Foo\n";
        delete p;
    };
};

int main()
{
    std::cout &lt;&lt; "Example constructor(1)...\n";
    std::unique_ptr&lt;Foo&gt; up1; // up1 is empty
    std::unique_ptr&lt;Foo&gt; up1b(nullptr); // up1b is empty

    std::cout &lt;&lt; "Example constructor(2)...\n";
    {
        std::unique_ptr&lt;Foo&gt; up2(new Foo); //up2 now owns a Foo
    } // Foo deleted

    std::cout &lt;&lt; "Example constructor(3)...\n";
    D d;
    {   // deleter type is not a reference
        std::unique_ptr&lt;Foo, D&gt; up3(new Foo, d); // deleter copied
    }
    {   // deleter type is a reference
        std::unique_ptr&lt;Foo, D&amp;&gt; up3b(new Foo, d); // up3b holds a reference to d
    }

    std::cout &lt;&lt; "Example constructor(4)...\n";
    {   // deleter is not a reference
        std::unique_ptr&lt;Foo, D&gt; up4(new Foo, D()); // deleter moved
    }

    std::cout &lt;&lt; "Example constructor(5)...\n";
    {
        std::unique_ptr&lt;Foo&gt; up5a(new Foo);
        std::unique_ptr&lt;Foo&gt; up5b(std::move(up5a)); // ownership transfer
    }

    std::cout &lt;&lt; "Example constructor(6)...\n";
    {
        std::unique_ptr&lt;Foo, D&gt; up6a(new Foo, d); // D is copied
        std::unique_ptr&lt;Foo, D&gt; up6b(std::move(up6a)); // D is moved

        std::unique_ptr&lt;Foo, D&amp;&gt; up6c(new Foo, d); // D is a reference
        std::unique_ptr&lt;Foo, D&gt; up6d(std::move(up6c)); // D is copied
    }

#if (__cplusplus &lt; 201703L)
    std::cout &lt;&lt; "Example constructor(7)...\n";
    {
        std::auto_ptr&lt;Foo&gt; up7a(new Foo);
        std::unique_ptr&lt;Foo&gt; up7b(std::move(up7a)); // ownership transfer
    }
#endif

    std::cout &lt;&lt; "Example array constructor...\n";
    {
        std::unique_ptr&lt;Foo[]&gt; up(new Foo[3]);
    } // three Foo objects deleted
}
|output=
Example constructor(1)...
Example constructor(2)...
Foo ctor
~Foo dtor
Example constructor(3)...
Foo ctor
D copy ctor
D is deleting a Foo
~Foo dtor
Foo ctor
D is deleting a Foo
~Foo dtor
Example constructor(4)...
Foo ctor
D move ctor
D is deleting a Foo
~Foo dtor
Example constructor(5)...
Foo ctor
~Foo dtor
Example constructor(6)...
Foo ctor
D copy ctor
D move ctor
Foo ctor
D non-const copy ctor
D is deleting a Foo
~Foo dtor
D is deleting a Foo
~Foo dtor
Example constructor(7)...
Foo ctor
~Foo dtor
Example array constructor...
Foo ctor
Foo ctor
Foo ctor
~Foo dtor
~Foo dtor
~Foo dtor
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2118|std=C++11|before=Constructors of {{tt|unique_ptr&lt;T[]&gt;}} rejected qualification conversions.|after=Accept.}}
{{dr list item|wg=lwg|dr=2520|std=C++11|before={{tt|unique_ptr&lt;T[]&gt;}} was accidentally made non-constructible from {{tt|nullptr_t}}.|after=Made constructible.}}
{{dr list item|wg=lwg|dr=2801|std=C++11|before=The default constructor was not constrained.|after=Constrained.}}
{{dr list item|wg=lwg|dr=2899|std=C++11|before=The move constructor was not constrained.|after=Constrained.}}
{{dr list item|wg=lwg|dr=2905|std=C++11|before=Constraint on the constructor from a pointer and a deleter was wrong.|after=Corrected.}}
{{dr list item|wg=lwg|dr=2944|std=C++11|before=Some preconditions were accidentally dropped by LWG 2905|after=Restored.}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}