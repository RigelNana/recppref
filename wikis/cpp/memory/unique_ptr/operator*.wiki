{{cpp/memory/unique_ptr/title|operator*|operator-&gt;}}
{{cpp/memory/unique_ptr/navbar}}
{{dcl begin}}
{{dcl|since=c++11|num=1|notes={{mark|constexpr since C++23}}|1=
typename std::add_lvalue_reference&lt;T&gt;::type operator*() const
    noexcept(noexcept(*std::declval&lt;pointer&gt;()));
}}
{{dcl|since=c++11|num=2|notes={{mark|constexpr since C++23}}|1=
pointer operator-&gt;() const noexcept;
}}
{{dcl end}}

{{tt|operator*}} and {{tt|operator-&gt;}} provide access to the object owned by {{c|*this}}.

The behavior is undefined if {{c|get() {{==}} nullptr}}.

These member functions are only provided for {{tt|unique_ptr}} for the single objects i.e. the primary template.

===Parameters===
(none)

===Return value===
@1@ Returns the object owned by {{c|*this}}, equivalent to {{c|*get()}}.

@2@ Returns a pointer to the object owned by {{c|*this}}, i.e. {{c|get()}}.

===Exceptions===
@1@ May throw if {{tt|pointer}} has a throwing {{tt|operator*}}.

===Notes===
The use of {{lc|std::add_lvalue_reference}} is to make it possible to instantiate {{c|std::unique_ptr&lt;void&gt;}} since {{c|void&amp;}} isn't allowed in C++ while {{c|std::add_lvalue_reference&lt;void&gt;}} produces {{c|void}}. See {{wg21|LWG673}} for details.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;

struct Foo
{
    void bar() { std::cout &lt;&lt; "Foo::bar\n"; }
};

void f(const Foo&amp;) 
{
    std::cout &lt;&lt; "f(const Foo&amp;)\n";
}

int main() 
{
    std::unique_ptr&lt;Foo&gt; ptr(new Foo);

    ptr-&gt;bar();
    f(*ptr);
}
|output=
Foo::bar
f(const Foo&amp;)
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2762|std=C++11|before={{tt|operator*}} might be potentially-throwing even if&lt;br&gt;{{c|*get()}} was noexcept|after=a conditional exception specification added}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/memory/unique_ptr/dsc get}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}