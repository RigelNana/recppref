{{cpp/io/ios_base/title|iword}}
{{cpp/io/ios_base/navbar}}
{{ddcl|
long&amp; iword( int index );
}}

First, allocates or resizes the private storage (dynamic array of {{c|long}} or another indexable data structure) sufficiently to make {{c|index}} a valid index, then returns a reference to the {{c|long}} element of the private storage with the index {{c|index}}. 

The reference may be invalidated by any operation on this {{tt|ios_base}} object, including another call to {{tt|iword()}}, but the stored values are retained, so that reading from {{c|iword(index)}} with the same index later will produce the same value until the next call to {{lc|std::basic_ios::copyfmt()}}. The value can be used for any purpose. The index of the element must be obtained by a previous call to {{lc|xalloc()}}, otherwise the behavior is undefined&lt;!--LWG 3083--&gt;. New elements are initialized to {{c|0}}.

If the function fails (possibly caused by an allocation failure) and {{c|*this}} is a base class subobject of a {{tt|basic_ios&lt;&gt;}} object or subobject, calls {{c|std::basic_ios&lt;&gt;::setstate(badbit)}} which may throw {{lc|std::ios_base::failure}}.

===Notes===
Typical use of iword storage is to pass information (e.g. custom formatting flags) from user-defined I/O manipulators to user-defined {{tt|operator&lt;&lt;}} and {{tt|operator&gt;&gt;}} or to user-defined formatting facets imbued into standard streams.

===Parameters===
{{par begin}}
{{par|index|index value of the element}}
{{par end}}

===Return value===
A reference to the element.

===Exceptions===
May throw {{lc|std::ios_base::failure}} when setting the badbit.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;

struct Foo
{
    static int foo_xalloc;
    std::string data; 
    
    Foo(const std::string&amp; s) : data(s) {}
};

// Allocates the iword storage for use with Foo objects
int Foo::foo_xalloc = std::ios_base::xalloc();

// This user-defined operator&lt;&lt; prints the string in reverse if the iword holds 1
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Foo&amp; f)
{
    if (os.iword(Foo::foo_xalloc) == 1)
        return os &lt;&lt; std::string(f.data.rbegin(), f.data.rend());
    else
        return os &lt;&lt; f.data;
}

// This I/O manipulator flips the number stored in iword between 0 and 1
std::ios_base&amp; rev(std::ios_base&amp; os)
{
    os.iword(Foo::foo_xalloc) = !os.iword(Foo::foo_xalloc);
    return os;
}

int main()
{
    Foo f("example");
    std::cout &lt;&lt; f &lt;&lt; '\n' &lt;&lt; rev &lt;&lt; f &lt;&lt; '\n' &lt;&lt; rev &lt;&lt; f &lt;&lt; '\n';
}
|output=
example
elpmaxe
example
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=36|std=C++98|before=the stored value might not be&lt;br&gt;retained if the reference is invalidated|after=the stored value is retained&lt;br&gt;until the next call of {{tt|copyfmt()}}}}
{{dr list item|wg=lwg|dr=41|std=C++98|before=the function set badbit by itself on failure,&lt;br&gt;but {{tt|ios_base}} does not provide such interface|after=badbit is set by {{tt|basic_ios}}&lt;br&gt;(if {{c|*this}} is its base class subobject)}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/ios_base/dsc pword}}
{{dsc inc|cpp/io/ios_base/dsc xalloc}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}