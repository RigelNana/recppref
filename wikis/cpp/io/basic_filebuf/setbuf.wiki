{{cpp/io/basic_filebuf/title|setbuf}}
{{cpp/io/basic_filebuf/navbar}}
{{ddcl|
protected:
virtual std::basic_streambuf&lt;CharT, Traits&gt;* setbuf( char_type* s, std::streamsize n )
}}

If {{c|s}} is a null pointer and {{c|n}} is zero, the filebuf becomes ''unbuffered'' for output, meaning {{tt|pbase()}} and {{tt|pptr()}} are null and any output is immediately sent to file.

Otherwise, a call to {{tt|setbuf()}} replaces the internal buffer (the controlled character sequence) with the user-supplied character array whose first element is pointed to by {{c|s}} and allows this {{lc|std::basic_filebuf}} object to use up to {{c|n}} bytes in that array for buffering.

This function is protected virtual, it may only be called through {{tt|pubsetbuf()}} or from member functions of a user-defined class derived from {{tt|std::basic_filebuf}}.

===Parameters===
{{par begin}}
{{par|s|pointer to the first {{tt|CharT}} in the user-provided buffer or null}}
{{par|n|the number of {{tt|CharT}} elements in the user-provided buffer or zero}}
{{par end}}

===Return value===
{{c|this}}

===Notes===
The conditions when this function may be used and the way in which the provided buffer is used is implementation-defined.

* GCC 4.6 libstdc++
: {{tt|setbuf()}} may only be called when the {{lc|std::basic_filebuf}} is not associated with a file (has no effect otherwise). With a user-provided buffer, reading from file reads {{tt|n-1}} bytes at a time.
* Clang++3.0 libc++
: {{tt|setbuf()}} may be called after opening the file, but before any I/O (may crash otherwise). With a user-provided buffer, reading from file reads largest multiples of 4096 that fit in the buffer. 
* Visual Studio 2010 
: {{tt|setbuf()}} may be called at any time, even after some I/O took place. Current contents of the buffer, if any, are lost.

The standard does not define any behavior for this function except that {{c|setbuf(0, 0)}} called before any I/O has taken place is required to set unbuffered output.

===Example===
{{example
|Provides a 10k buffer for reading. On linux, the strace utility may be used to observe the actual number of bytes read.
|code=
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    int cnt = 0;
    std::ifstream file;
    char buf[10241];
    
    file.rdbuf()-&gt;pubsetbuf(buf, sizeof buf);
    file.open("/usr/share/dict/words");
    
    for (std::string line; getline(file, line);)
        ++cnt;
    std::cout &lt;&lt; cnt &lt;&lt; '\n';
}
|p=true
|output=
356010
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=173|std=C++98|before=the type of {{c|n}} was misspecified as {{c|int}}|after=corrected to {{lc|std::streamsize}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/basic_streambuf/dsc pubsetbuf|mem=std::basic_streambuf}}
{{dsc inc|cpp/io/c/dsc setvbuf}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}