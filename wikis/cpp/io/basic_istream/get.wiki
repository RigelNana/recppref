{{cpp/io/basic_istream/title|get}}
{{cpp/io/basic_istream/navbar}}
{{dcl begin}}
{{dcl|num=1|
int_type get();
}}
{{dcl|num=2|
basic_istream&amp; get( char_type&amp; ch );
}}
{{dcl|num=3|
basic_istream&amp; get( char_type* s, std::streamsize count );
}}
{{dcl|num=4|
basic_istream&amp; get( char_type* s, std::streamsize count, char_type delim );
}}
{{dcl|num=5|
basic_istream&amp; get( basic_streambuf&amp; strbuf );
}}
{{dcl|num=6|
basic_istream&amp; get( basic_streambuf&amp; strbuf, char_type delim );
}}
{{dcl end}}

Extracts character or characters from stream.

All versions behave as {{named req|UnformattedInputFunction}}s. After constructing and checking the sentry object, these functions perform the following:

@1@ Reads one character and returns it if available. Otherwise, returns {{c|Traits::eof()}} and sets {{lc|failbit}} and {{lc|eofbit}}.

@2@ Reads one character and stores it to {{c|ch}} if available. Otherwise, leaves {{c|ch}} unmodified and sets {{lc|failbit}} and {{lc|eofbit}}. Note that this function is not overloaded on the types {{c/core|signed char}} and {{c/core|unsigned char}}, unlike the formatted character input operator&gt;&gt;.

@3@ Same as {{c|get(s, count, widen('\n'))}}, that is, reads at most {{c|std::max(0, count - 1)}} characters and stores them into character string pointed to by {{c|s}} until {{c|'\n'}} is found.

@4@ Reads characters and stores them into the successive locations of the character array whose first element is pointed to by {{c|s}}. Characters are extracted and stored until any of the following occurs:
* {{c|count}} is less than {{c|1}} or {{c|count - 1}} characters have been stored.
* end of file condition occurs in the input sequence ({{c|setstate(eofbit)}} is called).
* the next available input character {{c|c}} equals {{c|delim}}, as determined by {{c|Traits::eq(c, delim)}}. This character is not extracted (unlike {{rlpf|getline}}).

@@ In any case, if {{c|count &gt; 0}}, a null character ({{c|CharT()}} is stored in the next successive location of the array.

@5@ Same as {{c|get(strbuf, widen('\n'))}}, that is, reads available characters and inserts them to the given {{ltt|cpp/io/basic_streambuf}} object until {{c|'\n'}} is found.

@6@ Reads characters and inserts them to the output sequence controlled by the given {{ltt|cpp/io/basic_streambuf}} object. Characters are extracted and inserted into {{c|strbuf}} until any of the following occurs:
* end of file condition occurs in the input sequence.
* inserting into the output sequence fails (in which case the character that could not be inserted, is not extracted).
* the next available input character {{c|c}} equals {{c|delim}}, as determined by {{c|Traits::eq(c, delim)}}. This character is not extracted.
* an exception occurs (in which case the exception is caught and not rethrown).

If no characters were extracted, calls {{c|setstate(failbit)}}. 

All versions set the value of {{lc|gcount()}} to the number of characters extracted.

===Parameters===
{{par begin}}
{{par|ch|reference to the character to write the result to}}
{{par|s|pointer to the character string to store the characters to}}
{{par|count|size of character string pointed to by {{c|s}}}}
{{par|delim|delimiting character to stop the extraction at. It is not extracted and not stored}}
{{par|strbuf|stream buffer to read the content to}}
{{par end}}

===Return value===
@1@ The extracted character or {{c|Traits::eof()}}.
@2-6@ {{c|*this}}

===Exceptions===
{{include|cpp/io/stream exceptions}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;sstream&gt;

int main()
{
    std::istringstream s1("Hello, world.");
    char c1 = s1.get(); // reads 'H'
    std::cout &lt;&lt; "after reading " &lt;&lt; c1 &lt;&lt; ", gcount() == " &lt;&lt;  s1.gcount() &lt;&lt; '\n';
    
    char c2;
    s1.get(c2);         // reads 'e'
    char str[5];
    s1.get(str, 5);     // reads "llo,"
    std::cout &lt;&lt; "after reading " &lt;&lt; str &lt;&lt; ", gcount() == " &lt;&lt;  s1.gcount() &lt;&lt; '\n';
    
    std::cout &lt;&lt; c1 &lt;&lt; c2 &lt;&lt; str;
    s1.get(*std::cout.rdbuf()); // reads the rest, not including '\n'
    std::cout &lt;&lt; "\nAfter the last get(), gcount() == " &lt;&lt; s1.gcount() &lt;&lt; '\n';
}
|output=
after reading H, gcount() == 1
after reading llo,, gcount() == 4
Hello, world.
After the last get(), gcount() == 7
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=370|std=C++98|before=the effect of overload {{v|5}} was {{c|get(s, count, widen('\n'))}},&lt;br&gt;which is the effect of overload {{v|3}}|after=corrected to&lt;br&gt;{{c|get(strbuf, widen('\n'))}}}}
{{dr list item|wg=lwg|dr=531|std=C++98|before=overloads {{v|3,4}} could not handle the&lt;br&gt;case where {{c|count}} is non-positive|after=no character is&lt;br&gt;extracted in this case}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/basic_istream/dsc read}}
{{dsc inc|cpp/io/basic_istream/dsc operator_gtgt}}
{{dsc inc|cpp/io/basic_istream/dsc operator_gtgt2}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}