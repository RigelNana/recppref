{{cpp/io/basic_istream/title|getline}}
{{cpp/io/basic_istream/navbar}}
{{dcl begin}}
{{dcl|num=1|
basic_istream&amp; getline( char_type* s, std::streamsize count );
}}
{{dcl|num=2|
basic_istream&amp; getline( char_type* s, std::streamsize count, char_type delim );
}}
{{dcl end}}

Extracts characters from stream until end of line or the specified delimiter {{c|delim}}.

The first overload is equivalent to {{c|getline(s, count, widen('\n'))}}.

Behaves as {{named req|UnformattedInputFunction}}. After constructing and checking the sentry object, extracts characters from {{c|*this}} and stores them in successive locations of the array whose first element is pointed to by {{c|s}}, until any of the following occurs (tested in the order shown):

# end of file condition occurs in the input sequence.
# the next available character {{c|c}} is the delimiter, as determined by {{c|Traits::eq(c, delim)}}. The delimiter is extracted (unlike {{rlpt|get|basic_istream::get()}}) and counted towards {{lc|gcount()}}, but is not stored.
# {{c|count}} is non-positive, or {{c|count - 1}} characters have been extracted ({{c|setstate(failbit)}} is called in this case).

If the function extracts no characters, â€‹{{tt|failbit}} is set in the local error state before {{ltf|cpp/io/basic_ios/setstate}} is called.

In any case, if {{c|count &gt; 0}}, it then stores a null character {{c|CharT()}} into the next successive location of the array and updates {{lc|gcount()}}.

===Notes===
Because condition #2 is tested before condition #3, the input line that exactly fits the buffer does not trigger {{tt|failbit}}.

Because the terminating character is counted as an extracted character, an empty input line does not trigger {{tt|failbit}}.

===Parameters===
{{par begin}}
{{par|s|pointer to the character string to store the characters to}}
{{par|count|size of character string pointed to by {{c|s}}}}
{{par|delim|delimiting character to stop the extraction at. It is extracted but not stored.}}
{{par end}}

===Return value===
{{c|*this}}

===Exceptions===
{{include|cpp/io/stream exceptions}}

===Example===
{{example
|code=
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;

int main()
{
    std::istringstream input("abc{{!}}def{{!}}gh");
    std::vector&lt;std::array&lt;char, 4&gt;&gt; v;
    
    // note: the following loop terminates when std::ios_base::operator bool()
    // on the stream returned from getline() returns false
    for (std::array&lt;char, 4&gt; a; input.getline(&amp;a[0], 4, '{{!}}');)
        v.push_back(a);
    
    for (auto&amp; a : v)
        std::cout &lt;&lt; &amp;a[0] &lt;&lt; '\n';
}
|output=
abc
def
gh
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=531|std=C++98|before={{tt|std::getline}} could not handle the&lt;br&gt;case where {{c|count}} is non-positive|after=no character is&lt;br&gt;extracted in this case}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/string/basic_string/dsc getline}}
{{dsc inc|cpp/io/basic_istream/dsc operator_gtgt}}
{{dsc inc|cpp/io/basic_istream/dsc get}}
{{dsc inc|cpp/io/basic_istream/dsc read}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}