{{cpp/title|endl}}
{{cpp/io/manip/navbar}}
{{ddcl|header=ostream|
template&lt; class CharT, class Traits &gt;
std::basic_ostream&lt;CharT, Traits&gt;&amp; endl( std::basic_ostream&lt;CharT, Traits&gt;&amp; os );
}}

Inserts a newline character into the output sequence {{c|os}} and flushes it as if by calling {{c|os.put(os.widen('\n'))}} followed by {{c|os.flush()}}. 

This is an output-only I/O manipulator, it may be called with an expression such as {{c|out &lt;&lt; std::endl}} for any {{tt|out}} of type {{lc|std::basic_ostream}}.

===Notes===
This manipulator may be used to produce a line of output immediately, e.g. when displaying output from a long-running process, logging activity of multiple threads or logging activity of a program that may crash unexpectedly. An explicit flush  of {{lc|std::cout}} is also necessary before a call to {{lc|std::system}}, if the spawned process performs any screen I/O.&lt;!--couldn't reproduce in VS2013, did it change? ---- (a common example is {{c|std::system("pause")}} on Windows).--&gt; In most other usual interactive I/O scenarios, {{tt|std::endl}} is redundant when used with {{lc|std::cout}} because any input from {{lc|std::cin}}, output to {{lc|std::cerr}}, or program termination forces a call to {{c|std::cout.flush()}}. Use of {{tt|std::endl}} in place of {{c/core|'\n'}}, encouraged by some sources, may significantly degrade output performance.

In many implementations, standard output is line-buffered, and writing {{c/core|'\n'}} causes a flush anyway, unless {{c|std::ios::sync_with_stdio(false)}} was executed. In those situations, unnecessary {{tt|endl}} only degrades the performance of file output, not standard output.

The code samples on this wiki [https://www.stroustrup.com/3rd_code.html follow Bjarne Stroustrup] and [https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rio-endl The C++ Core Guidelines] in flushing the standard output only where necessary.

When an incomplete line of output needs to be flushed, the {{lc|std::flush}} manipulator may be used.

When every character of output needs to be flushed, the {{lc|std::unitbuf}} manipulator may be used.

===Parameters===
{{par begin}}
{{par|os|reference to output stream}}
{{par end}}

===Return value===
{{c|os}} (reference to the stream after manipulation).

===Example===
{{example
|With {{c/core|'\n'}} instead of {{tt|endl}}, the output would be the same, but may not appear in real time.
|code=
#include &lt;chrono&gt;
#include &lt;iostream&gt;
 
template&lt;typename Diff&gt;
void log_progress(Diff d)
{
    std::cout &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(d)
              &lt;&lt; " passed" &lt;&lt; std::endl;
}
 
int main()
{
    std::cout.sync_with_stdio(false); // on some platforms, stdout flushes on \n
 
    static volatile int sink{};
    const auto t1 = std::chrono::high_resolution_clock::now();
    for (int i = 0; i &lt; 5; ++i)
    {
        for (int j = 0; j &lt; 10000; ++j)
            for (int k = 0; k &lt; 20000; ++k)
                sink += i * j * k; // do some work
        log_progress(std::chrono::high_resolution_clock::now() - t1);
    }
}
|p=true
|output=
566ms passed
1133ms passed
1699ms passed
2262ms passed
2829ms passed
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/manip/dsc unitbuf}}
{{dsc inc|cpp/io/manip/dsc flush}}
{{dsc inc|cpp/io/basic_ostream/dsc flush}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}