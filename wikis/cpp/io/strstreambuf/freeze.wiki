{{cpp/io/strstreambuf/title|freeze}}
{{cpp/io/strstreambuf/navbar}}
{{ddcl|deprecated=c++98|removed=c++26|1=
void freeze( bool freezefl = true );
}}

If the buffer uses dynamic allocation, sets the frozen status of the stream to {{c|freezefl}}.

While the stream is frozen, {{lc|overflow()}} will not reallocate the buffer and the {{rlpt|~strstreambuf|destructor}} will not deallocate the buffer (thereby causing a memory leak). 

===Parameters===
{{par begin}}
{{par|freezefl|new value to set the freeze status to}}
{{par end}}

===Return value===
(none)

===Notes===
Every call to {{lc|str()}} freezes the stream to preserve the validity of the pointer it returns. To allow the destructor to deallocate the buffer, {{c|freeze(false)}} needs to be called explicitly.

===Example===
{{example
|In this example, initial allocation of the underlying array was for 16 bytes.
|code=
#include &lt;iostream&gt;
#include &lt;strstream&gt;
 
int main()
{
    {
        std::strstream dyn; // dynamically-allocated read/write buffer
        dyn &lt;&lt; "Test: " &lt;&lt; 1.23; // note: no std::ends to demonstrate append behavior
        std::cout &lt;&lt; "dynamic buffer holds " &lt;&lt; dyn.pcount() &lt;&lt; " characters: '";
        std::cout.write(dyn.str(), dyn.pcount()) &lt;&lt; "'\n";
        // the buffer is now frozen, further output will not make the buffer grow
        dyn &lt;&lt; "more output, hopefully enough to run out of the allocated space"
            &lt;&lt; std::ends;
        std::cout &lt;&lt; "After more output, it holds "
                  &lt;&lt; dyn.pcount() &lt;&lt; " characters: '" &lt;&lt; dyn.str() &lt;&lt; "'\n";
        dyn.freeze(false); // unfreeze before destructor
    } // memory freed by the destructor
 
    {
        char arr[20];
        std::ostrstream st(arr, sizeof arr); // fixed-size buffer
        st &lt;&lt; 1.23; // note: no std::ends to demonstrate append behavior
        std::cout &lt;&lt; "static buffer holds "
                  &lt;&lt; st.pcount() &lt;&lt; " characters: '";
        std::cout.write(st.str(), st.pcount());
        std::cout &lt;&lt; "'\n";
        st &lt;&lt; "more output, hopefully enough to run out of the allocated space"
           &lt;&lt; std::ends;
        std::cout &lt;&lt; "static buffer holds "
                  &lt;&lt; st.pcount() &lt;&lt; " characters: '";
        std::cout.write(st.str(), st.pcount());
        std::cout &lt;&lt; "'\n";
    } // nothing to deallocate, no need to unfreeze,
}
|output=
dynamic buffer holds 10 characters: 'Test: 1.23'
After more output, it holds 16 characters: 'Test: 1.23more o'
static buffer holds 4 characters: '1.23'
static buffer holds 20 characters: '1.23more output, hop'
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/strstream/dsc freeze|strstream}}
{{dsc inc|cpp/io/strstream/dsc freeze|ostrstream}}
{{dsc inc|cpp/io/strstreambuf/dsc ~strstreambuf}}
{{dsc inc|cpp/io/strstreambuf/dsc overflow}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}