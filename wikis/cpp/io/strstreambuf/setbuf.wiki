{{cpp/io/strstreambuf/title|setbuf}}
{{cpp/io/strstreambuf/navbar}}
{{ddcl|deprecated=c++98|removed=c++26|1=
protected:
virtual streambuf* setbuf( char* s, std::streamsize n );
}}

If {{c|s}} is a null pointer and {{c|n}} is zero, this function has no effect.

Otherwise, the effect is implementation-defined: some implementations do nothing, while some implementations deallocate the dynamic member array used as the buffer and begin using the user-supplied character array of size {{c|n}}, whose first element is pointed to by {{c|s}}.

This function is protected virtual, it may only be called through {{tt|pubsetbuf()}} or from member functions of a user-defined class derived from {{tt|std::strstreambuf}}.

===Parameters===
{{par begin}}
{{par|s|pointer to the first byte in the user-provided buffer}}
{{par|n|the number of bytes in the user-provided buffer}}
{{par end}}

===Return value===
{{c|this}}

===Example===
{{example
|Implementation test to check if {{tt|setbuf()}} is supported on a dynamic strstream (output obtained with Sun Studio):
|code=
#include &lt;iostream&gt;
#include &lt;strstream&gt;

int main()
{
    char a[100] = {};
    std::strstream str;
    str.rdbuf()-&gt;pubsetbuf(a, sizeof a);
    str &lt;&lt; "Test string" &lt;&lt; std::ends;
    std::cout &lt;&lt; "user-provided buffer holds \"" &lt;&lt; a &lt;&lt; "\"\n";
}
|p=true
|output=
user-provided buffer holds "Test string"
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=66|std=C++98|before=the effect of {{tt|setbuf()}} was "performs an operation that is&lt;br&gt;defined separately for each class derived from {{tt|strstreambuf}}",&lt;br&gt;but there are no classes derived from {{tt|strstreambuf}}|after=the effect is&lt;br&gt;implementation-defined}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/basic_streambuf/dsc pubsetbuf}}
{{dsc inc|cpp/io/basic_streambuf/dsc setbuf}}
{{dsc inc|cpp/io/basic_stringbuf/dsc setbuf}}
{{dsc inc|cpp/io/basic_filebuf/dsc setbuf}}
{{dsc end}}

{{langlinks|ja|zh}}