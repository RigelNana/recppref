{{cpp/io/basic_stringbuf/title|overflow}}
{{cpp/io/basic_stringbuf/navbar}}
{{ddcl|1=
protected:
virtual int_type overflow( int_type c = Traits::eof() );
}}

Appends the character {{c|c}} to the output character sequence.

If {{c|c}} is the end-of-file indicator ({{c|1=traits::eq_int_type(c, traits::eof()) == true}}), then there is no character to append. The function does nothing and returns an unspecified value other than {{c|traits::eof()}}.

Otherwise, if the output sequence has a write position available or this function can successfully make a write position available, then calls {{c|sputc(c)}} and returns {{c|c}}.

This function can make a write position available if the {{lc|std::stringbuf}} is open for output ({{c|1=(mode &amp; ios_base::out) != 0}}): in this case, it reallocates (or initially allocates) the buffer big enough to hold the entire current buffer plus at least one more character. If the {{lc|std::stringbuf}} is also open for input ({{c|1=(mode &amp; ios_base::in) != 0}}), then {{tt|overflow}} also increases the size of the get area by moving {{lc|egptr()}} to point just past the new write position.

===Parameters===
{{par begin}}
{{par|c|the character to store in the put area}}
{{par end}}

===Return value===
{{c|Traits::eof()}} to indicate failure, {{c|c}} if the character {{c|c}} was successfully appended, or some value other than {{c|Traits::eof()}} if called with {{c|Traits::eof()}} as the argument.

===Notes===
This function is different from a typical {{tt|overflow()}} which moves the contents of the buffer to the associated character sequence because for a {{lc|std::basic_stringbuf}}, the buffer and the associated sequence are one and the same.


===Example===
{{example
|In the implementation used to execute this example (e.g. GCC-4.9), {{tt|overflow()}} over-allocates the put area to 512 bytes: a call to {{lc|str()}} would only return the four initialized bytes, but the next 508 calls to {{lc|sputc()}} would not require new calls to {{tt|overflow()}}.
|code=
#include &lt;sstream&gt;
#include &lt;iostream&gt;

struct mybuf : std::stringbuf
{
    mybuf(const std::string&amp; new_str,
          std::ios_base::openmode which = std::ios_base::in {{!}} std::ios_base::out)
        : std::stringbuf(new_str, which) {}
    
    int_type overflow(int_type c = EOF) override
    {
        std::cout &lt;&lt; "stringbuf::overflow('" &lt;&lt; char(c) &lt;&lt; "') called\n"
                  &lt;&lt; "Before: size of get area: " &lt;&lt; egptr() - eback() &lt;&lt; '\n'
                  &lt;&lt; "        size of put area: " &lt;&lt; epptr() - pbase() &lt;&lt; '\n';
        
        int_type ret = std::stringbuf::overflow(c);
        
        std::cout &lt;&lt; "After : size of get area: " &lt;&lt; egptr() - eback() &lt;&lt; '\n'
                  &lt;&lt; "        size of put area: " &lt;&lt; epptr() - pbase() &lt;&lt; '\n';
        
        return ret;
    }
};

int main()
{
    std::cout &lt;&lt; "read-write stream:\n";
    mybuf sbuf("   "); // read-write stream
    std::iostream stream(&amp;sbuf);
    stream &lt;&lt; 1234;
    std::cout &lt;&lt; sbuf.str() &lt;&lt; '\n';
    
    std::cout &lt;&lt; "\nread-only stream:\n";
    mybuf ro_buf("   ", std::ios_base::in); // read-only stream
    std::iostream ro_stream(&amp;ro_buf);
    ro_stream &lt;&lt; 1234;
    
    std::cout &lt;&lt; "\nwrite-only stream:\n";
    mybuf wr_buf("   ", std::ios_base::out); // write-only stream
    std::iostream wr_stream(&amp;wr_buf);
    wr_stream &lt;&lt; 1234;
}
|p=true
|output=
read-write stream:
stringbuf::overflow('4') called
Before: size of get area: 3
        size of put area: 3
After : size of get area: 4
        size of put area: 512
1234

read-only stream:
stringbuf::overflow('1') called
Before: size of get area: 3
        size of put area: 0
After : size of get area: 3
        size of put area: 0

write-only stream:
stringbuf::overflow('4') called
Before: size of get area: 0
        size of put area: 3
After : size of get area: 0
        size of put area: 512
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=169|std=C++98|before=the buffer (re)allocated could only hold one extra character|after=allows more extra characters}}
{{dr list item|wg=lwg|dr=432|std=C++98|before={{tt|overflow}} moved {{lc|epptr()}} to point just past the new&lt;br&gt;write position if the {{tt|std::stringbuf}} is open for input|after=it is not moved}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/basic_streambuf/dsc overflow}}
{{dsc inc|cpp/io/basic_stringbuf/dsc underflow}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}