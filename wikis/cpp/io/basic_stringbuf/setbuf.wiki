{{cpp/io/basic_stringbuf/title|setbuf}}
{{cpp/io/basic_stringbuf/navbar}}
{{ddcl|
protected:
virtual std::basic_streambuf&lt;CharT, Traits&gt;* setbuf( char_type* s, std::streamsize n )
}}

If {{c|s}} is a null pointer and {{c|n}} is zero, this function has no effect.

Otherwise, the effect is implementation-defined: some implementations do nothing, while some implementations clear the {{lc|std::string}} member currently used as the buffer and begin using the user-supplied character array of size {{c|n}}, whose first element is pointed to by {{c|s}}, as the buffer and the input/output character sequence.

This function is protected virtual, it may only be called through {{tt|pubsetbuf()}} or from member functions of a user-defined class derived from {{tt|std::basic_stringbuf}}.

===Parameters===
{{par begin}}
{{par|s|pointer to the first CharT in the user-provided buffer or null}}
{{par|n|the number of CharT elements in the user-provided buffer or zero}}
{{par end}}

===Return value===
{{c|this}}

===Notes===
The deprecated stream buffer {{c|std::strstreambuf}} or the boost.IOStreams device [https://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array {{tt|boost::basic_array}}] may be used to implement I/O buffering over a user-provided char array in portable manner.

===Example===
{{example
|Test for the stringstream's setbuf functionality.
|code=
#include &lt;iostream&gt;
#include &lt;sstream&gt;

int main()
{
    std::ostringstream ss;
    char c[1024] = {};
    ss.rdbuf()-&gt;pubsetbuf(c, 1024);
    ss &lt;&lt; 3.14 &lt;&lt; '\n';
    std::cout &lt;&lt; c &lt;&lt; '\n';
}
|output=
3.14 (on GNU g++/libstdc++ and SunPro C++/roguewave)
&lt;nothing&gt; (on MS Visual Studio 2010, SunPro C++/stlport4, CLang++/libc++)
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/basic_streambuf/dsc pubsetbuf}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}