{{cpp/io/basic_stringbuf/title|basic_stringbuf}}
{{cpp/io/basic_stringbuf/navbar}}
{{dcl begin}}
{{dcl rev multi|num=1|until1=c++11|dcl1=
explicit basic_stringbuf( std::ios_base::openmode which =
                              std::ios_base::in {{!}} std::ios_base::out );
|dcl2=
explicit basic_stringbuf( std::ios_base::openmode which );
}}
{{dcl|num=2|since=c++11|1=
basic_stringbuf()
    : basic_stringbuf( std::ios_base::in {{!}} std::ios_base::out ) {}
}}
{{dcl|num=3|1=
explicit
    basic_stringbuf( const std::basic_string&lt;CharT, Traits, Allocator&gt;&amp; s,
                     std::ios_base::openmode which =
                         std::ios_base::in {{!}} std::ios_base::out );
}}
{{dcl|num=4|since=c++20|1=
explicit basic_stringbuf( std::basic_string&lt;CharT, Traits, Allocator&gt;&amp;&amp; s,
                          std::ios_base::openmode which =
                              std::ios_base::in {{!}} std::ios_base::out );
}}
{{dcl|num=5|since=c++20|1=
basic_stringbuf( std::ios_base::openmode which, const Allocator&amp; a );
}}
{{dcl|num=6|since=c++20|1=
explicit basic_stringbuf( const Allocator&amp; a )
    : basic_stringbuf( std::ios_base::in {{!}} std::ios_base::out, a ) {}
}}
{{dcl|num=7|since=c++20|1=
template&lt; class SAlloc &gt;
explicit basic_stringbuf( const std::basic_string&lt;CharT, Traits, SAlloc&gt;&amp; s,
                          std::ios_base::openmode which =
                              std::ios_base::in {{!}} std::ios_base::out );
}}
{{dcl|num=8|since=c++20|1=
template&lt; class SAlloc &gt;
basic_stringbuf( const std::basic_string&lt;CharT, Traits, SAlloc&gt;&amp; s,
                 std::ios_base::openmode which, const Allocator&amp; a );
}}
{{dcl|num=9|since=c++20|1=
template&lt; class SAlloc &gt;
basic_stringbuf( const std::basic_string&lt;CharT, Traits, SAlloc&gt;&amp; s,
                 const Allocator&amp; a )
    : basic_stringbuf( s, std::ios_base::in {{!}} std::ios_base::out, a ) {}
}}
{{dcl|num=10|since=c++26|1=
template&lt; class StringViewLike &gt;
explicit basic_stringbuf( const StringViewLike&amp; t,
                          std::ios_base::openmode which =
                              std::ios_base::in {{!}} std::ios_base::out );
}}
{{dcl|num=11|since=c++26|1=
template&lt; class StringViewLike &gt;
basic_stringbuf( const StringViewLike&amp; t,
                 std::ios_base::openmode which, const Allocator&amp; a );
}}
{{dcl|num=12|since=c++26|1=
template&lt; class StringViewLike &gt;
basic_stringbuf( const StringViewLike&amp; t, const Allocator&amp; a );
}}
{{dcl|num=13|since=c++11|1=
basic_stringbuf( basic_stringbuf&amp;&amp; rhs );
}}
{{dcl|num=14|since=c++20|1=
basic_stringbuf( basic_stringbuf&amp;&amp; rhs, const Allocator&amp; a );
}}
{{dcl|num=15|since=c++11|1=
basic_stringbuf( const basic_stringbuf&amp; rhs ) = delete;
}}
{{dcl end}}

The {{lc|std::basic_streambuf}} base and the {{rlp|/#Exposition-only members|exposition-only data members}} {{tti|buf}} and {{tti|mode}} are initialized as follows.

After initializing these subobjects, overloads {{v|3-12}} initialize the input and output sequences as if by calling {{rlpf|init_buf_ptrs|''init_buf_ptrs''}}.

{|class="wikitable" style="text-align: center;"
|-
!{{nbsp}}Overload{{nbsp}}
!{{nbsp}}{{lc|std::basic_streambuf}} base{{nbsp}}
!{{tti|buf}}
!{{tti|mode}}
|-
|{{v|1}}
|rowspan=12|default-initialized
|rowspan=2|implementation-defined&lt;br&gt;(see below)
|{{c|which}}
|-
|{{v|2}}
|style="text-align: left;"|{{nbsp}}{{c multi|std::ios_base::in {{!}}|    std::ios_base::out}}{{nbsp}}
|-
|{{v|3}}
|{{c|s}}
|rowspan=3|{{c|which}}
|-
|{{v|4}}
|{{c|std::move(s)}}
|-
|{{v|5}}
|rowspan=2|{{c|a}}
|-
|{{v|6}}
|style="text-align: left;"|{{nbsp}}{{c multi|std::ios_base::in {{!}}|    std::ios_base::out}}
|-
|{{v|7}}
|{{c|s}}
|rowspan=2|{{c|which}}
|-
|{{v|8}}
|rowspan=2|{{c|{s, a}&lt;!----&gt;}}
|-
|{{v|9}}
|style="text-align: left;"|{{nbsp}}{{c multi|std::ios_base::in {{!}}|    std::ios_base::out}}
|-
|{{v|10}}
|{{c|{sv, Allocator()}&lt;!----&gt;}}
|rowspan=2|{{c|which}}
|-
|{{v|11}}
|rowspan=2|{{c|{sv, a}&lt;!----&gt;}}
|-
|{{v|12}}
|style="text-align: left;"|{{nbsp}}{{c multi|std::ios_base::in {{!}}|    std::ios_base::out}}
|-
|{{v|13}}
|rowspan=2|{{c|rhs}}&lt;br&gt;(copy constructed)
|{{c|std::move(rhs).str()}}
|rowspan=2|{{c|rhs.mode}}
|-
|{{v|14}}
|{{nbsp}}{{c|{std::move(rhs).str(), a}&lt;!----&gt;}}{{nbsp}}
|}

@1,2@ Overload {{rev inl|until=c++11|{{v|1}}}}{{rev inl|since=c++11|{{v|2}}}} is the default constructor. It is implementation-defined whether the sequence pointers ({{lc|eback()}}, {{lc|gptr()}}, {{lc|egptr()}}, {{lc|pbase()}}, {{lc|pptr()}}, {{lc|epptr()}}) are initialized to null pointers.&lt;!-- LWG 2995 --&gt;

@5,6@ When the construction is complete, {{c|str.empty()}} is {{c|true}}.

@7@ {{cpp/enable if|{{c|std::is_same_v&lt;SAlloc, Allocator&gt;}} is {{c|false}}}}.

@10-12@ {{cpp/string/sv hack|it is used as above in the table|plural=yes|checkptr=no}}

@13,14@ Overload {{v|13}} is the move constructor. It is implementation-defined whether the six sequence pointers in {{c|*this}} obtain the values which {{c|rhs}} had.
@@ When the construction is complete, {{c|rhs}} is empty but usable, and
* Let {{c|rhs_p}} refer to the state of {{c|rhs}} just prior to this construction, the following expressions will evaluate to {{c|true}}:
:* {{c|1=str() == rhs_p.str()}}
:* {{c|1=getloc() == rhs_p.getloc()}}
:* {{c|1=gptr() - eback() == rhs_p.gptr() - rhs_p.eback()}}
:* {{c|1=egptr() - eback() == rhs_p.egptr() - rhs_p.eback()}}
:* {{c|1=pptr() - pbase() == rhs_p.pptr() - rhs_p.pbase()}}
:* {{c|1=epptr() - pbase() == rhs_p.epptr() - rhs_p.pbase()}}
* Let {{c|rhs_a}} refer to the state of {{c|rhs}} just after this construction, the following expressions will evaluate to {{c|true}}:
:* {{c|1=!eback() {{!!}} eback() != rhs_a.eback()}}
:* {{c|1=!gptr() {{!!}} gptr() != rhs_a.gptr()}}
:* {{c|1=!egptr() {{!!}} egptr() != rhs_a.egptr()}}
:* {{c|1=!pbase() {{!!}} pbase() != rhs_a.pbase()}}
:* {{c|1=!pptr() {{!!}} pptr() != rhs_a.pptr()}}
:* {{c|1=!epptr() {{!!}} epptr() != rhs_a.epptr()}}

@15@ The copy constructor is deleted; {{tt|std::basic_stringbuf}} is not {{named req|CopyConstructible}}.

===Parameters===
{{par begin}}
{{par|s|a {{lc|std::basic_string}} used to initialize the buffer}}
{{par|t|an object (convertible to {{lc|std::basic_string_view}}) used to initialize the buffer}}
{{par|a|another allocator used to construct the internal {{lc|std::basic_string}}}}
{{par|rhs|another {{tt|basic_stringbuf}}}}
{{par|which|specifies stream open mode. It is bitmask type, the following constants are defined: 
{{cpp/io/ios_base/openmode consts}}}}
{{par end}}

===Notes===
Typically called by the constructor of {{lc|std::basic_stringstream}}.

The level of support for the open modes other than {{lc|std::ios_base::in}} and {{lc|std::ios_base::out}} varies among implementations. C++11 explicitly specifies the support for {{lc|std::ios_base::ate}} in {{lc|str()}} and in this constructor, but {{lc|std::ios_base::app}}, {{lc|std::ios_base::trunc}}, and {{lc|std::ios_base::binary}} have different effects on different implementations.

{{ftm begin|std=yes}}
{{ftm|std=C++26|value=202306L|__cpp_lib_sstream_from_string_view|Interfacing string streams with {{lc|std::string_view}}}}
{{ftm end}}

===Example===
{{example
|Demonstrates calling the constructor of {{tt|std::basic_stringbuf}} directly:
|code=
#include &lt;iostream&gt;
#include &lt;sstream&gt;

int main()
{
    // default constructor (mode = in {{!}} out)
    std::stringbuf buf1;
    buf1.sputc('1');
    std::cout &lt;&lt; &amp;buf1 &lt;&lt; '\n';
    
    // string constructor in at-end mode (C++11)
    std::stringbuf buf2("test", std::ios_base::in
                              {{!}} std::ios_base::out
                              {{!}} std::ios_base::ate);
    buf2.sputc('1');
    std::cout &lt;&lt; &amp;buf2 &lt;&lt; '\n';
    
    // append mode test (results differ among compilers)
    std::stringbuf buf3("test", std::ios_base::in
                              {{!}} std::ios_base::out
                              {{!}} std::ios_base::app);
    buf3.sputc('1');
    buf3.pubseekpos(1);
    buf3.sputc('2');
    std::cout &lt;&lt; &amp;buf3 &lt;&lt; '\n';
}
|output=
1
test1
est12 (Sun Studio) 2st1 (GCC)
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=432|std=C++98|before=1. overload {{v|1}} allocated no array object&lt;br&gt;2. overload {{v|3}} did not specify how the input&lt;br&gt;{{nbsp|4}}and output sequences are initialized|after=1. removed the limitation&lt;!-- 'requirements' is not used here because it is not normative --&gt;&lt;br&gt;2. specified}}
{{dr list item|wg=lwg|dr=562|std=C++98|before=overload {{v|3}} set {{lc|epptr()}} to point one past the last underlying&lt;br&gt;character if {{c|1=bool(which &amp; std::ios_base::out) == true}}|after={{lc|epptr()}} can be set&lt;br&gt;beyond that position}}
{{dr list item|paper=P0935R0|std=C++11|before=the default constructor was explicit|after=made implicit}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/basic_stringstream/dsc constructor|basic_stringstream}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}