{{cpp/title|scanf|fscanf|sscanf}}
{{cpp/io/c/navbar}}
{{dcl begin}}
{{dcl header|cstdio}}
{{dcl|num=1|
int scanf( const char* format, ... );
}}
{{dcl|num=2|
int fscanf( std::FILE* stream, const char* format, ... );
}}
{{dcl|num=3|
int sscanf( const char* buffer, const char* format, ... );
}}
{{dcl end}}

Reads data from a variety of sources, interprets it according to {{c|format}} and stores the results into given locations.

@1@ Reads the data from {{lc|stdin}}.
@2@ Reads the data from file stream {{c|stream}}.
@3@ Reads the data from null-terminated character string {{c|buffer}}.

===Parameters===
{{par begin}}
{{par|stream|input file stream to read from}}
{{par|buffer|pointer to a null-terminated character string to read from}}
{{par|format|pointer to a null-terminated character string specifying how to read the input}}
{{par|...|receiving arguments}}
{{par end}}

{{cpp/io/c/scanf format}}

===Return value===
Number of receiving arguments successfully assigned (which may be zero in case a matching failure occurred before the first receiving argument was assigned), or {{lc|EOF}} if input failure occurs before the first receiving argument was assigned.

===Complexity===
Not guaranteed. Notably, some implementations of {{tt|std::sscanf}} are {{math|O(N)}}, where {{c|1=N = std::strlen(buffer)}} [https://sourceware.org/bugzilla/show_bug.cgi?id=17577]. For performant string parsing, see {{tt|[[cpp/utility/from_chars|std::from_chars]]}}.

===Notes===
Because most conversion specifiers first consume all consecutive whitespace, code such as 
{{source|1=
std::scanf("%d", &amp;a);
std::scanf("%d", &amp;b);
}}
will read two integers that are entered on different lines (second {{c|%d}} will consume the newline left over by the first) or on the same line, separated by spaces or tabs (second {{c|%d}} will consume the spaces or tabs).

The conversion specifiers that do not consume leading whitespace, such as {{c|%c}}, can be made to do so by using a whitespace character in the format string: {{source|1=
std::scanf("%d", &amp;a);
std::scanf(" %c", &amp;c); // ignore the endline after %d, then read a char
}}

Note that some implementations of {{tt|std::sscanf}} involve a call to {{lc|std::strlen}}, which makes their runtime linear on the length of the entire string. This means that if {{tt|std::sscanf}} is called in a loop to repeatedly parse values from the front of a string, your code might run in quadratic time ([https://nee.lv/2021/02/28/How-I-cut-GTA-Online-loading-times-by-70/#Problem-one-It%E2%80%99s%E2%80%A6-strlen example]).

===Example===
{{example
|code=
#include &lt;clocale&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;

int main()
{
    int i, j;
    float x, y;
    char str1[10], str2[4];
    wchar_t warr[2];
    std::setlocale(LC_ALL, "en_US.utf8");

    char input[] = "25 54.32E-1 Thompson 56789 0123 56ß水";
    // parse as follows:
    // %d: an integer 
    // %f: a floating-point value
    // %9s: a string of at most 9 non-whitespace characters
    // %2d: two-digit integer (digits 5 and 6)
    // %f: a floating-point value (digits 7, 8, 9)
    // %*d an integer which isn't stored anywhere
    // ' ': all consecutive whitespace
    // %3[0-9]: a string of at most 3 digits (digits 5 and 6)
    // %2lc: two wide characters, using multibyte to wide conversion
    const int ret = std::sscanf(input, "%d%f%9s%2d%f%*d %3[0-9]%2lc",
                                &amp;i, &amp;x, str1, &amp;j, &amp;y, str2, warr);

    std::cout &lt;&lt; "Converted " &lt;&lt; ret &lt;&lt; " fields:\n"
                 "i = " &lt;&lt; i &lt;&lt; "\n"
                 "x = " &lt;&lt; x &lt;&lt; "\n"
                 "str1 = " &lt;&lt; str1 &lt;&lt; "\n"
                 "j = " &lt;&lt; j &lt;&lt; "\n"
                 "y = " &lt;&lt; y &lt;&lt; "\n"
                 "str2 = " &lt;&lt; str2 &lt;&lt; std::hex &lt;&lt; "\n"
                 "warr[0] = U+" &lt;&lt; (int)warr[0] &lt;&lt; "\n"
                 "warr[1] = U+" &lt;&lt; (int)warr[1] &lt;&lt; '\n';
}
|output=
Converted 7 fields:
i = 25
x = 5.432
str1 = Thompson
j = 56
y = 789
str2 = 56
warr[0] = U+df
warr[1] = U+6c34
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/c/dsc vfscanf}}
{{dsc inc|cpp/io/c/dsc fgets}}
{{dsc inc|cpp/io/c/dsc fprintf}}
{{dsc inc|cpp/utility/dsc from_chars}} 
{{dsc see c|c/io/fscanf|scanf|fscanf|sscanf}}
{{dsc end}}

{{langlinks|cs|de|es|fr|it|ja|pt|ru|zh}}