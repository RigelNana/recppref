{{cpp/title|fgets}}
{{cpp/io/c/navbar}}
{{ddcl|header=cstdio|
char* fgets( char* str, int count, std::FILE* stream );
}}

Reads at most {{c|count - 1}} characters from the given file stream and stores them in the character array pointed to by {{c|str}}. Parsing stops if a newline character is found, in which case {{c|str}} will contain that newline character, or if end-of-file occurs. If bytes are read and no errors occur, writes a null character at the position immediately after the last character written to {{c|str}}.

===Parameters===
{{par begin}}
{{par|str|pointer to an element of a char array}}
{{par|count|maximum number of characters to write (typically the length of {{c|str}})}}
{{par|stream|file stream to read the data from}}
{{par end}}

===Return value===
{{c|str}} on success, null pointer on failure.

If the end-of-file condition is encountered, sets the ''eof'' indicator on {{c|stream}} (see {{lc|std::feof()}}). This is only a failure if it causes no bytes to be read, in which case a null pointer is returned and the contents of the array pointed to by {{c|str}} are not altered (i.e. the first byte is not overwritten with a null character).

If the failure has been caused by some other error, sets the ''error'' indicator (see {{lc|std::ferror()}}) on {{c|stream}}. The contents of the array pointed to by {{c|str}} are indeterminate (it may not even be null-terminated).

===Notes===
[https://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html POSIX additionally requires] that {{tt|fgets}} sets {{lc|errno}} if it encounters a failure other than the end-of-file condition.

Although the standard specification is [https://stackoverflow.com/questions/23388620 unclear] in the cases where {{c|1=count &lt;= 1}}, common implementations do
* if {{c|count &lt; 1}}, do nothing, report error,
* if {{c|1=count == 1}},
:* some implementations do nothing, report error,
:* others read nothing, store zero in {{c|str[0]}}, report success.

===Example===
{{example
|code=
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;span&gt;

void dump(std::span&lt;const char&gt; buf, std::size_t offset)
{
    std::cout &lt;&lt; std::dec;
    for (char ch : buf)
        std::cout &lt;&lt; (ch &gt;= ' ' ? ch : '.'), offset--;
    std::cout &lt;&lt; std::string(offset, ' ') &lt;&lt; std::hex
              &lt;&lt; std::setfill('0') &lt;&lt; std::uppercase;
    for (unsigned ch : buf)
        std::cout &lt;&lt; std::setw(2) &lt;&lt; ch &lt;&lt; ' ';
    std::cout &lt;&lt; std::dec &lt;&lt; '\n';
}

int main()
{
    std::FILE* tmpf = std::tmpfile();
    std::fputs("Alan Turing\n", tmpf);
    std::fputs("John von Neumann\n", tmpf);
    std::fputs("Alonzo Church\n", tmpf);

    std::rewind(tmpf);
    for (char buf[8]; std::fgets(buf, sizeof buf, tmpf) != nullptr;)
        dump(buf, 10);
}
|output=
Alan Tu.  41 6C 61 6E 20 54 75 00 
ring..u.  72 69 6E 67 0A 00 75 00 
John vo.  4A 6F 68 6E 20 76 6F 00 
n Neuma.  6E 20 4E 65 75 6D 61 00 
nn..uma.  6E 6E 0A 00 75 6D 61 00 
Alonzo .  41 6C 6F 6E 7A 6F 20 00 
Church..  43 68 75 72 63 68 0A 00
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/c/dsc fscanf}}
{{dsc inc|cpp/io/c/dsc gets}}
{{dsc inc|cpp/io/c/dsc fputs}}
{{dsc see c|c/io/fgets}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}