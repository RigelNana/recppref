{{cpp/title|ungetc}}
{{cpp/io/c/navbar}}
{{ddcl|header=cstdio|
int ungetc( int ch, std::FILE *stream );
}}

If {{tt|ch}} does not equal {{lc|EOF}}, pushes the character {{tt|ch}} (reinterpreted as {{c|unsigned char}}) into the input buffer associated with the stream {{tt|stream}} in such a manner than subsequent read operation from {{tt|stream}} will retrieve that character. The external device associated with the stream is not modified.

Stream repositioning operations {{lc|std::fseek}}, {{lc|std::fsetpos}}, and {{lc|std::rewind}} discard the effects of {{tt|ungetc}}.

If {{tt|ungetc}} is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful {{tt|ungetc}} were performed, read operations retrieve the pushed-back characters in reverse order of {{tt|ungetc}}

If {{tt|ch}} equals {{lc|EOF}}, the operation fails and the stream is not affected.

A successful call to {{tt|ungetc}} clears the end of file status flag {{lc|std::feof}}.

A successful call to {{tt|ungetc}} on a binary stream decrements the stream position indicator by one (the behavior is indeterminate if the stream position indicator was zero).

A successful call to {{tt|ungetc}} on a text stream modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back characters are retrieved with a read operation, the stream position indicator is equal to its value before {{tt|ungetc}}.

===Parameters===
{{par begin}}
{{par|ch|character to be pushed into the input stream buffer }}
{{par|stream|file stream to put the character back to}}
{{par end}}

===Return value===
On success {{tt|ch}} is returned.

On failure {{lc|EOF}} is returned and the given stream remains unchanged.

===Notes===
The size of the pushback buffer varies in practice from 4k (Linux, MacOS) to as little as 4 (Solaris) or the guaranteed minimum 1 (HPUX, AIX).

The apparent size of the pushback buffer may be larger if the character that is pushed back equals the character existing at that location in the external character sequence (the implementation may simply decrement the read file position indicator and avoid maintaining a pushback buffer).

===Example===
{{example|demonstrates the use of {{tt|std::ungetc}} in its original purpose: implementing {{lc|std::scanf}}
|code=
#include &lt;cctype&gt;
#include &lt;cstdio&gt;

void demo_scanf(const char* fmt, std::FILE* s)
{
    while (*fmt != '\0') {
        if (*fmt == '%') {
            switch (*++fmt) {
                case 'u': {
                    int c{};
                    while (std::isspace(c=std::getc(s))) {}
                    unsigned int num{};
                    while (std::isdigit(c)) {
                        num = num*10 + c-'0';
                        c = std::getc(s);
                    }
                    std::printf("%%u scanned %u\n", num);
                    std::ungetc(c, s);
                    break;
                }
                case 'c': {
                    int c = std::getc(s);
                    std::printf("%%c scanned '%c'\n", c);
                    break;
                }
            }
        } else {
            ++fmt;
        }
    }
}

int main()
{
    if (std::FILE* f = std::fopen("input.txt", "w+")) {
        std::fputs("123x", f);
        std::rewind(f);
        demo_scanf("%u%c", f);
        std::fclose(f);
    }
}
|output=
%u scanned 123
%c scanned 'x'
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/c/dsc fgetc}}
{{dsc see c|c/io/ungetc}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}