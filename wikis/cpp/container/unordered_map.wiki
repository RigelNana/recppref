{{cpp/title|unordered_map}}
{{cpp/container/unordered_map/navbar}}
{{dcl begin}}
{{dcl header|unordered_map}}
{{dcl|num=1|since=c++11|1=
template&lt;
    class Key,
    class T,
    class Hash = std::hash&lt;Key&gt;,
    class KeyEqual = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;
&gt; class unordered_map;
}}
{{dcl|num=2|since=c++17|1=
namespace pmr {
    template&lt;
        class Key,
        class T,
        class Hash = std::hash&lt;Key&gt;,
        class KeyEqual = std::equal_to&lt;Key&gt;
    &gt; using unordered_map =
          std::unordered_map&lt;Key, T, Hash, KeyEqual,
              std::pmr::polymorphic_allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;;
}
}}
{{dcl end}}

{{tt|std::unordered_map}} is an associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity.

Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its key. Keys with the same hash code appear in the same bucket. This allows fast access to individual elements, since once the hash is computed, it refers to the exact bucket the element is placed into.

Two keys are considered ''equivalent'' if the map's key equality predicate returns true when passed those keys. If two keys are equivalent, the hash function must return the same value for both keys. 

{{tt|std::unordered_map}} meets the requirements of {{named req|Container}}, {{named req|AllocatorAwareContainer}}, {{named req|UnorderedAssociativeContainer}}.

===Iterator invalidation===
{|class="dsctable" style="font-size:1.0em"
!Operations
!Invalidated
|-
|All read only operations, {{lc|swap}}, {{lc|std::swap}}
|Never
|-
|{{lc|clear}}, {{lc|rehash}}, {{lc|reserve}}, {{lc|1=operator=}}
|Always
|-
|{{lc|insert}}, {{lc|emplace}}, {{lc|emplace_hint}}, {{lc|operator[]}}
|Only if causes rehash
|-
|{{lc|erase}}
|Only to the element erased
|}

====Notes====
* The swap functions do not invalidate any of the iterators inside the container, but they do invalidate the iterator marking the end of the swap region.

* References and pointers to either key or data stored in the container are only invalidated by erasing that element, even when the corresponding iterator is invalidated.

===Template parameters===
{{todo|Add descriptions of the template parameters.}}

===Member types===
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc inc|cpp/container/dsc key_type|unordered_map}}
{{dsc inc|cpp/container/dsc mapped_type|unordered_map}}
{{dsc inc|cpp/container/dsc value_type|unordered_map}}
{{dsc inc|cpp/container/dsc size_type|unordered_map}}
{{dsc inc|cpp/container/dsc difference_type|unordered_map}}
{{dsc inc|cpp/container/dsc hasher|unordered_map}}
{{dsc inc|cpp/container/dsc key_equal|unordered_map}}
{{dsc inc|cpp/container/dsc allocator_type|unordered_map}}
{{dsc inc|cpp/container/dsc reference|unordered_map}}
{{dsc inc|cpp/container/dsc const_reference|unordered_map}}
{{dsc inc|cpp/container/dsc pointer|unordered_map}}
{{dsc inc|cpp/container/dsc const_pointer|unordered_map}}
{{dsc inc|cpp/container/dsc iterator|unordered_map}}
{{dsc inc|cpp/container/dsc const_iterator|unordered_map}}
{{dsc inc|cpp/container/dsc local_iterator|unordered_map}}
{{dsc inc|cpp/container/dsc const_local_iterator|unordered_map}}
{{dsc inc|cpp/container/dsc node_type|unordered_map}}
{{dsc inc|cpp/container/dsc insert_return_type|unordered_map}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/container/dsc constructor|unordered_map}}
{{dsc inc|cpp/container/dsc destructor|unordered_map}}
{{dsc inc|cpp/container/dsc operator{{=}}|unordered_map}}
{{dsc inc|cpp/container/dsc get_allocator|unordered_map}}

{{dsc h2|Iterators}}
{{dsc inc|cpp/container/dsc begin|unordered_map}}
{{dsc inc|cpp/container/dsc end|unordered_map}}

{{dsc h2|Capacity}}
{{dsc inc|cpp/container/dsc empty|unordered_map}}
{{dsc inc|cpp/container/dsc size|unordered_map}}
{{dsc inc|cpp/container/dsc max_size|unordered_map}}

{{dsc h2|Modifiers}}
{{dsc inc|cpp/container/dsc clear|unordered_map}}
{{dsc inc|cpp/container/dsc insert|unordered_map}}
{{dsc inc|cpp/container/dsc insert_range|unordered_map}}
{{dsc inc|cpp/container/dsc insert_or_assign|unordered_map}}
{{dsc inc|cpp/container/dsc emplace|unordered_map}}
{{dsc inc|cpp/container/dsc emplace_hint|unordered_map}}
{{dsc inc|cpp/container/dsc try_emplace|unordered_map}}
{{dsc inc|cpp/container/dsc erase|unordered_map}}
{{dsc inc|cpp/container/dsc swap|unordered_map}}
{{dsc inc|cpp/container/dsc extract|unordered_map}}
{{dsc inc|cpp/container/dsc merge|unordered_map}}

{{dsc h2|Lookup}}
{{dsc inc|cpp/container/dsc at|unordered_map}}
{{dsc inc|cpp/container/dsc operator_at|unordered_map}}
{{dsc inc|cpp/container/dsc count|unordered_map}}
{{dsc inc|cpp/container/dsc find|unordered_map}}
{{dsc inc|cpp/container/dsc contains|unordered_map}}
{{dsc inc|cpp/container/dsc equal_range|unordered_map}}

{{dsc h2|Bucket interface}}
{{dsc inc|cpp/container/dsc begin(int)|unordered_map}}
{{dsc inc|cpp/container/dsc end(int)|unordered_map}}
{{dsc inc|cpp/container/dsc bucket_count|unordered_map}}
{{dsc inc|cpp/container/dsc max_bucket_count|unordered_map}}
{{dsc inc|cpp/container/dsc bucket_size|unordered_map}}
{{dsc inc|cpp/container/dsc bucket|unordered_map}}

{{dsc h2|Hash policy}}
{{dsc inc|cpp/container/dsc load_factor|unordered_map}}
{{dsc inc|cpp/container/dsc max_load_factor|unordered_map}}
{{dsc inc|cpp/container/dsc rehash|unordered_map}}
{{dsc inc|cpp/container/dsc reserve|unordered_map}}

{{dsc h2|Observers}}
{{dsc inc|cpp/container/dsc hash_function|unordered_map}}
{{dsc inc|cpp/container/dsc key_eq|unordered_map}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator_cmp_unord|unordered_map}}
{{dsc inc|cpp/container/dsc swap2|unordered_map}}
{{dsc inc|cpp/container/dsc erase_if|unordered_map}}
{{dsc end}}

{{rrev|since=c++17|
==={{rl|deduction guides|Deduction guides}}===
}}

===Notes===
{{ftm begin|std=1|comment=1}}
{{ftm|__cpp_lib_containers_ranges|value=202202L|std=C++23|Ranges construction and insertion for containers}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

int main()
{
    // Create an unordered_map of three strings (that map to strings)
    std::unordered_map&lt;std::string, std::string&gt; u =
    {
        {"RED", "#FF0000"},
        {"GREEN", "#00FF00"},
        {"BLUE", "#0000FF"}
    };
    
    // Helper lambda function to print key-value pairs
    auto print_key_value = [](const auto&amp; key, const auto&amp; value)
    {
        std::cout &lt;&lt; "Key:[" &lt;&lt; key &lt;&lt; "] Value:[" &lt;&lt; value &lt;&lt; "]\n";
    };
    
    std::cout &lt;&lt; "Iterate and print key-value pairs of unordered_map, being\n"
                 "explicit with their types:\n";
    for (const std::pair&lt;const std::string, std::string&gt;&amp; n : u)
        print_key_value(n.first, n.second);
    
    std::cout &lt;&lt; "\nIterate and print key-value pairs using C++17 structured binding:\n";
    for (const auto&amp; [key, value] : u)
        print_key_value(key, value);
    
    // Add two new entries to the unordered_map
    u["BLACK"] = "#000000";
    u["WHITE"] = "#FFFFFF";
    
    std::cout &lt;&lt; "\nOutput values by key:\n"
                 "The HEX of color RED is:[" &lt;&lt; u["RED"] &lt;&lt; "]\n"
                 "The HEX of color BLACK is:[" &lt;&lt; u["BLACK"] &lt;&lt; "]\n\n";
    
    std::cout &lt;&lt; "Use operator[] with non-existent key to insert a new key-value pair:\n";
    print_key_value("new_key", u["new_key"]);
    
    std::cout &lt;&lt; "\nIterate and print key-value pairs, using `auto`;\n"
                 "new_key is now one of the keys in the map:\n";
    for (const auto&amp; n : u)
        print_key_value(n.first, n.second);
}
|p=true&lt;!--the order of elements is not specified--&gt;
|output=
Iterate and print key-value pairs of unordered_map, being
explicit with their types:
Key:[BLUE] Value:[#0000FF]
Key:[GREEN] Value:[#00FF00]
Key:[RED] Value:[#FF0000]

Iterate and print key-value pairs using C++17 structured binding:
Key:[BLUE] Value:[#0000FF]
Key:[GREEN] Value:[#00FF00]
Key:[RED] Value:[#FF0000]

Output values by key:
The HEX of color RED is:[#FF0000]
The HEX of color BLACK is:[#000000]

Use operator[] with non-existent key to insert a new key-value pair:
Key:[new_key] Value:[]

Iterate and print key-value pairs, using `auto`;
new_key is now one of the keys in the map:
Key:[new_key] Value:[]
Key:[WHITE] Value:[#FFFFFF]
Key:[BLACK] Value:[#000000]
Key:[BLUE] Value:[#0000FF]
Key:[GREEN] Value:[#00FF00]
Key:[RED] Value:[#FF0000]
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2050|std=C++11|before=the definitions of {{tt|reference}}, {{tt|const_reference}}, {{tt|pointer}}&lt;br&gt;and {{tt|const_pointer}} were based on {{tt|allocator_type}}|after=based on {{tt|value_type}} and&lt;br&gt;{{lc|std::allocator_traits}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc unordered_multimap}}
{{dsc inc|cpp/container/dsc map}}
{{dsc inc|cpp/container/dsc flat_map}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|ko|pt|ru|zh}}