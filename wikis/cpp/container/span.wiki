{{cpp/title|span}}
{{cpp/container/span/navbar}}
{{dcl begin}}
{{dcl header|span}}
{{dcl|since=c++20|1=
template&lt;
    class T,
    std::size_t Extent = std::dynamic_extent
&gt; class span;
}}
{{dcl end}}

The class template {{tt|span}} describes an object that can refer to a contiguous sequence of objects with the first element of the sequence at position zero. A {{tt|span}} can either have a ''static'' extent, in which case the number of elements in the sequence is known at compile-time and encoded in the type, or a ''dynamic'' extent.

For a {{tt|span}} {{c|s}}, pointers, iterators, and references to elements of {{c|s}} are invalidated when an operation invalidates a pointer in the range {{range|s.data()|s.data() + s.size()}}.

{{rrev|since=c++23|
Every specialization of {{tt|std::span}} is a {{named req|TriviallyCopyable}} type.
}}

A typical implementation holds a pointer to {{tt|T}}, if the extent is dynamic, the implementation also holds a size.

===Template parameters===
{{par begin}}
{{par|T|element type; must be a complete object type that is not an abstract class type}}
{{par|Extent|the number of elements in the sequence, or {{tt|std::dynamic_extent}} if dynamic}}
{{par end}}

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc|{{tt|element_type}}|{{tt|T}}}}
{{dsc|{{tt|value_type}}|{{c/core|std::remove_cv_t&lt;T&gt;}}}}
{{dsc|{{tt|size_type}}|{{lc|std::size_t}}}}
{{dsc|{{tt|difference_type}}|{{lc|std::ptrdiff_t}}}}
{{dsc|{{tt|pointer}}|{{c/core|T*}}}}
{{dsc|{{tt|const_pointer}}|{{c/core|const T*}}}}
{{dsc|{{tt|reference}}|{{c/core|T&amp;}}}}
{{dsc|{{tt|const_reference}}|{{c/core|const T&amp;}}}}
{{dsc|{{tt|iterator}}|implementation-defined {{named req|RandomAccessIterator}}, {{named req|ConstexprIterator}}, and {{lconcept|contiguous_iterator}} whose {{tt|value_type}} is {{tt|value_type}}}}
{{dsc|{{tt|const_iterator}} {{mark since c++23}}|{{c/core|std::const_iterator&lt;iterator&gt;}}}}
{{dsc|{{tt|reverse_iterator}}|{{c/core|std::reverse_iterator&lt;iterator&gt;}}}}
{{dsc|{{tt|const_reverse_iterator}} {{mark since c++23}}|{{c/core|std::const_iterator&lt;reverse_iterator&gt;}}}}
{{dsc end}}

{{petty|Note: {{tt|iterator}} is a mutable iterator if {{tt|T}} is not const-qualified.}}

All requirements on the iterator types of a {{named req|Container}} apply to the {{tt|iterator}} type of {{tt|span}} as well.

===Member constant===
{{dsc begin}}
{{dsc hitem|Name|Value}}
{{dsc mem sconst|nolink=true|{{dsc small|{{c/core|constexpr std::size_t}}}} extent|{{c|Extent}}}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/container/span/dsc constructor}}
{{dsc inc|cpp/container/span/dsc operator{{=}}}}
{{dsc mem dtor|nolink=true|notes={{mark implicit}}|destructs a {{tt|span}}}}

{{dsc h2|Iterators}}
{{dsc inc|cpp/container/dsc begin|span}}
{{dsc inc|cpp/container/dsc end|span}}
{{dsc inc|cpp/container/dsc rbegin|span}}
{{dsc inc|cpp/container/dsc rend|span}}

{{dsc h2|Element access}}
{{dsc inc|cpp/container/dsc front|span}}
{{dsc inc|cpp/container/dsc back|span}}
{{dsc inc|cpp/container/dsc at|span}}
{{dsc inc|cpp/container/dsc operator_at|span}}
{{dsc inc|cpp/container/dsc data|span}}

{{dsc h2|Observers}}
{{dsc inc|cpp/container/dsc size|span}}
{{dsc inc|cpp/container/span/dsc size_bytes}}
{{dsc inc|cpp/container/span/dsc empty}}

{{dsc h2|Subviews}}
{{dsc inc|cpp/container/span/dsc first}}
{{dsc inc|cpp/container/span/dsc last}}
{{dsc inc|cpp/container/span/dsc subspan}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/container/span/dsc as_bytes}}
{{dsc end}}

===Non-member constant===
{{dsc begin}}
{{dsc inc|cpp/container/span/dsc dynamic_extent}}
{{dsc end}}

===Helper templates===
{{ddcl|since=c++20|1=
template&lt; class T, std::size_t Extent &gt;
constexpr bool ranges::enable_borrowed_range&lt;std::span&lt;T, Extent&gt;&gt; = true;
}}
This specialization of {{lc|ranges::enable_borrowed_range}} makes {{tt|span}} satisfy {{lconcept|borrowed_range}}.

{{ddcl|since=c++20|1=
template&lt; class T, std::size_t Extent &gt;
constexpr bool ranges::enable_view&lt;std::span&lt;T, Extent&gt;&gt; = true;
}}
This specialization of {{lc|ranges::enable_view}} makes {{tt|span}} satisfy {{lconcept|view}}.

==={{rl|deduction guides|Deduction guides}}===

===Notes===
Specializations of {{tt|std::span}} are already trivially copyable types in all existing implementations, even before the formal requirement introduced in C++23.

{{ftm begin|sort=yes}}
{{ftm|__cpp_lib_span|std=C++20|value=202002L|{{tt|std::span}}|rowspan="2"}}
{{ftm|-|std=C++26|value=202311L|{{lc|std::span::at}}}}
{{ftm|__cpp_lib_span_initializer_list|value=202311L|std=C++26|Constructing {{tt|std::span}} from a {{lc|std::initializer_list}}}}
{{ftm end}}

===Example===
{{example
|The example uses {{tt|std::span}} to implement some algorithms on contiguous ranges.
|code=
#include &lt;algorithm&gt;
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;span&gt;

template&lt;class T, std::size_t N&gt;
[[nodiscard]]
constexpr auto slide(std::span&lt;T, N&gt; s, std::size_t offset, std::size_t width)
{
    return s.subspan(offset, offset + width &lt;= s.size() ? width : 0U);
}

template&lt;class T, std::size_t N, std::size_t M&gt;
constexpr bool starts_with(std::span&lt;T, N&gt; data, std::span&lt;T, M&gt; prefix)
{
    return data.size() &gt;= prefix.size()
        &amp;&amp; std::equal(prefix.begin(), prefix.end(), data.begin());
}

template&lt;class T, std::size_t N, std::size_t M&gt;
constexpr bool ends_with(std::span&lt;T, N&gt; data, std::span&lt;T, M&gt; suffix)
{
    return data.size() &gt;= suffix.size()
        &amp;&amp; std::equal(data.end() - suffix.size(), data.end(),
                      suffix.end() - suffix.size());
}

template&lt;class T, std::size_t N, std::size_t M&gt;
constexpr bool contains(std::span&lt;T, N&gt; span, std::span&lt;T, M&gt; sub)
{
    return std::ranges::search(span, sub).begin() != span.end();
}

void println(const auto&amp; seq)
{
    for (const auto&amp; elem : seq)
        std::cout &lt;&lt; elem &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    constexpr int a[]{0, 1, 2, 3, 4, 5, 6, 7, 8};
    constexpr int b[]{8, 7, 6};
    constexpr static std::size_t width{6};

    for (std::size_t offset{}; ; ++offset)
        if (auto s = slide(std::span{a}, offset, width); !s.empty())
            println(s);
        else
            break;

    static_assert(""
        &amp;&amp; starts_with(std::span{a}, std::span{a, 4})
        &amp;&amp; starts_with(std::span{a + 1, 4}, std::span{a + 1, 3})
        &amp;&amp; !starts_with(std::span{a}, std::span{b})
        &amp;&amp; !starts_with(std::span{a, 8}, std::span{a + 1, 3})
        &amp;&amp; ends_with(std::span{a}, std::span{a + 6, 3})
        &amp;&amp; !ends_with(std::span{a}, std::span{a + 6, 2})
        &amp;&amp; contains(std::span{a}, std::span{a + 1, 4})
        &amp;&amp; !contains(std::span{a, 8}, std::span{a, 9})
    );
}
|output=
0 1 2 3 4 5
1 2 3 4 5 6
2 3 4 5 6 7
3 4 5 6 7 8
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3203|std=C++20|before=it was unclear when the pointers, iterators, and&lt;br&gt;references to elements of {{tt|span}} are invalidated|after=made clear}}
{{dr list item|wg=lwg|dr=3903|std=C++20|before=the declaration of {{tt|span}}'s destructor was unnecessary|after=removed the declaration}}
{{dr list item|paper=P2325R3|std=C++20|before=a {{tt|span}} of non-zero static extents was not a {{tt|view}}|after=any {{tt|span}} is a {{tt|view}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc mdspan}}
{{dsc inc|cpp/ranges/dsc subrange}}
{{dsc inc|cpp/utility/dsc initializer_list}}
{{dsc inc|cpp/string/dsc basic_string_view}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}