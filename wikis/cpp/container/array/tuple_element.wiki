{{cpp/title|tuple_element{{small|&lt;std::array&gt;}}}}
{{cpp/container/array/navbar}}
{{dcl begin}}
{{dcl header|array}}
{{dcl|since=c++11|1=
template&lt; std::size_t I, class T, std::size_t N &gt;
struct tuple_element&lt; I, std::array&lt;T, N&gt; &gt;;
}}
{{dcl end}}

Provides compile-time indexed access to the type of the elements of the array using tuple-like interface.

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc|type|the type of elements of the array}}
{{dsc end}}

===Possible implementation===
{{eq fun
|1=
template&lt;std::size_t I, class T&gt;
struct tuple_element;

template&lt;std::size_t I, class T, std::size_t N&gt;
struct tuple_element&lt;I, std::array&lt;T,N&gt;&gt;
{
    using type = T;
};
}}

===Example===
{{example
|code=
#include &lt;array&gt;
#include &lt;tuple&gt;
#include &lt;type_traits&gt;

int main()
{
    // define array and get the type of the element at position 0
    std::array&lt;int, 10&gt; data{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    using T = std::tuple_element&lt;0, decltype(data)&gt;::type; // int
    static_assert(std::is_same_v&lt;T, int&gt;);

    const auto const_data = data;
    using CT = std::tuple_element&lt;0, decltype(const_data)&gt;::type; // const int

    // the result of tuple_element depends on the cv-qualification of the tuple-like type
    static_assert(!std::is_same_v&lt;T, CT&gt;);
    static_assert(std::is_same_v&lt;CT, const int&gt;);
}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc structured binding}}
{{dsc inc|cpp/utility/tuple/dsc tuple_element}}
{{dsc inc|cpp/utility/pair/dsc tuple_element}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}