{{cpp/title|deque}}
{{cpp/container/deque/navbar}}
{{dcl begin}}
{{dcl header|deque}}
{{dcl|num=1|1=
template&lt;
    class T,
    class Allocator = std::allocator&lt;T&gt;
&gt; class deque;
}}
{{dcl|num=2|since=c++17|1=
namespace pmr {
    template&lt; class T &gt;
    using deque = std::deque&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt;;
}
}}
{{dcl end}}

{{tt|std::deque}} (double-ended queue) is an indexed sequence container that allows fast insertion and deletion at both its beginning and its end. In addition, insertion and deletion at either end of a deque never invalidates pointers or references to the rest of the elements.

As opposed to {{lc|std::vector}}, the elements of a deque are not stored contiguously: typical implementations use a sequence of individually allocated fixed-size arrays, with additional bookkeeping, which means indexed access to deque must perform two pointer dereferences, compared to vector's indexed access which performs only one.

The storage of a deque is automatically expanded and contracted as needed. Expansion of a deque is cheaper than the expansion of a {{lc|std::vector}} because it does not involve copying of the existing elements to a new memory location. On the other hand, deques typically have large minimal memory cost; a deque holding just one element has to allocate its full internal array (e.g. 8 times the object size on 64-bit libstdc++; 16 times the object size or 4096 bytes, whichever is larger, on 64-bit libc++).

The complexity (efficiency) of common operations on deques is as follows:

* Random access - constant {{math|O(1)}}.
* Insertion or removal of elements at the end or beginning - constant {{math|O(1)}}.
* Insertion or removal of elements - linear {{math|O(n)}}.

{{tt|std::deque}} meets the requirements of {{named req|Container}}, {{named req|AllocatorAwareContainer}}, {{named req|SequenceContainer}} and {{named req|ReversibleContainer}}.

===Template parameters===
{{par begin}}
{{par inc|cpp/container/param list T|deque}}
{{par inc|cpp/container/param list Allocator|deque}}
{{par end}}

===Iterator invalidation===
{{todo|There are still a few inaccuracies in this section, refer to individual member function pages for more detail}}

{|class="dsctable" style="font-size:0.9em"
!Operations
!Invalidated
|-
|All read only operations.
|Never.
|-
|{{lc|swap}}, {{lc|std::swap}}
|The past-the-end iterator may be invalidated (implementation defined).
|-
|{{lc|shrink_to_fit}}, {{lc|clear}}, {{lc|insert}}, {{lc|emplace}}, {{lc|push_front}},&lt;br&gt;{{lc|push_back}}, {{lc|emplace_front}}, {{lc|emplace_back}}
|Always.
|-
|{{lc|erase}}
|If erasing at begin - only erased elements.&lt;br&gt;
If erasing at end - only erased elements and the past-the-end iterator.&lt;br&gt;
Otherwise - all iterators are invalidated.&lt;br&gt;&lt;br&gt;
{{rev inl|until=c++11|It is unspecified when the past-the-end iterator is invalidated.}}&lt;br&gt;&lt;br&gt;
{{rev inl|since=c++11|The past-the-end iterator is also invalidated unless the erased&lt;br&gt;
elements are at the beginning of the container and the last element is not erased.}}
|-
|{{lc|resize}}
|If the new size is smaller than the old one - only erased elements and the&lt;br&gt; past-the-end iterator.&lt;br&gt;
If the new size is bigger than the old one - all iterators are invalidated.&lt;br&gt;
Otherwise - none iterators are invalidated.
|-
|{{lc|pop_front}}, {{lc|pop_back}}
|To the element erased.&lt;br&gt;
The past-the-end iterator&lt;br&gt;
{{rev inl|until=c++11|may be invalidated (implementation defined)}}&lt;br&gt;
{{rev inl|since=c++11|is also invalidated.}}
|}

====Invalidation notes====
* When inserting at either end of the deque, references are not invalidated by {{lc|insert}} and {{lc|emplace}}.
* {{lc|push_front}}, {{lc|push_back}}, {{lc|emplace_front}} and {{lc|emplace_back}} do not invalidate any references to elements of the deque.
* When erasing at either end of the deque, references to non-erased elements are not invalidated by {{lc|erase}}, {{lc|pop_front}} and {{lc|pop_back}}.
* A call to {{lc|resize}} with a smaller size does not invalidate any references to non-erased elements.
* A call to {{lc|resize}} with a bigger size does not invalidate any references to elements of the deque.

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc inc|cpp/container/dsc value_type|deque}}
{{dsc inc|cpp/container/dsc allocator_type|deque}}
{{dsc inc|cpp/container/dsc size_type|deque}}
{{dsc inc|cpp/container/dsc difference_type|deque}}
{{dsc inc|cpp/container/dsc reference|deque}}
{{dsc inc|cpp/container/dsc const_reference|deque}}
{{dsc inc|cpp/container/dsc pointer|deque}}
{{dsc inc|cpp/container/dsc const_pointer|deque}}
{{dsc inc|cpp/container/dsc iterator|deque}}
{{dsc inc|cpp/container/dsc const_iterator|deque}}
{{dsc inc|cpp/container/dsc reverse_iterator|deque}}
{{dsc inc|cpp/container/dsc const_reverse_iterator|deque}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/container/dsc constructor|deque}}
{{dsc inc|cpp/container/dsc destructor|deque}}
{{dsc inc|cpp/container/dsc operator{{=}}|deque}}
{{dsc inc|cpp/container/dsc assign|deque}}
{{dsc inc|cpp/container/dsc assign_range|deque}}
{{dsc inc|cpp/container/dsc get_allocator|deque}}

{{dsc h2|Element access}}
{{dsc inc|cpp/container/dsc at|deque}}
{{dsc inc|cpp/container/dsc operator_at|deque}}
{{dsc inc|cpp/container/dsc front|deque}}
{{dsc inc|cpp/container/dsc back|deque}}

{{dsc h2|Iterators}}
{{dsc inc|cpp/container/dsc begin|deque}}
{{dsc inc|cpp/container/dsc end|deque}}
{{dsc inc|cpp/container/dsc rbegin|deque}}
{{dsc inc|cpp/container/dsc rend|deque}}

{{dsc h2|Capacity}}
{{dsc inc|cpp/container/dsc empty|deque}}
{{dsc inc|cpp/container/dsc size|deque}}
{{dsc inc|cpp/container/dsc max_size|deque}}
{{dsc inc|cpp/container/dsc shrink_to_fit|deque}}

{{dsc h2|Modifiers}}
{{dsc inc|cpp/container/dsc clear|deque}}
{{dsc inc|cpp/container/dsc insert|deque}}
{{dsc inc|cpp/container/dsc insert_range|deque}}
{{dsc inc|cpp/container/dsc emplace|deque}}
{{dsc inc|cpp/container/dsc erase|deque}}
{{dsc inc|cpp/container/dsc push_back|deque}}
{{dsc inc|cpp/container/dsc emplace_back|deque}}
{{dsc inc|cpp/container/dsc append_range|deque}}
{{dsc inc|cpp/container/dsc pop_back|deque}}
{{dsc inc|cpp/container/dsc push_front|deque}}
{{dsc inc|cpp/container/dsc emplace_front|deque}}
{{dsc inc|cpp/container/dsc prepend_range|deque}}
{{dsc inc|cpp/container/dsc pop_front|deque}}
{{dsc inc|cpp/container/dsc resize|deque}}
{{dsc inc|cpp/container/dsc swap|deque}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator_cmp|deque}}
{{dsc inc|cpp/container/dsc swap2|deque}}
{{dsc inc|cpp/container/dsc erase seq|deque}}
{{dsc end}}

{{rrev|since=c++17|
==={{rl|deduction guides|Deduction guides}}===
}}

===Notes===
{{ftm begin|std=1|comment=1}}
{{ftm|__cpp_lib_containers_ranges|value=202202L|std=C++23|Ranges construction and insertion for containers}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;deque&gt;
#include &lt;iostream&gt;

int main()
{
    // Create a deque containing integers
    std::deque&lt;int&gt; d = {7, 5, 16, 8};
    
    // Add an integer to the beginning and end of the deque
    d.push_front(13);
    d.push_back(25);
    
    // Iterate and print values of deque
    for (int n : d)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
13 7 5 16 8 25
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=230|std=C++98|before={{tt|T}} was not required to be {{named req|CopyConstructible}}&lt;br&gt;(an element of type {{tt|T}} might not be able to be constructed)|after={{tt|T}} is also required to&lt;br&gt;be {{named req|CopyConstructible}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc queue}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pl|pt|ru|zh}}