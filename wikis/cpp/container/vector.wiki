{{cpp/title|vector}}
{{cpp/container/vector/navbar}}
{{dcl begin}}
{{dcl header|vector}}
{{dcl|num=1|1=
template&lt;
    class T,
    class Allocator = std::allocator&lt;T&gt;
&gt; class vector;
}}
{{dcl|since=c++17|num=2|1=
namespace pmr {
    template&lt; class T &gt;
    using vector = std::vector&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt;;
}
}}
{{dcl end}}

@1@ {{tt|std::vector}} is a sequence container that encapsulates dynamic size arrays.
@2@ {{tt|std::pmr::vector}} is an alias template that uses a [[cpp/memory/polymorphic_allocator|polymorphic allocator]].

The elements are stored contiguously, which means that elements can be accessed not only through iterators, but also using offsets to regular pointers to elements. This means that a pointer to an element of a vector may be passed to any function that expects a pointer to an element of an array.

The storage of the vector is handled automatically, being expanded as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using {{lc|capacity()}} function. Extra memory can be returned to the system via a call to {{lc|shrink_to_fit()}}&lt;ref&gt;In libstdc++, {{tt|shrink_to_fit()}} is [https://gcc.gnu.org/onlinedocs/libstdc++/manual/strings.html#strings.string.shrink not available] in C++98 mode.&lt;/ref&gt;.

Reallocations are usually costly operations in terms of performance. The {{lc|reserve()}} function can be used to eliminate reallocations if the number of elements is known beforehand.

The complexity (efficiency) of common operations on vectors is as follows:

* Random access - constant {{math|ùìû(1)}}.
* Insertion or removal of elements at the end - amortized constant {{math|ùìû(1)}}.
* Insertion or removal of elements - linear in the distance to the end of the vector {{math|ùìû(n)}}.

{{tt|std::vector}} (for {{tt|T}} other than {{c/core|bool}}) meets the requirements of {{named req|Container}}{{rev inl|since=c++11|, {{named req|AllocatorAwareContainer}}}}, {{named req|SequenceContainer}}{{rev inl|since=c++17|, {{named req|ContiguousContainer}}}} and {{named req|ReversibleContainer}}.

{{rrev|since=c++20|
Member functions of {{tt|std::vector}} are {{c/core|constexpr}}: it is possible to create and use {{tt|std::vector}} objects in the evaluation of a constant expression.

However, {{tt|std::vector}} objects generally cannot be {{c/core|constexpr}}, because any dynamically allocated storage must be released in the same evaluation of constant expression.
}}

&lt;references/&gt;

===Template parameters===
{{par begin}}
{{par inc|cpp/container/param list T|vector}}
{{par inc|cpp/container/param list Allocator|vector}}
{{par end}}

===Specializations===
The standard library provides a specialization of {{tt|std::vector}} for the type {{c/core|bool}}, which may be optimized for space efficiency.
{{dsc begin}}
{{dsc inc|cpp/container/dsc vector bool}}
{{dsc end}}

===Iterator invalidation===
{|class="dsctable" style="font-size:0.9em"
!Operations
!Invalidated
|-
|All read only operations
|Never.
|-
|{{lc|swap}}, {{lc|std::swap}}
|{{lc|end()}}
|-
|{{lc|clear}}, {{lc|1=operator=}}, {{lc|assign}}
|Always.
|-
|{{lc|reserve}}, {{lc|shrink_to_fit}}
|If the vector changed capacity, all of them. If not, none.
|-
|{{lc|erase}}
|Erased elements and all elements after them (including {{lc|end()}}).
|-
|{{lc|push_back}}, {{lc|emplace_back}}
|If the vector changed capacity, all of them. If not, only {{lc|end()}}.
|-
|{{lc|insert}}, {{lc|emplace}}
|If the vector changed capacity, all of them.&lt;br&gt;If not, only those at or after the insertion point (including {{lc|end()}}).
|-
|{{lc|resize}}
|If the vector changed capacity, all of them. If not, only {{lc|end()}} and any elements erased.
|-
|{{lc|pop_back}}
|The element erased and {{lc|end()}}.
|}

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc inc|cpp/container/dsc value_type|vector}}
{{dsc inc|cpp/container/dsc allocator_type|vector}}
{{dsc inc|cpp/container/dsc size_type|vector}}
{{dsc inc|cpp/container/dsc difference_type|vector}}
{{dsc inc|cpp/container/dsc reference|vector}}
{{dsc inc|cpp/container/dsc const_reference|vector}}
{{dsc inc|cpp/container/dsc pointer|vector}}
{{dsc inc|cpp/container/dsc const_pointer|vector}}
{{dsc inc|cpp/container/dsc iterator|vector}}
{{dsc inc|cpp/container/dsc const_iterator|vector}}
{{dsc inc|cpp/container/dsc reverse_iterator|vector}}
{{dsc inc|cpp/container/dsc const_reverse_iterator|vector}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/container/dsc constructor|vector}}
{{dsc inc|cpp/container/dsc destructor|vector}}
{{dsc inc|cpp/container/dsc operator{{=}}|vector}}
{{dsc inc|cpp/container/dsc assign|vector}}
{{dsc inc|cpp/container/dsc assign_range|vector}}
{{dsc inc|cpp/container/dsc get_allocator|vector}}

{{dsc h2|Element access}}
{{dsc inc|cpp/container/dsc at|vector}}
{{dsc inc|cpp/container/dsc operator_at|vector}}
{{dsc inc|cpp/container/dsc front|vector}}
{{dsc inc|cpp/container/dsc back|vector}}
{{dsc inc|cpp/container/dsc data|vector}}

{{dsc h2|Iterators}}
{{dsc inc|cpp/container/dsc begin|vector}}
{{dsc inc|cpp/container/dsc end|vector}}
{{dsc inc|cpp/container/dsc rbegin|vector}}
{{dsc inc|cpp/container/dsc rend|vector}}

{{dsc h2|Capacity}}
{{dsc inc|cpp/container/dsc empty|vector}}
{{dsc inc|cpp/container/dsc size|vector}}
{{dsc inc|cpp/container/dsc max_size|vector}}
{{dsc inc|cpp/container/dsc reserve|vector}}
{{dsc inc|cpp/container/dsc capacity|vector}}
{{dsc inc|cpp/container/dsc shrink_to_fit|vector}}

{{dsc h2|Modifiers}}
{{dsc inc|cpp/container/dsc clear|vector}}
{{dsc inc|cpp/container/dsc insert|vector}}
{{dsc inc|cpp/container/dsc insert_range|vector}}
{{dsc inc|cpp/container/dsc emplace|vector}}
{{dsc inc|cpp/container/dsc erase|vector}}
{{dsc inc|cpp/container/dsc push_back|vector}}
{{dsc inc|cpp/container/dsc emplace_back|vector}}
{{dsc inc|cpp/container/dsc append_range|vector}}
{{dsc inc|cpp/container/dsc pop_back|vector}}
{{dsc inc|cpp/container/dsc resize|vector}}
{{dsc inc|cpp/container/dsc swap|vector}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator_cmp|vector}}
{{dsc inc|cpp/container/dsc swap2|vector}}
{{dsc inc|cpp/container/dsc erase seq|vector}}
{{dsc end}}

{{rrev|since=c++17|
==={{rl|deduction guides|Deduction guides}}===
}}

===Notes===
{{ftm begin|std=1|comment=1}}
{{ftm|__cpp_lib_containers_ranges|value=202202L|std=C++23|Ranges construction and insertion for containers}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    // Create a vector containing integers
    std::vector&lt;int&gt; v = {8, 4, 5, 9};
 
    // Add two more integers to vector
    v.push_back(6);
    v.push_back(9);
    
    // Overwrite element at position 2
    v[2] = -1;
 
    // Print out the vector
    for (int n : v)
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
8 4 -1 9 6 9
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=69|std=C++98|before=contiguity of the storage for elements of {{tt|vector}} was not required|after=required}}
{{dr list item|wg=lwg|dr=230|std=C++98|before={{tt|T}} was not required to be {{named req|CopyConstructible}}&lt;br&gt;(an element of type {{tt|T}} might not be able to be constructed)|after={{tt|T}} is also required to&lt;br&gt;be {{named req|CopyConstructible}}}}
{{dr list item|wg=lwg|dr=464|std=C++98|before=access to the underlying storage of an empty {{tt|vector}} resulted in UB|after={{tt|data}} function provided}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc inplace_vector}}
{{dsc inc|cpp/container/dsc array}}
{{dsc inc|cpp/container/dsc deque}}
{{dsc end}}

{{langlinks|cs|de|es|fr|it|ja|ko|pl|pt|ru|zh}}