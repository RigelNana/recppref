{{cpp/container/list/title|splice}}
{{cpp/container/list/navbar}}
{{dcl begin}}
{{dcl|num=1|
void splice( const_iterator pos, list&amp; other );
}}
{{dcl|num=2|since=c++11|
void splice( const_iterator pos, list&amp;&amp; other );
}}
{{dcl|num=3|
void splice( const_iterator pos, list&amp; other, const_iterator it );
}}
{{dcl|num=4|since=c++11|
void splice( const_iterator pos, list&amp;&amp; other, const_iterator it );
}}
{{dcl|num=5|
void splice( const_iterator pos, list&amp; other, 
             const_iterator first, const_iterator last);
}}
{{dcl|num=6|since=c++11|
void splice( const_iterator pos, list&amp;&amp; other, 
             const_iterator first, const_iterator last );
}}
{{dcl end}}

Transfers elements from one list to another.

No elements are copied or moved, only the internal pointers of the list nodes are re-pointed. No iterators or references become invalidated, the iterators to moved elements remain valid, but now refer into {{c|*this}}, not into {{c|other}}.

@1,2@ Transfers all elements from {{c|other}} into {{c|*this}}. The elements are inserted before the element pointed to by {{c|pos}}. The container {{c|other}} becomes empty after the operation.

@3,4@ Transfers the element pointed to by {{c|it}} from {{c|other}} into {{c|*this}}. The element is inserted before the element pointed to by {{c|pos}}.

@5,6@ Transfers the elements in the range {{range|first|last}} from {{c|other}} into {{c|*this}}. The elements are inserted before the element pointed to by {{c|pos}}.

The behavior is undefined if
* {{c|1=get_allocator() != other.get_allocator()}},
* for overloads {{v|1,2}}, {{c|*this}} and {{c|other}} refer to the same object,
* for overloads {{v|3,4}}, {{c|it}} is not a [[cpp/iterator#Dereferenceability and validity|dereferenceable iterator]] into {{c|other}}, or
* for overloads {{v|5,6}},
:* {{range|first|last}} is not a [[cpp/iterator#Ranges|valid range]] in {{c|other}}, or
:* {{c|pos}} is in {{range|first|last}}.

===Parameters===
{{par begin}}
{{par|pos|element before which the content will be inserted}}
{{par|other|another container to transfer the content from}}
{{par|it|the element to transfer from {{c|other}} to {{c|*this}}}}
{{par|first, last|the range of elements to transfer from {{c|other}} to {{c|*this}}}}
{{par end}} 

===Return value===
(none)

===Exceptions===
Throws nothing.

===Complexity===
@1-4@ Constant.

@5,6@ Constant if {{c|other}} refers to the same object as {{c|*this}}, otherwise linear in {{c|std::distance(first, last)}}.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;list&gt;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; ostr, const std::list&lt;int&gt;&amp; list)
{
    for (auto&amp; i : list)
        ostr &lt;&lt; ' ' &lt;&lt; i;
    
    return ostr;
}

int main ()
{
    std::list&lt;int&gt; list1{1, 2, 3, 4, 5};
    std::list&lt;int&gt; list2{10, 20, 30, 40, 50};
    
    auto it = list1.begin();
    std::advance(it, 2);
    
    list1.splice(it, list2);
    
    std::cout &lt;&lt; "list1:" &lt;&lt; list1 &lt;&lt; '\n';
    std::cout &lt;&lt; "list2:" &lt;&lt; list2 &lt;&lt; '\n';
    
    list2.splice(list2.begin(), list1, it, list1.end());
    
    std::cout &lt;&lt; "list1:" &lt;&lt; list1 &lt;&lt; '\n';
    std::cout &lt;&lt; "list2:" &lt;&lt; list2 &lt;&lt; '\n';
}
|output=
list1: 1 2 10 20 30 40 50 3 4 5
list2:
list1: 1 2 10 20 30 40 50
list2: 3 4 5
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=250|std=C++98|before=references and iterators to the moved&lt;br&gt;element(s) were all invalidated|after=they refer or point to the&lt;br&gt;same element(s) in {{c|*this}}}}
{{dr list item|paper=N2525|std=C++98|before=O(1) splicing could not be guaranteed if&lt;br&gt;{{c|1=get_allocator() != other.get_allocator()}}|after=the behavior is&lt;br&gt;undefined in this case}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc merge|list}}
{{dsc inc|cpp/container/dsc remove|list}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|ko|pl|pt|ru|zh}}