{{cpp/title|{{petty|vector&lt;bool, Alloc&gt;::}}reference}}
{{cpp/container/vector_bool/navbar}}
{{ddcl|
class reference;
}}

The {{rlpt|/|std::vector}}{{c/core|&lt;bool, Alloc&gt;}} specializations define {{rlpt|/|std::vector}}{{c/core|&lt;bool, Alloc&gt;::reference}} as a publicly-accessible nested class. {{rlpt|/|std::vector}}{{c/core|&lt;bool, Alloc&gt;::reference}} proxies the behavior of references to a single bit in {{rlpt|/|std::vector}}{{c/core|&lt;bool, Alloc&gt;}}.

The primary use of {{rlpt|/|std::vector}}{{c/core|&lt;bool, Alloc&gt;::reference}} is to provide an lvalue that can be returned from {{c/core|operator[]}}.

Any reads or writes to a vector that happen via a {{rlpt|/|std::vector}}{{c/core|&lt;bool, Alloc&gt;::reference}} potentially read or write to the entire underlying vector.

===Member functions===
{{dsc begin}}
{{dsc mem ctor|nolink=true|constructs the reference. There is no default constructor. The copy constructor is {{rev inl|until=c++11|implicitly declared}}{{rev inl|since=c++11|defaulted}}. There may be internal constructor that is accessible only to {{rlpt|/|std::vector}}{{c/core|&lt;bool, Alloc&gt;}} itself.}}
{{dsc mem dtor|nolink=true|destroys the reference}}
{{dsc mem fun|operator{{=}}|nolink=true|assigns a {{c/core|bool}} to the referenced bit}}
{{dsc inc|cpp/container/vector_bool/reference/dsc operator bool}}
{{dsc mem fun|flip|nolink=true|flips the referenced bit}}
{{dsc end}}

{{member|{{small|std::vector&lt;bool, Alloc&gt;::reference::}}~reference|2=
{{dcl begin}}
{{dcl rev multi
|dcl1=
~reference();
|since2=c++20|dcl2=
constexpr ~reference();
}}
{{dcl end}}

Destroys the reference.
}}

{{member|{{small|std::vector&lt;bool, Alloc&gt;::reference::}}operator{{=}}|2=
{{dcl begin}}
{{dcl rev multi|num=1
|dcl1=
reference&amp; operator=( bool x );
|since2=c++11|dcl2=
reference&amp; operator=( bool x ) noexcept;
|since3=c++20|dcl3=
constexpr reference&amp; operator=( bool x ) noexcept;
}}
{{dcl rev multi|num=2
|dcl1=
reference&amp; operator=( const reference&amp; x );
|since2=c++11|dcl2=
reference&amp; operator=( const reference&amp; x ) noexcept;
|since3=c++20|dcl3=
constexpr reference&amp; operator=( const reference&amp; x ) noexcept;
}}
{{dcl|num=3
|since=c++23|1=
constexpr const reference&amp; operator=( bool x ) const noexcept;
}}
{{dcl end}}

Assigns a value to the referenced bit.

===Parameters===
{{par begin}}
{{par|x|value to assign}}
{{par end}}

===Return value===
{{c|*this}}
}}

{{member|{{small|std::vector&lt;bool, Alloc&gt;::reference::}}operator bool|2=
{{dcl begin}}
{{dcl rev multi|until1=c++11|dcl1=
operator bool() const;
|until2=c++20|dcl2=
operator bool() const noexcept;
|dcl3=
constexpr operator bool() const noexcept;
}}
{{dcl end}}

Returns the value of the referenced bit.

===Parameters===
(none)

===Return value===
The referenced bit.
}}

{{member|{{small|std::vector&lt;bool, Alloc&gt;::reference::}}flip|2=
{{dcl begin}}
{{dcl rev multi|until1=c++11|dcl1=
void flip();
|until2=c++20|dcl2=
void flip() noexcept;
|dcl3=
constexpr void flip() noexcept;
}}
{{dcl end}}

Inverts the referenced bit.

===Parameters===
(none)

===Return value===
(none)
}}

===Helper classes===
{{member|{{small|std::}}formatter{{small|&lt;std::vector&lt;bool, Alloc&gt;::reference&gt;}}|2=
{{ddcl|since=c++23|
template&lt; class T, class CharT &gt;
  requires /*is-vector-bool-reference*/&lt;T&gt;
struct formatter&lt;T, CharT&gt;;
}}

Specializes the {{lc|std::formatter}} for {{rlpt|/|std::vector}}{{c/core|&lt;bool, Alloc&gt;::reference}}. The specialization uses {{c/core|std::formatter&lt;bool, CharT&gt;}} as its underlying formatter (denoted as {{tti|underlying_}}) where the referenced bit is converted to {{c/core|bool}} to be formatted.

The exposition-only constant {{c|/*is-vector-bool-reference*/&lt;T&gt;}} is {{c|true}} if and only if {{tt|T}} denotes the type {{rlpt|/|std::vector}}{{c/core|&lt;bool, Alloc&gt;::reference}} for some type {{tt|Alloc}} and {{rlpt|/|std::vector}}{{c/core|&lt;bool, Alloc&gt;}} is not a [[cpp/language/type#Program-defined type|program-defined specialization]].

====Member functions====
{{dcl begin}}
{{dcl|num=1|since=c++23|1=
template&lt; class ParseContext &gt;
constexpr ParseContext::iterator parse( ParseContext&amp; ctx );
}}
{{dcl|num=2|since=c++23|1=
template&lt; class FormatContext &gt;
FormatContext::iterator format( const T&amp; r, FormatContext&amp; ctx ) const;
}}
{{dcl end}}

@1@ Equivalent to {{box|{{c/core|return}}{{nbspt}}{{tti|underlying_}}{{c/core|.parse(ctx);}}}}.
@2@ Equivalent to {{box|{{c/core|return}}{{nbspt}}{{tti|underlying_}}{{c/core|.format(r, ctx);}}}}.
}}

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator_at|vector}}
{{dsc inc|cpp/container/vector bool/dsc swap}}
{{dsc end}}

===External links===
{{eli|"Effective Modern C++" by Scott Meyers (2015), Chapter 2, Item 6: "Use the explicitly typed initializer idiom when {{c/core|auto}} deduces undesired types." (p.43-46) &amp;mdash; describes a possible misuse of the proxy class {{ttt|std::vector&lt;bool&gt;::reference}}).}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}