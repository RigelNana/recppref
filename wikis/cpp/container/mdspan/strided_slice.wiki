{{cpp/title|strided_slice}}
{{cpp/container/mdspan/navbar}}
{{dcl begin}}
{{dcl header|mdspan}}
{{dcl|since=c++26|1=
template&lt; class OffsetType, class ExtentType, class StrideType &gt;
struct strided_slice;
}}
{{dcl end}}

An instance of every specialization of {{tt|strided_slice}} is a slice specifier used in {{lc|std::submdspan}} to select a subset of elements using a set of regularly spaced indices at a specified dimension in {{rlpt|/|std::mdspan}}. 

Each {{tt|strided_slice}} object {{c|s}} is characterized by three data members: the offset index {{c|s.offset}}, the extent {{c|s.extent}}, and the stride {{c|s.stride}}.

Given that {{c|s.stride}} is greater than zero, the number of selected indices denoted by {{c|N}} is determined by {{c|1 + (s.extent - 1) / s.stride}} if {{c|s.extent}} is nonzero, otherwise {{c|0}}. The half-open interval from which indices will be selected is given by {{range|s.offset|s.offset + s.extent}}. The sequence of selected indices is produced as follows: {{c|s.offset, ..., s.offset + (N - 1) * s.stride}}.

This class template has no base classes or declared members other than those shown below.

===Template parameters===
{{par begin}}
{{par|OffsetType|the type of offset}}
{{par|ExtentType|the type of extent}}
{{par|StrideType|the type of stride}}
{{par hreq}}
{{par req|All template parameters must be unsigned or signed integer types or must satisfy {{lti|cpp/header/span#Concept integral-constant-like|integral-constant-like}}}}
{{par end}}

The program is ill-formed if the type requirement is not satisfied.

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc|{{tt|offset_type}}|{{tt|OffsetType}}}}
{{dsc|{{tt|extent_type}}|{{tt|ExtentType}}}}
{{dsc|{{tt|stride_type}}|{{tt|StrideType}}}}
{{dsc end}}

===Data members===
{{dsc begin}}
{{dsc begin}}
{{dsc hitem|Member name|Definition}}
{{dsc mem obj|offset|nolink=true|a starting index of type {{tt|offset_type}}}}
{{dsc mem obj|extent|nolink=true|a value of type {{tt|extent_type}} added to offset used to define the upper bound of indices}}
{{dsc mem obj|stride|nolink=true|an increment value of type {{tt|stride_type}} which is equivalent to the distance between two indices}}
{{dsc end}}

All these members are declared with {{attr|no_unique_address}} attribute and have default member initializers where each data member is value initialized.

===Notes===
Every specialization of {{tt|strided_slice}} is an aggregate class which allows [[cpp/language/aggregate_initialization|aggregate initialization]] (including designated initialization) of data members (for instance, {{c|1=std::strided_slice{.offset = 2, .extent = 10, .stride = 3}&lt;!----&gt;}}).

The slice specification of {{tt|strided_slice}} takes advantage of the data member {{c|extent}}, as opposed to other slice specifications that use {{c|end}} to indicate the upper bound value. This is because it can directly generate a static extent for subview of {{lc|std::mdspan}} if both {{c|extent}} and {{c|stride}} are of types that satisfy {{lti|cpp/header/span#Concept integral-constant-like|integral-constant-like}}. This enables efficient extraction of subviews with static extents by mixing compile time values with a runtime value of {{tt|offset}}.

===Example===
{{example
|code=
#include &lt;mdspan&gt;
#include &lt;print&gt;

template &lt;typename View, typename O = int, typename E = int, typename S = int&gt;
    requires (View::extents_type::rank() == 1)
void print_sliced_view(View v, std::strided_slice&lt;O, E, S&gt; s)
{
    using index_type = View::index_type;
    auto subview = std::submdspan(v, s);
    const auto&amp; submap = subview.mapping();

    std::print("[");
    bool uses_comma = false;
    for (index_type i = 0; i != subview.extent(0); ++i)
    {
        if (uses_comma)
            std::print(", ");
        std::print("{}", subview[i]);
        uses_comma = true;
    }
    uses_comma = false;
    std::print("] extracted from indices [");
    for (index_type i = 0; i != subview.extent(0); ++i)
    {
        if (uses_comma)
            std::print(", ");
        std::print("{}", submap(i) + s.offset);
        uses_comma = true;
    }
    std::println("]");
}

int main()
{
    static constexpr char letters[]
    {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
        'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
        'U', 'V', 'W', 'X', 'Y', 'Z'
    };
    constexpr std::mdspan md(letters, 26);
    print_sliced_view(md, {.offset = 0, .extent = 10, .stride = 1});
    print_sliced_view(md, {.offset = 2, .extent = 10, .stride = 1});
    print_sliced_view(md, {.offset = 0, .extent = 5,  .stride = 1});
    print_sliced_view(md, {.offset = 2, .extent = 5,  .stride = 1});
    print_sliced_view(md, {.offset = 0, .extent = 10, .stride = 2});
    print_sliced_view(md, {.offset = 2, .extent = 10, .stride = 3});
    print_sliced_view(md, {.offset = 0, .extent = 15, .stride = 5});
    print_sliced_view(md, {.offset = 6, .extent = 15, .stride = 5});
}
|output=
[A, B, C, D, E, F, G, H, I, J] extracted from indices [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[C, D, E, F, G, H, I, J, K, L] extracted from indices [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
[A, B, C, D, E] extracted from indices [0, 1, 2, 3, 4]
[C, D, E, F, G] extracted from indices [2, 3, 4, 5, 6]
[A, C, E, G, I] extracted from indices [0, 2, 4, 6, 8]
[C, F, I, L] extracted from indices [2, 5, 8, 11]
[A, F, K] extracted from indices [0, 5, 10]
[G, L, Q] extracted from indices [6, 11, 16]
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/valarray/dsc slice}}
{{dsc inc|cpp/container/mdspan/dsc submdspan}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}