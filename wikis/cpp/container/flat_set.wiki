{{cpp/title|flat_set}}
{{cpp/container/flat_set/navbar}}
{{ddcl|header=flat_set|since=c++23|1=
template&lt;
    class Key,
    class Compare = std::less&lt;Key&gt;,
    class KeyContainer = std::vector&lt;Key&gt;
&gt; class flat_set;
}}

The flat set is a [[cpp/container#Container adaptors|container adaptor]] that gives the functionality of an associative container that stores a sorted set of unique objects of type {{tt|Key}}. Sorting is done using the key comparison function {{tt|Compare}}.

The class template {{tt|flat_set}} acts as a wrapper to the underlying sorted container passed as object of type {{tt|KeyContainer}}.

Everywhere the standard library uses the {{named req|Compare}} requirements, uniqueness is determined by using the equivalence relation. Informally, two objects {{c|a}} and {{c|b}} are considered equivalent if neither compares less than the other: {{c|!comp(a, b) &amp;&amp; !comp(b, a)}}.

{{tt|std::flat_set}} meets the requirements of {{named req|Container}}, {{named req|ReversibleContainer}}, {{lsd|cpp/named_req/Container#Optional container requirements}}, and all requirements of {{named req|AssociativeContainer}} (including logarithmic search complexity), except that:
* requirements related to nodes are not applicable,
* iterator invalidation requirements differ, &lt;!--TODO: describe iterator/pointer invalidation properties, maybe per each function --&gt;
* the complexity of insertion and erasure operations is linear.&lt;!--TODO: add the list of member functions (with usual semantics) that must be present in adapted container--&gt;

A flat set supports most {{named req|AssociativeContainer}}'s operations that use unique keys.

===Iterator invalidation===
{{todo}} &lt;!-- TODO: see e.g. [[cpp/container/unordered_set#Iterator invalidation]] as a basis --&gt;

===Template parameters===
{{par begin}}
{{par|Key|The type of the stored elements. The program is ill-formed if {{tt|Key}} is not the same type as {{tt|KeyContainer::value_type}}.}}
{{par|Compare|A {{named req|Compare}} type providing a strict weak ordering.
{{par|KeyContainer|The type of the underlying {{named req|SequenceContainer}} to store the elements. The iterators of such container should satisfy {{named req|RandomAccessIterator}} or model {{lconcept|random_access_iterator}}.

The standard containers {{lc|std::vector}} and {{lc|std::deque}} satisfy these requirements.}}}}{{par end}}
&lt;!----&gt;
===Member types===
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc inc|cpp/container/dsc container_type|flat_set}}
{{dsc inc|cpp/container/dsc key_type|flat_set}}
{{dsc inc|cpp/container/dsc value_type|flat_set}}
{{dsc inc|cpp/container/dsc key_compare|flat_set}}
{{dsc inc|cpp/container/dsc value_compare2|flat_set}}
{{dsc inc|cpp/container/dsc reference|flat_set}}
{{dsc inc|cpp/container/dsc const_reference|flat_set}}
{{dsc inc|cpp/container/dsc size_type|flat_set}}
{{dsc inc|cpp/container/dsc difference_type|flat_set}}
{{dsc inc|cpp/container/dsc iterator|flat_set}}
{{dsc inc|cpp/container/dsc const_iterator|flat_set}}
{{dsc inc|cpp/container/dsc reverse_iterator|flat_set}}
{{dsc inc|cpp/container/dsc const_reverse_iterator|flat_set}}
{{dsc end}}

===Member objects===
{{dsc begin}}
{{dsc hitem|Member|Description}}
{{dsc expos mem obj|private=yes|spec={{tt|container_type}}|id=c|c|the adapted container}}
{{dsc expos mem obj|private=yes|spec={{tt|key_compare}}|id=key_compare|compare|the comparison function object}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/container/dsc constructor|flat_set}}
{{dsc mem dtor|nolink=true|notes={{mark implicit}}|destroys every element of the container adaptor}}
{{dsc inc|cpp/container/dsc operator{{=}}|flat_set}}

{{dsc h2|Iterators}}
{{dsc inc|cpp/container/dsc begin|flat_set}}
{{dsc inc|cpp/container/dsc end|flat_set}}
{{dsc inc|cpp/container/dsc rbegin|flat_set}}
{{dsc inc|cpp/container/dsc rend|flat_set}}

{{dsc h2|Capacity}}
{{dsc inc|cpp/container/dsc empty|flat_set}}
{{dsc inc|cpp/container/dsc size|flat_set}}
{{dsc inc|cpp/container/dsc max_size|flat_set}}

{{dsc h2|Modifiers}}
{{dsc inc|cpp/container/dsc emplace|flat_set}}
{{dsc inc|cpp/container/dsc emplace_hint|flat_set}}
{{dsc inc|cpp/container/dsc insert|flat_set}}
{{dsc inc|cpp/container/dsc insert_range|flat_set}}
{{dsc inc|cpp/container/dsc extract|flat_set}}
{{dsc inc|cpp/container/dsc replace|flat_set}}
{{dsc inc|cpp/container/dsc erase|flat_set}}
{{dsc inc|cpp/container/dsc swap|flat_set}}
{{dsc inc|cpp/container/dsc clear|flat_set}}

{{dsc h2|Lookup}}
{{dsc inc|cpp/container/dsc find|flat_set}}
{{dsc inc|cpp/container/dsc count|flat_set}}
{{dsc inc|cpp/container/dsc contains|flat_set}}
{{dsc inc|cpp/container/dsc lower_bound|flat_set}}
{{dsc inc|cpp/container/dsc upper_bound|flat_set}}
{{dsc inc|cpp/container/dsc equal_range|flat_set}}

{{dsc h2|Observers}}
{{dsc inc|cpp/container/dsc key_comp|flat_set}}
{{dsc inc|cpp/container/dsc value_comp|flat_set}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator_cmp|flat_set}}
{{dsc inc|cpp/container/dsc swap2|flat_set}}
{{dsc inc|cpp/container/dsc erase_if|flat_set}}
{{dsc end}}

===Helper classes===
{{dsc begin}}
{{dsc inc|cpp/container/dsc uses_allocator|flat_set}}
{{dsc end}}

===Tags===
{{dsc begin}}
{{dsc inc|cpp/container/dsc sorted_unique}}
{{dsc end}}

==={{rl|deduction guides|Deduction guides}}===

===Notes===
{{cpp/container/assoc_note}}&lt;!-- TODO: is this relevant to flat_set? --&gt;

Some advantages of flat set over other standard {{lsd|cpp/container#Container adaptors}} are: &lt;!-- TODO: maybe this lyrics is unnecessary: --&gt;
* Potentially faster lookup (even though search operations have logarithmic complexity).
* Much faster iteration: {{lt|cpp/iterator/random access iterator}}s instead of {{lt|cpp/iterator/bidirectional iterator}}s.
* Less memory consumption for small objects (and for big objects if {{c|KeyContainer::shrink_to_fit()}} is available).
* Better cache performance (depending on {{tt|KeyContainer}}, keys are stored in a contiguous block(s) of memory).

Some disadvantages of flat set are:
* Non-stable iterators (iterators are invalidated when inserting and erasing elements).
* Non-copyable and non-movable type values can not be stored.
* Weaker exception safety (copy/move constructors can throw when shifting values in erasures and insertions).
* Slower (i.e. linear) insertion and erasure, especially for non-movable types.

{{ftm begin}}
{{ftm|__cpp_lib_flat_set|value=202207L|std=C++23|{{tt|std::flat_set}} and {{lc|std::flat_multiset}}}}
{{ftm end}}

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc flat_multiset}}
{{dsc inc|cpp/container/dsc set}}
{{dsc inc|cpp/container/dsc unordered_set}}
{{dsc end}}

{{langlinks|cs|de|es|fr|it|ja|pl|pt|ru|zh}}

&lt;!--TODO: N4950::24.6.11 says:
TODO: add this to the "Exceptions" sections of appropriate member functions:
6. If any member function in 24.6.11.2 exits via an exception, the invariant is restored.
[Note 2 : This can result in the flat_set’s being emptied. — end note].
--&gt;

&lt;!--TODO: N4950::24.6.11 says:
TODO: add to constructors:
9. The effect of calling a constructor or member function that takes a sorted_unique_t argument with a range that is not sorted with respect to key_comp(), or that contains equal elements, is undefined.
--&gt;

&lt;!-- TODO: also complete [[cpp/container#Iterator invalidation]] table for flat_* adaptors --&gt;