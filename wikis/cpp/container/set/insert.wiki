{{cpp/container/set/title|insert}}
{{cpp/container/set/navbar}}
{{dcl begin}}
{{dcl|num=1|
std::pair&lt;iterator, bool&gt; insert( const value_type&amp; value );
}}
{{dcl|num=2|since=c++11|
std::pair&lt;iterator, bool&gt; insert( value_type&amp;&amp; value );
}}
{{dcl rev multi|num=3|anchor=3|until1=c++11
|dcl1=
iterator insert( iterator pos, const value_type&amp; value );
|dcl2=
iterator insert( const_iterator pos, const value_type&amp; value );
}}
{{dcl|num=4|since=c++11|
iterator insert( const_iterator pos, value_type&amp;&amp; value );
}}
{{dcla|num=5|
template&lt; class InputIt &gt;
void insert( InputIt first, InputIt last );
}}
{{dcl|num=6|since=c++11|
void insert( std::initializer_list&lt;value_type&gt; ilist );
}}
{{dcl|num=7|since=c++17|
insert_return_type insert( node_type&amp;&amp; nh );
}}
{{dcl|num=8|since=c++17|
iterator insert( const_iterator pos, node_type&amp;&amp; nh );
}}
{{dcla|num=9|since=c++23|
template&lt; class K &gt;
std::pair&lt;iterator, bool&gt; insert( K&amp;&amp; x );
}}
{{dcl|num=10|since=c++23|
template&lt; class K &gt;
iterator insert( const_iterator pos, K&amp;&amp; x );
}}
{{dcl end}}

Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.

@1,2@ Inserts {{c|value}}. 

@3,4@ Inserts {{c|value}} in the position as close as possible to the position just prior to {{c|pos}}. 

@5@ Inserts elements from range {{range|first|last}}. {{cpp/container/lwg2488-note}}

@6@ Inserts elements from initializer list {{c|ilist}}. {{cpp/container/lwg2488-note}}

{{cpp/container/node handle insert desc|set|7|8}}

@9@ If {{c|*this}} already contains an element which transparently compares ''equivalent'' to {{c|x}}, does nothing. Otherwise, constructs an object {{tt|u}} of the {{rlpt|/#Member types|value_type}} with {{c|std::forward&lt;K&gt;(x)}} and then inserts {{tt|u}} into {{c|*this}}. If {{c|1=equal_range(u) == equal_range(x)}} is {{c|false}}, the behavior is undefined. The {{tt|value_type}} must be {{named req|EmplaceConstructible}} into {{tt|set}} from {{c|std::forward&lt;K&gt;(x)}}. {{cpp/container/ordered_heterogeneous_lookup}}

@10@ If {{c|*this}} already contains an element which transparently compares ''equivalent'' to {{c|x}}, does nothing. Otherwise, constructs an object {{tt|u}} of the {{rlpt|/#Member types|value_type}} with {{c|std::forward&lt;K&gt;(x)}} and then inserts {{tt|u}} into {{c|*this}} in the position as close as possible to the position just prior to {{c|pos}}. If {{c|1=equal_range(u) == equal_range(x)}} is {{c|false}}, the behavior is undefined. The {{tt|value_type}} must be {{named req|EmplaceConstructible}} into {{tt|set}} from {{c|std::forward&lt;K&gt;(x)}}. This overload participates in overload resolution only if:
* {{c|std::is_convertible_v&lt;K&amp;&amp;, const_iterator&gt;}} and {{c|std::is_convertible_v&lt;K&amp;&amp;, iterator&gt;}} are both {{c|false}}, and
* the qualified-id {{c|Compare::is_transparent}} is valid and denotes a type,
which together allows calling this function without constructing an instance of {{tt|Key}}.

{{cpp/container/note iterator invalidation|set|insert}}

===Parameters===
{{par begin}}
{{par|pos|iterator to the position before which the new element will be inserted}}
{{par|value|element value to insert}}
{{par|first, last|range of elements to insert}}
{{par|ilist|initializer list to insert the values from}}
{{par|nh|a compatible {{lt|cpp/container/node handle}}}}
{{par|x|a value of any type that can be transparently compared with a key}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par end}} 

===Return value===
@1,2@ {{cpp/container/return iterator pair||pair}}
@3,4@ {{cpp/container/return iterator pair}}
@5,6@ (none)
{{cpp/container/node handle insert return|set|7|8}}
@9@ {{cpp/container/return iterator pair||pair}}
@10@ {{cpp/container/return iterator pair}}

===Exceptions===
@1-4@ If an exception is thrown by any operation, the insertion has no effect.

{{todo|cases 5-8, 9, 10}}

===Complexity===
@1,2@ Logarithmic in the size of the container, {{tt|O(log(size()))}}.

@3,4@ Amortized constant if the insertion happens in the position just {{rev inl|until=c++11|''after''}}{{rev inl|since=c++11|''before''}} {{c|pos}}, logarithmic in the size of the container otherwise.

@5,6@ {{tt|O(N&amp;middot;log(size() + N))}}, where {{tt|N}} is the number of elements to insert.

@7@ Logarithmic in the size of the container, {{tt|O(log(size()))}}.

@8@ Amortized constant if the insertion happens in the position just ''before'' {{c|pos}}, logarithmic in the size of the container otherwise.

@9@ Logarithmic in the size of the container, {{tt|O(log(size()))}}.

@10@ Amortized constant if the insertion happens in the position just ''before'' {{c|pos}}, logarithmic in the size of the container otherwise.

===Notes===
{{cpp/container/hinted insert note}}

The overloads {{vl|5,6}} are often implemented&lt;!--examined GNU libstdc++ 4.8 and LLVM libc++--&gt; as a loop that calls the overload {{vl|3}} with {{lc|end()}} as the hint; they are optimized for appending a sorted sequence (such as another {{lc|std::set}}) whose smallest element is greater than the last element in {{c|*this}}.

{{ftm begin}}
{{ftm|__cpp_lib_associative_heterogeneous_insertion|std=C++26|value=202311L|Heterogeneous overloads for the remaining member functions in [[cpp/container#Associative containers|ordered]] and [[cpp/container#Unordered associative containers|unordered]] associative containers. {{vl|9,10}}}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;

int main()
{
    std::set&lt;int&gt; set;
    
    auto result_1 = set.insert(3);
    assert(result_1.first != set.end()); // it is a valid iterator
    assert(*result_1.first == 3);
    if (result_1.second)
        std::cout &lt;&lt; "insert done\n";
    
    auto result_2 = set.insert(3);
    assert(result_2.first == result_1.first); // same iterator
    assert(*result_2.first == 3);
    if (!result_2.second)
        std::cout &lt;&lt; "no insertion\n";
}
|output=
insert done
no insertion
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=233|std=C++98|before={{c|pos}} was just a hint, it could be totally ignored|after=the insertion is required to&lt;br&gt;be as close as possible to the&lt;br&gt;position just prior to {{c|pos}}}}
{{dr list item|wg=lwg|dr=264|std=C++98|before=the complexity of overload {{v|5}} was required to be linear if&lt;br&gt;the range {{range|first|last}} is sorted according to {{tt|Compare}}|after=removed the linear requirement&lt;br&gt;in this special case}}
{{dr list item|wg=lwg|dr=316|std=C++98|before=in the return value of overload {{v|1}}, it was not specified&lt;br&gt;which {{c/core|bool}} value indicates a successful insertion|after=success is&lt;br&gt;indicated by {{c|true}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc emplace|set}}
{{dsc inc|cpp/container/dsc emplace_hint|set}}
{{dsc inc|cpp/iterator/dsc inserter}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}