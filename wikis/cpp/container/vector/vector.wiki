{{cpp/container/vector/title|vector}}
{{cpp/container/vector/navbar}}
{{dcl begin}}
{{dcl rev begin|num=1}}
{{dcl|since=c++11|until=c++17|
vector() : vector(Allocator()) {}
}}
{{dcla|since=c++17|constexpr=c++20|
vector() noexcept(noexcept(Allocator())) : vector(Allocator()) {}
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|until=c++11|1=
explicit vector( const Allocator&amp; alloc = Allocator() );
}}
{{dcla|since=c++11|noexcept=c++17|constexpr=c++20|
explicit vector( const Allocator&amp; alloc );
}}
{{dcl rev end}}
{{dcl|num=3|since=c++11|1=
explicit vector( size_type count,
                 const Allocator&amp; alloc = Allocator() );
}}
{{dcl rev begin|num=4}}
{{dcl|until=c++11|1=
explicit vector( size_type count, const T&amp; value = T(),
                 const Allocator&amp; alloc = Allocator() );
}}
{{dcla|since=c++11|constexpr=c++20|1=
vector( size_type count, const T&amp; value,
        const Allocator&amp; alloc = Allocator() );
}}
{{dcl rev end}}
{{dcla|num=5|constexpr=c++20|1=
template&lt; class InputIt &gt;
vector( InputIt first, InputIt last,
        const Allocator&amp; alloc = Allocator() );
}}
{{dcl|num=6|since=c++23|1=
template&lt; container-compatible-range&lt;T&gt; R &gt;
constexpr vector( std::from_range_t, R&amp;&amp; rg,
                  const Allocator&amp; alloc = Allocator() );
}}
{{dcla|num=7|constexpr=c++20|
vector( const vector&amp; other );
}}
{{dcla|num=8|since=c++11|noexcept=c++17|constexpr=c++20|
vector( vector&amp;&amp; other );
}}
{{dcl rev begin|num=9}}
{{dcla|since=c++11|constexpr=c++20|until=c++23|
vector( const vector&amp; other, const Allocator&amp; alloc );
}}
{{dcl|since=c++23|
constexpr vector( const vector&amp; other,
                  const std::type_identity_t&lt;Allocator&gt;&amp; alloc );
}}
{{dcl rev end}}
{{dcl rev begin|num=10}}
{{dcl|since=c++11|constexpr=c++20|until=c++23|
vector( vector&amp;&amp; other, const Allocator&amp; alloc );
}}
{{dcl|since=c++23|
constexpr vector( vector&amp;&amp; other,
                  const std::type_identity_t&lt;Allocator&gt;&amp; alloc );
}}
{{dcl rev end}}
{{dcl|num=11|since=c++11|1=
vector( std::initializer_list&lt;T&gt; init,
        const Allocator&amp; alloc = Allocator() );
}}
{{dcl end}}

Constructs a new {{tt|vector}} from a variety of data sources, optionally using a user supplied allocator {{c|alloc}}.

@1@ The default constructor since C++11. Constructs an empty {{tt|vector}} with a default-constructed allocator.
@@ If {{tt|Allocator}} is not {{named req|DefaultConstructible}}, the behavior is undefined.

@2@ The default constructor until C++11. Constructs an empty {{tt|vector}} with the given allocator {{c|alloc}}.

@3@ Constructs a {{tt|vector}} with {{c|count}} default-inserted objects of {{tt|T}}. No copies are made.
@@ If {{tt|T}} is not {{named req|DefaultInsertable}} into {{c/core|std::vector&lt;T&gt;}}, the behavior is undefined.

@4@ Constructs a {{tt|vector}} with {{c|count}} copies of elements with value {{c|value}}.
{{rrev|since=c++11|
If {{tt|T}} is not {{named req|CopyInsertable}} into {{c/core|std::vector&lt;T&gt;}}, the behavior is undefined.
}}

@5@ Constructs a {{tt|vector}} with the contents of the range {{range|first|last}}. Each iterator in {{range|first|last}} is dereferenced exactly once.
{{rev begin}}
{{rev|until=c++11|
If {{tt|InputIt}} does not satisfy the requirements of {{named req|InputIterator}}, overload {{v|4}} is called instead with arguments {{c|static_cast&lt;size_type&gt;(first)}}, {{c|last}} and {{c|alloc}}.
}}
{{rev|since=c++11|
{{cpp/enable if|{{tt|InputIt}} satisfies the requirements of {{named req|InputIterator}}}}.

If any of the following conditions is satisfied, the behavior is undefined:
* {{tt|T}} is not {{named req|EmplaceConstructible}} into {{c/core|std::vector&lt;T&gt;}} from {{c|*first}}.
* {{tt|Iter}} does not satisfy the requirements of {{named req|ForwardIterator}}, and {{tt|T}} is not {{named req|MoveInsertable}} into {{c/core|std::vector&lt;T&gt;}}.
}}
{{rev end}}

@6@ Constructs a {{tt|vector}} with the contents of the range {{c|rg}}. Each iterator in {{c|rg}} is dereferenced exactly once.
@@ If any of the following conditions is satisfied, the behavior is undefined:
* {{tt|T}} is not {{named req|EmplaceConstructible}} into {{c/core|std::vector&lt;T&gt;}} from {{c|*ranges::begin(rg)}}.
* {{tt|R}} models neither {{lconcept|sized_range}} nor {{lconcept|forward_range}}, and {{tt|T}} is not {{named req|MoveInsertable}} into {{c/core|std::vector&lt;T&gt;}}.

@7-10@ Constructs a {{tt|vector}} with the contents of {{c|other}}.

:@7@ The copy constructor.
{{rrev|since=c++11|
The allocator is obtained as if by calling {{c multi|std::allocator_traits&lt;Allocator&gt;::|    select_on_container_copy_construction|        (other.get_allocator())}}.
}}

:@8@ The move constructor. The allocator is obtained by move construction from {{c|other.get_allocator()}}.

:@9@ Same as the copy constructor, except that {{c|alloc}} is used as the allocator.
:@@ If {{tt|T}} is not {{named req|CopyInsertable}} into {{c/core|std::vector&lt;T&gt;}}, the behavior is undefined.

:@10@ Same as the move constructor, except that {{c|alloc}} is used as the allocator.
:@@ If {{tt|T}} is not {{named req|MoveInsertable}} into {{c/core|std::vector&lt;T&gt;}}, the behavior is undefined.

@11@ Equivalent to {{c|vector(il.begin(), il.end(), alloc)}}.

===Parameters===
{{par begin}}
{{par|alloc|allocator to use for all memory allocations of this container}}
{{par|count|the size of the container}}
{{par|value|the value to initialize elements of the container with}}
{{par|first, last|the range to copy the elements from}}
{{par|other|another container to be used as source to initialize the elements of the container with}}
{{par|init|initializer list to initialize the elements of the container with}}
{{par|rg|a container compatible range}}
{{par end}}

===Complexity===
@1,2@ Constant.

@3,4@ Linear in {{c|count}}.

@5@ Given {{c|std::distance(first, last)}} as {{math|N}}:
* If {{c|first}} and {{c|last}} are both forward, bidirectional or random-access iterators,
:* The copy constructor of {{tt|T}} is only called {{math|N}}{{nbsp}} times, and
:* No reallocation occurs.
* Otherwise ({{c|first}} and {{c|last}} are just input iterators),
:* The copy constructor of {{tt|T}} is called {{math|O(N)}} times, and
:* Reallocation occurs {{math|O(log N)}} times.

@6@ Given {{c|ranges::distance(rg)}} as {{math|N}}:
* If {{tt|R}} models {{lc|ranges::forward_range}} or {{lc|ranges::sized_range}},
:* Initializes exactly {{math|N}} elements from the result of dereferencing successive iterators of {{c|rg}}, and
:* No reallocation occurs.
* Otherwise ({{tt|R}} models input range),
:* The copy or move constructor of {{tt|T}} is called {{math|O(N)}} times, and
:* Reallocation occurs {{math|O(log N)}} times.

@7@ Linear in {{c|other.size()}}.

@8@ Constant.

@9@ Linear in {{c|other.size()}}.

@10@ Linear in {{c|other.size()}} if {{c|1=alloc != other.get_allocator()}}, otherwise constant.

@11@ Linear in {{c|init.size()}}.

===Exceptions===
Calls to {{c|Allocator::allocate}} may throw.

===Notes===
{{cpp/container/lwg2321-note|8}}

{{feature test macro|__cpp_lib_containers_ranges|[[cpp/ranges/to#container compatible range|Ranges-aware]] construction and insertion; overload {{v|6}}|value=202202L|std=C++23}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

template&lt;typename T&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const std::vector&lt;T&gt;&amp; v)
{
    s.put('{');
    for (char comma[]{'\0', ' ', '\0'}; const auto&amp; e : v)
        s &lt;&lt; comma &lt;&lt; e, comma[0] = ',';
    return s &lt;&lt; "}\n";
}

int main()
{
    // C++11 initializer list syntax:
    std::vector&lt;std::string&gt; words1{"the", "frogurt", "is", "also", "cursed"};
    std::cout &lt;&lt; "1: " &lt;&lt; words1;
    
    // words2 == words1
    std::vector&lt;std::string&gt; words2(words1.begin(), words1.end());
    std::cout &lt;&lt; "2: " &lt;&lt; words2;
    
    // words3 == words1
    std::vector&lt;std::string&gt; words3(words1);
    std::cout &lt;&lt; "3: " &lt;&lt; words3;
    
    // words4 is {"Mo", "Mo", "Mo", "Mo", "Mo"}
    std::vector&lt;std::string&gt; words4(5, "Mo");
    std::cout &lt;&lt; "4: " &lt;&lt; words4;
    
    const auto rg = {"cat", "cow", "crow"};
#ifdef __cpp_lib_containers_ranges
    std::vector&lt;std::string&gt; words5(std::from_range, rg); // overload (6)
#else
    std::vector&lt;std::string&gt; words5(rg.begin(), rg.end()); // overload (5)
#endif
    std::cout &lt;&lt; "5: " &lt;&lt; words5;
}
|output=
1: {the, frogurt, is, also, cursed}
2: {the, frogurt, is, also, cursed}
3: {the, frogurt, is, also, cursed}
4: {Mo, Mo, Mo, Mo, Mo}
5: {cat, cow, crow}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=134|std=C++98|before=overload {{v|5}} allowed up to {{math|2N}}{{sep}} copy&lt;br&gt;constructor calls in the input iterator case|after=changed to {{math|O(N)}} calls}}
{{dr list item|wg=lwg|dr=438|std=C++98|before=overload {{v|5}} would only call overload {{v|4}}&lt;br&gt;if {{tt|InputIt}} is an integral type|after=calls overload {{v|4}} if {{tt|InputIt}}&lt;br&gt;is not an {{named req|InputIterator}}}}
{{dr list item|wg=lwg|dr=2193|std=C++11|before=the default constructor was explicit|after=made non-explicit}}
{{dr list item|wg=lwg|dr=2210|std=C++11|before=overload {{v|3}} did not have an allocator parameter|after=added the parameter}}
{{dr list item|paper=N3346|std=C++11|before=for overload {{v|3}}, the elements in&lt;br&gt;the container were value-initialized|after=they are default-inserted}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc assign|vector}}
{{dsc inc|cpp/container/dsc operator{{=}}|vector}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pl|pt|ru|zh}}