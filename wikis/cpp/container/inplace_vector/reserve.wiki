{{cpp/container/inplace_vector/title|reserve}}
{{cpp/container/inplace_vector/navbar}}
{{ddcl|since=c++26|
static constexpr void reserve( size_type new_cap );
}}

Does nothing, except that may throw {{lc|std::bad_alloc}}. The request to increase the capacity (i.e., the internal storage size) is ignored because {{c/core|std::inplace_vector&lt;T, N&gt;}} is a fixed-capacity container.

===Parameters===
{{par begin}}
{{par|new_cap|new capacity of the {{tt|inplace_vector}}, in number of elements}}
{{par end}}

===Return value===
(none)

===Complexity===
Constant.

===Exceptions===
{{lc|std::bad_alloc}} if {{c|new_cap &gt; capacity()}} is {{c|true}}.

===Notes===
This function exists for compatibility with vector-like interfaces.

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;inplace_vector&gt;
#include &lt;iostream&gt;

int main()
{
    std::inplace_vector&lt;int, 4&gt; v{1, 2, 3};
    assert(v.capacity() == 4 &amp;&amp; v.size() == 3);

    v.reserve(2); // does nothing
    assert(v.capacity() == 4 &amp;&amp; v.size() == 3);

    try
    {
        v.reserve(13); // throws, because requested capacity &gt; N; v is left unchanged
    }
    catch(const std::bad_alloc&amp; ex)
    {
        std::cout &lt;&lt; ex.what() &lt;&lt; '\n';
    }
    assert(v.capacity() == 4 &amp;&amp; v.size() == 3);
}
|p=true
|output=
std::bad_alloc
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc size|inplace_vector}}
{{dsc inc|cpp/container/dsc max_size|inplace_vector}}
{{dsc inc|cpp/container/dsc resize|inplace_vector}}
{{dsc inc|cpp/container/dsc capacity|inplace_vector}}
{{dsc inc|cpp/container/dsc shrink_to_fit|inplace_vector}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pl|pt|ru|zh}}