{{cpp/container/forward_list/title|splice_after}}
{{cpp/container/forward_list/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++11|
void splice_after( const_iterator pos, forward_list&amp; other );
}}
{{dcl|num=2|since=c++11|
void splice_after( const_iterator pos, forward_list&amp;&amp; other );
}}
{{dcl|num=3|since=c++11|
void splice_after( const_iterator pos, forward_list&amp; other,
                   const_iterator it );
}}
{{dcl|num=4|since=c++11|
void splice_after( const_iterator pos, forward_list&amp;&amp; other,
                   const_iterator it );
}}
{{dcl|num=5|since=c++11|
void splice_after( const_iterator pos, forward_list&amp; other,
                   const_iterator first, const_iterator last );
}}
{{dcl|num=6|since=c++11|
void splice_after( const_iterator pos, forward_list&amp;&amp; other,
                   const_iterator first, const_iterator last );
}}
{{dcl end}}

Moves elements from another {{tt|forward_list}} to {{c|*this}}. The elements are inserted after the element pointed to by {{c|pos}}.

No elements are copied. No iterators or references become invalidated. The iterators to the moved elements now refer into {{c|*this}}, not into {{c|other}}.

@1,2@ Moves all elements from {{c|other}} into {{c|*this}}. The container {{c|other}} becomes empty after the operation.

@3,4@ Moves the element pointed to by the iterator following {{c|it}} from {{c|other}} into {{c|*this}}. Has no effect if {{c|1=pos == it}} or if {{c|1=pos == ++it}}.

@5,6@ Moves the elements in the range {{open range|first|last}} from {{c|other}} into {{c|*this}}. The element pointed-to by {{c|first}} is not moved.

The behavior is undefined if
* {{c|1=get_allocator() != other.get_allocator()}},
* {{c|pos}} is neither {{c|before_begin()}} nor a [[cpp/iterator#Dereferenceability and validity|dereferenceable iterator]] in {{range|begin()|end()}},
* for overloads {{v|1,2}}, {{c|*this}} and {{c|other}} refer to the same object,
* for overloads {{v|3,4}}, the iterator following {{c|it}} is not a [[cpp/iterator#Dereferenceability and validity|dereferenceable iterator]] into {{c|other}}, or
* for overloads {{v|5,6}},
:* {{open range|first|last}} is not a [[cpp/iterator#Ranges|valid range]] in {{c|other}},
:* some iterators in {{open range|first|last}} are not [[cpp/iterator#Dereferenceability and validity|dereferenceable]], or
:* {{c|pos}} is in {{open range|first|last}}.

===Parameters===
{{par begin}}
{{par|pos|element after which the content will be inserted}}
{{par|other|another container to move the content from}}
{{par|it|iterator preceding the iterator to the element to move from {{c|other}} to {{c|*this}}}}
{{par|first, last|the range of elements to move from {{c|other}} to {{c|*this}}}}
{{par end}}

===Exceptions===
Throws nothing.

===Complexity===
@1,2@ Linear in the size of {{c|other}}.

@3,4@ Constant.

@5,6@ Linear in {{c|std::distance(first, last)}}.

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;forward_list&gt;

int main()
{
    using F = std::forward_list&lt;int&gt;;
    
    // Demonstrate the meaning of open range (first, last)
    // in overload (5): the first element of l1 is not moved.
    F l1 = {1, 2, 3, 4, 5};
    F l2 = {10, 11, 12};
    
    l2.splice_after(l2.cbegin(), l1, l1.cbegin(), l1.cend());
    // Not equivalent to l2.splice_after(l2.cbegin(), l1);
    // which is equivalent to
    // l2.splice_after(l2.cbegin(), l1, l1.cbefore_begin(), l1.end());
    
    assert((l1 == F{1}));
    assert((l2 == F{10, 2, 3, 4, 5, 11, 12}));
    
    // Overload (1)
    F x = {1, 2, 3, 4, 5};
    F y = {10, 11, 12};
    x.splice_after(x.cbegin(), y);
    assert((x == F{1, 10, 11, 12, 2, 3, 4, 5}));
    assert((y == F{}));
    
    // Overload (3)
    x = {1, 2, 3, 4, 5};
    y = {10, 11, 12};
    x.splice_after(x.cbegin(), y, y.cbegin());
    assert((x == F{1, 11, 2, 3, 4, 5}));
    assert((y == F{10, 12}));
    
    // Overload (5)
    x = {1, 2, 3, 4, 5};
    y = {10, 11, 12};
    x.splice_after(x.cbegin(), y, y.cbegin(), y.cend());
    assert((x == F{1, 11, 12, 2, 3, 4, 5}));
    assert((y == F{10}));
}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2045|std=C++11|before=O(1) splicing could not be guaranteed if&lt;br&gt;{{c|1=get_allocator() != other.get_allocator()}}|after=the behavior is&lt;br&gt;undefined in this case}}
{{dr list item|wg=lwg|dr=2222|std=C++11|before=the element pointed to by {{c|it}} is not moved, but pointers, references and&lt;br&gt;iterators referring to it would refer to an element in {{c|*this}} after splicing|after=still refer to the&lt;br&gt;element in {{c|other}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc merge|forward_list}}
{{dsc inc|cpp/container/dsc remove|forward_list}}
{{dsc inc|cpp/container/dsc before_begin|forward_list}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pl|pt|ru|zh}}