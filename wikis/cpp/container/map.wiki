{{cpp/title|map}}
{{cpp/container/map/navbar}}
{{dcl begin}}
{{dcl header|map}}
{{dcl|num=1|1=
template&lt;
    class Key,
    class T,
    class Compare = std::less&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;
&gt; class map;
}}
{{dcl|num=2|since=c++17|1=
namespace pmr {
    template&lt;
        class Key,
        class T,
        class Compare = std::less&lt;Key&gt;
    &gt; using map = std::map&lt;Key, T, Compare,
                           std::pmr::polymorphic_allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;;
}
}}
{{dcl end}}

{{tt|std::map}} is a sorted associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function {{tt|Compare}}. Search, removal, and insertion operations have logarithmic complexity. Maps are usually implemented as {{enwiki|Redâ€“black tree}}s.

Iterators of {{tt|std::map}} iterate in ascending order of keys, where ascending is defined by the comparison that was used for construction. That is, given
* {{c|m}}, a {{tt|std::map}}
* {{c|it_l}} and {{c|it_r}}, dereferenceable iterators to {{c|m}}, with {{c|it_l &lt; it_r}}.
{{c|1=m.value_comp()(*it_l, *it_r) == true}} (least to greatest if using the default comparison).

Everywhere the standard library uses the {{named req|Compare}} requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects {{c|a}} and {{c|b}} are considered equivalent (not unique) if neither compares less than the other: {{c|!comp(a, b) &amp;&amp; !comp(b, a)}}.

{{tt|std::map}} meets the requirements of {{named req|Container}}, {{named req|AllocatorAwareContainer}}, {{named req|AssociativeContainer}} and {{named req|ReversibleContainer}}.

===Template parameters===
{{todo|Add descriptions of the template parameters.}}

===Member types===
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc inc|cpp/container/dsc key_type|map}}
{{dsc inc|cpp/container/dsc mapped_type|map}}
{{dsc inc|cpp/container/dsc value_type|map}}
{{dsc inc|cpp/container/dsc size_type|map}}
{{dsc inc|cpp/container/dsc difference_type|map}}
{{dsc inc|cpp/container/dsc key_compare|map}}
{{dsc inc|cpp/container/dsc allocator_type|map}}
{{dsc inc|cpp/container/dsc reference|map}}
{{dsc inc|cpp/container/dsc const_reference|map}}
{{dsc inc|cpp/container/dsc pointer|map}}
{{dsc inc|cpp/container/dsc const_pointer|map}}
{{dsc inc|cpp/container/dsc iterator|map}}
{{dsc inc|cpp/container/dsc const_iterator|map}}
{{dsc inc|cpp/container/dsc reverse_iterator|map}}
{{dsc inc|cpp/container/dsc const_reverse_iterator|map}}
{{dsc inc|cpp/container/dsc node_type|map}}
{{dsc inc|cpp/container/dsc insert_return_type|map}}
{{dsc end}}

===Member classes===
{{dsc begin}}
{{dsc inc|cpp/container/dsc value_compare|map}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/container/dsc constructor|map}}
{{dsc inc|cpp/container/dsc destructor|map}}
{{dsc inc|cpp/container/dsc operator{{=}}|map}}
{{dsc inc|cpp/container/dsc get_allocator|map}}

{{dsc h2|Element access}}
{{dsc inc|cpp/container/dsc at|map}}
{{dsc inc|cpp/container/dsc operator_at|map}}

{{dsc h2|Iterators}}
{{dsc inc|cpp/container/dsc begin|map}}
{{dsc inc|cpp/container/dsc end|map}}
{{dsc inc|cpp/container/dsc rbegin|map}}
{{dsc inc|cpp/container/dsc rend|map}}

{{dsc h2|Capacity}}
{{dsc inc|cpp/container/dsc empty|map}}
{{dsc inc|cpp/container/dsc size|map}}
{{dsc inc|cpp/container/dsc max_size|map}}

{{dsc h2|Modifiers}}
{{dsc inc|cpp/container/dsc clear|map}}
{{dsc inc|cpp/container/dsc insert|map}}
{{dsc inc|cpp/container/dsc insert_range|map}}
{{dsc inc|cpp/container/dsc insert_or_assign|map}}
{{dsc inc|cpp/container/dsc emplace|map}}
{{dsc inc|cpp/container/dsc emplace_hint|map}}
{{dsc inc|cpp/container/dsc try_emplace|map}}
{{dsc inc|cpp/container/dsc erase|map}}
{{dsc inc|cpp/container/dsc swap|map}}
{{dsc inc|cpp/container/dsc extract|map}}
{{dsc inc|cpp/container/dsc merge|map}}

{{dsc h2|Lookup}}
{{dsc inc|cpp/container/dsc count|map}}
{{dsc inc|cpp/container/dsc find|map}}
{{dsc inc|cpp/container/dsc contains|map}}
{{dsc inc|cpp/container/dsc equal_range|map}}
{{dsc inc|cpp/container/dsc lower_bound|map}}
{{dsc inc|cpp/container/dsc upper_bound|map}}

{{dsc h2|Observers}}
{{dsc inc|cpp/container/dsc key_comp|map}}
{{dsc inc|cpp/container/dsc value_comp|map}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator_cmp|map}}
{{dsc inc|cpp/container/dsc swap2|map}}
{{dsc inc|cpp/container/dsc erase_if|map}}
{{dsc end}}

{{rrev|since=c++17|
==={{rl|deduction guides|Deduction guides}}===
}}

===Notes===
{{ftm begin|std=1|comment=1}}
{{ftm|__cpp_lib_containers_ranges|value=202202L|std=C++23|Ranges construction and insertion for containers}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;

void print_map(std::string_view comment, const std::map&lt;std::string, int&gt;&amp; m)
{
    std::cout &lt;&lt; comment;
    // Iterate using C++17 facilities
    for (const auto&amp; [key, value] : m)
        std::cout &lt;&lt; '[' &lt;&lt; key &lt;&lt; "] = " &lt;&lt; value &lt;&lt; "; ";
    
// C++11 alternative:
//  for (const auto&amp; n : m)
//      std::cout &lt;&lt; n.first &lt;&lt; " = " &lt;&lt; n.second &lt;&lt; "; ";
//
// C++98 alternative:
//  for (std::map&lt;std::string, int&gt;::const_iterator it = m.begin(); it != m.end(); ++it)
//      std::cout &lt;&lt; it-&gt;first &lt;&lt; " = " &lt;&lt; it-&gt;second &lt;&lt; "; ";
    
    std::cout &lt;&lt; '\n';
}

int main()
{
    // Create a map of three (string, int) pairs
    std::map&lt;std::string, int&gt; m{&lt;!----&gt;{"CPU", 10}, {"GPU", 15}, {"RAM", 20}&lt;!----&gt;};

    print_map("1) Initial map: ", m);

    m["CPU"] = 25; // update an existing value
    m["SSD"] = 30; // insert a new value
    print_map("2) Updated map: ", m);

    // Using operator[] with non-existent key always performs an insert
    std::cout &lt;&lt; "3) m[UPS] = " &lt;&lt; m["UPS"] &lt;&lt; '\n';
    print_map("4) Updated map: ", m);

    m.erase("GPU");
    print_map("5) After erase: ", m);

    std::erase_if(m, [](const auto&amp; pair){ return pair.second &gt; 25; });
    print_map("6) After erase: ", m);
    std::cout &lt;&lt; "7) m.size() = " &lt;&lt; m.size() &lt;&lt; '\n';

    m.clear();
    std::cout &lt;&lt; std::boolalpha &lt;&lt; "8) Map is empty: " &lt;&lt; m.empty() &lt;&lt; '\n';
}
|output=
1) Initial map: [CPU] = 10; [GPU] = 15; [RAM] = 20;
2) Updated map: [CPU] = 25; [GPU] = 15; [RAM] = 20; [SSD] = 30;
3) m[UPS] = 0
4) Updated map: [CPU] = 25; [GPU] = 15; [RAM] = 20; [SSD] = 30; [UPS] = 0;
5) After erase: [CPU] = 25; [RAM] = 20; [SSD] = 30; [UPS] = 0;
6) After erase: [CPU] = 25; [RAM] = 20; [UPS] = 0;
7) m.size() = 3
8) Map is empty: true
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=230|std=C++98|before={{tt|Key}} was not required to be {{named req|CopyConstructible}}&lt;br&gt;(a key of type {{tt|Key}} might not be able to be constructed)|after={{tt|Key}} is also required to&lt;br&gt;be {{named req|CopyConstructible}}}}
{{dr list item|wg=lwg|dr=464|std=C++98|before=accessing a const {{tt|map}} by key was inconvenient|after={{tt|at}} function provided}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc multimap}}
{{dsc inc|cpp/container/dsc unordered_map}}
{{dsc inc|cpp/container/dsc flat_map}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pl|pt|ru|zh}}