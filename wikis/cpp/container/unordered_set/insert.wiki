{{cpp/container/unordered_set/title|insert}}
{{cpp/container/unordered_set/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++11|
std::pair&lt;iterator,bool&gt; insert( const value_type&amp; value );
}}
{{dcl|num=2|since=c++11|
std::pair&lt;iterator,bool&gt; insert( value_type&amp;&amp; value );
}}
{{dcl|num=3|since=c++11|
iterator insert( const_iterator hint, const value_type&amp; value );
}}
{{dcl|num=4|since=c++11|
iterator insert( const_iterator hint, value_type&amp;&amp; value );
}}
{{dcl|num=5|since=c++11|
template&lt; class InputIt &gt;
void insert( InputIt first, InputIt last );
}}
{{dcl|num=6|since=c++11|
void insert( std::initializer_list&lt;value_type&gt; ilist );
}}
{{dcl|num=7|since=c++17|
insert_return_type insert( node_type&amp;&amp; nh );
}}
{{dcl|num=8|since=c++17|
iterator insert( const_iterator hint, node_type&amp;&amp; nh );
}}
{{dcla|num=9|since=c++23|
template&lt; class K &gt;
std::pair&lt;iterator, bool&gt; insert( K&amp;&amp; obj );
}}
{{dcl|num=10|since=c++23|
template&lt; class K &gt;
iterator insert( const_iterator hint, K&amp;&amp; obj );
}}
{{dcl end}}

Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.

@1,2@ Inserts {{c|value}}.

@3,4@ Inserts {{c|value}}, using {{c|hint}} as a non-binding suggestion to where the search should start.

@5@ Inserts elements from range {{range|first|last}}. {{cpp/container/lwg2488-note}}

@6@ Inserts elements from initializer list {{c|ilist}}. {{cpp/container/lwg2488-note}}

{{cpp/container/node_handle_insert_desc|unordered_set|7|8}}

@9@ If {{c|*this}} already contains an element which transparently compares ''equivalent'' to {{c|obj}}, does nothing. Otherwise, constructs an object {{tt|u}} of {{rlpt|/#Member types|value_type}} with {{c|std::forward&lt;K&gt;(obj)}} and then inserts {{tt|u}} into {{c|*this}}. If {{c|1=equal_range(u) != hash_function()(obj) {{!!}} contains(u)}} is {{c|true}}, the behavior is undefined. The {{tt|value_type}} must be {{named req|EmplaceConstructible}} into {{tt|unordered_set}} from {{c|std::forward&lt;K&gt;(obj)}}. {{cpp/container/unordered heterogeneous lookup}}

@10@ If {{c|*this}} already contains an element which transparently compares ''equivalent'' to {{c|obj}}, does nothing.
Otherwise, constructs an object {{tt|u}} of {{rlpt|/#Member types|value_type}} with {{c|std::forward&lt;K&gt;(obj)}} and then inserts {{tt|u}} into {{c|*this}}. {{hint}} is used as a non-binding suggestion to where the search should start. If {{c|1=equal_range(u) != hash_function()(obj) {{!!}} contains(u)}} is {{c|true}}, the behavior is undefined.
The {{tt|value_type}} must be {{named req|EmplaceConstructible}} into {{tt|unordered_set}} from {{c|std::forward&lt;K&gt;(obj)}}. This overload participates in overload resolution only if:
* {{c|std::is_convertible_v&lt;K&amp;&amp;, const_iterator&gt;}} and {{c|std::is_convertible_v&lt;K&amp;&amp;, iterator&gt;}} are both {{c|false}}, and
* {{c|Hash::is_transparent}} and {{c|KeyEqual::is_transparent}} are valid and each denotes a type. This assumes that such {{tt|Hash}} is callable with both {{tt|K}} and {{tt|Key}} type, and that the {{tt|KeyEqual}} is transparent,
which, together, allows calling this function without constructing an instance of {{tt|Key}}.

{{cpp/container/note_iterator_invalidation|unordered_set|insert}}

===Parameters===
{{par begin}}
{{par|hint|iterator, used as a suggestion as to where to insert the content}}
{{par|value|element value to insert}}
{{par|first, last|range of elements to insert}}
{{par|ilist|initializer list to insert the values from}}
{{par|nh|a compatible [[cpp/container/node_handle|node handle]]}}
{{par|obj|a value of any type that can be transparently compared with a key}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par end}}

===Return value===
@1,2@ {{cpp/container/return iterator pair||pair}}
@3,4@ {{cpp/container/return iterator pair}}
@5,6@ (none)
{{cpp/container/node_handle_insert_return|unordered_set|7|8}}
@9@ {{cpp/container/return iterator pair||pair}}
@10@ {{cpp/container/return iterator pair}}

===Exceptions===
@1-4@ If an exception is thrown by any operation, the insertion has no effect.

{{todo|cases 5-10}}

===Complexity===
@1-4@ Average case: {{tt|O(1)}}, worst case {{tt|O(size())}}.

@5,6@ Average case: {{tt|O(N)}}, where N is the number of elements to insert. Worst case: {{tt|O(N * size() + N)}}.

@7-10@ Average case: {{tt|O(1)}}, worst case {{tt|O(size())}}.

===Notes===
{{cpp/container/hinted insert note}}

{{ftm begin}}
{{ftm|__cpp_lib_associative_heterogeneous_insertion|std=C++26|value=202311L|Heterogeneous overloads for the remaining member functions in [[cpp/container#Associative containers|ordered]] and [[cpp/container#Unordered associative containers|unordered]] associative {{lt|cpp/container}}s. {{vl|9,10}}}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, std::unordered_set&lt;int&gt; const&amp; s)
{
    for (os &lt;&lt; '[' &lt;&lt; s.size() &lt;&lt; "] { "; int i : s)
        os &lt;&lt; i &lt;&lt; ' ';
    return os &lt;&lt; "}\n";
}

int main ()
{
    std::unordered_set&lt;int&gt; nums{2, 3, 4};

    std::cout &lt;&lt; "1) Initially: " &lt;&lt; nums &lt;&lt; std::boolalpha;
    auto p = nums.insert(1); // insert element, overload (1)
    std::cout &lt;&lt; "2) '1' was inserted: " &lt;&lt; p.second &lt;&lt; '\n';
    std::cout &lt;&lt; "3) After insertion: " &lt;&lt; nums;

    nums.insert(p.first, 0); // insert with hint, overload (3)
    std::cout &lt;&lt; "4) After insertion: " &lt;&lt; nums;

    std::array&lt;int, 4&gt; a = {10, 11, 12, 13};
    nums.insert(a.begin(), a.end()); // insert range, overload (5)
    std::cout &lt;&lt; "5) After insertion: " &lt;&lt; nums;

    nums.insert({20, 21, 22, 23}); // insert initializer_list, (6)
    std::cout &lt;&lt; "6) After insertion: " &lt;&lt; nums;

    std::unordered_set&lt;int&gt; other_nums = {42, 43};
    auto node = other_nums.extract(other_nums.find(42));
    nums.insert(std::move(node)); // insert node, overload (7)
    std::cout &lt;&lt; "7) After insertion: " &lt;&lt; nums;

    node = other_nums.extract(other_nums.find(43));
    nums.insert(nums.begin(), std::move(node)); // insert node with hint, (8)
    std::cout &lt;&lt; "8) After insertion: " &lt;&lt; nums;
}
|p=true
|output=
1) Initially: [3] { 4 3 2 }
2) '1' was inserted: true
3) After insertion: [4] { 1 2 3 4 }
4) After insertion: [5] { 0 1 2 3 4 }
5) After insertion: [9] { 13 12 11 10 4 3 2 1 0 }
6) After insertion: [13] { 23 22 13 12 11 10 21 4 20 3 2 1 0 }
7) After insertion: [14] { 42 23 22 13 12 11 10 21 4 20 3 2 1 0 }
8) After insertion: [15] { 43 42 23 22 13 12 11 10 21 4 20 3 2 1 0 }
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc emplace|unordered_set}}
{{dsc inc|cpp/container/dsc emplace_hint|unordered_set}}
{{dsc inc|cpp/iterator/dsc inserter}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}