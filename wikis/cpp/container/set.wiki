{{cpp/title|set}}
{{cpp/container/set/navbar}}
{{dcl begin}}
{{dcl header|set}}
{{dcl|num=1|1=
template&lt;
    class Key,
    class Compare = std::less&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt;
&gt; class set;
}}
{{dcl|num=2|since=c++17|1=
namespace pmr {
    template&lt;
        class Key,
        class Compare = std::less&lt;Key&gt;
    &gt; using set = std::set&lt;Key, Compare, std::pmr::polymorphic_allocator&lt;Key&gt;&gt;;
}
}}
{{dcl end}}

{{tt|std::set}} is an associative container that contains a sorted set of unique objects of type {{tt|Key}}. Sorting is done using the key comparison function {{named req|Compare}}. Search, removal, and insertion operations have logarithmic complexity. Sets are usually implemented as {{enwiki|Redâ€“black tree}}s.

Everywhere the standard library uses the {{named req|Compare}} requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects {{c|a}} and {{c|b}} are considered equivalent if neither compares less than the other: {{c|!comp(a, b) &amp;&amp; !comp(b, a)}}.

{{tt|std::set}} meets the requirements of {{named req|Container}}, {{named req|AllocatorAwareContainer}}, {{named req|AssociativeContainer}} and {{named req|ReversibleContainer}}.

===Template parameters===
{{todo|Add descriptions of the template parameters.}}

===Member types===
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc inc|cpp/container/dsc key_type|set}}
{{dsc inc|cpp/container/dsc value_type|set}}
{{dsc inc|cpp/container/dsc size_type|set}}
{{dsc inc|cpp/container/dsc difference_type|set}}
{{dsc inc|cpp/container/dsc key_compare|set}}
{{dsc inc|cpp/container/dsc value_compare2|set}}
{{dsc inc|cpp/container/dsc allocator_type|set}}
{{dsc inc|cpp/container/dsc reference|set}}
{{dsc inc|cpp/container/dsc const_reference|set}}
{{dsc inc|cpp/container/dsc pointer|set}}
{{dsc inc|cpp/container/dsc const_pointer|set}}
{{dsc inc|cpp/container/dsc iterator|set}}
{{dsc inc|cpp/container/dsc const_iterator|set}}
{{dsc inc|cpp/container/dsc reverse_iterator|set}}
{{dsc inc|cpp/container/dsc const_reverse_iterator|set}}
{{dsc inc|cpp/container/dsc node_type|set}}
{{dsc inc|cpp/container/dsc insert_return_type|set}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/container/dsc constructor|set}}
{{dsc inc|cpp/container/dsc destructor|set}}
{{dsc inc|cpp/container/dsc operator{{=}}|set}}
{{dsc inc|cpp/container/dsc get_allocator|set}}

{{dsc h2|Iterators}}
{{dsc inc|cpp/container/dsc begin|set}}
{{dsc inc|cpp/container/dsc end|set}}
{{dsc inc|cpp/container/dsc rbegin|set}}
{{dsc inc|cpp/container/dsc rend|set}}

{{dsc h2|Capacity}}
{{dsc inc|cpp/container/dsc empty|set}}
{{dsc inc|cpp/container/dsc size|set}}
{{dsc inc|cpp/container/dsc max_size|set}}

{{dsc h2|Modifiers}}
{{dsc inc|cpp/container/dsc clear|set}}
{{dsc inc|cpp/container/dsc insert|set}}
{{dsc inc|cpp/container/dsc insert_range|set}}
{{dsc inc|cpp/container/dsc emplace|set}}
{{dsc inc|cpp/container/dsc emplace_hint|set}}
{{dsc inc|cpp/container/dsc erase|set}}
{{dsc inc|cpp/container/dsc swap|set}}
{{dsc inc|cpp/container/dsc extract|set}}
{{dsc inc|cpp/container/dsc merge|set}}

{{dsc h2|Lookup}}
{{dsc inc|cpp/container/dsc count|set}}
{{dsc inc|cpp/container/dsc find|set}}
{{dsc inc|cpp/container/dsc contains|set}}
{{dsc inc|cpp/container/dsc equal_range|set}}
{{dsc inc|cpp/container/dsc lower_bound|set}}
{{dsc inc|cpp/container/dsc upper_bound|set}}

{{dsc h2|Observers}}
{{dsc inc|cpp/container/dsc key_comp|set}}
{{dsc inc|cpp/container/dsc value_comp|set}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator_cmp|set}}
{{dsc inc|cpp/container/dsc swap2|set}}
{{dsc inc|cpp/container/dsc erase_if|set}}
{{dsc end}}

{{rrev|since=c++17|
==={{rl|deduction guides|Deduction guides}}===
}}

===Notes===
{{cpp/container/assoc_note}}

{{ftm begin|std=1|comment=1}}
{{ftm|__cpp_lib_containers_ranges|value=202202L|std=C++23|Ranges construction and insertion for containers}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;set&gt;
#include &lt;string_view&gt;

template&lt;typename T&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const std::set&lt;T&gt;&amp; set)
{
    if (set.empty())
        return out &lt;&lt; "{}";
    out &lt;&lt; "{ " &lt;&lt; *set.begin();
    std::for_each(std::next(set.begin()), set.end(), [&amp;out](const T&amp; element)
    {
        out &lt;&lt; ", " &lt;&lt; element;
    });
    return out &lt;&lt; " }";
}

int main()
{
    std::set&lt;int&gt; set{1, 5, 3};
    std::cout &lt;&lt; set &lt;&lt; '\n';

    set.insert(2);
    std::cout &lt;&lt; set &lt;&lt; '\n';

    set.erase(1);
    std::cout &lt;&lt; set &lt;&lt; "\n\n";

    std::set&lt;int&gt; keys{3, 4};
    for (int key : keys)
    {
        if (set.contains(key))
            std::cout &lt;&lt; set &lt;&lt; " does contain " &lt;&lt; key &lt;&lt; '\n';
        else
            std::cout &lt;&lt; set &lt;&lt; " doesn't contain " &lt;&lt; key &lt;&lt; '\n';
    }
    std::cout &lt;&lt; '\n';

    std::string_view word = "element";
    std::set&lt;char&gt; characters(word.begin(), word.end());
    std::cout &lt;&lt; "There are " &lt;&lt; characters.size() &lt;&lt; " unique characters in "
              &lt;&lt; std::quoted(word) &lt;&lt; ":\n" &lt;&lt; characters &lt;&lt; '\n';
}
|output=
{ 1, 3, 5 }
{ 1, 2, 3, 5 }
{ 2, 3, 5 }

{ 2, 3, 5 } does contain 3
{ 2, 3, 5 } doesn't contain 4

There are 5 unique characters in "element":
{ e, l, m, n, t }
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=103|std=C++98|before=iterator allows modification of keys|after=iterator made constant}}
{{dr list item|wg=lwg|dr=230|std=C++98|before={{tt|Key}} was not required to be {{named req|CopyConstructible}}&lt;br&gt;(a key of type {{tt|Key}} might not be able to be constructed)|after={{tt|Key}} is also required to&lt;br&gt;be {{named req|CopyConstructible}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc multiset}}
{{dsc inc|cpp/container/dsc unordered_set}}
{{dsc inc|cpp/container/dsc flat_set}}
{{dsc end}}

{{langlinks|cs|de|es|fr|it|ja|pl|pt|ru|zh}}