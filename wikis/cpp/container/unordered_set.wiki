{{cpp/title|unordered_set}}
{{cpp/container/unordered_set/navbar}}
{{dcl begin}}
{{dcl header|unordered_set}}
{{dcl|num=1|since=c++11|1=
template&lt;
    class Key,
    class Hash = std::hash&lt;Key&gt;,
    class KeyEqual = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt;
&gt; class unordered_set;
}}
{{dcl|num=2|since=c++17|1=
namespace pmr {
    template&lt;
        class Key,
        class Hash = std::hash&lt;Key&gt;,
        class Pred = std::equal_to&lt;Key&gt;
    &gt; using unordered_set = std::unordered_set&lt;Key, Hash, Pred,
                                std::pmr::polymorphic_allocator&lt;Key&gt;&gt;;
}
}}
{{dcl end}}

{{tt|std::unordered_set}} is an associative container that contains a set of unique objects of type {{tt|Key}}. Search, insertion, and removal have average constant-time complexity.

Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once a hash is computed, it refers to the exact bucket the element is placed into.

Container elements may not be modified (even by non const iterators) since modification could change an element's hash and corrupt the container.

{{tt|std::unordered_set}} meets the requirements of {{named req|Container}}, {{named req|AllocatorAwareContainer}}, {{named req|UnorderedAssociativeContainer}}.

===Iterator invalidation===
{|class="dsctable" style="font-size:1.0em"
!Operations
!Invalidated
|-
|All read only operations, {{lc|swap}}, {{lc|std::swap}}
|Never
|-
|{{lc|clear}}, {{lc|rehash}}, {{lc|reserve}}, {{lc|1=operator=}}
|Always
|-
|{{lc|insert}}, {{lc|emplace}}, {{lc|emplace_hint}}
|Only if causes rehash
|-
|{{lc|erase}}
|Only to the element erased
|}

====Notes====
* The swap functions do not invalidate any of the iterators inside the container, but they do invalidate the iterator marking the end of the swap region.

* References and pointers to data stored in the container are only invalidated by erasing that element, even when the corresponding iterator is invalidated.

* After container move assignment, unless elementwise move assignment is forced by incompatible allocators, references, pointers, and iterators (other than the past-the-end iterator) to moved-from container remain valid, but refer to elements that are now in {{c|*this}}.

===Template parameters===
{{todo|Add descriptions of the template parameters.}}

===Member types===
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc inc|cpp/container/dsc key_type|unordered_set}}
{{dsc inc|cpp/container/dsc value_type|unordered_set}}
{{dsc inc|cpp/container/dsc size_type|unordered_set}}
{{dsc inc|cpp/container/dsc difference_type|unordered_set}}
{{dsc inc|cpp/container/dsc hasher|unordered_set}}
{{dsc inc|cpp/container/dsc key_equal|unordered_set}}
{{dsc inc|cpp/container/dsc allocator_type|unordered_set}}
{{dsc inc|cpp/container/dsc reference|unordered_set}}
{{dsc inc|cpp/container/dsc const_reference|unordered_set}}
{{dsc inc|cpp/container/dsc pointer|unordered_set}}
{{dsc inc|cpp/container/dsc const_pointer|unordered_set}}
{{dsc inc|cpp/container/dsc iterator|unordered_set}}
{{dsc inc|cpp/container/dsc const_iterator|unordered_set}}
{{dsc inc|cpp/container/dsc local_iterator|unordered_set}}
{{dsc inc|cpp/container/dsc const_local_iterator|unordered_set}}
{{dsc inc|cpp/container/dsc node_type|unordered_set}}
{{dsc inc|cpp/container/dsc insert_return_type|unordered_set}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/container/dsc constructor|unordered_set}}
{{dsc inc|cpp/container/dsc destructor|unordered_set}}
{{dsc inc|cpp/container/dsc operator{{=}}|unordered_set}}
{{dsc inc|cpp/container/dsc get_allocator|unordered_set}}

{{dsc h2|Iterators}}
{{dsc inc|cpp/container/dsc begin|unordered_set}}
{{dsc inc|cpp/container/dsc end|unordered_set}}

{{dsc h2|Capacity}}
{{dsc inc|cpp/container/dsc empty|unordered_set}}
{{dsc inc|cpp/container/dsc size|unordered_set}}
{{dsc inc|cpp/container/dsc max_size|unordered_set}}

{{dsc h2|Modifiers}}
{{dsc inc|cpp/container/dsc clear|unordered_set}}
{{dsc inc|cpp/container/dsc insert|unordered_set}}
{{dsc inc|cpp/container/dsc insert_range|unordered_set}}
{{dsc inc|cpp/container/dsc emplace|unordered_set}}
{{dsc inc|cpp/container/dsc emplace_hint|unordered_set}}
{{dsc inc|cpp/container/dsc erase|unordered_set}}
{{dsc inc|cpp/container/dsc swap|unordered_set}}
{{dsc inc|cpp/container/dsc extract|unordered_set}}
{{dsc inc|cpp/container/dsc merge|unordered_set}}

{{dsc h2|Lookup}}
{{dsc inc|cpp/container/dsc count|unordered_set}}
{{dsc inc|cpp/container/dsc find|unordered_set}}
{{dsc inc|cpp/container/dsc contains|unordered_set}}
{{dsc inc|cpp/container/dsc equal_range|unordered_set}}

{{dsc h2|Bucket interface}}
{{dsc inc|cpp/container/dsc begin(int)|unordered_set}}
{{dsc inc|cpp/container/dsc end(int)|unordered_set}}
{{dsc inc|cpp/container/dsc bucket_count|unordered_set}}
{{dsc inc|cpp/container/dsc max_bucket_count|unordered_set}}
{{dsc inc|cpp/container/dsc bucket_size|unordered_set}}
{{dsc inc|cpp/container/dsc bucket|unordered_set}}

{{dsc h2|Hash policy}}
{{dsc inc|cpp/container/dsc load_factor|unordered_set}}
{{dsc inc|cpp/container/dsc max_load_factor|unordered_set}}
{{dsc inc|cpp/container/dsc rehash|unordered_set}}
{{dsc inc|cpp/container/dsc reserve|unordered_set}}

{{dsc h2|Observers}}
{{dsc inc|cpp/container/dsc hash_function|unordered_set}}
{{dsc inc|cpp/container/dsc key_eq|unordered_set}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/container/dsc operator_cmp_unord|unordered_set}}
{{dsc inc|cpp/container/dsc swap2|unordered_set}}
{{dsc inc|cpp/container/dsc erase_if|unordered_set}}
{{dsc end}}

{{rrev|since=c++17|
==={{rl|deduction guides|Deduction guides}}===
}}

===Notes===
{{cpp/container/assoc_note}}

{{ftm begin|std=1|comment=1}}
{{ftm|__cpp_lib_containers_ranges|value=202202L|std=C++23|Ranges construction and insertion for containers}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

void print(const auto&amp; set)
{
    for (const auto&amp; elem : set)
        std::cout &lt;&lt; elem &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    std::unordered_set&lt;int&gt; mySet{2, 7, 1, 8, 2, 8}; // creates a set of ints
    print(mySet);
    
    mySet.insert(5); // puts an element 5 in the set
    print(mySet);
    
    if (auto iter = mySet.find(5); iter != mySet.end())
        mySet.erase(iter); // removes an element pointed to by iter
    print(mySet);
    
    mySet.erase(7); // removes an element 7
    print(mySet);
}
|p=true
|output=
8 1 7 2
5 8 1 7 2
8 1 7 2
8 1 2
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2050|std=C++11|before=the definitions of {{tt|reference}}, {{tt|const_reference}}, {{tt|pointer}}&lt;br&gt;and {{tt|const_pointer}} were based on {{tt|allocator_type}}|after=based on {{tt|value_type}} and&lt;br&gt;{{lc|std::allocator_traits}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc unordered_multiset}}
{{dsc inc|cpp/container/dsc set}}
{{dsc inc|cpp/container/dsc flat_set}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}