{{cpp/header/experimental/title|experimental/ranges/algorithm}}
{{cpp/header/experimental/navbar}}

This header is part of the [[cpp/experimental/ranges|ranges]] library.

=== Tag specifiers ===
{{dsc begin}}
{{dsc namespace | std::experimental::ranges::tag}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc tags}}
{{dsc end}}

=== Non-modifying sequence operations ===
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc all_any_none_of}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc for_each}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc count}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc mismatch}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc equal}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc lexicographical_compare}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc find}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc find_end}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc find_first_of}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc adjacent_find}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc search}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc search_n}}
{{dsc end}}

=== Modifying sequence operations ===
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc copy}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc copy_n}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc copy_backward}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc move}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc move_backward}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc fill}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc fill_n}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc transform}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc generate}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc generate_n}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc remove}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc remove_copy}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc replace}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc replace_copy}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc swap_ranges}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc reverse}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc reverse_copy}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc rotate}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc rotate_copy}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc shuffle}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc unique}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc unique_copy}}
{{dsc end}}

=== Partitioning operations ===
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc is_partitioned}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc partition}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc partition_copy}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc stable_partition}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc partition_point}}
{{dsc end}}

=== Sorting operations ===
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc is_sorted}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc is_sorted_until}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc sort}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc partial_sort}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc partial_sort_copy}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc stable_sort}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc nth_element}}
{{dsc end}}

=== Binary search operations (on sorted ranges) ===
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc lower_bound}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc upper_bound}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc binary_search}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc equal_range}}
{{dsc end}}

=== Set operations (on sorted ranges) ===
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc merge}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc inplace_merge}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc includes}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc set_difference}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc set_intersection}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc set_symmetric_difference}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc set_union}}
{{dsc end}}

=== Heap operations ===
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc is_heap}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc is_heap_until}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc make_heap}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc push_heap}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc pop_heap}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc sort_heap}}
{{dsc end}}

=== Minimum/maximum operations ===
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc max}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc max_element}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc min}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc min_element}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc minmax}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc minmax_element}}
{{dsc end}}

=== Permutation operations ===
{{dsc begin}}
{{dsc namespace | std::experimental::ranges}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc is_permutation}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc next_permutation}}
{{dsc inc | cpp/experimental/ranges/algorithm/dsc prev_permutation}}
{{dsc end}}

=== Synopsis ===
{{source|1=

#include &lt;initializer_list&gt;

namespace std { namespace experimental { namespace ranges { inline namespace v1 {

namespace tag {
  struct in;
  struct in1;
  struct in2;
  struct out;
  struct out1;
  struct out2;
  struct fun;
  struct min;
  struct max;
  struct begin;
  struct end;
}

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  bool all_of(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  bool all_of(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  bool any_of(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  bool any_of(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  bool none_of(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  bool none_of(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryInvocable&lt;projected&lt;I, Proj&gt;&gt; Fun&gt;
  tagged_pair&lt;tag::in(I), tag::fun(Fun)&gt;
    for_each(I first, S last, Fun f, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectUnaryInvocable&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Fun&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::fun(Fun)&gt;
    for_each(Rng&amp;&amp; rng, Fun f, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
  requires IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
  I find(I first, S last, const T&amp; value, Proj proj = Proj{});

template &lt;InputRange Rng, class T, class Proj = identity&gt;
  requires IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T*&gt;
  safe_iterator_t&lt;Rng&gt;
    find(Rng&amp;&amp; rng, const T&amp; value, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  I find_if(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  safe_iterator_t&lt;Rng&gt;
    find_if(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  I find_if_not(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  safe_iterator_t&lt;Rng&gt;
    find_if_not(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

template &lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2,
    Sentinel&lt;I2&gt; S2, class Proj = identity,
    IndirectRelation&lt;I2, projected&lt;I1, Proj&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  I1
    find_end(I1 first1, S1 last1, I2 first2, S2 last2,
             Pred pred = Pred{}, Proj proj = Proj{});

template &lt;ForwardRange Rng1, ForwardRange Rng2, class Proj = identity,
    IndirectRelation&lt;iterator_t&lt;Rng2&gt;,
      projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  safe_iterator_t&lt;Rng1&gt;
    find_end(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{}, Proj proj = Proj{});

template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2, Sentinel&lt;I2&gt; S2,
    class Proj1 = identity, class Proj2 = identity,
    IndirectRelation&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  I1
    find_first_of(I1 first1, S1 last1, I2 first2, S2 last2,
                  Pred pred = Pred{},
                  Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, ForwardRange Rng2, class Proj1 = identity,
    class Proj2 = identity,
    IndirectRelation&lt;projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;,
      projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  safe_iterator_t&lt;Rng1&gt;
    find_first_of(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2,
                  Pred pred = Pred{},
                  Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  I
    adjacent_find(I first, S last, Pred pred = Pred{},
                  Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectRelation&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    adjacent_find(Rng&amp;&amp; rng, Pred pred = Pred{}, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
  requires IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
  difference_type_t&lt;I&gt;
    count(I first, S last, const T&amp; value, Proj proj = Proj{});

template &lt;InputRange Rng, class T, class Proj = identity&gt;
  requires IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T*&gt;
  difference_type_t&lt;iterator_t&lt;Rng&gt;&gt;
    count(Rng&amp;&amp; rng, const T&amp; value, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  difference_type_t&lt;I&gt;
    count_if(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  difference_type_t&lt;iterator_t&lt;Rng&gt;&gt;
    count_if(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    class Proj1 = identity, class Proj2 = identity,
    IndirectRelation&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  tagged_pair&lt;tag::in1(I1), tag::in2(I2)&gt;
    mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2,
    class Proj1 = identity, class Proj2 = identity,
    IndirectRelation&lt;projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;,
      projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;&gt; Pred = equal_to&lt;&gt;&gt;
  tagged_pair&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;),
              tag::in2(safe_iterator_t&lt;Rng2&gt;)&gt;
    mismatch(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    class Pred = equal_to&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
  bool equal(I1 first1, S1 last1, I2 first2, S2 last2,
             Pred pred = Pred{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, class Pred = equal_to&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires IndirectlyComparable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, Pred, Proj1, Proj2&gt;
  bool equal(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2,
    Sentinel&lt;I2&gt; S2, class Pred = equal_to&lt;&gt;, class Proj1 = identity,
    class Proj2 = identity&gt;
  requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
  bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2,
                      Pred pred = Pred{},
                      Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;ForwardRange Rng1, ForwardRange Rng2, class Pred = equal_to&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires IndirectlyComparable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, Pred, Proj1, Proj2&gt;
  bool is_permutation(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{},
                      Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2,
    Sentinel&lt;I2&gt; S2, class Pred = equal_to&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires IndirectlyComparable&lt;I1, I2, Pred, Proj1, Proj2&gt;
  I1
    search(I1 first1, S1 last1, I2 first2, S2 last2,
           Pred pred = Pred{},
           Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;ForwardRange Rng1, ForwardRange Rng2, class Pred = equal_to&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires IndirectlyComparable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, Pred, Proj1, Proj2&gt;
  safe_iterator_t&lt;Rng1&gt;
    search(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Pred pred = Pred{},
           Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T,
    class Pred = equal_to&lt;&gt;, class Proj = identity&gt;
  requires IndirectlyComparable&lt;I, const T*, Pred, Proj&gt;
  I
    search_n(I first, S last, difference_type_t&lt;I&gt; count,
             const T&amp; value, Pred pred = Pred{},
             Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Pred = equal_to&lt;&gt;,
    class Proj = identity&gt;
  requires IndirectlyComparable&lt;iterator_t&lt;Rng&gt;, const T*, Pred, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    search_n(Rng&amp;&amp; rng, difference_type_t&lt;iterator_t&lt;Rng&gt;&gt; count,
             const T&amp; value, Pred pred = Pred{}, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
  requires IndirectlyCopyable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    copy(I first, S last, O result);

template &lt;InputRange Rng, WeaklyIncrementable O&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    copy(Rng&amp;&amp; rng, O result);

template &lt;InputIterator I, WeaklyIncrementable O&gt;
  requires IndirectlyCopyable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    copy_n(I first, difference_type_t&lt;I&gt; n, O result);

template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, WeaklyIncrementable O, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    copy_if(Rng&amp;&amp; rng, O result, Pred pred, Proj proj = Proj{});

template &lt;BidirectionalIterator I1, Sentinel&lt;I1&gt; S1, BidirectionalIterator I2&gt;
  requires IndirectlyCopyable&lt;I1, I2&gt;
  tagged_pair&lt;tag::in(I1), tag::out(I2)&gt;
    copy_backward(I1 first, S1 last, I2 result);

template &lt;BidirectionalRange Rng, BidirectionalIterator I&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, I&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(I)&gt;
    copy_backward(Rng&amp;&amp; rng, I result);

template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
  requires IndirectlyMovable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    move(I first, S last, O result);

template &lt;InputRange Rng, WeaklyIncrementable O&gt;
  requires IndirectlyMovable&lt;iterator_t&lt;Rng&gt;, O&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    move(Rng&amp;&amp; rng, O result);

template &lt;BidirectionalIterator I1, Sentinel&lt;I1&gt; S1, BidirectionalIterator I2&gt;
  requires IndirectlyMovable&lt;I1, I2&gt;
  tagged_pair&lt;tag::in(I1), tag::out(I2)&gt;
    move_backward(I1 first, S1 last, I2 result);

template &lt;BidirectionalRange Rng, BidirectionalIterator I&gt;
  requires IndirectlyMovable&lt;iterator_t&lt;Rng&gt;, I&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(I)&gt;
    move_backward(Rng&amp;&amp; rng, I result);

template &lt;ForwardIterator I1, Sentinel&lt;I1&gt; S1, ForwardIterator I2, Sentinel&lt;I2&gt; S2&gt;
  requires IndirectlySwappable&lt;I1, I2&gt;
  tagged_pair&lt;tag::in1(I1), tag::in2(I2)&gt;
    swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);

template &lt;ForwardRange Rng1, ForwardRange Rng2&gt;
  requires IndirectlySwappable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;&gt;
  tagged_pair&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;), tag::in2(safe_iterator_t&lt;Rng2&gt;)&gt;
    swap_ranges(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2);

template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O,
    CopyConstructible F, class Proj = identity&gt;
  requires Writable&lt;O, indirect_result_of_t&lt;F&amp;(projected&lt;I, Proj&gt;)&gt;&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    transform(I first, S last, O result, F op, Proj proj = Proj{});

template &lt;InputRange Rng, WeaklyIncrementable O, CopyConstructible F,
    class Proj = identity&gt;
  requires Writable&lt;O, indirect_result_of_t&lt;F&amp;(
    projected&lt;iterator_t&lt;R&gt;, Proj&gt;)&gt;&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    transform(Rng&amp;&amp; rng, O result, F op, Proj proj = Proj{});

template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    WeaklyIncrementable O, CopyConstructible F, class Proj1 = identity,
    class Proj2 = identity&gt;
  requires Writable&lt;O, indirect_result_of_t&lt;F&amp;(projected&lt;I1, Proj1&gt;,
    projected&lt;I2, Proj2&gt;)&gt;&gt;
  tagged_tuple&lt;tag::in1(I1), tag::in2(I2), tag::out(O)&gt;
    transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
              F binary_op, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
    CopyConstructible F, class Proj1 = identity, class Proj2 = identity&gt;
  requires Writable&lt;O, indirect_result_of_t&lt;F&amp;(
    projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;, projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;)&gt;&gt;
  tagged_tuple&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;),
               tag::in2(safe_iterator_t&lt;Rng2&gt;),
               tag::out(O)&gt;
    transform(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result,
              F binary_op, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T1, class T2, class Proj = identity&gt;
  requires Writable&lt;I, const T2&amp;&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T1*&gt;
  I
    replace(I first, S last, const T1&amp; old_value, const T2&amp; new_value, Proj proj = Proj{});

template &lt;InputRange Rng, class T1, class T2, class Proj = identity&gt;
  requires Writable&lt;iterator_t&lt;Rng&gt;, const T2&amp;&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T1*&gt;
  safe_iterator_t&lt;Rng&gt;
    replace(Rng&amp;&amp; rng, const T1&amp; old_value, const T2&amp; new_value, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires Writable&lt;I, const T&amp;&gt;
  I
    replace_if(I first, S last, Pred pred, const T&amp; new_value, Proj proj = Proj{});

template &lt;InputRange Rng, class T, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires Writable&lt;iterator_t&lt;Rng&gt;, const T&amp;&gt;
  safe_iterator_t&lt;Rng&gt;
    replace_if(Rng&amp;&amp; rng, Pred pred, const T&amp; new_value, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T1, class T2, OutputIterator&lt;const T2&amp;&gt; O,
    class Proj = identity&gt;
  requires IndirectlyCopyable&lt;I, O&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T1*&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    replace_copy(I first, S last, O result, const T1&amp; old_value, const T2&amp; new_value,
                 Proj proj = Proj{});

template &lt;InputRange Rng, class T1, class T2, OutputIterator&lt;const T2&amp;&gt; O,
    class Proj = identity&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T1*&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    replace_copy(Rng&amp;&amp; rng, O result, const T1&amp; old_value, const T2&amp; new_value,
                 Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class T, OutputIterator&lt;const T&amp;&gt; O,
    class Proj = identity, IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    replace_copy_if(I first, S last, O result, Pred pred, const T&amp; new_value,
                    Proj proj = Proj{});

template &lt;InputRange Rng, class T, OutputIterator&lt;const T&amp;&gt; O, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    replace_copy_if(Rng&amp;&amp; rng, O result, Pred pred, const T&amp; new_value,
                    Proj proj = Proj{});

template &lt;class T, OutputIterator&lt;const T&amp;&gt; O, Sentinel&lt;O&gt; S&gt;
  O fill(O first, S last, const T&amp; value);

template &lt;class T, OutputRange&lt;const T&amp;&gt; Rng&gt;
  safe_iterator_t&lt;Rng&gt;
    fill(Rng&amp;&amp; rng, const T&amp; value);

template &lt;class T, OutputIterator&lt;const T&amp;&gt; O&gt;
  O fill_n(O first, difference_type_t&lt;O&gt; n, const T&amp; value);

template &lt;Iterator O, Sentinel&lt;O&gt; S, CopyConstructible F&gt;
  requires Invocable&lt;F&amp;&gt; &amp;&amp; Writable&lt;O, result_of_t&lt;F&amp;()&gt;&gt;
  O generate(O first, S last, F gen);

template &lt;class Rng, CopyConstructible F&gt;
  requires Invocable&lt;F&amp;&gt; &amp;&amp; OutputRange&lt;Rng, result_of_t&lt;F&amp;()&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    generate(Rng&amp;&amp; rng, F gen);

template &lt;Iterator O, CopyConstructible F&gt;
  requires Invocable&lt;F&amp;&gt; &amp;&amp; Writable&lt;O, result_of_t&lt;F&amp;()&gt;&gt;
  O generate_n(O first, difference_type_t&lt;O&gt; n, F gen);

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity&gt;
  requires Permutable&lt;I&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
  I remove(I first, S last, const T&amp; value, Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Proj = identity&gt;
  requires Permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T*&gt;
  safe_iterator_t&lt;Rng&gt;
    remove(Rng&amp;&amp; rng, const T&amp; value, Proj proj = Proj{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;I&gt;
    I remove_if(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    remove_if(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O, class T,
    class Proj = identity&gt;
  requires IndirectlyCopyable&lt;I, O&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;I, Proj&gt;, const T*&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    remove_copy(I first, S last, O result, const T&amp; value, Proj proj = Proj{});

template &lt;InputRange Rng, WeaklyIncrementable O, class T, class Proj = identity&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp;
    IndirectRelation&lt;equal_to&lt;&gt;, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;, const T*&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    remove_copy(Rng&amp;&amp; rng, O result, const T&amp; value, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O,
    class Proj = identity, IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    remove_copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, WeaklyIncrementable O, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    remove_copy_if(Rng&amp;&amp; rng, O result, Pred pred, Proj proj = Proj{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; R = equal_to&lt;&gt;&gt;
  requires Permutable&lt;I&gt;
  I unique(I first, S last, R comp = R{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectRelation&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; R = equal_to&lt;&gt;&gt;
  requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    unique(Rng&amp;&amp; rng, R comp = R{}, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O,
    class Proj = identity, IndirectRelation&lt;projected&lt;I, Proj&gt;&gt; R = equal_to&lt;&gt;&gt;
  requires IndirectlyCopyable&lt;I, O&gt; &amp;&amp;
    (ForwardIterator&lt;I&gt; {{!}}{{!}}
    (InputIterator&lt;O&gt; &amp;&amp; Same&lt;value_type_t&lt;I&gt;, value_type_t&lt;O&gt;&gt;) {{!}}{{!}}
    IndirectlyCopyableStorable&lt;I, O&gt;)
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    unique_copy(I first, S last, O result, R comp = R{}, Proj proj = Proj{});

template &lt;InputRange Rng, WeaklyIncrementable O, class Proj = identity,
    IndirectRelation&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; R = equal_to&lt;&gt;&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp;
    (ForwardIterator&lt;iterator_t&lt;Rng&gt;&gt; {{!}}{{!}}
    (InputIterator&lt;O&gt; &amp;&amp; Same&lt;value_type_t&lt;iterator_t&lt;Rng&gt;&gt;, value_type_t&lt;O&gt;&gt;) {{!}}{{!}}
    IndirectlyCopyableStorable&lt;iterator_t&lt;Rng&gt;, O&gt;)
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    unique_copy(Rng&amp;&amp; rng, O result, R comp = R{}, Proj proj = Proj{});

template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S&gt;
  requires Permutable&lt;I&gt;
  I reverse(I first, S last);

template &lt;BidirectionalRange Rng&gt;
  requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    reverse(Rng&amp;&amp; rng);

template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
  requires IndirectlyCopyable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt; reverse_copy(I first, S last, O result);

template &lt;BidirectionalRange Rng, WeaklyIncrementable O&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    reverse_copy(Rng&amp;&amp; rng, O result);

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S&gt;
  requires Permutable&lt;I&gt;
  tagged_pair&lt;tag::begin(I), tag::end(I)&gt;
    rotate(I first, I middle, S last);

template &lt;ForwardRange Rng&gt;
  requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
  tagged_pair&lt;tag::begin(safe_iterator_t&lt;Rng&gt;),
              tag::end(safe_iterator_t&lt;Rng&gt;)&gt;
    rotate(Rng&amp;&amp; rng, iterator_t&lt;Rng&gt; middle);

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O&gt;
  requires IndirectlyCopyable&lt;I, O&gt;
  tagged_pair&lt;tag::in(I), tag::out(O)&gt;
    rotate_copy(I first, I middle, S last, O result);

template &lt;ForwardRange Rng, WeaklyIncrementable O&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O&gt;
  tagged_pair&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out(O)&gt;
    rotate_copy(Rng&amp;&amp; rng, iterator_t&lt;Rng&gt; middle, O result);

template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Gen&gt;
  requires Permutable&lt;I&gt; &amp;&amp;
    UniformRandomNumberGenerator&lt;remove_reference_t&lt;Gen&gt;&gt; &amp;&amp;
    ConvertibleTo&lt;result_of_t&lt;Gen&amp;()&gt;, difference_type_t&lt;I&gt;&gt;
  I shuffle(I first, S last, Gen&amp;&amp; g);

template &lt;RandomAccessRange Rng, class Gen&gt;
  requires Permutable&lt;I&gt; &amp;&amp;
    UniformRandomNumberGenerator&lt;remove_reference_t&lt;Gen&gt;&gt; &amp;&amp;
    ConvertibleTo&lt;result_of_t&lt;Gen&amp;()&gt;, difference_type_t&lt;I&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    shuffle(Rng&amp;&amp; rng, Gen&amp;&amp; g);

template &lt;InputIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  bool is_partitioned(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  bool
    is_partitioned(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;I&gt;
    I partition(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    partition(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;I&gt;
  I stable_partition(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;BidirectionalRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires Permutable&lt;iterator_t&lt;Rng&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    stable_partition(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

template &lt;InputIterator I, Sentinel&lt;I&gt; S, WeaklyIncrementable O1, WeaklyIncrementable O2,
    class Proj = identity, IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;I, O1&gt; &amp;&amp; IndirectlyCopyable&lt;I, O2&gt;
  tagged_tuple&lt;tag::in(I), tag::out1(O1), tag::out2(O2)&gt;
    partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                   Proj proj = Proj{});

template &lt;InputRange Rng, WeaklyIncrementable O1, WeaklyIncrementable O2,
    class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O1&gt; &amp;&amp;
    IndirectlyCopyable&lt;iterator_t&lt;Rng&gt;, O2&gt;
  tagged_tuple&lt;tag::in(safe_iterator_t&lt;Rng&gt;), tag::out1(O1), tag::out2(O2)&gt;
    partition_copy(Rng&amp;&amp; rng, O1 out_true, O2 out_false, Pred pred, Proj proj = Proj{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;
  I partition_point(I first, S last, Pred pred, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectUnaryPredicate&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Pred&gt;
  safe_iterator_t&lt;Rng&gt;
    partition_point(Rng&amp;&amp; rng, Pred pred, Proj proj = Proj{});

template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
    I sort(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    sort(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
    I stable_sort(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    stable_sort(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
    I partial_sort(I first, I middle, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    partial_sort(Rng&amp;&amp; rng, iterator_t&lt;Rng&gt; middle, Comp comp = Comp{},
                 Proj proj = Proj{});

template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, RandomAccessIterator I2, Sentinel&lt;I2&gt; S2,
    class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires IndirectlyCopyable&lt;I1, I2&gt; &amp;&amp; Sortable&lt;I2, Comp, Proj2&gt; &amp;&amp;
    IndirectStrictWeakOrder&lt;Comp, projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt;
  I2
    partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                      Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, RandomAccessRange Rng2, class Comp = less&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires IndirectlyCopyable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;&gt; &amp;&amp;
    Sortable&lt;iterator_t&lt;Rng2&gt;, Comp, Proj2&gt; &amp;&amp;
    IndirectStrictWeakOrder&lt;Comp, projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;,
      projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;&gt;
  safe_iterator_t&lt;Rng2&gt;
    partial_sort_copy(Rng1&amp;&amp; rng, Rng2&amp;&amp; result_rng, Comp comp = Comp{},
                      Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  bool is_sorted(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    is_sorted(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  I is_sorted_until(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    is_sorted_until(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
    I nth_element(I first, I nth, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    nth_element(Rng&amp;&amp; rng, iterator_t&lt;Rng&gt; nth, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  I
    lower_bound(I first, S last, const T&amp; value, Comp comp = Comp{},
                Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    lower_bound(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  I
    upper_bound(I first, S last, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    upper_bound(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  tagged_pair&lt;tag::begin(I), tag::end(I)&gt;
    equal_range(I first, S last, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  tagged_pair&lt;tag::begin(safe_iterator_t&lt;Rng&gt;),
              tag::end(safe_iterator_t&lt;Rng&gt;)&gt;
    equal_range(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    binary_search(I first, S last, const T&amp; value, Comp comp = Comp{},
                  Proj proj = Proj{});

template &lt;ForwardRange Rng, class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;const T*, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    binary_search(Rng&amp;&amp; rng, const T&amp; value, Comp comp = Comp{},
                  Proj proj = Proj{});

template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    WeaklyIncrementable O, class Comp = less&lt;&gt;, class Proj1 = identity,
    class Proj2 = identity&gt;
  requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
  tagged_tuple&lt;tag::in1(I1), tag::in2(I2), tag::out(O)&gt;
    merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
          Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O, class Comp = less&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, Comp, Proj1, Proj2&gt;
  tagged_tuple&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;),
               tag::in2(safe_iterator_t&lt;Rng2&gt;),
               tag::out(O)&gt;
    merge(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result,
          Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  I
    inplace_merge(I first, I middle, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;BidirectionalRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    inplace_merge(Rng&amp;&amp; rng, iterator_t&lt;Rng&gt; middle, Comp comp = Comp{},
                  Proj proj = Proj{});

template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    class Proj1 = identity, class Proj2 = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = Comp{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, class Proj1 = identity,
    class Proj2 = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;,
      projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    includes(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Comp comp = Comp{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    WeaklyIncrementable O, class Comp = less&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
  tagged_tuple&lt;tag::in1(I1), tag::in2(I2), tag::out(O)&gt;
    set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = Comp{},
              Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
    class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, Comp, Proj1, Proj2&gt;
  tagged_tuple&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;),
               tag::in2(safe_iterator_t&lt;Rng2&gt;),
               tag::out(O)&gt;
    set_union(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result, Comp comp = Comp{},
              Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    WeaklyIncrementable O, class Comp = less&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
  O
    set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                     Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
    class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, Comp, Proj1, Proj2&gt;
  O
    set_intersection(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result,
                     Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    WeaklyIncrementable O, class Comp = less&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
  tagged_pair&lt;tag::in1(I1), tag::out(O)&gt;
    set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                   Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
    class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, Comp, Proj1, Proj2&gt;
  tagged_pair&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;), tag::out(O)&gt;
    set_difference(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result,
                   Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    WeaklyIncrementable O, class Comp = less&lt;&gt;,
    class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;
  tagged_tuple&lt;tag::in1(I1), tag::in2(I2), tag::out(O)&gt;
    set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                             Comp comp = Comp{}, Proj1 proj1 = Proj1{},
                             Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
    class Comp = less&lt;&gt;, class Proj1 = identity, class Proj2 = identity&gt;
  requires Mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, Comp, Proj1, Proj2&gt;
  tagged_tuple&lt;tag::in1(safe_iterator_t&lt;Rng1&gt;),
               tag::in2(safe_iterator_t&lt;Rng2&gt;),
               tag::out(O)&gt;
    set_symmetric_difference(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, O result, Comp comp = Comp{},
                             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  I push_heap(I first, S last, Comp comp = Comp{}, Proj proj == Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    push_heap(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  I pop_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    pop_heap(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  I make_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    make_heap(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  I sort_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Comp = less&lt;&gt;, class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  safe_iterator_t&lt;Rng&gt;
    sort_heap(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  bool is_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    is_heap(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  I is_heap_until(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;RandomAccessRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    is_heap_until(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  constexpr const T&amp; min(const T&amp; a, const T&amp; b, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;Copyable T, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  constexpr T min(initializer_list&lt;T&gt; t, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  requires Copyable&lt;value_type_t&lt;iterator_t&lt;Rng&gt;&gt;&gt;
  value_type_t&lt;iterator_t&lt;Rng&gt;&gt;
    min(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  constexpr const T&amp; max(const T&amp; a, const T&amp; b, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;Copyable T, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  constexpr T max(initializer_list&lt;T&gt; t, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  requires Copyable&lt;value_type_t&lt;iterator_t&lt;Rng&gt;&gt;&gt;
  value_type_t&lt;iterator_t&lt;Rng&gt;&gt;
    max(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;class T, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  constexpr tagged_pair&lt;tag::min(const T&amp;), tag::max(const T&amp;)&gt;
    minmax(const T&amp; a, const T&amp; b, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;Copyable T, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;const T*, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  constexpr tagged_pair&lt;tag::min(T), tag::max(T)&gt;
    minmax(initializer_list&lt;T&gt; t, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;InputRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  requires Copyable&lt;value_type_t&lt;iterator_t&lt;Rng&gt;&gt;&gt;
  tagged_pair&lt;tag::min(value_type_t&lt;iterator_t&lt;Rng&gt;&gt;),
              tag::max(value_type_t&lt;iterator_t&lt;Rng&gt;&gt;)&gt;
    minmax(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  I min_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    min_element(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  I max_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  safe_iterator_t&lt;Rng&gt;
    max_element(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardIterator I, Sentinel&lt;I&gt; S, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  tagged_pair&lt;tag::min(I), tag::max(I)&gt;
    minmax_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;ForwardRange Rng, class Proj = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; Comp = less&lt;&gt;&gt;
  tagged_pair&lt;tag::min(safe_iterator_t&lt;Rng&gt;),
              tag::max(safe_iterator_t&lt;Rng&gt;)&gt;
    minmax_element(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;InputIterator I1, Sentinel&lt;I1&gt; S1, InputIterator I2, Sentinel&lt;I2&gt; S2,
    class Proj1 = identity, class Proj2 = identity,
    IndirectStrictWeakOrder&lt;projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                            Comp comp = Comp{},
                            Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;InputRange Rng1, InputRange Rng2, class Proj1 = identity,
    class Proj2 = identity,
    IndirectStrictWeakOrder&lt;projected&lt;iterator_t&lt;Rng1&gt;, Proj1&gt;,
      projected&lt;iterator_t&lt;Rng2&gt;, Proj2&gt;&gt; Comp = less&lt;&gt;&gt;
  bool
    lexicographical_compare(Rng1&amp;&amp; rng1, Rng2&amp;&amp; rng2, Comp comp = Comp{},
                            Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  bool next_permutation(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;BidirectionalRange Rng, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  bool
    next_permutation(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;BidirectionalIterator I, Sentinel&lt;I&gt; S, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;I, Comp, Proj&gt;
  bool prev_permutation(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

template &lt;BidirectionalRange Rng, class Comp = less&lt;&gt;,
    class Proj = identity&gt;
  requires Sortable&lt;iterator_t&lt;Rng&gt;, Comp, Proj&gt;
  bool
    prev_permutation(Rng&amp;&amp; rng, Comp comp = Comp{}, Proj proj = Proj{});

{{))}}{{))}}

}}

{{langlinks|ja|zh}}