{{cpp/header/experimental/title|experimental/reflect}}
{{cpp/header/experimental/navbar}}

This header is part of the [[cpp/experimental/reflect|Reflection TS]].

{{dsc begin}}
{{dsc namespace | std::experimental::reflect}}
{{dsc namespace | inline=true | std::experimental::reflect::v1}}

{{dsc h1 | Concepts}}
{{dsc concept | cpp/experimental/reflect/Object | notes={{mark since reflection ts}} | specifies that a type is a meta-object type}}
{{dsc concept | cpp/experimental/reflect/ObjectSequence | notes={{mark since reflection ts}} | specifies that a meta-object type is a meta-object sequence type}}
{{dsc concept | cpp/experimental/reflect/TemplateParameterScope | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a template parameter scope}}
{{dsc concept | cpp/experimental/reflect/Named | notes={{mark since reflection ts}} | specifies that a meta-object type reflects an entity or alias with an associated (possibly empty) name}}
{{dsc concept | cpp/experimental/reflect/Alias | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a type alias, namespace alias, or an alias introduced by a using-declaration}}
{{dsc concept | cpp/experimental/reflect/RecordMember | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a {{spar|member-declaration}} of a class}}
{{dsc concept | cpp/experimental/reflect/Enumerator | notes={{mark since reflection ts}} | specifies that a meta-object type reflects an enumerator}}
{{dsc concept | cpp/experimental/reflect/Variable | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a variable or data member}}
{{dsc concept | cpp/experimental/reflect/ScopeMember | notes={{mark since reflection ts}} | specifies that a meta-object type satisfies {{tt|RecordMember}}, {{tt|Enumerator}}, or {{tt|Variable}}, or reflects a namespace other than the global namespace}}
{{dsc concept | cpp/experimental/reflect/Typed | notes={{mark since reflection ts}} | specifies that a meta-object type reflects an entity with a type}}
{{dsc concept | cpp/experimental/reflect/Namespace | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a namespace}}
{{dsc concept | cpp/experimental/reflect/GlobalScope | notes={{mark since reflection ts}} | specifies that a meta-object type reflects the global namespace}}
{{dsc concept | cpp/experimental/reflect/Class | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a non-union class type}}
{{dsc concept | cpp/experimental/reflect/Enum | notes={{mark since reflection ts}} | specifies that a meta-object type reflects an enumeration type}}
{{dsc concept | cpp/experimental/reflect/Record | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a class type}}
{{dsc concept | cpp/experimental/reflect/Scope | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a namespace, class, enumeration, function, closure type, a template parameter scope}}
{{dsc concept | cpp/experimental/reflect/Type | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a type}}
{{dsc concept | cpp/experimental/reflect/Constant | notes={{mark since reflection ts}} | specifies that a meta-object type reflects an enumerator or a constexpr variable}}
{{dsc concept | cpp/experimental/reflect/Base | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a direct base class obtained from {{tt|get_base_classes}} }}
{{dsc concept | cpp/experimental/reflect/FunctionParameter | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a function parameter}}
{{dsc concept | cpp/experimental/reflect/Callable | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a function (including constructors and destructors)}}
{{dsc concept | cpp/experimental/reflect/Expression | notes={{mark since reflection ts}} | specifies that a meta-object type reflects an expression}}
{{dsc concept | cpp/experimental/reflect/ParenthesizedExpression | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a parenthesized expression}}
{{dsc concept | cpp/experimental/reflect/FunctionCallExpression | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a {{spar|function-call-expression}}}}
{{dsc concept | cpp/experimental/reflect/FunctionalTypeConversion | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a {{spar|functional-type-conv-expression}}}}
{{dsc concept | cpp/experimental/reflect/Function | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a function (excluding constructors and destructors)}}
{{dsc concept | cpp/experimental/reflect/MemberFunction | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a member function (excluding constructors and destructors)}}
{{dsc concept | cpp/experimental/reflect/SpecialMemberFunction | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a special member function}}
{{dsc concept | cpp/experimental/reflect/Constructor | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a constructor}}
{{dsc concept | cpp/experimental/reflect/Destructor | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a destructor}}
{{dsc concept | cpp/experimental/reflect/Operator | notes={{mark since reflection ts}} | specifies that a meta-object type reflects an operator function or a conversion function}}
{{dsc concept | cpp/experimental/reflect/ConversionOperator | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a conversion function}}
{{dsc concept | cpp/experimental/reflect/Lambda | notes={{mark since reflection ts}} | specifies that a meta-object type reflects the closure type of a non-generic lambda}}
{{dsc concept | cpp/experimental/reflect/LambdaCapture | notes={{mark since reflection ts}} | specifies that a meta-object type reflects a lambda capture}}

{{dsc h1 | Classes}}

{{dsc h2 | {{tt|Object}} operations}}
{{dsc tclass | cpp/experimental/reflect/reflects_same | notes={{mark since reflection ts}} | checks if two meta-object types reflect the same entity or alias}}
{{dsc tclass | cpp/experimental/reflect/get_source_line | notes={{mark since reflection ts}} | obtains the presumed line number of the declaration of the reflected entity or alias}}
{{dsc tclass | cpp/experimental/reflect/get_source_column | notes={{mark since reflection ts}} | obtains the implementation-defined column number of the declaration of the reflected entity or alias}}
{{dsc tclass | cpp/experimental/reflect/get_source_file_name | notes={{mark since reflection ts}} | obtains the presumed file name of the declaration of the reflected entity or alias}}

{{dsc h2 | {{tt|ObjectSequence}} operations}}
{{dsc tclass | cpp/experimental/reflect/get_size | notes={{mark since reflection ts}} | obtains the size of a meta-object sequence}}
{{dsc tclass | cpp/experimental/reflect/get_element | notes={{mark since reflection ts}} | obtains the meta-object type with specified index in a sequence}}
{{dsc tclass | cpp/experimental/reflect/unpack_sequence | notes={{mark since reflection ts}} | applies a template to the meta-object sequence}}

{{dsc h2 | {{tt|Named}} operations}}
{{dsc tclass | cpp/experimental/reflect/is_unnamed | notes={{mark since reflection ts}} | checks if the reflected entity or alias is named}}
{{dsc tclass | cpp/experimental/reflect/get_name | notes={{mark since reflection ts}} | obtains the unqualified name of the reflected entity or alias}}
{{dsc tclass | cpp/experimental/reflect/get_display_name | notes={{mark since reflection ts}} | obtains the implementation-defined display name of the reflected entity or alias}}

{{dsc h2 | {{tt|Alias}} operations}}
{{dsc tclass | cpp/experimental/reflect/get_alias | notes={{mark since reflection ts}} | obtains the meta-object type reflecting the associated entity of the reflected alias}}

{{dsc h2 | {{tt|Type}} operations}}
{{dsc tclass | cpp/experimental/reflect/get_type | notes={{mark since reflection ts}} | obtains the meta-object type reflecting the type of the reflected entity or alias}}
{{dsc tclass | cpp/experimental/reflect/get_reflected_type | notes={{mark since reflection ts}} | obtains the type of the reflected entity or alias}}
{{dsc tclass | cpp/experimental/reflect/is_enum | notes={{mark since reflection ts}} | checks if the meta-object type reflects an enumeration type}}
{{dsc tclass | cpp/experimental/reflect/is_union | notes={{mark since reflection ts}} | checks if the meta-object type reflects a union type}}
{{dsc tclass | cpp/experimental/reflect/uses_key | title=uses_class_key&lt;br&gt;uses_struct_key | notes={{mark since reflection ts}} | checks if the meta-object type reflects a non-union class type whose declaration uses {{c|class}} or {{c|struct}} respectively}}

{{dsc h2 | {{tt|ScopeMember}} operations}}
{{dsc tclass | cpp/experimental/reflect/get_scope | notes={{mark since reflection ts}} | obtains the meta-object type reflecting the scope of the reflected entity or alias}}

{{dsc h2 | {{tt|Base}} operations}}
{{dsc tclass | cpp/experimental/reflect/get_class | notes={{mark since reflection ts}} | obtains the meta-object type reflecting the base class in the given base class relationship}}

{{dsc h2 | {{tt|RecordMember}} and {{tt|Base}} operations}}
{{dsc tclass | cpp/experimental/reflect/is_public | notes={{mark since reflection ts}} | checks if the reflected member or base class is public}}
{{dsc tclass | cpp/experimental/reflect/is_protected | notes={{mark since reflection ts}} | checks if the reflected member or base class is protected}}
{{dsc tclass | cpp/experimental/reflect/is_private | notes={{mark since reflection ts}} | checks if the reflected member or base class is private}}

{{dsc h2 | {{tt|Record}} operations}}
{{dsc tclass | cpp/experimental/reflect/get_data_members | title=get_public_data_members&lt;br&gt;get_accessible_data_members&lt;br&gt;get_data_members | notes={{mark since reflection ts}} | obtains a meta-object sequence type whose elements reflect public, accessible, or all data members of the reflected class}}
{{dsc tclass | cpp/experimental/reflect/get_member_functions | title=get_public_member_functions&lt;br&gt;get_accessible_member_functions&lt;br&gt;get_member_functions | notes={{mark since reflection ts}} | obtains a meta-object sequence type whose elements reflect public, accessible, or all member functions of the reflected class}}
{{dsc tclass | cpp/experimental/reflect/get_constructors | notes={{mark since reflection ts}} | obtains a meta-object sequence type whose elements reflect all constructors of the reflected class}}
{{dsc tclass | cpp/experimental/reflect/get_operators | notes={{mark since reflection ts}} | obtains a meta-object sequence type whose elements reflect all operator functions and conversion functions declared in the reflected class}}
{{dsc tclass | cpp/experimental/reflect/get_destructor | notes={{mark since reflection ts}} | obtains the meta-object type reflecting the destructor of the reflected class}}
{{dsc tclass | cpp/experimental/reflect/get_member_types | title=get_public_member_types&lt;br&gt;get_accessible_member_types&lt;br&gt;get_member_types | notes={{mark since reflection ts}} | obtains a meta-object sequence type whose elements reflect public, accessible, or all nested type or member typedefs of the reflected class}}
{{dsc tclass | cpp/experimental/reflect/get_base_classes | title=get_public_base_classes&lt;br&gt;get_accessible_base_classes&lt;br&gt;get_base_classes | notes={{mark since reflection ts}} | obtains a meta-object sequence type whose elements reflect public, accessible, or all base classes of the reflected class}}

{{dsc h2 | {{tt|Enum}} operations}}
{{dsc tclass | cpp/experimental/reflect/is_scoped_enum | notes={{mark since reflection ts}} | checks whether the reflected enumeration is scoped}}
{{dsc tclass | cpp/experimental/reflect/get_enumerators | notes={{mark since reflection ts}} | obtains a meta-object sequence type whose elements reflects the enumerators of the reflected enumeration}}
{{dsc tclass | cpp/experimental/reflect/get_underlying_type | notes={{mark since reflection ts}} | obtains the meta-object type reflecting the underlying type of the reflected enumeration}}

{{dsc h2 | {{tt|Variable}} operations}}
{{dsc tclass | cpp/experimental/reflect/get_constant | notes={{mark since reflection ts}} | obtains the value of the reflected variable which is a constant expression}}
{{dsc tclass | cpp/experimental/reflect/is_thread_local | notes={{mark since reflection ts}} | checks if the variable is declared with {{c|thread_local}} }}

{{dsc h2 | {{tt|FunctionParameter}} operations}}
{{dsc tclass | cpp/experimental/reflect/has_default_argument | notes={{mark since reflection ts}} | checks whether the reflected parameter has a default argument}}

{{dsc h2 | {{tt|Callable}} operations}}
{{dsc tclass | cpp/experimental/reflect/get_parameters | notes={{mark since reflection ts}} | obtains a meta-object sequence type whose elements reflects the parameters of the reflected function}}
{{dsc tclass | cpp/experimental/reflect/is_vararg | notes={{mark since reflection ts}} | checks whether the parameter list of the reflected function contains an ellipsis parameter}}
{{dsc tclass | cpp/experimental/reflect/is_noexcept | notes={{mark since reflection ts}} | checks whether the reflected function is non-throwing}}
{{dsc tclass | cpp/experimental/reflect/is_deleted | notes={{mark since reflection ts}} | checks whether the reflected function is deleted}}

{{dsc h2 | {{tt|Variable}} and {{tt|Callable}} operations}}
{{dsc tclass | cpp/experimental/reflect/is_constexpr | notes={{mark since reflection ts}} | checks if the reflected variable or function is constexpr}}

{{dsc h2 | {{tt|Namespace}} and {{tt|Callable}} operations}}
{{dsc tclass | cpp/experimental/reflect/is_inline | notes={{mark since reflection ts}} | checks whether the reflected namespace or function is inline}}

{{dsc h2 | {{tt|ParenthesizedExpression}} operations}}
{{dsc tclass | cpp/experimental/reflect/get_subexpression | notes={{mark since reflection ts}} | obtains the meta-object type reflecting the unparenthesized expression of the reflected parethesized expression}}

{{dsc h2 | {{tt|FunctionCallExpression}} operations}}
{{dsc tclass | cpp/experimental/reflect/get_callable | notes={{mark since reflection ts}} | obtains the meta-object type reflecting the function in the reflected {{spar|function-call-expression}} }}

{{dsc h2 | {{tt|FunctionalTypeConversion}} operations}}
{{dsc tclass | cpp/experimental/reflect/get_constructor | notes={{mark since reflection ts}} | obtains the meta-object type reflecting the constructor in reflected {{spar|functional-type-conv-expression}} }}

{{dsc h2 | {{tt|Variable}} and {{tt|Function}} operations}}
{{dsc tclass | cpp/experimental/reflect/get_pointer | notes={{mark since reflection ts}} | get the address of the reflected variable or function, or the pointer-to-member value to the reflected non-static member}}

{{dsc h2 | {{tt|MemberFunction}} operations}}
{{dsc tclass | cpp/experimental/reflect/is_qualified | title=is_const&lt;br&gt;is_volatile&lt;br&gt;has_lvalueref_qualifier&lt;br&gt;has_rvalueref_qualifier | notes={{mark since reflection ts}} | checks if the reflected member function is declared with {{c|const}}, {{c|volatile}}, {{c|&amp;}}, or {{c|&amp;&amp;}} qualifier respectively}}
{{dsc tclass | cpp/experimental/reflect/is_override | notes={{mark since reflection ts}} | checks if the reflected member function overrides a member function of base class}}

{{dsc h2 | {{tt|Record}} and {{tt|MemberFunction}} operations}}
{{dsc tclass | cpp/experimental/reflect/is_final | notes={{mark since reflection ts}} | checks if the reflected class or member function is marked with {{c|final}} }}

{{dsc h2 | {{tt|Variable}} and {{tt|MemberFunction}} operations}}
{{dsc tclass | cpp/experimental/reflect/is_static | notes={{mark since reflection ts}} | checks if the reflected variable is of static storage duration, or the reflected member function is static}}

{{dsc h2 | {{tt|SpecialMemberFunction}} operations}}
{{dsc tclass | cpp/experimental/reflect/is_implicitly_declared | notes={{mark since reflection ts}} | checks if the reflected special member function is implicitly declared}}
{{dsc tclass | cpp/experimental/reflect/is_defaulted | notes={{mark since reflection ts}} | checks if the reflected special member function is defaulted in its first declaration}}

{{dsc h2 | {{tt|Constructor}} and {{tt|ConversionOperator}} operations}}
{{dsc tclass | cpp/experimental/reflect/is_explicit | notes={{mark since reflection ts}} | checks if the reflected constructor or conversion function is declared with {{c|explicit}} }}

{{dsc h2 | {{tt|MemberFunction}} and {{tt|Destructor}} operations}}
{{dsc tclass | cpp/experimental/reflect/is_virtual | notes={{mark since reflection ts}} | checks if the reflected member function is virtual}}
{{dsc tclass | cpp/experimental/reflect/is_pure_virtual | notes={{mark since reflection ts}} | checks if the reflected member function is pure virtual}}

{{dsc h2 | {{tt|Lambda}} operations}}
{{dsc tclass | cpp/experimental/reflect/get_captures | notes={{mark since reflection ts}} | obtains a meta-object sequence type whose elements reflect the captures of the reflected closure type}}
{{dsc tclass | cpp/experimental/reflect/uses_default_capture | title=uses_default_copy_capture&lt;br&gt;uses_default_reference_capture | notes={{mark since reflection ts}} | checks if the capture-default of the lambda expression of the reflected closure type is {{tt|1==}} or {{tt|&amp;}} respectively}}
{{dsc tclass | cpp/experimental/reflect/is_call_operator_const | notes={{mark since reflection ts}} | checks if the {{tt|operator()}} of the reflected closure type is declared with {{c|const}} }}

{{dsc h2 | {{tt|LambdaCapture}} operations}}
{{dsc tclass | cpp/experimental/reflect/is_explictly_captured | notes={{mark since reflection ts}} | checks if the reflected lambda capture is explicitly captured }}
{{dsc tclass | cpp/experimental/reflect/is_init_capture | notes={{mark since reflection ts}} | checks if the reflected lambda capture is an init-capture}}
{{dsc end}}

===Synopsis===
{{source|1=
namespace std::experimental::reflect {
inline namespace v1 {

// 21.12.3 Concepts for meta-object types
template &lt;class T&gt;
concept Object = /* see description */;
template &lt;class T&gt;
concept ObjectSequence = /* see description */; // refines Object
template &lt;class T&gt;
concept TemplateParameterScope = /* see description */; // refines Scope
template &lt;class T&gt;
concept Named = /* see description */;          // refines Object
template &lt;class T&gt;
concept Alias = /* see description */;          // refines Named and ScopeMember
template &lt;class T&gt;
concept RecordMember = /* see description */;   // refines ScopeMember
template &lt;class T&gt;
concept Enumerator = /* see description */;     // refines Constant
template &lt;class T&gt;
concept Variable = /* see description */;       // refines Typed and ScopeMember
template &lt;class T&gt;
concept ScopeMember = /* see description */;    // refines Named
template &lt;class T&gt;
concept Typed = /* see description */;          // refines Object
template &lt;class T&gt;
concept Namespace = /* see description */;      // refines Named and Scope
template &lt;class T&gt;
concept GlobalScope = /* see description */;    // refines Namespace
template &lt;class T&gt;
concept Class = /* see description */;          // refines Record
template &lt;class T&gt;
concept Enum = /* see description */;           // refines Type, Scope, and ScopeMember
template &lt;class T&gt;
concept Record = /* see description */;         // refines Type, Scope, and ScopeMember
template &lt;class T&gt;
concept Scope = /* see description */;          // refines Object
template &lt;class T&gt;
concept Type = /* see description */;           // refines Named
template &lt;class T&gt;
concept Constant = /* see description */;       // refines Typed and ScopeMember
template &lt;class T&gt;
concept Base = /* see description */;           // refines Object
template &lt;class T&gt;
concept FunctionParameter = /* see description */; // refines Typed and ScopeMember
template &lt;class T&gt;
concept Callable = /* see description */;       // refines Scope and ScopeMember
template &lt;class T&gt;
concept Expression = /* see description */;     // refines Object
template &lt;class T&gt;
concept ParenthesizedExpression = /* see description */; // refines Expression
template &lt;class T&gt;
concept FunctionCallExpression = /* see description */; // refines Expression
template &lt;class T&gt;
concept FunctionalTypeConversion = /* see description */; // refines Expression
template &lt;class T&gt;
concept Function = /* see description */;       // refines Typed and Callable
template &lt;class T&gt;
concept MemberFunction = /* see description */; // refines RecordMember and Function
template &lt;class T&gt;
concept SpecialMemberFunction = /* see description */; // refines RecordMember
template &lt;class T&gt;
concept Constructor = /* see description */;    // refines Callable and RecordMember
template &lt;class T&gt;
concept Destructor = /* see description */;     // refines Callable and SpecialMemberFunction
template &lt;class T&gt;
concept Operator = /* see description */;       // refines Function
template &lt;class T&gt;
concept ConversionOperator = /* see description */; // refines MemberFunction and Operator
template &lt;class T&gt;
concept Lambda = /* see description */;         // refines Type and Scope
template &lt;class T&gt;
concept LambdaCapture = /* see description */;  // refines Variable

// 21.12.4 Meta-object operations
// Multi-concept operations
template &lt;Object T&gt; struct is_public;
template &lt;Object T&gt; struct is_protected;
template &lt;Object T&gt; struct is_private;
template &lt;Object T&gt; struct is_constexpr;
template &lt;Object T&gt; struct is_static;
template &lt;Object T&gt; struct is_final;
template &lt;Object T&gt; struct is_explicit;
template &lt;Object T&gt; struct is_inline;
template &lt;Object T&gt; struct is_virtual;
template &lt;Object T&gt; struct is_pure_virtual;
template &lt;Object T&gt; struct get_pointer;

template &lt;class T&gt;
requires RecordMember&lt;T&gt; {{!!}} Base&lt;T&gt;
  constexpr auto is_public_v = is_public&lt;T&gt;::value;
template &lt;class T&gt;
requires RecordMember&lt;T&gt; {{!!}} Base&lt;T&gt;
  constexpr auto is_protected_v = is_protected&lt;T&gt;::value;
template &lt;class T&gt;
requires RecordMember&lt;T&gt; {{!!}} Base&lt;T&gt;
  constexpr auto is_private_v = is_private&lt;T&gt;::value;
template &lt;class T&gt;
requires Variable&lt;T&gt; {{!!}} Callable&lt;T&gt;
  constexpr auto is_constexpr_v = is_constexpr&lt;T&gt;::value;
template &lt;class T&gt;
requires Variable&lt;T&gt; {{!!}} MemberFunction&lt;T&gt;
  constexpr auto is_static_v = is_static&lt;T&gt;::value;
template &lt;class T&gt;
requires Class&lt;T&gt; {{!!}} MemberFunction&lt;T&gt;
  constexpr auto is_final_v = is_final&lt;T&gt;::value;
template &lt;class T&gt;
requires Constructor&lt;T&gt; {{!!}} ConversionOperator&lt;T&gt;
  constexpr auto is_explicit_v = is_explicit&lt;T&gt;::value;
template &lt;class T&gt;
requires Namespace&lt;T&gt; {{!!}} Callable&lt;T&gt;
  constexpr auto is_inline_v = is_inline&lt;T&gt;::value;
template &lt;class T&gt;
requires Base&lt;T&gt; {{!!}} MemberFunction&lt;T&gt; {{!!}} Destructor&lt;T&gt;
  constexpr auto is_virtual_v = is_virtual&lt;T&gt;::value;
template &lt;class T&gt;
requires MemberFunction&lt;T&gt; {{!!}} Destructor&lt;T&gt;
  constexpr auto is_pure_virtual_v = is_pure_virtual&lt;T&gt;::value;
template &lt;class T&gt;
requires Variable&lt;T&gt; {{!!}} Function&lt;T&gt;
  constexpr auto get_pointer_v = get_pointer&lt;T&gt;::value;

// 21.12.4.1 Object operations
template &lt;Object T1, Object T2&gt; struct reflects_same;
template &lt;Object T&gt; struct get_source_line;
template &lt;Object T&gt; struct get_source_column;
template &lt;Object T&gt; struct get_source_file_name;

template &lt;Object T1, Object T2&gt;
  constexpr auto reflects_same_v = reflects_same&lt;T1, T2&gt;::value;
template &lt;class T&gt;
  constexpr auto get_source_line_v = get_source_line&lt;T&gt;::value;
template &lt;class T&gt;
  constexpr auto get_source_column_v = get_source_column&lt;T&gt;::value;
template &lt;class T&gt;
  constexpr auto get_source_file_name_v = get_source_file_name&lt;T&gt;::value;

// 21.12.4.2 ObjectSequence operations
template &lt;ObjectSequence T&gt; struct get_size;
template &lt;size_t I, ObjectSequence T&gt; struct get_element;
template &lt;template &lt;class...&gt; class Tpl, ObjectSequence T&gt;
  struct unpack_sequence;

template &lt;ObjectSequence T&gt;
  constexpr auto get_size_v = get_size&lt;T&gt;::value;
template &lt;size_t I, ObjectSequence T&gt;
  using get_element_t = typename get_element&lt;I, T&gt;::type;
template &lt;template &lt;class...&gt; class Tpl, ObjectSequence T&gt;
  using unpack_sequence_t = typename unpack_sequence&lt;Tpl, T&gt;::type;

// 21.12.4.3 Named operations
template &lt;Named T&gt; struct is_unnamed;
template &lt;Named T&gt; struct get_name;
template &lt;Named T&gt; struct get_display_name;

template &lt;Named T&gt;
  constexpr auto is_unnamed_v = is_unnamed&lt;T&gt;::value;
template &lt;Named T&gt;
  constexpr auto get_name_v = get_name&lt;T&gt;::value;
template &lt;Named T&gt;
  constexpr auto get_display_name_v = get_display_name&lt;T&gt;::value;

// 21.12.4.4 Alias operations
template &lt;Alias T&gt; struct get_aliased;

template &lt;Alias T&gt;
  using get_aliased_t = typename get_aliased&lt;T&gt;::type;

// 21.12.4.5 Type operations
template &lt;Typed T&gt; struct get_type;
template &lt;Type T&gt; struct get_reflected_type;
template &lt;Type T&gt; struct is_enum;
template &lt;Class T&gt; struct uses_class_key;
template &lt;Class T&gt; struct uses_struct_key;
template &lt;Type T&gt; struct is_union;

template &lt;Typed T&gt;
  using get_type_t = typename get_type&lt;T&gt;::type;
template &lt;Type T&gt;
  using get_reflected_type_t = typename get_reflected_type&lt;T&gt;::type;
template &lt;Type T&gt;
  constexpr auto is_enum_v = is_enum&lt;T&gt;::value;
template &lt;Class T&gt;
  constexpr auto uses_class_key_v = uses_class_key&lt;T&gt;::value;
template &lt;Class T&gt;
  constexpr auto uses_struct_key_v = uses_struct_key&lt;T&gt;::value;
template &lt;Type T&gt;
  constexpr auto is_union_v = is_union&lt;T&gt;::value;

// 21.12.4.6 Member operations
template &lt;ScopeMember T&gt; struct get_scope;
template &lt;RecordMember T&gt; struct is_public&lt;T&gt;;
template &lt;RecordMember T&gt; struct is_protected&lt;T&gt;;
template &lt;RecordMember T&gt; struct is_private&lt;T&gt;;
template &lt;ScopeMember T&gt;
  using get_scope_t = typename get_scope&lt;T&gt;::type;

// 21.12.4.7 Record operations
template &lt;Record T&gt; struct get_public_data_members;
template &lt;Record T&gt; struct get_accessible_data_members;
template &lt;Record T&gt; struct get_data_members;
template &lt;Record T&gt; struct get_public_member_functions;
template &lt;Record T&gt; struct get_accessible_member_functions;
template &lt;Record T&gt; struct get_member_functions;
template &lt;Record T&gt; struct get_public_member_types;
template &lt;Record T&gt; struct get_accessible_member_types;
template &lt;Record T&gt; struct get_member_types;
template &lt;Record T&gt; struct get_constructors;
template &lt;Record T&gt; struct get_destructor;
template &lt;Record T&gt; struct get_operators;
template &lt;Class T&gt; struct get_public_base_classes;
template &lt;Class T&gt; struct get_accessible_base_classes;
template &lt;Class T&gt; struct get_base_classes;
template &lt;Class T&gt; struct is_final&lt;T&gt;;

template &lt;Record T&gt;
  using get_public_data_members_t = typename get_public_data_members&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_accessible_data_members_t = typename get_accessible_data_members&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_data_members_t = typename get_data_members&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_public_member_functions_t = typename get_public_member_functions&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_accessible_member_functions_t = typename get_accessible_member_functions&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_member_functions_t = typename get_member_functions&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_public_member_types_t = typename get_public_member_types&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_accessible_member_types_t = typename get_accessible_member_types&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_member_types_t = typename get_member_types&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_constructors_t = typename get_constructors&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_destructor_t = typename get_destructor&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_operators_t = typename get_operators&lt;T&gt;::type;
template &lt;Class T&gt;
  using get_public_base_classes_t = typename get_public_base_classes&lt;T&gt;::type;
template &lt;Class T&gt;
  using get_accessible_base_classes_t = typename get_accessible_base_classes&lt;T&gt;::type;
template &lt;Class T&gt;
  using get_base_classes_t = typename get_base_classes&lt;T&gt;::type;

// 21.12.4.8 Enum operations
template &lt;Enum T&gt; struct is_scoped_enum;
template &lt;Enum T&gt; struct get_enumerators;
template &lt;Enum T&gt; struct get_underlying_type;

template &lt;Enum T&gt;
  constexpr auto is_scoped_enum_v = is_scoped_enum&lt;T&gt;::value;
template &lt;Enum T&gt;
  using get_enumerators_t = typename get_enumerators&lt;T&gt;::type;
template &lt;Enum T&gt;
  using get_underlying_type_t = typename get_underlying_type&lt;T&gt;::type;

// 21.12.4.9 Value operations
template &lt;Constant T&gt; struct get_constant;
template &lt;Variable T&gt; struct is_constexpr&lt;T&gt;;
template &lt;Variable T&gt; struct is_static&lt;T&gt;;
template &lt;Variable T&gt; struct is_thread_local;
template &lt;Variable T&gt; struct get_pointer&lt;T&gt;;

template &lt;Constant T&gt;
  constexpr auto get_constant_v = get_constant&lt;T&gt;::value;
template &lt;Variable T&gt;
  constexpr auto is_thread_local_v = is_thread_local&lt;T&gt;::value;

// 21.12.4.10 Base operations
template &lt;Base T&gt; struct get_class;
template &lt;Base T&gt; struct is_virtual&lt;T&gt;;
template &lt;Base T&gt; struct is_public&lt;T&gt;;
template &lt;Base T&gt; struct is_protected&lt;T&gt;;
template &lt;Base T&gt; struct is_private&lt;T&gt;;

template &lt;Base T&gt;
  using get_class_t = typename get_class&lt;T&gt;::type;

// 21.12.4.11 Namespace operations
template &lt;Namespace T&gt; struct is_inline&lt;T&gt;;

// 21.12.4.12 FunctionParameter operations
template &lt;FunctionParameter T&gt; struct has_default_argument;

template &lt;FunctionParameter T&gt;
  constexpr auto has_default_argument_v = has_default_argument&lt;T&gt;::value;

// 21.12.4.13 Callable operations
template &lt;Callable T&gt; struct get_parameters;
template &lt;Callable T&gt; struct is_vararg;
template &lt;Callable T&gt; struct is_constexpr&lt;T&gt;;
template &lt;Callable T&gt; struct is_noexcept;
template &lt;Callable T&gt; struct is_inline&lt;T&gt;;
template &lt;Callable T&gt; struct is_deleted;

template &lt;Callable T&gt;
  using get_parameters_t = typename get_parameters&lt;T&gt;::type;
template &lt;Callable T&gt;
  constexpr auto is_vararg_v = is_vararg&lt;T&gt;::value;
template &lt;Callable T&gt;
  constexpr auto is_deleted_v = is_deleted&lt;T&gt;::value;

// 21.12.4.14 ParenthesizedExpression operations
template &lt;ParenthesizedExpression T&gt; struct get_subexpression;

template &lt;ParenthesizedExpression T&gt;
  using get_subexpression_t = typename get_subexpression&lt;T&gt;::type;

// 21.12.4.15 FunctionCallExpression operations
template &lt;FunctionCallExpression T&gt; struct get_callable;

template &lt;FunctionCallExpression T&gt;
  using get_callable_t = typename get_callable&lt;T&gt;::type;

// 21.12.4.16 FunctionalTypeConversion operations
template &lt;FunctionalTypeConversion T&gt; struct get_constructor;

template &lt;FunctionalTypeConversion T&gt;
  using get_constructor_t = typename get_constructor&lt;T&gt;::type;

// 21.12.4.17 Function operations
template &lt;Function T&gt; struct get_pointer&lt;T&gt;;

// 21.12.4.18 MemberFunction operations
template &lt;MemberFunction T&gt; struct is_static&lt;T&gt;;
template &lt;MemberFunction T&gt; struct is_const;
template &lt;MemberFunction T&gt; struct is_volatile;
template &lt;MemberFunction T&gt; struct has_lvalueref_qualifier;
template &lt;MemberFunction T&gt; struct has_rvalueref_qualifier;
template &lt;MemberFunction T&gt; struct is_virtual&lt;T&gt;;
template &lt;MemberFunction T&gt; struct is_pure_virtual&lt;T&gt;;
template &lt;MemberFunction T&gt; struct is_override;
template &lt;MemberFunction T&gt; struct is_final&lt;T&gt;;

template &lt;MemberFunction T&gt;
  constexpr auto is_const_v = is_const&lt;T&gt;::value;
template &lt;MemberFunction T&gt;
  constexpr auto is_volatile_v = is_volatile&lt;T&gt;::value;
template &lt;MemberFunction T&gt;
  constexpr auto has_lvalueref_qualifier_v = has_lvalueref_qualifier&lt;T&gt;::value;
template &lt;MemberFunction T&gt;
  constexpr auto has_rvalueref_qualifier_v = has_rvalueref_qualifier&lt;T&gt;::value;
template &lt;MemberFunction T&gt;
  constexpr auto is_override_v = is_override&lt;T&gt;::value;

// 21.12.4.19 SpecialMemberFunction operations
template &lt;SpecialMemberFunction T&gt; struct is_implicitly_declared;
template &lt;SpecialMemberFunction T&gt; struct is_defaulted;

template &lt;SpecialMemberFunction T&gt;
  constexpr auto is_implicitly_declared_v = is_implicitly_declared&lt;T&gt;::value;
template &lt;SpecialMemberFunction T&gt;
  constexpr auto is_defaulted_v = is_defaulted&lt;T&gt;::value;

// 21.12.4.20 Constructor operations
template &lt;Constructor T&gt; struct is_explicit&lt;T&gt;;

// 21.12.4.21 Destructor operations
template &lt;Destructor T&gt; struct is_virtual&lt;T&gt;;
template &lt;Destructor T&gt; struct is_pure_virtual&lt;T&gt;;

// 21.12.4.22 ConversionOperator operations
template &lt;ConversionOperator T&gt; struct is_explicit&lt;T&gt;;

// 21.12.4.23 Lambda operations
template &lt;Lambda T&gt; struct get_captures;
template &lt;Lambda T&gt; struct uses_default_copy_capture;
template &lt;Lambda T&gt; struct uses_default_reference_capture;
template &lt;Lambda T&gt; struct is_call_operator_const;

template &lt;Lambda T&gt;
  using get_captures_t = typename get_captures&lt;T&gt;::type;
template &lt;Lambda T&gt;
  constexpr auto uses_default_copy_capture_v = uses_default_copy_capture&lt;T&gt;::value;
template &lt;Lambda T&gt;
  constexpr auto uses_default_reference_capture_v = uses_default_reference_capture&lt;T&gt;::value;
template &lt;Lambda T&gt;
  constexpr auto is_call_operator_const_v = is_call_operator_const&lt;T&gt;::value;

// 21.12.4.24 LambdaCapture operations
template &lt;LambdaCapture T&gt; struct is_explicitly_captured;
template &lt;LambdaCapture T&gt; struct is_init_capture;

template &lt;LambdaCapture T&gt;
  constexpr auto is_explicitly_captured_v = is_explicitly_captured&lt;T&gt;::value;
template &lt;LambdaCapture T&gt;
  constexpr auto is_init_capture_v = is_init_capture&lt;T&gt;::value;

} // inline namespace v1
} // namespace std::experimental::reflect
}}

{{langlinks|es|ja|ru|zh}}