{{cpp/chrono/title|1=operator==,&lt;=&gt;{{small|(std::chrono::year_month_day_last)}}}}
{{cpp/chrono/year_month_day_last/navbar}}
{{dcl begin}}
{{dcl header|chrono}}
{{dcl|since=c++20|num=1|1=
constexpr bool operator==( const std::chrono::year_month_day_last&amp; x,
                           const std::chrono::year_month_day_last&amp; y ) noexcept;
}}
{{dcl|since=c++20|num=2|1=
constexpr std::strong_ordering
    operator&lt;=&gt;( const std::chrono::year_month_day_last&amp; x,
                 const std::chrono::year_month_day_last&amp; y ) noexcept;
}}
{{dcl end}}

Compares the two {{tt|year_month_day_last}} values {{c|x}} and {{c|y}}. This is a lexicographical comparison: the {{rlpf|accessors|year}} is compared first, then {{rlpf|accessors|month}}.

{{cpp/note synthesized compare}}

===Return value===
@1@ {{c|1=x.year() == y.year() &amp;&amp; x.month() == y.month()}}
@2@ {{c|1=x.year() &lt;=&gt; y.year() != 0 ? x.year() &lt;=&gt; y.year() : x.month() &lt;=&gt; y.month()}}

===Notes===
If both {{c|x}} and {{c|y}} represent valid dates ({{c|1=x.ok() &amp;&amp; y.ok() == true}}), the result of the lexicographical comparison is consistent with the calendar order.

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;

int main()
{
    auto ymdl1{11/std::chrono::last/2020};
    auto mdl{std::chrono::last/std::chrono::November};
    auto ymdl2{mdl/2020};
    assert(ymdl1 == ymdl2);

    ymdl1 -= std::chrono::months{2};
    ymdl2 -= std::chrono::months{1};
    assert(ymdl1 &lt; ymdl2);
}
}}

{{langlinks|de|es|ja|ru|zh}}