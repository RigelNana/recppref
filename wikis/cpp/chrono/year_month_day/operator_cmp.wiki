{{cpp/chrono/title|1=operator==,&lt;=&gt;{{small|(std::chrono::year_month_day)}}}}
{{cpp/chrono/year_month_day/navbar}}
{{dcl begin}}
{{dcl header|chrono}}
{{dcl|since=c++20|num=1|1=
constexpr bool operator==( const std::chrono::year_month_day&amp; x,
                           const std::chrono::year_month_day&amp; y ) noexcept;
}}
{{dcl|since=c++20|num=2|1=
constexpr std::strong_ordering
    operator&lt;=&gt;( const std::chrono::year_month_day&amp; x,
                 const std::chrono::year_month_day&amp; y ) noexcept;
}}
{{dcl end}}

Compares the two {{tt|year_month_day}} values {{c|x}} and {{c|y}}. This is a lexicographical comparison: the {{rlpf|accessors|year}} is compared first, then {{rlpf|accessors|month}}, then {{rlpf|accessors|day}}.

{{cpp/note synthesized compare}}

===Return value===
@1@ {{c|1=x.year() == y.year() &amp;&amp; x.month() == y.month() &amp;&amp; x.day() == y.day()}}
@2@ If {{c|1=x.year() &lt;=&gt; y.year != 0}}, {{c|1=x.year() &lt;=&gt; y.year}}; otherwise if {{c|1=x.month() &lt;=&gt; y.month() != 0}}, {{c|1=x.month() &lt;=&gt; y.month()}}; otherwise {{c|1=x.day() &lt;=&gt; y.day()}}.

===Notes===
If both {{c|x}} and {{c|y}} represent valid dates ({{c|1=x.ok() &amp;&amp; y.ok() == true}}), the result of the lexicographical comparison is consistent with the calendar order.

===Example===
{{example
|code=
#include &lt;chrono&gt;

int main()
{
    constexpr auto ymd1{std::chrono::day(13)/7/1337};
    constexpr auto ymd2{std::chrono::year(1337)/7/13};
    static_assert(ymd1 == ymd2);
    static_assert(ymd1 &lt;= ymd2);
    static_assert(ymd1 &gt;= ymd2);
    static_assert(ymd1 &lt;=&gt; ymd2 == 0);
}
}}

{{langlinks|es|ja|ru|zh}}