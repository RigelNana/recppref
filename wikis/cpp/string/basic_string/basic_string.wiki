{{cpp/string/basic_string/title|basic_string}}
{{cpp/string/basic_string/navbar}}
{{dcl begin}}
{{dcl rev begin|num=1}}
{{dcla|since=c++11|until=c++17|
basic_string() : basic_string(Allocator()) {}
}}
{{dcla|since=c++17|constexpr=c++20|
basic_string() noexcept(noexcept(Allocator()))
    : basic_string(Allocator()) {}
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcla|until=c++11|1=
explicit basic_string( const Allocator&amp; alloc = Allocator() );
}}
{{dcla|noexcept=c++17|constexpr=c++20|
explicit basic_string( const Allocator&amp; alloc );
}}
{{dcl rev end}}
{{dcla|num=3|constexpr=c++20|1=
basic_string( size_type count, CharT ch,
              const Allocator&amp; alloc = Allocator() );
}}
{{dcla|num=4|constexpr=c++20|1=
template&lt; class InputIt &gt;
basic_string( InputIt first, InputIt last,
              const Allocator&amp; alloc = Allocator() );
}}
{{dcl|num=5|since=c++23|1=
template&lt; container-compatible-range&lt;CharT&gt; R &gt;
constexpr basic_string( std::from_range_t, R&amp;&amp; rg,
                        const Allocator&amp; = Allocator());
}}
{{dcla|num=6|constexpr=c++20|1=
basic_string( const CharT* s, size_type count,
              const Allocator&amp; alloc = Allocator() );
}}
{{dcla|num=7|constexpr=c++20|1=
basic_string( const CharT* s, const Allocator&amp; alloc = Allocator() );
}}
{{dcl|num=8|since=c++23|1=
basic_string( std::nullptr_t ) = delete;
}}
{{dcla|num=9|since=c++17|constexpr=c++20|1=
template&lt; class StringViewLike &gt;
explicit basic_string( const StringViewLike&amp; t,
                       const Allocator&amp; alloc = Allocator() );
}}
{{dcl|num=10|since=c++17|constexpr=c++20|1=
template&lt; class StringViewLike &gt;
basic_string( const StringViewLike&amp; t,
              size_type pos, size_type count,
              const Allocator&amp; alloc = Allocator() );
}}
{{dcla|num=11|constexpr=c++20|
basic_string( const basic_string&amp; other );
}}
{{dcla|num=12|since=c++11|constexpr=c++20|
basic_string( basic_string&amp;&amp; other ) noexcept;
}}
{{dcla|num=13|since=c++11|constexpr=c++20|
basic_string( const basic_string&amp; other, const Allocator&amp; alloc );
}}
{{dcla|num=14|since=c++11|constexpr=c++20|
basic_string( basic_string&amp;&amp; other, const Allocator&amp; alloc );
}}
{{dcla|num=15|constexpr=c++20|1=
basic_string( const basic_string&amp; other, size_type pos,
              const Allocator&amp; alloc = Allocator() );
}}
{{dcl|num=16|since=c++23|1=
constexpr basic_string( basic_string&amp;&amp; other, size_type pos,
                        const Allocator&amp; alloc = Allocator() );
}}
{{dcla|num=17|constexpr=c++20|1=
basic_string( const basic_string&amp; other,
              size_type pos, size_type count,
              const Allocator&amp; alloc = Allocator() );
}}
{{dcl|num=18|since=c++23|1=
constexpr basic_string( basic_string&amp;&amp; other,
                        size_type pos, size_type count,
                        const Allocator&amp; alloc = Allocator() );
}}
{{dcla|num=19|since=c++11|constexpr=c++20|1=
basic_string( std::initializer_list&lt;CharT&gt; ilist,
              const Allocator&amp; alloc = Allocator() );
}}
{{dcl end}}

Constructs new string from a variety of data sources and optionally using user supplied allocator {{c|alloc}}.

@1@ The default constructor since C++11. Constructs an empty string with a default-constructed allocator.
@@ If Allocator is not {{named req|DefaultConstructible}}, the behavior is undefined.

@2@ The default constructor until C++11. Constructs an empty string with the given allocator {{c|alloc}}.

@3@ Constructs a string with {{c|count}} copies of character {{c|ch}}.
{{rev begin}}
{{rev|since=c++11|
If {{tt|CharT}} is not {{named req|CopyInsertable}} into {{c/core|std::basic_string&lt;CharT&gt;}}, the behavior is undefined.
}}
{{rev|since=c++17|
{{cpp/enable if|{{tt|Allocator}} satisfies the requirements of {{named req|Allocator}}}}.
}}
{{rev end}}

@4@ Constructs a string with the contents of the range {{range|first|last}}. Each iterator in {{range|first|last}} is dereferenced exactly once.
{{rev begin}}
{{rev|until=c++11|
If {{tt|InputIt}} does not satisfy the requirements of {{named req|InputIterator}}, overload {{v|3}} is called instead with arguments {{c|static_cast&lt;size_type&gt;(first)}}, {{c|last}} and {{c|alloc}}.
}}
{{rev|since=c++11|
{{cpp/enable if|{{tt|InputIt}} satisfies the requirements of {{named req|InputIterator}}}}.

If {{tt|CharT}} is not {{named req|EmplaceConstructible}} into {{c/core|std::basic_string&lt;CharT&gt;}} from {{c|*first}}, the behavior is undefined.
}}
{{rev end}}

@5@ Constructs a string with the contents of the range {{c|rg}}. Each iterator in {{c|rg}} is dereferenced exactly once.
@@ If {{tt|CharT}} is not {{named req|EmplaceConstructible}} into {{c/core|std::basic_string&lt;CharT&gt;}} from {{c|*ranges::begin(rg)}}, the behavior is undefined.

@6@ Constructs a string with the contents of the range {{range|s|s + count}}.
@@ If {{range|s|s + count}} is not a valid range, the behavior is undefined.

@7@ Equivalent to {{c|basic_string(s, Traits::length(s), alloc)}}.
{{rrev|since=c++17|
{{cpp/enable if|{{tt|Allocator}} satisfies the requirements of {{named req|Allocator}}}}.
}}

@8@ {{tt|std::basic_string}} cannot be constructed from {{c|nullptr}}.

@9@ {{cpp/string/sv hack|constructs a string as if by {{c|basic_string(sv.data(), sv.size(), alloc)}}}}

@10@ {{cpp/string/sv hack|checkptr=no|constructs a string as if by {{c|basic_string(sv.substr(pos, n), alloc)}}}}

@11-18@ Constructs a string with (part of) the contents of {{c|other}}. If the type of {{c|other}} is {{tt|basic_string&amp;&amp;}}, when the construction finishes, {{c|other}} is in a valid but unspecified state.

:@11@ The copy constructor.
{{rrev|since=c++11|
The allocator is obtained as if by calling {{c multi|std::allocator_traits&lt;Allocator&gt;::|    select_on_container_copy_construction|        (other.get_allocator())}}.
}}

:@12@ The move constructor. The allocator is obtained by move construction from {{c|other.get_allocator()}}.

:@13@ Same as the copy constructor, except that {{c|alloc}} is used as the allocator.
:@@ If {{tt|CharT}} is not {{named req|CopyInsertable}} into {{c/core|std::basic_string&lt;CharT&gt;}}, the behavior is undefined.

:@14@ Same as the move constructor, except that {{c|alloc}} is used as the allocator.
:@@ If {{tt|CharT}} is not {{named req|MoveInsertable}} into {{c/core|std::basic_string&lt;CharT&gt;}}, the behavior is undefined.

:@15,16@ Constructs a string with the contents of the range {{range|other.data() + pos|other.data() + other.size()}}.

:@17,18@ Constructs a string with the contents of the range {{range|other.data() + pos|other.data() + (pos + std::min(count, other.size() - pos))}}.

@19@ Equivalent to {{c|basic_string(ilist.begin(), ilist.end())}}.

===Parameters===
{{par begin}}
{{par|alloc|allocator to use for all memory allocations of this string}}
{{par|count|size of the resulting string}}
{{par|ch|value to initialize the string with}}
{{par|pos|position of the first character to include}}
{{par|first, last|range to copy the characters from}}
{{par|s|pointer to an array of characters to use as source to initialize the string with}}
{{par|other|another string to use as source to initialize the string with}}
{{par|ilist|{{lc|std::initializer_list}} to initialize the string with}}
{{par|t|object (convertible to {{lc|std::basic_string_view}}) to initialize the string with}}
{{par|rg|a container compatible range}}
{{par end}}

===Complexity===
@1,2@ Constant.

@3-7@ Linear in the size of the string.

@9-11@ Linear in the size of the string.

@12@ Constant.

@13@ Linear in the size of the string.

@14@ Linear in the size of the string if {{c|1=alloc != other.get_allocator()}} is {{c|true}}, otherwise constant.

@15-19@ Linear in the size of the string.

===Exceptions===
@10@ {{lc|std::out_of_range}} if {{c|pos}} is out of range.

@14@ Throws nothing if {{c|1=alloc == str.get_allocator()}} is {{c|true}}.

@15-18@ {{lc|std::out_of_range}} if {{c|pos &gt; other.size()}} is {{c|true}}.

Throws {{lc|std::length_error}} if the length of the constructed string would exceed {{lc|max_size()}} (for example, if {{c|count &gt; max_size()}} for {{v|3}}). Calls to {{tt|Allocator::allocate}} may throw.

{{cpp/strong exception safety guarantee|plural=yes}}

===Notes===
Initialization with a {{lt|cpp/language/string literal}} that contains embedded {{c|'\0'}} characters uses the overload {{v|7}}, which stops at the first null character. This can be avoided by specifying a different constructor or by using {{rlpt|operator""s}}:
{{source|1=
std::string s1 = "ab\0\0cd";   // s1 contains "ab"
std::string s2{"ab\0\0cd", 6}; // s2 contains "ab\0\0cd"
std::string s3 = "ab\0\0cd"s;  // s3 contains "ab\0\0cd"
}}

{{feature test macro|__cpp_lib_containers_ranges|value=202202L|std=C++23|Tagged constructor {{v|5}} to construct from {{ls|cpp/ranges/to#container compatible range}}}}

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;

int main()
{
    std::cout &lt;&lt; "1)  string(); ";
    std::string s1;
    assert(s1.empty() &amp;&amp; (s1.length() == 0) &amp;&amp; (s1.size() == 0));
    std::cout &lt;&lt; "s1.capacity(): " &lt;&lt; s1.capacity() &lt;&lt; '\n'; // unspecified
    
    std::cout &lt;&lt; "3)  string(size_type count, CharT ch): ";
    std::string s2(4, '=');
    std::cout &lt;&lt; std::quoted(s2) &lt;&lt; '\n'; // "===="
    
    std::cout &lt;&lt; "4)  string(InputIt first, InputIt last): ";
    char mutable_c_str[] = "another C-style string";
    std::string s4(std::begin(mutable_c_str) + 8, std::end(mutable_c_str) - 1);
    std::cout &lt;&lt; std::quoted(s4) &lt;&lt; '\n'; // "C-style string"
    
    std::cout &lt;&lt; "6)  string(CharT const* s, size_type count): ";
    std::string s6("C-style string", 7);
    std::cout &lt;&lt; std::quoted(s6) &lt;&lt; '\n'; // "C-style", i.e. [0, 7)
    
    std::cout &lt;&lt; "7)  string(CharT const* s): ";
    std::string s7("C-style\0string");
    std::cout &lt;&lt; std::quoted(s7) &lt;&lt; '\n'; // "C-style"
    
    std::cout &lt;&lt; "11) string(string&amp;): ";
    std::string const other11("Exemplar");
    std::string s11(other11);
    std::cout &lt;&lt; std::quoted(s11) &lt;&lt; '\n'; // "Exemplar"
    
    std::cout &lt;&lt; "12) string(string&amp;&amp;): ";
    std::string s12(std::string("C++ by ") + std::string("example"));
    std::cout &lt;&lt; std::quoted(s12) &lt;&lt; '\n'; // "C++ by example"
    
    std::cout &lt;&lt; "15) string(const string&amp; other, size_type pos): ";
    std::string const other15("Mutatis Mutandis");
    std::string s15(other15, 8);
    std::cout &lt;&lt; std::quoted(s15) &lt;&lt; '\n'; // "Mutandis", i.e. [8, 16)
    
    std::cout &lt;&lt; "17) string(const string&amp; other, size_type pos, size_type count): ";
    std::string const other17("Exemplary");
    std::string s17(other17, 0, other17.length() - 1);
    std::cout &lt;&lt; std::quoted(s17) &lt;&lt; '\n'; // "Exemplar"
    
    std::cout &lt;&lt; "19) string(std::initializer_list&lt;CharT&gt;): ";
    std::string s19({'C', '-', 's', 't', 'y', 'l', 'e'});
    std::cout &lt;&lt; std::quoted(s19) &lt;&lt; '\n'; // "C-style"
}
|p=true&lt;!-- due to .capacity() --&gt;
|output=
1)  string(); s1.capacity(): 15
3)  string(size_type count, CharT ch): "===="
4)  string(InputIt first, InputIt last): "C-style string"
6)  string(CharT const* s, size_type count): "C-style"
7)  string(CharT const* s): "C-style"
11) string(string&amp;): "Exemplar"
12) string(string&amp;&amp;): "C++ by example"
15) string(const string&amp; other, size_type pos): "Mutandis"
17) string(const string&amp; other, size_type pos, size_type count): "Exemplar"
19) string(std::initializer_list&lt;CharT&gt;): "C-style"
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=301|std=C++98|before=overload {{v|4}} did not use the parameter&lt;br&gt;{{c|alloc}} if {{tt|InputIt}} is an integral type|after=use that parameter}}
{{dr list item|wg=lwg|dr=438|std=C++98|before=overload {{v|4}} would only call overload {{v|3}}&lt;br&gt;if {{tt|InputIt}} is an integral type|after=calls overload {{v|3}} if {{tt|InputIt}}&lt;br&gt;is not an {{named req|InputIterator}}}}
{{dr list item|wg=lwg|dr=847|std=C++98|before=there was no exception safety guarantee|after=added strong exception safety guarantee}}
{{dr list item|wg=lwg|dr=2193|std=C++11|before=the default constructor is explicit|after=made non-explicit}}
{{dr list item|wg=lwg|dr=2235|std=C++98|before={{c|s}} could be a null pointer value|after=the behavior is undefined in this case}}
{{dr list item|wg=lwg|dr=2250|std=C++98|before=the behavior of overload {{v|17}} was undefined&lt;br&gt;if {{c|pos &gt; other.size()}} is {{c|true}}|after=always throws an&lt;br&gt;exception in this case}}
{{dr list item|wg=lwg|dr=2583|std=C++98|before=there was no way to supply an allocator for overload {{v|17}}|after=added overload {{v|15}}}}
{{dr list item|wg=lwg|dr=2946|std=C++17|before=overload {{v|9}} causes ambiguity in some cases|after=avoided by making it a template}}
{{dr list item|wg=lwg|dr=3076|std=C++17|before=overloads {{v|3,7}} might cause ambiguities&lt;br&gt;in class template argument deduction|after=constrained}}
{{dr list item|wg=lwg|dr=3111|paper=P1148R0|std=C++98|before=the resolution of {{lwg|2235}} made the&lt;br&gt;behavior of {{c|basic_string(nullptr, 0)}} undefined|after=the behavior is well-&lt;br&gt;defined in this case&lt;ref&gt;{{range|nullptr|nullptr + 0}} is a valid empty range, because adding zero to a null pointer value is also [[cpp/language/operator arithmetic#Pointer arithmetic|well-defined]] (the result is still a null pointer value).&lt;/ref&gt;}}
{{dr list end}}
&lt;references/&gt;

===See also===
{{dsc begin}}
{{dsc inc|cpp/string/basic_string/dsc assign}}
{{dsc inc|cpp/string/basic_string/dsc operator{{=}}}}
{{dsc inc|cpp/string/basic_string/dsc to_string}}
{{dsc inc|cpp/string/basic_string/dsc to_wstring}}
{{dsc inc|cpp/string/basic_string_view/dsc constructor}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pl|pt|ru|zh}}