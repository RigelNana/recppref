{{cpp/string/basic_string/title|reserve}}
{{cpp/string/basic_string/navbar}}
{{dcl begin}}
{{dcl rev multi|num=1|until1=c++20
|dcl1=
void reserve( size_type new_cap = 0 );
|dcl2=
constexpr void reserve( size_type new_cap );
}}
{{dcl|num=2|since=c++20|deprecated=c++20|removed=c++26|
void reserve();
}}
{{dcl end}}

@1@ Informs a {{tt|std::basic_string}} object of a planned change in size, so that it can manage the storage allocation appropriately.
* If {{c|new_cap}} is greater than the current {{lc|capacity()}}, new storage is allocated, and {{lc|capacity()}} is made equal or greater than {{c|new_cap}}.
{{rrev multi|until1=c++20|rev1=
* If {{c|new_cap}} is less than the current {{lc|capacity()}}, this is a non-binding shrink request.
* If {{c|new_cap}} is less than the current {{lc|size()}}, this is a non-binding shrink-to-fit request{{rev inl|since=c++11| equivalent to {{lc|shrink_to_fit()}}}}.
|rev2=
* If {{c|new_cap}} is less than or equal to the current {{lc|capacity()}}, there is no effect.
}}

@@ If a capacity change takes place, all iterators and references, including the past-the-end iterator, are invalidated. 

@2@ A non-binding shrink-to-fit request. After this call, {{lc|capacity()}} has an unspecified value greater than or equal to {{lc|size()}}.

===Parameters===
{{par begin}}
{{par|new_cap|new capacity of the string}}
{{par end}}

===Return value===
(none)

===Exceptions===
Throws {{lc|std::length_error}} if {{c|new_cap}} is greater than {{lc|max_size()}}.

May throw any exceptions thrown by {{c|std::allocator_traits&lt;Allocator&gt;::allocate()}}, such as {{lc|std::bad_alloc}}.

{{cpp/strong exception safety guarantee}}

===Complexity===
At most linear in the {{lc|size()}} of the string.

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::string s;
    std::cout &lt;&lt; "1) Initially: " &lt;&lt; s.capacity() &lt;&lt; '\n';
    
    const std::string::size_type new_cap{101u};
    s.reserve(new_cap);
    assert(s.capacity() &gt;= new_cap);
    std::cout &lt;&lt; "2) After reserve(" &lt;&lt; new_cap &lt;&lt; "): " &lt;&lt; s.capacity() &lt;&lt; '\n';
    
    // observing the capacity growth factor
    auto cap{s.capacity()};
    for (int check{}; check != 4; ++check)
    {
        while (cap == s.capacity())
            s += '$';
        cap = s.capacity();
        std::cout &lt;&lt; (3) + check &lt;&lt; ") Capacity: " &lt;&lt; cap &lt;&lt; '\n';
    }
    
//  s.reserve(); // deprecated/removed in C++20/26, use:
    s.shrink_to_fit();
    std::cout &lt;&lt; "7) After shrink_to_fit: " &lt;&lt; s.capacity() &lt;&lt; '\n';
}
|p=true
|output=
1) Initially: 15
2) After reserve(101): 101
3) Capacity: 202
4) Capacity: 404
5) Capacity: 808
6) Capacity: 1616
7) After shrink_to_fit: 809
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=847|std=C++98|before=there was no exception safety guarantee|after=added strong exception safety guarantee}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/string/basic_string/dsc capacity}}
{{dsc inc|cpp/string/basic_string/dsc resize}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}