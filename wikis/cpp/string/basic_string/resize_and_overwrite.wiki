{{cpp/string/basic_string/title|resize_and_overwrite}}
{{cpp/string/basic_string/navbar}}
{{ddcl|since=c++23|
template&lt; class Operation &gt;
constexpr void resize_and_overwrite( size_type count, Operation op );
}}

Resizes the string to contain at most {{c|count}} characters, using the user-provided operation {{c|op}} to modify the possibly indeterminate contents and set the length. This avoids the cost of initializing a suitably-sized {{lc|std::string}} when it is intended to be used as a char array to be populated by, e.g., a C API call.

This function performs the following steps:
# Obtains contiguous storage that contains {{c|count + 1}} characters, and makes its first {{c|k}} characters equal to the first {{c|k}} characters of {{c|*this}}, where {{c|k}} is the smaller of {{c|count}} and the result of {{c|size()}} before the call to {{tt|resize_and_overwrite}}. Let {{c|p}} denote the pointer to the first character in the storage.
#* The equality is determined as if by checking {{c|1=this-&gt;compare(0, k, p, k) == 0}}.
#* The characters in {{closed range|p + k|p + count}} may have indeterminate values.
# Evaluates {{c|std::move(op)(p, count)}}, let {{c|r}} be the return value.
# Replaces the contents of {{c|*this}} with {{range|p|p + r}} (which sets the length of {{c|*this}} to {{c|r}}). Invalidates all pointers and references to the range {{closed range|p|p + count}}.

If {{c|r}} is not of an [[cpp/iterator/is-integer-like|integer-like type]], the program is ill-formed.

If any of the following conditions is satisfied, the behavior is undefined:
* {{c|std::move(op)(p, count)}} throws an exception.
* {{c|std::move(op)(p, count)}} modifies {{c|p}} or {{c|count}}.
* {{c|r}} is not in the range {{closed range|0|count}}.
* Any character in range {{range|p|p + r}} has an indeterminate value.

Implementations are recommended to avoid unnecessary copies and allocations by, e.g., making {{c|p}} equal to the pointer to beginning of storage of characters allocated for {{c|*this}} after the call, which can be identical to the existing storage of {{c|*this}} if {{c|count}} is less than or equal to {{c|capacity()}}.

===Parameters===
{{par begin}}
{{par|count|the maximal possible new size of the string}}
{{par|op|the function object used for setting the new contents of the string}}
{{par end}}

===Exceptions===
{{lc|std::length_error}} if {{c|count &gt; max_size()}}.
Any exceptions thrown by corresponding {{tt|Allocator}}.

If an exception is thrown from {{c|std::move(op)(p, count)}}, the behavior is undefined. Otherwise, if an exception is thrown, this function has no effect.

===Notes===
{{tt|resize_and_overwrite}} invalidates all iterators, pointers, and references into {{c|*this}}, regardless whether reallocation occurs. Implementations may assume that the contents of the string are not aliased after the call to {{tt|resize_and_overwrite}}.

{{feature_test_macro|__cpp_lib_string_resize_and_overwrite|std=C++23|value=202110L|{{tt|std::basic_string::resize_and_overwrite}}}}

===Example===
{{example
|Link to test the example: [https://godbolt.org/z/fbbeYGf5h compiler explorer].
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cstddef&gt;
#include &lt;cstring&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
static_assert(__cpp_lib_string_resize_and_overwrite);

constexpr std::string_view fruits[]{"apple", "banana", "coconut", "date", "elderberry"};

int main()
{
    // A simple case, append only fruits[0]. The string size will be increased.
    std::string s{"Food: "};
    s.resize_and_overwrite(16, [sz = s.size()](char* buf, std::size_t buf_size) noexcept
    {
        const auto to_copy = std::min(buf_size - sz, fruits[0].size());
        std::memcpy(buf + sz, fruits[0].data(), to_copy);
        return sz + to_copy;
    });
    std::cout &lt;&lt; "1. " &lt;&lt; std::quoted(s) &lt;&lt; '\n';
    
    // The size shrinking case. Note, that the user's lambda is always invoked.
    s.resize_and_overwrite(10, [](char* buf, int n) noexcept
    {
        return std::find(buf, buf + n, ':') - buf;
    });
    std::cout &lt;&lt; "2. " &lt;&lt; std::quoted(s) &lt;&lt; '\n';
    
    std::cout &lt;&lt; "3. Copy data until the buffer is full. Print data and sizes.\n";
    std::string food{"Food:"};
    const auto resize_to{27};
    std::cout &lt;&lt; "Initially, food.size: " &lt;&lt; food.size()
              &lt;&lt; ", food.capacity: " &lt;&lt; food.capacity()
              &lt;&lt; ", resize_to: " &lt;&lt; resize_to
              &lt;&lt; ", food: " &lt;&lt; std::quoted(food) &lt;&lt; '\n';
    
    food.resize_and_overwrite
    (
        resize_to,
        [food_size = food.size()](char* p, std::size_t n) noexcept -&gt; std::size_t
        {
            // p[0]..p[n] is the assignable range
            // p[0]..p[min(n, food_size) - 1] is the readable range
            // (contents initially equal to the original string)
            
            // Debug print:
            std::cout &lt;&lt; "In Operation(); n: " &lt;&lt; n &lt;&lt; '\n';
            
            // Copy fruits to the buffer p while there is enough space.
            char* first = p + food_size;
            
            for (char* const end = p + n; const std::string_view fruit : fruits)
            {
                char* last = first + fruit.size() + 1;
                if (last &gt; end)
                    break;
                *first++ = ' ';
                std::ranges::copy(fruit, first);
                first = last;
            }
            
            const auto final_size{static_cast&lt;std::size_t&gt;(first - p)};
            
            // Debug print:
            std::cout &lt;&lt; "In Operation(); final_size: " &lt;&lt; final_size &lt;&lt; '\n';
            
            assert(final_size &lt;= n);
            return final_size; // Return value is the actual new length
                               // of the string, must be in range 0..n
        }
    );
    
    std::cout &lt;&lt; "Finally, food.size: " &lt;&lt; food.size()
              &lt;&lt; ", food.capacity: " &lt;&lt; food.capacity()
              &lt;&lt; ", food: " &lt;&lt; std::quoted(food) &lt;&lt; '\n';
}
|p=true&lt;!-- string capacity policy might vary --&gt;
|output=
1. "Food: apple"
2. "Food"
3. Copy data until the buffer is full. Print data and sizes.
Initially, food.size: 5, food.capacity: 15, resize_to: 27, food: "Food:"
In Operation(); n: 27
In Operation(); final_size: 26
Finally, food.size: 26, food.capacity: 30, food: "Food: apple banana coconut"
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/string/basic_string/dsc resize}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}