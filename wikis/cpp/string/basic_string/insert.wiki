{{cpp/string/basic_string/title|insert}}
{{cpp/string/basic_string/navbar}}
{{dcl begin}}
{{dcl|num=1|notes={{mark constexpr since c++20}}|
basic_string&amp; insert( size_type index, size_type count, CharT ch );
}}
{{dcl|num=2|notes={{mark constexpr since c++20}}|
basic_string&amp; insert( size_type index, const CharT* s );
}}
{{dcl|num=3|notes={{mark constexpr since c++20}}|
basic_string&amp; insert( size_type index, const CharT* s, size_type count );
}}
{{dcl|num=4|notes={{mark constexpr since c++20}}|
basic_string&amp; insert( size_type index, const basic_string&amp; str );
}}
{{dcl rev multi|num=5
|dcl1=
basic_string&amp; insert( size_type index, const basic_string&amp; str,
                      size_type s_index, size_type count );
|since2=c++14|notes2={{mark constexpr since c++20}}|dcl2=
basic_string&amp; insert( size_type index, const basic_string&amp; str,
                      size_type s_index, size_type count = npos );
}}
{{dcl rev multi|num=6
|dcl1=
iterator insert( iterator pos, CharT ch );
|since2=c++11|notes2={{mark constexpr since c++20}}|dcl2=
iterator insert( const_iterator pos, CharT ch );
}}
{{dcl rev multi|num=7
|dcl1=
void insert( iterator pos, size_type count, CharT ch );
|since2=c++11|notes2={{mark constexpr since c++20}}|dcl2=
iterator insert( const_iterator pos, size_type count, CharT ch );
}}
{{dcl rev multi|num=8
|dcl1=
template&lt; class InputIt &gt;
void insert( iterator pos, InputIt first, InputIt last );
|since2=c++11|notes2={{mark constexpr since c++20}}|dcl2=
template&lt; class InputIt &gt;
iterator insert( const_iterator pos, InputIt first, InputIt last );
}}
{{dcl|num=9|since=c++11|notes={{mark constexpr since c++20}}|
iterator insert( const_iterator pos, std::initializer_list&lt;CharT&gt; ilist );
}}
{{dcl|num=10|since=c++17|notes={{mark constexpr since c++20}}|
template&lt; class StringViewLike &gt;
basic_string&amp; insert( size_type index, const StringViewLike&amp; t );
}}
{{dcl|num=11|since=c++17|notes={{mark constexpr since c++20}}|1=
template&lt; class StringViewLike &gt;
basic_string&amp; insert( size_type index, const StringViewLike&amp; t,
                      size_type t_index, size_type count = npos );
}}
{{dcl end}}

Inserts characters into the string.

@1@ Inserts {{c|count}} copies of character {{c|ch}} at the position {{c|index}}.

@2@ Inserts null-terminated character string pointed to by {{c|s}} at the position {{c|index}}. The length of the string is determined by the first null character using {{c|Traits::length(s)}}. 

@3@ Inserts the characters in the range {{range|s|s + count}} at the position {{c|index}}. The range can contain null characters.

@4@ Inserts string {{c|str}} at the position {{c|index}}.

@5@ Inserts a string, obtained by {{c|str.substr(s_index, count)}} at the position {{c|index}}.

@6@ Inserts character {{c|ch}} before the character pointed by {{c|pos}}.

@7@ Inserts {{c|count}} copies of character {{c|ch}} before the element (if any) pointed by {{c|pos}}.

@8@ Inserts characters from the range {{range|first|last}} before the element (if any) pointed by {{c|pos}}, as if by {{c|insert(pos - begin(), basic_string(first, last, get_allocator()))}}.
{{rrev|since=c++11|
This overload does not participate in overload resolution if {{tt|InputIt}} does not satisfy {{named req|InputIterator}}.
}}

@9@ Inserts elements from initializer list {{c|ilist}} before the element (if any) pointed by {{c|pos}}.

@10@ {{cpp/string/sv hack|inserts the elements from {{c|sv}} before the element (if any) pointed by {{c|index}}, as if by {{c|insert(index, sv.data(), sv.size())}}}}

@11@ {{cpp/string/sv hack|inserts, before the element (if any) pointed by {{c|index}}, the characters from the subview {{range|t_index|t_index + count}} of {{c|sv}}.
* If the requested subview lasts past the end of {{c|sv}}, or if {{c|1=count == npos}}, the resulting subview is {{range|t_index|sv.size()}}.
* If {{c|t_index &gt; sv.size()}}, or if {{c|index &gt; size()}}, {{lc|std::out_of_range}} is thrown}}

If {{c|pos}} is not a valid iterator on {{c|*this}}, the behavior is undefined. 

===Parameters===
{{par begin}}
{{par|index|position at which the content will be inserted}}
{{par|pos|iterator before which the characters will be inserted}}
{{par|ch|character to insert}}
{{par|count|number of characters to insert}}
{{par|s|pointer to the character string to insert}}
{{par|str|string to insert}}
{{par|first, last|range defining characters to insert}}
{{par|s_index|position of the first character in {{c|str}} to insert}}
{{par|ilist|{{lc|std::initializer_list}} to insert the characters from}}
{{par|t|object (convertible to {{lc|std::basic_string_view}}) to insert the characters from}}
{{par|t_index|position of the first character in {{c|t}} to insert}}
{{par hreq}}
{{par req named|InputIt|InputIterator}}
{{par end}}

===Return value===
@1-5@ {{c|*this}}

@6-9@ An iterator which refers to the copy of the first inserted character or {{c|pos}} if no characters were inserted ({{c|1=count == 0}} or {{c|1=first == last}} or {{c|1=ilist.size() == 0}})

@10,11@ {{c|*this}}

===Exceptions===
@1-4,10@ Throws {{lc|std::out_of_range}} if {{c|index &gt; size()}}.
@5@ Throws {{lc|std::out_of_range}} if {{c|index &gt; size()}} or if {{c|s_index &gt; str.size()}}.
@11@ Throws {{lc|std::out_of_range}} if {{c|index &gt; size()}} or if {{c|t_index &gt; sv.size()}}.

In all cases, throws {{lc|std::length_error}} if {{c|size() + ins_count &gt; max_size()}} where {{c|ins_count}} is the number of characters that will be inserted.

{{rrev|since=c++20|
In all cases, if {{c/core|std::allocator_traits&lt;Allocator&gt;::allocate}} throws an exception, it is rethrown.
}}

{{cpp/strong exception safety guarantee}}

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;

using namespace std::string_literals;

int main()
{
    std::string s = "xmplr";
    
    // insert(size_type index, size_type count, char ch)
    s.insert(0, 1, 'E');
    assert("Exmplr" == s);
    
    // insert(size_type index, const char* s)
    s.insert(2, "e");
    assert("Exemplr" == s);
    
    // insert(size_type index, string const&amp; str)
    s.insert(6, "a"s);
    assert("Exemplar" == s);
    
    // insert(size_type index, string const&amp; str,
    //        size_type s_index, size_type count)
    s.insert(8, " is an example string."s, 0, 14);
    assert("Exemplar is an example" == s);
    
    // insert(const_iterator pos, char ch)
    s.insert(s.cbegin() + s.find_first_of('n') + 1, ':');
    assert("Exemplar is an: example" == s);
    
    // insert(const_iterator pos, size_type count, char ch)
    s.insert(s.cbegin() + s.find_first_of(':') + 1, 2, '=');
    assert("Exemplar is an:== example" == s);
    
    // insert(const_iterator pos, InputIt first, InputIt last)
    {
        std::string seq = " string";
        s.insert(s.begin() + s.find_last_of('e') + 1,
            std::begin(seq), std::end(seq));
        assert("Exemplar is an:== example string" == s);
    }
    
    // insert(const_iterator pos, std::initializer_list&lt;char&gt;)
    s.insert(s.cbegin() + s.find_first_of('g') + 1, {'.'});
    assert("Exemplar is an:== example string." == s);
}
|output=
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=7|std=C++98|before=overload {{v|8}} referred to a non-existing overload|after=refers to overload {{v|4}} correctly}}
{{dr list item|wg=lwg|dr=847|std=C++98|before=there was no exception safety guarantee|after=added strong exception safety guarantee}}
{{dr list item|wg=lwg|dr=2946|std=C++17|before=overload {{v|10}} caused ambiguity in some cases|after=avoided by making it a template}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/string/basic_string/dsc insert_range}}
{{dsc inc|cpp/string/basic_string/dsc append}}
{{dsc inc|cpp/string/basic_string/dsc push_back}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}