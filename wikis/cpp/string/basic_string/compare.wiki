{{cpp/string/basic_string/title|compare}}
{{cpp/string/basic_string/navbar}}
{{dcl begin}}
{{dcla|num=1|noexcept=c++11|constexpr=c++20|1=
int compare( const basic_string&amp; str ) const;
}}
{{dcla|anchor=no|num=2|constexpr=c++20|
int compare( size_type pos1, size_type count1,
             const basic_string&amp; str ) const;
}}
{{dcl rev multi|num=3
|dcl1=
int compare( size_type pos1, size_type count1,
             const basic_string&amp; str,
             size_type pos2, size_type count2 ) const;
|since2=c++14|notes2={{mark constexpr since c++20}}|dcl2=
int compare( size_type pos1, size_type count1,
             const basic_string&amp; str,
             size_type pos2, size_type count2 = npos ) const;
}}
{{dcla|anchor=no|num=4|constexpr=c++20|
int compare( const CharT* s ) const;
}}
{{dcla|anchor=no|num=5|constexpr=c++20|
int compare( size_type pos1, size_type count1,
             const CharT* s ) const;
}}
{{dcla|anchor=no|num=6|constexpr=c++20|
int compare( size_type pos1, size_type count1,
             const CharT* s, size_type count2 ) const;
}}
{{dcla|anchor=no|num=7|since=c++17|constexpr=c++20|
template&lt; class StringViewLike &gt;
int compare( const StringViewLike&amp; t ) const noexcept(/* see below */);
}}
{{dcla|anchor=no|num=8|since=c++17|constexpr=c++20|
template&lt; class StringViewLike &gt;
int compare( size_type pos1, size_type count1,
             const StringViewLike&amp; t ) const;
}}
{{dcla|anchor=no|num=9|since=c++17|constexpr=c++20|1=
template&lt; class StringViewLike &gt;
int compare( size_type pos1, size_type count1,
             const StringViewLike&amp; t,
             size_type pos2, size_type count2 = npos) const;
}}
{{dcl end}}

Compares two character sequences.

@1@ Compares this string to {{c|str}}.

@2@ Compares a {{range|pos1|pos1 + count1}} substring of this string to {{c|str}}.
* If {{c|count1 &gt; size() - pos1}}, the substring is {{range|pos1|size()}}.

@3@ Compares a {{range|pos1|pos1 + count1}} substring of this string to a substring {{range|pos2|pos2 + count2}} of {{c|str}}.
* If {{c|count1 &gt; size() - pos1}}, the first substring is {{range|pos1|size()}}.
* If {{c|count2 &gt; str.size() - pos2}}, the second substring is {{range|pos2|str.size()}}.

@4@ Compares this string to the null-terminated character sequence beginning at the character pointed to by {{c|s}} with length {{c|Traits::length(s)}}.

@5@ Compares a {{range|pos1|pos1 + count1}} substring of this string to the null-terminated character sequence beginning at the character pointed to by {{c|s}} with length {{c|Traits::length(s)}}.
* If {{c|count1 &gt; size() - pos1}}, the substring is {{range|pos1|size()}}.

@6@ Compares a {{range|pos1|pos1 + count1}} substring of this string to the characters in the range {{range|s|s + count2}}. The characters in {{range|s|s + count2}} may include null characters.
* If {{c|count1 &gt; size() - pos1}}, the substring is {{range|pos1|size()}}.

@7-9@ {{cpp/string/sv hack|plural=yes|
:@7@ compares this string to {{c|sv}};
:@8@ compares a {{range|pos1|pos1 + count1}} substring of this string to {{c|sv}}, as if by {{c|std::basic_string_view&lt;CharT, Traits&gt;(*this).substr(pos1, count1).compare(sv)}};
:@9@ compares a {{range|pos1|pos1 + count1}} substring of this string to a substring {{range|pos2|pos2 + count2}} of {{c|sv}}, as if by {{c multi|
std::basic_string_view&lt;CharT, Traits&gt;(*this)|
    .substr(pos1, count1).compare(sv.substr(pos2, count2))}}}}.

A character sequence consisting of {{c|count1}} characters starting at {{c|data1}} is compared to a character sequence consisting of {{c|count2}} characters starting at {{c|data2}} as follows:
* First, calculate the number of characters to compare, as if by {{c|1=size_type rlen = std::min(count1, count2)}}.
* Then compare the sequences by calling {{c|Traits::compare(data1, data2, rlen)}}. For standard strings this function performs character-by-character lexicographical comparison. If the result is zero (the character sequences are equal so far), then their sizes are compared as follows:

{|class="wikitable" style="text-align:center;"
!colspan=2|Condition
!Result
!Return value
|-
|colspan=2 style="text-align:left;"|{{tt|Traits::compare({{spar|data1}}, {{spar|data2}}, {{spar|rlen}}) &lt; 0}}
|{{spar|data1}} is ''less'' than {{spar|data2}}
|{{c|&lt;0}}
|-
|rowspan=3|{{tt|Traits::compare({{spar|data1}}, {{spar|data2}}, {{spar|rlen}}) {{==}} 0}}
|{{spar|size1}} &lt; {{spar|size2}}
|{{spar|data1}} is ''less'' than {{spar|data2}}
|{{c|&lt;0}}
|-
&lt;!----&gt;
|{{spar|size1}} {{==}} {{spar|size2}}
|{{spar|data1}} is ''equal'' to {{spar|data2}}
|{{c|0}}
|-
&lt;!----&gt;
|{{spar|size1}} &gt; {{spar|size2}}
|{{spar|data1}} is ''greater'' than {{spar|data2}}
|{{c|&gt;0}}
|-
|colspan=2 style="text-align:left;"|{{tt|Traits::compare({{spar|data1}}, {{spar|data2}}, {{spar|rlen}}) &gt; 0}}
|{{spar|data1}} is ''greater'' than {{spar|data2}}
|{{c|&gt;0}}
|}

===Parameters===
{{par begin}}
{{par|str|other string to compare to}}
{{par|s|pointer to the character string to compare to}}
{{par|count1|number of characters of this string to compare}}
{{par|pos1|position of the first character in this string to compare}}
{{par|count2|number of characters of the given string to compare}}
{{par|pos2|position of the first character of the given string to compare}}
{{par|t|object (convertible to {{lc|std::basic_string_view}}) to compare to}}
{{par end}}

===Return value===
* Negative value if {{c|*this}} appears before the character sequence specified by the arguments, in lexicographical order.
* Zero if both character sequences compare equivalent.
* Positive value if {{c|*this}} appears after the character sequence specified by the arguments, in lexicographical order.

===Exceptions===
The overloads taking parameters named {{c|pos1}} or {{c|pos2}} throws {{lc|std::out_of_range}} if the argument is out of range.

@7@ {{noexcept|std::is_nothrow_convertible_v&lt;const T&amp;, std::basic_string_view&lt;CharT, Traits&gt;&gt;}}
@8,9@ Throws anything thrown by the conversion to {{lc|std::basic_string_view}}.

{{cpp/strong exception safety guarantee}}

===Possible implementation===
{{eq impl
|title1=overload (1)|ver1=1|1=
template&lt;class CharT, class Traits, class Alloc&gt;
int std::basic_string&lt;CharT, Traits, Alloc&gt;::compare
    (const std::basic_string&amp; s) const noexcept
{
    size_type lhs_sz = size();
    size_type rhs_sz = s.size();
    int result = traits_type::compare(data(), s.data(), std::min(lhs_sz, rhs_sz));
    if (result != 0)
        return result;
    if (lhs_sz &lt; rhs_sz)
        return -1;
    if (lhs_sz &gt; rhs_sz)
        return 1;
    return 0;
}
}}

===Notes===
For the situations when three-way comparison is not required, {{lc|std::basic_string}} provides the usual {{rlp|operator cmp|relational operators}} ({{tt|&lt;}}, {{tt|1=&lt;=}}, {{tt|1===}}, {{tt|&gt;}}, etc).

By default (with the default {{lc|std::char_traits}}), this function is not locale-sensitive. See {{lc|std::collate::compare}} for locale-aware three-way string comparison.

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;

void print_compare_result(std::string_view str1,
                          std::string_view str2,
                          int compare_result)
{
    if (compare_result &lt; 0)
        std::cout &lt;&lt; std::quoted(str1) &lt;&lt; " comes before "
                  &lt;&lt; std::quoted(str2) &lt;&lt; ".\n";
    else if (compare_result &gt; 0)
        std::cout &lt;&lt; std::quoted(str2) &lt;&lt; " comes before "
                  &lt;&lt; std::quoted(str1) &lt;&lt; ".\n";
    else
        std::cout &lt;&lt; std::quoted(str1) &lt;&lt; " and "
                  &lt;&lt; std::quoted(str2) &lt;&lt; " are the same.\n";
}

int main()
{
    std::string batman{"Batman"};
    std::string superman{"Superman"};
    int compare_result{0};
    
    // 1) Compare with other string
    compare_result = batman.compare(superman);
    std::cout &lt;&lt; "1) ";
    print_compare_result("Batman", "Superman", compare_result);
    
    // 2) Compare substring with other string
    compare_result = batman.compare(3, 3, superman);
    std::cout &lt;&lt; "2) ";
    print_compare_result("man", "Superman", compare_result);
    
    // 3) Compare substring with other substring
    compare_result = batman.compare(3, 3, superman, 5, 3);
    std::cout &lt;&lt; "3) ";
    print_compare_result("man", "man", compare_result);
    
    // Compare substring with other substring
    // defaulting to end of other string
    assert(compare_result == batman.compare(3, 3, superman, 5));
    
    // 4) Compare with char pointer
    compare_result = batman.compare("Superman");
    std::cout &lt;&lt; "4) ";
    print_compare_result("Batman", "Superman", compare_result);
    
    // 5) Compare substring with char pointer
    compare_result = batman.compare(3, 3, "Superman");
    std::cout &lt;&lt; "5) ";
    print_compare_result("man", "Superman", compare_result);
    
    // 6) Compare substring with char pointer substring
    compare_result = batman.compare(0, 3, "Superman", 5);
    std::cout &lt;&lt; "6) ";
    print_compare_result("Bat", "Super", compare_result);
}
|output=
1) "Batman" comes before "Superman".
2) "Superman" comes before "man".
3) "man" and "man" are the same.
4) "Batman" comes before "Superman".
5) "Superman" comes before "man".
6) "Bat" comes before "Super".
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=5|std=C++98|before=the parameter {{c|count2}} of overload {{v|6}}&lt;br&gt;had a default argument {{c|npos}}|after=default argument removed,&lt;br&gt;split to overloads {{v|5}} and {{v|6}}}}
{{dr list item|wg=lwg|dr=847|std=C++98|before=there was no exception safety guarantee|after=added strong exception safety guarantee}}
{{dr list item|wg=lwg|dr=2946|std=C++17|before=overload {{v|7}} caused ambiguity in some cases|after=avoided by making it a template}}
{{dr list item|paper=P1148R0|std=C++17|before=noexcept for overload {{v|7}} was accidentally&lt;br&gt;dropped by the resolution of LWG2946|after=restored}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/string/basic_string/dsc operator cmp}}
{{dsc inc|cpp/string/basic_string/dsc substr}}
{{dsc inc|cpp/locale/dsc collate}}
{{dsc inc|cpp/string/byte/dsc strcoll}}
{{dsc inc|cpp/algorithm/dsc lexicographical_compare}}
{{dsc inc|cpp/string/basic_string_view/dsc compare}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pl|pt|ru|zh}}