{{cpp/title|operator+{{small|(std::basic_string)}}}}
{{cpp/string/basic_string/navbar}}
{{dcl begin}}
{{dcl header|string}}
{{dcla|num=1|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; lhs,
               const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; rhs );
}}
{{dcl|num=2|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; lhs,
               const CharT* rhs );
}}
{{dcl|num=3|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; lhs,
               CharT rhs );
}}
{{dcla|num=4|since=c++26|1=
template&lt; class CharT, class Traits, class Alloc &gt;
constexpr std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; lhs,
               std::type_identity_t&lt;std::basic_string_view&lt;CharT,Traits&gt;&gt; rhs );
}}
{{dcl|num=5|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( const CharT* lhs,
               const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; rhs );
}}
{{dcl|num=6|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( CharT lhs,
               const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; rhs );
}}
{{dcla|num=7|since=c++26|1=
template&lt; class CharT, class Traits, class Alloc &gt;
constexpr std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( std::type_identity_t&lt;std::basic_string_view&lt;CharT,Traits&gt;&gt; lhs,
               const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; rhs );
}}
{{dcla|num=8|since=c++11|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; lhs,
               std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; rhs );
}}
{{dcl|num=9|since=c++11|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; lhs,
               const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; rhs );
}}
{{dcl|num=10|since=c++11|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; lhs,
               const CharT* rhs );
}}
{{dcl|num=11|since=c++11|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; lhs,
               CharT rhs );
}}
{{dcla|num=12|since=c++26|1=
template&lt; class CharT, class Traits, class Alloc &gt;
constexpr std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; lhs,
               std::type_identity_t&lt;std::basic_string_view&lt;CharT,Traits&gt;&gt; rhs );
}}
{{dcl|num=13|since=c++11|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( const std::basic_string&lt;CharT,Traits,Alloc&gt;&amp; lhs,
               std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; rhs );
}}
{{dcl|num=14|since=c++11|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( const CharT* lhs,
               std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; rhs );
}}
{{dcl|num=15|since=c++11|notes={{mark constexpr since c++20}}|1=
template&lt; class CharT, class Traits, class Alloc &gt;
std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( CharT lhs,
               std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; rhs );
}}
{{dcla|num=16|since=c++26|1=
template&lt; class CharT, class Traits, class Alloc &gt;
constexpr std::basic_string&lt;CharT,Traits,Alloc&gt;
    operator+( std::type_identity_t&lt;std::basic_string_view&lt;CharT,Traits&gt;&gt; lhs,
               std::basic_string&lt;CharT,Traits,Alloc&gt;&amp;&amp; rhs );
}}
{{dcl end}}

Returns a string containing characters from {{c|lhs}} followed by the characters from {{c|rhs}}. Equivalent to:

@1,2@ {{c|1=std::basic_string&lt;CharT, Traits, Allocator&gt; r = lhs; r.append(rhs); return r;}}
@3@ {{c|1=std::basic_string&lt;CharT, Traits, Allocator&gt; r = lhs; r.push_back(rhs); return r;}}
@4@ {{c|1=std::basic_string&lt;CharT, Traits, Allocator&gt; r = lhs; r.append(rhs); return r;}}
@5@ {{c|1=std::basic_string&lt;CharT, Traits, Allocator&gt; r = rhs; r.insert(0, lhs); return r;}}
@6@ {{c|1=std::basic_string&lt;CharT, Traits, Allocator&gt; r = rhs; r.insert(r.begin(), lhs); return r;}}
@7@ {{c|1=std::basic_string&lt;CharT, Traits, Allocator&gt; r = rhs; r.insert(0, lhs); return r;}}
@8@ {{c|1=lhs.append(rhs); return std::move(lhs);}} except that both {{c|lhs}} and {{c|rhs}} are left in valid but unspecified states. If {{c|lhs}} and {{c|rhs}} have equal allocators, the implementation can move from either.
@9,10@ {{c|1=lhs.append(rhs); return std::move(lhs);}}
@11@ {{c|1=lhs.push_back(rhs); return std::move(lhs);}}
@12@ {{c|1=lhs.append(rhs); return std::move(lhs);}}
@13,14@ {{c|1=rhs.insert(0, lhs); return std::move(rhs);}}
@15@ {{c|1=rhs.insert(rhs.begin(), lhs); return std::move(rhs);}}
@16@ {{c|1=rhs.insert(0, lhs); return std::move(rhs);}}

{{rrev|since=c++11|
The allocator used for the result is:
@1-4@ {{c|std::allocator_traits&lt;Alloc&gt;::select_on_container_copy_construction(lhs.get_allocator())
}}
@5-7@ {{c|std::allocator_traits&lt;Alloc&gt;::select_on_container_copy_construction(rhs.get_allocator())
}}
@8-12@ {{c|lhs.get_allocator()}}
@13-16@ {{c|rhs.get_allocator()}}

In other words:
* If one operand is a {{tt|basic_string}} rvalue, its allocator is used.
* Otherwise, {{tt|select_on_container_copy_construction}} is used on the allocator of the lvalue {{tt|basic_string}} operand.
In each case, the left operand is preferred when both are {{tt|basic_string}}s of the same value category.

For {{vl|8-16}}, all rvalue {{tt|basic_string}} operands are left in valid but unspecified states.
}}

===Parameters===
{{par begin}}
{{par|lhs|string{{rev inl|since=c++26|, string view}}, character, or pointer to the first character in a null-terminated array}}
{{par|rhs|string{{rev inl|since=c++26|, string view}}, character, or pointer to the first character in a null-terminated array}}
{{par end}}

===Return value===
A string containing characters from {{c|lhs}} followed by the characters from {{c|rhs}}{{rev inl|since=c++11|, using the allocator determined as above}}.

{{rrev|since=c++11|1=
===Notes===
{{tt|operator+}} should be used with great caution when stateful allocators are involved{{rev inl|since=c++17| (such as when {{lc|std::pmr::string}} is used)}}. Prior to {{wg21|P1165R1}}, the allocator used for the result was determined by historical accident and can vary from overload to overload for no apparent reason. Moreover, for {{vl|1-5}}, the allocator propagation behavior varies across major standard library implementations and differs from the behavior depicted in the standard.

Because the allocator used by the result of {{tt|operator+}} is sensitive to value category, {{tt|operator+}} is not associative with respect to allocator propagation:

{{source|1=
using my_string = std::basic_string&lt;char, std::char_traits&lt;char&gt;, my_allocator&lt;char&gt;&gt;;
my_string cat();
const my_string&amp; dog();

my_string meow = /* ... */, woof = /* ... */;
meow + cat() + /* ... */; // uses select_on_container_copy_construction on meow's allocator
woof + dog() + /* ... */; // uses allocator of dog()'s return value instead

meow + woof + meow; // uses select_on_container_copy_construction on meow's allocator
meow + (woof + meow); // uses SOCCC on woof's allocator instead
}}

For a chain of {{tt|operator+}} invocations, the allocator used for the ultimate result may be controlled by prepending an rvalue {{tt|basic_string}} with the desired allocator:

{{source|1=
// use my_favorite_allocator for the final result
my_string(my_favorite_allocator) + meow + woof + cat() + dog();
}}

For better and portable control over allocators, member functions like {{rlpt|append}}, {{rlpt|insert}}, and {{rlpt|1=operator+=}} should be used on a result string constructed with the desired allocator.
}}

{{rrev|since=c++26|1=
The usage of {{c/core|std::type_identity_t}} as parameter in overloads {{vl|4}}, {{vl|7}}, {{vl|12}}, and {{vl|16}} ensures that an object of type {{c/core|std::basic_string&lt;CharT, Traits, Allocator&gt;}} can always be concatenated to an object of a type {{tt|T}} with an implicit conversion to {{c/core|std::basic_string_view&lt;CharT, Traits&gt;}}, and vice versa, as per [[cpp/language/overload_resolution#Call to an overloaded operator|overload resolution]] rules&lt;!--[over.match.oper]--&gt;.

{{ftm begin}}
{{ftm|__cpp_lib_string_view|std=C++26|value=202403|Concatenation of strings and string views, overloads {{vl|4}}, {{vl|7}}, {{vl|12}}, {{vl|16}}}}
{{ftm end}}
}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;

int main()
{
    std::string s1 = "Hello";
    std::string s2 = "world";
    const char* end = "!\n";
    std::cout &lt;&lt; s1 + ' ' + s2 + end;

    std::string_view water{" Water"};
    #if __cpp_lib_string_view &gt;= 202403
    std::cout &lt;&lt; s1 + water + s2 &lt;&lt; end; // overload (4), then (1)
    #else
    std::cout &lt;&lt; s1 + std::string(water) + s2 &lt;&lt; end; // OK, but less efficient
    #endif
}
|output=
Hello world!
Hello Waterworld!
}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P1165R1|std=C++11|before=allocator propagation is haphazard and inconsistent|after=made more consistent}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/string/basic_string/dsc operator+{{=}}}}
{{dsc inc|cpp/string/basic_string/dsc append}}
{{dsc inc|cpp/string/basic_string/dsc insert}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}