{{cpp/title|mblen}}
{{cpp/string/multibyte/navbar}}
{{ddcl|header=cstdlib|
int mblen( const char* s, std::size_t n );
}}

Determines the size, in bytes, of the multibyte character whose first byte is pointed to by {{c|s}}.

If {{c|s}} is a null pointer, resets the global conversion state and determines whether shift sequences are used.

This function is equivalent to the call {{c|std::mbtowc(nullptr, s, n)}}, except that conversion state of {{lc|std::mbtowc}} is unaffected.

===Notes===
Each call to {{tt|mblen}} updates the internal global conversion state (a static object of type {{lc|std::mbstate_t}}, only known to this function). If the multibyte encoding uses shift states, care must be taken to avoid backtracking or multiple scans. In any case, multiple threads should not call {{tt|mblen}} without synchronization: {{lc|std::mbrlen}} may be used instead.

===Parameters===
{{par begin}}
{{par|s|pointer to the multibyte character}}
{{par|n|limit on the number of bytes in s that can be examined}}
{{par end}}

===Return value===
If {{c|s}} is not a null pointer, returns the number of bytes that are contained in the multibyte character or {{c|-1}} if the first bytes pointed to by {{c|s}} do not form a valid multibyte character or {{c|0}} if {{c|s}} is pointing at the null character {{c|'\0'}}.

If {{c|s}} is a null pointer, resets its internal conversion state to represent the initial shift state and returns {{c|0}} if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).

===Example===
{{example
|code=
#include &lt;clocale&gt;
#include &lt;cstdlib&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;string_view&gt;

// the number of characters in a multibyte string is the sum of mblen()'s
// note: the simpler approach is std::mbstowcs(nullptr, s.c_str(), s.size())
std::size_t strlen_mb(const std::string_view s)
{
    std::mblen(nullptr, 0); // reset the conversion state
    std::size_t result = 0;
    const char* ptr = s.data();
    for (const char* const end = ptr + s.size(); ptr &lt; end; ++result)
    {
        const int next = std::mblen(ptr, end - ptr);
        if (next == -1)
            throw std::runtime_error("strlen_mb(): conversion error");
        ptr += next;
    }
    return result;
}

void dump_bytes(const std::string_view str)
{
    std::cout &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; std::setfill('0');
    for (unsigned char c : str)
        std::cout &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;int&gt;(c) &lt;&lt; ' ';
    std::cout &lt;&lt; std::dec &lt;&lt; '\n';
}

int main()
{
    // allow mblen() to work with UTF-8 multibyte encoding
    std::setlocale(LC_ALL, "en_US.utf8");
    // UTF-8 narrow multibyte encoding
    const std::string_view str = "z\u00df\u6c34\U0001f34c"; // or u8"z√üÊ∞¥üçå"
    std::cout &lt;&lt; std::quoted(str) &lt;&lt; " is " &lt;&lt; strlen_mb(str)
              &lt;&lt; " characters, but as much as " &lt;&lt; str.size() &lt;&lt; " bytes: ";
    dump_bytes(str);
}
|p=true
|output=
"z√üÊ∞¥üçå" is 4 characters, but as much as 10 bytes: 7A C3 9F E6 B0 B4 F0 9F 8D 8C
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/string/multibyte/dsc mbtowc}}
{{dsc inc|cpp/string/multibyte/dsc mbrlen}}
{{dsc see c|c/string/multibyte/mblen}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}