{{cpp/title|mbrtoc32}}
{{cpp/string/multibyte/navbar}}
{{ddcl|header=cuchar|since=c++11|
std::size_t mbrtoc32( char32_t* pc32,
                      const char* s,
                      std::size_t n,
                      std::mbstate_t* ps );
}}

Converts a narrow multibyte character to its UTF-32 character representation.

If {{c|s}} is not a null pointer, inspects at most {{c|n}} bytes of the multibyte character string, beginning with the byte pointed to by {{c|s}} to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in {{c|s}} is complete and valid, converts it to the corresponding 32-bit character and stores it in {{c|*pc32}} (if {{c|pc32}} is not null).

If the multibyte character in {{c|*s}} corresponds to a multi-char32_t sequence (not possible with UTF-32), then after the first call to this function, {{c|*ps}} is updated in such a way that the next calls to {{tt|mbrtoc32}} will write out the additional {{c/core|char32_t}}, without considering {{c|*s}}.

If {{c|s}} is a null pointer, the values of {{c|n}} and {{c|pc32}} are ignored and the call is equivalent to {{c|std::mbrtoc32(nullptr, "", 1, ps)}}.

If the wide character produced is the null character, the conversion state {{c|*ps}} represents the initial shift state.

The multibyte encoding used by this function is specified by the currently active C locale.

===Parameters===
{{par begin}}
{{par|pc32|pointer to the location where the resulting 32-bit character will be written}}
{{par|s|pointer to the multibyte character string used as input}}
{{par|n|limit on the number of bytes in s that can be examined}}
{{par|ps|pointer to the conversion state object used when interpreting the multibyte string}}
{{par end}}

===Return value===
The first of the following that applies:
* {{c|0}} if the character converted from {{c|s}} (and stored in {{c|*pc32}} if non-null) was the null character.
* the number of bytes {{c|[1...n]}} of the multibyte character successfully converted from {{c|s}}.
* {{c|-3}} if the next {{c/core|char32_t}} from a multi-{{c/core|char32_t}} character has now been written to {{c|*pc32}}. No bytes are processed from the input in this case.
* {{c|-2}} if the next {{c|n}} bytes constitute an incomplete, but so far valid, multibyte character. Nothing is written to {{c|*pc32}}.
* {{c|-1}} if encoding error occurs. Nothing is written to {{c|*pc32}}, the value {{lc|EILSEQ}} is stored in {{lc|errno}} and the value of {{c|*ps}} is unspecified.

===Examples===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;clocale&gt;
#include &lt;cstring&gt;
#include &lt;cuchar&gt;
#include &lt;cwchar&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;

int main()
{
    std::setlocale(LC_ALL, "en_US.utf8");

    std::string str = "z\u00df\u6c34\U0001F34C"; // or u8"z√üÊ∞¥üçå"

    std::cout &lt;&lt; "Processing " &lt;&lt; str.size() &lt;&lt; " bytes: [ " &lt;&lt; std::showbase;
    for (unsigned char c : str)
        std::cout &lt;&lt; std::hex &lt;&lt; +c &lt;&lt; ' ';
    std::cout &lt;&lt; "]\n";

    std::mbstate_t state{}; // zero-initialized to initial state
    char32_t c32;
    const char* ptr = str.c_str(), *end = str.c_str() + str.size() + 1;

    while (std::size_t rc = std::mbrtoc32(&amp;c32, ptr, end - ptr, &amp;state))
    {
        std::cout &lt;&lt; "Next UTF-32 char: " &lt;&lt; std::hex
                  &lt;&lt; static_cast&lt;int&gt;(c32) &lt;&lt; " obtained from ";
        assert(rc != (std::size_t) - 3); // no surrogates in UTF-32
        if (rc == (std::size_t) - 1)
            break;
        if (rc == (std::size_t) - 2)
            break;
        std::cout &lt;&lt; std::dec &lt;&lt; rc &lt;&lt; " bytes [ ";
        for (std::size_t n = 0; n &lt; rc; ++n)
            std::cout &lt;&lt; std::hex &lt;&lt; +static_cast&lt;unsigned char&gt;(ptr[n]) &lt;&lt; ' ';
        std::cout &lt;&lt; "]\n";
        ptr += rc;
    }
}
|output=
Processing 10 bytes: [ 0x7a 0xc3 0x9f 0xe6 0xb0 0xb4 0xf0 0x9f 0x8d 0x8c ]
Next UTF-32 char: 0x7a obtained from 1 bytes [ 0x7a ]
Next UTF-32 char: 0xdf obtained from 2 bytes [ 0xc3 0x9f ]
Next UTF-32 char: 0x6c34 obtained from 3 bytes [ 0xe6 0xb0 0xb4 ]
Next UTF-32 char: 0x1f34c obtained from 4 bytes [ 0xf0 0x9f 0x8d 0x8c ]
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/string/multibyte/dsc c32rtomb}}
{{dsc inc|cpp/locale/codecvt/dsc do_in|mem=std::codecvt&lt;char32_t, char, std::mbstate_t&gt;}}
{{dsc see c|c/string/multibyte/mbrtoc32}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}