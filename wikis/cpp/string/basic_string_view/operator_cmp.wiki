{{title|1=operator==,!=,&lt;,&lt;=,&gt;,&gt;=,&lt;=&gt;{{small|(std::basic_string_view)}}}}
{{cpp/string/basic_string_view/navbar}}
{{dcl begin}}
{{dcl header|string_view}}
{{dcl rev multi|num=1
|since1=c++17|dcl1=
template&lt; class CharT, class Traits &gt;
constexpr bool operator==( std::basic_string_view&lt;CharT,Traits&gt; lhs,
                           std::basic_string_view&lt;CharT,Traits&gt; rhs ) noexcept;
|since2=c++20|dcl2=
template&lt; class CharT, class Traits &gt;
constexpr bool operator==(
    std::basic_string_view&lt;CharT,Traits&gt; lhs,
    std::type_identity_t&lt;std::basic_string_view&lt;CharT,Traits&gt;&gt; rhs ) noexcept;
}}
{{dcl|num=2|since=c++17|until=c++20|1=
template&lt; class CharT, class Traits &gt;
constexpr bool operator!=( std::basic_string_view&lt;CharT,Traits&gt; lhs,
                           std::basic_string_view&lt;CharT,Traits&gt; rhs ) noexcept;
}}
{{dcl|num=3|since=c++17|until=c++20|1=
template&lt; class CharT, class Traits &gt;
constexpr bool operator&lt;( std::basic_string_view&lt;CharT,Traits&gt; lhs,
                          std::basic_string_view&lt;CharT,Traits&gt; rhs ) noexcept;
}}
{{dcl|num=4|since=c++17|until=c++20|1=
template&lt; class CharT, class Traits &gt;
constexpr bool operator&lt;=( std::basic_string_view&lt;CharT,Traits&gt; lhs,
                           std::basic_string_view&lt;CharT,Traits&gt; rhs ) noexcept;
}}
{{dcl|num=5|since=c++17|until=c++20|1=
template&lt; class CharT, class Traits &gt;
constexpr bool operator&gt;( std::basic_string_view&lt;CharT,Traits&gt; lhs,
                          std::basic_string_view&lt;CharT,Traits&gt; rhs ) noexcept;
}}
{{dcl|num=6|since=c++17|until=c++20|1=
template&lt; class CharT, class Traits &gt;
constexpr bool operator&gt;=( std::basic_string_view&lt;CharT,Traits&gt; lhs,
                           std::basic_string_view&lt;CharT,Traits&gt; rhs ) noexcept;
}}
{{dcl|num=7|since=c++20|1=
template&lt; class CharT, class Traits &gt;
constexpr /*comp-cat*/ operator&lt;=&gt;(
    std::basic_string_view&lt;CharT,Traits&gt; lhs,
    std::type_identity_t&lt;std::basic_string_view&lt;CharT,Traits&gt;&gt; rhs ) noexcept;
}}
{{dcl end}}

Compares two views.

All comparisons are done via the {{lc|compare()}} member function (which itself is defined in terms of {{tt|Traits::compare()}}):

* Two views are equal if both the size of {{c|lhs}} and {{c|rhs}} are equal and each character in {{c|lhs}} has an equivalent character in {{c|rhs}} at the same position.

* The ordering comparisons are done lexicographically â€“ the comparison is performed by a function equivalent to {{lc|std::lexicographical_compare}}.

{{rrev multi
|rev1=
The implementation provides sufficient additional {{tt|constexpr}} and {{tt|noexcept}} overloads of these functions so that a {{tt|basic_string_view&lt;CharT,Traits&gt;}} object {{tt|sv}} may be compared to another object {{tt|t}} with an implicit conversion to {{tt|basic_string_view&lt;CharT,Traits&gt;}}, with semantics identical to comparing {{tt|sv}} and {{tt|basic_string_view&lt;CharT,Traits&gt;(t)}}.
|since2=c++20|rev2=
The return type of three-way comparison operators ({{c|/*comp-cat*/}}) is {{c|Traits::comparison_category}} if that qualified-id denotes a type, {{lc|std::weak_ordering}} otherwise. If {{c|/*comp-cat*/}} is not a comparison category type, the program is ill-formed.

{{cpp/note synthesized compare}}
}}

===Parameters===
{{par begin}}
{{par|lhs, rhs|views to compare}}
{{par end}}

===Return value===
@1-6@ {{c|true}} if the corresponding comparison holds, {{c|false}} otherwise.
@7@ {{c|1=static_cast&lt;/*comp-cat*/&gt;(lhs.compare(rhs) &lt;=&gt; 0)}}.

===Complexity===
Linear in the size of the views.

===Notes===
{{rrev multi
|rev1=
Sufficient additional overloads can be implemented through non-deduced context in one parameter type.
|since2=c++20|rev2=
Three-way comparison result type of {{lc|std::string_view}}, {{lc|std::wstring_view}}, {{lc|std::u8string_view}}, {{lc|std::u16string_view}} and {{lc|std::u32string_view}} is {{lc|std::strong_ordering}}.

{{lc|std::type_identity_t}} is used for non-deduced context, which makes arguments that implicitly convertible to the string view type comparable with the string view.
}}

===Example===
{{example
|code=
#include &lt;string_view&gt;

int main()
{
    using namespace std::literals;

    static_assert(""sv == ""sv);

    static_assert(""sv == "", "Selects an additional overload until C++20.");

    static_assert("" == ""sv, "Selects an additional overload until C++20."
                              "Uses a rewritten candidate since C++20.");

    static_assert(!(""sv != ""sv), "Uses the rewritten candidate since C++20.");

    static_assert(!(""sv != ""), "Selects an additional overload until C++20;"
                                 "Uses a rewritten candidate since C++20.");

    static_assert(!("" != ""sv), "Selects an additional overload until C++20."
                                 "Uses a rewritten candidate since C++20.");
}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3432|std=C++20|before=the return type of {{tt|1=operator&lt;=&gt;}} was not required to be a comparison category type|after=required}}
{{dr list item|wg=lwg|dr=3950|std=C++20|before=redundant additional overloads were still required|after=overload sets reduced}}
{{dr list end}}

{{langlinks|es|ja|zh}}