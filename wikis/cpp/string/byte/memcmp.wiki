{{cpp/title|memcmp}}
{{cpp/string/byte/navbar}}
{{ddcl|header=cstring|
int memcmp( const void* lhs, const void* rhs, std::size_t count );
}}

Reinterprets the objects pointed to by {{c|lhs}} and {{c|rhs}} as arrays of {{c/core|unsigned char}} and compares the first {{c|count}} bytes of these arrays. The comparison is done lexicographically.

The sign of the result is the sign of the difference between the values of the first pair of bytes (both interpreted as {{c/core|unsigned char}}) that differ in the objects being compared.

===Parameters===
{{par begin}}
{{par|lhs, rhs|pointers to the memory buffers to compare}}
{{par|count|number of bytes to examine}}
{{par end}}

===Return value===
Negative value if the first differing byte (reinterpreted as {{c/core|unsigned char}}) in {{c|lhs}} is less than the corresponding byte in {{c|rhs}}.

{{c|0}} if all {{c|count}} bytes of {{c|lhs}} and {{c|rhs}} are equal.

Positive value if the first differing byte in {{c|lhs}} is greater than the corresponding byte in {{c|rhs}}.

===Notes===
This function reads [[cpp/language/object#Object representation and value representation|object representations]], not the object values, and is typically meaningful for only trivially-copyable objects that have no padding. For example, {{tt|memcmp()}} between two objects of type {{lc|std::string}} or {{lc|std::vector}} will not compare their contents, {{tt|memcmp()}} between two objects of type {{c|struct { char c; int n; }&lt;!----&gt;}} will compare the padding bytes whose values may differ when the values of {{c|c}} and {{c|n}} are the same, and even if there were no padding bytes, the {{tt|int}} would be compared without taking into account endianness.

===Example===
{{example
|code=
#include &lt;cstring&gt;
#include &lt;iostream&gt;

void demo(const char* lhs, const char* rhs, std::size_t sz)
{
    std::cout &lt;&lt; std::string(lhs, sz);
    const int rc = std::memcmp(lhs, rhs, sz);
    if (rc &lt; 0)
        std::cout &lt;&lt; " precedes ";
    else if (rc &gt; 0)
        std::cout &lt;&lt; " follows ";
    else
        std::cout &lt;&lt; " compares equal to ";
    std::cout &lt;&lt; std::string(rhs, sz) &lt;&lt; " in lexicographical order\n";
}

int main()
{
    char a1[] = {'a', 'b', 'c'};
    char a2[sizeof a1] = {'a', 'b', 'd'};
    
    demo(a1, a2, sizeof a1);
    demo(a2, a1, sizeof a1);
    demo(a1, a1, sizeof a1);
}
|output=
abc precedes abd in lexicographical order
abd follows abc in lexicographical order
abc compares equal to abc in lexicographical order
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/string/byte/dsc strcmp}}
{{dsc inc|cpp/string/byte/dsc strncmp}}
{{dsc see c|c/string/byte/memcmp}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}