{{cpp/title|memcpy}}
{{cpp/string/byte/navbar}}
{{ddcl|header=cstring|
void* memcpy( void* dest, const void* src, std::size_t count );
}}

Copies {{c|count}} bytes from the object pointed to by {{c|src}} to the object pointed to by {{c|dest}}. Both objects are reinterpreted as arrays of {{c|unsigned char}}.

If the objects overlap, the behavior is undefined.

If either {{c|dest}} or {{c|src}} is an [[cpp/language/pointer#Pointers|invalid or null pointer]], the behavior is undefined, even if {{c|count}} is zero.

If the objects are [[cpp/language/object#Subobjects|potentially-overlapping]] or not {{named req|TriviallyCopyable}}, the behavior of {{tt|memcpy}} is not specified and [https://stackoverflow.com/questions/29777492 may be undefined].

===Parameters===
{{par begin}}
{{par|dest|pointer to the memory location to copy to}}
{{par|src|pointer to the memory location to copy from}}
{{par|count|number of bytes to copy}}
{{par end}}

===Return value===
{{c|dest}}

===Notes===
{{tt|std::memcpy}} may be used to [[cpp/language/object#Object creation|implicitly create]] objects in the destination buffer.

{{tt|std::memcpy}} is meant to be the fastest library routine for memory-to-memory copy. It is usually more efficient than {{lc|std::strcpy}}, which must scan the data it copies or {{lc|std::memmove}}, which must take precautions to handle overlapping inputs.

Several C++ compilers transform suitable memory-copying loops to {{tt|std::memcpy}} calls.

Where {{lsd|cpp/language/object#Strict aliasing}} prohibits examining the same memory as values of two different types, {{tt|std::memcpy}} may be used to convert the values.

===Example===
{{example
|code=
#include &lt;cstdint&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;

int main()
{
    // simple usage
    char source[] = "once upon a daydream...", dest[4];
    std::memcpy(dest, source, sizeof dest);
    std::cout &lt;&lt; "dest[4] = {";
    for (int n{}; char c : dest)
        std::cout &lt;&lt; (n++ ? ", " : "") &lt;&lt; '\'' &lt;&lt; c &lt;&lt; "'";
    std::cout &lt;&lt; "};\n";

    // reinterpreting
    double d = 0.1;
//  std::int64_t n = *reinterpret_cast&lt;std::int64_t*&gt;(&amp;d); // aliasing violation
    std::int64_t n;
    std::memcpy(&amp;n, &amp;d, sizeof d); // OK

    std::cout &lt;&lt; std::hexfloat &lt;&lt; d &lt;&lt; " is " &lt;&lt; std::hex &lt;&lt; n
              &lt;&lt; " as a std::int64_t\n" &lt;&lt; std::dec;

    // object creation in destination buffer
    struct S
    {
        int x{42};
        void print() const { std::cout &lt;&lt; '{' &lt;&lt; x &lt;&lt; "}\n"; }
    } s;
    alignas(S) char buf[sizeof(S)];
    S* ps = new (buf) S; // placement new
    std::memcpy(ps, &amp;s, sizeof s);
    ps-&gt;print();
}
|output=
dest[4] = {'o', 'n', 'c', 'e'};
0x1.999999999999ap-4 is 3fb999999999999a as a std::int64_t
{42}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/string/byte/dsc memmove}}
{{dsc inc|cpp/string/byte/dsc memset}}
{{dsc inc|cpp/string/wide/dsc wmemcpy}}
{{dsc inc|cpp/string/basic_string/dsc copy}}
{{dsc inc|cpp/algorithm/dsc copy}}
{{dsc inc|cpp/algorithm/dsc copy_backward}}
{{dsc inc|cpp/types/dsc is_trivially_copyable}}
{{dsc see c|c/string/byte/memcpy}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}