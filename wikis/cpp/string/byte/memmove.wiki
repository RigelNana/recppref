{{cpp/title|memmove}}
{{cpp/string/byte/navbar}}
{{ddcl|header=cstring|
void* memmove( void* dest, const void* src, std::size_t count );
}}

Copies {{c|count}} characters from the object pointed to by {{c|src}} to the object pointed to by {{c|dest}}. Both objects are reinterpreted as arrays of {{c|unsigned char}}.

The objects may overlap: copying takes place as if the characters were copied to a temporary character array and then the characters were copied from the array to {{c|dest}}.

If either {{c|dest}} or {{c|src}} is an [[cpp/language/pointer#Pointers|invalid or null pointer]], the behavior is undefined, even if {{c|count}} is zero.

If the objects are [[cpp/language/object#Subobjects|potentially-overlapping]] or not {{named req|TriviallyCopyable}}, the behavior of {{tt|memmove}} is not specified and [https://stackoverflow.com/questions/29777492 may be undefined].

===Parameters===
{{par begin}}
{{par|dest|pointer to the memory location to copy to}}
{{par|src|pointer to the memory location to copy from}}
{{par|count|number of bytes to copy}}
{{par end}}

===Return value===
{{c|dest}}

===Notes===
{{tt|std::memmove}} may be used to [[cpp/language/object#Object creation|implicitly create]] objects in the destination buffer.

Despite being specified "as if" a temporary buffer is used, actual implementations of this function do not incur the overhead of double copying or extra memory. For small {{lc|count}}, it may load up and write out registers; for larger blocks, a common approach (glibc and bsd libc) is to copy bytes forwards from the beginning of the buffer if the destination starts before the source, and backwards from the end otherwise, with a fall back to {{lc|std::memcpy}} when there is no overlap at all.

Where {{lsd|cpp/language/object#Strict aliasing}} prohibits examining the same memory as values of two different types, {{tt|std::memmove}} may be used to convert the values.

===Example===
{{example
|code=
#include &lt;cstring&gt;
#include &lt;iostream&gt;

int main()
{
    char str[] = "1234567890";
    std::cout &lt;&lt; str &lt;&lt; '\n';
    std::memmove(str + 4, str + 3, 3); // copies from [4, 5, 6] to [5, 6, 7]
    std::cout &lt;&lt; str &lt;&lt; '\n';
}
|output=
1234567890
1234456890
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/string/byte/dsc memcpy}}
{{dsc inc|cpp/string/byte/dsc memset}}
{{dsc inc|cpp/string/wide/dsc wmemmove}}
{{dsc inc|cpp/algorithm/dsc copy}}
{{dsc inc|cpp/algorithm/dsc copy_backward}}
{{dsc inc|cpp/types/dsc is_trivially_copyable}}
{{dsc see c|c/string/byte/memmove}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pl|pt|ru|zh}}