{{cpp/title|strtol|strtoll}}
{{cpp/string/byte/navbar}}
{{dcl begin}}
{{dcl header|cstdlib}}
{{dcl|num=1|
long      strtol( const char* str, char** str_end, int base );
}}
{{dcl|num=2|since=c++11|
long long strtoll( const char* str, char** str_end, int base );
}}
{{dcl end}}

Interprets an integer value in a byte string pointed to by {{c|str}}.

{{cpp/string/cvt str2int base|base=base}}

The function sets the pointer pointed to by {{c|str_end}} to point to the character past the last character interpreted. If {{c|str_end}} is a null pointer, it is ignored.

If the {{c|str}} is empty or does not have the expected form, no conversion is performed, and (if {{c|str_end}} is not a null pointer) the value of {{c|str}} is stored in the object pointed to by {{c|str_end}}.

===Parameters===
{{par begin}}
{{par|str|pointer to the null-terminated byte string to be interpreted}}
{{par|str_end|pointer to a pointer to character}}
{{par|base|''base'' of the interpreted integer value}}
{{par end}}

===Return value===
* If successful, an integer value corresponding to the contents of {{c|str}} is returned.
* If the converted value falls out of range of corresponding return type, a range error occurs (setting {{lc|errno}} to {{lc|ERANGE}}) and {{lc|LONG_MAX}}, {{lc|LONG_MIN}}, {{lc|LLONG_MAX}} or {{lc|LLONG_MIN}} is returned.
* If no conversion can be performed, {{c|0}} is returned.

===Example===
{{example
|code=
#include &lt;cerrno&gt;
#include &lt;cstdlib&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
 
int main()
{
    const char* p = "10 200000000000000000000000000000 30 -40";
    std::cout &lt;&lt; "Parsing " &lt;&lt; std::quoted(p) &lt;&lt; ":\n";
    
    for (;;)
    {
        // errno can be set to any non-zero value by a library function call
        // regardless of whether there was an error, so it needs to be cleared
        // in order to check the error set by strtol
        errno = 0;
        char* p_end{};
        const long i = std::strtol(p, &amp;p_end, 10);
        if (p == p_end)
            break;
        
        const bool range_error = errno == ERANGE;
        const std::string extracted(p, p_end - p);
        p = p_end;
        
        std::cout &lt;&lt; "Extracted " &lt;&lt; std::quoted(extracted)
                  &lt;&lt; ", strtol returned " &lt;&lt; i &lt;&lt; '.';
        if (range_error)
            std::cout &lt;&lt; "\n  Range error occurred.";
        
        std::cout &lt;&lt; '\n';
    }
}
|p=true
|output=
Parsing "10 200000000000000000000000000000 30 -40":
Extracted "10", strtol returned 10.
Extracted " 200000000000000000000000000000", strtol returned 9223372036854775807.
  Range error occurred.
Extracted " 30", strtol returned 30.
Extracted " -40", strtol returned -40.
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/string/basic_string/dsc stol}}
{{dsc inc|cpp/string/byte/dsc strtoul}}
{{dsc inc|cpp/string/byte/dsc strtoimax}}
{{dsc inc|cpp/string/wide/dsc wcstol}}
{{dsc inc|cpp/string/byte/dsc strtof}}
{{dsc inc|cpp/utility/dsc from_chars}}
{{dsc inc|cpp/string/byte/dsc atoi}}
{{dsc see c|c/string/byte/strtol|strtol|strtoll}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}