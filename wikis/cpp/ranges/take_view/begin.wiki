{{cpp/ranges/take_view/title|begin}}
{{cpp/ranges/take_view/navbar}}

{{dcl begin}}
{{dcla|num=1|since=c++20|
constexpr auto begin() requires (!/*simple-view*/&lt;V&gt;);
}}
{{dcla|num=2|since=c++20|
constexpr auto begin() const requires ranges::range&lt;const V&gt;;
}}
{{dcl end}}

Returns an iterator to the first element of the {{tt|take_view}}.

@1@ Returns a {{c|std::counted_iterator}} or a {{c|ranges::iterator_t&lt;V&gt;}}.
@2@ Returns a {{c|std::counted_iterator}} or a {{c|ranges::iterator_t&lt;const V&gt;}}.

Overload {{v|1}} does not participate in overload resolution if {{tt|V}} is a [[cpp/ranges#Helper concepts|simple view]] (that is, if {{tt|V}} and {{tt|const V}} are views with the same iterator and sentinel types).

===Parameters===
(none)

===Return value===
The result depends on the concepts satisfied by possibly const-qualified underlying view type {{tti|Base}}, which is {{tt|V}} for {{vl|1}} or {{tt|const V}} for {{vl|2}}.

Let {{rlpi|/#Data members|base_}} be the underlying view, {{rlpi|/#Data members|count_}} be the underlying counter (equals to {{c|0}} if {{tt|take_view}} was default initialized).

{|class="wikitable"
|-
! rowspan=2 colspan=2|The underlying view type&lt;br&gt;satisfies ...
! colspan=2|{{lconcept|random_access_range}}
|-
! yes
! no
|-
! rowspan=2|{{lconcept|sized_range}}
! yes
|{{c|ranges::begin(base_)}}
|{{c multi|std::counted_iterator(ranges::begin(base_),
|    ranges::range_difference_t&lt;Base_&gt;(this-&gt;size()))}}
|-
! no
|colspan=2|{{c|std::counted_iterator(ranges::begin(base_), count_)}}
|}

===Example===
{{example
|code=
#include &lt;concepts&gt;
#include &lt;forward_list&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;string_view&gt;
#include &lt;type_traits&gt;
using namespace std::literals;

int main()
{
    {
        static constexpr auto v = {"∀x"sv, "∃y"sv, "ε"sv, "δ"sv};
        auto view = std::ranges::take_view(v, 8);
        auto iter = view.begin();
        std::cout &lt;&lt; *iter &lt;&lt; '\n';
        static_assert(
            std::ranges::sized_range&lt;decltype(v)&gt; and
            std::ranges::random_access_range&lt;decltype(v)&gt; and
            std::is_same_v&lt;decltype(iter), decltype(std::ranges::begin(v))&gt;
        );
    }

    {
        std::forward_list v = {"Ax"sv, "Ey"sv, "p"sv, "q"sv};
        auto view = std::ranges::take_view(v, 8);
        auto iter = view.begin();
        std::cout &lt;&lt; *iter &lt;&lt; '\n';
        static_assert(
            not std::ranges::sized_range&lt;decltype(v)&gt; and
            not std::ranges::random_access_range&lt;decltype(v)&gt; and
            std::is_same_v&lt;decltype(iter),
                std::counted_iterator&lt;
                    std::forward_list&lt;std::string_view&gt;::iterator&gt;&gt;
        );
    }
}
|output=
∀x
Ax
}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P2393R1|std=C++20|before=implicit conversions between signed and unsigned integer-class types might fail|after=made explicit}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/adaptor/dsc end|take_view}}
{{dsc inc|cpp/iterator/dsc counted_iterator}}
{{dsc inc|cpp/ranges/adaptor/sentinel/dsc operator cmp|take_view}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}