{{cpp/ranges/take_view/title|end}}
{{cpp/ranges/take_view/navbar}}

{{dcl begin}}
{{dcla|num=1|since=c++20|
constexpr auto end() requires (!/*simple-view*/&lt;V&gt;);
}}
{{dcla|num=2|since=c++20|
constexpr auto end() const requires ranges::range&lt;const V&gt;;
}}
{{dcl end}}

Returns a sentinel or an iterator representing the end of the {{tt|take_view}}. The end of the {{tt|take_view}} is either one past the {{tt|count}}{{sup|th}} element in the underlying range, or the end of the underlying range if the latter has less than {{tt|count}} elements.

@1@ Returns a {{c|take_view::/*sentinel*/&lt;false&gt;}}, a {{c|std::default_sentinel_t}}, or a {{c|ranges::iterator_t&lt;V&gt;}}.

@2@ Returns a {{c|take_view::/*sentinel*/&lt;true&gt;}}, a {{c|std::default_sentinel_t}}, or a {{c|ranges::iterator_t&lt;const V&gt;}}.

Overload {{v|1}} does not participate in overload resolution if {{tt|V}} is a [[cpp/ranges#Helper concepts|simple view]] (that is, if {{tt|V}} and {{tt|const V}} are views with the same iterator and sentinel types).

===Parameters===
(none)

===Return value===
The result depends on the concepts satisfied by possibly const-qualified underlying view type {{tti|Base}}, that is {{tt|V}} for {{vl|1}} or {{tt|const V}} for {{vl|2}}.

Let {{rlpi|/#Data members|base_}} be the underlying view.

{|class="wikitable"
|-
!rowspan=2 colspan=2|The underlying view type&lt;br&gt;satisfies ...
!colspan=2|{{lconcept|random_access_range}}
|-
!yes
!no
|-
!rowspan=2|{{lconcept|sized_range}}
!yes
|{{c multi|ranges::begin(base_) +
|    ranges::range_difference_t&lt;Base_&gt;(this-&gt;size())}}
|{{c|std::default_sentinel}}
|-
!no
|colspan=2|
@1@ {{c|/*sentinel*/&lt;false&gt;{ranges::end(base_)}&lt;!----&gt;}}
@2@ {{c|/*sentinel*/&lt;true&gt;{ranges::end(base_)}&lt;!----&gt;}}
|}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;list&gt;
#include &lt;ranges&gt;
#include &lt;type_traits&gt;
namespace ranges = std::ranges;
namespace views = std::views;

int main()
{
    const auto list1 = {3, 1, 4, 1, 5};
    const auto seq1{list1 {{!}} views::take(4)};
    static_assert(ranges::sized_range&lt;decltype(seq1)&gt; and
                  ranges::random_access_range&lt;decltype(seq1)&gt; and
                  std::is_same_v&lt;decltype(seq1.end()), decltype(list1.end())&gt;);
    for (auto it = seq1.begin(); it != seq1.end(); ++it)
        std::cout &lt;&lt; *it &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    std::list list2{2, 7, 1, 8, 2};
    const auto seq2{list2 {{!}} views::take(4)};
    static_assert(ranges::sized_range&lt;decltype(seq2)&gt; and
                  not ranges::random_access_range&lt;decltype(seq2)&gt; and
                  std::is_same_v&lt;decltype(seq2.end()), std::default_sentinel_t&gt;);
    for (auto it = seq2.begin(); it != std::default_sentinel; ++it)
        std::cout &lt;&lt; *it &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
3 1 4 1
2 7 1 8
}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P2393R1|std=C++20|before=implicit conversions between signed and unsigned integer-class types might fail|after=made explicit}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/adaptor/dsc begin|take_view}}
{{dsc inc|cpp/iterator/dsc counted_iterator}}
{{dsc inc|cpp/ranges/adaptor/sentinel/dsc operator cmp|take_view}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}