{{cpp/ranges/title|{{small|lazy_split_view&lt;V, Pattern&gt;::}}''inner_iterator''}}
{{cpp/ranges/lazy_split_view/navbar}}
{{ddcla|num=1|since=c++20|expos=yes|
template&lt; bool Const &gt;
struct /*inner_iterator*/;
}}

The return type of {{rlpt|value_type|lazy_split_view::}}{{rlpi|outer_iterator}}{{c/core|::value_type::begin()}}.

{{tt|Const}} matches the template argument of {{rlpi|outer_iterator}}.

===Member types===
{{dsc begin}}
{{dsc hitem|Member|Definition}}
{{dsc expos mem type|Base|{{cpp/ranges/maybe-const|V}}}}
{{dsc|{{tt|iterator_concept}}|
* {{rlpi|outer_iterator}}{{c/core|&lt;Const&gt;::iterator_concept}}, that is {{lc|std::forward_iterator_tag}}, if {{tti|Base}} models {{lconcept|forward_range}}.
* {{lc|std::input_iterator_tag}}, otherwise.}}
{{dsc|{{tt|iterator_category}}&lt;br&gt;{{mark cond present}}|
Present only if {{tti|Base}} models {{lconcept|forward_range}}.
* {{lc|std::forward_iterator_tag}} if {{c/core|std::iterator_traits&lt;ranges::iterator_t&lt;Base&gt;&gt;::iterator_category}} models {{c/core|std::derived_from&lt;std::forward_iterator_tag&gt;}}.
* {{c/core|std::iterator_traits&lt;ranges::iterator_t&lt;Base&gt;&gt;::iterator_category}} otherwise.}}
{{dsc|{{tt|value_type}}|{{c/core|ranges::range_value_t&lt;Base&gt;}}}}
{{dsc|{{tt|difference_type}}|{{c/core|ranges::range_difference_t&lt;Base&gt;}}}}
{{dsc end}}

===Data members===
{{dsc begin}}
{{dsc hitem|Member|Description}}
{{dsc expos mem obj|i_|id=i|private=yes|spec={{rlpi|outer_iterator}}{{c/core|&lt;Const&gt;}}|an iterator into the underlying {{lconcept|view}} of the parent object {{rlpt|lazy_split_view}}}}
{{dsc expos mem obj|incremented_|id=incremented|private=yes|spec=bool|a flag that indicates whether the {{c/core|operator++}} was invoked on this object at least once}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc mem ctor|nolink=true|constructs an iterator|notes={{mark c++20}}}}
{{dsc mem fun|nolink=true|base|returns the underlying iterator|notes={{mark c++20}}}}
{{dsc mem fun|nolink=true|operator*|returns the current element|notes={{mark c++20}}}}
{{dsc mem fun|nolink=true|operator++&lt;br&gt;operator++{{dsc small|(int)}}|advances the iterator|notes={{mark c++20}}}}
{{dsc end}}

===Member functions===
{{member|{{small|std::ranges::lazy_split_view::''inner_iterator''::}}''inner_iterator''|2=
{{dcl begin}}
{{dcl|num=1|since=c++20|1=
/*inner_iterator*/() = default;
}}
{{dcl|num=2|since=c++20|
constexpr explicit /*inner_iterator*/( /*outer_iterator*/&lt;Const&gt; i );
}}
{{dcl end}}

@1@ Value initializes data member {{lsi|#i_}} via its default member initializer (= {{c|/*outer_iterator*/&lt;Const&gt;()}}).
@2@ Initializes {{lsi|#i_}} with {{c|std::move(i)}}.

The data member {{lsi|#incremented_}} is initialized with its default member initializer to {{c/core|false}}.
}}

{{member|{{small|std::ranges::lazy_split_view::''inner_iterator''::}}''base''|2=
{{dcl begin}}
{{dcl|num=1|since=c++20|1=
constexpr const ranges::iterator_t&lt;Base&gt;&amp; base() const &amp; noexcept;
}}
{{dcl|num=2|since=c++20|
constexpr ranges::iterator_t&lt;Base&gt; base() &amp;&amp;
    requires ranges::forward_range&lt;V&gt;;
}}
{{dcl end}}

Returns a copy of the underlying iterator.

@1@ Copy constructs the result from the underlying iterator. Equivalent to {{c|return i_./*cur*/();}}.
@2@ Move constructs the result from the underlying iterator. Equivalent to {{c|return std::move(i_./*cur*/());}}.
}}

{{member|{{small|std::ranges::lazy_split_view::''inner_iterator''::}}operator*|2=
{{ddcl|since=c++20|
constexpr decltype(auto) operator*() const;
}}

Returns the element the underlying iterator points to.

Equivalent to {{c|return *i_./*cur*/();}}.
}}

{{member|{{small|std::ranges::lazy_split_view::''inner_iterator''::}}operator++|2=
{{dcl begin}}
{{dcl|num=1|since=c++20|1=
constexpr /*inner_iterator*/&amp; operator++();
}}
{{dcl|num=2|since=c++20|1=
constexpr decltype(auto) operator++(int);
}}
{{dcl end}}

@1@ The function body is equivalent to&lt;br&gt;{{c|1=
incremented_ = true;
if constexpr (!ranges::forward_range&lt;Base&gt;)
{
    if constexpr (Pattern::size() == 0)
        return *this;
}
++i_./*cur*/();
return *this;
}}

@2@ Equivalent to&lt;br&gt;{{c|1=
if constexpr (ranges::forward_range&lt;Base&gt;)
{
    auto tmp = *this;
    ++*this;
    return tmp;
}
else
    ++*this; // no return statement
}}
}}

===Non-member functions===
{{dsc begin}}
{{dsc fun|nolink=true|operator{{==}}|compares the iterators or the iterator and {{lc|std::default_sentinel}}|notes={{mark c++20}}}}
{{dsc fun|nolink=true|iter_move|casts the result of dereferencing the underlying iterator to its associated rvalue reference type|notes={{mark c++20}}}}
{{dsc fun|nolink=true|iter_swap|swaps the objects pointed to by two underlying iterators|notes={{mark c++20}}}}
{{dsc end}}

{{member|1= operator=={{petty|(std::ranges::split_view::''inner_iterator'')}}|2=
{{dcl begin}}
{{dcl|num=1|since=c++20|1=
friend constexpr bool operator==( const /*inner_iterator*/&amp; x,
                                  const /*inner_iterator*/&amp; y )
      requires forward_range&lt;Base&gt;;
}}
{{dcl|num=2|since=c++20|1=
friend constexpr bool operator==( const /*inner_iterator*/&amp; x,
                                  std::default_sentinel_t );
}}
{{dcl end}}

@1@ Equivalent to {{c|1=return x.i_./*cur*/() == y.i_./*cur*/();}}.
@2@ The function body is equivalent to
{{source|1=
auto [pcur, pend] = ranges::subrange{x.i_.parent_-&gt;pattern_};
auto end = ranges::end(x.i_.parent_-&gt;base_);
if constexpr (/*tiny_range*/&lt;Pattern&gt;)
{
    const auto&amp; cur = x.i_./*cur*/();
    if (cur == end)
        return true;
    if (pcur == pend)
        return x.incremented_;
    return *cur == *pcur;
}
else
{
    auto cur = x.i_./*cur*/();
    if (cur == end)
        return true;
    if (pcur == pend)
        return x.incremented_;
    do
    {
        if (*cur != *pcur)
            return false;
        if (++pcur == pend)
            return true;
    }
    while (++cur != end);
    return false;
}
}}

{{cpp/note synthesized eq}}

{{cpp/hidden friend|plural=yes|{{tt|std::ranges::split_view::''inner_iterator''}}}}
}}

{{member|1= iter_move{{small|(std::ranges::split_view::''inner_iterator'')}}|2=
{{ddcl|since=c++20|
friend constexpr decltype(auto) iter_move( const /*inner_iterator*/&amp; i )
    noexcept(noexcept(ranges::iter_move(i.i_./*cur*/())));
}}
Equivalent to {{c|1=return ranges::iter_move(i.i_./*cur*/());}}.

{{cpp/hidden friend|plural=no|{{tt|std::ranges::split_view::''inner_iterator''}}}}
}}

{{member|1= iter_swap{{small|(std::ranges::split_view::''inner_iterator'')}}|2=
{{ddcl|since=c++20|
friend constexpr void iter_swap( const /*inner_iterator*/&amp; x,
                                 const /*inner_iterator*/&amp; y )
    noexcept(noexcept(ranges::iter_swap(x.i_.current, y.i_.current)))
    requires std::indirectly_swappable&lt;ranges::iterator_t&lt;Base&gt;&gt;;
}}
Equivalent to {{c|ranges::iter_swap(x.i_./*cur*/(), y.i_./*cur*/())}}.

{{cpp/hidden friend|plural=no|{{tt|std::ranges::split_view::''inner_iterator''}}}}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3591|std=C++20|before=the {{c|&amp;&amp;}} overload of {{tt|base}} might invalidate outer iterators|after=constraints added}}
{{dr list item|wg=lwg|dr=3593|std=C++20|before=the {{c|const&amp;}} overload of {{tt|base}} returns a reference but might not be noexcept|after=made noexcept}}
{{dr list end}}

{{langlinks|de|es|ja|ru|zh}}