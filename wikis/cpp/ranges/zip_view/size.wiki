{{cpp/ranges/zip_view/title|size}}
{{cpp/ranges/zip_view/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++23|1=
constexpr auto size()
    requires (ranges::sized_range&lt;Views&gt; &amp;&amp; ...);
}}
{{dcl|num=2|since=c++23|1=
constexpr auto size() const
    requires (ranges::sized_range&lt;const Views&gt; &amp;&amp; ...);
}}
{{dcl end}}

Returns the number of elements in the {{rlpt|/|zip_view}}. Provided only if each underlying (adapted) range satisfies {{lconcept|sized_range}}.

Equivalent to:
{{source|1=
return std::apply
(
    [](auto... sizes)
    {
        using CT = /*make-unsigned-like-t*/&lt;std::common_type_t&lt;decltype(sizes)...&gt;&gt;;
        return ranges::min({CT(sizes)...});
    },
    /*tuple-transform*/(ranges::size, views_)
);
}}

===Parameters===
(none)

===Return value===
The number of elements, which is the minimum size among all sizes of adapted {{lconcept|view}}s.

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;deque&gt;
#include &lt;forward_list&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

int main()
{
    auto x = std::vector{1, 2, 3, 4, 5};
    auto y = std::deque{'a', 'b', 'c'};
    auto z = std::forward_list{1., 2.};

    auto v1 = std::views::zip(x, y);
    assert(v1.size() == std::min(x.size(), y.size()));
    assert(v1.size() == 3);

    [[maybe_unused]] auto v2 = std::views::zip(x, z);
//  auto sz = v2.size(); // Error, v2 does not have size():
    static_assert(not std::ranges::sized_range&lt;decltype(z)&gt;);
}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc size}}
{{dsc inc|cpp/ranges/dsc ssize}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}