{{cpp/ranges/view title|stride}}
{{cpp/ranges/stride_view/navbar}}
{{dcl begin}}
{{dcl header|ranges}}
{{dcl|num=1|since=c++23|1=
template&lt; ranges::input_range V &gt;
    requires ranges::view&lt;V&gt;
class stride_view
    : public ranges::view_interface&lt;stride_view&lt;V&gt;&gt;
}}
{{dcl|num=2|since=c++23|1=
namespace views {
    inline constexpr /* unspecified */ stride = /* unspecified */;
}
}}
{{dcl h|Call signature}}
{{dcl|since=c++23|1=
template&lt; ranges::viewable_range R &gt;
constexpr ranges::view auto stride( R&amp;&amp; r, ranges::range_difference_t&lt;R&gt; n );
}}
{{dcl|since=c++23|1=
template&lt; class DifferenceType &gt;
constexpr /*range adaptor closure*/ stride( DifferenceType&amp;&amp; n );
}}
{{dcl h|Helper templates}}
&lt;!-- TODO: show or add links to: __simple_view , __div_ceil, __maybe_const, __to_unsigned_like --&gt;
{{dcl end}}

@1@ {{tt|stride_view}} is a range adaptor that takes a {{lconcept|view}} and a number {{tti|n}} and produces a view, that consists of elements of the original view by advancing over ''n'' elements at a time. This means that each {{tti|m}}{{sup|''th''}} element of the produced view is {{tti|(n * i)}}{{sup|th}} element of the original view, for some non-negative index {{tti|i}}.
The elements of the original view, whose "index" is not a multiple of {{tti|n}}, are not present in the produced view.

@@ Let {{tti|S}} be the size of the original view. Then the size of produced view is:
* {{c|(S / n) + (S % n ? 1 : 0)}}, if {{c|1=S &gt;= n}}; otherwise,
* {{c|1}}, if {{c|S &gt; 0}}; otherwise,
* {{c|0}}, and the resulting view is empty.

@2@ The name {{c|views::stride}} denotes a {{named req|RangeAdaptorObject}}. Given subexpressions {{c|e}} and {{c|n}}, the expression {{c|views::stride(e, n)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to {{c|stride_view(e, n)}}.

@@ The {{tt|n}} must be greater than {{c|0}}, otherwise the behavior is undefined.

{{tt|stride_view}} always models {{lconcept|input_range}}, and models {{lconcept|forward_range}}, {{lconcept|bidirectional_range}}, {{lconcept|random_access_range}}, and/or {{lconcept|sized_range}}, if adapted {{lconcept|view}} type {{c|V}} models the corresponding concept.
{{c|stride_view&lt;V&gt;}} models {{lconcept|common_range}} whenever the underlying view {{c|V}} does.

===Data members===
{{dsc begin}}
{{dsc hitem|Member object|Definition}}
{{dsc expos mem obj|base_|private=yes|The underlying {{lconcept|view}} of type {{tt|V}}.}}
{{dsc expos mem obj|stride_|private=yes|The size object (the "stride") of type {{c|ranges::range_difference_t&lt;V&gt;}}.}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/ranges/adaptor/dsc constructor|stride_view}}
{{dsc mem fun|cpp/ranges/stride_view/stride|returns the stored stride value|notes={{mark c++23}}}}
{{dsc inc|cpp/ranges/adaptor/dsc base|stride_view}}
{{dsc inc|cpp/ranges/adaptor/dsc begin|stride_view}}
{{dsc inc|cpp/ranges/adaptor/dsc end|stride_view}}
{{dsc inc|cpp/ranges/adaptor/dsc size|stride_view}}
{{cpp/ranges/view_interface/inherit|embedded=yes|size=invalid|data=invalid}}
{{dsc end}}

==={{rl|deduction guides|Deduction guides}}===

===Nested classes===
{{dsc begin}}
{{dsc expos mem tclass|cpp/ranges/stride_view/iterator|notes={{mark c++23}}|the iterator type}}
{{dsc end}}

===Helper templates===
{{ddcl|since=c++23|1=
template&lt; class V &gt;
constexpr bool ranges::enable_borrowed_range&lt;stride_view&lt;V&gt;&gt; =
    ranges::enable_borrowed_range&lt;V&gt;;
}}
This specialization of {{ltt|cpp/ranges/borrowed_range|ranges::enable_borrowed_range}} makes {{tt|stride_view}} satisfy {{lconcept|borrowed_range}} when the underlying view satisfies it.

===Notes===
{{feature test macro|__cpp_lib_ranges_stride|std=C++23|value=202207L|{{tt|std::ranges::stride_view}}}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;string_view&gt;
using namespace std::literals;

void print(std::ranges::viewable_range auto&amp;&amp; v, std::string_view separator = " ")
{
    for (auto const&amp; x : v)
        std::cout &lt;&lt; x &lt;&lt; separator;
    std::cout &lt;&lt; '\n';
}

int main()
{
    print(std::views::iota(1, 13) {{!}} std::views::stride(3));
    print(std::views::iota(1, 13) {{!}} std::views::stride(3) {{!}} std::views::reverse);
    print(std::views::iota(1, 13) {{!}} std::views::reverse {{!}} std::views::stride(3));

    print("0x0!133713337*x//42/A$@"sv {{!}} std::views::stride(0B11) {{!}}
          std::views::transform([](char O) -&gt; char { return 0100 {{!}} O; }),
          "");
}
|output=
1 4 7 10
10 7 4 1
12 9 6 3
password
}}

===References===
{{ref std c++23}}
{{ref std|title=Stride view|id=range.stride|section=26.7.31}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc slide_view}}
{{dsc inc|cpp/ranges/dsc chunk_view}}
{{dsc inc|cpp/ranges/dsc adjacent_view}}
{{dsc inc|cpp/ranges/dsc filter_view}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}