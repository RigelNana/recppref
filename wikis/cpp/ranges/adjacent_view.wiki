{{cpp/ranges/view title|adjacent|{{small|views::}}pairwise}}
{{cpp/ranges/adjacent_view/navbar}}
{{dcl begin}}
{{dcl header|ranges}}
{{dcl|num=1|since=c++23|1=
template&lt; ranges::forward_range V, std::size_t N &gt;
    requires ranges::view&lt;V&gt; &amp;&amp; (N &gt; 0)
class adjacent_view
    : public ranges::view_interface&lt;adjacent_view&lt;V, N&gt;&gt;
}}
{{dcl|num=2|since=c++23|1=
namespace views {
    template&lt; std::size_t N &gt;
    constexpr /* unspecified */ adjacent = /* unspecified */ ;
}
}}
{{dcl|num=3|since=c++23|1=
namespace views {
    inline constexpr auto pairwise = adjacent&lt;2&gt;;
}
}}
{{dcl h|Call signature}}
{{dcl|since=c++23|1=
template&lt; ranges::viewable_range R &gt;
    requires /* see below */
constexpr ranges::view auto adjacent&lt;N&gt;( R&amp;&amp; r );
}}
{{dcl end}}

@1@ {{tt|adjacent_view}} is a range adaptor that takes a {{lconcept|view}}, and produces a {{lconcept|view}} whose {{tti|i}}{{sup|''th''}} element (a "window") is a {{lc|std::tuple}} that holds {{tti|N}} references to the elements of the original view, from {{tti|i}}{{sup|''th''}} up to {{c|i + N - 1}}{{sup|''th''}} inclusively.

@@ Let {{tti|S}} be the size of the original view. Then the size of produced view is:
* {{c|S - N + 1}}, if {{tt|1=S &gt;= N}},
* {{c|0}} otherwise, and the resulting view is empty.

@2@ The name {{c|views::adjacent&lt;N&gt;}} denotes a {{named req|RangeAdaptorObject}}. Given a subexpression {{c|e}} and a constant expression {{c|N}}, the expression {{c|views::adjacent&lt;N&gt;(e)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to
* {{c|((void)e, auto(views::empty&lt;tuple&lt;&gt;&gt;))}} if {{c|N}} is equal to {{c|0}} and {{c|decltype((e))}} models {{lconcept|forward_range}},
* {{c|adjacent_view&lt;views::all_t&lt;decltype((e))&gt;, N&gt;(e)}} otherwise.

@3@ The name {{c|views::pairwise}} denotes a {{named req|RangeAdaptorObject}} that behaves exactly as {{c|views::adjacent&lt;2&gt;}}.

{{tt|adjacent_view}} always models {{lconcept|forward_range}}, and models {{lconcept|bidirectional_range}}, {{lconcept|random_access_range}}, or {{lconcept|sized_range}} if adapted {{lconcept|view}} type models the corresponding concept.
&lt;!--{{tt|adjacent_view}} models {{lconcept|common_range}} if--&gt;
&lt;!--{{cpp/ranges/cpo|views|adjacent}}--&gt;

===Data members===
{{dsc begin}}
{{dsc hitem|Member name|Definition}}
{{dsc expos mem obj|base_|private=yes|the underlying {{lconcept|view}} of type {{tt|V}}.}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/ranges/adaptor/dsc constructor|adjacent_view}}
{{dsc inc|cpp/ranges/adaptor/dsc begin|adjacent_view}}
{{dsc inc|cpp/ranges/adaptor/dsc end|adjacent_view}}
{{dsc inc|cpp/ranges/adaptor/dsc size|adjacent_view}}
{{cpp/ranges/view_interface/inherit|embedded=yes|size=invalid|data=invalid}}
{{dsc end}}

===Deduction guides===
(none)

===Nested classes===
{{dsc begin}}
{{dsc expos mem tclass|cpp/ranges/adjacent_view/iterator|the iterator type}}
{{dsc expos mem tclass|cpp/ranges/adjacent_view/sentinel|the sentinel type used when {{tt|adjacent_view}} is not a {{lconcept|common_range}}}}
{{dsc end}}

===Helper templates===
{{ddcl|since=c++23|1=
template&lt; class V, size_t N &gt;
constexpr bool ranges::enable_borrowed_range&lt;adjacent_view&lt;V, N&gt;&gt; =
    ranges::enable_borrowed_range&lt;V&gt;;
}}
This specialization of {{ltt|cpp/ranges/borrowed_range|ranges::enable_borrowed_range}} makes {{tt|adjacent_view}} satisfy {{lconcept|borrowed_range}} when the underlying view satisfies it.

===Notes===
{{c|views::adjacent}} only accepts forward ranges even when {{tt|N}} is {{tt|0}}.

{{cpp/ranges/adjacent vs slide}}

{{feature test macro|__cpp_lib_ranges_zip|std=C++23|value=202110L|{{c/core|ranges::zip_view}},&lt;br&gt;{{c/core|ranges::zip_transform_view}},&lt;br&gt;{{tt|ranges::adjacent_view}},&lt;br&gt;{{c/core|ranges::adjacent_transform_view}}}}

===Example===
{{example
|code=
#include &lt;array&gt;
#include &lt;format&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;tuple&gt;

int main()
{
    constexpr std::array v{1, 2, 3, 4, 5, 6};
    std::cout &lt;&lt; "v = [1 2 3 4 5 6]\n";

    for (int i{}; std::tuple t : v {{!}} std::views::adjacent&lt;3&gt;)
    {
        auto [t0, t1, t2] = t;
        std::cout &lt;&lt; std::format("e = {:&lt;{}&lt;!----&gt;}[{} {} {}]\n", "", 2 * i++, t0, t1, t2);
    }
}
|output=
v = [1 2 3 4 5 6]
e = [1 2 3]
e =   [2 3 4]
e =     [3 4 5]
e =       [4 5 6]
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=4098|std=C++23|before={{c|views::adjacent&lt;0&gt;}} used to accept input-only ranges|after=made rejected}}
{{dr list end}}

===References===
{{ref std c++23}}
{{ref std|title=Adjacent view|id=range.adjacent|section=26.7.25}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc adjacent_transform_view}}
{{dsc inc|cpp/ranges/dsc slide_view}}
{{dsc inc|cpp/ranges/dsc chunk_view}}
{{dsc inc|cpp/ranges/dsc stride_view}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}