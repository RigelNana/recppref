{{cpp/ranges/view title|enumerate}}
{{cpp/ranges/enumerate_view/navbar}}
{{dcl begin}}
{{dcl header|ranges}}
{{dcl|num=1|since=c++23|1=
template&lt; ranges::view V &gt;
    requires /*range-with-movable-references*/&lt;V&gt;
class enumerate_view
    : public ranges::view_interface&lt;enumerate_view&lt;V&gt;&gt;
}}
{{dcl|num=2|since=c++23|1=
namespace views {
    inline constexpr /* unspecified */ enumerate = /* unspecified */;
}
}}
{{dcl h|Call signature}}
{{dcl|since=c++23|1=
template&lt; ranges::viewable_range R &gt;
    requires /* see below */
constexpr /* see below */ enumerate( R&amp;&amp; r );
}}
{{dcl h|Helper concepts}}
{{dcl|num=3|notes={{mark expos}}|1=
template&lt; class R &gt;
    concept /*range-with-movable-references*/ =
        ranges::input_range&lt;R&gt; &amp;&amp;
        std::move_constructible&lt;ranges::range_reference_t&lt;R&gt;&gt; &amp;&amp;
        std::move_constructible&lt;ranges::range_rvalue_reference_t&lt;R&gt;&gt;;
}}
{{dcl end}}

@1@ {{tt|enumerate_view}} is a range adaptor that takes a {{lconcept|view}} and produces a view of {{lc|std::tuple|tuple}}s. {{tt|i}}{{sup|th}} element (the tuple) of the resulting sequence holds:
* the value equal to {{tt|i}}, which is a zero-based index of the element of underlying sequence, and
* the reference to the underlying element.

@2@ The name {{tt|views::enumerate}} denotes a {{named req|RangeAdaptorObject}}. Given a subexpression {{c|e}}, the expression {{c|views::enumerate(e)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to {{c|enumerate_view&lt;views::all_t&lt;decltype((e))&gt;&gt;(e)}} for any suitable subexpression {{c|e}}.

@3@ Ensures that the reference type of the underlying type can be moved.

{{tt|enumerate_view}} models the concepts {{lconcept|random_access_range}}, {{lconcept|bidirectional_range}}, {{lconcept|forward_range}}, {{lconcept|input_range}}, {{lconcept|common_range}}, and {{lconcept|sized_range}} when the underlying view {{tt|V}} models respective concepts.

===Data members===
{{dsc begin}}
{{dsc hitem|Member name|Definition}}
{{dsc expos mem obj|base_|private=yes|An iterator to the underlying sequence of type {{tt|V}}.}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/ranges/adaptor/dsc constructor|enumerate_view}}
{{dsc inc|cpp/ranges/adaptor/dsc base|enumerate_view}}
{{dsc inc|cpp/ranges/adaptor/dsc begin|enumerate_view}}
{{dsc inc|cpp/ranges/adaptor/dsc end|enumerate_view}}
{{dsc inc|cpp/ranges/adaptor/dsc size|enumerate_view|notes}}
{{cpp/ranges/view_interface/inherit|embedded=yes|size=invalid|data=invalid}}
{{dsc end}}

==={{rl|deduction guides|Deduction guides}}===

===Nested classes===
{{dsc begin}}
{{dsc expos mem tclass|cpp/ranges/enumerate_view/iterator|the iterator type|notes={{mark c++23}}}}
{{dsc expos mem tclass|cpp/ranges/enumerate_view/sentinel|the sentinel type|notes={{mark c++23}}}}
{{dsc end}}

===Helper templates===
{{ddcl|since=c++23|1=
template&lt; class View &gt;
constexpr bool enable_borrowed_range&lt;ranges::enumerate_view&lt;View&gt;&gt; =
    ranges::enable_borrowed_range&lt;View&gt;;
}}
This specialization of {{ltt|cpp/ranges/borrowed_range|ranges::enable_borrowed_range}} makes {{tt|enumerate_view}} satisfy {{lconcept|borrowed_range}} when the underlying view satisfies it.

===Notes===
{{feature test macro|__cpp_lib_ranges_enumerate|std=C++23|value=202302L|{{tt|std::ranges::enumerate_view}}}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

int main()
{
    constexpr static auto v = {'A', 'B', 'C', 'D'};

    for (auto const [index, letter] : std::views::enumerate(v))
        std::cout &lt;&lt; '(' &lt;&lt; index &lt;&lt; ':' &lt;&lt; letter &lt;&lt; ") ";
    std::cout &lt;&lt; '\n';

#if __cpp_lib_ranges_to_container
    // create a map using the position of each element as key
    auto m = v {{!}} std::views::enumerate {{!}} std::ranges::to&lt;std::map&gt;();

    for (auto const [key, value] : m)
        std::cout &lt;&lt; '[' &lt;&lt; key &lt;&lt; "]:" &lt;&lt; value &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
#endif

    std::vector&lt;int&gt; numbers{1, 3, 5, 7};

    // num is mutable even with const, which does not propagate to reference to
    // make it const, use `std::views::enumerate(numbers) {{!}} std::views::as_const`
    // or `std::views::enumerate(std::as_const(numbers))`
    for (auto const [index, num] : std::views::enumerate(numbers))
    {
        ++num; // the type is int&amp;
        std::cout &lt;&lt; numbers[index] &lt;&lt; ' ';
    }
    std::cout &lt;&lt; '\n';
}
|p=true
|output=
(0:A) (1:B) (2:C) (3:D)
[0]:A [1]:B [2]:C [3]:D
2 4 6 8
}}

===References===
{{ref std c++23}}
{{ref std|title=Enumerate view|id=range.enumerate|section=26.7.23}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc iota_view}}
{{dsc inc|cpp/ranges/dsc zip_view}}
{{dsc inc|cpp/ranges/dsc elements_view}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}