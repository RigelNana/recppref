{{cpp/ranges/views/title|all|all_t}}
{{cpp/ranges/navbar}}
{{dcl begin}}
{{dcl header|ranges}}
{{dcl|num=1|since=c++20|1=
inline constexpr /* unspecified */ all = /* unspecified */;
}}
{{dcl|num=2|since=c++20|1=
template&lt; ranges::viewable_range R &gt;
using all_t = decltype(views::all(std::declval&lt;R&gt;()));
}}
{{dcl end}}

@1@ A {{named req|RangeAdaptorObject}} (also a {{named req|RangeAdaptorClosureObject}}) that returns a {{lconcept|view}} that includes all elements of its {{lconcept|range}} argument.

@@ Given an expression {{c|e}} of type {{tt|R}}, the expression {{c|views::all(e)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to:
* Implicitly converting {{c|e}} to a {{c/core|std::decay_t&lt;R&gt;}} prvalue, if {{c/core|std::decay_t&lt;R&gt;}} models {{lconcept|view}}.
* Otherwise, {{c|std::ranges::ref_view{e}&lt;!----&gt;}} if that expression is well-formed.
* Otherwise, {{c|std::ranges::owning_view{e}&lt;!----&gt;}}.

@2@ Calculates the suitable {{lconcept|view}} type of a {{lconcept|viewable_range}} type.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5};
    for (int n : std::views::all(v) {{!}} std::views::take(2))
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
    
    static_assert(std::is_same&lt;
        decltype(std::views::single(42)),
        std::ranges::single_view&lt;int&gt;
        &gt;{});
    
    static_assert(std::is_same&lt;
        decltype(std::views::all(v)),
        std::ranges::ref_view&lt;std::vector&lt;int, std::allocator&lt;int&gt;&gt;&gt;
        &gt;{});
    
    int a[]{1, 2, 3, 4};
    static_assert(std::is_same&lt;
        decltype(std::views::all(a)),
        std::ranges::ref_view&lt;int[4]&gt;
        &gt;{});
    
    static_assert(std::is_same&lt;
        decltype(std::ranges::subrange{std::begin(a) + 1, std::end(a) - 1}),
        std::ranges::subrange&lt;int*, int*, std::ranges::subrange_kind(1)&gt;
        &gt;{});
}
|output=
0 1
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3724|std=C++20|before={{tt|views::all}} might result in hard error for some move-only views|after=it gets well-constrained}}
{{dr list item|paper=P2415R2|std=C++20|before={{tt|views::all}} returned a {{tt|subrange}} for a non-{{lconcept|view}} rvalue {{lconcept|range}}|after=returns an {{tt|owning_view}} for it}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc empty_view}}
{{dsc inc|cpp/ranges/dsc single_view}}
{{dsc inc|cpp/ranges/dsc owning_view}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}