{{cpp/ranges/view title|iota}}
{{cpp/ranges/iota_view/navbar}}
{{dcl begin}}
{{dcl header|ranges}}
{{dcl|num=1|since=c++20|1=
template&lt; std::weakly_incrementable W,
          std::semiregular Bound = std::unreachable_sentinel_t &gt;
    requires /*weakly-equality-comparable-with*/&lt;W, Bound&gt; &amp;&amp; std::copyable&lt;W&gt;
class iota_view
    : public ranges::view_interface&lt;iota_view&lt;W, Bound&gt;&gt;
}}
{{dcl|num=2|since=c++20|1=
namespace views {
    inline constexpr /* unspecified */ iota = /* unspecified */;
}
}}
{{dcl h|Call signature}}
{{dcl|since=c++20|1=
template&lt; class W &gt;
    requires /* see below */
constexpr /* see below */ iota( W&amp;&amp; value );
}}
{{dcl|since=c++20|1=
template&lt; class W, class Bound &gt;
    requires /* see below */
constexpr /* see below */ iota( W&amp;&amp; value, Bound&amp;&amp; bound );
}}
{{dcl end}}

@1@ A range factory that generates a sequence of elements by repeatedly incrementing an initial value. Can be either bounded or unbounded (infinite).
@2@ {{c|views::iota(e)}} and {{c|views::iota(e, f)}} are [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to {{c|iota_view&lt;std::decay_t&lt;decltype((e))&gt;&gt;(e)}} and {{c|iota_view(e, f)}} respectively for any suitable subexpressions {{c|e}} and {{c|f}}.

{{cpp/ranges/cpo|views|iota}}

===Data members===
{{dsc begin}}
{{dsc hitem|Member|Definition}}
{{dsc expos mem obj|spec={{tt|W}}|value_|id=value|the beginning value}}
{{dsc expos mem obj|spec={{tt|Bound}}|bound_|id=bound|the sentinel value, may be unreachable}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc mem ctor|cpp/ranges/iota_view/iota_view|creates an {{tt|iota_view}}}}
{{dsc mem fun|cpp/ranges/iota_view/begin|obtains the beginning iterator of an {{tt|iota_view}}}}
{{dsc mem fun|cpp/ranges/iota_view/end|obtains the sentinel denoting the end of an {{tt|iota_view}}}}
{{dsc mem fun|cpp/ranges/iota_view/empty|tests whether the {{tt|iota_view}} is empty (i.e. the iterator and the sentinel compare equal)}}
{{dsc mem fun|cpp/ranges/iota_view/size|notes={{mark optional}}|obtains the size of an {{tt|iota_view}} (only provided if it is bounded)}}

{{cpp/ranges/view_interface/inherit|embedded=yes|data=invalid|empty=invalid|size=yes}}
{{dsc end}}

==={{rl|deduction guides|Deduction guides}}===

===Nested classes===
{{dsc begin}}
{{dsc expos mem class|cpp/ranges/iota_view/iterator|the iterator type}}
{{dsc expos mem class|cpp/ranges/iota_view/sentinel|the sentinel type used when the {{tt|iota_view}} is bounded and {{tt|Bound}} and {{tt|W}} are not the same type}}
{{dsc end}}

===Helper templates===
{{ddcl|since=c++20|1=
template&lt; std::weakly_incrementable W, std::semiregular Bound &gt;
constexpr bool ranges::enable_borrowed_range&lt;ranges::iota_view&lt;W, Bound&gt;&gt; = true;
}}
This specialization of {{c/core|ranges::enable_borrowed_range}} makes {{tt|iota_view}} satisfy {{lconcept|borrowed_range}}.

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
    
struct Bound
{
    int bound;
    bool operator==(int x) const { return x == bound; }
};

int main()
{
    for (int i : std::ranges::iota_view{1, 10})
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
    
    for (int i : std::views::iota(1, 10))
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
    
    for (int i : std::views::iota(1, Bound{10}))
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
    
    for (int i : std::views::iota(1) {{!}} std::views::take(9))
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
    
    std::ranges::for_each(std::views::iota(1, 10),
                          [](int i){ std::cout &lt;&lt; i &lt;&lt; ' '; });
    std::cout &lt;&lt; '\n';
}
|output=
1 2 3 4 5 6 7 8 9
1 2 3 4 5 6 7 8 9
1 2 3 4 5 6 7 8 9
1 2 3 4 5 6 7 8 9
1 2 3 4 5 6 7 8 9
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=4096|std=C++20|before={{tt|views::iota}} could copy an {{tt|iota_view}} as-is|after=forbidden}}
{{dr list item|paper=P2325R3|std=C++20|before={{tt|iota_view}} required that {{tt|W}} is {{lconcept|semiregular}}&lt;br&gt;as {{lconcept|view}} required {{lconcept|default_initializable}}|after=only requires that {{tt|W}} is {{lconcept|copyable}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc iota}}
{{dsc inc|cpp/algorithm/ranges/dsc iota}}
{{dsc inc|cpp/ranges/dsc repeat_view}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}