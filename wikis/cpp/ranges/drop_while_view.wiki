{{cpp/ranges/view title|drop_while}}
{{cpp/ranges/drop_while_view/navbar}}

{{dcl begin}}
{{dcl header|ranges}}
{{dcl|num=1|since=c++20|1=
template&lt; ranges::view V, class Pred &gt;
    requires ranges::input_range&lt;V&gt; &amp;&amp;
             std::is_object_v&lt;Pred&gt; &amp;&amp;
             std::indirect_unary_predicate&lt;const Pred, ranges::iterator_t&lt;V&gt;&gt;
class drop_while_view
    : public ranges::view_interface&lt;drop_while_view&lt;V, Pred&gt;&gt;
}}
{{dcl|num=2|since=c++20|1=
namespace views {
    inline constexpr /* unspecified */ drop_while = /* unspecified */;
}
}}
{{dcl h|Call signature}}
{{dcl|since=c++20|1=
template&lt; ranges::viewable_range R, class Pred &gt;
    requires /* see below */
constexpr ranges::view auto drop_while( R&amp;&amp; r, Pred&amp;&amp; pred );
}}
{{dcl|since=c++20|1=
template&lt; class Pred &gt;
constexpr /*range adaptor closure*/ drop_while( Pred&amp;&amp; pred );
}}
{{dcl end}}

@1@ A range adaptor that represents {{lconcept|view}} of elements from an underlying sequence, beginning at the first element for which the predicate returns {{c|false}}.
@2@ {{named req|RangeAdaptorObject}}. The expression {{c|views::drop_while(e, f)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to {{c|drop_while_view(e, f)}}&lt;!-- LWG 3524 --&gt; for any suitable subexpressions {{c|e}} and {{c|f}}.

{{c|drop_while_view}} models the concepts {{lconcept|contiguous_range}}, {{lconcept|random_access_range}}, {{lconcept|bidirectional_range}}, {{lconcept|forward_range}}, {{lconcept|input_range}}, and {{lconcept|common_range}} when the underlying view {{c|V}} models respective concepts. It also models {{lconcept|sized_range}} if {{c|ranges::forward_range&lt;V&gt;}} and {{c|std::sized_sentinel_for&lt;ranges::sentinel_t&lt;V&gt;, ranges::iterator_t&lt;V&gt;&gt;}} are modeled.

===Data members===
{{dsc begin}}
{{dsc hitem|Member name|Definition}}
{{dsc expos mem obj|base_|private=yes|the underlying {{lconcept|view}} of type {{tt|V}}}}
{{dsc expos mem obj|pred_|private=yes|the underlying function object of type {{rev inl|until=c++23|{{rlpi|copyable_wrapper|copyable-box&lt;!--P2325R3--&gt;}}{{tt|&lt;Pred&gt;}}}}{{rev inl|since=c++23|{{rlpi|copyable_wrapper|movable-box}}{{tt|&lt;Pred&gt;}}}}}}
{{dsc expos mem obj|cache_|private=yes|maybe=yes|TODO: mension L4$, see {{lsd|#Notes}}.}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/ranges/adaptor/dsc constructor|drop_while_view}}
{{dsc inc|cpp/ranges/adaptor/dsc base|drop_while_view}}
{{dsc inc|cpp/ranges/adaptor/dsc pred|drop_while_view}}
{{dsc inc|cpp/ranges/adaptor/dsc begin|drop_while_view}}
{{dsc inc|cpp/ranges/adaptor/dsc end|drop_while_view}}

{{cpp/ranges/view_interface/inherit|embedded=yes}}
{{dsc end}}

==={{rl|deduction guides|Deduction guides}}===

===Helper templates===
{{ddcl|since=c++20|1=
template&lt; class T, class Pred &gt;
constexpr bool enable_borrowed_range&lt;std::ranges::drop_while_view&lt;T, Pred&gt;&gt; =
    ranges::enable_borrowed_range&lt;T&gt;;
}}
This specialization of {{c/core|std::ranges::enable_borrowed_range}} makes {{tt|drop_while_view}} satisfy {{lconcept|borrowed_range}} when the underlying view satisfies it.

===Notes===
In order to provide the amortized constant time complexity required by the {{lconcept|range}} concept, the result of {{rlt|begin}} is cached within the {{tt|drop_while_view}} object. If the underlying range is modified after the first call to {{lc|begin()}}, subsequent uses of the {{tt|drop_while_view}} object might have unintuitive behavior.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;

using std::operator""sv;

[[nodiscard]]
constexpr bool is_space(char p) noexcept
{
    auto ne = [p](auto q) { return p != q; };
    return !!(" \t\n\v\r\f" {{!}} std::views::drop_while(ne));
};

[[nodiscard("trims the output")]]
constexpr std::string_view trim_left(std::string_view const in) noexcept
{
    auto view = in {{!}} std::views::drop_while(is_space);
    return {view.begin(), view.end()};
}

[[nodiscard("trims the output")]]
constexpr std::string trim(std::string_view const in)
{
    auto view = in
              {{!}} std::views::drop_while(is_space)
              {{!}} std::views::reverse
              {{!}} std::views::drop_while(is_space)
              {{!}} std::views::reverse
              ;
    return {view.begin(), view.end()};
}

int main()
{
    static_assert(trim_left(" \n C++23") == "C++23"sv);

    constexpr auto src{" \f\n\t\r\vHello, C++20!\f\n\t\r\v "sv};
    static_assert(trim(src) == "Hello, C++20!");

    static constexpr auto v = {0, 1, 2, 3, 4, 5};
    for (int n : v {{!}} std::views::drop_while([](int i) { return i &lt; 3; }))
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
3 4 5
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3494|std=c++20|before={{tt|drop_while_view}} was never a {{tt|borrowed_range}}|after=it is a {{tt|borrowed_range}} if its underlying view is}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc drop_view}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}