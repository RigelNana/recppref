{{cpp/ranges/title|rend}}
{{cpp/ranges/navbar}}

{{dcl begin}}
{{dcl header|ranges}}
{{dcl header|iterator}}
{{dcl|notes={{mark custpt}}|since=c++20|1=
inline namespace /* unspecified */ {
    inline constexpr /* unspecified */ rend = /* unspecified */;
}
}}
{{dcl h|Call signature}}
{{dcl|since=c++20|1=
template&lt; class T &gt;
    requires /* see below */
constexpr std::sentinel_for&lt;
    decltype(ranges::rbegin(std::declval&lt;T&gt;()))&gt; auto rend( T&amp;&amp; t );
}}
{{dcl end}}

Returns a sentinel indicating the end of a reversed range.

{{image|range-rbegin-rend.svg}}

If {{tt|T}} is an array type and {{c/core|std::remove_all_extents_t&lt;std::remove_reference_t&lt;T&gt;&gt;}} is incomplete, then the call to {{tt|ranges::rend}} is ill-formed, no diagnostic required.

If the argument is an lvalue or {{c|ranges::enable_borrowed_range&lt;std::remove_cv_t&lt;T&gt;&gt;}} is {{c|true}}, then a call to {{tt|ranges::rend}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to:
# {{rev inl|until=c++23|{{box|{{lti|cpp/standard library/decay-copy}}{{c/core|(t.rend())}}}}}}{{rev inl|since=c++23|{{c|auto(t.rend())}}}}, if that expression is valid and its type models {{c|std::sentinel_for&lt;decltype(ranges::rbegin(std::declval&lt;T&gt;()))&gt;}}.
# Otherwise, {{rev inl|until=c++23|{{box|{{lti|cpp/standard library/decay-copy}}{{c/core|(rend(t))}}}}}}{{rev inl|since=c++23|{{c|auto(rend(t))}}}}, if {{tt|T}} is a class or enumeration type, that expression is valid and its type models {{c|std::sentinel_for&lt;decltype(ranges::rbegin(std::declval&lt;T&gt;()))&gt;}}, where the meaning of {{tt|rend}} is established as if by performing [[cpp/language/adl|argument-dependent lookup]] only.
# Otherwise, {{c|std::make_reverse_iterator(ranges::begin(t))}} if both {{c|ranges::begin(t)}} and {{c|ranges::end(t)}} are valid expressions, have the same type, and that type models {{lc|std::bidirectional_iterator}}.

In all other cases, a call to {{tt|ranges::rend}} is ill-formed, which can result in [[cpp/language/sfinae|substitution failure]] when {{c|ranges::rend(t)}} appears in the immediate context of a template instantiation.

{{cpp/ranges/cpo}}

===Notes===
If the argument is an rvalue (i.e. {{tt|T}} is an object type) and {{c|ranges::enable_borrowed_range&lt;std::remove_cv_t&lt;T&gt;&gt;}} is {{c|false}}, or if it is of an array type of unknown bound, the call to {{tt|ranges::rend}} is ill-formed, which also results in substitution failure.

If {{c|ranges::rend(std::forward&lt;T&gt;(t))}} is valid, then {{c/core|decltype(ranges::rend(std::forward&lt;T&gt;(t)))}} and {{c/core|decltype(ranges::begin(std::forward&lt;T&gt;(t)))}} model {{lc|std::sentinel_for}} in all cases, while {{tt|T}} models {{lc|std::ranges::range}}.

{{cpp/ranges/prv}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; v = {3, 1, 4};
    namespace ranges = std::ranges;
    if (ranges::find(ranges::rbegin(v), ranges::rend(v), 5) != ranges::rend(v))
        std::cout &lt;&lt; "found a 5 in vector v!\n";
    
    int a[] = {5, 10, 15};
    if (ranges::find(ranges::rbegin(a), ranges::rend(a), 5) != ranges::rend(a))
        std::cout &lt;&lt; "found a 5 in array a!\n";
}
|output=
found a 5 in array a!
}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P2602R2|std=C++20|before=there's machinery to prohibit certain non-member {{tt|rend}} found by [[cpp/language/adl|ADL]]|after=removed such machinery}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc crend}}
{{dsc inc|cpp/ranges/dsc rbegin}}
{{dsc inc|cpp/iterator/dsc rend}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}