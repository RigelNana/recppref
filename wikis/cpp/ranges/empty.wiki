{{cpp/ranges/title|empty}}
{{cpp/ranges/navbar}}

{{dcl begin}}
{{dcl header|ranges}}
{{dcl header|iterator}}
{{dcl|notes={{mark custpt}}|since=c++20|1=
inline namespace /*unspecified*/ {
    inline constexpr auto empty = /*unspecified*/;
}
}}
{{dcl h|Call signature}}
{{dcl|since=c++20|1=
template&lt; class T &gt;
    requires /* see below */
constexpr bool empty( T&amp;&amp; t );
}}
{{dcl end}}

Determines whether or not {{c|t}} has any elements.

A call to {{tt|ranges::empty}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to:
# {{c|bool(t.empty())}}, if that expression is valid.
# Otherwise, {{c|1=(ranges::size(t) == 0)}}, if that expression is valid.
# Otherwise, {{c|1=bool(ranges::begin(t) == ranges::end(t))}}, if that expression is valid and {{c|decltype(ranges::begin(t))}} models {{lc|std::forward_iterator}}.

In all other cases, a call to {{tt|ranges::empty}} is ill-formed, which can result in [[cpp/language/sfinae|substitution failure]] when {{c|ranges::empty(t)}} appears in the immediate context of a template instantiation.

{{cpp/ranges/cpo}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

template&lt;std::ranges::input_range R&gt;
void print(char id, R&amp;&amp; r)
{
    if (std::ranges::empty(r))
    {
        std::cout &lt;&lt; '\t' &lt;&lt; id &lt;&lt; ") Empty\n";
        return;
    }

    std::cout &lt;&lt; '\t' &lt;&lt; id &lt;&lt; ") Elements:";
    for (const auto&amp; element : r)
        std::cout &lt;&lt; ' ' &lt;&lt; element;
    std::cout &lt;&lt; '\n';
}

int main()
{
    {
        auto v = std::vector&lt;int&gt;{1, 2, 3};
        std::cout &lt;&lt; "(1) ranges::empty uses std::vector::empty:\n";
        print('a', v);

        v.clear();
        print('b', v);
    }
    {
        std::cout &lt;&lt; "(2) ranges::empty uses ranges::size(initializer_list):\n";
        auto il = {7, 8, 9};
        print('a', il);

        print('b', std::initializer_list&lt;int&gt;{});
    }
    {
        std::cout &lt;&lt; "(2) ranges::empty on a raw array uses ranges::size:\n";
        int array[] = {4, 5, 6}; // array has a known bound
        print('a', array);
    }
    {
        struct Scanty : private std::vector&lt;int&gt;
        {
            using std::vector&lt;int&gt;::begin;
            using std::vector&lt;int&gt;::end;
            using std::vector&lt;int&gt;::push_back;
            // Note: both empty() and size() are hidden
        };

        std::cout &lt;&lt; "(3) calling ranges::empty on an object w/o empty() or size():\n";
        Scanty y;
        print('a', y);
        y.push_back(42);
        print('b', y);
    }
}
|output=
(1) ranges::empty uses std::vector::empty:
        a) Elements: 1 2 3
        b) Empty
(2) ranges::empty uses ranges::size(initializer_list):
        a) Elements: 7 8 9
        b) Empty
(2) ranges::empty on a raw array uses ranges::size:
        a) Elements: 4 5 6
(3) calling ranges::empty on an object w/o empty() or size():
        a) Empty
        b) Elements: 42
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/iterator/dsc empty}}
{{dsc end}}

{{langlinks|es|ja|zh}}