{{cpp/ranges/zip_transform_view/title|''iterator''}}
{{cpp/ranges/zip_transform_view/navbar}}
{{ddcl|since=c++23|notes={{mark expos}}|
template&lt; bool Const &gt;
class /*iterator*/;
}}

The iterator type of a possibly const-qualified {{tt|zip_transform_view}}, returned by {{rlpt|begin|zip_transform_view::begin}} and in certain cases by {{rlpt|end|zip_transform_view::end}}.

The type {{c|/*iterator*/&lt;true&gt;}} or {{c|/*iterator*/&lt;false&gt;}} treats the underlying views as const-qualified or non-const-qualified respectively.

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc expos mem type|Parent|private=yes|{{rlpt|/|zip_transform_view}} if {{c|Const}} is {{c|false}}, {{c|const zip_transform_view}} otherwise.}}
{{dsc expos mem type|Base|private=yes|[[cpp/ranges/zip_transform_view#Member types|{{tti|InnerView}}]] if {{c|Const}} is {{c|false}}, {{c|const InnerView}} otherwise.}}
{{dsc|{{tt|iterator_category}}&lt;br&gt;{{mark cond present}}|
Let {{c|/*maybe-const*/&lt;Const, F&gt;&amp;}} denote {{c|const F&amp;}} if {{c|Const}} is {{c|true}}, {{c|F&amp;}} otherwise.&lt;br&gt;
Let {{c|/*maybe-const*/&lt;Const, Views&gt;}} denote {{c|const Views}} if {{c|Const}} is {{c|true}}, {{c|Views}} otherwise.&lt;br&gt;

Let {{c|/*POT*/}} denote the pack of types
{{c multi
|std::iterator_traits&lt;std::iterator_t&lt;
|    /*maybe-const*/&lt;Const, Views&gt;&gt;&gt;::iterator_category...
}}&lt;br&gt;

If {{c|/*Base*/}} models {{lconcept|forward_range}}, then {{tt|iterator_category}} denotes:
* {{lc|std::input_iterator_tag}}, if {{c multi
|std::invoke_result_t&lt;/*maybe-const*/&lt;Const, F&gt;&amp;,
|    ranges::range_reference_t&lt;/*maybe-const*/&lt;Const, Views&gt;&gt;...&gt;}}
: is not a reference.
* Otherwise,
:* {{lc|std::random_access_iterator_tag}}, if&lt;br&gt;
:: {{c|(std::derived_from&lt;/*POT*/, std::random_access_iterator_tag&gt; &amp;&amp; ...)}} is {{c|true}}.&lt;br&gt;
:* Otherwise, {{lc|std::bidirectional_iterator_tag}}, if&lt;br&gt;
:: {{c|(std::derived_from&lt;/*POT*/, std::bidirectional_iterator_tag&gt; &amp;&amp; ...)}} is {{c|true}}.&lt;br&gt;
:* Otherwise, {{lc|std::forward_iterator_tag}}, if&lt;br&gt;
:: {{c|(std::derived_from&lt;/*POT*/, std::forward_iterator_tag&gt; &amp;&amp; ...)}} is {{c|true}}.&lt;br&gt;
:* Otherwise, {{lc|std::input_iterator_tag}}.
Not present if {{c|/*Base*/}} does not model {{lconcept|forward_range}}.}}
{{dsc|{{tt|iterator_concept}}|{{c|/*ziperator*/&lt;Const&gt;::iterator_concept}}}}
{{dsc|{{tt|value_type}}|
Let {{c|/*RREF*/}} be {{c|ranges::range_reference_t&lt;Views&gt;...}},&lt;br&gt;
and {{c|/*CRREF*/}} be {{c|ranges::range_reference_t&lt;const Views&gt;...}}. Then:
* {{c|std::remove_cvref_t&lt;std::invoke_result_t&lt;F&amp;, /*RREF*/&gt;&gt;}} if {{c|Const}} is {{c|false}},
* {{c|std::remove_cvref_t&lt;std::invoke_result_t&lt;const F&amp;, /*CRREF*/&gt;&gt;}} otherwise.}}
{{dsc|{{tt|difference_type}}|{{c|range::range_difference_t&lt;/*Base*/&gt;}}}}
{{dsc end}}

===Data members===
{{dsc begin}}
{{dsc hitem|Member object|Definition}}
{{dsc expos mem obj|parent_|private=yes|A pointer [[#Member types|{{tti|Parent*}}]] to the parent object}}
{{dsc expos mem type|inner_|private=yes|An iterator of type [[cpp/ranges/zip_transform_view#Member types|{{tti|ziperator&lt;Const&gt;}}]].}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc mem ctor|cpp/ranges/zip_transform_view/iterator/iterator|constructs an iterator}}
{{dsc mem fun|cpp/ranges/zip_transform_view/iterator/operator*|obtains the result of applying the invocable object to the underlying pointed-to elements}}
{{dsc mem fun|cpp/ranges/zip_transform_view/iterator/operator_at|title=operator[]|obtains the result of applying the invocable object to the underlying elements at given offset}}
{{dsc inc|cpp/ranges/adaptor/iterator/dsc operator arith|zip_transform_view}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc fun|cpp/ranges/zip_transform_view/iterator/operator_cmp|title=operator==&lt;br&gt;operator&lt;=&gt;|compares the underlying iterators|notes={{mark c++23}}}}
{{dsc fun|cpp/ranges/zip_transform_view/iterator/operator_arith2|title=operator+&lt;br&gt;operator-|performs iterator arithmetic on underlying iterators|notes={{mark c++23}}}}
{{dsc end}}

===Example===
{{example}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}