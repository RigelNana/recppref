{{cpp/ranges/view title|split}}
{{cpp/ranges/split_view/navbar}}

{{dcl begin}}
{{dcl header|ranges}}
{{dcl|num=1|since=c++20|1=
template&lt; ranges::forward_range V, ranges::forward_range Pattern &gt;
requires ranges::view&lt;V&gt; &amp;&amp;
         ranges::view&lt;Pattern&gt; &amp;&amp;
         std::indirectly_comparable&lt;ranges::iterator_t&lt;V&gt;,
                                    ranges::iterator_t&lt;Pattern&gt;,
                                    ranges::equal_to&gt;
class split_view
    : public ranges::view_interface&lt;split_view&lt;V, Pattern&gt;&gt;
}}
{{dcl|num=2|since=c++20|1=
namespace views {
    inline constexpr /* unspecified */ split = /* unspecified */;
}
}}
{{dcl h|Call signature}}
{{dcl|since=c++20|1=
template&lt; ranges::viewable_range R, class Pattern &gt;
    requires /* see below */
constexpr ranges::view auto split( R&amp;&amp; r, Pattern&amp;&amp; pattern );
}}
{{dcl|since=c++20|1=
template&lt; class Pattern &gt;
constexpr /* range adaptor closure */ split( Pattern&amp;&amp; pattern );
}}
{{dcl end}}
&lt;!--add an extended wording--&gt;

@1@ {{tt|split_view}} takes a {{lconcept|view}} and a delimiter, and splits the {{lconcept|view}} into subranges on the delimiter.

@2@ {{named req|RangeAdaptorObject}}. The expression {{c|views::split(e, p)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to {{c|split_view(e, p)}}&lt;!-- LWG 3524 --&gt; for any suitable subexpressions {{c|e}} and {{c|p}}.

{{tt|split_view}} models the concepts {{lconcept|forward_range}}, and {{lconcept|common_range}} when the underlying {{lconcept|view}} {{tt|V}} models respective concepts.

The inner range ({{c/core|ranges::range_reference_t&lt;split_view&gt;}}) is a {{c/core|ranges::subrange&lt;ranges::iterator_t&lt;V&gt;&gt;}}, which models {{lconcept|common_range}}, models {{lconcept|sized_range}} when {{c/core|ranges::iterator_t&lt;V&gt;}} models {{c|std::sized_sentinel_for&lt;ranges::iterator_t&lt;V&gt;&gt;}}, and models {{lconcept|contiguous_range}}, {{lconcept|random_access_range}}, {{lconcept|bidirectional_range}}, and {{lconcept|forward_range}} when {{tt|V}} models respective concepts.

Unlike {{rlpt|lazy_split_view}}, {{tt|split_view}} maintains the continuity of the subrange, making it suitable for string splitting.

===Data members===
{{dsc begin}}
{{dsc hitem|Member|Description}}
{{dsc expos mem obj|base_|id=base|private=yes|spec={{tt|V}}|the underlying (adapted) {{lconcept|view}}}}
{{dsc expos mem obj|pattern_|id=pattern|private=yes|spec={{tt|Pattern}}|the pattern object that is used as a delimiter to split the underlying {{lconcept|view}}}}
{{dsc expos mem obj|cached_begin_|id=cached_begin|private=yes|spec={{lti|cpp/ranges/non-propagating-cache}}{{c/core|&lt;ranges::subrange}}&lt;br&gt;{{nbspt|4}}{{c/core|&lt;ranges::iterator_t&lt;V&gt;&gt;&gt;}}|an object that caches the result of the first call to {{rltf|begin}}}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/ranges/adaptor/dsc constructor|split_view}}
{{dsc inc|cpp/ranges/adaptor/dsc base|split_view}}
{{dsc inc|cpp/ranges/adaptor/dsc begin|split_view}}
{{dsc inc|cpp/ranges/adaptor/dsc end|split_view}}
{{dsc expos mem fun|cpp/ranges/split_view/find_next|searches for the next occurrence of the pattern}}

{{cpp/ranges/view_interface/inherit|embedded=yes|data=invalid|back=invalid|size=invalid|operator[]=invalid}}
{{dsc end}}

===Nested classes===
{{dsc begin}}
{{dsc expos mem class|cpp/ranges/split_view/iterator|the iterator type}}
{{dsc expos mem class|cpp/ranges/split_view/sentinel|the sentinel type}}
{{dsc end}}

==={{rl|deduction guides|Deduction guides}}===

===Notes===
Before {{wg21|P2210R2}}, {{tt|split_view}} used a ''lazy'' mechanism for splitting, and thus could not keep the bidirectional, random access, or contiguous properties of the underlying view, or make the iterator type of the inner range same as that of the underlying view. Consequently, it is redesigned by {{wg21|P2210R2}}, and the lazy mechanism is moved to {{rlpt|lazy_split_view}}.

The delimiter {{tt|pattern}} generally should not be an ordinary string literal, as it will consider the null terminator to be necessary part of the delimiter; therefore, it is advisable to use a {{lc|std::string_view}} literal instead.

===Example===
{{example
|code=
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;string_view&gt;

int main()
{
    using std::operator""sv;
    constexpr auto words{"Hello^_^C++^_^20^_^!"sv};
    constexpr auto delim{"^_^"sv};

    for (const auto word : std::views::split(words, delim))
        // with string_view's C++23 range constructor:
        std::cout &lt;&lt; std::quoted(std::string_view(word)) &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
"Hello" "C++" "20" "!"
}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P2210R2|std=C++20|before=the old {{tt|split_view}} was too lazy to be easily used|after=it is redesigned}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc lazy_split_view}}
{{dsc inc|cpp/ranges/dsc join_view}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}