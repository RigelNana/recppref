{{cpp/ranges/view title|take}}
{{cpp/ranges/take_view/navbar}}

{{dcl begin}}
{{dcl header|ranges}}
{{dcl|num=1|since=c++20|1=
template&lt; ranges::view V &gt;
class take_view
    : public ranges::view_interface&lt;take_view&lt;V&gt;&gt;
}}
{{dcl|num=2|since=c++20|1=
namespace views {
    inline constexpr /* unspecified */ take = /* unspecified */;
}
}}
{{dcl h|Call signature}}
{{dcl|since=c++20|1=
template&lt; ranges::viewable_range R &gt;
    requires /* see below */
constexpr ranges::view auto
    take( R&amp;&amp; r, ranges::range_difference_t&lt;R&gt; count );
}}
{{dcl|since=c++20|1=
template&lt; class DifferenceType &gt;
constexpr /* range adaptor closure */ take( DifferenceType&amp;&amp; count );
}}
{{dcl end}}

@1@ A range adaptor that represents {{lconcept|view}} of the elements from an underlying sequence, starting at the beginning and ending at a given bound.
@2@ {{tt|views::take}} is a {{named req|RangeAdaptorObject}}. The expression {{c|views::take(e, f)}} results in a view that represents the first {{c|f}} elements from {{c|e}}. The result is not necessarily a {{tt|take_view}}.
&lt;!----&gt;
{{c|views::take(e, f)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to (where {{tt|T}} is {{c/core|std::remove_cvref_t&lt;decltype((e))&gt;}} and {{tt|D}} is {{c/core|ranges::range_difference_t&lt;decltype((e))&gt;}}):
&lt;!----&gt;
* {{box|{{c/core|((void)f,}}{{nbspt}}{{lti|cpp/standard library/decay-copy}}{{c/core|(e))}}}}, if {{tt|T}} is a {{c/core|ranges::empty_view}}, except that the evaluations of {{c|e}} and {{c|f}} are indeterminately sequenced;&lt;!-- LWG 3524 --&gt;
* {{c|U(ranges::begin(e), ranges::begin(e) + std::min&lt;D&gt;(ranges::distance(e), f))}}, if {{tt|T}} is a specialization of {{c/core|std::span}}, {{lc|std::basic_string_view}}, or {{c/core|ranges::subrange}} that models both {{lconcept|random_access_range}} and {{lconcept|sized_range}}, where {{tt|U}} is
:* {{c/core|std::span&lt;typename T::element_type&gt;}}, if {{tt|T}} is a specialization of {{c/core|std::span}};
:* {{tt|T}}, if {{tt|T}} is a specialization of {{lc|std::basic_string_view}};
:* {{c/core|ranges::subrange&lt;ranges::iterator_t&lt;T&gt;&gt;}}, if {{tt|T}} is a specialization of {{c/core|ranges::subrange}};
* {{c multi|ranges::iota_view(*ranges::begin(e),|                  *(ranges::begin(e) + std::min&lt;D&gt;(ranges::distance(e), f)))}}, if {{tt|T}} is a specialization of {{c/core|ranges::iota_view}} that models both {{lconcept|random_access_range}} and {{lconcept|sized_range}};
{{rrev|since=c++23|
* otherwise, if {{tt|T}} is a specialization of {{l2tt|cpp/ranges/repeat_view}}:
:* {{c|views::repeat(*e.value_, std::min&lt;D&gt;(ranges::distance(e), f))}}, if {{tt|T}} models {{lconcept|sized_range}}; is such case {{c|e}} is evaluated only once;
:* {{c|views::repeat(*e.value_, static_cast&lt;D&gt;(e))}} otherwise;
}}
* otherwise, {{c|take_view(e, f)}}.
&lt;!----&gt;
In all cases, {{c/core|decltype((f))}} must model {{c|std::convertible_to&lt;D&gt;}}.

{{tt|take_view}} models the concepts {{lconcept|contiguous_range}}, {{lconcept|random_access_range}}, {{lconcept|bidirectional_range}}, {{lconcept|forward_range}},  {{lconcept|input_range}}, and {{lconcept|sized_range}} when the underlying view {{tt|V}} models respective concepts. It models {{lconcept|common_range}} when the underlying view {{tt|V}} models both {{lconcept|random_access_range}} and {{lconcept|sized_range}}.

===Data members===
{{dsc begin}}
{{dsc hitem|Member name|Definition}}
{{dsc expos mem obj|base_|private=yes|the underlying {{lconcept|view}} of type {{tt|V}}}}
{{dsc expos mem obj|count_|private=yes|the number of elements to take, of type {{c/core|ranges::range_difference_t&lt;V&gt;}}}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/ranges/adaptor/dsc constructor|take_view}}
{{dsc inc|cpp/ranges/adaptor/dsc base|take_view}}
{{dsc inc|cpp/ranges/adaptor/dsc begin|take_view}}
{{dsc inc|cpp/ranges/adaptor/dsc end|take_view}}
{{dsc inc|cpp/ranges/adaptor/dsc size|take_view}}

{{cpp/ranges/view_interface/inherit|embedded=yes|size=yes}}
{{dsc end}}

==={{rl|deduction guides|Deduction guides}}===

===Nested classes===
{{dsc begin}}
{{dsc expos mem tclass|cpp/ranges/take_view/sentinel|notes={{mark c++20}}|the sentinel type}}
{{dsc end}}

===Helper templates===
{{ddcl|since=c++20|1=
template&lt; class T &gt;
constexpr bool enable_borrowed_range&lt;std::ranges::take_view&lt;T&gt;&gt; =
    ranges::enable_borrowed_range&lt;T&gt;;
}}
This specialization of {{ltt|cpp/ranges/borrowed_range|std::ranges::enable_borrowed_range}} makes {{tt|take_view}} satisfy {{lconcept|borrowed_range}} when the underlying view satisfies it.

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;

int main()
{
    namespace views = std::views;
    auto print = [](char x){ std::cout &lt;&lt; x; };

    for (const char nums[]{'1', '2', '3'};
         int n : views::iota(0, 5))
    {
        std::cout &lt;&lt; "take(" &lt;&lt; n &lt;&lt; "): ";
        // safely takes only upto min(n, nums.size()) elements:
        std::ranges::for_each(nums {{!}} views::take(n), print);
        std::cout &lt;&lt; '\n';
    }
}
|output=
take(0): 
take(1): 1
take(2): 12
take(3): 123
take(4): 123
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3407|std=C++20|before={{tt|views::take}} sometimes failed to&lt;br&gt;construct a sized random access range|after=the result type is adjusted so&lt;br&gt;that construction is always valid}}
{{dr list item|wg=lwg|dr=3494|std=C++20|before={{tt|take_view}} was never a {{tt|borrowed_range}}|after=it is a {{tt|borrowed_range}} if its underlying view is}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc view_counted}}
{{dsc inc|cpp/ranges/dsc take_while_view}}
{{dsc inc|cpp/algorithm/ranges/dsc copy_n}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}