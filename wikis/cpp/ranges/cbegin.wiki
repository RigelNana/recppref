{{cpp/ranges/title|cbegin}}
{{cpp/ranges/navbar}}
{{dcl begin}}
{{dcl header|ranges}}
{{dcl header|iterator}}
{{dcl|notes={{mark custpt}}|since=c++20|1=
inline namespace /* unspecified */ {
    inline constexpr /* unspecified */ cbegin = /* unspecified */;
}
}}
{{dcl h|Call signature}}
{{dcl|since=c++20|1=
template&lt; class T &gt;
    requires /* see below */
constexpr /* see below */ auto cbegin( T&amp;&amp; t );
}}
{{dcl end}}

{{rrev multi|until1=c++23
|rev1=Returns an iterator to the first element of the const-qualified argument.
|rev2=Returns a constant iterator to the first element of the argument.}}

{{image|range-begin-end.svg}}

{{rrev multi|until1=c++23|rev1=
Let {{tt|CT}} be
* {{c|const std::remove_reference_t&lt;T&gt;&amp;}} if the argument is an lvalue (i.e. {{tt|T}} is an lvalue reference type),
* {{c|const T}} otherwise.
A call to {{tt|ranges::cbegin}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to {{c|ranges::begin(static_cast&lt;CT&amp;&amp;&gt;(t))}}.
|rev2=
If the argument is an lvalue or {{c|ranges::enable_borrowed_range&lt;std::remove_cv_t&lt;T&gt;&gt;}} is {{c|true}}, then a call to {{tt|ranges::cbegin}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to:
* {{c|std::const_iterator&lt;decltype(U)&gt;(U)}} for some expression {{c|U}} equivalent to {{box|{{c/core|ranges::begin(}}{{rlpsi|/#possibly-const-range}}{{c/core|(t)}}}}.

In all other cases, a call to {{tt|ranges::cbegin}} is ill-formed, which can result in [[cpp/language/sfinae|substitution failure]] when the call appears in the immediate context of a template instantiation.
}}

The return type models {{lc|std::input_or_output_iterator}} {{rev inl|since=c++23| and {{rlpi|constant_range|constant-iterator}}}} in all cases.

{{cpp/ranges/cpo}}

===Notes===
For an lvalue range {{c|e}} of type {{c|T}}, {{c|ranges::cbegin(e)}} is equivalent to
{{rrev multi|until1=c++23|rev1=
{{c|ranges::begin(std::as_const(e))}}.
|rev2=
* {{c|ranges::begin(e)}} if {{c|T}} models {{lconcept|constant_range}}.
* Otherwise, {{c|ranges::begin(std::as_const(e))}} if {{c|const T}} models {{lconcept|constant_range}}.
* Otherwise, {{c|std::basic_const_iterator(ranges::begin(e))}}.
}}

===Example===
{{example
|
|code=
#include &lt;cassert&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

int main()
{
    std::vector v{3, 1, 4};
    auto vi = std::ranges::cbegin(v);
    assert(3 == *vi);
    ++vi; // OK, constant-iterator object is mutable
    assert(1 == *vi);
    // *vi = 13; // Error: constant-iterator points to an immutable element

    int a[]{3, 1, 4};
    auto ai = std::ranges::cbegin(a); // cbegin works with C-arrays as well
    assert(3 == *ai and *(ai + 1) == 1);
    // *ai = 13; // Error: read-only variable is not assignable
}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc begin}}
{{dsc inc|cpp/iterator/dsc begin}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}