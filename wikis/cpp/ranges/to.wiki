{{cpp/ranges/title|to}}
{{cpp/ranges/navbar}}

{{dcl begin}}
{{dcl header|ranges}}
{{dcla|num=1|since=c++23|
template&lt; class C, ranges::input_range R, class... Args &gt;
    requires (!ranges::view&lt;C&gt;)
constexpr C to( R&amp;&amp; r, Args&amp;&amp;... args );
}}
{{dcl|num=2|since=c++23|
template&lt; template&lt; class... &gt; class C,
          ranges::input_range R, class... Args &gt;
constexpr auto to( R&amp;&amp; r, Args&amp;&amp;... args );
}}
{{dcla|num=3|since=c++23|
template&lt; class C, class... Args &gt;
    requires (!ranges::view&lt;C&gt;)
constexpr /*range adaptor closure*/ to( Args&amp;&amp;... args );
}}
{{dcl|num=4|since=c++23|
template&lt; template&lt; class... &gt; class C, class... Args &gt;
constexpr /*range adaptor closure*/ to( Args&amp;&amp;... args );
}}
{{dcl h|Helper templates}}
{{dcla|num=5|expos=yes|anchor=reservable-container|1=
template&lt; class Container &gt;
constexpr bool /*reservable-container*/ =
    ranges::sized_range&lt;Container&gt; &amp;&amp;
    requires (Container&amp; c, ranges::range_size_t&lt;Container&gt; n)
    {
        c.reserve(n);
        { c.capacity() } -&gt; std::same_as&lt;decltype(n)&gt;;
        { c.max_size() } -&gt; std::same_as&lt;decltype(n)&gt;;
    };
}}
{{dcla|num=6|expos=yes|anchor=container-appendable|1=
template&lt; class Container, class Reference &gt;
constexpr bool /*container-appendable*/ =
    requires (Container&amp; c, Reference&amp;&amp; ref)
    {
        requires
        (
            requires { c.emplace_back(std::forward&lt;Reference&gt;(ref)); }     {{!!}}
            requires { c.push_back(std::forward&lt;Reference&gt;(ref)); }        {{!!}}
            requires { c.emplace(c.end(), std::forward&lt;Reference&gt;(ref)); } {{!!}}
            requires { c.insert(c.end(), std::forward&lt;Reference&gt;(ref)); }
        );
    };
}}
{{dcla|num=7|expos=yes|anchor=container-appender|1=
template&lt; class Reference, class C &gt;
constexpr auto /*container-appender*/( C&amp; c );
}}
{{dcla|num=8|expos=yes|anchor=container-compatible-range|1=
template&lt; class R, class T &gt;
concept /*container-compatible-range*/ =
    ranges::input_range&lt;R&gt; &amp;&amp;
    std::convertible_to&lt;ranges::range_reference_t&lt;R&gt;, T&gt;;
}}
{{dcl end}}

The overloads of the range conversion function construct a new non-view object from a source range as its first argument by calling a constructor taking a range, a {{tt|std::from_range_t}} tagged ranged constructor, a constructor taking an iterator-sentinel pair, or by back inserting each element of the source range into the arguments-constructed object.

@1@ Constructs an object of type {{tt|C}} from the elements of {{c|r}} in the following:
:@a@ If {{tt|C}} does not satisfy {{lconcept|input_range}} or {{c|std::convertible_to&lt;ranges::range_reference_t&lt;R&gt;, ranges::range_value_t&lt;C&gt;&gt;}} is {{c|true}}:
::@1@ Constructing a non-view object as if [[cpp/language/direct_initialization|direct-initializing]] (but not direct-list-initializing) an object of type {{tt|C}} from the source range {{c|std::forward&lt;R&gt;(r)}} and the rest of the functional arguments {{c|std::forward&lt;Args&gt;(args)...}} if {{c|std::constructible_from&lt;C, R, Args...&gt;}} is {{c|true}}.
::@2@ Otherwise, constructing a non-view object as if [[cpp/language/direct initialization|direct-initializing]] (but not direct-list-initializing) an object of type {{tt|C}} from additional disambiguation tag {{c|std::from_range}}, the source range {{c|std::forward&lt;R&gt;(r)}} and the rest of the functional arguments {{c|std::forward&lt;Args&gt;(args)...}} if {{c|std::constructible_from&lt;C, std::from_range_t, R, Args...&gt;}} is {{c|true}}.
::@3@ Otherwise, constructing a non-view object as if [[cpp/language/direct initialization|direct-initializing]] (but not direct-list-initializing) an object of type {{tt|C}} from the iterator-sentinel pair ({{c|ranges::begin(r)}} as an iterator and {{c|ranges::end(r)}} as sentinel, where iterator and sentinel have the same type. In other words, the source range must be a common range), and the rest of function arguments {{c|std::forward&lt;Args&gt;(args)...}} if all of the conditions below are {{c|true}}:
* {{c/core|ranges::common_range&lt;R&gt;}}
* If {{c/core|std::iterator_traits&lt;ranges::iterator_t&lt;R&gt;&gt;::iterator_category}} is valid and denotes a type that satisfies {{c|std::derived_from&lt;std::input_iterator_tag&gt;}}
* {{c|std::constructible_from&lt;C, ranges::iterator_t&lt;R&gt;, ranges::sentinel_t&lt;R&gt;, Args...&gt;}}
::@4@ Otherwise, constructing a non-view range object as if [[cpp/language/direct initialization|direct-initializing]] (but not direct-list-initializing) an object of type {{tt|C}} from the rest of the function arguments {{c|std::forward&lt;Args&gt;(args)...}} with the following equivalent call below after the construction:
{{c multi|
if constexpr (ranges::sized_range&lt;R&gt; &amp;&amp; /*reservable-container*/&lt;C&gt;)
    c.reserve(static_cast&lt;ranges::range_size_t&lt;C&gt;&gt;(ranges::size(r)));
ranges::for_each(r, /*container-appender*/(c));
}}&lt;br&gt;
If the {{tt|R}} satisfies {{lconcept|sized_range}} and {{tt|C}} satisfies {{lsi|#reservable-container}}, the constructed object {{c|c}} of type {{tt|C}} is able to reserve storage with the initial storage size {{c|ranges::size(r)}} to prevent additional allocations during inserting new elements. Each element of {{c|r}} is appended to {{c|c}}.
The operations above are valid if both of the conditions below are {{c|true}}:
* {{c|std::constructible_from&lt;C, Args...&gt;}}
* {{box|{{lsi|#container-appendable}}{{c/core|&lt;C, ranges::range_reference_t&lt;R&gt;&gt;}}}}
:@b@ Otherwise, the return expression is equivalent to:
{{c multi|
to&lt;C&gt;(ranges::ref_view(r) {{!}} views::transform([](auto&amp;&amp; elem)|
{|
    return to&lt;ranges::range_value_t&lt;C&gt;&gt;(std::forward&lt;decltype(elem)&gt;(elem));|
}), std::forward&lt;Args&gt;(args)...)
}}&lt;br&gt;
Which allows nested range constructions within the range if {{c|ranges::input_range&lt;ranges::range_reference_t&lt;C&gt;&gt;}} is {{c|true}}.
Otherwise, the program is ill-formed.

@2@ Constructs an object of deduced type from the elements of {{c|r}}.
Let {{c/core|/*input-iterator*/}} be an exposition only type that satisfies {{named req|InputIterator}}:
{{dcl begin}}
{{dcla|anchor=no|expos=yes|1=
struct /*input-iterator*/
{
    using iterator_category = std::input_iterator_tag;
    using value_type = ranges::range_value_t&lt;R&gt;;
    using difference_type = std::ptrdiff_t;
    using pointer = std::add_pointer_t&lt;ranges::range_reference_t&lt;R&gt;&gt;;
    using reference = ranges::range_reference_t&lt;R&gt;;
    reference operator*() const;                      // not defined
    pointer operator-&gt;() const;                       // not defined
    /*input-iterator*/&amp; operator++();                 // not defined
    /*input-iterator*/ operator++(int);               // not defined
    bool operator==(const /*input-iterator*/&amp;) const; // not defined
};
}}
{{dcl end}}
Let {{c|/*DEDUCE-EXPR*/}} be defined as follows:
* {{c|C(std::declval&lt;R&gt;(), std::declval&lt;Args&gt;()...)}}, if that expression is valid.
* Otherwise, {{c multi|C(std::from_range, std::declval&lt;R&gt;(),|  std::declval&lt;Args&gt;()...)}}, if that expression is valid.
* Otherwise, {{c multi|C(std::declval&lt;/*input-iterator*/&gt;(),|  std::declval&lt;/*input-iterator*/&gt;(),|  std::declval&lt;Args&gt;()...)}}, if that expression is valid.
* Otherwise, the program is ill-formed.
The call is equivalent to {{c multi|to&lt;decltype(/*DEDUCE-EXPR*/)&gt;|    (std::forward&lt;R&gt;(r), std::forward&lt;Args&gt;(args)...)}}.
@3,4@ Returns a perfect forwarding call wrapper that is also a {{named req|RangeAdaptorClosureObject}}.
@5@ Is {{c|true}} if it satisfies {{c/core|ranges::sized_range}} and is eligible to be reservable.
@6@ Is {{c|true}} if one element of type {{tt|Reference}} can be appended to {{tt|Container}} through a member function call {{tt|emplace_back}}, {{tt|push_back}}, {{tt|emplace}} or {{tt|insert}}.
@7@ Returns a function object where a call to the returned function object is expression-equivalent to appending one element to a container. The return expression is equivalent to:
{{c multi|
return [&amp;c]&lt;class Reference&gt;(Reference&amp;&amp; ref)
{
    if constexpr (requires { c.emplace_back(std::declval&lt;Reference&gt;()); })
        c.emplace_back(std::forward&lt;Reference&gt;(ref));
    else if constexpr (requires { c.push_back(std::declval&lt;Reference&gt;()); })
        c.push_back(std::forward&lt;Reference&gt;(ref));
    else if constexpr (requires { c.emplace(c.end(),
                                            std::declval&lt;Reference&gt;()); })
        c.emplace(c.end(), std::forward&lt;Reference&gt;(ref));
    else
        c.insert(c.end(), std::forward&lt;Reference&gt;(ref));
};
}}
{{anchor|container compatible range}}
@8@ Is used in the definition of containers in constructing an input range {{tt|R}} whose range reference type must be convertible to {{tt|T}}.

===Parameters===
{{par begin}}
{{par|r|a source range object}}
{{par|args|list of the arguments to {{vl|1,2}} construct a range or {{vl|3,4}} bind to the last parameters of range adaptor closure object}}
{{par hreq}}
{{par req|{{tt|C}} must be cv-unqualified class type {{vl|1,3}}}}
{{par end}}

===Return value===
@1,2@ A constructed non-view object.
@3,4@ A range adaptor closure object of unspecified type, with the following properties:
{{member|{{small|ranges::to}} return type|2=
====Member objects====
The returned object behaves as if it has no target object, and an {{lc|std::tuple}} object {{c|tup}} constructed with {{c|std::tuple&lt;std::decay_t&lt;Args&gt;...&gt;(std::forward&lt;Args&gt;(args)...)}}, except that the returned object's assignment behavior is unspecified and the names are for exposition only.

====Constructors====
The return type of {{tt|ranges::to}} {{vl|3,4}} behaves as if its copy/move constructors perform a memberwise copy/move. It is {{named req|CopyConstructible}} if all of its member objects (specified above) are {{named req/core|CopyConstructible}}, and is {{named req|MoveConstructible}} otherwise.

====Member function {{tt|operator()}}====
Given an object {{tt|G}} obtained from an earlier call to {{c|range::to&lt;/* see below */&gt;(args...)}}, when a glvalue {{c|g}} designating {{tt|G}} is invoked in a function call expression {{c|g(r)}}, an invocation of the stored object takes place, as if by
* {{c|ranges::to&lt;/* see below */&gt;(r, std::get&lt;Ns&gt;(g.tup)...)}}, where
:* {{c|r}} is a source range object that must satisfy {{lconcept|input_range}}.
:* {{c|Ns}} is an integer pack {{c|0, 1, ..., (sizeof...(Args) - 1)}}.
:* {{c|g}} is an lvalue in the call expression if it is an lvalue in the call expression, and is an rvalue otherwise. Thus {{c|std::move(g)(r)}} can move the bound arguments into the call, where {{c|g(r)}} would copy.
:* The specified template argument is {{vl|3}} {{tt|C}} or {{vl|4}} the deduced type from a class template {{tt|C}} that must not satisfy {{lconcept|view}}.

The program is ill-formed if {{c|g}} has volatile-qualified type.
}}

===Exceptions===
Only throws if construction of a non-view object throws.

===Notes===
The insertion of elements into the container may involve copy which can be less efficient than move because lvalue references are produced during the indirection call. Users can opt-in to use {{c/core|views::as_rvalue}} to adapt the range in order for their elements to always produce an rvalue reference during the indirection call which implies move.

The parentheses are mandatory when using the pipe syntax.

{{source|1=
auto vec = r {{!}} std::ranges::to&lt;std::vector&gt;;   // Error
auto vec = r {{!}} std::ranges::to&lt;std::vector&gt;(); // OK
}}

{{feature test macro|__cpp_lib_ranges_to_container|std=C++23|value=202202L|{{tt|std::ranges::to}}}}

===Example===
{{example
|A preview link: [https://godbolt.org/z/s4E3n8ed5 Compiler Explorer]
|code=
#include &lt;boost/container/devector.hpp&gt;
#include &lt;concepts&gt;
#include &lt;list&gt;
#include &lt;initializer_list&gt;
#include &lt;iostream&gt;
#include &lt;print&gt;
#include &lt;ranges&gt;
#include &lt;regex&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main()
{
    auto vec = std::views::iota(1, 5)
             {{!}} std::views::transform([](int v){ return v * 2; })
             {{!}} std::ranges::to&lt;std::vector&gt;();
    
    static_assert(std::same_as&lt;decltype(vec), std::vector&lt;int&gt;&gt;);
    std::println("{}", vec);
    
    auto list = vec {{!}} std::views::take(3) {{!}} std::ranges::to&lt;std::list&lt;double&gt;&gt;();
    std::println("{}", list);
}

void ctor_demos()
{
    // 1.a.1) Direct init
    {
        char array[]{'a', 'b', '\0', 'c'};
        
        // Argument type is convertible to result value type:
        auto str_to = std::ranges::to&lt;std::string&gt;(array);
        // Equivalent to
        std::string str(array);
        
        // Result type is not an input range:
        auto re_to = std::ranges::to&lt;std::regex&gt;(array);
        // Equivalent to
        std::regex re(array);
    }
    
    // 1.a.2) from_range ctor
    {
        auto list = {'a', 'b', '\0', 'c'};
        
        // Argument type is convertible to result value type:
        auto str_to = std::ranges::to&lt;std::string&gt;(list);
        // Equivalent to
        std::string str(std::from_range, list);
        
        // Result type is not an input range:
        auto pair_to = std::ranges::to&lt;std::pair&lt;std::from_range_t, bool&gt;&gt;(true);
        // Equivalent to
        std::pair&lt;std::from_range_t, bool&gt; pair(std::from_range, true);
    }
    
    // 1.a.3) iterator pair ctor
    {
        auto list = {'a', 'b', '\0', 'c'};
        
        // Argument type is convertible to result value type:
        auto devector_to = std::ranges::to&lt;boost::container::devector&lt;char&gt;&gt;(list);
        // Equivalent to
        boost::container::devector&lt;char&gt; devector(std::ranges::begin(list), 
                                                  std::ranges::end(list));
        
        // Result type is not an input range:
        std::regex re;
        auto it_to = std::ranges::to&lt;std::cregex_iterator&gt;(list, re);
        // Equivalent to
        std::cregex_iterator it(std::ranges::begin(list), std::ranges::end(list), re);
    }
}
|output=
[2, 4, 6, 8]
[2, 4, 6]
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3984|std=C++23|before=the nested construction branch of {{tt|ranges::to}} resulted to&lt;br&gt;program ill-formed if {{tt|R&amp;}} does not model {{lconcept|viewable_range}}|after=made well-formed}}
{{dr list item|wg=lwg|dr=4016|std=C++23|before=the container insertion branch of&lt;br&gt;{{tt|ranges::to}} involved use of insert iterators|after=replaced with direct appending&lt;br&gt;of elements to container}}
{{dr list end}}

===References===
{{ref std c++23}}
{{ref std|title=Range conversions|id=range.utility.conv|section=26.5.7}}
{{ref std end}}

{{langlinks|zh}}