{{cpp/ranges/title|range_adaptor_closure}}
{{cpp/ranges/navbar}}

{{ddcl|header=ranges|since=c++23|1=
template&lt; class D &gt;
    requires std::is_object_v&lt;D&gt; &amp;&amp; std::same_as&lt;D, std::remove_cv_t&lt;D&gt;&gt;
class range_adaptor_closure {};
}}

{{tt|std::ranges::range_adaptor_closure}} is a helper class template for defining a {{named req|RangeAdaptorClosureObject}}.

Let {{c|t}} be the object of type {{tt|T}}, the implementation ensures that {{c|t}} is a range adaptor closure object if all the requirements are met:
* {{c|t}} is a unary function object that takes one {{lconcept|range}} argument.
* {{tt|T}} has exactly one public base class {{c/core|ranges::range_adaptor_closure&lt;T&gt;}}, and {{tt|T}} has no base classes of type {{c/core|ranges::range_adaptor_closure&lt;U&gt;}} for any other type {{tt|U}}.
* {{tt|T}} does not satisfy {{lconcept|range}}.

===Notes===
{{ftm begin}}
{{ftm|__cpp_lib_ranges|value=202202L|std=C++23|{{tt|std::ranges::range_adaptor_closure}}}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;ranges&gt;
#include &lt;string_view&gt;

// Define Slice as a range adaptor closure
struct Slice : std::ranges::range_adaptor_closure&lt;Slice&gt;
{
    std::size_t start = 0;
    std::size_t end = std::string_view::npos;

    constexpr std::string_view operator()(std::string_view sv) const
    {
        return sv.substr(start, end - start);
    }
};

int main()
{
    constexpr std::string_view str = "01234567";

    constexpr Slice slicer{.start = 1, .end = 6};

    // use slicer as a normal function object
    constexpr auto sv1 = slicer(str);
    static_assert(sv1 == "12345");

    // use slicer as a range adaptor closure object
    constexpr auto sv2 = str {{!}} slicer;
    static_assert(sv2 == "12345");

    // range adaptor closures can be composed
    constexpr auto slice_and_drop = slicer {{!}} std::views::drop(2);
    static_assert(std::string_view(str {{!}} slice_and_drop) == "345");
}
}}

{{langlinks|de|es|ja|ru|zh}}