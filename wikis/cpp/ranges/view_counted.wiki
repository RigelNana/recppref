{{cpp/ranges/views/title|counted}}
{{cpp/ranges/navbar}}

{{dcl begin}}
{{dcl header|ranges}}
{{dcl|since=c++20|1=
inline constexpr /*unspecified*/ counted = /*unspecified*/;
}}
{{dcl h|Call signature}}
{{dcl|since=c++20|1=
template&lt; class Iterator, class DifferenceType &gt;
    requires /* see below */
constexpr /*span-or-subrange*/ counted( Iterator&amp;&amp; it, DifferenceType&amp;&amp; count );
}}
{{dcl end}}

A counted view presents a {{lconcept|view}} of the elements of the ''counted range'' {{range/core|i|n}} for some iterator {{tt|i}} and non-negative integer {{tt|n}}.

A counted range {{range/core|i|n}} is the {{tt|n}} elements starting with the element pointed to by {{tt|i}} and up to but not including the element, if any, pointed to by the result of {{tt|n}} applications of {{c|++i}}.

If {{c|1=n == 0}}, the counted range is valid and empty. Otherwise, the counted range is only valid if {{tt|n}} is positive, {{tt|i}} is dereferenceable, and {{range|++i|--n}} is a valid counted range.

Formally, if {{c|it}} and {{c|count}} are expressions, {{tt|T}} is {{c|std::decay_t&lt;decltype((it))&gt;}}, and {{tt|D}} is {{c|std::iter_difference_t&lt;T&gt;}}, then
: if {{tt|T}} models {{lconcept|input_or_output_iterator}} and {{c|decltype((count))}} models {{c|std::convertible_to&lt;D&gt;}},
:* if {{tt|T}} models {{lconcept|contiguous_iterator}}, then {{c|views::counted(it, count)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to {{c|std::span(std::to_address(it), static_cast&lt;std::size_t&gt;(static_cast&lt;D&gt;(count)))}},
:* otherwise, if {{tt|T}} models {{lconcept|random_access_iterator}}, then {{c|views::counted(it, count)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to {{c|ranges::subrange(it, it + static_cast&lt;D&gt;(count))}},
:* otherwise, {{c|views::counted(it, count)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to {{c|ranges::subrange(std::counted_iterator(it, count), std::default_sentinel)}}.
: Otherwise, {{c|views::counted(it, count)}} is ill-formed.

{{cpp/ranges/cpo|views|counted}}

===Notes===
{{ttt|views::counted}} does not check if the range is long enough to provide all {{c|count}} elements: use {{c/core|views::take}} if that check is necessary.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;ranges&gt;

int main()
{
    const int a[]{1, 2, 3, 4, 5, 6, 7};
    for (int i : std::views::counted(a, 3))
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    const auto il = {1, 2, 3, 4, 5};
    for (int i : std::views::counted(il.begin() + 1, 3))
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
1 2 3
2 3 4
}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P2393R1|std=C++20|before=implicit conversion from an integer-class type to {{c/core|std::size_t}} might be invalid|after=made explicit}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc take_view}}
{{dsc inc|cpp/ranges/dsc subrange}}
{{dsc inc|cpp/iterator/dsc counted_iterator}}
{{dsc inc|cpp/algorithm/ranges/dsc count}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}