{{cpp/title|tuple_element&lt;small&gt;&lt;std::ranges::subrange&gt;&lt;/small&gt;}}
{{cpp/ranges/subrange/navbar}}
{{dcl begin}}
{{dcl header|ranges}}
{{dcl|num=1|since=c++20|
template&lt; class I, class S, ranges::subrange_kind K &gt;
struct tuple_element&lt;0, ranges::subrange&lt;I, S, K&gt;&gt;;
}}
{{dcl|num=2|since=c++20|
template&lt; class I, class S, ranges::subrange_kind K &gt;
struct tuple_element&lt;0, const ranges::subrange&lt;I, S, K&gt;&gt;;
}}
{{dcl|num=3|since=c++20|
template&lt; class I, class S, ranges::subrange_kind K &gt;
struct tuple_element&lt;1, ranges::subrange&lt;I, S, K&gt;&gt;;
}}
{{dcl|num=4|since=c++20|
template&lt; class I, class S, ranges::subrange_kind K &gt;
struct tuple_element&lt;1, const ranges::subrange&lt;I, S, K&gt;&gt;;
}}
{{dcl end}}

The partial specializations of {{ltt|cpp/utility/tuple_element|std::tuple_element}} for {{lc|std::ranges::subrange}} provide compile-time access to the iterator or sentinel type of a {{tt|subrange}}, using tuple-like syntax. They are provided for structured binding support.

@1,2@ Obtains the iterator type, i.e. {{tt|I}}.
@3,4@ Obtains the sentinel type, i.e. {{tt|S}}.

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc|{{tt|type}}|{{v|1,2}} {{tt|I}}&lt;br&gt;{{v|3,4}} {{tt|S}}}}
{{dsc end}}

===Notes===
As {{rlpt|get}} functions for {{tt|subrange}} return iterators and sentinels by value, {{c|const}} qualifier is not added to the result types when the {{tt|subrange}} is const-qualified (but not volatile-qualified).

If the {{tt|subrange}} is volatile-qualified, the result types are also volatile-qualified because the partial specialization for volatile or const volatile types are used. Such usage is deprecated.

===Example===
{{example
|code=
#include &lt;iterator&gt;
#include &lt;list&gt;
#include &lt;ranges&gt;
#include &lt;type_traits&gt;

int main()
{
    std::list&lt;int&gt; list{3, 1, 4, 1, 5, 9, 2, 6};

    std::ranges::subrange subrange
    {
        std::counted_iterator{std::begin(list), 4},
        std::default_sentinel
    };

    static_assert(
        std::is_same_v&lt;
            std::tuple_element_t&lt;0, decltype(subrange)&gt;,
            // implementation-defined type:
            std::counted_iterator&lt;std::_List_iterator&lt;int&gt;&gt;
            &gt;);

    static_assert(
        std::is_same_v&lt;
            std::tuple_element_t&lt;1, decltype(subrange)&gt;,
            std::default_sentinel_t
            &gt;);
}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc structured binding}}
{{dsc inc|cpp/utility/dsc tuple_element}}
{{dsc inc|cpp/ranges/subrange/dsc tuple_size}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}