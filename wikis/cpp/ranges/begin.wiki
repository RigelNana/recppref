{{cpp/ranges/title|begin}}
{{cpp/ranges/navbar}}
{{dcl begin}}
{{dcl header|ranges}}
{{dcl header|iterator}}
{{dcl|notes={{mark custpt}}|since=c++20|1=
inline namespace /* unspecified */ {
    inline constexpr /* unspecified */ begin = /* unspecified */;
}
}}
{{dcl h|Call signature}}
{{dcl|since=c++20|1=
template&lt; class T &gt;
    requires /* see below */
constexpr std::input_or_output_iterator auto begin( T&amp;&amp; t );
}}
{{dcl end}}

Returns an iterator to the first element of the argument.

{{image|range-begin-end.svg}}

If the argument is an lvalue or {{c|ranges::enable_borrowed_range&lt;std::remove_cv_t&lt;T&gt;&gt;}} is {{c|true}}, then a call to {{tt|ranges::begin}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to:
# {{c|t + 0}} if {{c|t}} has an array type.
#* If {{c/core|std::remove_all_extents_t&lt;std::remove_reference_t&lt;T&gt;&gt;}} is incomplete, then the call to {{tt|ranges::begin}} is ill-formed, no diagnostic required.
# Otherwise, {{rev inl|until=c++23|{{box|{{lti|cpp/standard library/decay-copy}}{{c/core|(t.begin())}}}}}}{{rev inl|since=c++23|{{c|auto(t.begin())}}}}, if that expression is valid and its type models {{lc|std::input_or_output_iterator}}.
# Otherwise, {{rev inl|until=c++23|{{box|{{lti|cpp/standard library/decay-copy}}{{c/core|(begin(t))}}}}}}{{rev inl|since=c++23|{{c|auto(begin(t))}}}}, if {{tt|T}} is a class or enumeration type, that expression is valid and its type models {{lc|std::input_or_output_iterator}}, where the meaning of {{tt|begin}} is established as if by performing [[cpp/language/adl|argument-dependent lookup]] only.

In all other cases, a call to {{tt|ranges::begin}} is ill-formed, which can result in [[cpp/language/sfinae|substitution failure]] when the call appears in the immediate context of a template instantiation.

{{cpp/ranges/cpo}}

===Notes===
If the argument is an rvalue (i.e. {{tt|T}} is an object type) and {{c|ranges::enable_borrowed_range&lt;std::remove_cv_t&lt;T&gt;&gt;}} is {{c|false}}, the call to {{tt|ranges::begin}} is ill-formed, which also results in substitution failure.

The return type models {{lc|std::input_or_output_iterator}} in all cases.

{{cpp/ranges/prv}}

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;
 
int main() 
{
    std::vector v{3, 1, 4};
    auto vi = std::ranges::begin(v);
    auto vci = std::ranges::cbegin(v);
    assert(*vi == 3 and *vi == *vci);
    ++vi;
    ++vci; // OK: vci is modifiable object
    *vi = 42; // OK: vi points to mutable element
    // *vci = 13; // Error: vci points to immutable element

    int a[]{-5, 10, 15};
    auto ai = std::ranges::begin(a); // works with C-arrays as well
    assert(*ai == -5);
    *ai = 42; // OK
}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P2602R2|std=C++20|before=there's machinery to prohibit certain non-member {{tt|begin}} found by [[cpp/language/adl|ADL]]|after=removed such machinery}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc cbegin}}
{{dsc inc|cpp/iterator/dsc begin}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}