{{cpp/ranges/title|subrange}}
{{cpp/ranges/subrange/navbar}}

{{dcl begin}}
{{dcl header|ranges}}
{{dcl|num=1|since=c++20|1=
template&lt;
    std::input_or_output_iterator I,
    std::sentinel_for&lt;I&gt; S = I,
    ranges::subrange_kind K = std::sized_sentinel_for&lt;S, I&gt; ?
                                  ranges::subrange_kind::sized :
                                  ranges::subrange_kind::unsized
&gt;
    requires (K == ranges::subrange_kind::sized {{!!}}
                 !std::sized_sentinel_for&lt;S, I&gt;)
class subrange
    : public ranges::view_interface&lt;subrange&lt;I, S, K&gt;&gt;
}}
{{dcl h|Helper concepts}}
{{dcla|num=2|expos=yes|1=
template&lt;class From, class To&gt;
concept /*uses-nonqualification-pointer-conversion*/ =
    /* see description */;
}}
{{dcla|num=3|expos=yes|1=
template&lt;class From, class To&gt;
concept /*convertible-to-non-slicing*/ = /* see description */;
}}
{{dcl end}}

@1@ The {{tt|subrange}} class template combines together an iterator and a sentinel into a single {{lconcept|view}}. It models {{lconcept|sized_range}} whenever the final template parameter is {{c|subrange_kind​::​sized}} (which happens when {{c|std::sized_sentinel_for&lt;S, I&gt;}} is satisfied or when size is passed explicitly as a constructor argument).

@2@ Determines whether {{tt|From}} is convertible to {{tt|To}} without {{lsd|cpp/language/implicit conversion#Qualification conversions}}. Equivalent to:
{{source|1=
template&lt;class From, class To&gt;
concept /*uses-nonqualification-pointer-conversion*/ =
    std::is_pointer_v&lt;From&gt; &amp;&amp; std::is_pointer_v&lt;To&gt; &amp;&amp;
        !std::convertible_to&lt;std::remove_pointer_t&lt;From&gt;(*)[],
                             std::remove_pointer_t&lt;To&gt;(*)[]&gt;;
}}

@3@ Determines whether {{tt|From}} is convertible to {{tt|To}} without derived-to-base conversion:
{{source|1=
template&lt;class From, class To&gt;
concept /*convertible-to-non-slicing*/ =
    std::convertible_to&lt;From, To&gt; &amp;&amp;
        !/*uses-nonqualification-pointer-conversion*/
            &lt;std::decay_t&lt;From&gt;, std::decay_t&lt;To&gt;&gt;;
}}

===Data members===
{{dsc begin}}
{{dsc hitem|Member|Definition}}
{{dsc expos mem sconst|spec={{c/core|constexpr bool}}|StoreSize|id=﻿StoreSize|{{box|{{c/core|1=K == ranges::subrange_kind::sized &amp;&amp;}}&lt;br&gt;{{nbspt|4}}{{c/core|!std::sized_sentinel_for&lt;S, I&gt;}}}}}}
{{dsc expos mem obj|spec={{tt|I}}|begin_|id=begin|an iterator to the beginning of the subrange}}
{{dsc expos mem obj|spec={{tt|S}}|end_|id=end|a sentinel denoting the end of the subrange}}
{{dsc expos mem obj|spec={{lsi|cpp/ranges#make-unsigned-like-t}}{{sep}}{{c/core|&lt;std::iter_difference_t&lt;I&gt;&gt;}}|size_|id=size|maybe=(present only if {{tti|StoreSize}} is {{c|true}})|the size of the subrange}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc mem ctor|cpp/ranges/subrange/subrange|creates a new {{tt|subrange}}}}
{{dsc inc|cpp/ranges/subrange/dsc operator PairLike}}

{{dsc h2|Observers}}
{{dsc inc|cpp/ranges/subrange/dsc begin}}
{{dsc inc|cpp/ranges/subrange/dsc end}}
{{dsc inc|cpp/ranges/subrange/dsc empty}}
{{dsc inc|cpp/ranges/subrange/dsc size}}

{{dsc h2|Iterator operations}}
{{dsc inc|cpp/ranges/subrange/dsc advance}}
{{dsc inc|cpp/ranges/subrange/dsc prev}}
{{dsc inc|cpp/ranges/subrange/dsc next}}

{{cpp/ranges/view_interface/inherit|embedded=yes|empty=yes|size=yes}}
{{dsc end}}

==={{rl|deduction guides|Deduction guides}}===

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/ranges/subrange/dsc get}}
{{dsc end}}

===Helper types===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc subrange_kind}}
{{dsc inc|cpp/ranges/subrange/dsc tuple_size}}
{{dsc inc|cpp/ranges/subrange/dsc tuple_element}}
{{dsc end}}

===Helper templates===
{{ddcl|since=c++20|1=
template&lt; class I, class S, ranges::subrange_kind K &gt;
constexpr bool ranges::enable_borrowed_range&lt;ranges::subrange&lt;I, S, K&gt;&gt; = true;
}}
This specialization of {{c/core|ranges::enable_borrowed_range}} makes {{tt|subrange}} satisfy {{lconcept|borrowed_range}}.

===Example===
{{example
|code=
#include &lt;map&gt;
#include &lt;print&gt;
#include &lt;ranges&gt;
 
void make_uppercase(char&amp; v)
{
    v += 'A' - 'a';
}
 
void uppercase_transform(std::multimap&lt;int, char&gt;&amp; m, int k)
{
    auto [first, last] = m.equal_range(k);
    for (auto&amp; [_, v] : std::ranges::subrange(first, last))
        make_uppercase(v);
}
 
int main()
{
    std::multimap&lt;int, char&gt; mm{&lt;!----&gt;{4, 'a'}, {3, '-'}, {4, 'b'}, {5, '-'}, {4, 'c'}&lt;!----&gt;};
    std::println("Before: {}", mm);
    uppercase_transform(mm, 4);
    std::println("After:  {}", mm);
}
|output=
Before: {3: '-', 4: 'a', 4: 'b', 4: 'c', 5: '-'}
After:  {3: '-', 4: 'A', 4: 'B', 4: 'C', 5: '-'}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3470|std=C++20|before={{tti|convertible-to-non-slicing}} might reject qualification conversions|after=always accepts them}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc view_interface}}
{{dsc end}}

===External links===
{{eli|[https://stackoverflow.com/a/59659686 Read/write all values of a {{tt|std::multimap}} with a given key in C++20] &amp;mdash; SO}}

{{langlinks|es|ja|ru|zh}}