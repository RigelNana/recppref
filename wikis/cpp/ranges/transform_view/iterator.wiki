{{cpp/ranges/transform_view/title|''iterator''}}
{{cpp/ranges/transform_view/navbar}}

{{ddcl|since=c++20|notes={{mark expos}}|
template&lt; bool Const &gt;
class /*iterator*/
}}

The return type of {{rlpt|begin|transform_view::begin}}, and of {{rlpt|end|transform_view::end}} when the underlying view is a {{lconcept|common_range}}.

The type {{c|/*iterator*/&lt;true&gt;}} is returned by the const-qualified overloads. The type {{c|/*iterator*/&lt;false&gt;}} is returned by the non-const-qualified overloads.

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc expos mem type|Parent|private=yes|{{cpp/ranges/maybe-const|ranges::transform_view&lt;V, F&gt;}}}}
{{dsc expos mem type|Base|private=yes|{{cpp/ranges/maybe-const|V}}}}
{{dsc|{{tt|iterator_concept}}|
*{{lc|std::random_access_iterator_tag}}, if {{tti|Base}} models {{lconcept|random_access_range}},
*{{lc|std::bidirectional_iterator_tag}}, if {{tti|Base}} models {{lconcept|bidirectional_range}},
*{{lc|std::forward_iterator_tag}}, if {{tti|Base}} models {{lconcept|forward_range}},
*{{lc|std::input_iterator_tag}} otherwise.}}
{{dsc|{{tt|iterator_category}}&lt;br&gt;{{small|(present only if {{tti|Base}} models&lt;br&gt;{{lconcept|forward_range}})}}|Let {{tt|MCF}} be {{cpp/ranges/maybe-const|F}}.
*{{lc|std::input_iterator_tag}}, if {{c/core|std::invoke_result_t&lt;MCF&amp;, ranges::range_reference_t&lt;Base&gt;&gt;}} is not a reference.
Otherwise, let {{tti|C}} be {{c/core|std::iterator_traits&lt;ranges::iterator_t&lt;Base&gt;&gt;::iterator_category}}.
*{{lc|std::random_access_iterator_tag}}, if {{tti|C}} is {{lc|std::contiguous_iterator_tag}}; 
*{{tti|C}}, otherwise.}}
{{dsc|{{tt|value_type}}|{{c/core|std::remove_cvref_t&lt;std::invoke_result_t&lt;MCF&amp;, ranges::range_reference_t&lt;Base&gt;&gt;&gt;}}, where {{tt|MCF}} denotes {{cpp/ranges/maybe-const|F}}}}
{{dsc|{{tt|difference_type}}|{{c/core|ranges::range_difference_t&lt;Base&gt;}}}}
{{dsc end}}

===Data members===
{{dsc begin}}
{{dsc hitem|Member name|Definition}}
{{dsc expos mem obj|current_|private=yes|An iterator into (possibly const-qualified) {{tt|V}}.}}
{{dsc expos mem obj|parent_|private=yes|A pointer to parent {{tt|transform_view}}.}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc mem ctor|cpp/ranges/transform_view/iterator/iterator|constructs an iterator}}
{{dsc mem fun|cpp/ranges/transform_view/iterator/base|returns the underlying iterator}}
{{dsc mem fun|cpp/ranges/transform_view/iterator/operator*|accesses the transformed element}}
{{dsc mem fun|cpp/ranges/transform_view/iterator/operator_at|title=operator[]|accesses an element by index}}
{{dsc mem fun|cpp/ranges/transform_view/iterator/operator_arith|title=operator++&lt;br&gt;operator++{{small|(int)}}&lt;br&gt;operator--&lt;br&gt;operator--{{small|(int)}}&lt;br&gt;operator+=&lt;br&gt;operator-=|advances or decrements the underlying iterator}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc fun|cpp/ranges/transform_view/iterator/operator_cmp|title=operator==&lt;br&gt;operator&lt;&lt;br&gt;operator&gt;&lt;br&gt;operator&lt;=&lt;br&gt;operator&gt;=&lt;br&gt;operator&lt;=&gt;|compares the underlying iterators|notes={{mark c++20}}}}
{{dsc fun|cpp/ranges/transform_view/iterator/operator_arith2|title=operator+&lt;br&gt;operator-|performs iterator arithmetic|notes={{mark c++20}}}}
{{dsc fun|cpp/ranges/transform_view/iterator/iter_move|obtains an rvalue reference to the transformed element|notes={{mark c++20}}}}
{{dsc end}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P2259R1|std=C++20|before=member {{tt|iterator_category}} is always defined|after=defined only if {{tti|Base}} models {{lconcept|forward_range}}}}
{{dr list item|wg=lwg|dr=3555|std=C++20|before=the definition of {{tt|iterator_concept}} ignores const|after=made to consider}}
{{dr list item|wg=lwg|dr=3798|std=C++20|before={{tt|iterator_category}} is input-only if transformation result is rvalue reference|after=may have a stronger category}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}