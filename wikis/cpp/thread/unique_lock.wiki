{{cpp/title|unique_lock}}
{{cpp/thread/unique_lock/navbar}}
{{ddcl|header=mutex|since=c++11|1=
template&lt; class Mutex &gt;
class unique_lock;
}}

The class {{tt|unique_lock}} is a general-purpose mutex ownership wrapper allowing deferred locking, time-constrained attempts at locking, recursive locking, transfer of lock ownership, and use with condition variables. 

The class {{tt|unique_lock}} is movable, but not copyable -- it meets the requirements of {{named req|MoveConstructible}} and {{named req|MoveAssignable}} but not of {{named req|CopyConstructible}} or {{named req|CopyAssignable}}.

The class {{tt|unique_lock}} meets the {{named req|BasicLockable}} requirements. If {{tt|Mutex}} meets the {{named req|Lockable}} requirements, {{tt|unique_lock}} also meets the {{named req|Lockable}} requirements (ex.: can be used in {{lc|std::lock}}); if {{tt|Mutex}} meets the {{named req|TimedLockable}} requirements, {{tt|unique_lock}} also meets the {{named req|TimedLockable}} requirements.

===Template parameters===
{{par begin}}
{{par|Mutex|the type of the mutex to lock. The type must meet the {{named req|BasicLockable}} requirements}}
{{par end}}

===Nested types===
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|mutex_type}}|{{tt|Mutex}}}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/thread/unique_lock/dsc constructor}}
{{dsc inc|cpp/thread/unique_lock/dsc destructor}}
{{dsc inc|cpp/thread/unique_lock/dsc operator{{=}}}}

{{dsc h2|Locking}}
{{dsc inc|cpp/thread/unique_lock/dsc lock}}
{{dsc inc|cpp/thread/unique_lock/dsc try_lock}}
{{dsc inc|cpp/thread/unique_lock/dsc try_lock_for}}
{{dsc inc|cpp/thread/unique_lock/dsc try_lock_until}}
{{dsc inc|cpp/thread/unique_lock/dsc unlock}}

{{dsc h2|Modifiers}}
{{dsc inc|cpp/thread/unique_lock/dsc swap}}
{{dsc inc|cpp/thread/unique_lock/dsc release}}

{{dsc h2|Observers}}
{{dsc inc|cpp/thread/unique_lock/dsc mutex}}
{{dsc inc|cpp/thread/unique_lock/dsc owns_lock}}
{{dsc inc|cpp/thread/unique_lock/dsc operator bool}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/thread/unique_lock/dsc swap2}}
{{dsc end}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

struct Box
{
    explicit Box(int num) : num_things{num} {}
    
    int num_things;
    std::mutex m;
};

void transfer(Box&amp; from, Box&amp; to, int num)
{
    // don't actually take the locks yet
    std::unique_lock lock1{from.m, std::defer_lock};
    std::unique_lock lock2{to.m, std::defer_lock};
    
    // lock both unique_locks without deadlock
    std::lock(lock1, lock2);
    
    from.num_things -= num;
    to.num_things += num;
    
    // “from.m” and “to.m” mutexes unlocked in unique_lock dtors
}

int main()
{
    Box acc1{100};
    Box acc2{50};
    
    std::thread t1{transfer, std::ref(acc1), std::ref(acc2), 10};
    std::thread t2{transfer, std::ref(acc2), std::ref(acc1), 5};
    
    t1.join();
    t2.join();
    
    std::cout &lt;&lt; "acc1: " &lt;&lt; acc1.num_things &lt;&lt; "\n"
                 "acc2: " &lt;&lt; acc2.num_things &lt;&lt; '\n';
}
|output=
acc1: 95
acc2: 55
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2981|std=C++17|before=redundant deduction guide from {{tt|unique_lock&lt;Mutex&gt;}} was provided|after=removed}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/thread/dsc lock}}
{{dsc inc|cpp/thread/dsc lock_guard}}
{{dsc inc|cpp/thread/dsc scoped_lock}}
{{dsc inc|cpp/thread/dsc mutex}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}