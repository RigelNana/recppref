{{cpp/thread/unique_lock/title|unique_lock}}
{{cpp/thread/unique_lock/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++11|1=
unique_lock() noexcept;
}}
{{dcl|num=2|since=c++11|1=
unique_lock( unique_lock&amp;&amp; other ) noexcept;
}}
{{dcl|num=3|since=c++11|1=
explicit unique_lock( mutex_type&amp; m );
}}
{{dcl|num=4|since=c++11|1=
unique_lock( mutex_type&amp; m, std::defer_lock_t t ) noexcept;
}}
{{dcl|num=5|since=c++11|1=
unique_lock( mutex_type&amp; m, std::try_to_lock_t t );
}}
{{dcl|num=6|since=c++11|1=
unique_lock( mutex_type&amp; m, std::adopt_lock_t t );
}}
{{dcl|num=7|since=c++11|1=
template&lt; class Rep, class Period &gt;
unique_lock( mutex_type&amp; m,
             const std::chrono::duration&lt;Rep, Period&gt;&amp; timeout_duration );
}}
{{dcl|num=8|since=c++11|1=
template&lt; class Clock, class Duration &gt;
unique_lock( mutex_type&amp; m,
             const std::chrono::time_point&lt;Clock, Duration&gt;&amp; timeout_time );
}}
{{dcl end}}

Constructs a {{tt|unique_lock}}, optionally locking the supplied mutex.

@1@ Constructs a {{tt|unique_lock}} with no associated mutex.
@2@ Move constructor. Initializes the {{tt|unique_lock}} with the contents of {{c|other}}. Leaves {{c|other}} with no associated mutex.
@3-8@ Constructs a {{tt|unique_lock}} with {{c|m}} as the associated mutex. Additionally:
:@3@ Locks the associated mutex by calling {{c|m.lock()}}.
:@4@ Does not lock the associated mutex.
:@5@ Tries to lock the associated mutex without blocking by calling {{c|m.try_lock()}}. The behavior is undefined if {{tt|Mutex}} does not satisfy {{named req|Lockable}}.
:@6@ Assumes the calling thread already holds a non-shared lock (i.e., a lock acquired by {{tt|lock}}, {{tt|try_lock}}, {{tt|try_lock_for}}, or {{tt|try_lock_until}}) on {{c|m}}. The behavior is undefined if not so.&lt;!--P2160R1--&gt;
:@7@ Tries to lock the associated mutex by calling {{c|m.try_lock_for(timeout_duration)}}. Blocks until specified {{c|timeout_duration}} has elapsed or the lock is acquired, whichever comes first. May block for longer than {{c|timeout_duration}}. The behavior is undefined if {{tt|Mutex}} does not satisfy {{named req|TimedLockable}}.
:@8@ Tries to lock the associated mutex by calling {{c|m.try_lock_until(timeout_time)}}. Blocks until specified {{c|timeout_time}} has been reached or the lock is acquired, whichever comes first. May block for longer than until {{c|timeout_time}} has been reached. The behavior is undefined if {{tt|Mutex}} does not satisfy {{named req|TimedLockable}}.

===Parameters===
{{par begin}}
{{par|other|another {{tt|unique_lock}} to initialize the state with}}
{{par|m|mutex to associate with the lock and optionally acquire ownership of}}
{{par|t|tag parameter used to select constructors with different locking strategies}}
{{par|timeout_duration|maximum duration to block for}}
{{par|timeout_time|maximum time point to block until}}
{{par end}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

std::mutex m_a, m_b, m_c;
int a, b, c = 1;

void update()
{
    {   // Note: std::lock_guard or atomic&lt;int&gt; can be used instead
        std::unique_lock&lt;std::mutex&gt; lk(m_a);
        ++a;
    }
    
    {   // Note: see std::lock and std::scoped_lock for details and alternatives
        std::unique_lock&lt;std::mutex&gt; lk_b(m_b, std::defer_lock);
        std::unique_lock&lt;std::mutex&gt; lk_c(m_c, std::defer_lock);
        std::lock(lk_b, lk_c);
        b = std::exchange(c, b + c);
    }
}

int main()
{
    std::vector&lt;std::thread&gt; threads;
    for (unsigned i = 0; i &lt; 12; ++i)
        threads.emplace_back(update);

    for (auto&amp; i : threads)
        i.join();
    
    std::cout &lt;&lt; a &lt;&lt; "'th and " &lt;&lt; a + 1 &lt;&lt; "'th Fibonacci numbers: "
              &lt;&lt; b &lt;&lt; " and " &lt;&lt; c &lt;&lt; '\n';
}
|output=
12'th and 13'th Fibonacci numbers: 144 and 233
}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}