{{cpp/title|async}}
{{cpp/thread/navbar}}
{{dcl begin}}
{{dcl header|future}}
{{dcl|num=1|since=c++11|
template&lt; class F, class... Args &gt;
std::future&lt;/* see below */&gt; async( F&amp;&amp; f, Args&amp;&amp;... args );
}}
{{dcl|num=2|since=c++11|
template&lt; class F, class... Args &gt;
std::future&lt;/* see below */&gt; async( std::launch policy,
                                    F&amp;&amp; f, Args&amp;&amp;... args );
}}
{{dcl end}}

The function template {{tt|std::async}} runs the function {{c|f}} asynchronously (potentially in a separate thread which might be a part of a thread pool) and returns a {{lc|std::future}} that will eventually hold the result of that function call.
@1@ Behaves as if {{v|2}} is called with {{c|policy}} being {{c|std::launch::async {{!}} std::launch::deferred}}.
@2@ Calls a function {{c|f}} with arguments {{c|args}} according to a specific launch policy {{c|policy}} (see [[#Launch policies|below]]).

The return type of {{tt|std::async}} is {{c/core|std::future&lt;V&gt;}}, where {{tt|V}} is:
{{rrev multi|until1=c++17
|rev1=
{{cc multi
|typename std::result_of&lt;typename std::decay&lt;F&gt;::type(
|                        typename std::decay&lt;Args&gt;::type...)&gt;::type}}.
|rev2=
{{c/core|std::invoke_result_t&lt;std::decay_t&lt;F&gt;, std::decay_t&lt;Args&gt;...&gt;}}.
}}


{{rrev multi|until1=c++20
|rev1=
If any of the following conditions is satisfied, the program is ill-formed:
* {{tt|F}} is not {{named req|MoveConstructible}}.
* Any type in {{tt|Args}} is not {{named req|MoveConstructible}}.
* {{box|{{lti|cpp/utility/functional|INVOKE}}{{c/core|(}}{{lti|cpp/standard library/decay-copy}}{{c/core|(std::forward&lt;F&gt;(f)),}}&lt;br&gt;{{nbspt|7}}{{lti|cpp/standard library/decay-copy}}{{c/core|(std::forward&lt;Args&gt;(args))...)}}}} is not a valid expression.
|rev2=
If any of the following is {{c|false}}, the program is ill-formed:
* {{c|std::is_constructible_v&lt;std::decay_t&lt;F&gt;, F&gt;}}
* {{c|(std::is_constructible_v&lt;std::decay_t&lt;Args&gt;, Args&gt; &amp;&amp; ...)}}
* {{c|std::is_invocable_v&lt;std::decay_t&lt;F&gt;, std::decay_t&lt;Args&gt;...&gt;}}
}}

The call to {{tt|std::async}} [[cpp/atomic/memory_order|synchronizes with]] the call to {{c|f}}, and the completion of {{c|f}} is [[cpp/language/eval order|sequenced before]] making the shared state ready.

===Parameters===
{{par begin}}
{{par|f|{{named req|Callable}} object to call}}
{{par|args|parameters to pass to {{c|f}}}}
{{par|policy|bitmask value, where individual bits control the allowed methods of execution}}
{{par end}}

===Return value===
{{lc|std::future}} referring to the shared state created by this call to {{tt|std::async}}.

===Launch policies===
====Async invocation====
If the ''async'' flag is set, i.e. {{c|1=(policy &amp; std::launch::async) != 0}}, then {{tt|std::async}} calls
{{rrev multi|until1=c++23
|rev1=
{{box|{{lti|cpp/utility/functional|INVOKE}}{{c/core|(}}{{lti|cpp/standard library/decay-copy}}{{c/core|(std::forward&lt;F&gt;(f)),}}&lt;br&gt;{{c/core| }}{{c/core| }}{{c/core| }}{{c/core| }}{{c/core| }}{{c/core| }}{{c/core| }}{{lti|cpp/standard library/decay-copy}}{{c/core|(std::forward&lt;Args&gt;(args))...)}}}}
|rev2=
{{c multi
|std::invoke(auto(std::forward&lt;F&gt;(f)),
|            auto(std::forward&lt;Args&gt;(args))...)}}
}}
as if in a new thread of execution represented by a {{lc|std::thread}} object.

{{rrev multi|until1=c++23
|rev1=The calls of {{lti|cpp/standard library/decay-copy}} are evaluated in the current thread.
|rev2=The values produced by {{c/core|auto}} are [[cpp/language/implicit conversion#Temporary materialization|materialized]] in the current thread.
}}
If the function {{c|f}} returns a value or throws an exception, it is stored in the shared state accessible through the {{lc|std::future}} that {{tt|std::async}} returns to the caller.

====Deferred invocation====
If the ''deferred'' flag is set (i.e. {{c|1=(policy &amp; std::launch::deferred) != 0}}), then {{tt|std::async}} stores
{{rrev multi|until1=c++23
|rev1={{box|{{lti|cpp/standard library/decay-copy}}{{c/core|(std::forward&lt;F&gt;(f))}}}} and {{box|{{lti|cpp/standard library/decay-copy}}{{c/core|(std::forward&lt;Args&gt;(args))...}}}} in the shared state.
|rev2={{c|auto(std::forward&lt;F&gt;(f))}} and {{c|auto(std::forward&lt;Args&gt;(args))...}} in the shared state.
}}

''Lazy evaluation'' is performed:
* The first call to a non-timed wait function on the {{lc|std::future}} that {{tt|std::async}} returned to the caller will evaluate {{box|{{lti|cpp/utility/functional|INVOKE}}{{c/core|(std::move(g), std::move(xyz))}}}} in the thread that called the waiting function (which does not have to be the thread that originally called {{tt|std::async}}), where
{{rrev multi|until1=c++23|rev1=
:* {{c|g}} is the stored value of {{box|{{lti|cpp/standard library/decay-copy}}{{c/core|(std::forward&lt;F&gt;(f))}}}} and
:* {{c|xyz}} is the stored copy of {{box|{{lti|cpp/standard library/decay-copy}}{{c/core|(std::forward&lt;Args&gt;(args))...}}}}.
|rev2=
:* {{c|g}} is the stored value of {{c|auto(std::forward&lt;F&gt;(f))}} and
:* {{c|xyz}} is the stored copy of {{c|auto(std::forward&lt;Args&gt;(args))...}}.
}}
* The result or exception is placed in the shared state associated with the returned {{lc|std::future}} and only then it is made ready. All further accesses to the same {{lc|std::future}} will return the result immediately.

====Other policies====
If neither {{lc|std::launch::async}} nor {{lc|std::launch::deferred}}, nor any implementation-defined policy flag is set in {{c|policy}}, the behavior is undefined.

===Policy selection===
If more than one flag is set, it is implementation-defined which policy is selected. For the default (both the {{lc|std::launch::async}} and {{lc|std::launch::deferred}} flags are set in {{c|policy}}), standard recommends (but does not require) utilizing available concurrency, and deferring any additional tasks.

If the {{lc|std::launch::async}} policy is chosen,
* a call to a waiting function on an asynchronous return object that shares the shared state created by this {{tt|std::async}} call blocks until the associated thread has completed, as if joined, or else time out; and
* the associated thread completion ''synchronizes-with'' the successful return from the first function that is waiting on the shared state, or with the return of the last function that releases the shared state, whichever comes first. 

===Exceptions===
Throws
* {{lc|std::bad_alloc}}, if the memory for the internal data structures cannot be allocated, or
* {{lc|std::system_error}} with error condition {{lc|std::errc::resource_unavailable_try_again}}, if {{c|1=policy == std::launch::async}} and the implementation is unable to start a new thread.
** If {{c|policy}} is {{c|std::launch::async {{!}} std::launch::deferred}} or has additional bits set, it will fall back to deferred invocation or the implementation-defined policies in this case.

===Notes===
The implementation may extend the behavior of the first overload of {{tt|std::async}} by enabling additional (implementation-defined) bits in the default launch policy.

Examples of implementation-defined launch policies are the sync policy (execute immediately, within the {{tt|std::async}} call) and the task policy (similar to {{tt|std::async}}, but thread-locals are not cleared)

If the {{lc|std::future}} obtained from  {{tt|std::async}} is not moved from or bound to a reference, the destructor of the {{lc|std::future}} will block at the end of the full expression until the asynchronous operation completes, essentially making code such as the following synchronous:
{{source|
std::async(std::launch::async, []{ f(); }); // temporary's dtor waits for f()
std::async(std::launch::async, []{ g(); }); // does not start until f() completes
}}
Note that the destructors of {{lc|std::future}}s obtained by means other than a call to {{tt|std::async}} never block.

===Example===
{{example|
|code= 
#include &lt;algorithm&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;numeric&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

std::mutex m;

struct X
{
    void foo(int i, const std::string&amp; str)
    {
        std::lock_guard&lt;std::mutex&gt; lk(m);
        std::cout &lt;&lt; str &lt;&lt; ' ' &lt;&lt; i &lt;&lt; '\n';
    }
    
    void bar(const std::string&amp; str)
    {
        std::lock_guard&lt;std::mutex&gt; lk(m);
        std::cout &lt;&lt; str &lt;&lt; '\n';
    }
    
    int operator()(int i)
    {
        std::lock_guard&lt;std::mutex&gt; lk(m);
        std::cout &lt;&lt; i &lt;&lt; '\n';
        return i + 10;
    }
};

template&lt;typename RandomIt&gt;
int parallel_sum(RandomIt beg, RandomIt end)
{
    auto len = end - beg;
    if (len &lt; 1000)
        return std::accumulate(beg, end, 0);
    
    RandomIt mid = beg + len / 2;
    auto handle = std::async(std::launch::async,
                             parallel_sum&lt;RandomIt&gt;, mid, end);
    int sum = parallel_sum(beg, mid);
    return sum + handle.get();
}

int main()
{
    std::vector&lt;int&gt; v(10000, 1);
    std::cout &lt;&lt; "The sum is " &lt;&lt; parallel_sum(v.begin(), v.end()) &lt;&lt; '\n';
    
    X x;
    // Calls (&amp;x)-&gt;foo(42, "Hello") with default policy:
    // may print "Hello 42" concurrently or defer execution
    auto a1 = std::async(&amp;X::foo, &amp;x, 42, "Hello");
    // Calls x.bar("world!") with deferred policy
    // prints "world!" when a2.get() or a2.wait() is called
    auto a2 = std::async(std::launch::deferred, &amp;X::bar, x, "world!");
    // Calls X()(43); with async policy
    // prints "43" concurrently
    auto a3 = std::async(std::launch::async, X(), 43);
    a2.wait();                     // prints "world!"
    std::cout &lt;&lt; a3.get() &lt;&lt; '\n'; // prints "53"
} // if a1 is not done at this point, destructor of a1 prints "Hello 42" here
|p=true
|output=
The sum is 10000
43
world!
53
Hello 42
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2021|std=C++11|before=return type incorrect and value category&lt;br&gt;of arguments unclear in the deferred case|after=corrected return type and&lt;br&gt;clarified that rvalues are used}}
{{dr list item|wg=lwg|dr=2078|std=C++11|before=it was unclear whether {{lc|std::system_error}}&lt;br&gt;may be thrown if {{c|policy}} specifies other&lt;br&gt;launch policies besides {{lc|std::launch::async}}|after=can only be thrown if&lt;br&gt;{{c|1=policy == std::launch::async}}}}
{{dr list item|wg=lwg|dr=2100|std=C++11|before=timed waiting functions could not timeout&lt;br&gt;if {{lc|std::launch::async}} policy is used|after=allowed}}
{{dr list item|wg=lwg|dr=2120|std=C++11|before=the behavior was unclear if no standard&lt;br&gt;or implementation-defined policy is set|after=the behavior is&lt;br&gt;undefined in this case}}
{{dr list item|wg=lwg|dr=2186|std=C++11|before=it was unclear how the value returned and the&lt;br&gt;exception thrown from the lazy evaluation are handled|after=they are stored in&lt;br&gt;the shared state}}
{{dr list item|wg=lwg|dr=2752|std=C++11|before={{tt|std::async}} might not throw {{lc|std::bad_alloc}} if the&lt;br&gt;memory for the internal data structures cannot be allocated|after=throws}}
{{dr list item|wg=lwg|dr=3476|std=C++20|before=(the decayed types of) {{tt|F}} and the argument types&lt;br&gt;were directly required to be move constructible|after=removed these requirements&lt;ref&gt;The move-constructibility is already indirectly required by {{lc|std::is_constructible_v}}.&lt;/ref&gt;}}
{{dr list end}}
&lt;references/&gt;

===See also===
{{dsc begin}}
{{dsc inc|cpp/thread/dsc future}}
{{dsc see cpp|cpp/execution|Execution support library|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}