{{cpp/title|stop_source}}
{{cpp/thread/stop_source/navbar}}
{{ddcl|header=stop_token|since=c++20|
class stop_source;
}}

The {{tt|stop_source}} class provides the means to issue a stop request, such as for {{lc|std::jthread}} cancellation. A stop request made for one {{tt|stop_source}} object is visible to all {{tt|stop_source}}s and {{lc|std::stop_token}}s of the same associated stop-state; any {{lc|std::stop_callback}}(s) registered for associated {{lc|std::stop_token}}(s) will be invoked, and any {{lc|std::condition_variable_any}} objects waiting on associated {{lc|std::stop_token}}(s) will be awoken.

Once a stop is requested, it cannot be withdrawn. Additional stop requests have no effect.

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/thread/stop_source/dsc constructor}}
{{dsc inc|cpp/thread/stop_source/dsc destructor}}
{{dsc inc|1=cpp/thread/stop_source/dsc operator=}}

{{dsc h2|Modifiers}}
{{dsc inc|cpp/thread/stop_source/dsc request_stop}}
{{dsc inc|cpp/thread/stop_source/dsc swap}}

{{dsc h2|Observers}}
{{dsc inc|cpp/thread/stop_source/dsc get_token}}
{{dsc inc|cpp/thread/stop_source/dsc stop_requested}}
{{dsc inc|cpp/thread/stop_source/dsc stop_possible}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/thread/stop_source/dsc operator_cmp}}
{{dsc inc|cpp/thread/stop_source/dsc swap2}}
{{dsc end}}

===Helper tags===
{{dsc begin}}
{{dsc inc|cpp/thread/stop_source/dsc nostopstate}}
{{dsc end}}

===Notes===
For the purposes of {{lc|std::jthread}} cancellation the {{tt|stop_source}} object should be retrieved from the {{lc|std::jthread}} object using {{ltf|cpp/thread/jthread/get_stop_source}}; or stop should be requested directly from the {{lc|std::jthread}} object using {{ltf|cpp/thread/jthread/request_stop}}. This will then use the same associated stop-state as that passed into the {{lc|std::jthread}}'s invoked function argument (i.e., the function being executed on its thread).

For other uses, however, a {{tt|stop_source}} can be constructed separately using the default constructor, which creates new stop-state.

{{feature test macro|__cpp_lib_jthread|std=C++20|value=201911L|{{rlp|stop_token|Stop token}} and {{rlp|jthread|joining thread}}}}

===Example===
{{example
|code=
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;stop_token&gt;
#include &lt;thread&gt;

using namespace std::chrono_literals;

void worker_fun(int id, std::stop_token stoken)
{ 
    for (int i = 10; i; --i)
    {
        std::this_thread::sleep_for(300ms);
        if (stoken.stop_requested())
        {
            std::printf("  worker%d is requested to stop\n", id);
            return;
        }
        std::printf("  worker%d goes back to sleep\n", id);
    }
}

int main()
{
    std::jthread threads[4];
    std::cout &lt;&lt; std::boolalpha;
    auto print = [](const std::stop_source&amp; source)
    {
        std::printf("stop_source stop_possible = %s, stop_requested = %s\n",
                    source.stop_possible() ? "true" : "false",
                    source.stop_requested() ? "true" : "false");
    };

    // Common source
    std::stop_source stop_source;

    print(stop_source);

    // Create worker threads
    for (int i = 0; i &lt; 4; ++i)
        threads[i] = std::jthread(worker_fun, i + 1, stop_source.get_token());

    std::this_thread::sleep_for(500ms);

    std::puts("Request stop");
    stop_source.request_stop();

    print(stop_source);

    // Note: destructor of jthreads will call join so no need for explicit calls
}
|p=true
|output=
stop_source stop_possible = true, stop_requested = false
  worker2 goes back to sleep
  worker3 goes back to sleep
  worker1 goes back to sleep
  worker4 goes back to sleep
Request stop
stop_source stop_possible = true, stop_requested = true
  worker3 is requested to stop
  worker1 is requested to stop
  worker2 is requested to stop
  worker4 is requested to stop
}}

{{langlinks|es|ja|ru|zh}}