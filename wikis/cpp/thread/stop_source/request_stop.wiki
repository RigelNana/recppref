{{cpp/thread/stop_source/title|request_stop}}
{{cpp/thread/stop_source/navbar}}
{{ddcl|since=c++20|
bool request_stop() noexcept;
}}

Issues a stop request to the stop-state, if the {{tt|stop_source}} object has a stop-state and it has not yet already had stop requested.

The determination is made atomically, and if stop was requested, the stop-state is atomically updated to avoid race conditions, such that:
* {{c|stop_requested()}} and {{c|stop_possible()}} can be concurrently invoked on other {{tt|stop_token}}s and {{tt|stop_source}}s of the same stop-state;
* {{c|request_stop()}} can be concurrently invoked on other {{tt|stop_source}} objects, and only one will actually perform the stop request.
However, see the Notes section.

===Parameters===
(none)

===Return value===
{{c|true}} if the {{tt|stop_source}} object has a stop-state and this invocation made a stop request, otherwise {{c|false}}.

===Postconditions===
{{c|stop_possible()}} is {{c|false}} or {{c|stop_requested()}} is {{c|true}}.

===Notes===
If the {{c|request_stop()}} does issue a stop request (i.e., returns {{c|true}}), then any {{tt|stop_callback}}s registered for the same associated stop-state will be invoked synchronously, on the same thread {{c|request_stop()}} is issued on. If an invocation of a callback exits via an exception, {{lc|std::terminate}} is called.

If the {{tt|stop_source}} object has a stop-state but a stop request has already been made, this function returns {{c|false}}. However there is no guarantee that another {{tt|stop_source}} object which has just (successfully) requested stop is not still in the middle of invoking a {{tt|stop_callback}} function.

If the {{c|request_stop()}} does issue a stop request (i.e., returns {{c|true}}), then all condition variables of base type {{lc|std::condition_variable_any}} registered with an interruptible wait for {{tt|stop_token}}s associated with the {{tt|stop_source}}'s stop-state will be notified.

===Example===
{{example}}

{{langlinks|es|ja|ru|zh}}