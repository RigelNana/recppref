{{cpp/thread/stop_token/title|stop_requested}}
{{cpp/thread/stop_token/navbar}}
{{ddcl|since=c++20|
bool stop_requested() const noexcept;
}}

Checks if the {{rlpt|/|stop_token}} object has associated stop-state and that state has received a stop request. A default constructed {{c|stop_token}} has no associated stop-state, and thus has not had stop requested.

===Parameters===
(none)

===Return value===
{{c|true}} if the {{c|stop_token}} object has associated stop-state and it received a stop request, {{c|false}} otherwise.

===Example===
{{example
|code=
#include &lt;chrono&gt;
#include &lt;condition_variable&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;string_view&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;

int main()
{
    std::cout &lt;&lt; std::boolalpha;
    auto print = [](std::string_view name, const std::stop_token&amp; token)
    {
        std::cout &lt;&lt; name &lt;&lt; ": stop_possible = " &lt;&lt; token.stop_possible();
        std::cout &lt;&lt; ", stop_requested = " &lt;&lt; token.stop_requested() &lt;&lt; '\n';
    };

    // A worker thread that will listen to stop requests
    auto stop_worker = std::jthread([](std::stop_token stoken)
    {
        for (int i = 10; i; --i)
        {
            std::this_thread::sleep_for(300ms);
            if (stoken.stop_requested())
            {
                std::cout &lt;&lt; "  Sleepy worker is requested to stop\n";
                return;
            }
            std::cout &lt;&lt; "  Sleepy worker goes back to sleep\n";
        }
    });

    // A worker thread that will only stop when completed
    auto inf_worker = std::jthread([]()
    {
        for (int i = 5; i; --i)
        {
            std::this_thread::sleep_for(300ms);
            std::cout &lt;&lt; "  Run as long as we want\n";
        }
    });

    std::stop_token def_token;
    std::stop_token stop_token = stop_worker.get_stop_token();
    std::stop_token inf_token = inf_worker.get_stop_token();
    print("def_token ", def_token);
    print("stop_token", stop_token);
    print("inf_token ", inf_token);

    std::cout &lt;&lt; "\nRequest and join stop_worker:\n";
    stop_worker.request_stop();
    stop_worker.join();

    std::cout &lt;&lt; "\nRequest and join inf_worker:\n";
    inf_worker.request_stop();
    inf_worker.join();
    std::cout &lt;&lt; '\n';

    print("def_token ", def_token);
    print("stop_token", stop_token);
    print("inf_token ", inf_token);
}
|p=true
|output=
def_token : stop_possible = false, stop_requested = false
stop_token: stop_possible = true, stop_requested = false
inf_token : stop_possible = true, stop_requested = false

Request and join stop_worker:
  Run as long as we want
  Sleepy worker is requested to stop

Request and join inf_worker:
  Run as long as we want
  Run as long as we want
  Run as long as we want
  Run as long as we want

def_token : stop_possible = false, stop_requested = false
stop_token: stop_possible = true, stop_requested = true
inf_token : stop_possible = true, stop_requested = true
}}

{{langlinks|es|ja|ru|zh}}