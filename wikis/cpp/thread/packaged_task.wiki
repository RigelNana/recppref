{{cpp/title|packaged_task}}
{{cpp/thread/packaged_task/navbar}}
{{dcl begin}}
{{dcl header|future}}
{{dcl|num=1|since=c++11|
template&lt; class &gt; class packaged_task; //not defined
}}
{{dcl|num=2|since=c++11|
template&lt; class R, class ...ArgTypes &gt; 
class packaged_task&lt;R(ArgTypes...)&gt;;
}}
{{dcl end}}

The class template {{tt|std::packaged_task}} wraps any {{named req|Callable}} target (function, lambda expression, bind expression, or another function object) so that it can be invoked asynchronously. Its return value or exception thrown is stored in a shared state which can be accessed through {{lc|std::future}} objects.

{{rrev|until=c++17|
Just like {{lc|std::function}}, {{tt|std::packaged_task}} is a polymorphic, allocator-aware container: the stored callable target may be allocated on heap or with a provided allocator.
}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/thread/packaged_task/dsc constructor}}
{{dsc inc|cpp/thread/packaged_task/dsc destructor}}
{{dsc inc|cpp/thread/packaged_task/dsc operator{{=}}}}
{{dsc inc|cpp/thread/packaged_task/dsc valid}}
{{dsc inc|cpp/thread/packaged_task/dsc swap}}

{{dsc h2|Getting the result}}
{{dsc inc|cpp/thread/packaged_task/dsc get_future}}

{{dsc h2|Execution}}
{{dsc inc|cpp/thread/packaged_task/dsc operator()}}
{{dsc inc|cpp/thread/packaged_task/dsc make_ready_at_thread_exit}}
{{dsc inc|cpp/thread/packaged_task/dsc reset}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/thread/packaged_task/dsc swap2}}
{{dsc end}}

===Helper classes===
{{dsc begin}}
{{dsc inc|cpp/thread/packaged_task/dsc uses_allocator}}
{{dsc end}}

==={{rl|deduction_guides|Deduction guides}}{{mark since c++17}}===

===Example===
{{example
|code=
#include &lt;cmath&gt;
#include &lt;functional&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

// unique function to avoid disambiguating the std::pow overload set
int f(int x, int y) { return std::pow(x, y); }

void task_lambda()
{
    std::packaged_task&lt;int(int, int)&gt; task([](int a, int b)
    {
        return std::pow(a, b); 
    });
    std::future&lt;int&gt; result = task.get_future();
	
    task(2, 9);

    std::cout &lt;&lt; "task_lambda:\t" &lt;&lt; result.get() &lt;&lt; '\n';
}

void task_bind()
{
    std::packaged_task&lt;int()&gt; task(std::bind(f, 2, 11));
    std::future&lt;int&gt; result = task.get_future();
	
    task();

    std::cout &lt;&lt; "task_bind:\t" &lt;&lt; result.get() &lt;&lt; '\n';
}

void task_thread()
{
    std::packaged_task&lt;int(int, int)&gt; task(f);
    std::future&lt;int&gt; result = task.get_future();
	
    std::thread task_td(std::move(task), 2, 10);
    task_td.join();

    std::cout &lt;&lt; "task_thread:\t" &lt;&lt; result.get() &lt;&lt; '\n';
}

int main()
{
    task_lambda();
    task_bind();
    task_thread();
}
|output=
task_lambda: 512
task_bind:   2048
task_thread: 1024
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3117|std=C++17|before=deduction guides for {{tt|packaged_task}} were missing|after=added}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/thread/dsc future}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}