{{cpp/title|mutex}}
{{cpp/thread/mutex/navbar}}

{{ddcl|header=mutex|since=c++11|
class mutex;
}}

The {{tt|mutex}} class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.

{{tt|mutex}} offers exclusive, non-recursive ownership semantics:

* A calling thread ''owns'' a {{tt|mutex}} from the time that it successfully calls either {{rlt|lock}} or {{rlt|try_lock}} until it calls {{rlt|unlock}}.
* When a thread owns a {{tt|mutex}}, all other threads will block (for calls to {{rlt|lock}}) or receive a {{c|false}} return value (for {{rlt|try_lock}}) if they attempt to claim ownership of the {{tt|mutex}}.
* A calling thread must not own the {{tt|mutex}} prior to calling {{rlt|lock}} or {{rlt|try_lock}}.

The behavior of a program is undefined if a {{tt|mutex}} is destroyed while still owned by any threads, or a thread terminates while owning a {{tt|mutex}}. The {{tt|mutex}} class satisfies all requirements of {{named req|Mutex}} and {{named req|StandardLayoutType}}.

{{tt|std::mutex}} is neither copyable nor movable.

===Nested types===
{{dsc begin}}
{{dsc hitem|Name|Definition}}
{{dsc inc|cpp/thread/dsc native_handle_type|mutex}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/thread/mutex/dsc constructor|mutex}}
{{dsc inc|cpp/thread/mutex/dsc destructor|mutex}}
{{dsc inc|cpp/thread/mutex/dsc operator{{=}}}}

{{dsc h2|Locking}}
{{dsc inc|cpp/thread/mutex/dsc lock|mutex}}
{{dsc inc|cpp/thread/mutex/dsc try_lock|mutex}}
{{dsc inc|cpp/thread/mutex/dsc unlock|mutex}}

{{dsc h2|Native handle}}
{{dsc inc|cpp/thread/mutex/dsc native_handle|mutex}}
{{dsc end}}

===Notes===
{{tt|std::mutex}} is usually not accessed directly: {{lc|std::unique_lock}}, {{lc|std::lock_guard}}, {{rev inl|since=c++17|or [[cpp/thread/scoped_lock|{{lc|std::scoped_lock}}]]}} manage locking in a more exception-safe manner.

===Example===
{{example
|This example shows how a {{tt|mutex}} can be used to protect an {{lc|std::map}} shared between two threads.
|code=
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;thread&gt;

std::map&lt;std::string, std::string&gt; g_pages;
std::mutex g_pages_mutex;

void save_page(const std::string&amp; url)
{
    // simulate a long page fetch
    std::this_thread::sleep_for(std::chrono::seconds(2));
    std::string result = "fake content";
    
    std::lock_guard&lt;std::mutex&gt; guard(g_pages_mutex);
    g_pages[url] = result;
}

int main() 
{
    std::thread t1(save_page, "http://foo");
    std::thread t2(save_page, "http://bar");
    t1.join();
    t2.join();
    
    // safe to access g_pages without lock now, as the threads are joined
    for (const auto&amp; [url, page] : g_pages)
        std::cout &lt;&lt; url &lt;&lt; " =&gt; " &lt;&lt; page &lt;&lt; '\n';
}
|output=
http://bar =&gt; fake content
http://foo =&gt; fake content
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/thread/dsc recursive_mutex}}
{{dsc inc|cpp/thread/dsc lock_guard}}
{{dsc inc|cpp/thread/dsc unique_lock}}
{{dsc inc|cpp/thread/dsc scoped_lock}}
{{dsc inc|cpp/thread/dsc condition_variable}}
{{dsc end}}

{{langlinks|ar|de|es|fr|it|ja|ko|pt|ru|zh}}