{{cpp/title|shared_future}}
{{cpp/thread/shared_future/navbar}}
{{dcl begin}}
{{dcl header|future}}
{{dcl|num=1|since=c++11|
template&lt; class T &gt; class shared_future;
}}
{{dcl|num=2|since=c++11|
template&lt; class T &gt; class shared_future&lt;T&amp;&gt;;
}}
{{dcl|num=3|since=c++11|
template&lt;&gt; class shared_future&lt;void&gt;;
}}
{{dcl end}}

The class template {{tt|std::shared_future}} provides a mechanism to access the result of asynchronous operations, similar to {{lc|std::future}}, except that multiple threads are allowed to wait for the same shared state. Unlike {{lc|std::future}}, which is only moveable (so only one instance can refer to any particular asynchronous result), {{tt|std::shared_future}} is copyable and multiple shared future objects may refer to the same shared state.

Access to the same shared state from multiple threads is safe if each thread does it through its own copy of a {{tt|shared_future}} object.

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/thread/future/dsc constructor|shared_future}}
{{dsc mem dtor|cpp/thread/shared_future/~shared_future|destructs the future object}}
{{dsc mem fun|cpp/thread/shared_future/operator{{=}}|assigns the contents}}

{{dsc h2|Getting the result}}
{{dsc inc|cpp/thread/future/dsc get|shared_future}}

{{dsc h2|State}}
{{dsc inc|cpp/thread/future/dsc valid|shared_future}}
{{dsc inc|cpp/thread/future/dsc wait|shared_future}}
{{dsc inc|cpp/thread/future/dsc wait_for|shared_future}}
{{dsc inc|cpp/thread/future/dsc wait_until|shared_future}}
{{dsc end}}

===Example===
{{example
|A {{tt|shared_future}} may be used to signal multiple threads simultaneously, similar to {{lc|std::condition_variable::notify_all()}}.
|code=
#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;

int main()
{   
    std::promise&lt;void&gt; ready_promise, t1_ready_promise, t2_ready_promise;
    std::shared_future&lt;void&gt; ready_future(ready_promise.get_future());

    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; start;

    auto fun1 = [&amp;, ready_future]() -&gt; std::chrono::duration&lt;double, std::milli&gt; 
    {
        t1_ready_promise.set_value();
        ready_future.wait(); // waits for the signal from main()
        return std::chrono::high_resolution_clock::now() - start;
    };


    auto fun2 = [&amp;, ready_future]() -&gt; std::chrono::duration&lt;double, std::milli&gt; 
    {
        t2_ready_promise.set_value();
        ready_future.wait(); // waits for the signal from main()
        return std::chrono::high_resolution_clock::now() - start;
    };

    auto fut1 = t1_ready_promise.get_future();
    auto fut2 = t2_ready_promise.get_future();

    auto result1 = std::async(std::launch::async, fun1);
    auto result2 = std::async(std::launch::async, fun2);

    // wait for the threads to become ready
    fut1.wait();
    fut2.wait();

    // the threads are ready, start the clock
    start = std::chrono::high_resolution_clock::now();

    // signal the threads to go
    ready_promise.set_value();

    std::cout &lt;&lt; "Thread 1 received the signal "
              &lt;&lt; result1.get().count() &lt;&lt; " ms after start\n"
              &lt;&lt; "Thread 2 received the signal "
              &lt;&lt; result2.get().count() &lt;&lt; " ms after start\n";
}
|p=true
|output=
Thread 1 received the signal 0.072 ms after start
Thread 2 received the signal 0.041 ms after start
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/thread/dsc async}}
{{dsc inc|cpp/thread/dsc future}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}