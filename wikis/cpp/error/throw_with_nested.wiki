{{cpp/title|throw_with_nested}}
{{cpp/error/navbar}}
{{ddcla|header=exception|since=c++11|constexpr=c++26|
template&lt; class T &gt;
[[noreturn]] void throw_with_nested( T&amp;&amp; t );
}}

If {{c|std::decay&lt;T&gt;::type}} is a non-final non-union class type that is neither {{lc|std::nested_exception}} nor derived from {{lc|std::nested_exception}}, throws an exception of an unspecified type that is publicly derived from both {{lc|std::nested_exception}} and from {{c|std::decay&lt;T&gt;::type}}, and constructed from {{c|std::forward&lt;T&gt;(t)}}. The default constructor of the {{tt|nested_exception}} base class calls {{lc|std::current_exception}}, capturing the currently handled exception object, if any, in a {{lc|std::exception_ptr}}. 

Otherwise, throws {{c|std::forward&lt;T&gt;(t)}}.

Requires that {{c|std::decay&lt;T&gt;::type}} is {{named req|CopyConstructible}}.

===Parameters===
{{par begin}}
{{par|t|the exception object to throw}}
{{par end}}

===Notes===
{{ftm begin}}
{{ftm|__cpp_lib_constexpr_exceptions|value=202411L|std=C++26|{{c/core|constexpr}} for exception types}}
{{ftm end}}

===Example===
{{include|cpp/error/example_nested_exception}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/error/dsc nested_exception}}
{{dsc inc|cpp/error/dsc rethrow_if_nested}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}