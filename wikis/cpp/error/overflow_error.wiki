{{cpp/title|overflow_error}}
{{cpp/error/navbar}}
{{ddcl|header=stdexcept|
class overflow_error;
}}

Defines a type of object to be thrown as exception. It can be used to report arithmetic overflow errors (that is, situations where a result of a computation is too large for the destination type).

{{rev begin}}
{{rev|until=c++11|
The only standard library component that throws this exception is {{lc|std::bitset::to_ulong}}.
}}
{{rev|since=c++11|
The only standard library components that throw this exception are {{lc|std::bitset::to_ulong}} and {{lc|std::bitset::to_ullong}}.
}}
{{rev end}}

The mathematical functions of the standard library components do not throw this exception (mathematical functions report overflow errors as specified in {{lc|math_errhandling}}). Third-party libraries, however, use this. For example,
[https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/error_handling.html boost.math] throws {{tt|std::overflow_error}} if {{tt|boost::math::policies::throw_on_error}} is enabled (the default setting).

{{inheritance diagram/std-overflow_error}}

===Member functions===
{{cpp/error/exception/member of derived with message|overflow_error}}

{{cpp/error/runtime_error/inherit}}

{{cpp/error/exception/inherit}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;stdexcept&gt;
#include &lt;utility&gt;

template&lt;typename T, int N&gt;
    requires (N &gt; 0) /*...*/
class Stack
{
    int top_{-1};
    T data_[N];

public:
    [[nodiscard]] bool empty() const { return top_ == -1; }

    void push(T x)
    {
        if (top_ == N - 1)
            throw std::overflow_error("Stack overflow!");
        data_[++top_] = std::move(x);
    }

    void pop()
    {
        if (empty())
            throw std::underflow_error("Stack underflow!");
        --top_;
    }

    T const&amp; top() const
    {
        if (empty())
            throw std::overflow_error("Stack is empty!");
        return data_[top_];
    }
};

int main()
{
    Stack&lt;int, 4&gt; st;

    try
    {
        [[maybe_unused]] auto x = st.top();
    }
    catch (std::overflow_error const&amp; ex)
    {
        std::cout &lt;&lt; "1) Exception: " &lt;&lt; ex.what() &lt;&lt; '\n';
    }

    st.push(1337);
    while (!st.empty())
    	st.pop();

    try
    {
        st.pop();
    }
    catch (std::underflow_error const&amp; ex)
    {
        std::cout &lt;&lt; "2) Exception: " &lt;&lt; ex.what() &lt;&lt; '\n';
    }

    try
    {
        for (int i{}; i != 13; ++i)
            st.push(i);
    }
    catch (std::overflow_error const&amp; ex)
    {
        std::cout &lt;&lt; "3) Exception: " &lt;&lt; ex.what() &lt;&lt; '\n';
    }
}
|output=
1) Exception: Stack is empty!
2) Exception: Stack underflow!
3) Exception: Stack overflow!
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=254|std=C++98|before=the constructor accepting {{c|const char*}} was missing|after=added}}
{{dr list item|wg=lwg|dr=471|std=C++98|before=the explanatory strings of {{tt|std::overflow_error}}'s&lt;br&gt;copies were implementation-defined|after=they are the same as that of the&lt;br&gt;original {{tt|std::overflow_error}} object}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}