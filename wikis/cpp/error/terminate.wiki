{{cpp/title|terminate}}
{{cpp/error/navbar}}
{{dcl begin}}
{{dcl header|exception}}
{{dcl rev multi
|dcl1=
void terminate();
|since2=c++11|dcl2=
[[noreturn]] void terminate() noexcept;
}}
{{dcl end}}

{{tt|std::terminate()}} is called by the C++ runtime when the program cannot continue for any of the following reasons:

@1@ An [[cpp/language/throw|exception is thrown]] and not caught (it is implementation-defined whether any stack unwinding is done in this case).

@2@ A function directly invoked by the exception handling mechanism while handling an exception that has not yet been caught exits via an exception (e.g. a destructor of some local object, or a copy constructor constructing a catch-clause parameter).

@3@ The constructor or the destructor of a static {{rev inl|since=c++11|or thread-local}} object throws an exception.

@4@ A function registered with {{lc|std::atexit}} {{rev inl|since=c++11|or {{lc|std::at_quick_exit}}}} throws an exception.

{{rrev|until=c++17|
@5@ A [[cpp/language/except spec|dynamic exception specification]] is violated and the default handler for {{lc|std::unexpected}} is executed.

@6@ A non-default handler for {{lc|std::unexpected}} throws an exception that violates the previously violated dynamic exception specification, if the specification does not include {{lc|std::bad_exception}}.
}}

{{rrev|since=c++11|
@7@ A [[cpp/language/noexcept spec|noexcept specification]] is violated (it is implementation-defined whether any stack unwinding is done in this case).

@8@ {{lc|std::nested_exception::rethrow_nested}} is called for an object that isn't holding a captured exception.

@9@ An exception is thrown from the initial function of {{lc|std::thread}}.

@10@ A joinable {{lc|std::thread}} is destroyed or assigned to.

@11@ {{lc|std::condition_variable::wait}}, {{lc|std::condition_variable::wait_until}}, or {{lc|std::condition_variable::wait_for}} fails to reach its postcondition (e.g. if relocking the mutex throws).&lt;!-- LWG 2135 --&gt;
}}

{{rrev|since=c++17|
@12@ A function invoked by a [[cpp/algorithm|parallel algorithm]] exits via an uncaught exception and the [[cpp/algorithm/execution_policy_tag_t|execution policy]] specifies termination.
}}

{{tt|std::terminate()}} may also be called directly from the program.

When {{tt|std::terminate}} is called due to a thrown exception, an implicit try/catch handler is considered active. Thus, calling {{lc|std::current_exception}} will return the thrown exception.

In any case, {{tt|std::terminate}} calls the currently installed {{lc|std::terminate_handler}}. The default {{lc|std::terminate_handler}} calls {{lc|std::abort}}.

{{rrev multi
|rev1=
If a destructor reset the terminate handler during stack unwinding and the unwinding later led to {{tt|terminate}} being called, the handler that was installed at the end of the throw expression is the one that will be called. (note: it was ambiguous whether re-throwing applied the new handlers)
|since2=c++11|rev2=
If a destructor reset the terminate handler during stack unwinding, it is unspecified which handler is called if the unwinding later led to {{tt|terminate}} being called.
}}

===Notes===
If the handler mechanism is not wanted, e.g. because it requires atomic operations which may bloat binary size, a direct call to {{lc|std::abort}} is preferred when terminating the program abnormally.

Some compiler intrinsics, e.g. [https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html {{tt|__builtin_trap}}] (gcc, clang, and icc) or [https://docs.microsoft.com/en-us/cpp/intrinsics/debugbreak?view=msvc-160 {{tt|__debugbreak}}] (msvc), can be used to terminate the program as fast as possible.

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2111|std=C++11|before=effect of calling {{lc|std::set_terminate}} during stack&lt;br&gt;unwinding differs from C++98 and breaks some ABIs|after=made unspecified}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/error/dsc terminate_handler}}
{{dsc inc|cpp/utility/program/dsc abort}}
{{dsc inc|cpp/utility/dsc breakpoint}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}