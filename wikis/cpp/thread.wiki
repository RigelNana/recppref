{{title|Concurrency support library {{mark since c++11}}}}
{{cpp/thread/navbar}}

C++ includes built-in support for threads, atomic operations, mutual exclusion, condition variables, and futures.

===Threads===
Threads enable programs to execute across several processor cores.

{{dsc begin}}
{{dsc header|thread}}
{{dsc inc|cpp/thread/dsc thread}}
{{dsc inc|cpp/thread/dsc jthread}}
{{dsc h2|Functions managing the current thread}}
{{dsc namespace|this_thread}}
{{dsc inc|cpp/thread/dsc yield}}
{{dsc inc|cpp/thread/dsc get_id}}
{{dsc inc|cpp/thread/dsc sleep_for}}
{{dsc inc|cpp/thread/dsc sleep_until}}
{{dsc end}}

{{anchor|Cooperative cancellation}}
===Cooperative cancellation {{mark since c++20}}===
The components ''stop source'', ''stop token'', and ''stop callback'' can be used to asynchronously request that an operation stops execution in a timely manner, typically because the result is no longer required. Such a request is called a ''stop request''.

These components specify the semantics of shared access to a ''stop state''. Any object modeling any of these components that refer to the same stop state is an associated stop source, stop token, or stop callback, respectively.

{{rrev|since=c++26|
The concepts {{lconcept|stoppable-source}}, {{lconcept|stoppable_token}}, and {{lconcept|stoppable-callback-for}} specify the required syntax and model semantics of stop source, stop token, and stop callback, respectively.
}}

They are designed:
* to cooperatively cancel the execution such as for {{lc|std::jthread}}, 
* to interrupt {{lc|std::condition_variable_any}} waiting functions, 
{{rrev|since=c++26|* to perform stopped completion of an asynchronous operation created by {{lc|execution::connect}},}} 
* or for a custom execution management implementation. 
In fact, they do not even need to be used to "stop" anything, but can instead be used for a thread-safe one-time function(s) invocation trigger, for example.

{{dsc begin}}
{{dsc header|stop_token}}
{{dsc h2|Stop token types}}
{{dsc inc|cpp/thread/dsc stop_token}}
{{dsc inc|cpp/thread/dsc never_stop_token}}
{{dsc inc|cpp/thread/dsc inplace_stop_token}}
{{dsc h2|Stop source types}}
{{dsc inc|cpp/thread/dsc stop_source}}&lt;!--include nostopstate_t inside as helper--&gt;
{{dsc inc|cpp/thread/dsc inplace_stop_source}}
{{dsc h2|Stop callback types}}
{{dsc inc|cpp/thread/dsc stop_callback}}
{{dsc inc|cpp/thread/dsc inplace_stop_callback}}
{{dsc inc|cpp/thread/dsc stop_callback_for_t}}
{{anchor|Concepts}}
{{dsc h2|Concepts {{mark since c++20}}}}
{{dsc inc|cpp/thread/dsc stoppable_token}}
{{dsc inc|cpp/thread/dsc unstoppable_token}}
{{dsc inc|cpp/thread/dsc stoppable_source}}
{{dsc inc|cpp/thread/dsc stoppable_callback_for}}
{{dsc end}}

{{anchor|Cache size access}}
===Cache size access {{mark since c++17}}===
{{dsc begin}}
{{dsc header|new}}
{{dsc inc|cpp/thread/dsc hardware_destructive_interference_size}}
{{dsc end}}

===Atomic operations===
These components are provided for fine-grained atomic operations allowing for lockless concurrent programming. Each atomic operation is indivisible with regards to any other atomic operation that involves the same object. Atomic objects are [[cpp/language/memory_model#Threads_and_data_races|free of data races]].

{{dsc begin}}
{{dsc header|atomic}}
{{dsc h2|Atomic types}}
{{dsc inc|cpp/atomic/dsc atomic}}
{{dsc inc|cpp/atomic/dsc atomic_ref}}
{{dsc h2|Operations on atomic types}}
{{dsc inc|cpp/atomic/dsc atomic_is_lock_free}}
{{dsc inc|cpp/atomic/dsc atomic_store}}
{{dsc inc|cpp/atomic/dsc atomic_load}}
{{dsc inc|cpp/atomic/dsc atomic_exchange}}
{{dsc inc|cpp/atomic/dsc atomic_compare_exchange}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_add}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_sub}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_and}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_or}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_xor}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_max}}
{{dsc inc|cpp/atomic/dsc atomic_fetch_min}}
{{dsc inc|cpp/atomic/dsc atomic_wait}}
{{dsc inc|cpp/atomic/dsc atomic_notify_one}}
{{dsc inc|cpp/atomic/dsc atomic_notify_all}}
{{dsc h2|Flag type and operations}}
{{dsc inc|cpp/atomic/dsc atomic_flag}}
{{dsc inc|cpp/atomic/dsc atomic_flag_test_and_set}}
{{dsc inc|cpp/atomic/dsc atomic_flag_clear}}
{{dsc inc|cpp/atomic/dsc atomic_flag_test}}
{{dsc inc|cpp/atomic/dsc atomic_flag_wait}}
{{dsc inc|cpp/atomic/dsc atomic_flag_notify_one}}
{{dsc inc|cpp/atomic/dsc atomic_flag_notify_all}}
{{dsc h2|Initialization}}
{{dsc inc|cpp/atomic/dsc atomic_init}}
{{dsc inc|cpp/atomic/dsc ATOMIC_VAR_INIT}}
{{dsc inc|cpp/atomic/dsc ATOMIC_FLAG_INIT}}
{{dsc h2|Memory synchronization ordering}}
{{dsc inc|cpp/atomic/dsc memory_order}}
{{dsc inc|cpp/atomic/dsc kill_dependency}}
{{dsc inc|cpp/atomic/dsc atomic_thread_fence}}
{{dsc inc|cpp/atomic/dsc atomic_signal_fence}}
{{dsc header|stdatomic.h}}
{{anchor|C compatibility macros}}
{{dsc h2|C compatibility macros {{mark since c++23}}}}
{{dsc inc|cpp/atomic/dsc _Atomic}}
{{dsc end}}

Neither the {{tt|_Atomic}} macro, nor any of the non-macro global namespace declarations are provided by any C++ standard library header other than {{tt|&lt;stdatomic.h&gt;}}.

===Mutual exclusion===
Mutual exclusion algorithms prevent multiple threads from simultaneously accessing shared resources. This prevents data races and provides support for synchronization between threads.

{{dsc begin}}
{{dsc header|mutex}}
{{dsc inc|cpp/thread/dsc mutex}}
{{dsc inc|cpp/thread/dsc timed_mutex}}
{{dsc inc|cpp/thread/dsc recursive_mutex}}
{{dsc inc|cpp/thread/dsc recursive_timed_mutex}}
{{dsc header|shared_mutex}}
{{dsc inc|cpp/thread/dsc shared_mutex}}
{{dsc inc|cpp/thread/dsc shared_timed_mutex}}

{{dsc h2|Generic mutex management}}
{{dsc header|mutex}}
{{dsc inc|cpp/thread/dsc lock_guard}}
{{dsc inc|cpp/thread/dsc scoped_lock}}
{{dsc inc|cpp/thread/dsc unique_lock}}
{{dsc inc|cpp/thread/dsc shared_lock}}
{{dsc inc|cpp/thread/dsc lock_tag}}

{{dsc h2|Generic locking algorithms}}
{{dsc inc|cpp/thread/dsc try_lock}}
{{dsc inc|cpp/thread/dsc lock}}

{{dsc h2|Call once}}
{{dsc inc|cpp/thread/dsc once_flag}}
{{dsc inc|cpp/thread/dsc call_once}}
{{dsc end}}

===Condition variables===
A condition variable is a synchronization primitive that allows multiple threads to communicate with each other.  It allows some number of threads to wait (possibly with a timeout) for notification from another thread that they may proceed. A condition variable is always associated with a mutex. 

{{dsc begin}}
{{dsc header|condition_variable}}
{{dsc inc|cpp/thread/dsc condition_variable}}
{{dsc inc|cpp/thread/dsc condition_variable_any}}
{{dsc inc|cpp/thread/dsc notify_all_at_thread_exit}}
{{dsc inc|cpp/thread/dsc cv_status}}
{{dsc end}}

{{anchor|Semaphores}}
===Semaphores {{mark since c++20}}===
A semaphore is a lightweight synchronization primitive used to constrain concurrent access to a shared resource. When either would suffice, a semaphore can be more efficient than a condition variable.
{{dsc begin}}
{{dsc header|semaphore}}
{{dsc inc|cpp/thread/dsc counting_semaphore}}
{{dsc inc|cpp/thread/dsc binary_semaphore}}
{{dsc end}}

{{anchor|Latches and Barriers}}
===Latches and Barriers {{mark since c++20}}===
Latches and barriers are thread coordination mechanisms that allow any number of threads to block until an expected number of threads arrive. A latch cannot be reused, while a barrier can be used repeatedly.
{{dsc begin}}
{{dsc header|latch}}
{{dsc inc|cpp/thread/dsc latch}}
{{dsc header|barrier}}
{{dsc inc|cpp/thread/dsc barrier}}
{{dsc end}}

===Futures===
The standard library provides facilities to obtain values that are returned and to catch exceptions that are thrown by asynchronous tasks (i.e. functions launched in separate threads). These values are communicated in a ''shared state'', in which the asynchronous task may write its return value or store an exception, and which may be examined, waited for, and otherwise manipulated by other threads that hold instances of {{lc|std::future}} or {{lc|std::shared_future}} that reference that shared state.

{{dsc begin}}
{{dsc header|future}}
{{dsc inc|cpp/thread/dsc promise}}
{{dsc inc|cpp/thread/dsc packaged_task}}
{{dsc inc|cpp/thread/dsc future}}
{{dsc inc|cpp/thread/dsc shared_future}}
{{dsc inc|cpp/thread/dsc async}}
{{dsc inc|cpp/thread/dsc launch}}
{{dsc inc|cpp/thread/dsc future_status}}

{{dsc h2|Future errors}}
{{dsc inc|cpp/thread/dsc future_error}}
{{dsc inc|cpp/thread/dsc future_category}}
{{dsc inc|cpp/thread/dsc future_errc}}
{{dsc end}}

{{anchor|Safe Reclamation}}
===Safe Reclamation {{mark since c++26}}===
Safe-reclamation techniques are most frequently used to straightforwardly resolve access-deletion races.

{{dsc begin}}
{{dsc h2|Read-Copy-Update Mechanism}}
{{dsc header|rcu}}
{{dsc inc|cpp/thread/dsc rcu_obj_base}}
{{dsc inc|cpp/thread/dsc rcu_domain}}
{{dsc inc|cpp/thread/dsc rcu_default_domain}}
{{dsc inc|cpp/thread/dsc rcu_synchronize}}
{{dsc inc|cpp/thread/dsc rcu_barrier}}
{{dsc inc|cpp/thread/dsc rcu_retire}}

{{dsc h2|Hazard Pointers}}
{{dsc header|hazard_pointer}}
{{dsc inc|cpp/thread/dsc hazard_pointer_obj_base}}
{{dsc inc|cpp/thread/dsc hazard_pointer}}
{{dsc inc|cpp/thread/dsc make_hazard_pointer}}
{{dsc end}}

===See also===
{{dsc begin}}
{{dsc see c|c/thread|Concurrency support library|nomono=true}}
{{dsc end}}

{{langlinks|ar|de|es|fr|it|ja|pt|ru|zh}}