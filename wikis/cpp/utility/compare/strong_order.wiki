{{cpp/title|strong_order}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|compare}}
{{dcl|since=c++20|1=
inline namespace /* unspecified */ {
    inline constexpr /* unspecified */ strong_order = /* unspecified */;
}
}}
{{dcl h|Call signature}}
{{dcl|1=
template&lt; class T, class U &gt;
    requires /* see below */
constexpr std::strong_ordering strong_order( T&amp;&amp; t, U&amp;&amp; u ) noexcept(/* see below */);
}}
{{dcl end}}

Compares two values using 3-way comparison and produces a result of type {{rlpt|strong_ordering|std::strong_ordering}}.

Let {{c|t}} and {{c|u}} be expressions and {{tt|T}} and {{tt|U}} denote {{c|decltype((t))}} and {{c|decltype((u))}} respectively, {{c|std::strong_order(t, u)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to:
* If {{c|std::is_same_v&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;}} is {{c|true}}:
** {{c|std::strong_ordering(strong_order(t, u))}}, if it is a well-formed expression with overload resolution performed in a context that does not include a declaration of {{tt|std::strong_order}},
** otherwise, if {{tt|T}} is a floating-point type:
*** if {{c|std::numeric_limits&lt;T&gt;::is_iec559}} is {{c|true}}, performs the ISO/IEC/IEEE 60559 ''totalOrder'' comparison of floating-point values and returns that result as a value of type {{lc|std::strong_ordering}} (note: this comparison can distinguish between the positive and negative zero and between the NaNs with different representations),
*** otherwise, yields a value of type {{lc|std::strong_ordering}} that is consistent with the ordering observed by {{tt|T}}'s comparison operators,
** otherwise, {{c|std::strong_ordering(std::compare_three_way()(t, u))}} if it is well-formed.
* In all other cases, the expression is ill-formed, which can result in [[cpp/language/sfinae|substitution failure]] when it appears in the immediate context of a template instantiation.

{{cpp/ranges/cpo|std}}

====Strict total order of IEEE floating-point types====
Let {{c|x}} and {{c|y}} be values of same IEEE floating-point type, and {{c|total_order_less(x, y)}} be the boolean result indicating if {{c|x}} precedes {{c|y}} in the strict total order defined by ''totalOrder'' in ISO/IEC/IEEE 60559.

{{c|1=(total_order_less(x, y) {{!!}} total_order_less(y, x)) == false}} if and only if {{c|x}} and {{c|y}} have the same bit pattern.

* if neither {{c|x}} nor {{c|y}} is NaN:
** if {{c|x &lt; y}}, then {{c|1=total_order_less(x, y) == true}};
** if {{c|x &gt; y}}, then {{c|1=total_order_less(x, y) == false}};
** if {{c|1=x == y}},
*** if {{c|x}} is negative zero and {{c|y}} is positive zero, {{c|1=total_order_less(x, y) == true}},
*** if {{c|x}} is not zero and {{c|x}}'s exponent field is less than {{c|y}}'s, then {{c|1=total_order_less(x, y) == (x &gt; 0)}} (only meaningful for decimal floating-point number);
* if either {{c|x}} or {{c|y}} is NaN:
** if {{c|x}} is negative NaN and {{c|y}} is not negative NaN, then {{c|1=total_order_less(x, y) == true}},
** if {{c|x}} is not positive NaN and {{c|y}} is positive NaN, then {{c|1=total_order_less(x, y) == true}},
** if both {{c|x}} and {{c|y}} are NaNs with the same sign and {{c|x}}'s mantissa field is less than {{c|y}}'s, then {{c|1=total_order_less(x, y) == !std::signbit(x)}}.

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/compare/dsc strong_ordering}}
{{dsc inc|cpp/utility/compare/dsc weak_order}}
{{dsc inc|cpp/utility/compare/dsc partial_order}}
{{dsc inc|cpp/utility/compare/dsc compare_strong_order_fallback}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}