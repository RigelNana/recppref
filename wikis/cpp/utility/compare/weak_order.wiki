{{cpp/title|weak_order}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|compare}}
{{dcl|since=c++20|1=
inline namespace /* unspecified */ {
    inline constexpr /* unspecified */ weak_order = /* unspecified */;
}
}}
{{dcl h|Call signature}}
{{dcl|1=
template&lt; class T, class U &gt;
    requires /* see below */
constexpr std::weak_ordering weak_order(T&amp;&amp; t, U&amp;&amp; u) noexcept(/* see below */);
}}
{{dcl end}}

Compares two values using 3-way comparison and produces a result of type {{rlpt|weak_ordering|std::weak_ordering}}.

Let {{c|t}} and {{c|u}} be expressions and {{tt|T}} and {{tt|U}} denote {{c/core|decltype((t))}} and {{c/core|decltype((u))}} respectively, {{c|std::weak_order(t, u)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to:
* If {{c|std::is_same_v&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;}} is {{c|true}}:
** {{c|std::weak_ordering(weak_order(t, u))}}, if it is a well-formed expression with overload resolution performed in a context that does not include a declaration of {{tt|std::weak_order}},
** otherwise, if {{tt|T}} is a floating-point type:
*** if {{c|std::numeric_limits&lt;T&gt;::is_iec559}} is {{c|true}}, performs the weak ordering comparison of floating-point values (see below) and returns that result as a value of type {{rlpt|weak_ordering|std::weak_ordering}},
*** otherwise, yields a value of type {{rlpt|weak_ordering|std::weak_ordering}} that is consistent with the ordering observed by {{tt|T}}'s comparison operators,
** otherwise, {{c|std::weak_ordering(std::compare_three_way()(t, u))}}, if it is well-formed,
** otherwise, {{c|std::weak_ordering(std::strong_order(t, u))}}, if it is well-formed.
* In all other cases, the expression is ill-formed, which can result in [[cpp/language/sfinae|substitution failure]] when it appears in the immediate context of a template instantiation.

{{cpp/ranges/cpo|std}}

====Strict weak order of IEEE floating-point types====
Let {{c|x}} and {{c|y}} be values of same IEEE floating-point type, and {{c|weak_order_less(x, y)}} be the boolean result indicating if {{c|x}} precedes {{c|y}} in the strict weak order defined by the C++ standard.

* If neither {{c|x}} nor {{c|y}} is NaN, then {{c|1=weak_order_less(x, y) == true}} if and only if {{c|x &lt; y}}, i.e. all representations of equal floating-point value are equivalent;
* If {{c|x}} is negative NaN and {{c|y}} is not negative NaN, then {{c|1=weak_order_less(x, y) == true}};
* If {{c|x}} is not positive NaN and {{c|y}} is positive NaN, then {{c|1=weak_order_less(x, y) == true}};
* If both {{c|x}} and {{c|y}} are NaNs with the same sign, then {{c|1=(weak_order_less(x, y) {{!!}} weak_order_less(y, x)) == false}}, i.e. all NaNs with the same sign are equivalent.

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/compare/dsc weak_ordering}}
{{dsc inc|cpp/utility/compare/dsc strong_order}}
{{dsc inc|cpp/utility/compare/dsc partial_order}}
{{dsc inc|cpp/utility/compare/dsc compare_weak_order_fallback}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}