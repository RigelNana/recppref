{{cpp/title|partial_order}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|compare}}
{{dcl|since=c++20|1=
inline namespace /* unspecified */ {
    inline constexpr /* unspecified */ partial_order = /* unspecified */;
}
}}
{{dcl h|Call signature}}
{{dcl|1=
template&lt; class T, class U &gt;
    requires /* see below */
constexpr std::partial_ordering
    partial_order( T&amp;&amp; t, U&amp;&amp; u ) noexcept(/* see below */);
}}
{{dcl end}}

Compares two values using 3-way comparison and produces a result of type {{rlpt|partial_ordering|std::partial_ordering}}.

Let {{c|t}} and {{c|u}} be expressions and {{tt|T}} and {{tt|U}} denote {{c/core|decltype((t))}} and {{c/core|decltype((u))}} respectively, {{c|std::partial_order(t, u)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to:
* If {{c|std::is_same_v&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;}} is {{c|true}}:
** {{c|std::partial_ordering(partial_order(t, u))}}, if it is a well-formed expression with overload resolution performed in a context that does not include a declaration of {{tt|std::partial_order}},
** otherwise, {{c|std::partial_ordering(std::compare_three_way()(t, u))}}, if it is well-formed,
** otherwise, {{c|std::partial_ordering(std::weak_order(t, u))}}, if it is well-formed.
* In all other cases, the expression is ill-formed, which can result in [[cpp/language/sfinae|substitution failure]] when it appears in the immediate context of a template instantiation.

{{cpp/ranges/cpo|std}}

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/compare/dsc partial_ordering}}
{{dsc inc|cpp/utility/compare/dsc strong_order}}
{{dsc inc|cpp/utility/compare/dsc weak_order}}
{{dsc inc|cpp/utility/compare/dsc compare_partial_order_fallback}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}