{{cpp/title|compare_weak_order_fallback}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|compare}}
{{dcl|since=c++20|1=
inline namespace /* unspecified */ {
    inline constexpr /* unspecified */
        compare_weak_order_fallback = /* unspecified */;
}
}}
{{dcl h|Call signature}}
{{dcl|since=c++20|1=
template&lt; class T, class U &gt;
    requires /* see below */
constexpr std::weak_ordering
    compare_weak_order_fallback( T&amp;&amp; t, U&amp;&amp; u ) noexcept(/* see below */);
}}
{{dcl end}}

Performs three-way comparison on [[cpp/language/expressions#Full-expressions|subexpressions]] {{c|t}} and {{c|u}} and produces a result of type {{ltt std|cpp/utility/compare/weak_ordering}}, even if the operator {{tt|1=&lt;=&gt;}} is unavailable.

If {{c/core|std::decay_t&lt;T&gt;}} and {{c/core|std::decay_t&lt;U&gt;}} are the same type, {{c|std::compare_weak_order_fallback(t, u)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to:
* {{c|std::weak_order(t, u)}}, if it is a well-formed expression; otherwise,
* {{c multi
|1=t == u ? std::weak_ordering::equivalent :
|2=t &lt;  u ? std::weak_ordering::less :
|3=         std::weak_ordering::greater
}}, if the expressions {{c|1=t == u}} and {{c|t &lt; u}} are both well-formed and each of {{c/core|1=decltype(t == u)}} and {{c/core|decltype(t &lt; u)}} models {{lti|cpp/concepts/boolean-testable}}, except that {{c|t}} and {{c|u}} are evaluated only once.

In all other cases, {{c|std::compare_weak_order_fallback(t, u)}} is ill-formed, which can result in [[cpp/language/sfinae|substitution failure]] when it appears in the immediate context of a template instantiation.

{{cpp/ranges/cpo|std}}

===Example===
{{example
|code=
#include &lt;compare&gt;
#include &lt;iostream&gt;

// does not support &lt;=&gt;
struct Rational_1
{
    int num;
    int den; // &gt; 0
};

inline constexpr bool operator&lt;(Rational_1 lhs, Rational_1 rhs)
{
    return lhs.num * rhs.den &lt; rhs.num * lhs.den;
}

inline constexpr bool operator==(Rational_1 lhs, Rational_1 rhs)
{
    return lhs.num * rhs.den == rhs.num * lhs.den;
}

// supports &lt;=&gt;
struct Rational_2
{
    int num;
    int den; // &gt; 0
};

inline constexpr std::weak_ordering operator&lt;=&gt;(Rational_2 lhs, Rational_2 rhs)
{
    return lhs.num * rhs.den &lt;=&gt; rhs.num * lhs.den;
}

inline constexpr bool operator==(Rational_2 lhs, Rational_2 rhs)
{
    return lhs &lt;=&gt; rhs == 0;
}

void print(int id, std::weak_ordering value)
{
    std::cout &lt;&lt; id &lt;&lt; ") ";
    if (value == 0)
        std::cout &lt;&lt; "equal\n";
    else if (value &lt; 0)
        std::cout &lt;&lt; "less\n";
    else
        std::cout &lt;&lt; "greater\n";
}

int main()
{
    Rational_1 a{1, 2}, b{3, 4};
//  print(0, a &lt;=&gt; b); // does not work
    print(1, std::compare_weak_order_fallback(a, b)); // works, defaults to &lt; and ==

    Rational_2 c{6, 5}, d{8, 7};
    print(2, c &lt;=&gt; d); // works
    print(3, std::compare_weak_order_fallback(c, d)); // works

    Rational_2 e{2, 3}, f{4, 6};
    print(4, e &lt;=&gt; f); // works
    print(5, std::compare_weak_order_fallback(e, f)); // works
}
|output=
1) less
2) greater
3) greater
4) equal
5) equal
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2114|paper=P2167R3|std=C++20|before=the fallback mechanism only required&lt;br&gt;return types to be convertible to {{c/core|bool}}|after=constraints strengthened}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/compare/dsc weak_order}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}