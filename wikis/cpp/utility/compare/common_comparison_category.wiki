{{cpp/title|common_comparison_category}}
{{cpp/utility/navbar}}
{{ddcl|since=c++20|header=compare|1=
template&lt; class... Ts &gt;
struct common_comparison_category
{
    using type = /* see below */ ;
};
}}

The class template {{tt|std::common_comparison_category}} provides an alias (as the member typedef {{tt|type}}) for the strongest comparison category to which all of the template arguments {{tt|Ts...}} can be converted.

In detail, the common comparison type of a list of n types {{tt|T}}{{sub|0}}...{{tt|T}}{{sub|n-1}} is defined as follows:
* If any {{tt|T}}{{sub|i}} is not a comparison category type ({{ltt|cpp/utility/compare/partial_ordering|std::partial_ordering}}, {{ltt|cpp/utility/compare/weak_ordering|std::weak_ordering}}, {{ltt|cpp/utility/compare/strong_ordering|std::strong_ordering}}), {{tt|U}} is {{c|void}}.
* Otherwise, if at least one {{tt|T}}{{sub|i}} is {{ltt|cpp/utility/compare/partial_ordering|std::partial_ordering}}, {{tt|U}} is {{ltt|cpp/utility/compare/partial_ordering|std::partial_ordering}}.
* Otherwise, if at least one {{tt|T}}{{sub|i}} is {{ltt|cpp/utility/compare/weak_ordering|std::weak_ordering}}, {{tt|U}} is {{ltt|cpp/utility/compare/weak_ordering|std::weak_ordering}}.
* Otherwise (if every {{tt|T}}{{sub|i}} is {{ltt|cpp/utility/compare/strong_ordering|std::strong_ordering}}, or if the list is empty), {{tt|U}} is {{ltt|cpp/utility/compare/strong_ordering|std::strong_ordering}}.

===Template parameters===
{{par begin}}
{{par|...Ts|a possibly empty list of types}}
{{par end}}

===Helper template===
{{ddcl|since=c++20|1=
template&lt; class... Ts &gt;
using common_comparison_category_t = common_comparison_category&lt;Ts...&gt;::type;
}}

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc|{{tt|type}}|the strongest common comparison category (as defined above)}}
{{dsc end}}

===Possible implementation===
{{eq fun|1=
namespace detail
{
    template&lt;unsigned int&gt;
    struct common_cmpcat_base     { using type = void; };
    template&lt;&gt;
    struct common_cmpcat_base&lt;0u&gt; { using type = std::strong_ordering; };
    template&lt;&gt;
    struct common_cmpcat_base&lt;2u&gt; { using type = std::partial_ordering; };
    template&lt;&gt;
    struct common_cmpcat_base&lt;4u&gt; { using type = std::weak_ordering; };
    template&lt;&gt;
    struct common_cmpcat_base&lt;6u&gt; { using type = std::partial_ordering; };
} // namespace detail

template&lt;class...Ts&gt;
struct common_comparison_category :
    detail::common_cmpcat_base&lt;(0u {{!}} ... {{!}}
        (std::is_same_v&lt;Ts, std::strong_ordering&gt;  ? 0u :
         std::is_same_v&lt;Ts, std::weak_ordering&gt;    ? 4u :
         std::is_same_v&lt;Ts, std::partial_ordering&gt; ? 2u : 1u)
    )&gt; {};
}}

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/compare/dsc strong_ordering}}
{{dsc inc|cpp/utility/compare/dsc weak_ordering}}
{{dsc inc|cpp/utility/compare/dsc partial_ordering}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}