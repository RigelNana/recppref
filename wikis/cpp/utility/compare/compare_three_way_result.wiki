{{cpp/title|compare_three_way_result}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|compare}}
{{dcl|since=c++20|1=
template&lt; class T, class U = T &gt;
struct compare_three_way_result;
}}
{{dcl end}}

Let {{tt|t}} and {{tt|u}} denote lvalue of {{c|const std::remove_reference_t&lt;T&gt;}} and {{c|const std::remove_reference_t&lt;U&gt;}} respectively, if the expression {{c|1=t &lt;=&gt; u}} is well-formed, provides the member typedef {{tt|type}} equal to {{c|1=decltype(t &lt;=&gt; u)}}, otherwise there is no member {{tt|type}}.

{{cpp/types/nospec}}

===Member types===
{{dsc begin}}
{{dsc hitem|Name|Definition}}
{{dsc|{{tt|type}}|the result type of {{c|1=operator&lt;=&gt;}} on const-qualified lvalue of {{tt|T}} and {{tt|U}}}}
{{dsc end}}

===Helper types===
{{ddcl|since=c++20|1=
template&lt; class T, class U = T &gt;
using compare_three_way_result_t = compare_three_way_result&lt;T, U&gt;::type;
}}

===Possible implementation===
{{eq fun
|1=
// recommended by Casey Carter
// see also: https://github.com/microsoft/STL/pull/385#discussion_r357894054
template&lt;class T, class U = T&gt;
using compare_three_way_result_t = decltype(
    std::declval&lt;const std::remove_reference_t&lt;T&gt;&amp;&gt;() &lt;=&gt;
    std::declval&lt;const std::remove_reference_t&lt;U&gt;&amp;&gt;()
);

template&lt;class T, class U = T&gt;
struct compare_three_way_result {};

template&lt;class T, class U&gt;
    requires requires { typename compare_three_way_result_t&lt;T, U&gt;; }
struct compare_three_way_result&lt;T, U&gt;
{
    using type = compare_three_way_result_t&lt;T, U&gt;;
};
}}

===Example===
{{example
|code=
#include &lt;compare&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;

template&lt;class Ord&gt;
void print_cmp_type()
{
    if constexpr (std::is_same_v&lt;Ord, std::strong_ordering&gt;)
        std::cout &lt;&lt; "strong ordering\n";
    else if constexpr (std::is_same_v&lt;Ord, std::weak_ordering&gt;)
        std::cout &lt;&lt; "weak ordering\n";
    else if constexpr (std::is_same_v&lt;Ord, std::partial_ordering&gt;)
        std::cout &lt;&lt; "partial ordering\n";
    else
        std::cout &lt;&lt; "illegal comparison result type\n";
}

int main()
{
    print_cmp_type&lt;std::compare_three_way_result_t&lt;int&gt;&gt;();
    print_cmp_type&lt;std::compare_three_way_result_t&lt;double&gt;&gt;();
}
|output=
strong ordering
partial ordering
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/compare/dsc partial_ordering}}
{{dsc inc|cpp/utility/compare/dsc weak_ordering}}
{{dsc inc|cpp/utility/compare/dsc strong_ordering}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}