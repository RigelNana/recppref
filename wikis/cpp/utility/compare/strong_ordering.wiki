{{cpp/title|strong_ordering}}
{{cpp/utility/navbar}}
{{ddcl|since=c++20|header=compare|1=
class strong_ordering;
}}

The class type {{tt|std::strong_ordering}} is the result type of a {{lsd|cpp/language/operator comparison#Three-way comparison}} that:
* Admits all six relational operators ({{tt|1===}}, {{tt|1=!=}}, {{tt|&lt;}}, {{tt|1=&lt;=}}, {{tt|&gt;}}, {{tt|1=&gt;=}}).
{{cpp/utility/compare/substitutable|yes}}
* {{enwiki|Connected relation|Does not allow incomparable values}}: exactly one of {{c|a &lt; b}}, {{c|1=a == b}}, or {{c|a &gt; b}} must be {{c|true}}.

===Constants===
The type {{tt|std::strong_ordering}} has four valid values, implemented as const static data members of its type:
{{dsc begin}}
{{dsc hitem|Name|Definition}}
{{dsc mem sconst|{{dsc small|{{c/core|inline constexpr std::strong_ordering}}}} less|nolink=true|a valid value indicating less-than (ordered before) relationship}}
{{dsc mem sconst|{{dsc small|{{c/core|inline constexpr std::strong_ordering}}}} equivalent|nolink=true|a valid value indicating equivalence (neither ordered before nor ordered after), the same as {{tt|equal}}}}
{{dsc mem sconst|{{dsc small|{{c/core|inline constexpr std::strong_ordering}}}} equal|nolink=true|a valid value indicating equivalence (neither ordered before nor ordered after), the same as {{tt|equivalent}}}}
{{dsc mem sconst|{{dsc small|{{c/core|inline constexpr std::strong_ordering}}}} greater|nolink=true|a valid value indicating greater-than (ordered after) relationship}}
{{dsc end}}

===Conversions===
{{tt|std::strong_ordering}} is the strongest of the three comparison categories: it is not implicitly-convertible from any other category and is implicitly-convertible to the other two.

{{dsc begin}}
{{dsc mem fun|cpp/utility/compare/strong_ordering|inlinemem=true|title=operator partial_ordering|implicit conversion to {{lc|std::partial_ordering}}}}
{{dsc end}}

{{member|{{small|std::strong_ordering::}}operator partial_ordering|2=
{{ddcl|1=
constexpr operator partial_ordering() const noexcept;
}}

===Return value===
{{lc|std::partial_ordering::less}} if {{tt|v}} is {{tt|less}},
{{lc|std::partial_ordering::greater}} if {{tt|v}} is {{tt|greater}},
{{lc|std::partial_ordering::equivalent}} if {{tt|v}} is {{tt|equal}} or {{tt|equivalent}}.
}}

{{dsc begin}}
{{dsc mem fun|cpp/utility/compare/strong_ordering|inlinemem=true|title=operator weak_ordering|implicit conversion to {{lc|std::weak_ordering}}}}
{{dsc end}}

{{member|{{small|std::strong_ordering::}}operator weak_ordering|2=
{{ddcl|1=
constexpr operator weak_ordering() const noexcept;
}}

===Return value===
{{lc|std::weak_ordering::less}} if {{tt|v}} is {{tt|less}},
{{lc|std::weak_ordering::greater}} if {{tt|v}} is {{tt|greater}},
{{lc|std::weak_ordering::equivalent}} if {{tt|v}} is {{tt|equal}} or {{tt|equivalent}}.
}}

===Comparisons===
Comparison operators are defined between values of this type and literal {{c|0}}. This supports the expressions {{c|1=a &lt;=&gt; b == 0}} or {{c|1=a &lt;=&gt; b &lt; 0}} that can be used to convert the result of a three-way comparison operator to a boolean relationship; see  {{ltt|cpp/utility/compare/named comparison functions|std::is_eq}}, {{ltt|cpp/utility/compare/named comparison functions|std::is_lt}}, etc.

{{cpp/hidden friend|plural=yes|{{tt|std::strong_ordering}}}}

The behavior of a program that attempts to compare a {{tt|strong_ordering}} with anything other than the integer literal {{c|0}} is undefined.

{{dsc begin}}
{{dsc fun|cpp/utility/compare/strong_ordering|inlinemem=true|title=operator{{==}}&lt;br&gt;operator&amp;lt;&lt;br&gt;operator&amp;gt;&lt;br&gt;operator&amp;lt;{{=}}&lt;br&gt;operator&amp;gt;{{=}}&lt;br&gt;operator&lt;{{=}}&gt;|compares with zero or a {{tt|strong_ordering}}}}
{{dsc end}}

{{member|1=operator==|2=
{{dcl begin}}
{{dcl|num=1|1=
friend constexpr bool
operator==( strong_ordering v, /*unspecified*/ u ) noexcept;
}}
{{dcl|num=2|1=
friend constexpr bool
operator==( strong_ordering v, strong_ordering w ) noexcept = default;
}}
{{dcl end}}

===Parameters===
{{par begin}}
{{par|v, w|{{tt|std::strong_ordering}} values to check}}
{{par|u|an unused parameter of any type that accepts literal zero argument}}
{{par end}}

===Return value===
@1@ {{c|true}} if {{tt|v}} is {{tt|equivalent}} or {{tt|equal}}, {{c|false}} if {{tt|v}} is {{tt|less}} or {{tt|greater}}
@2@ {{c|true}} if both parameters hold the same value, {{c|false}} otherwise. Note that {{tt|equal}} is the same as {{tt|equivalent}}.
}}

{{member|1=operator&lt;|2=
{{dcl begin}}
{{dcl|num=1|1=
friend constexpr bool operator&lt;( strong_ordering v, /*unspecified*/ u ) noexcept;
}}
{{dcl|num=2|1=
friend constexpr bool operator&lt;( /*unspecified*/ u, strong_ordering v ) noexcept;
}}
{{dcl end}}

===Parameters===
{{par begin}}
{{par|v|a {{tt|std::strong_ordering}} value to check}}
{{par|u|an unused parameter of any type that accepts literal zero argument}}
{{par end}}

===Return value===
@1@ {{c|true}} if {{tt|v}} is {{tt|less}}, and {{c|false}} if {{tt|v}} is {{tt|greater}},  {{tt|equivalent}}, or {{tt|equal}}
@2@ {{c|true}} if {{tt|v}} is {{tt|greater}}, and {{c|false}} if {{tt|v}} is {{tt|less}},  {{tt|equivalent}}, or {{tt|equal}}
}}

{{member|1=operator&lt;=|2=
{{dcl begin}}
{{dcl|num=1|1=
friend constexpr bool operator&lt;=( strong_ordering v, /*unspecified*/ u ) noexcept;
}}
{{dcl|num=2|1=
friend constexpr bool operator&lt;=( /*unspecified*/ u, strong_ordering v ) noexcept;
}}
{{dcl end}}

===Parameters===
{{par begin}}
{{par|v|a {{tt|std::strong_ordering}} value to check}}
{{par|u|an unused parameter of any type that accepts literal zero argument}}
{{par end}}

===Return value===
@1@ {{c|true}} if {{tt|v}} is {{tt|less}}, {{tt|equivalent}}, or {{tt|equal}}, and {{c|false}} if {{tt|v}} is {{tt|greater}}
@2@ {{c|true}} if {{tt|v}} is {{tt|greater}}, {{tt|equivalent}}, or {{tt|equal}}, and {{c|false}} if {{tt|v}} is {{tt|less}}
}}

{{member|1=operator&gt;|2=
{{dcl begin}}
{{dcl|num=1|1=
friend constexpr bool operator&gt;( strong_ordering v, /*unspecified*/ u ) noexcept;
}}
{{dcl|num=2|1=
friend constexpr bool operator&gt;( /*unspecified*/ u, strong_ordering v ) noexcept;
}}
{{dcl end}}

===Parameters===
{{par begin}}
{{par|v|a {{tt|std::strong_ordering}} value to check}}
{{par|u|an unused parameter of any type that accepts literal zero argument}}
{{par end}}

===Return value===
@1@ {{c|true}} if {{tt|v}} is {{tt|greater}}, and {{c|false}} if {{tt|v}} is {{tt|less}}, {{tt|equivalent}}, or {{tt|equal}}
@2@ {{c|true}} if {{tt|v}} is {{tt|less}}, and {{c|false}} if {{tt|v}} is {{tt|greater}}, {{tt|equivalent}}, or {{tt|equal}}
}}

{{member|1=operator&gt;=|2=
{{dcl begin}}
{{dcl|num=1|1=
friend constexpr bool operator&gt;=( strong_ordering v, /*unspecified*/ u ) noexcept;
}}
{{dcl|num=2|1=
friend constexpr bool operator&gt;=( /*unspecified*/ u, strong_ordering v ) noexcept;
}}
{{dcl end}}

===Parameters===
{{par begin}}
{{par|v|a {{tt|std::strong_ordering}} value to check}}
{{par|u|an unused parameter of any type that accepts literal zero argument}}
{{par end}}

===Return value===
@1@ {{c|true}} if {{tt|v}} is {{tt|greater}}, {{tt|equivalent}}, or {{tt|equal}}, and {{c|false}} if {{tt|v}} is {{tt|less}}
@2@ {{c|true}} if {{tt|v}} is {{tt|less}}, {{tt|equivalent}}, or {{tt|equal}}, and {{c|false}} if {{tt|v}} is {{tt|greater}}
}}

{{member|1=operator&lt;=&gt;|2=
{{dcl begin}}
{{dcl|num=1|1=
friend constexpr strong_ordering
operator&lt;=&gt;( strong_ordering v, /*unspecified*/ u ) noexcept;
}}
{{dcl|num=2|1=
friend constexpr strong_ordering
operator&lt;=&gt;( /*unspecified*/ u, strong_ordering v ) noexcept;
}}
{{dcl end}}

===Parameters===
{{par begin}}
{{par|v|a {{tt|std::strong_ordering}} value to check}}
{{par|u|an unused parameter of any type that accepts literal zero argument}}
{{par end}}

===Return value===
@1@ {{c|v}}.
@2@ {{tt|greater}} if {{tt|v}} is {{tt|less}}, {{tt|less}} if {{tt|v}} is {{tt|greater}}, otherwise {{tt|v}}.
}}

===Example===
{{example
|code=
#include &lt;compare&gt;
#include &lt;iostream&gt;

struct Point
{
    int x{}, y{};

    friend constexpr std::strong_ordering operator&lt;=&gt;(Point lhs, Point rhs)
    {
        if (lhs.x &lt; rhs.x or (lhs.x == rhs.x and lhs.y &lt; rhs.y))
            return std::strong_ordering::less;
        if (lhs.x &gt; rhs.x or (lhs.x == rhs.x and lhs.y &gt; rhs.y))
            return std::strong_ordering::greater;
        return std::strong_ordering::equivalent;
    }

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Point s)
    {
        return os &lt;&lt; '(' &lt;&lt; s.x &lt;&lt; ',' &lt;&lt; s.y &lt;&lt; ')';
    }
};

void print_three_way_comparison(const auto&amp; p, const auto&amp; q)
{
    const auto cmp{p &lt;=&gt; q};
    std::cout &lt;&lt; p
              &lt;&lt; (cmp &lt; 0 ? " &lt;  " : cmp &gt; 0 ? " &gt;  " : " == " ) // compares with 0
              &lt;&lt; q &lt;&lt; '\n';
}

void print_two_way_comparison(const auto&amp; p, const auto&amp; q)
{
    std::cout &lt;&lt; p
              &lt;&lt; (p &lt; q ? " &lt;  " : p &gt; q ? " &gt;  " : " == ") // compares p and q
              &lt;&lt; q &lt;&lt; '\n';
}

int main()
{
    const Point p1{0, 1}, p2{0, 1}, p3{0, 2};

    print_three_way_comparison(p1, p2);
    print_two_way_comparison(p1, p2);

    print_three_way_comparison(p2, p3);
    print_two_way_comparison(p2, p3);

    print_three_way_comparison(p3, p2);
    print_two_way_comparison(p3, p2);
}
|output=
(0,1) == (0,1)
(0,1) == (0,1)
(0,1) &lt;  (0,2)
(0,1) &lt;  (0,2)
(0,2) &gt;  (0,1)
(0,2) &gt;  (0,1)
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/compare/dsc weak_ordering}}
{{dsc inc|cpp/utility/compare/dsc partial_ordering}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}