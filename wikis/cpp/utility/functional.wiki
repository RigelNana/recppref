{{title|Function objects}}
{{cpp/utility/functional/navbar}}

A ''function object'' is any object for which the function call operator is defined.  C++ provides many built-in function objects as well as support for creation and manipulation of new function objects.

===Function invocation===
{{rrev|since=c++11|
The exposition-only operation {{box|{{tti|INVOKE}}{{c/core|(f, arg_0, arg_1, arg_2, ..., arg_N)}}}} is defined as follows:

Let type {{tt|Obj}} be the unqualified type of {{c|arg_0}} (i.e., {{c/core|std::remove_cv&lt;std::remove_reference&lt;decltype(arg_0)&gt;::type&gt;::type}})
* If {{c|f}} is a [[cpp/language/pointer#Pointers to member functions|pointer to member function]] of class {{tt|C}}, then {{box|{{tti|INVOKE}}{{c/core|(f, obj, arg_1, arg_2, ..., arg_N)}}}} is equivalent to:
:* If {{c|std::is_same&lt;C, Obj&gt;::value {{!!}} std::is_base_of&lt;C, Obj&gt;::value}} is {{c|true}}
::* {{c|(obj.*f)(arg_1, arg_2, ..., arg_N)}} (invoke the member function on the object).
:* If {{tt|Obj}} is a specialization of {{lc|std::reference_wrapper}}
::* {{c|(obj.get().*f)(arg_1, arg_2, ..., arg_N)}} (invoke the member function on the specially referred object).
:* Otherwise
::* {{c|((*obj).*f)(arg_1, arg_2, ..., arg_N)}} (invoke the member function on the dereferenced object).
* Otherwise, if {{c|1=N == 0}} and {{c|f}} is a [[cpp/language/pointer#Pointers to data members|pointer to data member]] of class {{tt|C}}, then {{box|{{tti|INVOKE}}{{c/core|(mptr, obj)}}}} is equivalent to:
:* If {{c|std::is_same&lt;C, Obj&gt;::value {{!!}} std::is_base_of&lt;C, Obj&gt;::value}} is {{c|true}}
::* {{c|obj.*mptr}} (access the data member of the object).
:* If {{tt|Obj}} is a specialization of {{lc|std::reference_wrapper}}
::* {{c|obj.get().*mptr}} (access the data member of the specially referred object).
:* Otherwise
::* {{c|(*obj).*mptr}} (access the data member of the dereferenced object).
* Otherwise
:* {{box|{{tti|INVOKE}}{{c/core|(f, arg_0, arg_1, arg_2, ..., arg_N)}}}} is equivalent to {{c|f(arg_0, arg_1, arg_2, ..., arg_N)}} (invoke the callable).


The exposition-only operation {{box|{{tti|INVOKE&lt;R&gt;}}{{c/core|(f, arg_0, arg_1, arg_2, ..., arg_N)}}}} is defined as follows:
* If {{tt|R}} is (possibly cv-qualified) {{c/core|void}}
:* {{box|{{c/core|static_cast&lt;void&gt;(}}{{tti|INVOKE}}{{c/core|(f, arg_0, arg_1, arg_2, ..., arg_N))}}}}.
* Otherwise
:* {{box|{{tti|INVOKE}}{{c/core|(f, arg_0, arg_1, arg_2, ..., arg_N)}}}} implicitly converted to {{tt|R}}.
{{rrev|since=c++23|
Let type {{tt|Actual}} be {{c/core|decltype(}}{{tti|INVOKE}}{{c/core|(f, arg_0, arg_1, arg_2, ..., arg_N))}}
* If {{box|{{ltt|cpp/types/reference_converts_from_temporary|std::reference_converts_from_temporary_v}} {{c/core|&lt;R, Actual&gt;}}}} is {{c|true}}
:* {{box|{{tti|INVOKE&lt;R&gt;}}{{c/core|(f, arg_0, arg_1, arg_2, ..., arg_N)}}}} is ill-formed.
}}
}}


{{tt|std::invoke}}{{rev inl|since=c++23| and {{tt|std::invoke_r}}}} can invoke any {{named req|Callable}} object with given arguments according to the rules of {{tti|INVOKE}}{{rev inl|since=c++23| and {{tti|INVOKE&lt;R&gt;}}}}.

{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc invoke}}
{{dsc end}}

===Function wrappers===
These polymorphic wrapper classes provide support for storing arbitrary function objects.

{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc function}}
{{dsc inc|cpp/utility/functional/dsc move_only_function}}
{{dsc inc|cpp/utility/functional/dsc copyable_function}}
{{dsc inc|cpp/utility/functional/dsc function_ref}}
{{dsc inc|cpp/utility/functional/dsc bad_function_call}}
{{dsc inc|cpp/utility/functional/dsc mem_fn}}
{{dsc end}}

===Identity===
{{lc|std::identity}} is the identity function object: it returns its argument unchanged.

{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc identity}}
{{dsc end}}

===Partial function application===
{{lc|std::bind_front}} and {{lc|std::bind}} provide support for {{enwiki|Partial application|partial function application}}, i.e. binding arguments to functions to produce new functions.

{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc bind_front}}
{{dsc inc|cpp/utility/functional/dsc bind}}
{{dsc inc|cpp/utility/functional/dsc is_bind_expression}}
{{dsc inc|cpp/utility/functional/dsc is_placeholder}}
{{dsc namespace|std::placeholders}}
{{dsc inc|cpp/utility/functional/dsc placeholders}}
{{dsc end}}

===Negators===
{{lc|std::not_fn}} creates a function object that negates the result of the callable object passed to it.

{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc not_fn}}
{{dsc end}}

===Searchers===
Searchers implementing several string searching algorithms are provided and can be used either directly or with {{lc|std::search}}.

{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc default_searcher}}
{{dsc inc|cpp/utility/functional/dsc boyer_moore_searcher}}
{{dsc inc|cpp/utility/functional/dsc boyer_moore_horspool_searcher}}
{{dsc end}}

===Reference wrappers===
Reference wrappers allow reference arguments to be stored in copyable function objects:

{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc reference_wrapper}}
{{dsc inc|cpp/utility/functional/dsc ref}}
{{dsc inc|cpp/utility/functional/dsc unwrap_reference}}
{{dsc end}}

{{rrev|since=c++14|
===Transparent function objects===
{{ls|cpp/container#Associative containers}}{{rev inl|since=c++20| and {{lsd|cpp/container#Unordered associative containers}}}} provide heterogeneous lookup{{rev inl|since=c++23| and erasure}} operations, but they are only enabled if the supplied function object type {{tt|T}} is ''transparent''{{sep}}: the qualified identifier {{tt|T::is_transparent}} is valid and denotes a type.

All transparent function object types in the standard library defines a nested type {{tt|is_transparent}}. However, user-defined transparent function object types do not need to directly provide {{tt|is_transparent}} as a nested type: it can be defined in a base class, as long as {{tt|T::is_transparent}} satisfies the transparent requirement stated above.
}}

===Operator function objects===
C++ defines the following function objects that represent common arithmetic and logical operations.

{{rrev|since=c++14|
The {{c/core|void}} specializations deduce their parameter types and return types from their arguments, they are all [[#Transparent function objects|transparent]].
}}

{{dsc begin}}
{{dsc h2|Arithmetic operations}}
{{dsc inc|cpp/utility/functional/dsc plus}}
{{dsc inc|cpp/utility/functional/dsc plus void}}
{{dsc inc|cpp/utility/functional/dsc minus}}
{{dsc inc|cpp/utility/functional/dsc minus void}}
{{dsc inc|cpp/utility/functional/dsc multiplies}}
{{dsc inc|cpp/utility/functional/dsc multiplies void}}
{{dsc inc|cpp/utility/functional/dsc divides}}
{{dsc inc|cpp/utility/functional/dsc divides void}}
{{dsc inc|cpp/utility/functional/dsc modulus}}
{{dsc inc|cpp/utility/functional/dsc modulus void}}
{{dsc inc|cpp/utility/functional/dsc negate}}
{{dsc inc|cpp/utility/functional/dsc negate void}}

{{dsc h2|Comparisons}}
{{dsc inc|cpp/utility/functional/dsc equal_to}}
{{dsc inc|cpp/utility/functional/dsc equal_to void}}
{{dsc inc|cpp/utility/functional/dsc not_equal_to}}
{{dsc inc|cpp/utility/functional/dsc not_equal_to void}}
{{dsc inc|cpp/utility/functional/dsc greater}}
{{dsc inc|cpp/utility/functional/dsc greater void}}
{{dsc inc|cpp/utility/functional/dsc less}}
{{dsc inc|cpp/utility/functional/dsc less void}}
{{dsc inc|cpp/utility/functional/dsc greater_equal}}
{{dsc inc|cpp/utility/functional/dsc greater_equal void}}
{{dsc inc|cpp/utility/functional/dsc less_equal}}
{{dsc inc|cpp/utility/functional/dsc less_equal void}}

{{dsc h2|Logical operations}}
{{dsc inc|cpp/utility/functional/dsc logical_and}}
{{dsc inc|cpp/utility/functional/dsc logical_and void}}
{{dsc inc|cpp/utility/functional/dsc logical_or}}
{{dsc inc|cpp/utility/functional/dsc logical_or void}}
{{dsc inc|cpp/utility/functional/dsc logical_not}}
{{dsc inc|cpp/utility/functional/dsc logical_not void}}

{{dsc h2|Bitwise operations}}
{{dsc inc|cpp/utility/functional/dsc bit_and}}
{{dsc inc|cpp/utility/functional/dsc bit_and void}}
{{dsc inc|cpp/utility/functional/dsc bit_or}}
{{dsc inc|cpp/utility/functional/dsc bit_or void}}
{{dsc inc|cpp/utility/functional/dsc bit_xor}}
{{dsc inc|cpp/utility/functional/dsc bit_xor void}}
{{dsc inc|cpp/utility/functional/dsc bit_not}}
{{dsc inc|cpp/utility/functional/dsc bit_not void}}
{{dsc end}}


{{rrev|since=c++20|
===Constrained comparison function objects===
The following comparison function objects are [[cpp/language/constraints|constrained]].
* The equality operators ({{tt|ranges::equal_to}} and {{tt|ranges::not_equal_to}}) require the types of the arguments to satisfy {{lconcept|equality_comparable_with}}.
* The relational operators ({{tt|ranges::less}}, {{tt|ranges::greater}}, {{tt|ranges::less_equal}}, and {{tt|ranges::greater_equal}}) require the types of the arguments to satisfy {{lconcept|totally_ordered_with}}.
* The three-way comparison operator ({{tt|compare_three_way}}) requires the type to model {{lconcept|three_way_comparable_with}}.

All these function objects are [[#Transparent function objects|transparent]].

{{dsc begin}}
{{dsc inc|cpp/utility/functional/ranges/dsc equal_to}}
{{dsc inc|cpp/utility/functional/ranges/dsc not_equal_to}}
{{dsc inc|cpp/utility/functional/ranges/dsc less}}
{{dsc inc|cpp/utility/functional/ranges/dsc greater}}
{{dsc inc|cpp/utility/functional/ranges/dsc less_equal}}
{{dsc inc|cpp/utility/functional/ranges/dsc greater_equal}}
{{dsc inc|cpp/utility/compare/dsc compare_three_way}}
{{dsc end}}
}}


{{rrev|since=c++26|
===Helper items===
Following exposition-only items are used for several components in the standard library but they are not part of the interface of the standard library.

{{dcl begin}}
{{dcla|num=1|anchor=callable|expos=yes|1=
template&lt; class Fn, class... Args &gt;
concept /*callable*/ =
    requires (Fn&amp;&amp; fn, Args&amp;&amp;... args) {
        std::forward&lt;Fn&gt;(fn)(std::forward&lt;Args&gt;(args)...);
    };
}}
{{dcla|num=2|anchor=nothrow-callable|expos=yes|1=
template&lt; class Fn, class... Args &gt;
concept /*nothrow-callable*/ =
    /*callable*/&lt;Fn, Args...&gt; &amp;&amp;
    requires (Fn&amp;&amp; fn, Args&amp;&amp;... args) {
        { std::forward&lt;Fn&gt;(fn)(std::forward&lt;Args&gt;(args)...) } noexcept;
    };
}}
{{dcla|num=3|anchor=call-result-t|expos=yes|1=
template&lt; class Fn, class... Args &gt;
using /*call-result-t*/ = decltype(std::declval&lt;Fn&gt;()(std::declval&lt;Args&gt;()...));
}}
{{dcla|num=4|anchor=decayed-typeof|expos=yes|1=
template&lt; const auto&amp; T &gt;
using /*decayed-typeof*/ = decltype(auto(T));
}}
{{dcl end}}
}}


{{rrev|until=c++20|
===Old binders and adaptors===
Several utilities that provided early functional support are deprecated and removed:

{{dsc begin}}
{{dsc h2|Base}}
{{dsc inc|cpp/utility/functional/dsc unary_function}}
{{dsc inc|cpp/utility/functional/dsc binary_function}}

{{dsc h2|Binders}}
{{dsc inc|cpp/utility/functional/dsc binder12}}
{{dsc inc|cpp/utility/functional/dsc bind12}}

{{dsc h2|Function adaptors}}
{{dsc inc|cpp/utility/functional/dsc pointer_to_unary_function}}
{{dsc inc|cpp/utility/functional/dsc pointer_to_binary_function}}
{{dsc inc|cpp/utility/functional/dsc ptr_fun}}
{{dsc inc|cpp/utility/functional/dsc mem_fun_t}}
{{dsc inc|cpp/utility/functional/dsc mem_fun}}
{{dsc inc|cpp/utility/functional/dsc mem_fun_ref_t}}
{{dsc inc|cpp/utility/functional/dsc mem_fun_ref}}
{{dsc inc|cpp/utility/functional/dsc unary_negate}}
{{dsc inc|cpp/utility/functional/dsc binary_negate}}
{{dsc inc|cpp/utility/functional/dsc not1}}
{{dsc inc|cpp/utility/functional/dsc not2}}
{{dsc end}}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=185|std=C++98|before=using function objects improved the program efficiency|after=removed the claim}}
{{dr list item|wg=lwg|dr=660|std=C++98|before=function objects for bitwise operations are missing|after=added}}
{{dr list item|wg=lwg|dr=2149|std=C++98|before=function objects taking one or two arguments were required to&lt;br&gt;provide nested types to denote the argument and result types|after=not required}}
{{dr list item|wg=lwg|dr=2219|std=C++11|before={{tti|INVOKE}} did not handle {{lc|std::reference_wrapper}} correctly|after=handles correctly}}
{{dr list item|wg=lwg|dr=2420|std=C++11|before={{tti|INVOKE&lt;R&gt;}} did not discard the return value if {{tt|R}} is {{c/core|void}}|after=discards the return value in this case}}
{{dr list item|wg=lwg|dr=2926|paper=P0604R0|std=C++11|before=the syntax of the {{tti|INVOKE}} operation with a return&lt;br&gt;type {{tt|R}} was {{box|{{tti|INVOKE}}{{c/core|(f, t1, t2, ..., tN, R)}}}}|after=changed to&lt;br&gt;{{box|{{tti|INVOKE&lt;R&gt;}}{{c/core|(f, t1, t2, ..., tN)}}}}}}
{{dr list item|wg=lwg|dr=3655|std=C++11|before={{tti|INVOKE}} did not handle unions correctly&lt;br&gt;due to the resolution of {{lwg|2219}}|after=handles correctly}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}