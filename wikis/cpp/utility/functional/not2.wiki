{{cpp/title|not2}}
{{cpp/utility/functional/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl rev begin}}
{{dcl|until=c++14| 
template&lt; class Predicate &gt;
std::binary_negate&lt;Predicate&gt; not2( const Predicate&amp; pred );
}}
{{dcl|since=c++14|deprecated=c++17|removed=c++20|
template&lt; class Predicate &gt;
constexpr std::binary_negate&lt;Predicate&gt; not2( const Predicate&amp; pred );
}}
{{dcl rev end}}
{{dcl end}}

{{tt|std::not2}} is a helper function to create a function object that returns the complement of the binary predicate function passed. The function object created is of type {{c|std::binary_negate&lt;Predicate&gt;}}.

The binary predicate type must define two member types, {{tt|first_argument_type}} and {{tt|second_argument_type}}, that are convertible to the predicate's parameter types. The function objects obtained from {{lc|std::owner_less}}, {{lc|std::ref}}, {{lc|std::cref}}, {{lc|std::plus}}, {{lc|std::minus}}, {{lc|std::multiplies}}, {{lc|std::divides}}, {{lc|std::modulus}}, {{lc|std::equal_to}}, {{lc|std::not_equal_to}}, {{lc|std::greater}}, {{lc|std::less}}, {{lc|std::greater_equal}}, {{lc|std::less_equal}}, {{lc|std::logical_not}}, {{lc|std::logical_or}}, {{lc|std::bit_and}}, {{lc|std::bit_or}}, {{lc|std::bit_xor}}, {{lc|std::mem_fn}}, {{lc|std::map::value_comp}}, {{lc|std::multimap::value_comp}}, {{lc|std::function}}, or from another call to {{tt|std::not2}} have these types defined, as are function objects derived from the deprecated {{lc|std::binary_function}}. 

===Parameters===
{{par begin}}
{{par|pred|binary predicate}}
{{par end}}

===Return value===
{{tt|std::not2}} returns an object of type {{c|std::binary_negate&lt;Predicate&gt;}}, constructed with {{c|pred}}.

===Exceptions===
(none)

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cstddef&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
 
struct old_same : std::binary_function&lt;int, int, bool&gt;
{
    bool operator()(int a, int b) const { return a == b; }
};
 
struct new_same
{
    bool operator()(int a, int b) const { return a == b; }
};

bool same_fn(int a, int b)
{
    return a == b;
}
 
int main()
{
    std::vector&lt;int&gt; v1{0, 1, 2};
    std::vector&lt;int&gt; v2{2, 1, 0};
    std::vector&lt;bool&gt; v3(v1.size());
 
    std::cout &lt;&lt; "negating a binary_function:\n";
    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),
                   std::not2(old_same()));
 
    std::cout &lt;&lt; std::boolalpha;
    for (std::size_t i = 0; i &lt; v1.size(); ++i)
        std::cout &lt;&lt; v1[i] &lt;&lt; ' ' &lt;&lt; v2[i] &lt;&lt; ' ' &lt;&lt; v3[i] &lt;&lt; '\n';
 
    std::cout &lt;&lt; "negating a standard functor:\n";
    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),
                   std::not2(std::equal_to&lt;int&gt;()));
 
    for (std::size_t i = 0; i &lt; v1.size(); ++i)
        std::cout &lt;&lt; v1[i] &lt;&lt; ' ' &lt;&lt; v2[i] &lt;&lt; ' ' &lt;&lt; v3[i] &lt;&lt; '\n';
 
    std::cout &lt;&lt; "negating a std::function:\n";
    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),
                   std::not2(std::function&lt;bool(int, int)&gt;(new_same())));
 
    for (std::size_t i = 0; i &lt; v1.size(); ++i)
        std::cout &lt;&lt; v1[i] &lt;&lt; ' ' &lt;&lt; v2[i] &lt;&lt; ' ' &lt;&lt; v3[i] &lt;&lt; '\n';

    std::cout &lt;&lt; "negating a std::reference_wrapper:\n";
    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(),
                   std::not2(std::ref(same_fn)));
 
    for (std::size_t i = 0; i &lt; v1.size(); ++i)
        std::cout &lt;&lt; v1[i] &lt;&lt; ' ' &lt;&lt; v2[i] &lt;&lt; ' ' &lt;&lt; v3[i] &lt;&lt; '\n';
}
|output=
negating a binary_function:
0 2 true
1 1 false
2 0 true
negating a standard functor:
0 2 true
1 1 false
2 0 true
negating a std::function:
0 2 true
1 1 false
2 0 true
negating a std::reference_wrapper:
0 2 true
1 1 false
2 0 true
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc not_fn}}
{{dsc inc|cpp/utility/functional/dsc binary_negate}}
{{dsc inc|cpp/utility/functional/dsc function}}
{{dsc inc|cpp/utility/functional/dsc move_only_function}}
{{dsc inc|cpp/utility/functional/dsc not1}}
{{dsc inc|cpp/utility/functional/dsc ptr_fun}}
{{dsc inc|cpp/utility/functional/dsc binary_function}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}