{{cpp/title|move_only_function}}
{{cpp/utility/functional/move_only_function/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl|num=1|since=c++23|
template&lt; class... &gt;
class move_only_function; // not defined
}}
{{dcl|num=2|since=c++23|
template&lt; class R, class... Args &gt;
class move_only_function&lt;R(Args...)&gt;;
template&lt; class R, class... Args &gt;
class move_only_function&lt;R(Args...) noexcept&gt;;
template&lt; class R, class... Args &gt;
class move_only_function&lt;R(Args...) &amp;&gt;;
template&lt; class R, class... Args &gt;
class move_only_function&lt;R(Args...) &amp; noexcept&gt;;
template&lt; class R, class... Args &gt;
class move_only_function&lt;R(Args...) &amp;&amp;&gt;;
template&lt; class R, class... Args &gt;
class move_only_function&lt;R(Args...) &amp;&amp; noexcept&gt;;
template&lt; class R, class... Args &gt;
class move_only_function&lt;R(Args...) const&gt;;
template&lt; class R, class... Args &gt;
class move_only_function&lt;R(Args...) const noexcept&gt;;
template&lt; class R, class... Args &gt;
class move_only_function&lt;R(Args...) const &amp;&gt;;
template&lt; class R, class... Args &gt;
class move_only_function&lt;R(Args...) const &amp; noexcept&gt;;
template&lt; class R, class... Args &gt;
class move_only_function&lt;R(Args...) const &amp;&amp;&gt;;
template&lt; class R, class... Args &gt;
class move_only_function&lt;R(Args...) const &amp;&amp; noexcept&gt;;
}}
{{dcl end}}

Class template {{tt|std::move_only_function}} is a general-purpose polymorphic function wrapper. {{tt|std::move_only_function}} objects can store and invoke any constructible (not required to be move constructible) {{named req|Callable}} ''target'' â€” functions, [[cpp/language/lambda|lambda expressions]], [[cpp/utility/functional/bind|bind expressions]], or other function objects, as well as pointers to member functions and pointers to member objects.

The stored callable object is called the ''target'' of {{tt|std::move_only_function}}. If a {{tt|std::move_only_function}} contains no target, it is called ''empty''. Unlike {{lc|std::function}}, invoking an ''empty'' {{tt|std::move_only_function}} results in undefined behavior.

{{tt|std::move_only_function}}s supports every possible combination of [[cpp/language/member functions#Member functions with cv-qualifiers|cv-qualifiers]] (not including {{c/core|volatile}}), [[cpp/language/member functions#Member functions with ref-qualifier|ref-qualifiers]], and [[cpp/language/noexcept spec|noexcept-specifiers]] provided in its template parameter. These qualifiers and specifier (if any) are added to its {{rlt|operator()}}.

{{tt|std::move_only_function}} satisfies the requirements of {{named req|MoveConstructible}} and {{named req|MoveAssignable}}, but does not satisfy {{named req|CopyConstructible}} or {{named req|CopyAssignable}}.

===Member types===
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|result_type}}|{{tt|R}}}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/move_only_function/dsc constructor}}
{{dsc inc|cpp/utility/functional/move_only_function/dsc destructor}}
{{dsc inc|cpp/utility/functional/move_only_function/dsc operator{{=}}}}
{{dsc inc|cpp/utility/functional/move_only_function/dsc swap}}
{{dsc inc|cpp/utility/functional/move_only_function/dsc operator_bool}}
{{dsc inc|cpp/utility/functional/move_only_function/dsc operator()}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/move_only_function/dsc swap2}}
{{dsc inc|cpp/utility/functional/move_only_function/dsc operator{{==}}}}
{{dsc end}}

===Notes===
Implementations may store a callable object of small size within the {{tt|std::move_only_function}} object. Such small object optimization is effectively required for function pointers and {{lc|std::reference_wrapper}} specializations, and can only be applied to types {{tt|T}} for which {{c|std::is_nothrow_move_constructible_v&lt;T&gt;}} is {{c|true}}.

If a {{tt|std::move_only_function}} returning a reference is initialized from a function or function object returning a prvalue (including a lambda expression without a trailing-return-type), the program is ill-formed because binding the returned reference to a temporary object is forbidden. See also {{rlpt|function#Notes|std::function}} Notes.

{{feature test macro|__cpp_lib_move_only_function|std=C++23|value=202110L|{{tt|std::move_only_function}}}}

===Example===
{{example
|code=
#include &lt;functional&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;

int main()
{
    std::packaged_task&lt;double()&gt; packaged_task([](){ return 3.14159; });

    std::future&lt;double&gt; future = packaged_task.get_future();

    auto lambda = [task = std::move(packaged_task)]() mutable { task(); };

//  std::function&lt;void()&gt; function = std::move(lambda); // Error
    std::move_only_function&lt;void()&gt; function = std::move(lambda); // OK

    function();

    std::cout &lt;&lt; future.get();
}
|output=
3.14159
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc function}}
{{dsc inc|cpp/utility/functional/dsc function_ref}}
{{dsc inc|cpp/utility/functional/dsc copyable_function}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}