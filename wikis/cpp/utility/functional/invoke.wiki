{{cpp/title|invoke|invoke_r}}
{{cpp/utility/functional/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcla|num=1|since=c++17|notes={{mark constexpr since c++20}}|
template&lt; class F, class... Args &gt;
std::invoke_result_t&lt;F, Args...&gt;
    invoke( F&amp;&amp; f, Args&amp;&amp;... args ) noexcept(/* see below */);
}}
{{dcla|num=2|since=c++23|
template&lt; class R, class F, class... Args &gt;
constexpr R
    invoke_r( F&amp;&amp; f, Args&amp;&amp;... args ) noexcept(/* see below */);
}}
{{dcl end}}

@1@ Invoke the {{named req|Callable}} object {{c|f}} with the parameters {{c|args}} as by {{box|{{rlpi|/|INVOKE}}{{c/core|(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)}}}}. {{cpp/enable if|{{c|std::is_invocable_v&lt;F, Args...&gt;}} is {{c|true}}}}.

@2@ Invoke the {{named req|Callable}} object {{c|f}} with the parameters {{c|args}} as by {{box|{{rlpi|/|INVOKE&lt;R&gt;}}{{c/core|(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)}}}}. {{cpp/enable if|{{c|std::is_invocable_r_v&lt;R, F, Args...&gt;}} is {{c|true}}}}.

===Parameters===
{{par begin}}
{{par|f|{{named req|Callable}} object to be invoked}}
{{par|args|arguments to pass to {{c|f}}}}
{{par end}}

===Return value===
@1@ The value returned by {{c|f}}.
@2@ The value returned by {{c|f}}, implicitly converted to {{tt|R}}, if {{tt|R}} is not (possibly [[cpp/language/cv|cv-qualified]]) {{c/core|void}}. None otherwise.

===Exceptions===
@1@ {{noexcept|std::is_nothrow_invocable_v&lt;F, Args...&gt;}}
@2@ {{noexcept|std::is_nothrow_invocable_r_v&lt;R, F, Args...&gt;}}

===Possible implementation===
{{eq impl
|title1=invoke (1)|ver1=1|1=
namespace detail
{
    template&lt;class&gt;
    constexpr bool is_reference_wrapper_v = false;
    template&lt;class U&gt;
    constexpr bool is_reference_wrapper_v&lt;std::reference_wrapper&lt;U&gt;&gt; = true;
    
    template&lt;class T&gt;
    using remove_cvref_t = std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;;
    
    template&lt;class C, class Pointed, class Object, class... Args&gt;
    constexpr decltype(auto) invoke_memptr(Pointed C::* member, Object&amp;&amp; object,
                                           Args&amp;&amp;... args)
    {
        using object_t = remove_cvref_t&lt;Object&gt;;
        constexpr bool is_member_function = std::is_function_v&lt;Pointed&gt;;
        constexpr bool is_wrapped = is_reference_wrapper_v&lt;object_t&gt;;
        constexpr bool is_derived_object = std::is_same_v&lt;C, object_t&gt;
                                        {{!!}} std::is_base_of_v&lt;C, object_t&gt;;
        
        if constexpr (is_member_function)
        {
            if constexpr (is_derived_object)
                return (std::forward&lt;Object&gt;(object) .* member)
                           (std::forward&lt;Args&gt;(args)...);
            else if constexpr (is_wrapped)
                return (object.get() .* member)(std::forward&lt;Args&gt;(args)...);
            else
                return ((*std::forward&lt;Object&gt;(object)) .* member)
                           (std::forward&lt;Args&gt;(args)...);
        }
        else
        {
            static_assert(std::is_object_v&lt;Pointed&gt; &amp;&amp; sizeof...(args) == 0);
            if constexpr (is_derived_object)
                return std::forward&lt;Object&gt;(object) .* member;
            else if constexpr (is_wrapped)
                return object.get() .* member;
            else
                return (*std::forward&lt;Object&gt;(object)) .* member;
        }
    }
} // namespace detail

template&lt;class F, class... Args&gt;
constexpr std::invoke_result_t&lt;F, Args...&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args)
    noexcept(std::is_nothrow_invocable_v&lt;F, Args...&gt;)
{
    if constexpr (std::is_member_pointer_v&lt;detail::remove_cvref_t&lt;F&gt;&gt;)
        return detail::invoke_memptr(f, std::forward&lt;Args&gt;(args)...);
    else
        return std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...);
}
|title2=invoke_r (2)|ver2=2|2=
template&lt;class R, class F, class... Args&gt;
    requires std::is_invocable_r_v&lt;R, F, Args...&gt;
constexpr R invoke_r(F&amp;&amp; f, Args&amp;&amp;... args)
    noexcept(std::is_nothrow_invocable_r_v&lt;R, F, Args...&gt;)
{
    if constexpr (std::is_void_v&lt;R&gt;)
        std::invoke(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);
    else
        return std::invoke(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);
}
}}

===Notes===
{{ftm begin|comment=1|std=1}}
{{ftm|std=C++17|value=201411L|__cpp_lib_invoke|{{tt|std::invoke}}, {{vl|1}}}}
{{ftm|std=C++23|value=202106L|__cpp_lib_invoke_r|{{tt|std::invoke_r}}, {{vl|2}}}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;

struct Foo
{
    Foo(int num) : num_(num) {}
    void print_add(int i) const { std::cout &lt;&lt; num_ + i &lt;&lt; '\n'; }
    int num_;
};

void print_num(int i)
{
    std::cout &lt;&lt; i &lt;&lt; '\n';
}

struct PrintNum
{
    void operator()(int i) const
    {
        std::cout &lt;&lt; i &lt;&lt; '\n';
    }
};

int main()
{
    std::cout &lt;&lt; "invoke a free function: ";
    std::invoke(print_num, -9);

    std::cout &lt;&lt; "invoke a lambda: ";
    std::invoke([](){ print_num(42); });

    std::cout &lt;&lt; "invoke a member function: ";
    const Foo foo(314159);
    std::invoke(&amp;Foo::print_add, foo, 1);

    std::cout &lt;&lt; "invoke (i.e., access) a data member num_: "
              &lt;&lt; std::invoke(&amp;Foo::num_, foo) &lt;&lt; '\n';

    std::cout &lt;&lt; "invoke a function object: ";
    std::invoke(PrintNum(), 18);

#if defined(__cpp_lib_invoke_r)
    auto add = [](int x, int y){ return x + y; };
    std::cout &lt;&lt; "invoke a lambda converting result to float: ";
    auto ret = std::invoke_r&lt;float&gt;(add, 11, 22);
    static_assert(std::is_same&lt;decltype(ret), float&gt;());
    std::cout &lt;&lt; std::fixed &lt;&lt; ret &lt;&lt; "\ninvoke print_num: ";
    std::invoke_r&lt;void&gt;(print_num, 44);
#endif
}
|p=true
|output=
invoke a free function: -9
invoke a lambda: 42
invoke a member function: 314160
invoke (i.e., access) a data member num_: 314159
invoke a function object: 18
invoke a lambda converting result to float: 33.000000
invoke print_num: 44
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc mem_fn}}
{{dsc inc|cpp/types/dsc result_of}}
{{dsc inc|cpp/types/dsc is_invocable}}
{{dsc inc|cpp/utility/dsc apply}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}