{{title|deduction guides for {{tt|std::function_ref}}}}
{{cpp/utility/functional/function_ref/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl|num=1|since=c++26|
template&lt; class F &gt;
function_ref( F* ) -&gt; function_ref&lt;F&gt;;
}}
{{dcl|num=2|since=c++26|
template&lt; auto f &gt;
function_ref( std::nontype_t&lt;f&gt; ) -&gt; function_ref&lt;/*see below*/&gt;;
}}
{{dcl|num=3|since=c++26|
template&lt; auto f, class T &gt;
function_ref( std::nontype_t&lt;f&gt;, T&amp;&amp; ) -&gt; function_ref&lt;/*see below*/&gt;;
}}
{{dcl end}}
@1@ {{cpp/enable_if|{{c|std::is_function_v&lt;F&gt;}} is {{c|true}}}}.
@2@ Let type {{c|F}} be {{c|std::remove_pointer_t&lt;decltype(f)&gt;}}. {{cpp/enable_if|{{c|std::is_function_v&lt;F&gt;}} is {{c|true}}}}. The deduced type is {{c|std::function_ref&lt;F&gt;}}.
@3@ Let type {{c|F}} be {{c|decltype(f)}}. {{cpp/enable_if|:
* {{c|F}} is of the form {{c|R(G::*)(A...) noexcept(E)}} (optionally cv-qualified, optionally noexcept, optionally lvalue reference qualified) for a type {{c|G}}, or
* {{c|F}} is of the form {{c|M G::*}} for a type {{c|G}} and an object type {{c|M}}, in which case let {{c|R}} be {{c|std::invoke_result_t&lt;F, T&amp;&gt;}}, {{c|A...}} be an empty pack, and {{c|E}} be false, or
* {{c|F}} is of the form {{c|R(*)(G, A...) noexcept(E)}} for a type {{c|G}}.
}}
::The deduced type is {{c|std::function_ref&lt;R(A...) noexcept(E)&gt;}}.

===Example===
{{example}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}