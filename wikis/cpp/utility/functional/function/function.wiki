{{cpp/utility/functional/function/title|function}}
{{cpp/utility/functional/function/navbar}}

{{dcl begin}}
{{dcl|num=1|since=c++11|
function() noexcept;
}}
{{dcl|num=2|since=c++11|
function( std::nullptr_t ) noexcept;
}}
{{dcl|num=3|since=c++11|
function( const function&amp; other );
}}
{{dcl rev multi|num=4|since1=c++11|until1=c++20|dcl1=
function( function&amp;&amp; other );
|dcl2=
function( function&amp;&amp; other ) noexcept;
}}
{{dcla|num=5|since=c++11|
template&lt; class F &gt; 
function( F&amp;&amp; f );
}}
{{dcla|num=6|since=c++11|removed=c++17|
template&lt; class Alloc &gt; 
function( std::allocator_arg_t, const Alloc&amp; alloc ) noexcept;
}}
{{dcl|num=7|since=c++11|removed=c++17|
template&lt; class Alloc &gt; 
function( std::allocator_arg_t, const Alloc&amp; alloc, 
          std::nullptr_t ) noexcept;
}}
{{dcl|num=8|since=c++11|removed=c++17|
template&lt; class Alloc &gt; 
function( std::allocator_arg_t, const Alloc&amp; alloc, 
          const function&amp; other );
}}
{{dcl|num=9|since=c++11|removed=c++17|
template&lt; class Alloc &gt; 
function( std::allocator_arg_t, const Alloc&amp; alloc, 
          function&amp;&amp; other );
}}
{{dcl|num=10|since=c++11|removed=c++17|
template&lt; class F, class Alloc &gt; 
function( std::allocator_arg_t, const Alloc&amp; alloc, F f );
}}
{{dcl end}}

Constructs a {{tt|std::function}} from a variety of sources.

@1,2@ Creates an {{rlp|/|empty}} {{tt|std::function}}.

@3@ Copies the {{rlp|/|target}} of {{c|other}} to the target of {{c|*this}}.
@@ If {{c|other}} is empty, {{c|*this}} will be empty right after the call too.

@4@ Moves the target of {{c|other}} to the target of {{c|*this}}.
@@ If {{c|other}} is empty, {{c|*this}} will be empty right after the call too.
@@ {{c|other}} is in a valid but unspecified state right after the call.

@5@ Initializes the target with {{c|std::forward&lt;F&gt;(f)}}. The target is of type {{c/core|std::decay&lt;F&gt;::type}}.
@@ If {{c|f}} is a null pointer to function, a null pointer to member, or an empty value of some {{tt|std::function}} specialization, {{c|*this}} will be empty right after the call.
@@ {{cpp/enable if|all following conditions are satisfied}}:
{{rrev|since=c++23|
* {{c|std::is_same_v&lt;std::remove_cvref_t&lt;F&gt;, std::function&lt;R(Args...)&gt;}} is {{c|false}}.
}}
* An lvalue of type {{c/core|std::decay&lt;F&gt;::type}} is callable for argument types {{tt|Args...}} and return type {{tt|R}}.
{{rrev|since=c++23|
If {{c|std::is_copy_constructible_v&lt;std::decay_t&lt;F&gt;&gt;}} or {{c|std::is_constructible_v&lt;std::decay_t&lt;F&gt;, F&gt;}} is {{c|false}}, the program is ill-formed.
}}
@@ If {{tt|F}} is not {{named req|CopyConstructible}}, the behavior is undefined.

@6-10@ Same as {{v|1-5}} except that {{c|alloc}} is used to allocate memory for any internal data structures that the {{tt|std::function}} might use.

When the target is a function pointer or a {{lc|std::reference_wrapper}}, small object optimization is guaranteed, that is, these targets are always directly stored inside the {{lc|std::function}} object, no dynamic allocation takes place. Other large objects may be constructed in dynamic allocated storage and accessed by the {{lc|std::function}} object through a pointer.

===Parameters===
{{par begin}}
{{par|other|the function object used to initialize {{c|*this}}}}
{{par|f|a callable object used to initialize {{c|*this}}}}
{{par|alloc|an {{named req|Allocator}} used for internal memory allocation}}
{{par hreq}}
{{par req named|Alloc|Allocator}}
{{par end}}

===Exceptions===
@3,8,9@ Does not throw if {{c|other}}'s target is a function pointer or a {{lc|std::reference_wrapper}}, otherwise may throw {{lc|std::bad_alloc}} or any exception thrown by the constructor used to copy or move the stored callable object.

{{rrev|until=c++20|
@4@ Does not throw if {{c|other}}'s target is a function pointer or a {{lc|std::reference_wrapper}}, otherwise may throw {{lc|std::bad_alloc}} or any exception thrown by the constructor used to copy or move the stored callable object.
}}
@5,10@ Does not throw if {{c|f}} is a function pointer or a {{lc|std::reference_wrapper}}, otherwise may throw {{lc|std::bad_alloc}} or any exception thrown by the copy constructor of the stored callable object.

===Notes===
{{tt|std::function}}'s allocator support was poorly specified and inconsistently implemented. Some implementations do not provide overloads {{vl|6-10}} at all, some provide the overloads but ignore the supplied allocator argument, and some provide the overloads and use the supplied allocator for construction but not when the {{tt|std::function}} is reassigned. As a result, allocator support was removed in C++17.

===Example===
{{example
|code=
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;

void print_num(int i) { std::cout &lt;&lt; "print_num(" &lt;&lt; i &lt;&lt; ")\n"; }

int main()
{
    std::function&lt;void(int)&gt; func1; // (1) empty constructor
    try
    {
        func1(333 &lt;&lt; 1);
    }
    catch (const std::bad_function_call&amp; ex)
    {
        std::cout &lt;&lt; "1) " &lt;&lt; ex.what() &lt;&lt; '\n';
    }

    std::function&lt;void(int)&gt; func2{nullptr}; // (2) empty constructor
    try
    {
        func1(222 * 3);
    }
    catch (const std::bad_function_call&amp; ex)
    {
        std::cout &lt;&lt; "2) " &lt;&lt; ex.what() &lt;&lt; '\n';
    }

    func1 = print_num; // initializes func1 using assignment operator

    std::function&lt;void(int)&gt; func3{func1}; // (3) copy constructor
    func3(33);

    std::function&lt;void(int)&gt; func4{std::move(func3)}; // (4) move constructor,
                                                      // func3 in unspecified state
    func4(44);

    std::function&lt;void(int)&gt; func5{print_num}; // (5) constructor with function
    func5(55);

    // (5) constructor with lambda
    std::function&lt;void(int)&gt; func6([](int i) { std::cout &lt;&lt; "lambda(" &lt;&lt; i &lt;&lt; ")\n"; });
    func6(66);
}
|p=true
|output=
1) bad_function_call
2) bad_function_call
print_num(33)
print_num(44)
print_num(55)
lambda(66)
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2132|std=C++11|before=overloads {{vl|5,10}} might be ambiguous|after=constrained}}
{{dr list item|wg=lwg|dr=2774|std=C++11|before={{vl|5,10}} performed an additional move|after=eliminated}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/move_only_function/dsc constructor}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}