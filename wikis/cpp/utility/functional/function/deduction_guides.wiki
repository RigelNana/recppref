{{title|deduction guides for {{tt|std::function}}}}
{{cpp/utility/functional/function/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl | num=1 | since=c++17 |
template&lt; class R, class... ArgTypes &gt;
function( R(*)(ArgTypes...) ) -&gt; function&lt;R(ArgTypes...)&gt;;
}}
{{dcl | num=2 | since=c++17 |
template&lt; class F &gt;
function( F ) -&gt; function&lt;/*see below*/&gt;;
}}
{{dcl | num=3 | since=c++23 |
template&lt; class F &gt;
function( F ) -&gt; function&lt;/*see below*/&gt;;
}}
{{dcl | num=4 | since=c++23 |
template&lt; class F &gt;
function( F ) -&gt; function&lt;/*see below*/&gt;;
}}
{{dcl end}}
@1@ This [[cpp/language/class template argument deduction|deduction guide]] is provided for {{lc|std::function}} to allow deduction from functions.
@2@ {{cpp/enable_if|{{c|&amp;F::operator()}} is well-formed when treated as an unevaluated operand and  {{c|decltype(&amp;F::operator())}} is of the form {{c|R(G::*)(A...)}} (optionally cv-qualified, optionally noexcept, optionally lvalue reference qualified)}}. The deduced type is {{c|std::function&lt;R(A...)&gt;}}.
@3@ {{cpp/enable_if|{{c|&amp;F::operator()}} is well-formed when treated as an unevaluated operand and {{c|F::operator()}} is an [[cpp/language/member_functions#Explicit_object_parameter|explicit object parameter function]] whose type is of form {{c|R(G, A...)}} or {{c|R(G, A...) noexcept}}}}. The deduced type is {{c|std::function&lt;R(A...)&gt;}}.
@4@ {{cpp/enable_if|{{c|&amp;F::operator()}} is well-formed when treated as an unevaluated operand and {{c|F::operator()}} is a [[cpp/language/static#Static_member_functions|static member function]] whose type is of form {{c|R(A...)}} or {{c|R(A...) noexcept}}}}. The deduced type is {{c|std::function&lt;R(A...)&gt;}}.

===Notes===
These deduction guides do not allow deduction from a function with [[cpp/language/variadic_arguments|ellipsis parameter]], and the {{c|...}} in the types is always treated as a [[cpp/language/parameter_pack#Pack_expansion|pack expansion]].

The type deduced by these deduction guides may change in a later standard revision (in particular, this might happen if {{c|noexcept}} support is added to {{lc|std::function}} in a later standard).

===Example===
{{example|code=
#include &lt;functional&gt;
int func(double) { return 0; }
int main() {
  std::function f{func}; // guide #1 deduces function&lt;int(double)&gt;
  int i = 5;
  std::function g = [&amp;](double) { return i; }; // guide #2 deduces function&lt;int(double)&gt;
}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3238|std=C++17|before=behavior of {{v|2}} was unclear when&lt;br&gt;{{c|F::operator()}} is &amp;&amp;-qualified|after=clarified to be excluded from overload resolution}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}