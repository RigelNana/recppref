{{cpp/utility/functional/function/title|operator{{=}}}}
{{cpp/utility/functional/function/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++11|1=
function&amp; operator=( const function&amp; other );
}}
{{dcl|num=2|since=c++11|1=
function&amp; operator=( function&amp;&amp; other );
}}
{{dcla|num=3|since=c++11|1=
function&amp; operator=( std::nullptr_t ) noexcept;
}}
{{dcla|num=4|since=c++11|1=
template&lt; class F &gt;
function&amp; operator=( F&amp;&amp; f );
}}
{{dcl|num=5|since=c++11|1=
template&lt; class F &gt;
function&amp; operator=( std::reference_wrapper&lt;F&gt; f ) noexcept;
}}
{{dcl end}}

Assigns a new ''target'' to {{tt|std::function}}.

@1@ Assigns a copy of ''target'' of {{c|other}}, as if by executing {{c|function(other).swap(*this);}}

@2@ Moves the ''target'' of {{c|other}} to {{c|*this}}. {{c|other}} is in a valid state with an unspecified value.

@3@ Drops the current ''target''. {{c|*this}} is ''empty'' after the call.

@4@ Sets the ''target'' of {{c|*this}} to the callable {{c|f}}, as if by executing {{c|function(std::forward&lt;F&gt;(f)).swap(*this);}}. This operator does not participate in overload resolution unless {{c|f}} is {{named req|Callable}} for argument types {{tt|Args...}} and return type {{tt|R}}.

@5@ Sets the ''target'' of {{c|*this}} to a copy of {{c|f}}, as if by executing {{c|function(f).swap(*this);}}

===Parameters===
{{par begin}}
{{par|other|another {{tt|std::function}} object to copy the target of}}
{{par|f|a callable to initialize the ''target'' with}}
{{par hreq}}
{{par req named|F|Callable}}
{{par end}}

===Return value===
{{c|*this}}

===Notes===
Even before allocator support was removed from {{tt|std::function}} in C++17, these assignment operators use the default allocator rather than the allocator of {{c|*this}} or the allocator of {{c|other}} (see {{lwg|2386}}).

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;functional&gt;
#include &lt;utility&gt;

int inc(int n) { return n + 1; }

int main()
{
    std::function&lt;int(int)&gt; f1;
    std::function&lt;int(int)&gt; f2(inc);
    assert(f1 == nullptr and f2 != nullptr);

    f1 = f2; // overload (1)
    assert(f1 != nullptr and f1(1) == 2);

    f1 = std::move(f2); // overload (2)
    assert(f1 != nullptr and f1(1) == 2);
    // f2 is in valid but unspecified state

    f1 = nullptr; // overload (3)
    assert(f1 == nullptr);

    f1 = inc; // overload (4)
    assert(f1 != nullptr and f1(1) == 2);

    f1 = [](int n) { return n + n; }; // overload (4)
    assert(f1 != nullptr and f1(2) == 4);

    std::reference_wrapper&lt;int(int)&gt; ref1 = std::ref(inc);
    f1 = ref1; // overload (5)
    assert(f1 != nullptr and f1(1) == 2);
}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2132|std=C++11|before=the overload {{vl|4}} taking a {{named req/core|Callable}} object might be ambiguous|after=constrained}}
{{dr list item|wg=lwg|dr=2401|std=c++11|before=assignment operator {{vl|3}} from {{tt|std::nullptr_t}} not required to be noexcept|after=required}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/move_only_function/dsc operator{{=}}}}
{{dsc inc|cpp/utility/functional/function/dsc assign}}
{{dsc begin}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}