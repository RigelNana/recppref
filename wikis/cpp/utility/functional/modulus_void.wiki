{{cpp/title|modulus&lt;void&gt;}}
{{cpp/utility/functional/navbar}}
{{ddcl|header=functional|since=c++14|
template&lt;&gt;
class modulus&lt;void&gt;;
}}

{{c/core|std::modulus&lt;void&gt;}} is a specialization of {{lc|std::modulus}} with parameter and return type deduced.

===Nested types===
{{dsc begin}}
{{dsc hitem|Nested type|Definition}}
{{dsc|{{tt|is_transparent}}|[[cpp/utility/functional#Transparent function objects|unspecified]]}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc mem fun|cpp/utility/functional/modulus_void|title=operator()|inlinemem=true|returns the modulus of two arguments}}
{{dsc end}}

{{member|{{small|std::modulus&lt;void&gt;::}}operator()|2=
{{ddcl|1=
template&lt; class T, class U &gt;
constexpr auto operator()( T&amp;&amp; lhs, U&amp;&amp; rhs ) const
    -&gt; decltype(std::forward&lt;T&gt;(lhs) % std::forward&lt;U&gt;(rhs));
}}

Returns the remainder of the division of {{c|lhs}} by {{c|rhs}}.

===Parameters===
{{par begin}}
{{par|lhs, rhs|values to divide}}
{{par end}}

===Return value===
{{c|std::forward&lt;T&gt;(lhs) % std::forward&lt;U&gt;(rhs)}}.
}}

===Example===
{{example
|code=
#include &lt;functional&gt;
#include &lt;iostream&gt;

struct M
{
    M(int x) { std::cout &lt;&lt; "M(" &lt;&lt; x &lt;&lt; ");\n"; }
    M() {}
};

auto operator%(M, M) { std::cout &lt;&lt; "operator%(M, M);\n"; return M{}; }
auto operator%(M, int) { std::cout &lt;&lt; "operator%(M, int);\n"; return M{}; }
auto operator%(int, M) { std::cout &lt;&lt; "operator%(int, M);\n"; return M{}; }

int main()
{
    M m;
    
    // 42 is converted into a temporary object M{42}
    std::modulus&lt;M&gt;{}(m, 42);    // calls operator%(M, M)
    
    // no temporary object
    std::modulus&lt;void&gt;{}(m, 42); // calls operator%(M, int)
    std::modulus&lt;void&gt;{}(42, m); // calls operator%(int, M)
}
|output=
M(42);
operator%(M, M);
operator%(M, int);
operator%(int, M);
}}

{{langlinks|es|ja|ru|zh}}