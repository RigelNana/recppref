{{cpp/ranges/title|less}}
{{cpp/utility/functional/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl|since=c++20|
struct less;
}}
{{dcl end}}

Function object for performing comparisons. Deduces the parameter types of the function call operator from the arguments (but not the return type).

===Nested types===
{{dsc begin}}
{{dsc hitem|Nested type|Definition}}
{{dsc|{{tt|is_transparent}}|[[cpp/utility/functional#Transparent function objects|unspecified]]}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc mem fun|operator()|nolink=true|checks if the first argument is ''less'' than the second}}
{{dsc end}}

{{member|1={{small|std::ranges::less::}}operator()|2=
{{ddcl|
template&lt; class T, class U &gt;
constexpr bool operator()( T&amp;&amp; t, U&amp;&amp; u ) const;
}}

Given the expression {{c|std::forward&lt;T&gt;(t) &lt; std::forward&lt;U&gt;(u)}} as {{c|expr}}:
* If {{c|expr}} results in a call to [[cpp/language/operator comparison#Built-in pointer relational comparison|built-in]] {{c/core|operator&lt;}} comparing pointers, given the {{lsd|cpp/language/pointer#Composite pointer type}} of {{c|t}} and {{c|u}} as {{tt|P}}:
:* If the converted {{c|t}} precedes the converted {{c|u}} (both are of type {{tt|P}}) in the [[cpp/language/operator comparison#Pointer total order|implementation-defined strict total order over pointers]], returns {{c|true}}, otherwise returns {{c|false}}.
:* If the conversion sequence from {{tt|T}} to {{tt|P}} or the conversion sequence from {{tt|U}} to {{tt|P}} is not [[cpp/concepts#Equality preservation|equality-preserving]], the behavior is undefined.
* Otherwise:
:* Returns the result of {{c|expr}}.
:* If {{c|std::totally_ordered_with&lt;T, U&gt;}} is not modeled, the behavior is undefined.

{{cpp/enable if|{{c|std::totally_ordered_with&lt;T, U&gt;}} is satisfied}}.

If there exists an expression {{c|expr1}} of type {{tt|T}} and an expression {{c|expr2}} of {{tt|U}}, such that the comparison results of {{c|expr1}} and {{c|expr2}} violate {{enwiki|Total order#Strict and non-strict total orders|strict total ordering}} (rules are defined below), the behavior is undefined.

The comparison results of {{c|expr1}} and {{c|expr2}} follow strict total ordering only if '''exactly one''' of the following expressions is {{c|true}}:
* {{c|std::ranges::less{}(expr1, expr2)}}
* {{c|std::ranges::less{}(expr2, expr1)}}
* {{c|std::ranges::equal_to{}(expr1, expr2)}}
}}

===Notes===
Unlike {{lc|std::less}}, {{tt|std::ranges::less}} requires all six comparison operators {{tt|&lt;}}, {{tt|1=&lt;=}}, {{tt|&gt;}}, {{tt|1=&gt;=}}, {{tt|1===}} and {{tt|1=!=}} to be valid (via the {{lconcept|totally_ordered_with}} constraint).

===Example===
{{example}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3530|std=C++20|before=syntactic checks were relaxed while comparing pointers|after=only semantic requirements are relaxed}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc less}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}