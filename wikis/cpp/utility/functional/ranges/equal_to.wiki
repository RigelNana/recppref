{{cpp/ranges/title|equal_to}}
{{cpp/utility/functional/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl|since=c++20|
struct equal_to;
}}
{{dcl end}}

Function object for performing comparisons. The parameter types of the function call operator (but not the return type) are deduced from the arguments.

===Nested types===
{{dsc begin}}
{{dsc hitem|Nested type|Definition}}
{{dsc|{{tt|is_transparent}}|[[cpp/utility/functional#Transparent function objects|unspecified]]}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc mem fun|{{PAGENAME}}#operator call|title=operator()|nolink=true|checks if the arguments are ''equal''}}
{{dsc end}}

{{member|1={{small|std::ranges::equal_to::}}operator()|2=
{{ddcl|
template&lt; class T, class U &gt;
constexpr bool operator()( T&amp;&amp; t, U&amp;&amp; u ) const;
}}

Given the expression {{c|1=std::forward&lt;T&gt;(t) == std::forward&lt;U&gt;(u)}} as {{c|expr}}:
* If {{c|expr}} results in a call to [[cpp/language/operator comparison#Built-in pointer equality comparison|built-in]] {{c/core|1=operator==}} comparing pointers, given the {{lsd|cpp/language/pointer#Composite pointer type}} of {{c|t}} and {{c|u}} as {{tt|P}}:
:* For the two converted pointers (of type {{tt|P}}), if one pointer precedes the other in the [[cpp/language/operator comparison#Pointer total order|implementation-defined strict total order over pointers]], returns {{c|false}}, otherwise returns {{c|true}}.
:* If the conversion sequence from {{tt|T}} to {{tt|P}} or the conversion sequence from {{tt|U}} to {{tt|P}} is not [[cpp/concepts#Equality preservation|equality-preserving]], the behavior is undefined.
* Otherwise:
:* Returns the result of {{c|expr}}.
:* If {{c|std::equality_comparable_with&lt;T, U&gt;}} is not modeled, the behavior is undefined.

{{cpp/enable if|{{c|std::equality_comparable_with&lt;T, U&gt;}} is satisfied}}.
}}

===Notes===
Compared to {{lc|std::equal_to}}, {{tt|std::ranges::equal_to}} additionally requires {{tt|1=!=}} to be valid, and that both argument types are required to be (homogeneously) comparable with themselves (via the {{lconcept|equality_comparable_with}} constraint).

===Example===
{{example}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3530|std=C++20|before=syntactic checks were relaxed while comparing pointers|after=only semantic requirements are relaxed}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc equal_to}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}