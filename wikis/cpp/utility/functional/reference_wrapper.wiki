{{cpp/title|reference_wrapper}}
{{cpp/utility/functional/reference_wrapper/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl|since=c++11|
template&lt; class T &gt;
class reference_wrapper;
}}
{{dcl end}}

{{tt|std::reference_wrapper}} is a class template that wraps a reference in a copyable, assignable object.

Specifically, {{tt|std::reference_wrapper}} is a {{named req|CopyConstructible}} and {{named req|CopyAssignable}} wrapper around a reference to object or reference to function of type {{tt|T}}. Instances of {{tt|std::reference_wrapper}} are objects (they can be copied or stored in containers) but they are implicitly convertible to {{c|T&amp;}}, so that they can be used as arguments with the functions that take the underlying type by reference.

If the stored reference is {{named req|Callable}}, {{tt|std::reference_wrapper}} is callable with the same arguments.

Helper functions {{lc|std::ref}} and {{lc|std::cref}} are often used to generate {{tt|std::reference_wrapper}} objects.

{{tt|std::reference_wrapper}} is used to pass objects by reference to {{lc|std::bind}}, the constructor of {{lc|std::thread}}, or the helper functions {{lc|std::make_pair}} and {{lc|std::make_tuple}}. It can also be used as a mechanism to store references inside standard containers (like {{lc|std::vector}}) that cannot normally hold references.

{{rrev|since=c++17|
{{tt|std::reference_wrapper}} is guaranteed to be {{named req|TriviallyCopyable}}.
}}

{{rrev|since=c++20|
{{tt|T}} may be an incomplete type.
}}

===Member types===
{{dsc begin}}
{{dsc hitem|type|definition}}
{{dsc|{{tt|type}}|{{tt|T}}}}
{{dsc|{{tt|result_type}}&lt;br&gt;{{mark life|deprecated=c++17|removed=c++20|br=yes}}|The return type of {{tt|T}} if {{tt|T}} is a function. Otherwise, not defined.}}
{{dsc|{{tt|argument_type}}&lt;br&gt;{{mark life|deprecated=c++17|removed=c++20|br=yes}}|
* if {{tt|T}} is a function or pointer to function that takes one argument of type {{tt|A1}}, then {{tt|argument_type}} is {{tt|A1}}&lt;br&gt;
* if {{tt|T}} is a pointer to member function of class {{tt|T0}} that takes no arguments, then {{tt|argument_type}} is {{c/core|T0*}}, possibly cv-qualified&lt;br&gt;
* if {{tt|T}} is a class type with a member type {{c/core|T::argument_type}}, then {{tt|argument_type}} is an alias of that}}
{{dsc|{{tt|first_argument_type}}&lt;br&gt;{{mark life|deprecated=c++17|removed=c++20|br=yes}}|
* if {{tt|T}} is a function or pointer to function that takes two arguments of types {{tt|A1}} and {{tt|A2}}, then {{tt|first_argument_type}} is {{tt|A1}}&lt;br&gt;
* if {{tt|T}} is a pointer to member function of class {{tt|T0}} that takes one argument, then {{tt|first_argument_type}} is {{c/core|T0*}}, possibly cv-qualified&lt;br&gt;
* if {{tt|T}} is a class type with a member type {{c/core|T::first_argument_type}}, then {{tt|first_argument_type}} is an alias of that
}}
{{dsc|{{tt|second_argument_type}}&lt;br&gt;{{mark life|deprecated=c++17|removed=c++20|br=yes}}|
* if {{tt|T}} is a function or pointer to function that takes two arguments of type s {{tt|A1}} and {{tt|A2}}, then {{tt|second_argument_type}} is {{tt|A2}}&lt;br&gt;
* if {{tt|T}} is a pointer to member function of class {{tt|T0}} that takes one argument {{tt|A1}}, then {{tt|second_argument_type}} is {{tt|A1}}, possibly cv-qualified&lt;br&gt;
* if {{tt|T}} is a class type with a member type {{c/core|T::second_argument_type}}, then {{tt|second_argument_type}} is an alias of that}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/reference_wrapper/dsc constructor}}
{{dsc inc|cpp/utility/functional/reference_wrapper/dsc operator{{=}}}}
{{dsc inc|cpp/utility/functional/reference_wrapper/dsc get}}
{{dsc inc|cpp/utility/functional/reference_wrapper/dsc operator()}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/reference_wrapper/dsc operator_cmp}}
{{dsc end}}

==={{rl|deduction guides|Deduction guides}}{{mark since c++17}}===

===Helper classes===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/reference_wrapper/dsc basic_common_reference}}
{{dsc end}}

===Possible implementation===
{{eq fun
|1=
namespace detail
{
    template&lt;class T&gt; constexpr T&amp; FUN(T&amp; t) noexcept { return t; }
    template&lt;class T&gt; void FUN(T&amp;&amp;) = delete;
}

template&lt;class T&gt;
class reference_wrapper
{
public:
    // types
    using type = T;

    // construct/copy/destroy
    template&lt;class U, class = decltype(
        detail::FUN&lt;T&gt;(std::declval&lt;U&gt;()),
        std::enable_if_t&lt;!std::is_same_v&lt;reference_wrapper, std::remove_cvref_t&lt;U&gt;&gt;&gt;()
    )&gt;
    constexpr reference_wrapper(U&amp;&amp; u)
        noexcept(noexcept(detail::FUN&lt;T&gt;(std::forward&lt;U&gt;(u))))
        : _ptr(std::addressof(detail::FUN&lt;T&gt;(std::forward&lt;U&gt;(u)))) {}

    reference_wrapper(const reference_wrapper&amp;) noexcept = default;
 
    // assignment
    reference_wrapper&amp; operator=(const reference_wrapper&amp; x) noexcept = default;
 
    // access
    constexpr operator T&amp; () const noexcept { return *_ptr; }
    constexpr T&amp; get() const noexcept { return *_ptr; }

    template&lt;class... ArgTypes&gt;
    constexpr std::invoke_result_t&lt;T&amp;, ArgTypes...&gt;
        operator() (ArgTypes&amp;&amp;... args ) const
            noexcept(std::is_nothrow_invocable_v&lt;T&amp;, ArgTypes...&gt;)
    {
        return std::invoke(get(), std::forward&lt;ArgTypes&gt;(args)...);
    }
 
private:
    T* _ptr;
};

// deduction guides
template&lt;class T&gt;
reference_wrapper(T&amp;) -&gt; reference_wrapper&lt;T&gt;;
}}

===Example===
{{example
|Demonstrates the use of {{tt|std::reference_wrapper}} as a container of references, which makes it possible to access the same container using multiple indices.
|code=
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;numeric&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

void println(auto const rem, std::ranges::range auto const&amp; v)
{
    for (std::cout &lt;&lt; rem; auto const&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

int main()
{
    std::list&lt;int&gt; l(10);
    std::iota(l.begin(), l.end(), -4);

    // can't use shuffle on a list (requires random access), but can use it on a vector
    std::vector&lt;std::reference_wrapper&lt;int&gt;&gt; v(l.begin(), l.end());

    std::ranges::shuffle(v, std::mt19937{std::random_device{}()});

    println("Contents of the list: ", l);
    println("Contents of the list, as seen through a shuffled vector: ", v);

    std::cout &lt;&lt; "Doubling the values in the initial list...\n";
    std::ranges::for_each(l, [](int&amp; i) { i *= 2; });

    println("Contents of the list, as seen through a shuffled vector: ", v);
}
|p=true
|output=
Contents of the list: -4 -3 -2 -1 0 1 2 3 4 5
Contents of the list, as seen through a shuffled vector: -1 2 -2 1 5 0 3 -3 -4 4
Doubling the values in the initial list...
Contents of the list, as seen through a shuffled vector: -2 4 -4 2 10 0 6 -6 -8 8
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc ref}}
{{dsc inc|cpp/utility/functional/dsc bind}}
{{dsc inc|cpp/utility/functional/dsc unwrap_reference}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}