{{cpp/title|n=placeholders::|_1|_2, ...|_N}}
{{cpp/utility/functional/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl|
/*see below*/ _1;
/*see below*/ _2;
.
.
/*see below*/ _N;
}}
{{dcl end}}

The {{lc|std::placeholders}} namespace contains the placeholder objects {{tt|[_1, ..., _N]}} where {{tt|N}} is an implementation defined maximum number.

When used as an argument in a {{lc|std::bind}} expression, the placeholder objects are stored in the generated function object, and when that function object is invoked with unbound arguments, each placeholder {{tt|_N}} is replaced by the corresponding Nth unbound argument.

{{rev begin}}
{{rev|until=c++17|
Each placeholder is declared as if by {{c|extern /*unspecified*/ _1;}}.
}}
{{rev|since=c++17|
Implementations are encouraged to declare the placeholders as if by {{c|inline constexpr /*unspecified*/ _1;}}, although declaring them by {{c|extern /*unspecified*/ _1;}} is still allowed by the standard.
}}
{{rev end}}
The types of the placeholder objects are {{named req|DefaultConstructible}} and {{named req|CopyConstructible}}, their default copy/move constructors do not throw exceptions, and for any placeholder {{tt|_N}}, the type {{c|std::is_placeholder&lt;decltype(_N)&gt;}} is defined, where {{c|std::is_placeholder&lt;decltype(_N)&gt;}} is derived from {{c|std::integral_constant&lt;int, N&gt;}}.

===Example===
{{example
|The following code shows the creation of function objects with placeholder arguments.
|code=
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

void goodbye(const std::string&amp; s)
{
    std::cout &lt;&lt; "Goodbye " &lt;&lt; s &lt;&lt; '\n';
}

class Object
{
public:
    void hello(const std::string&amp; s)
    {
        std::cout &lt;&lt; "Hello " &lt;&lt; s &lt;&lt; '\n';
    }
};

int main()
{
    using namespace std::placeholders;

    using ExampleFunction = std::function&lt;void(const std::string&amp;)&gt;;
    Object instance;
    std::string str("World");

    ExampleFunction f = std::bind(&amp;Object::hello, &amp;instance, _1);
    f(str); // equivalent to instance.hello(str)

    f = std::bind(&amp;goodbye, std::placeholders::_1);
    f(str); // equivalent to goodbye(str)

    auto lambda = [](std::string pre, char o, int rep, std::string post)
    {
        std::cout &lt;&lt; pre;
        while (rep-- &gt; 0)
            std::cout &lt;&lt; o;
        std::cout &lt;&lt; post &lt;&lt; '\n';
    };

    // binding the lambda:
    std::function&lt;void(std::string, char, int, std::string)&gt; g =
        std::bind(&amp;decltype(lambda)::operator(), &amp;lambda, _1, _2, _3, _4);
    g("G", 'o', 'o'-'g', "gol");
}
|output=
Hello World
Goodbye World
Goooooooogol
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc bind}}
{{dsc inc|cpp/utility/functional/dsc is_placeholder}}
{{dsc inc|cpp/utility/tuple/dsc ignore}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}