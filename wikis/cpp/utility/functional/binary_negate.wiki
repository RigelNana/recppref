{{cpp/title|binary_negate}}
{{cpp/utility/functional/navbar}}
{{dcl begin}}
{{dcl header|functional}}
{{dcl rev begin}}
{{dcl|until=c++11|
template&lt; class Predicate &gt;
struct binary_negate
    : public std::binary_function&lt;
        Predicate::first_argument_type,
        Predicate::second_argument_type,
        bool
    &gt;;
}}
{{dcl|since=c++11|deprecated=c++17|removed=c++20|
template&lt; class Predicate &gt;
struct binary_negate;
}}
{{dcl rev end}}
{{dcl end}}

{{tt|std::binary_negate}} is a wrapper function object returning the complement of the binary predicate it holds.

The binary predicate type must define two member types, {{tt|first_argument_type}} and {{tt|second_argument_type}}, that are convertible to the predicate's parameter types. The function objects obtained from {{lc|std::owner_less}}, {{lc|std::ref}}, {{lc|std::cref}}, {{lc|std::plus}}, {{lc|std::minus}}, {{lc|std::multiplies}}, {{lc|std::divides}}, {{lc|std::modulus}}, {{lc|std::equal_to}}, {{lc|std::not_equal_to}}, {{lc|std::greater}}, {{lc|std::less}}, {{lc|std::greater_equal}}, {{lc|std::less_equal}}, {{lc|std::logical_not}}, {{lc|std::logical_or}}, {{lc|std::bit_and}}, {{lc|std::bit_or}}, {{lc|std::bit_xor}}, {{lc|std::mem_fn}}, {{lc|std::map::value_comp}}, {{lc|std::multimap::value_comp}}, {{lc|std::function}}, or from a call to {{lc|std::not2}} have these types defined, as are function objects derived from the deprecated {{lc|std::binary_function}}. 

{{tt|std::binary_negate}} objects are easily constructed with helper function {{lc|std::not2}}.

===Member types===
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|first_argument_type}}|{{c|Predicate::first_argument_type}}}}
{{dsc|{{tt|second_argument_type}}|{{c|Predicate::second_argument_type}}}}
{{dsc|{{tt|result_type}}|{{c|bool}}}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc mem ctor|nolink=true|constructs a new binary_negate object with the supplied predicate}}
{{dsc mem fun|operator()|nolink=true|returns the logical complement of the result of a call to the stored predicate}}
{{dsc end}}

{{member|{{small|std::binary_negate::}}binary_negate|2=
{{dcl begin}}
{{dcl rev begin}}
{{dcl|until=c++14|
explicit binary_negate( Predicate const&amp; pred );
}}
{{dcl|since=c++14|
constexpr explicit binary_negate( Predicate const&amp; pred );
}}
{{dcl rev end}}
{{dcl end}}

Constructs a {{tt|std::binary_negate}} function object with the stored predicate {{c|pred}}.

===Parameters===
{{par begin}}
{{par|pred|predicate function object}}
{{par end}}
}}

{{member|{{small|std::binary_negate::}}operator()|2=
{{dcl begin}}
{{dcl rev begin}}
{{dcl|until=c++14|
bool operator()( first_argument_type const&amp; x,
                 second_argument_type const&amp; y ) const;
}}
{{dcl|since=c++14|
constexpr bool operator()( first_argument_type const&amp; x,
                           second_argument_type const&amp; y ) const;
}}
{{dcl rev end}}
{{dcl end}}

Returns the logical complement of the result of calling {{c|pred(x, y)}}.

===Parameters===
{{par begin}}
{{par|x|first argument to pass through to predicate}}
{{par|y|second argument to pass through to predicate}}
{{par end}}

===Return value===
The logical complement of the result of calling {{c|pred(x, y)}}.
}}

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cstddef&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct same : std::binary_function&lt;int, int, bool&gt;
{
    bool operator()(int a, int b) const { return a == b; }
};

int main()
{
    std::vector&lt;int&gt; v1;
    for (int i = 0; i &lt; 7; ++i)
        v1.push_back(i);

    std::vector&lt;int&gt; v2(v1.size());
    std::reverse_copy(v1.begin(), v1.end(), v2.begin());

    std::vector&lt;bool&gt; v3(v1.size());

    std::binary_negate&lt;same&gt; not_same((same()));

    // C++11 solution:
    // std::function&lt;bool (int, int)&gt; not_same =
    //     [](int x, int y) -&gt; bool { return !same()(x, y); };

    std::transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), not_same);

    std::cout.setf(std::ios_base::boolalpha);
    for (std::size_t i = 0; i != v1.size(); ++i)
        std::cout &lt;&lt; v1[i] &lt;&lt; " != " &lt;&lt; v2[i] &lt;&lt; " : " &lt;&lt; v3[i] &lt;&lt; '\n';
}
|output=
0 != 6 : true
1 != 5 : true
2 != 4 : true
3 != 3 : false
4 != 2 : true
5 != 1 : true
6 != 0 : true
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc binary_function}}
{{dsc inc|cpp/utility/functional/dsc function}}
{{dsc inc|cpp/utility/functional/dsc move_only_function}}
{{dsc inc|cpp/utility/functional/dsc not2}}
{{dsc inc|cpp/utility/functional/dsc ptr_fun}}
{{dsc inc|cpp/utility/functional/dsc unary_negate}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}