{{cpp/title|declval}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|utility}}
{{dcl rev multi
|since1=c++11|notes1={{mark|unevaluated-only}}|dcl1=
template&lt; class T &gt;
typename std::add_rvalue_reference&lt;T&gt;::type declval() noexcept;
|since2=c++14|notes2={{mark|unevaluated-only}}|dcl2=
template&lt; class T &gt;
std::add_rvalue_reference_t&lt;T&gt; declval() noexcept;
}}
{{dcl end}}

Helper template for writing expressions that appear in [[cpp/language/expressions#Potentially-evaluated expressions|unevaluated contexts]], typically the operand of [[cpp/language/decltype|{{tt|decltype}}]]. In unevaluated context, this helper template converts any type {{tt|T}} (which may be an incomplete type) to an expression of that type, making it possible to use member functions of T without the need to go through constructors.

{{tt|std::declval}} can only be used in [[cpp/language/expressions#Potentially-evaluated expressions|unevaluated contexts]] and is not required to be defined; it is an error to evaluate an expression that contains this function. Formally, the program is ill-formed if this function is [[cpp/language/definition#ODR-use|odr-used]].

===Parameters===
(none)

===Return value===
Cannot be evaluated and thus never returns a value. The return type is {{tt|T&amp;&amp;}} (reference collapsing rules apply) unless {{tt|T}} is (possibly cv-qualified) {{c/core|void}}, in which case the return type is {{tt|T}}.

===Notes===
{{tt|std::declval}} is commonly used in templates where acceptable template parameters may have no constructor in common, but have the same member function whose return type is needed.

===Possible implementation===
{{eq fun
|1=
template&lt;typename T&gt;
typename std::add_rvalue_reference&lt;T&gt;::type declval() noexcept
{
    static_assert(false, "declval not allowed in an evaluated context");
}
}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;utility&gt;

struct Default
{
    int foo() const { return 1; }
};

struct NonDefault
{
    NonDefault() = delete;
    int foo() const { return 1; }
};

int main()
{
    decltype(Default().foo())               n1 = 1;     // type of n1 is int
    decltype(std::declval&lt;Default&gt;().foo()) n2 = 1;     // same

//  decltype(NonDefault().foo())               n3 = n1; // error: no default constructor
    decltype(std::declval&lt;NonDefault&gt;().foo()) n3 = n1; // type of n3 is int

    std::cout &lt;&lt; "n1 = " &lt;&lt; n1 &lt;&lt; '\n'
              &lt;&lt; "n2 = " &lt;&lt; n2 &lt;&lt; '\n'
              &lt;&lt; "n3 = " &lt;&lt; n3 &lt;&lt; '\n';
}
|output=
n1 = 1
n2 = 1
n3 = 1
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc decltype}}
{{dsc inc|cpp/types/dsc result_of}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}