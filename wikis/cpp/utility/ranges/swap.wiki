{{cpp/ranges/title|swap}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|concepts}}
{{dcl|notes={{mark custpt}}|since=c++20|1=
namespace ranges {
    inline namespace /* unspecified */ {
        inline constexpr /* unspecified */ swap = /* unspecified */;
    }
}
}}
{{dcl h|Call signature}}
{{dcl|since=c++20|1=
template&lt; class T, class U &gt;
constexpr void ranges::swap( T&amp;&amp; t, U&amp;&amp; u ) noexcept(/* see below */);
}}
{{dcl end}}

Exchanges the values referenced by {{c|t}} and {{c|u}}. 

{{c|ranges::swap(t, u)}} is [[cpp/language/expressions#Expression-equivalence|expression-equivalent]] to:
# {{c|(void)swap(t, u)}}, if {{c|t}} or {{c|u}} has class or enumeration type, and that expression is valid, where the [[cpp/language/overload resolution|overload resolution]] is performed within namespace {{tt|std::ranges}} with the additional candidate {{c|1=template&lt;class T&gt; void swap(T&amp;, T&amp;) = delete; }}.
#* If the function selected by overload resolution does not exchange the values referenced by {{c|t}} and {{c|u}}, the program is ill-formed; no diagnostic required.
# Otherwise, {{c|(void)ranges::swap_ranges(t, u)}}, if {{c|t}} and {{c|u}} are lvalue arrays of equal extent (but possibly different element types) and {{c|ranges::swap(*t, *u)}} is a valid expression, except that {{c|noexcept((void)ranges::swap_ranges(t, u))}} is equal to {{c|noexcept(ranges::swap(*t, *u))}}.
# Otherwise, an expression which exchanges the referenced values of {{c|t}} and {{c|u}}, if they are both lvalues of the same type {{tt|V}} that models {{c|std::move_constructible&lt;V&gt;}} and {{c|std::assignable_from&lt;V&amp;, V&gt;}}.
#* The result of applying the [[cpp/language/noexcept|{{tt|noexcept}} operator]] to that expression is equal to {{c|std::is_nothrow_move_constructible_v&lt;V&gt; &amp;&amp; std::is_nothrow_move_assignable_v&lt;V&gt;}}.
#* That expression is a [[cpp/language/constant expression|constant expression]] if
#** {{tt|V}} is a {{named req|LiteralType}},
#** both {{c|1=t = std::move(u))}} and {{c|1=u = std::move(t)}} are [[cpp/language/constant expression#Constant subexpression|constant subexpressions]], and
#** the [[cpp/language/expressions#Full-expressions|full-expressions]] of the initializers in the following declarations are constant subexpressions:
#*** {{c|V v1(std::move(t));}}
#*** {{c|V v2(std::move(u));}}
# Otherwise, {{c|ranges::swap(t, u)}} is ill-formed, which can result in [[cpp/language/sfinae|substitution failure]] when {{c|ranges::swap(t, u)}} appears in the immediate context of a template instantiation.

{{cpp/ranges/cpo}}

===Example===
{{example
|code=
#include &lt;array&gt;
#include &lt;concepts&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;

void print(std::string_view name, 
           std::ranges::common_range auto const&amp; p, 
           std::ranges::common_range auto const&amp; q)
{
    std::cout &lt;&lt; name &lt;&lt; "1{ ";
    for (auto const&amp; i : p)
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; "}, " &lt;&lt; name &lt;&lt; "2{ ";
    for (auto const&amp; i : q)
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; "}\n";
}

void print(std::string_view name, int p, int q)
{
    std::cout &lt;&lt; name &lt;&lt; "1 = " &lt;&lt; p &lt;&lt; ", " &lt;&lt; name &lt;&lt; "2 = " &lt;&lt; q &lt;&lt; '\n';
}

struct IntLike
{
    int v;
};

void swap(IntLike&amp; lhs, int&amp; rhs)
{
    std::swap(lhs.v, rhs);
}

void swap(int&amp; lhs, IntLike&amp; rhs)
{
    std::swap(lhs, rhs.v);
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, IntLike i)
{
    return out &lt;&lt; i.v;
}

int main()
{
    std::vector a1{10, 11, 12}, a2{13, 14};
    std::ranges::swap(a1, a2);
    print("a", a1, a2);
    
    std::array b1{15, 16, 17}, b2{18, 19, 20};
    std::ranges::swap(b1, b2);
    print("b", b1, b2);
    
    // std::array c1{1, 2, 3}; std::array c2{4, 5};
    // std::ranges::swap(c1, c2); // error: no swap found by ADL
    
    int d1[]{21, 22, 23}, d2[]{24, 25, 26};
    std::ranges::swap(d1, d2);
    print("d", d1, d2);
    
    // int e1[]{1, 2, 3}, e2[]{4, 5};
    // std::ranges::swap(e1, e2); // error: extents mismatch
    
    // char f1[]{1, 2, 3};
    // int  f2[]{4, 5, 6};
    // std::ranges::swap(f1, f2); // error: no swap(*f1, *f2) found by ADL
    
    IntLike g1[]{1, 2, 3};
    int     g2[]{4, 5, 6};
    std::ranges::swap(g1, g2); // heterogeneous swap supported
    print("g", g1, g2);
    
    int h1{27}, h2{28};
    std::ranges::swap(h1, h2);
    print("h", h1, h2);
}
|output=
a1{ 13 14 }, a2{ 10 11 12 }
b1{ 18 19 20 }, b2{ 15 16 17 }
d1{ 24 25 26 }, d2{ 21 22 23 }
g1{ 4 5 6 }, g2{ 1 2 3 }
h1 = 28, h2 = 27
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/concepts/dsc swappable}}
{{dsc inc|cpp/algorithm/dsc swap}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}