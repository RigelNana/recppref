{{cpp/title|make_pair}}
{{cpp/utility/pair/navbar}}
{{dcl begin}}
{{dcl header|utility}}
{{dcl rev begin}}
{{dcl|until=c++11|
template&lt; class T1, class T2 &gt;
std::pair&lt;T1, T2&gt; make_pair( T1 x, T2 y );
}}
{{dcla|since=c++11|constexpr=c++14|until=c++20|
template&lt; class T1, class T2 &gt;
std::pair&lt;/*V1*/, /*V2*/&gt; make_pair( T1&amp;&amp; x, T2&amp;&amp; y );
}}
{{dcl|since=c++20|
template&lt; class T1, class T2 &gt;
constexpr std::pair&lt;std::unwrap_ref_decay_t&lt;T1&gt;,
                    std::unwrap_ref_decay_t&lt;T2&gt;&gt;
    make_pair( T1&amp;&amp; x, T2&amp;&amp; y );
}}
{{dcl rev end}}
{{dcl end}}

Creates a {{lc|std::pair}} object, deducing the target type from the types of arguments.

{{rrev|since=c++11|until=c++20|
Given types {{c/core|std::decay&lt;T1&gt;::type}} as {{tt|U1}} and {{c/core|std::decay&lt;T2&gt;::type}} as {{tt|U2}}, the types {{c/core|/*V1*/}} and {{c/core|/*V2*/}} are defined as follows:
* If {{tt|U1}} is {{c/core|std::reference_wrapper&lt;X&gt;}}, {{c/core|/*V1*/}} is {{tt|X&amp;}}; otherwise {{c/core|/*V1*/}} is {{tt|U1}}.
* If {{tt|U2}} is {{c/core|std::reference_wrapper&lt;Y&gt;}}, {{c/core|/*V2*/}} is {{tt|Y&amp;}}; otherwise {{c/core|/*V2*/}} is {{tt|U2}}.
}}

===Parameters===
{{par begin}}
{{par|x, y|the values to construct the pair from}}
{{par end}}

===Return value===
{{rev begin}}
{{rev|until=c++11|
{{c|std::pair&lt;T1, T2&gt;(x, y)}}
}}
{{rev|since=c++11|until=c++20|
{{c|std::pair&lt;/*V1*/, /*V2*/&gt;(std::forward&lt;T1&gt;(x), std::forward&lt;T2&gt;(y))}}
}}
{{rev|since=c++20|
{{c multi|std::pair&lt;std::unwrap_ref_decay_t&lt;T1&gt;, std::unwrap_ref_decay_t&lt;T2&gt;&gt;|    (std::forward&lt;T1&gt;(x), std::forward&lt;T2&gt;(y))}}
}}
{{rev end}}

===Example===
{{example
|code=
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;

int main()
{
    int n = 1;
    int a[5] = {1, 2, 3, 4, 5};
    
    // build a pair from two ints
    auto p1 = std::make_pair(n, a[1]);
    std::cout &lt;&lt; "The value of p1 is "
              &lt;&lt; '(' &lt;&lt; p1.first &lt;&lt; ", " &lt;&lt; p1.second &lt;&lt; ")\n";
    
    // build a pair from a reference to int and an array (decayed to pointer)
    auto p2 = std::make_pair(std::ref(n), a);
    n = 7;
    std::cout &lt;&lt; "The value of p2 is "
              &lt;&lt; '(' &lt;&lt; p2.first &lt;&lt; ", " &lt;&lt; *(p2.second + 2) &lt;&lt; ")\n";
}
|output=
The value of p1 is (1, 2)
The value of p2 is (7, 3)
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=181|std=C++98|before=the parameter types were const-reference&lt;br&gt;types, which made passing arrays impossible|after=changed these&lt;br&gt;types to value types}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}