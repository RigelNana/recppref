{{cpp/utility/pair/title|pair}}
{{cpp/utility/pair/navbar}}
{{dcl begin}}
{{dcla|num=1|constexpr=c++11|notes={{mark|conditionally explicit since C++11}}|1=
pair();
}}
{{dcl|num=2|notes={{mark|conditionally explicit since C++11}}&lt;br&gt;{{mark constexpr since c++14}}|1=
pair( const T1&amp; x, const T2&amp; y );
}}
{{dcl rev multi|num=3 
|since1=c++11|notes1={{mark constexpr since c++14}}&lt;br&gt;{{mark|conditionally explicit}}|dcl1=
template&lt; class U1, class U2 &gt;
pair( U1&amp;&amp; x, U2&amp;&amp; y );
|since2=c++23|notes2={{mark|conditionally explicit}}|dcl2=
template&lt; class U1 = T1, class U2 = T2 &gt;
constexpr pair( U1&amp;&amp; x, U2&amp;&amp; y );
}}
{{dcl|num=4|since=c++23|notes={{mark|conditionally explicit}}|
template&lt; class U1, class U2 &gt;
constexpr pair( pair&lt;U1, U2&gt;&amp; p );
}}
{{dcl|num=5|notes={{mark|conditionally explicit since C++11}}&lt;br&gt;{{mark constexpr since c++14}}|
template&lt; class U1, class U2 &gt;
pair( const pair&lt;U1, U2&gt;&amp; p );
}}
{{dcla|num=6|constexpr=c++14|notes={{mark|conditionally explicit since C++11}}|
template&lt; class U1, class U2 &gt;
pair( pair&lt;U1, U2&gt;&amp;&amp; p );
}}
{{dcl|num=7|since=c++23|notes={{mark|conditionally explicit}}|
template&lt; class U1, class U2 &gt;
constexpr pair( const pair&lt;U1, U2&gt;&amp;&amp; p );
}}
{{dcl|num=8|since=c++23|notes={{mark|conditionally explicit}}|
template&lt; pair-like P &gt;
constexpr pair ( P&amp;&amp; u );
}}
{{dcla|num=9|since=c++11|constexpr=c++20|
template&lt; class... Args1, class... Args2 &gt;
pair( std::piecewise_construct_t,
      std::tuple&lt;Args1...&gt; first_args,
      std::tuple&lt;Args2...&gt; second_args );
}}
{{dcl|num=10|1=
pair( const pair&amp; p ) = default;
}}
{{dcl|num=11|since=c++11|1=
pair( pair&amp;&amp; p ) = default;
}}
{{dcl end}}

Constructs a new pair.

@1@ Default constructor. Value-initializes both elements of the pair, {{tt|first}} and {{tt|second}}.
{{rrev|since=c++11|
This constructor participates in overload resolution if and only if {{c|std::is_default_constructible_v&lt;T1&gt;}} and {{c|std::is_default_constructible_v&lt;T2&gt;}} are both {{c|true}}.

This constructor is {{c/core|explicit}} if and only if either {{tt|T1}} or {{tt|T2}} is not implicitly default-constructible.
}}

@2@ Initializes {{tt|first}} with {{c|x}} and {{tt|second}} with {{c|y}}. 
{{rrev|since=c++11|
This constructor participates in overload resolution if and only if {{c|std::is_copy_constructible_v&lt;T1&gt;}} and {{c|std::is_copy_constructible_v&lt;T2&gt;}} are both {{c|true}}.

This constructor is {{c/core|explicit}} if and only if {{c|std::is_convertible_v&lt;const T1&amp;, T1&gt;}} is {{c|false}} or {{c|std::is_convertible_v&lt;const T2&amp;, T2&gt;}} is {{c|false}}.}}

@3@ Initializes {{tt|first}} with {{c|std::forward&lt;U1&gt;(x)}} and {{tt|second}} with {{c|std::forward&lt;U2&gt;(y)}}. 
@@ This constructor participates in overload resolution if and only if  {{c|std::is_constructible_v&lt;T1, U1&gt;}} and {{c|std::is_constructible_v&lt;T2, U2&gt;}} are both {{c|true}}.
@@ This constructor is {{c/core|explicit}} if and only if {{c|std::is_convertible_v&lt;U1, T1&gt;}} is {{c|false}} or {{c|std::is_convertible_v&lt;U2, T2&gt;}} is {{c|false}}.
{{rrev|since=c++23|
This constructor is defined as deleted if the initialization of {{tt|first}} or {{tt|second}} would [[cpp/language/reference initialization#Lifetime of a temporary object|bind a reference to temporary object]].
}}

@4@ Initializes {{tt|first}} with {{c|p.first}} and {{tt|second}} with {{c|p.second}}.
@@ This constructor participates in overload resolution if and only if  {{c|std::is_constructible_v&lt;T1, U1&amp;&gt;}} and {{c|std::is_constructible_v&lt;T2, U2&amp;&gt;}} are both {{c|true}}.
@@ This constructor is {{c/core|explicit}} if and only if {{c|std::is_convertible_v&lt;U1&amp;, T1&gt;}} is {{c|false}} or {{c|std::is_convertible_v&lt;U2&amp;, T2&gt;}} is {{c|false}}.
@@ This constructor is defined as deleted if the initialization of {{tt|first}} or {{tt|second}} would bind a reference to temporary object.

@5@ Initializes {{tt|first}} with {{c|p.first}} and {{tt|second}} with {{c|p.second}}.
{{rrev|since=c++11|
This constructor participates in overload resolution if and only if  {{c|std::is_constructible_v&lt;T1, const U1&amp;&gt;}} and {{c|std::is_constructible_v&lt;T2, const U2&amp;&gt;}} are both {{c|true}}.

This constructor is {{c/core|explicit}} if and only if {{c|std::is_convertible_v&lt;const U1&amp;, T1&gt;}} is {{c|false}} or {{c|std::is_convertible_v&lt;const U2&amp;, T2&gt;}} is {{c|false}}.
}}
{{rrev|since=c++23|
This constructor is defined as deleted if the initialization of {{tt|first}} or {{tt|second}} would bind a reference to temporary object.
}}

@6@ Initializes {{tt|first}} with {{c|std::forward&lt;U1&gt;(p.first)}} and {{tt|second}} with {{c|std::forward&lt;U2&gt;(p.second)}}.
@@ This constructor participates in overload resolution if and only if  {{c|std::is_constructible_v&lt;T1, U1&gt;}} and {{c|std::is_constructible_v&lt;T2, U2&gt;}} are both {{c|true}}.
@@ This constructor is {{c/core|explicit}} if and only if {{c|std::is_convertible_v&lt;U1, T1&gt;}} is {{c|false}} or {{c|std::is_convertible_v&lt;U2, T2&gt;}} is {{c|false}}.
{{rrev|since=c++23|
This constructor is defined as deleted if the initialization of {{tt|first}} or {{tt|second}} would bind a reference to temporary object.
}}

@7@ Initializes {{tt|first}} with {{c|std::forward&lt;const U1&gt;(p.first)}} and {{tt|second}} with {{c|std::forward&lt;const U2&gt;(p.second)}}.
@@ This constructor participates in overload resolution if and only if  {{c|std::is_constructible_v&lt;T1, U1&gt;}} and {{c|std::is_constructible_v&lt;T2, U2&gt;}} are both {{c|true}}.
@@ This constructor is {{c/core|explicit}} if and only if {{c|std::is_convertible_v&lt;const U1, T1&gt;}} is {{c|false}} or {{c|std::is_convertible_v&lt;const U2, T2&gt;}} is {{c|false}}.
@@ This constructor is defined as deleted if the initialization of {{tt|first}} or {{tt|second}} would bind a reference to temporary object.

@8@ Given {{c|u1}} as {{c|std::get&lt;0&gt;(std::forward(u))}} and {{c|u2}} as {{c|std::get&lt;1&gt;(std::forward(u))}}, denote their types as {{tt|U1}} and {{tt|U2}} respectively. Initializes {{tt|first}} with {{c|u1}} and {{tt|second}} with {{c|u2}}.
@@ This constructor participates in overload resolution if and only if
* {{c/core|std::remove_cvref(P)}} is not a specialization of {{lc|std::ranges::subrange}},
* {{c|std::is_constructible_v&lt;T1, U1&gt;}} is {{c|true}}, and
* {{c|std::is_constructible_v&lt;T2, U2}} is {{c|true}}. 
@@ This constructor is {{c/core|explicit}} if and only if {{c|std::is_convertible_v&lt;U1, T1&gt;}} is {{c|false}} or {{c|std::is_convertible_v&lt;U2, T2&gt;}} is {{c|false}}.
@@ This constructor is defined as deleted if the initialization of {{tt|first}} or {{tt|second}} would bind a reference to temporary object.

@9@ Forwards the elements of {{c|first_args}} to the constructor of {{tt|first}} and forwards the elements of {{c|second_args}} to the constructor of {{tt|second}}. This is the only non-default constructor that can be used to create a pair of non-copyable non-movable types. The program is ill-formed if {{tt|first}} or {{tt|second}} is a reference and bound to a temporary object.

@10@ Copy constructor is {{rev inl|until=c++11|implicitly declared}}{{rev inl|since=c++11|defaulted, and is {{c/core|constexpr}} if copying of both elements satisfies the requirements on constexpr functions}}.

@11@ Move constructor is defaulted, and is {{c/core|constexpr}} if moving of both elements satisfies the requirements on constexpr functions.

===Parameters===
{{par begin}}
{{par|x|value to initialize the first element of this pair}}
{{par|y|value to initialize the second element of this pair}}
{{par|p|pair of values used to initialize both elements of this pair}}
{{par|u|{{lti|cpp/utility/tuple/tuple-like|pair-like}} object of values used to initialize both elements of this pair}}
{{par|first_args|tuple of constructor arguments to initialize the first element of this pair}}
{{par|second_args|tuple of constructor arguments to initialize the second element of this pair}}
{{par end}} 

===Exceptions===
Does not throw exceptions unless one of the specified operations (e.g. constructor of an element) throws.

===Example===
{{example
|code=
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;utility&gt;

int main()
{
    auto print = [](auto rem, auto const&amp; pair)
    {
        std::cout &lt;&lt; rem &lt;&lt; "(" &lt;&lt; pair.first &lt;&lt; ", " &lt;&lt; pair.second &lt;&lt; ")\n";
    };
    
    std::pair&lt;int, float&gt; p1;
    print("(1) Value-initialized: ", p1);
    
    std::pair&lt;int, double&gt; p2{42, 3.1415};
    print("(2) Initialized with two values: ", p2);
    
    std::pair&lt;char, int&gt; p4{p2};
    print("(4) Implicitly converted: ", p4);
    
    std::pair&lt;std::complex&lt;double&gt;, std::string&gt; p6
        {std::piecewise_construct, std::forward_as_tuple(0.123, 7.7),
            std::forward_as_tuple(10, 'a')};
    print("(8) Piecewise constructed: ", p6);
}
|p=true
|output=
(1) Value-initialized: (0, 0)
(2) Initialized with two values: (42, 3.1415)
(4) Implicitly converted: (*, 3)
(8) Piecewise constructed: ((0.123,7.7), aaaaaaaaaa)
}}

===Defect reports===
{{dr list begin}}
{{dr list item|dr=265|wg=lwg|std=C++98|before=the default constructor copy-initialized {{tt|first}}&lt;br&gt;and {{tt|second}} with {{c|T1()}} and {{c|T2()}} respectively&lt;br&gt;(thus required {{tt|T1}} and {{tt|T2}} to be {{named req|CopyConstructible}})|after={{tt|first}} and {{tt|second}}&lt;br&gt;are value-initialized}}
{{dr list item|dr=2510|wg=lwg|std=C++11|before=the default constructor was implicit|after=made conditionally-explicit}}
{{dr list item|paper=N4387|std=C++11|before=some constructors were implicit-only, preventing some uses|after=constructors made conditionally-explicit}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/pair/dsc make_pair}}
{{dsc inc|cpp/utility/tuple/dsc constructor}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}