{{title|1=operator==,!=,&lt;,&lt;=,&gt;,&gt;=,&lt;=&gt;&lt;small&gt;(std::pair)&lt;/small&gt;}}
{{cpp/utility/pair/navbar}}
{{dcl begin}}
{{dcl header|utility}}
{{dcl rev multi|num=1
|until1=c++14|dcl1=
template&lt; class T1, class T2, class U1, class U2 &gt;
bool operator==( const std::pair&lt;T1, T2&gt;&amp; lhs, const std::pair&lt;U1, U2&gt;&amp; rhs );
|dcl2=
template&lt; class T1, class T2, class U1, class U2 &gt;
constexpr bool operator==( const std::pair&lt;T1, T2&gt;&amp; lhs,
                           const std::pair&lt;U1, U2&gt;&amp; rhs );
}}
{{dcl rev multi|num=2
|until1=c++14|dcl1=
template&lt; class T1, class T2, class U1, class U2 &gt;
bool operator!=( const std::pair&lt;T1, T2&gt;&amp; lhs, const std::pair&lt;U1, U2&gt;&amp; rhs );
|until2=c++20|dcl2=
template&lt; class T1, class T2, class U1, class U2 &gt;
constexpr bool operator!=( const std::pair&lt;T1, T2&gt;&amp; lhs,
                           const std::pair&lt;U1, U2&gt;&amp; rhs );
}}
{{dcl rev multi|num=3
|until1=c++14|dcl1=
template&lt; class T1, class T2, class U1, class U2 &gt;
bool operator&lt;( const std::pair&lt;T1, T2&gt;&amp; lhs, const std::pair&lt;U1, U2&gt;&amp; rhs );
|until2=c++20|dcl2=
template&lt; class T1, class T2, class U1, class U2 &gt;
constexpr bool operator&lt;( const std::pair&lt;T1, T2&gt;&amp; lhs,
                          const std::pair&lt;U1, U2&gt;&amp; rhs );
}}
{{dcl rev multi|num=4
|until1=c++14|dcl1=
template&lt; class T1, class T2, class U1, class U2 &gt;
bool operator&lt;=( const std::pair&lt;T1, T2&gt;&amp; lhs, const std::pair&lt;U1, U2&gt;&amp; rhs );
|until2=c++20|dcl2=
template&lt; class T1, class T2, class U1, class U2 &gt;
constexpr bool operator&lt;=( const std::pair&lt;T1, T2&gt;&amp; lhs,
                           const std::pair&lt;U1, U2&gt;&amp; rhs );
}}
{{dcl rev multi|num=5
|until1=c++14|dcl1=
template&lt; class T1, class T2, class U1, class U2 &gt;
bool operator&gt;( const std::pair&lt;T1, T2&gt;&amp; lhs, const std::pair&lt;U1, U2&gt;&amp; rhs );
|until2=c++20|dcl2=
template&lt; class T1, class T2, class U1, class U2 &gt;
constexpr bool operator&gt;( const std::pair&lt;T1, T2&gt;&amp; lhs,
                          const std::pair&lt;U1, U2&gt;&amp; rhs );
}}
{{dcl rev multi|num=6
|until1=c++14|dcl1=
template&lt; class T1, class T2, class U1, class U2 &gt;
bool operator&gt;=( const std::pair&lt;T1, T2&gt;&amp; lhs, const std::pair&lt;U1, U2&gt;&amp; rhs );
|until2=c++20|dcl2=
template&lt; class T1, class T2, class U1, class U2 &gt;
constexpr bool operator&gt;=( const std::pair&lt;T1, T2&gt;&amp; lhs,
                           const std::pair&lt;U1, U2&gt;&amp; rhs );
}}
{{dcl|num=7|since=c++20|1=
template&lt; class T1, class T2, class U1, class U2 &gt;
constexpr std::common_comparison_category_t&lt;synth-three-way-result&lt;T1, U1&gt;,
                                            synth-three-way-result&lt;T2, U2&gt;&gt;
    operator&lt;=&gt;( const std::pair&lt;T1, T2&gt;&amp; lhs, const std::pair&lt;U1, U2&gt;&amp; rhs );
}}
{{dcl end}}

@1,2@ Tests if both elements of {{c|lhs}} and {{c|rhs}} are equal, that is, compares {{c|lhs.first}} with {{c|rhs.first}} and {{c|lhs.second}} with {{c|rhs.second}}.&lt;br&gt;&lt;!--
--&gt;{{rrev multi|rev1=
The behavior is undefined if the type and value category of either {{c|1=lhs.first == rhs.first}} or {{c|1=lhs.second == rhs.second}} do not meet the {{named req|BooleanTestable}} requirements.
|since2=c++26|rev2=
{{cpp/enable_if|both {{c|1=decltype(lhs.first == rhs.first)}} and {{c|1=decltype(lhs.second == rhs.second)}} model {{lconcept|boolean-testable}}}}.
}}

@3-6@ Compares {{c|lhs}} and {{c|rhs}} lexicographically by {{c/core|operator&lt;}}, that is, compares the first elements and only if they are equivalent, compares the second elements. The behavior is undefined if the type and value category of any of {{c|1=lhs.first &lt; rhs.first}}, {{c|1=rhs.first &lt; lhs.first}}, or {{c|1=lhs.second &lt; rhs.second}} do not meet the {{named req|BooleanTestable}} requirements.

@7@ Compares {{c|lhs}} and {{c|rhs}} lexicographically by {{lti|cpp/standard library/synth-three-way}}, that is, compares the first elements and only if they are equivalent, compares the second elements. {{lti|cpp/standard library/synth-three-way|synth-three-way-result}} is the return type of {{tti|synth-three-way}}.

{{rrev|since=c++20|
{{cpp/note synthesized compare}}
}}

===Parameters===
{{par begin}}
{{par|lhs, rhs|pairs to compare}}
{{par end}} 

===Return value===
@1@ {{c|true}} if both {{c|1=lhs.first == rhs.first}} and {{c|1=lhs.second == rhs.second}}, otherwise {{c|false}}.

@2@ {{c|1=!(lhs == rhs)}}

@3@ If {{c|lhs.first &lt; rhs.first}}, returns {{c|true}}. Otherwise, if {{c|rhs.first &lt; lhs.first}}, returns {{c|false}}. Otherwise, if {{c|lhs.second &lt; rhs.second}}, returns {{c|true}}. Otherwise, returns {{c|false}}.

@4@ {{c|!(rhs &lt; lhs)}}

@5@ {{c|rhs &lt; lhs}}

@6@ {{c|!(lhs &lt; rhs)}}

@7@ {{box|{{lti|cpp/standard library/synth-three-way}}{{c/core|(lhs.first, rhs.first)}}}} if it is not equal to {{c|0}}, otherwise {{box|{{lti|cpp/standard library/synth-three-way}}{{c/core|(lhs.second, rhs.second)}}}}.

===Notes===
{{rrev multi|rev1=
The relational operators are defined in terms of each element's {{c/core|operator&lt;}}.
|since2=c++20|rev2=
The relational operators are defined in terms of {{lti|cpp/standard library/synth-three-way}}, which uses {{c/core|1=operator&lt;=&gt;}} if possible, or {{c/core|operator&lt;}} otherwise.

Notably, if an element type does not itself provide {{c/core|1=operator&lt;=&gt;}}, but is implicitly convertible to a three-way comparable type, that conversion will be used instead of {{c/core|operator&lt;}}.
}}

{{feature test macro|__cpp_lib_constrained_equality|Constrained {{c/core|1=operator==}} for {{lc|std::pair}}|value=202403L|std=C++26}}

===Example===
{{example
|Because {{c/core|operator&lt;}} is defined for pairs, containers of pairs can be sorted.
|code=
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;std::pair&lt;int, std::string&gt;&gt; v = {&lt;!----&gt;{2, "baz"}, {2, "bar"}, {1, "foo"}&lt;!----&gt;};
    std::sort(v.begin(), v.end());
    
    for (auto p : v)
        std::cout &lt;&lt; '{' &lt;&lt; p.first &lt;&lt; ", " &lt;&lt; std::quoted(p.second) &lt;&lt; "}\n";
}
|output=
{1, "foo"}
{2, "bar"}
{2, "baz"}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=296|std=C++98|before=the descriptions of operators other than {{tt|1===}} and {{tt|&lt;}} were missing|after=added}}
{{dr list item|wg=lwg|dr=2114|paper=P2167R3|std=C++98|before=type preconditions for boolean operations were missing|after=added}}
{{dr list item|wg=lwg|dr=3865|std=C++98|before=comparison operators only accepted {{tt|pair}}s of the same type|after=accept {{tt|pair}}s of different types}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc operator_cmp}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}