{{cpp/title|tuple_element&lt;small&gt;&lt;std::pair&gt;&lt;/small&gt;}}
{{cpp/utility/pair/navbar}}
{{dcl begin}}
{{dcl header|utility}}
{{dcl|since=c++11|
template&lt; std::size_t I, class T1, class T2 &gt;
struct tuple_element&lt;I, std::pair&lt;T1, T2&gt;&gt;;
}}
{{dcl end}}

The partial specializations of {{c|std::tuple_element}} for pairs provide compile-time access to the types of the pair's elements, using tuple-like syntax. The program is ill-formed if {{tt|1=I &gt;= 2}}.

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc|{{tt|type}}|{{tt|T1}} if {{tt|1=I == 0}}&lt;br&gt;{{tt|T2}} if {{tt|1=I == 1}}}}
{{dsc end}}

===Possible implementation===
{{eq fun
|1=
template&lt;std::size_t I, typename T&gt;
struct tuple_element;

template&lt;std::size_t I, typename T1, typename T2&gt;
struct tuple_element&lt;I, std::pair&lt;T1, T2&gt;&gt;
{
    static_assert(I &lt; 2, "std::pair has only 2 elements!");
};

template&lt;typename T1, typename T2&gt;
struct tuple_element&lt;0, std::pair&lt;T1, T2&gt;&gt;
{
    using type = T1;
};

template&lt;typename T1, typename T2&gt;
struct tuple_element&lt;1, std::pair&lt;T1, T2&gt;&gt;
{
    using type = T2;
};
}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

namespace detail
{
    template&lt;std::size_t&gt;
    struct index_tag { constexpr explicit index_tag() = default; };

    template&lt;class T, class U&gt;
    constexpr T get_val_dispatch(std::pair&lt;T, U&gt; const&amp; pair, index_tag&lt;0&gt;)
    {
        return pair.first;
    }

    template&lt;class T, class U&gt;
    constexpr U get_val_dispatch(std::pair&lt;T, U&gt; const&amp; pair, index_tag&lt;1&gt;)
    {
        return pair.second;
    }
} // namespace detail

template&lt;std::size_t N, class T, class U&gt;
auto constexpr get_val(std::pair&lt;T, U&gt; const&amp; pair)
    -&gt; typename std::tuple_element&lt;N, std::pair&lt;T, U&gt;&gt;::type
{
    return detail::get_val_dispatch(pair, detail::index_tag&lt;N&gt;{});
}

int main()
{
    auto var = std::make_pair(1, std::string{"one"});
    
    std::cout &lt;&lt; get_val&lt;0&gt;(var) &lt;&lt; " = " &lt;&lt; get_val&lt;1&gt;(var);
}
|output=1 = one
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2974|std=c++11|before=out-of-bounds index referred the undefined primary template|after=made ill-formed (hard error)}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc structured binding}}
{{dsc inc|cpp/utility/tuple/dsc tuple_element}}
{{dsc inc|cpp/container/array/dsc tuple_element}}
{{dsc inc|cpp/ranges/subrange/dsc tuple_element}}
{{dsc inc|cpp/utility/pair/dsc tuple_size}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}