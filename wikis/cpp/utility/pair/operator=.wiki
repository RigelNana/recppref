{{cpp/utility/pair/title|operator{{=}}}}
{{cpp/utility/pair/navbar}}
{{dcl begin}}
{{dcl rev multi|num=1|dcl1=
pair&amp; operator=( const pair&amp; other );
|since2=c++20|dcl2=
constexpr pair&amp; operator=( const pair&amp; other );
}}
{{dcl|num=2
|since=c++23|1=
constexpr const pair&amp; operator=( const pair&amp; other ) const;
}}
{{dcl rev multi|num=3
|dcl1=
template&lt; class U1, class U2 &gt;
pair&amp; operator=( const pair&lt;U1, U2&gt;&amp; other );
|since2=c++20|dcl2=
template&lt; class U1, class U2 &gt;
constexpr pair&amp; operator=( const pair&lt;U1, U2&gt;&amp; other );
}}
{{dcl|num=4
|since=c++23|1=
template&lt; class U1, class U2 &gt;
constexpr const pair&amp; operator=( const pair&lt;U1, U2&gt;&amp; other ) const;
}}
{{dcl rev multi|num=5
|since1=c++11|dcl1=
pair&amp; operator=( pair&amp;&amp; other ) noexcept(/* see below */);
|since2=c++20|dcl2=
constexpr pair&amp; operator=( pair&amp;&amp; other ) noexcept(/* see below */);
}}
{{dcl|num=6
|since=c++23|1=
constexpr const pair&amp; operator=( pair&amp;&amp; other ) const;
}}
{{dcl rev multi|num=7|since1=c++11|dcl1=
template&lt; class U1, class U2 &gt;
pair&amp; operator=( pair&lt;U1, U2&gt;&amp;&amp; p );
|since2=c++20|dcl2=
template&lt; class U1, class U2 &gt;
constexpr pair&amp; operator=( pair&lt;U1, U2&gt;&amp;&amp; p );
}}
{{dcl|num=8
|since=c++23|1=
template&lt; class U1, class U2 &gt;
constexpr const pair&amp; operator=( pair&lt;U1, U2&gt;&amp;&amp; p ) const;
}}
{{dcl|num=9|since=c++23|1=
template&lt; pair-like P &gt;
constexpr pair&amp; operator=( P&amp;&amp; u );
}}
{{dcl|num=10|since=c++23|1=
template&lt; pair-like P &gt;
constexpr const pair&amp; operator=( P&amp;&amp; u ) const;
}}
{{dcl end}}

Replaces the contents of the pair.

@1@ Copy assignment operator. Replaces the contents with a copy of the contents of {{c|other}}.
{{rrev multi|until1=c++11|rev1=
The assignment operator is implicitly declared. Using this assignment operator makes the program ill-formed if either {{tt|T1}} or {{tt|T2}} is a const-qualified type, or a reference type, or a class type with an inaccessible copy assignment operator, or an array type of such class.
|rev2=
This overload is defined as deleted if either {{c|std::is_copy_assignable&lt;T1&gt;::value}} or {{c|std::is_copy_assignable&lt;T2&gt;::value}} is {{c|false}}.
}}

@2@ Copy assignment operator for const-qualified operand.
@@ {{cpp/enable if|{{c|std::is_copy_assignable_v&lt;const T1&gt;}} and {{c|std::is_copy_assignable_v&lt;const T2&gt;}} are both {{c|true}}}}.

@3@ Assigns {{c|other.first}} to {{tt|first}} and {{c|other.second}} to {{tt|second}}.
{{rrev|since=c++11|
{{cpp/enable if|{{c|std::is_assignable&lt;T1&amp;, const U1&amp;&gt;::value}} and {{c|std::is_assignable&lt;T2&amp;, const U2&amp;&gt;::value}} are both {{c|true}}}}.
}}

@4@ Assigns {{c|other.first}} to {{tt|first}} and {{c|other.second}} to {{tt|second}}.
@@ {{cpp/enable if|{{c|std::is_assignable_v&lt;const T1&amp;, const U1&amp;&gt;}} and {{c|std::is_assignable_v&lt;const T2&amp;, const U2&amp;&gt;}} are both {{c|true}}}}.

@5@ Move assignment operator. Replaces the contents with those of {{c|other}} using move semantics.
@@ {{cpp/enable if|{{c|std::is_move_assignable&lt;T1&gt;::value}} and {{c|std::is_move_assignable&lt;T2&gt;::value}} are both {{c|true}}}}.

@6@ Move assignment operator for const-qualified operand.
@@ {{cpp/enable if|{{c|std::is_assignable_v&lt;const T1&amp;, T1&gt;}} and {{c|std::is_assignable_v&lt;const T2&amp;, T2&gt;}} are both {{c|true}}}}.

@7@ Assigns {{c|std::forward&lt;U1&gt;(p.first)}} to {{tt|first}} and {{c|std::forward&lt;U2&gt;(p.second)}} to {{tt|second}}.
@@ {{cpp/enable if|{{c|std::is_assignable&lt;T1&amp;, U1&gt;::value}} and {{c|std::is_assignable&lt;T2&amp;, U2&gt;::value}} are both {{c|true}}}}.

@8@ Assigns {{c|std::forward&lt;U1&gt;(p.first)}} to {{tt|first}} and {{c|std::forward&lt;U2&gt;(p.second)}} to {{tt|second}}.
@@ {{cpp/enable if|{{c|std::is_assignable_v&lt;const T1&amp;, U1&gt;}} and {{c|std::is_assignable_v&lt;const T2&amp;, U2&gt;}} are both {{c|true}}}}.

@9@ Assigns {{c|std::get&lt;0&gt;(std::forward&lt;P&gt;(u))}} to {{tt|first}} and {{c|std::get&lt;1&gt;(std::forward&lt;P&gt;(u))}} to {{tt|second}}.
@@ {{cpp/enable if|
* {{c|std::same_as&lt;std::remove_cvref_t&lt;P&gt;, std::pair&gt;}} is {{c|false}},
* {{c/core|std::remove_cvref_t&lt;P&gt;}} is not a specialization of {{lc|std::ranges::subrange}},
* {{c|std::is_assignable_v&lt;T1&amp;, decltype(std::get&lt;0&gt;(std::forward&lt;P&gt;(p)))&gt;}} is {{c|true}}, and
* {{c|std::is_assignable_v&lt;T1&amp;, decltype(std::get&lt;1&gt;(std::forward&lt;P&gt;(p)))&gt;}} is {{c|true}}.}}

@10@ Assigns {{c|std::get&lt;0&gt;(std::forward&lt;P&gt;(u))}} to {{tt|first}} and {{c|std::get&lt;1&gt;(std::forward&lt;P&gt;(u))}} to {{tt|second}}.
@@ {{cpp/enable if|
* {{c|std::same_as&lt;std::remove_cvref_t&lt;P&gt;, std::pair&gt;}} is {{c|false}},
* {{c/core|std::remove_cvref_t&lt;P&gt;}} is not a specialization of {{lc|std::ranges::subrange}},
* {{c|std::is_assignable_v&lt;const T1&amp;, decltype(std::get&lt;0&gt;(std::forward&lt;P&gt;(p)))&gt;}} is {{c|true}}, and
* {{c|std::is_assignable_v&lt;const T1&amp;, decltype(std::get&lt;1&gt;(std::forward&lt;P&gt;(p)))&gt;}} is {{c|true}}.}}

===Parameters===
{{par begin}}
{{par|other|pair of values to replace the contents of this pair}}
{{par|p|pair of values of possibly different types to replace the contents of this pair}}
{{par|u|{{lti|cpp/utility/tuple/tuple-like|pair-like}} object of values to replace the contents of this pair}}
{{par hreq}}
{{par req|{{tt|T1}} must meet the requirements of {{named req|CopyAssignable}} from {{tt|U1}}. {{mark until c++11}}}}
{{par req|{{tt|T2}} must meet the requirements of {{named req|CopyAssignable}} from {{tt|U2}}. {{mark until c++11}}}}
{{par end}}

===Return value===
{{c|*this}}

===Exceptions===
@1-4@ {{cpp/impldef exception item}}
@5@{{noexcept|
    std::is_nothrow_move_assignable&lt;T1&gt;::value &amp;&amp;
    std::is_nothrow_move_assignable&lt;T2&gt;::value
}}
@6-10@ {{cpp/impldef exception item}}

===Example===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template&lt;class Os, class T&gt;
Os&amp; operator&lt;&lt;(Os&amp; os, const std::vector&lt;T&gt;&amp; v)
{
    os &lt;&lt; '{';
    for (std::size_t t = 0; t != v.size(); ++t)
        os &lt;&lt; v[t] &lt;&lt; (t + 1 &lt; v.size() ? ", " : "");
    return os &lt;&lt; '}';
}

template&lt;class Os, class U1, class U2&gt;
Os&amp; operator&lt;&lt;(Os&amp; os, const std::pair&lt;U1, U2&gt;&amp; pair)
{
    return os &lt;&lt; '{' &lt;&lt; pair.first &lt;&lt; ", " &lt;&lt; pair.second &lt;&lt; '}';
}

int main()
{
    std::pair&lt;int, std::vector&lt;int&gt;&gt; p{1, {2}&lt;!----&gt;}, q{2, {5, 6}&lt;!----&gt;};
    
    p = q; // (1) operator=(const pair&amp; other);
    std::cout &lt;&lt; std::setw(23) &lt;&lt; std::left
              &lt;&lt; "(1) p = q;"
              &lt;&lt; "p: " &lt;&lt; p &lt;&lt; "     q: " &lt;&lt; q &lt;&lt; '\n';
    
    std::pair&lt;short, std::vector&lt;int&gt;&gt; r{4, {7, 8, 9}&lt;!----&gt;};
    p = r; // (3) operator=(const pair&lt;U1, U2&gt;&amp; other);
    std::cout &lt;&lt; std::setw(23)
              &lt;&lt; "(3) p = r;"
              &lt;&lt; "p: " &lt;&lt; p &lt;&lt; "  r: " &lt;&lt; r &lt;&lt; '\n';
    
    p = std::pair&lt;int, std::vector&lt;int&gt;&gt;{3, {4}&lt;!----&gt;};
    p = std::move(q); // (5) operator=(pair&amp;&amp; other);
    std::cout &lt;&lt; std::setw(23)
              &lt;&lt; "(5) p = std::move(q);"
              &lt;&lt; "p: " &lt;&lt; p &lt;&lt; "     q: " &lt;&lt; q &lt;&lt; '\n';
    
    p = std::pair&lt;int, std::vector&lt;int&gt;&gt;{5, {6}&lt;!----&gt;};
    p = std::move(r); // (7) operator=(pair&lt;U1, U2&gt;&amp;&amp; other);
    std::cout &lt;&lt; std::setw(23)
              &lt;&lt; "(7) p = std::move(r);"
              &lt;&lt; "p: " &lt;&lt; p &lt;&lt; "  r: " &lt;&lt; r &lt;&lt; '\n';
}
|output=
&lt;nowiki&gt;
(1) p = q;             p: {2, {5, 6}}     q: {2, {5, 6}}
(3) p = r;             p: {4, {7, 8, 9}}  r: {4, {7, 8, 9}}
(5) p = std::move(q);  p: {2, {5, 6}}     q: {2, {}}
(7) p = std::move(r);  p: {4, {7, 8, 9}}  r: {4, {}}
&lt;/nowiki&gt;
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=885|std=C++98|before=missing heterogeneous copy assignment|after=added (as overload {{v|3}})}}
{{dr list item|wg=lwg|dr=2729|std=C++11|before={{tt|1=pair::operator=}} was unconstrained and might&lt;br&gt;result in unnecessary undefined behavior|after=constrained}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc operator{{=}}}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}