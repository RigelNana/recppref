{{title|1=operator==, !=, &lt;, &lt;=, &gt;, &gt;=, &lt;=&gt;{{small|(std::variant)}}}}
{{cpp/utility/variant/navbar}}
{{dcl begin}}
{{dcl header|variant}}
{{dcl|num=1|since=c++17|1=
template&lt; class... Types &gt;
constexpr bool operator==( const std::variant&lt;Types...&gt;&amp; lhs,
                           const std::variant&lt;Types...&gt;&amp; rhs );
}}
{{dcl|num=2|since=c++17|1=
template&lt; class... Types &gt;
constexpr bool operator!=( const std::variant&lt;Types...&gt;&amp; lhs,
                           const std::variant&lt;Types...&gt;&amp; rhs );
}}
{{dcl|num=3|since=c++17|
template&lt; class... Types &gt;
constexpr bool operator&lt;( const std::variant&lt;Types...&gt;&amp; lhs,
                          const std::variant&lt;Types...&gt;&amp; rhs );
}}
{{dcl|num=4|since=c++17|
template&lt; class... Types &gt;
constexpr bool operator&gt;( const std::variant&lt;Types...&gt;&amp; lhs,
                          const std::variant&lt;Types...&gt;&amp; rhs );
}}
{{dcl|num=5|since=c++17|1=
template&lt; class... Types &gt;
constexpr bool operator&lt;=( const std::variant&lt;Types...&gt;&amp; lhs,
                           const std::variant&lt;Types...&gt;&amp; rhs );
}}
{{dcl|num=6|since=c++17|1=
template&lt; class... Types &gt;
constexpr bool operator&gt;=( const std::variant&lt;Types...&gt;&amp; lhs,
                           const std::variant&lt;Types...&gt;&amp; rhs );
}}
{{dcl|num=7|since=c++20|1=
template&lt; class... Types &gt;
constexpr std::common_comparison_category_t
              &lt;std::compare_three_way_result_t&lt;Types&gt;...&gt;
    operator&lt;=&gt;( const std::variant&lt;Types...&gt;&amp; lhs,
                 const std::variant&lt;Types...&gt;&amp; rhs );
}}
{{dcl h|Helper function template}}
{{dcla|num=8|expos=yes|
template&lt; std::size_t I, class... Types &gt;
constexpr const std::variant_alternative_t&lt;I, std::variant&lt;Types...&gt;&gt;&amp;
    GET( const variant&lt;Types...&gt;&amp; v );
}}
{{dcl end}}

Performs comparison operations on {{lc|std::variant}} objects.

@1-7@ Compares two {{lc|std::variant}} objects {{c|lhs}} and {{c|rhs}}. The contained values are compared (using the corresponding operator of {{tt|T}}) only if both {{c|lhs}} and {{c|rhs}} contain values corresponding to the same index. Otherwise, 
* {{c|lhs}} is considered ''equal to'' {{c|rhs}} if, and only if, both {{c|lhs}} and {{c|rhs}} do not contain a value.
* {{c|lhs}} is considered ''less than'' {{c|rhs}} if, and only if, either {{c|rhs}} contains a value and {{c|lhs}} does not, or {{c|lhs.index()}} is less than {{c|rhs.index()}}.

:@1-6@ Let {{c|@}} denote the corresponding comparison operator, for each of these functions:
{{rev begin}}
{{rev|until=c++26|
If, for some values of {{c|I}}, the corresponding expression {{box|{{tti|GET}}{{sep}}{{c/core|&lt;I&gt;(lhs) @}}{{nbspt}}{{tti|GET}}{{sep}}{{c/core|&lt;I&gt;(rhs)}}}} is ill-formed or its result is not convertible to {{c/core|bool}}, the program is ill-formed.
}}
{{rev|since=c++26|
{{cpp/enable if|for all values of {{c|I}}, the corresponding expression {{box|{{tti|GET}}{{sep}}{{c/core|&lt;I&gt;(lhs) @}}{{nbspt}}{{tti|GET}}{{sep}}{{c/core|&lt;I&gt;(rhs)}}}} is well-formed and its result is convertible to {{c/core|bool}}}}.
}}
{{rev end}}

@8@ The exposition-only function template {{tti|GET}} behaves like {{rlpt|get|std::get{{petty|(std::variant)}}}}, except that {{lc|std::bad_variant_access}} is never thrown.
@@ If {{c|I &lt; sizeof...(Types)}} is {{c|false}}, the program is ill-formed.
@@ If {{c|1=I == v.index()}} is {{c|false}}, the behavior is undefined.

===Parameters===
{{par begin}}
{{par|lhs,rhs|variants to compare}}
{{par end}}

===Return value===
{|class="wikitable" style="text-align: center;"
!rowspan=2|{{nbsp}}Operator{{nbsp}}
!colspan=2|Both operands contains a value&lt;br&gt;{{normal|{{small|(let {{c|I}} be {{c|lhs.index()}} and {{c|J}} be {{c|rhs.index()}})}}}}
!rowspan=2|{{c|lhs}} or {{c|rhs}} is valueless&lt;br&gt;{{normal|{{small|(let {{c|lhs_empty}} be {{c|lhs.valueless_by_exception()}} and {{c|rhs_empty}} be {{c|rhs.valueless_by_exception()}})}}}}
|-
!{{c|I}} and {{c|J}} are equal
!{{c|I}} and {{c|J}} are unequal
|-
|{{co|1===}}
|{{box|{{tti|GET}}{{sep}}{{c/core|1=&lt;I&gt;(lhs) ==}}{{nbspt}}{{tti|GET}}{{sep}}{{c/core|&lt;I&gt;(rhs)}}}}
|{{c|false}}
|{{c|lhs_empty &amp;&amp; rhs_empty}}
|-
|{{co|1=!=}}
|{{box|{{tti|GET}}{{sep}}{{c/core|1=&lt;I&gt;(lhs) !=}}{{nbspt}}{{tti|GET}}{{sep}}{{c/core|&lt;I&gt;(rhs)}}}}
|{{c|true}}
|{{c|1=lhs_empty != rhs_empty}}
|-
|{{co|&lt;}}
|{{box|{{tti|GET}}{{sep}}{{c/core|&lt;I&gt;(lhs) &lt;}}{{nbspt}}{{tti|GET}}{{sep}}{{c/core|&lt;I&gt;(rhs)}}}}
|{{c|lhs.index() &lt; rhs.index()}}
|{{c|lhs_empty &amp;&amp; !rhs_empty}}
|-
|{{co|&gt;}}
|{{box|{{tti|GET}}{{sep}}{{c/core|&lt;I&gt;(lhs) &gt;}}{{nbspt}}{{tti|GET}}{{sep}}{{c/core|&lt;I&gt;(rhs)}}}}
|{{c|lhs.index() &gt; rhs.index()}}
|{{c|!lhs_empty &amp;&amp; rhs_empty}}
|-
|{{co|1=&lt;=}}
|{{box|{{tti|GET}}{{sep}}{{c/core|1=&lt;I&gt;(lhs) &lt;=}}{{nbspt}}{{tti|GET}}{{sep}}{{c/core|&lt;I&gt;(rhs)}}}}
|{{c|lhs.index() &lt; rhs.index()}}
|{{c|lhs_empty}}
|-
|{{co|1=&gt;=}}
|{{box|{{tti|GET}}{{sep}}{{c/core|1=&lt;I&gt;(lhs) &gt;=}}{{nbspt}}{{tti|GET}}{{sep}}{{c/core|&lt;I&gt;(rhs)}}}}
|{{c|lhs.index() &gt; rhs.index()}}
|{{c|rhs_empty}}
|-
|{{co|1=&lt;=&gt;}}
|{{box|{{tti|GET}}{{sep}}{{c/core|1=&lt;I&gt;(lhs) &lt;=&gt;}}{{nbspt}}{{tti|GET}}{{sep}}{{c/core|&lt;I&gt;(rhs)}}}}
|{{c|1=lhs.index() &lt;=&gt; rhs.index()}}
|see below
|}

For {{c/core|1=operator&lt;=&gt;}}:
* If only {{c|lhs}} is valueless, returns {{ltt|cpp/utility/compare/strong_ordering|std::strong_ordering::less}}.
* If only {{c|rhs}} is valueless, returns {{ltt|cpp/utility/compare/strong_ordering|std::strong_ordering::greater}}.
* If both {{c|lhs}} and {{c|rhs}} are valueless, returns {{ltt|cpp/utility/compare/strong_ordering|std::strong_ordering::equal}}.

===Notes===
{{feature test macro|__cpp_lib_constrained_equality|constrained comparison operators for {{lc|std::variant}}|value=202403L|std=C++26}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;variant&gt;

int main()
{
    std::cout &lt;&lt; std::boolalpha;
    std::string cmp;
    bool result;
    
    auto print2 = [&amp;cmp, &amp;result](const auto&amp; lhs, const auto&amp; rhs)
    {
        std::cout &lt;&lt; lhs &lt;&lt; ' ' &lt;&lt; cmp &lt;&lt; ' ' &lt;&lt; rhs &lt;&lt; " : " &lt;&lt; result &lt;&lt; '\n';
    };
    
    std::variant&lt;int, std::string&gt; v1, v2;
    
    std::cout &lt;&lt; "operator==\n";
    {
        cmp = "==";
        
        // by default v1 = 0, v2 = 0;
        result = v1 == v2; // true
        std::visit(print2, v1, v2);
        
        v1 = v2 = 1;
        result = v1 == v2; // true
        std::visit(print2, v1, v2);
        
        v2 = 2;
        result = v1 == v2; // false
        std::visit(print2, v1, v2);
        
        v1 = "A";
        result = v1 == v2; // false: v1.index == 1, v2.index == 0
        std::visit(print2, v1, v2);
        
        v2 = "B";
        result = v1 == v2; // false
        std::visit(print2, v1, v2);
        
        v2 = "A";
        result = v1 == v2; // true
        std::visit(print2, v1, v2);
    }
    
    std::cout &lt;&lt; "operator&lt;\n";
    {
        cmp = "&lt;";
        
        v1 = v2 = 1;
        result = v1 &lt; v2; // false
        std::visit(print2, v1, v2);
        
        v2 = 2;
        result = v1 &lt; v2; // true
        std::visit(print2, v1, v2);
        
        v1 = 3;
        result = v1 &lt; v2; // false
        std::visit(print2, v1, v2);
        
        v1 = "A"; v2 = 1;
        result = v1 &lt; v2; // false: v1.index == 1, v2.index == 0
        std::visit(print2, v1, v2);
        
        v1 = 1; v2 = "A";
        result = v1 &lt; v2; // true: v1.index == 0, v2.index == 1
        std::visit(print2, v1, v2);
        
        v1 = v2 = "A";
        result = v1 &lt; v2; // false
        std::visit(print2, v1, v2);
        
        v2 = "B";
        result = v1 &lt; v2; // true
        std::visit(print2, v1, v2);
        
        v1 = "C";
        result = v1 &lt; v2; // false
        std::visit(print2, v1, v2);
    }
    
    {
        std::variant&lt;int, std::string&gt; v1;
        std::variant&lt;std::string, int&gt; v2;
    //  v1 == v2; // Compilation error: no known conversion
    }
    
    // TODO: C++20 three-way comparison operator &lt;=&gt; for variants
}
|output=
operator==
0 == 0 : true
1 == 1 : true
1 == 2 : false
A == 2 : false
A == B : false
A == A : true
operator&lt;
1 &lt; 1 : false
1 &lt; 2 : true
3 &lt; 2 : false
A &lt; 1 : false
1 &lt; A : true
A &lt; A : false
A &lt; B : true
C &lt; B : false
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/optional/dsc operator cmp}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}