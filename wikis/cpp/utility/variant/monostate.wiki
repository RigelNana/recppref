{{cpp/title|monostate}}
{{cpp/utility/variant/navbar}}
{{dcl begin}}
{{dcl header|variant}}
{{dcl header|utility|notes={{mark since c++26}}}}
{{dcl|since=c++17|
struct monostate { };
}}
{{dcl end}}

Unit type intended for use as a well-behaved empty alternative in {{lc|std::variant}}. In particular, a variant of non-default-constructible types may list {{tt|std::monostate}} as its first alternative: this makes the variant itself default-constructible.

===Member functions===
{{dsc begin}}
{{dsc mem ctor|trivial implicit default/copy/move constructor|nolink=true|notes={{mark implicit}}}}
{{dsc mem dtor|trivial implicit destructor|nolink=true|notes={{mark implicit}}}}
{{dsc mem fun|operator{{=}}|trivial implicit copy/move assignment|notes={{mark implicit}}|nolink=true}}
{{dsc end}}

===Non-member functions===
{{member|1={{small|std::}}operator==, !=, &lt;, &lt;=, &gt;, &gt;=, &lt;=&gt;{{small|(std::monostate)}}|2=
{{dcl begin}}
{{dcl|since=c++17|num=1|1=
constexpr bool operator==( monostate, monostate ) noexcept { return true; }
}}
{{dcl rev multi|num=2|since1=c++17|until1=c++20|dcl1=
constexpr bool operator!=( monostate, monostate ) noexcept { return false; }
constexpr bool operator&lt; ( monostate, monostate ) noexcept { return false; }
constexpr bool operator&gt; ( monostate, monostate ) noexcept { return false; }
constexpr bool operator&lt;=( monostate, monostate ) noexcept { return true; }
constexpr bool operator&gt;=( monostate, monostate ) noexcept { return true; }
|dcl2=
constexpr std::strong_ordering operator&lt;=&gt;( monostate, monostate ) noexcept
{
    return std::strong_ordering::equal;
}
}}
{{dcl end}}

All instances of {{tt|std::monostate}} compare equal.

{{rrev|since=c++20|
{{cpp/note synthesized compare}}
}}
}}

===Helper classes===
{{member|{{small|std::}}hash{{small|&lt;std::monostate&gt;}}|2=
{{ddcl|since=c++17|
template &lt;&gt;
struct std::hash&lt;monostate&gt;;
}}
Specializes the {{lc|std::hash}} algorithm for {{tt|std::monostate}}.
}}

===Example===
{{example
|
|code=
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;variant&gt;

struct S
{
    S(int i) : i(i) {}
    int i;
};

int main()
{
    // Without the monostate type this declaration will fail.
    // This is because S is not default-constructible.
    std::variant&lt;std::monostate, S&gt; var;
    assert(var.index() == 0);

    try
    {
        std::get&lt;S&gt;(var); // throws! We need to assign a value
    }
    catch(const std::bad_variant_access&amp; e)
    {
        std::cout &lt;&lt; e.what() &lt;&lt; '\n';
    }

    var = 42;
    std::cout &lt;&lt; "std::get: " &lt;&lt; std::get&lt;S&gt;(var).i &lt;&lt; '\n'
              &lt;&lt; "std::hash: " &lt;&lt; std::hex &lt;&lt; std::showbase
              &lt;&lt; std::hash&lt;std::monostate&gt;{}(std::monostate{}) &lt;&lt; '\n';
}
|p=true
|output=
std::get: wrong index for variant
std::get: 42
std::hash: 0xffffffffffffe19f
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/variant/dsc constructor}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}