{{cpp/title|variant_alternative|variant_alternative_t}}
{{cpp/utility/variant/navbar}}
{{dcl begin}}
{{dcl header|variant}}
{{dcl |since=c++17|num=1|
template &lt;std::size_t I, class T&gt;
struct variant_alternative; /* undefined */
}}
{{dcl |since=c++17|num=2|
template &lt;std::size_t I, class... Types&gt;
struct variant_alternative&lt;I, variant&lt;Types...&gt;&gt;;
}}
{{dcl |since=c++17|num=3|
template &lt;std::size_t I, class T&gt; class variant_alternative&lt;I, const T&gt;;
}}
{{dcl |since=c++17|deprecated=c++20|num=3|
template &lt;std::size_t I, class T&gt;
class variant_alternative&lt;I, volatile T&gt;;
template &lt;std::size_t I, class T&gt;
class variant_alternative&lt;I, const volatile T&gt;;
}}
{{dcl end}}

Provides compile-time indexed access to the types of the alternatives of the possibly cv-qualified variant, combining cv-qualifications of the variant (if any) with the cv-qualifications of the alternative.

Formally, 
@2@ meets the {{named req|TransformationTrait}} requirements with a member typedef {{tt|type}} equal to the type of the alternative with index {{tt|I}}
@3@ meets the {{named req|TransformationTrait}} requirements with a member typedef {{tt|type}} that names, respectively, {{c|std::add_const_t&lt;std::variant_alternative_t&lt;I,T&gt;&gt;}}, {{c|std::add_volatile_t&lt;std::variant_alternative_t&lt;I,T&gt;&gt;}}, and {{c|std::add_cv_t&lt;std::variant_alternative_t&lt;I,T&gt;&gt;}}

===Member types===
{{dsc begin}}
{{dsc hitem | Member type | Definition}}
{{dsc | type | the type of {{tt|I}}th alternative of the variant, where {{tt|I}} must be in {{tt|[0, sizeof...(Types))}}, otherwise the program is ill-formed.}}
{{dsc end}}

===Helper template alias===
{{dcl begin}}
{{dcl|since=c++17|1=
template &lt;size_t I, class T&gt;
using variant_alternative_t = typename variant_alternative&lt;I, T&gt;::type;
}}
{{dcl end}}

===Example===
{{example
  | code=
#include &lt;variant&gt;
#include &lt;iostream&gt;

using my_variant = std::variant&lt;int, float&gt;;
static_assert(std::is_same_v
    &lt;int,   std::variant_alternative_t&lt;0, my_variant&gt;&gt;);
static_assert(std::is_same_v
    &lt;float, std::variant_alternative_t&lt;1, my_variant&gt;&gt;);
// cv-qualification on the variant type propagates to the extracted alternative type.
static_assert(std::is_same_v
    &lt;const int, std::variant_alternative_t&lt;0, const my_variant&gt;&gt;);

int main()
{
    std::cout &lt;&lt; "All static assertions passed.\n";
}
  | output=
All static assertions passed.
}}

===Defect reports===
{{dr list begin}}
{{dr list item | wg=lwg | dr=2974 | std=c++17 | before=out-of-bounds index resulted in undefined behavior | after=made ill-formed}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc | cpp/utility/variant/dsc variant_size}}
{{dsc inc | cpp/utility/tuple/dsc tuple_element}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}