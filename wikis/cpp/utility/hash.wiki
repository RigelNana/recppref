{{cpp/title|hash}}
{{cpp/utility/hash/navbar}}

{{dcl begin}}
{{dcl header|bitset}}
{{dcl header|coroutine}}
{{dcl header|chrono|notes={{mark since c++26}}}}
{{dcl header|filesystem}}
{{dcl header|functional}}
{{dcl header|memory}}
{{dcl header|optional}}
{{dcl header|stacktrace}}
{{dcl header|string}}
{{dcl header|string_view}}
{{dcl header|system_error}}
{{dcl header|text_encoding}}
{{dcl header|thread}}
{{dcl header|typeindex}}
{{dcl header|variant}}
{{dcl header|vector}}
{{dcl|since=c++11|
template&lt; class Key &gt;
struct hash;
}}
{{dcl end}}

The unordered associative containers {{lc|std::unordered_set}}, {{lc|std::unordered_multiset}}, {{lc|std::unordered_map}}, {{lc|std::unordered_multimap}} use specializations of the template {{tt|std::hash}} as the default hash function.

Given a type {{tt|Key}}, each specialization {{tt|std::hash&lt;Key&gt;}} is either ''enabled'' or ''disabled''{{sep}}:
* If {{tt|std::hash&lt;Key&gt;}} is not provided by the program or the user, it is disabled.
* Otherwise, {{tt|std::hash&lt;Key&gt;}} is enabled if all following conditions are satisfied:
:* All following requirements are satisfied:
::* {{named req|Hash}} (with {{tt|Key}} as the function call argument type)
::* {{named req|DefaultConstructible}}
::* {{named req|CopyAssignable}}
::* {{named req|Swappable}}
:* Given the following values:
::* {{c|h}}, an object of type {{tt|std::hash&lt;Key&gt;}}.
::* {{c|k1}} and {{c|k2}}, objects of type {{tt|Key}}.
:: All following requirements are satisfied:
::* If {{c|1=k1 == k2}} is {{c|true}}, {{c|1=h(k1) == h(k2)}} is also {{c|true}}.
::* Unless {{tt|std::hash&lt;Key&gt;}} is a [[cpp/language/type#Program-defined type|program-defined specialization]], {{c|h(k1)}} will never throw an exception.
* Otherwise, {{tt|std::hash&lt;Key&gt;}} is disabled.

Disabled specializations do not satisfy {{named req|Hash}}, do not satisfy {{named req|FunctionObject}}, and following values are all {{c|false}}:
* {{c|std::is_default_constructible&lt;std::hash&lt;Key&gt;&gt;::value}}
* {{c|std::is_copy_constructible&lt;std::hash&lt;Key&gt;&gt;::value}}
* {{c|std::is_move_constructible&lt;std::hash&lt;Key&gt;&gt;::value}}
* {{c|std::is_copy_assignable&lt;std::hash&lt;Key&gt;&gt;::value}}
* {{c|std::is_move_assignable&lt;std::hash&lt;Key&gt;&gt;::value}}

In other words, they exist, but cannot be used.

{{rrev|until=c++20|
===Nested types===
{{dsc begin}}
{{dsc hitem|Name|Definition}}
{{dsc|{{tt|argument_type}} {{mark deprecated c++17}}|{{tt|Key}}}}
{{dsc|{{tt|result_type}} {{mark deprecated c++17}}|{{lc|std::size_t}}}}
{{dsc end}}
}}

===Member functions===
{{dsc begin}}
{{dsc mem ctor|cpp/utility/hash/hash|constructs a hash function object}}
{{dsc mem fun|cpp/utility/hash/operator()|calculates the hash of the argument}}
{{dsc end}}

===Standard library specializations===
Each header that declares the template {{tt|std::hash}} also provides enabled specializations of {{tt|std::hash}} for the following types:
* all cv-unqualified [[cpp/language/types|arithmetic types]]
* all cv-unqualified [[cpp/language/enum|enumeration types]]
* all cv-unqualified [[cpp/language/pointer|pointer types]]
* {{lc|std::nullptr_t}}

On top of that, some headers also provide other enabled {{tt|std::hash}} specializations for library types (see [[#Specializations for library types|below]]).

{{rrev|since=c++17|&lt;!-- P0599R1, not a DR in P0636R2 --&gt;
For all {{tt|std::hash}} specializations provided by the standard library except the following, all their member functions are {{c/core|noexcept}}:
* {{ltt|cpp/utility/optional/hash|std::hash&lt;std::optional&gt;}}
* {{ltt|cpp/utility/variant/hash|std::hash&lt;std::variant&gt;}}
* {{ltt|cpp/memory/unique_ptr/hash|std::hash&lt;std::unique_ptr&gt;}}
{{rrev|since=c++26|
* {{ltt|cpp/chrono/duration/hash|std::hash&lt;std::chrono::duration&gt;}}
* {{ltt|cpp/chrono/time_point/hash|std::hash&lt;std::chrono::time_point&gt;}}
* {{ltt|cpp/chrono/zoned_time/hash|std::hash&lt;std::chrono::zoned_time&gt;}}
}}
}}

===Specializations for library types===
{{dsc begin}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc hash}}
{{dsc inc|cpp/error/error_code/dsc hash}}
{{dsc inc|cpp/error/error_condition/dsc hash}}
{{dsc inc|cpp/utility/stacktrace_entry/dsc hash}}
{{dsc inc|cpp/utility/basic_stacktrace/dsc hash}}
{{dsc inc|cpp/utility/optional/dsc hash}}
{{dsc inc|cpp/utility/variant/dsc hash}}
{{dsc ptclass|cpp/utility/variant/monostate#Helper classes|title=std::hash{{dsc small|&lt;std::monostate&gt;}}|notes={{mark c++17}}|hash support for {{lc|std::monostate}}}}
{{dsc inc|cpp/utility/bitset/dsc hash}}
{{dsc inc|cpp/memory/unique_ptr/dsc hash}}
{{dsc inc|cpp/memory/shared_ptr/dsc hash}}
{{dsc inc|cpp/types/type_index/dsc hash}}
{{dsc inc|cpp/string/basic_string/dsc hash}}
{{dsc inc|cpp/string/basic_string_view/dsc hash}}
{{dsc inc|cpp/text/text_encoding/dsc hash}}
{{dsc ptclass|cpp/container/vector bool/hash|title=std::hash{{dsc small|&lt;std::vector&lt;bool&gt;&gt;}}|hash support for {{ltt|cpp/container/vector bool|std::vector&lt;bool&gt;}}|notes={{mark c++11}}}}
{{dsc inc|cpp/filesystem/path/dsc hash}}
{{dsc inc|cpp/thread/thread/id/dsc hash}}
{{dsc hash|cpp/chrono/duration|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/time_point|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/day|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/month|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/year|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/weekday|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/weekday_indexed|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/weekday_last|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/month_day|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/month_day_last|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/month_weekday|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/month_weekday_last|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/year_month|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/year_month_day|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/year_month_day_last|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/year_month_weekday|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/year_month_weekday_last|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/zoned_time|nested=true|notes={{mark c++26}}}}
{{dsc hash|cpp/chrono/leap_second|nested=true|notes={{mark c++26}}}}
{{dsc end}}

===Notes===
The actual hash functions are implementation-dependent and are not required to fulfill any other quality criteria except those specified above. Notably, some implementations use trivial (identity) hash functions which map an integer to itself. In other words, these hash functions are designed to work with unordered associative containers, but not as cryptographic hashes, for example.

Hash functions are only required to produce the same result for the same input within a single execution of a program; this allows salted hashes that prevent collision denial-of-service attacks.

There is no specialization for C strings. {{c/core|std::hash&lt;const char*&gt;}} produces a hash of the value of the pointer (the memory address), it does not examine the contents of any character array.

Additional specializations for {{lc|std::pair}} and the standard container types, as well as utility functions to compose hashes are available in [https://www.boost.org/doc/libs/release/libs/container_hash/doc/html/hash.html#ref {{tt|boost::hash}}].

===Example===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;

struct S
{
    std::string first_name;
    std::string last_name;
    bool operator==(const S&amp;) const = default; // since C++20
};

// Before C++20.
// bool operator==(const S&amp; lhs, const S&amp; rhs)
// {
//     return lhs.first_name == rhs.first_name &amp;&amp; lhs.last_name == rhs.last_name;
// }

// Custom hash can be a standalone function object.
struct MyHash
{
    std::size_t operator()(const S&amp; s) const noexcept
    {
        std::size_t h1 = std::hash&lt;std::string&gt;{}(s.first_name);
        std::size_t h2 = std::hash&lt;std::string&gt;{}(s.last_name);
        return h1 ^ (h2 &lt;&lt; 1); // or use boost::hash_combine
    }
};

// Custom specialization of std::hash can be injected in namespace std.
template&lt;&gt;
struct std::hash&lt;S&gt;
{
    std::size_t operator()(const S&amp; s) const noexcept
    {
        std::size_t h1 = std::hash&lt;std::string&gt;{}(s.first_name);
        std::size_t h2 = std::hash&lt;std::string&gt;{}(s.last_name);
        return h1 ^ (h2 &lt;&lt; 1); // or use boost::hash_combine
    }
};

int main()
{
    std::string str = "Meet the new boss...";
    std::size_t str_hash = std::hash&lt;std::string&gt;{}(str);
    std::cout &lt;&lt; "hash(" &lt;&lt; std::quoted(str) &lt;&lt; ") =\t" &lt;&lt; str_hash &lt;&lt; '\n';
    
    S obj = {"Hubert", "Farnsworth"};
    // Using the standalone function object.
    std::cout &lt;&lt; "hash(" &lt;&lt; std::quoted(obj.first_name) &lt;&lt; ", "
              &lt;&lt; std::quoted(obj.last_name) &lt;&lt; ") =\t"
              &lt;&lt; MyHash{}(obj) &lt;&lt; " (using MyHash) or\n\t\t\t\t"
              &lt;&lt; std::hash&lt;S&gt;{}(obj) &lt;&lt; " (using injected specialization)\n";
    
    // Custom hash makes it possible to use custom types in unordered containers.
    // The example will use the injected std::hash&lt;S&gt; specialization above,
    // to use MyHash instead, pass it as a second template argument.
    std::unordered_set&lt;S&gt; names = {obj, {"Bender", "Rodriguez"}, {"Turanga", "Leela"}&lt;!----&gt;};
    for (auto const&amp; s: names)
        std::cout &lt;&lt; std::quoted(s.first_name) &lt;&lt; ' '
                  &lt;&lt; std::quoted(s.last_name) &lt;&lt; '\n';
}
|p=true
|output=
hash("Meet the new boss...") =  10656026664466977650
hash("Hubert", "Farnsworth") =  12922914235676820612 (using MyHash) or
                                12922914235676820612 (using injected specialization)
"Bender" "Rodriguez"
"Turanga" "Leela"
"Hubert" "Farnsworth"
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2119|std=C++11|before=specializations for extended integer types were missing|after=provided}}
{{dr list item|wg=lwg|dr=2148|std=C++11|before=specializations for enumerations were missing|after=provided}}
{{dr list item|wg=lwg|dr=2543|std=C++11|before={{tt|std::hash}} might not be SFINAE-friendly|after=made SFINAE-friendly}}
{{dr list item|wg=lwg|dr=2817|std=C++11|before=specialization for {{lc|std::nullptr_t}} was missing|after=provided}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}