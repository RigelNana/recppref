{{cpp/title|variant}}
{{cpp/utility/variant/navbar}}
{{ddcl|header=variant|since=c++17|
template&lt; class... Types &gt;
class variant;
}}

The class template {{tt|std::variant}} represents a type-safe {{lt|cpp/language/union}}. An instance of {{tt|std::variant}} at any given time either holds a value of one of its alternative types, or in the case of error - no value (this state is hard to achieve, see {{ltt|cpp/utility/variant/valueless_by_exception}}).

As with unions, if a variant holds a value of some object type {{tt|T}}, the {{tt|T}} object is [[cpp/language/object#Address|nested within]] the {{tt|variant}} object itself. Variant is not allowed to allocate additional (dynamic) memory.

A variant is not permitted to hold references, arrays, or the type {{c/core|void}}.

A variant is permitted to hold the same type more than once, and to hold differently cv-qualified versions of the same type.

Consistent with the behavior of unions during {{lt|cpp/language/aggregate initialization}}, a default-constructed variant holds a value of its first alternative, unless that alternative is not default-constructible (in which case the variant is not default-constructible either). The helper class {{ltt std|cpp/utility/variant/monostate}} can be used to make such variants default-constructible.

A program that instantiates the definition of {{tt|std::variant}} with no template arguments is ill-formed. {{c/core|std::variant&lt;std::monostate&gt;}} can be used instead.

If a program declares an [[cpp/language/template specialization|explicit]] or [[cpp/language/partial specialization|partial]] specialization of {{tt|std::variant}}, the program is ill-formed, no diagnostic required.

===Template parameters===
{{par begin}}
{{par|Types|the types that may be stored in this variant. All types must meet the {{named req|Destructible}} requirements (in particular, array types and non-object types are not allowed).}}
{{par end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/utility/variant/dsc constructor}}
{{dsc inc|cpp/utility/variant/dsc destructor}}
{{dsc inc|cpp/utility/variant/dsc operator{{=}}}}

{{dsc h2|Observers}}
{{dsc inc|cpp/utility/variant/dsc index}}
{{dsc inc|cpp/utility/variant/dsc valueless_by_exception}}

{{dsc h2|Modifiers}}
{{dsc inc|cpp/utility/variant/dsc emplace}}
{{dsc inc|cpp/utility/variant/dsc swap}}

{{dsc h2|Visitation}}
{{dsc inc|cpp/utility/variant/dsc visit}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/utility/variant/dsc visit2}}
{{dsc inc|cpp/utility/variant/dsc holds_alternative}}
{{dsc inc|cpp/utility/variant/dsc get}}
{{dsc inc|cpp/utility/variant/dsc get_if}}
{{dsc inc|cpp/utility/variant/dsc operator_cmp}}
{{dsc inc|cpp/utility/variant/dsc swap2}}
{{dsc end}}

===Helper classes===
{{dsc begin}}
{{dsc inc|cpp/utility/variant/dsc monostate}}&lt;!--including monostate's comparisons and hash--&gt;
{{dsc inc|cpp/utility/variant/dsc bad_variant_access}}
{{dsc inc|cpp/utility/variant/dsc variant_size}}
{{dsc inc|cpp/utility/variant/dsc variant_alternative}}
{{dsc inc|cpp/utility/variant/dsc hash}}
{{dsc end}}

===Helper objects===
{{dsc begin}}
{{dsc inc|cpp/utility/variant/dsc variant_npos}}
{{dsc end}}

===Notes===
{{ftm begin|sort=1}}
{{ftm|std=C++17|value=201606L|__cpp_lib_variant|rowspan="4"|{{tt|std::variant}}: a type-safe union}}
{{ftm|std=C++23|dr=17|value=202102L|-|{{lc|std::visit}} for classes derived from {{tt|std::variant}}}}
{{ftm|std=C++23|dr=20|value=202106L|-|Fully {{tt|constexpr}} {{tt|std::variant}}}}
{{ftm|std=C++26|-|value=202306L|Member {{rlt|visit2|visit}}}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;variant&gt;

int main()
{
    std::variant&lt;int, float&gt; v, w;
    v = 42; // v contains int
    int i = std::get&lt;int&gt;(v);
    assert(42 == i); // succeeds
    w = std::get&lt;int&gt;(v);
    w = std::get&lt;0&gt;(v); // same effect as the previous line
    w = v; // same effect as the previous line
    
//  std::get&lt;double&gt;(v); // error: no double in [int, float]
//  std::get&lt;3&gt;(v);      // error: valid index values are 0 and 1
    
    try
    {
        std::get&lt;float&gt;(w); // w contains int, not float: will throw
    }
    catch (const std::bad_variant_access&amp; ex)
    {
        std::cout &lt;&lt; ex.what() &lt;&lt; '\n';
    }
    
    using namespace std::literals;
    
    std::variant&lt;std::string&gt; x("abc");
    // converting constructors work when unambiguous
    x = "def"; // converting assignment also works when unambiguous
    
    std::variant&lt;std::string, void const*&gt; y("abc");
    // casts to void const* when passed a char const*
    assert(std::holds_alternative&lt;void const*&gt;(y)); // succeeds
    y = "xyz"s;
    assert(std::holds_alternative&lt;std::string&gt;(y)); // succeeds
}
|p=true
|output=
std::get: wrong index for variant
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2901|std=C++17|before=specialization of {{lc|std::uses_allocator}} provided,&lt;br&gt;but {{tt|std::variant}} cannot properly support allocators|after=specialization removed}}
{{dr list item|wg=lwg|dr=3990|std=C++17|before=a program could declare an explicit or&lt;br&gt;partial specialization of {{tt|std::variant}}|after=the program is ill-formed in this&lt;br&gt;case (no diagnostic required)}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/dsc in_place}}
{{dsc inc|cpp/utility/dsc optional}}
{{dsc inc|cpp/utility/dsc any}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}