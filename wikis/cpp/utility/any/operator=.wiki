{{cpp/utility/any/title|operator{{=}}}}
{{cpp/utility/any/navbar}}
{{dcl begin}}
{{dcl|since=c++17|num=1|1=
any&amp; operator=( const any&amp; rhs );
}}
{{dcl|since=c++17|num=2|1=
any&amp; operator=( any&amp;&amp; rhs ) noexcept;
}}
{{dcl|since=c++17|num=3|1=
template&lt; typename ValueType &gt;
any&amp; operator=( ValueType&amp;&amp; rhs );
}}
{{dcl end}}

Assigns contents to the contained value. 

@1@ Assigns by copying the state of {{c|rhs}}, as if by {{c|std::any(rhs).swap(*this)}}.
@2@ Assigns by moving the state of {{c|rhs}}, as if by {{c|std::any(std::move(rhs)).swap(*this)}}. {{c|rhs}} is left in a valid but unspecified state after the assignment.
@3@ Assigns the type and value of {{c|rhs}}, as if by {{c|std::any(std::forward&lt;ValueType&gt;(rhs)).swap(*this)}}. {{cpp/enable if|{{c|std::decay_t&lt;ValueType&gt;}} is not the same type as {{lc|std::any}} and {{c|std::is_copy_constructible_v&lt;std::decay_t&lt;ValueType&gt;&gt;}} is {{c|true}}.}}

===Template parameters===
{{par begin}}
{{par|ValueType|contained value type}}
{{par hreq}}
{{par req named|{{c|std::decay_t&lt;ValueType&gt;}}|CopyConstructible}}
{{par end}}

===Parameters===
{{par begin}}
{{par|rhs|object whose contained value to assign}}
{{par end}}

===Return value===
{{c|*this}}

===Exceptions===
@1,3@ Throws {{lc|std::bad_alloc}} or any exception thrown by the constructor of the contained type.
{{cpp/strong exception safety guarantee|plural=yes}}

===Example===
{{example
|code=
#include &lt;any&gt;
#include &lt;cassert&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;typeinfo&gt;

int main()
{
    using namespace std::string_literals;
    std::string cat{"cat"};

    std::any a1{42};
    std::any a2{cat};
    assert(a1.type() == typeid(int));
    assert(a2.type() == typeid(std::string));

    a1 = a2; // overload (1)
    assert(a1.type() == typeid(std::string));
    assert(a2.type() == typeid(std::string));
    assert(std::any_cast&lt;std::string&amp;&gt;(a1) == cat);
    assert(std::any_cast&lt;std::string&amp;&gt;(a2) == cat);

    a1 = 96; // overload (3)
    a2 = "dog"s; // overload (3)
    a1 = std::move(a2); // overload (2)
    assert(a1.type() == typeid(std::string));
    assert(std::any_cast&lt;std::string&amp;&gt;(a1) == "dog");
    // The state of a2 is valid but unspecified. In fact,
    // it is void in gcc/clang and std::string in msvc.
    std::cout &lt;&lt; "a2.type(): " &lt;&lt; std::quoted(a2.type().name()) &lt;&lt; '\n';

    a1 = std::move(cat); // overload (3)
    assert(*std::any_cast&lt;std::string&gt;(&amp;a1) == "cat");
    // The state of cat is valid but indeterminate:
    std::cout &lt;&lt; "cat: " &lt;&lt; std::quoted(cat) &lt;&lt; '\n';
}
|p=true
|output=
a2.type(): "void"
cat: ""
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/any/dsc constructor}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}