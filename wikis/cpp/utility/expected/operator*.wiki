{{cpp/utility/expected/title|operator-&gt;|operator*}}
{{cpp/utility/expected/navbar}}

{{dcl begin}}
{{dcl h|Primary template}}
{{dcl|num=1|since=c++23|
constexpr const T* operator-&gt;() const noexcept;
}}
{{dcl|num=2|since=c++23|
constexpr T* operator-&gt;() noexcept;
}}
{{dcl|num=3|since=c++23|
constexpr const T&amp; operator*() const&amp; noexcept;
}}
{{dcl|num=4|since=c++23|
constexpr T&amp; operator*() &amp; noexcept;
}}
{{dcl|num=5|since=c++23|
constexpr const T&amp;&amp; operator*() const&amp;&amp; noexcept;
}}
{{dcl|num=6|since=c++23|
constexpr T&amp;&amp; operator*() &amp;&amp; noexcept;
}}
{{dcl h|{{c/core|void}} partial specialization}}
{{dcl|num=7|since=c++23|
constexpr void operator*() const noexcept;
}}
{{dcl end}}

Accesses the expected value contained in {{c|*this}}.

@1,2@ Returns a pointer to the expected value.

@3-6@ Returns a reference to the expected value.

@7@ Returns nothing.

If {{rlpf|operator bool|has_value}} is {{c|false}}, the behavior is undefined.

===Return value===
@1,2@ {{box|{{c/core|std::addressof(}}{{rlpi|/#Data members|val}}{{c/core|)}}}}

@3,4@ {{box|{{tti|val}}}}

@5,6@ {{box|{{c/core|std::}}{{ltt|cpp/utility/move}}{{c/core|(}}{{tti|val}}{{c/core|)}}}}

===Notes===
These operators do not check whether the optional represents an expected value! You can do so manually by using {{rlpf|operator bool|has_value}} or simply {{rlpf|operator bool}}. Alternatively, if checked access is needed, {{rlpf|value}} or {{rlpf|value_or}} may be used.

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;expected&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    using namespace std::string_literals;
    
    std::expected&lt;int, std::string&gt; ex1 = 6;
    assert(*ex1 == 6);
    
    *ex1 = 9;
    assert(*ex1 == 9);
    
    // *ex1 = "error"s; // error, ex1 contains an expected value of type int
    ex1 = std::unexpected("error"s);
    // *ex1 = 13; // UB, ex1 contains an unexpected value
    assert(ex1.value_or(42) == 42);
    
    std::expected&lt;std::string, bool&gt; ex2 = "Moon"s;
    std::cout &lt;&lt; "ex2: " &lt;&lt; std::quoted(*ex2) &lt;&lt; ", size: " &lt;&lt; ex2-&gt;size() &lt;&lt; '\n';
    
    // You can "take" the expected value by calling operator* on an std::expected rvalue
    
    auto taken = *std::move(ex2);
    std::cout &lt;&lt; "taken " &lt;&lt; std::quoted(taken) &lt;&lt; "\n"
                 "ex2: " &lt;&lt; std::quoted(*ex2) &lt;&lt; ", size: " &lt;&lt; ex2-&gt;size() &lt;&lt; '\n';
}
|p=true
|output=
ex2: "Moon", size: 4
taken "Moon"
ex2: "", size: 0
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/expected/dsc value}}
{{dsc inc|cpp/utility/expected/dsc value_or}}
{{dsc inc|cpp/utility/expected/dsc operator bool}}
{{dsc inc|cpp/utility/expected/dsc error}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}