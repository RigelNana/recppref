{{cpp/utility/expected/title|1=operator=}}
{{cpp/utility/expected/navbar}}

{{dcl begin}}
{{dcl h|Primary template}}
{{dcla|num=1|since=c++23|1=
constexpr expected&amp; operator=( const expected&amp; other );
}}
{{dcla|num=2|since=c++23|1=
constexpr expected&amp; operator=( expected&amp;&amp; other )
    noexcept(/* see below */);
}}
{{dcla|num=3|since=c++23|1=
template&lt; class U = T &gt;
constexpr expected&amp; operator=( U&amp;&amp; v );
}}
{{dcla|num=4|since=c++23|1=
template&lt; class G &gt;
constexpr expected&amp; operator=( const std::unexpected&lt;G&gt;&amp; e );
}}
{{dcla|num=5|since=c++23|1=
template&lt; class G &gt;
constexpr expected&amp; operator=( std::unexpected&lt;G&gt;&amp;&amp; e );
}}
{{dcl h|{{c/core|void}} partial specialization}}
{{dcla|num=6|since=c++23|1=
constexpr expected&amp; operator=( const expected&amp; other );
}}
{{dcla|num=7|since=c++23|1=
constexpr expected&amp; operator=( expected&amp;&amp; other )
    noexcept(/* see below */);
}}
{{dcla|num=8|since=c++23|1=
template&lt; class G &gt;
constexpr expected&amp; operator=( const std::unexpected&lt;G&gt;&amp; e );
}}
{{dcla|num=9|since=c++23|1=
template&lt; class G &gt;
constexpr expected&amp; operator=( std::unexpected&lt;G&gt;&amp;&amp; e );
}}
{{dcl h|Helper function template}}
{{dcl|num=10|since=c++23|notes={{mark expos}}|
template&lt; class T, class U, class... Args &gt;
constexpr void reinit-expected( T&amp; newval, U&amp; oldval, Args&amp;&amp;... args )
}}
{{dcl end}}

Assigns a new value to an existing {{tt|expected}} object.

===Parameters===
{{par begin}}
{{par|other|another {{tt|expected}} object whose contained value to assign}}
{{par|v|value to assign to the contained value}}
{{par|e|{{ltt std|cpp/utility/expected/unexpected}} object whose contained value to assign}}
{{par|newval|the contained value to be constructed}}
{{par|oldval|the contained value to be destroyed}}
{{par|args|the arguments used as initializers of {{c|newval}}}}
{{par end}}

===Effects===
====Primary template assignment operators====
@1,2@ Assigns the state of {{c|other}} to {{c|*this}}.
@@ If {{rlpf|operator bool|has_value}} and {{c|rhs.has_value()}} have different values (i.e. one of {{c|*this}} and {{c|other}} contains an expected value {{rlpi|/#Data members|val}} and the other contains an unexpected value {{rlpi|/#Data members|unex}}{{sep}}), the exposition-only function template [[#Helper function template|{{tti|reinit-expected}}]] is called to safely update the state.
:@1@ The contained value is assigned as follows:
{|class="wikitable"
!rowspan=2|Value of&lt;br&gt;{{nbsp}}{{rlpf|operator bool|has_value}}{{nbsp}}
!colspan=2|Value of {{c|other.has_value()}}
|-
!style="font-weight: normal;"|{{c|true}}
!style="font-weight: normal;"|{{c|false}}
|-
|style="text-align: center;"|{{c|true}}
|{{box|{{tti|val}}{{nbspt}}{{c/core|1== *other;}}}}
|{{box|{{tti|reinit-expected}}&lt;br&gt;{{nbspt|4}}{{c/core|(}}{{tti|unex}}{{c/core|,}}{{nbspt}}{{tti|val}}{{c/core|, other.error());}}}}
|-
|style="text-align: center;"|{{c|false}}
|{{box|{{tti|reinit-expected}}&lt;br&gt;{{nbspt|4}}{{c/core|(}}{{tti|val}}{{c/core|,}}{{nbspt}}{{tti|unex}}{{c/core|, *other);}}}}
|{{box|{{tti|unex}}{{nbspt}}{{c/core|1== other.error();}}}}
|}
:@2@ The contained value is assigned as follows:
{|class="wikitable"
!rowspan=2|Value of&lt;br&gt;{{nbsp}}{{rlpf|operator bool|has_value}}{{nbsp}}
!colspan=2|Value of {{c|other.has_value()}}
|-
!style="font-weight: normal;"|{{c|true}}
!style="font-weight: normal;"|{{c|false}}
|-
|style="text-align: center;"|{{c|true}}
|{{box|{{tti|val}}{{nbspt}}{{c/core|1== std::move(*other);}}}}
|{{box|{{tti|reinit-expected}}&lt;br&gt;{{nbspt|4}}{{c/core|(}}{{tti|unex}}{{c/core|,}}{{nbspt}}{{tti|val}}{{c/core|, std::move(other.error()));}}}}
|-
|style="text-align: center;"|{{c|false}}
|{{box|{{tti|reinit-expected}}&lt;br&gt;{{nbspt|4}}{{c/core|(}}{{tti|val}}{{c/core|,}}{{nbspt}}{{tti|unex}}{{c/core|,}}&lt;br&gt;{{nbspt|5}}{{c/core|std::move(*other));}}}}
|{{box|{{tti|unex}}{{nbspt}}{{c/core|1== std::move(other.error());}}}}
|}
@@ Then, if no exception was thrown, executes {{box|{{rlpi|/#Data members|has_val}}{{nbspt}}{{c/core|1== other.has_value();}}}}.

@3@ The expected value is assigned as follows:
{|class="wikitable"
!Value of&lt;br&gt;{{nbsp}}{{rlpf|operator bool|has_value}}{{nbsp}}
!Equivalent to
|-
|style="text-align: center;"|{{c|true}}
|{{box|{{tti|val}}{{nbspt}}{{c/core|1== std::forward&lt;U&gt;(v);}}}}
|-
|style="text-align: center;"|{{c|false}}
|{{box|{{tti|reinit-expected}}{{c/core|(}}{{tti|val}}{{c/core|,}}{{nbspt}}{{tti|unex}}{{c/core|, std::forward&lt;U&gt;(v));}}&lt;br&gt;{{tti|has_val}}{{nbspt}}{{c/core|1== false;}}}}
|}

@4,5@ The unexpected value is assigned as follows:
{|class="wikitable"
!{{nbsp}}Overload{{nbsp}}
!Value of&lt;br&gt;{{nbsp}}{{rlpf|operator bool|has_value}}{{nbsp}}
!Equivalent to
|-
|rowspan=2 style="text-align: center;"|{{vl|4}}
|style="text-align: center;"|{{c|true}}
|{{box|{{tti|reinit-expected}}{{c/core|(}}{{tti|val}}{{c/core|,}}{{nbspt}}{{tti|unex}}{{c/core|, std::forward&lt;const G&amp;&gt;(e.error()));}}&lt;br&gt;{{tti|has_val}}{{nbspt}}{{c/core|1== false;}}}}
|-
|style="text-align: center;"|{{c|false}}
|{{box|{{tti|unex}}{{nbspt}}{{c/core|1== std::forward&lt;const G&amp;&gt;(e.error());}}}}
|-
|rowspan=2 style="text-align: center;"|{{vl|5}}
|style="text-align: center;"|{{c|true}}
|{{box|{{tti|reinit-expected}}{{c/core|(}}{{tti|val}}{{c/core|,}}{{nbspt}}{{tti|unex}}{{c/core|, std::forward&lt;G&gt;(e.error()));}}&lt;br&gt;{{tti|has_val}}{{nbspt}}{{c/core|1== false;}}}}
|-
|style="text-align: center;"|{{c|false}}
|{{box|{{tti|unex}}{{nbspt}}{{c/core|1== std::forward&lt;G&gt;(e.error());}}}}
|}

===={{c/core|void}} partial specialization assignment operators====
@6@ The unexpected value is assigned or destroyed as follows:
{|class="wikitable"
!rowspan=2|Value of&lt;br&gt;{{nbsp}}{{rlpf|operator bool|has_value}}{{nbsp}}
!colspan=2|Value of {{c|other.has_value()}}
|-
!style="font-weight: normal;"|{{c|true}}
!style="font-weight: normal;"|{{c|false}}
|-
|style="text-align: center;"|{{c|true}}
|(no effects)
|{{box|{{c/core|std::construct_at}}&lt;br&gt;{{nbspt|4}}{{c/core|(std::addressof(}}{{tti|unex}}{{c/core|), rhs.}}{{tti|unex}}{{c/core|);}}&lt;br&gt;{{tti|has_val}}{{nbspt}}{{c/core|1== false;}}}}
|-
|style="text-align: center;"|{{c|false}}
|{{box|{{c/core|std::destroy_at(std::addressof(}}{{tti|unex}}{{c/core|));}}&lt;br&gt;{{tti|has_val}}{{nbspt}}{{c/core|1== true;}}}}
|{{box|{{tti|unex}}{{nbspt}}{{c/core|1== other.error();}}}}
|}

@7@ The unexpected value is assigned or destroyed as follows:
{|class="wikitable"
!rowspan=2|Value of&lt;br&gt;{{nbsp}}{{rlpf|operator bool|has_value}}{{nbsp}}
!colspan=2|Value of {{c|other.has_value()}}
|-
!style="font-weight: normal;"|{{c|true}}
!style="font-weight: normal;"|{{c|false}}
|-
|style="text-align: center;"|{{c|true}}
|(no effects)
|{{box|{{c/core|std::construct_at}}&lt;br&gt;{{nbspt|4}}{{c/core|(std::addressof(}}{{tti|unex}}{{c/core|),}}&lt;br&gt;{{nbspt|5}}{{c/core|std::move(rhs.}}{{tti|unex}}{{c/core|));}}&lt;br&gt;{{tti|has_val}}{{nbspt}}{{c/core|1== false;}}}}
|-
|style="text-align: center;"|{{c|false}}
|{{box|{{c/core|std::destroy_at(std::addressof(}}{{tti|unex}}{{c/core|));}}&lt;br&gt;{{tti|has_val}}{{nbspt}}{{c/core|1== true;}}}}
|{{box|{{tti|unex}}{{nbspt}}{{c/core|1== std::move(other.error());}}}}
|}

@8,9@ The unexpected value is assigned as follows:
{|class="wikitable"
!{{nbsp}}Overload{{nbsp}}
!Value of&lt;br&gt;{{nbsp}}{{rlpf|operator bool|has_value}}{{nbsp}}
!Equivalent to
|-
|rowspan=2 style="text-align: center;"|{{vl|8}}
|style="text-align: center;"|{{c|true}}
|{{box|{{c/core|std::construct_at(std::addressof(}}{{tti|unex}}{{c/core|),}}&lt;br&gt;{{nbspt|18}}{{c/core|std::forward&lt;const G&amp;&gt;(e.error()));}}&lt;br&gt;{{tti|has_val}}{{nbspt}}{{c/core|1== false;}}}}
|-
|style="text-align: center;"|{{c|false}}
|{{box|{{tti|unex}}{{nbspt}}{{c/core|1== std::forward&lt;const G&amp;&gt;(e.error());}}}}
|-
|rowspan=2 style="text-align: center;"|{{vl|9}}
|style="text-align: center;"|{{c|true}}
|{{box|{{c/core|std::construct_at(std::addressof(}}{{tti|unex}}{{c/core|), std::forward&lt;G&gt;(e.error()));}}&lt;br&gt;{{tti|has_val}}{{nbspt}}{{c/core|1== false;}}}}
|-
|style="text-align: center;"|{{c|false}}
|{{box|{{tti|unex}}{{nbspt}}{{c/core|1== std::forward&lt;G&gt;(e.error());}}}}
|}

====Helper function template====
The exposition-only function template {{tti|reinit-expected}} is “defined” as follows:
{{source|1=
template&lt;class NewType, class OldType, class... Args&gt;
constexpr void reinit-expected(NewType&amp; new_val, OldType&amp; old_val, Args&amp;&amp;... args)
{
    // Case 1: the construction of “new_val” is non-throwing:
    // “new_val” can be directly constructed after destroying “old_val”
    if constexpr (std::is_nothrow_constructible_v&lt;NewType, Args...&gt;)
    {
        std::destroy_at(std::addressof(old_val));
        std::construct_at(std::addressof(new_val), std::forward&lt;Args&gt;(args)...);
    }
    // Case 2: the move construction of “new_val” is non-throwing:
    // constuct a temporary NewType object first
    // (“old_val” is left intact if an exception is thrown from this construction)
    else if constexpr (std::is_nothrow_move_constructible_v&lt;NewType&gt;)
    {
        NewType temp(std::forward&lt;Args&gt;(args)...); // may throw
        std::destroy_at(std::addressof(old_val));
        std::construct_at(std::addressof(new_val), std::move(temp));
    }
    // Case 3: the construction of “new_val” is potentially-throwing:
    // a backup of “old_val” is required in order to recover from an exception
    else
    {
        OldType temp(std::move(old_val)); // may throw
        std::destroy_at(std::addressof(old_val));
        try
        {
            std::construct_at(std::addressof(new_val),
                              std::forward&lt;Args&gt;(args)...); // may throw
        }
        catch (...)
        {
            std::construct_at(std::addressof(old_val), std::move(temp));
            throw;
        }
    }
}
}}

This function template is called when the assignment is going to make {{c|*this}} hold the alternative value (i.e. from expected value to unexpected value, or from unexpected value to expected value).

In this case, the old value {{c|oldval}} needs to be destroyed before constructing the new value {{c|newval}}. However, the construction of {{c|newval}} may throw an exception. In order to provide [[cpp/language/exceptions#Exception safety|strong exception safety guarantee]], the old value needs to be restored before rethrowing the exception so that {{c|*this}} will have a valid state while the exception is being handled.

===Return value===
@1-9@ {{c|*this}}

===Constraints and supplement information===
====Primary template assignment operators====
@1@ This overload is defined as deleted unless all following values are {{c|true}}:
* {{c|std::is_copy_assignable_v&lt;T&gt;}}
* {{c|std::is_copy_constructible_v&lt;T&gt;}}
* {{c|std::is_copy_assignable_v&lt;E&gt;}}
* {{c|std::is_copy_constructible_v&lt;E&gt;}}
* {{c|std::is_nothrow_move_constructible_v&lt;T&gt; {{!!}} std::is_nothrow_move_constructible_v&lt;E&gt;}}

@2@ {{cpp/enable if|all following values are {{c|true}}}}:
* {{c|std::is_move_assignable_v&lt;T&gt;}}
* {{c|std::is_move_constructible_v&lt;T&gt;}}
* {{c|std::is_move_assignable_v&lt;E&gt;}}
* {{c|std::is_move_constructible_v&lt;E&gt;}}
* {{c|std::is_nothrow_move_constructible_v&lt;T&gt; {{!!}} std::is_nothrow_move_constructible_v&lt;E&gt;}}

@3@ {{cpp/enable if|all following conditions are satisfied}}:
* {{c|std::is_same_v&lt;expected, std::remove_cvref_t&lt;U&gt;&gt;}} is {{c|false}}.
* {{c|std::remove_cvref_t&lt;U&gt;}} is not a specialization of {{tt|std::unexpected}}.
* All following values are {{c|true}}:
** {{c|std::is_constructible_v&lt;T, U&gt;}}
** {{c|std::is_assignable_v&lt;T&amp;, U&gt;}}
** {{c multi|std::is_nothrow_constructible_v&lt;T, U&gt; {{!!}} std::is_nothrow_move_constructible_v&lt;T&gt; {{!!}}|std::is_nothrow_move_constructible_v&lt;E&gt;}}

@4@ {{cpp/enable if|all following values are {{c|true}}}}:
* {{c|std::is_constructible_v&lt;E, const G&amp;&gt;}}
* {{c|std::is_assignable_v&lt;E&amp;, const G&amp;&gt;}}
* {{c multi|std::is_nothrow_constructible_v&lt;E, const G&amp;&gt; {{!!}} std::is_nothrow_move_constructible_v&lt;T&gt; {{!!}}|std::is_nothrow_move_constructible_v&lt;E&gt;}}

@5@ {{cpp/enable if|all following values are {{c|true}}}}:
* {{c|std::is_constructible_v&lt;E, G&gt;}}
* {{c|std::is_assignable_v&lt;E&amp;, G&gt;}}
* {{c multi|std::is_nothrow_constructible_v&lt;E, G&gt; {{!!}} std::is_nothrow_move_constructible_v&lt;T&gt; {{!!}}|std::is_nothrow_move_constructible_v&lt;E&gt;}}

===={{c/core|void}} partial specialization assignment operators====
@6@ This overload is defined as deleted unless {{c|std::is_copy_assignable_v&lt;E&gt;}} and {{c|std::is_copy_constructible_v&lt;E&gt;}} are both {{c|true}}.

@7@ {{cpp/enable if|{{c|std::is_move_constructible_v&lt;E&gt;}} and {{c|std::is_move_assignable_v&lt;E&gt;}} are both {{c|true}}}}.

@8@ {{cpp/enable if|{{c|std::is_constructible_v&lt;E, const G&amp;&gt;}} and {{c|std::is_assignable_v&lt;E&amp;, const G&amp;&gt;}} are both {{c|true}}}}.

@9@ {{cpp/enable if|{{c|std::is_constructible_v&lt;E, G&gt;}} and {{c|std::is_assignable_v&lt;E&amp;, G&gt;}} are both {{c|true}}}}.

===Exceptions===
@2@ {{noexcept|
    std::is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; std::is_nothrow_move_assignable_v&lt;T&gt; &amp;&amp;
    std::is_nothrow_move_constructible_v&lt;E&gt; &amp;&amp; std::is_nothrow_move_assignable_v&lt;E&gt;}}

@7@ {{noexcept|std::is_nothrow_move_constructible_v&lt;E&gt; &amp;&amp; std::is_nothrow_move_assignable_v&lt;E&gt;}}

===Example===
{{example}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=4025|std=C++23|before=overload {{v|7}} was defined as deleted if {{tt|E}} is not&lt;br&gt;move constructible or not move assignable|after=it does not participate in&lt;br&gt;overload resolution in this case}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/expected/dsc emplace}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}