{{ctitle|va_arg}}
{{cpp/utility/variadic/navbar}}
{{ddcl|header=cstdarg|
T va_arg( std::va_list ap, T );
}}

The {{tt|va_arg}} macro expands to an expression of type {{c|T}} that corresponds to the next parameter from the {{lc|va_list}} {{c|ap}}.

Prior to calling {{tt|va_arg}}, {{c|ap}} must be initialized by a call to either {{lc|va_start}} or {{lc|va_copy}}, with no intervening call to {{lc|va_end}}. Each invocation of the {{tt|va_arg}} macro modifies {{c|ap}} to point to the next variable argument.

If the type of the next argument in {{c|ap}} (after promotions) is not {{lt|c/language/type#Compatible types|compatible}} with {{c|T}}, the behavior is undefined, unless:

* one type is a signed integer type, the other type is the corresponding unsigned integer type, and the value is representable in both types; or
* one type is pointer to {{c/core|void}} and the other is a pointer to a character type ({{c/core|char}}, {{c/core|signed char}}, or {{c/core|unsigned char}}).

If {{tt|va_arg}} is called when there are no more arguments in {{c|ap}}, the behavior is undefined.

===Parameters===
{{par begin}}
{{par|ap|an instance of the {{lc|va_list}} type}}
{{par|T|the type of the next parameter in {{c|ap}}}}
{{par end}}

===Expanded value===
The next variable parameter in {{c|ap}}.

===Example===
{{example
|code=
#include &lt;cstdarg&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;

void print_variance(std::size_t count, const char* fmt, ...)
{
    double sum = 0;
    double sum_sq = 0;
    std::va_list args;
    va_start(args, fmt);
    for (std::size_t i = count; i--;)
    {
        double num = va_arg(args, double);
        sum += num;
        sum_sq += num*num;
    }
    va_end(args);
    std::printf(fmt, sum_sq / count - (sum / count) * (sum / count));
}

void nano_printf(const char* fmt, ...)
{
    std::va_list args;
    va_start(args, fmt);

    for (const char* p = fmt; *p != '\0'; ++p)
    {
        switch (*p)
        {
        case '%':
            switch (*++p) // read format symbol
            {
                case 'i':
                    std::cout &lt;&lt; va_arg(args, int);
                    continue;
                case 'f':
                    std::cout &lt;&lt; va_arg(args, double);
                    continue;
                case 's':
                    std::cout &lt;&lt; va_arg(args, const char*);
                    continue;
                case 'c':
                    std::cout &lt;&lt; static_cast&lt;char&gt;(va_arg(args, int));
                    continue;
                case '%':
                    std::cout &lt;&lt; '%';
                    continue;
                /* ...more cases... */
            }
            break; // format error...
        case '\n':
            std::cout &lt;&lt; '\n';
            continue;
        case '\t':
            std::cout &lt;&lt; '\t';
            continue;
        /* ...more cases... */
        }
        std::cout &lt;&lt; *p;
    }

    va_end(args);
}

int main()
{
    print_variance(4, "%f\n", 25.0, 27.3, 26.9, 25.7);
    nano_printf("Args: %i%% %c%f %s\n", 42, '#', 3.14, "C++");
}
|output=
0.846875
Args: 42% #3.14 C++
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/variadic/dsc va_start}}
{{dsc inc|cpp/utility/variadic/dsc va_copy}}
{{dsc inc|cpp/utility/variadic/dsc va_end}}
{{dsc see c|c/variadic/va_arg|va_arg}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}