{{cpp/utility/optional/title|value}}
{{cpp/utility/optional/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++17|1=
constexpr T&amp; value() &amp;;
constexpr const T&amp; value() const &amp;;
}}
{{dcl|num = 2|since=c++17|1=
constexpr T&amp;&amp; value() &amp;&amp;;
constexpr const T&amp;&amp; value() const &amp;&amp;;
}}
{{dcl end}}

If {{c|*this}} contains a value, returns a reference to the contained value.

Otherwise, throws a {{lc|std::bad_optional_access}} exception.

===Parameters===
(none)

===Return value===
A reference to the contained value.

===Exceptions===
{{lc|std::bad_optional_access}} if {{c|*this}} does not contain a value.

===Notes===
The dereference operator {{lc|operator*()}} does not check if this optional contains a value, which may be more efficient than {{tt|value()}}.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;optional&gt;

int main()
{
    std::optional&lt;int&gt; opt = {};
 
    try
    {
        [[maybe_unused]] int n = opt.value();
    }
    catch(const std::bad_optional_access&amp; e)
    {
        std::cout &lt;&lt; e.what() &lt;&lt; '\n';
    }
    
    try
    {
        opt.value() = 42;
    }
    catch(const std::bad_optional_access&amp; e)
    {
        std::cout &lt;&lt; e.what() &lt;&lt; '\n';
    }

    opt = 43;
    std::cout &lt;&lt; *opt &lt;&lt; '\n';

    opt.value() = 44;
    std::cout &lt;&lt; opt.value() &lt;&lt; '\n';
}
&lt;!--|p=true --&gt;
|output=
bad optional access
bad optional access
43
44
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/optional/dsc value_or}}
{{dsc inc|cpp/utility/optional/dsc operator*}}
{{dsc inc|cpp/utility/optional/dsc bad_optional_access}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}