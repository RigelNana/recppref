{{cpp/utility/optional/title|swap}}
{{cpp/utility/optional/navbar}}
{{ddcl|since=c++17|notes={{mark constexpr since c++20}}&lt;!-- P2231R1 --&gt;|
void swap( optional&amp; other ) noexcept(/* see below */);
}}

Swaps the contents with those of {{c|other}}.

* If neither {{c|*this}} nor {{c|other}} contain a value, the function has no effect.

* If only one of {{c|*this}} and {{c|other}} contains a value (let's call this object {{tt|in}} and the other {{tt|un}}), the contained value of {{tt|un}} is [[cpp/language/direct_initialization|direct-initialized]] from {{c|std::move(*in)}}, followed by destruction of the contained value of {{tt|in}} as if by {{c|in-&gt;T::~T()}}. After this call, {{tt|in}} does not contain a value; {{tt|un}} contains a value.

* If both {{c|*this}} and {{c|other}} contain values, the contained values are exchanged by calling {{c|using std::swap; swap(**this, *other)}}.

The program is ill-formed unless type {{tt|T}} is {{named req|Swappable}} and {{c|std::is_move_constructible_v&lt;T&gt;}} is {{c|true}}.

===Parameters===
{{par begin}}
{{par|other|the {{tt|optional}} object to exchange the contents with}}
{{par end}}

===Return value===
(none)

===Exceptions===
{{noexcept|std::is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp;
         std::is_nothrow_swappable_v&lt;T&gt;}}

In the case of thrown exception, the states of the contained values of {{c|*this}} and {{c|other}} are determined by the exception safety guarantees of {{tt|swap}} of type {{tt|T}} or {{tt|T}}'s move constructor, whichever is called. For both {{c|*this}} and {{c|other}}, if the object contained a value, it is left containing a value, and the other way round.

{{ftm begin}}
{{ftm|std=C++20|dr=20|value=202106L|__cpp_lib_optional|Fully {{c/core|constexpr}}}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;optional&gt;
#include &lt;string&gt;

int main()
{
    std::optional&lt;std::string&gt; opt1("First example text");
    std::optional&lt;std::string&gt; opt2("2nd text");

    enum Swap { Before, After };
    auto print_opts = [&amp;](Swap e)
    {
        std::cout &lt;&lt; (e == Before ? "Before swap:\n" : "After swap:\n");
        std::cout &lt;&lt; "opt1 contains '" &lt;&lt; opt1.value_or("") &lt;&lt; "'\n";
        std::cout &lt;&lt; "opt2 contains '" &lt;&lt; opt2.value_or("") &lt;&lt; "'\n";
        std::cout &lt;&lt; (e == Before ? "---SWAP---\n": "\n");
    };

    print_opts(Before);
    opt1.swap(opt2);
    print_opts(After);

    // Swap with only 1 set
    opt1 = "Lorem ipsum dolor sit amet, consectetur tincidunt.";
    opt2.reset();

    print_opts(Before);
    opt1.swap(opt2);
    print_opts(After);
}
|output=
Before swap:
opt1 contains 'First example text'
opt2 contains '2nd text'
---SWAP---
After swap:
opt1 contains '2nd text'
opt2 contains 'First example text'

Before swap:
opt1 contains 'Lorem ipsum dolor sit amet, consectetur tincidunt.'
opt2 contains ''
---SWAP---
After swap:
opt1 contains ''
opt2 contains 'Lorem ipsum dolor sit amet, consectetur tincidunt.'
}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P2231R1|std=C++20|before={{tt|swap}} was not {{c/core|constexpr}} while the required operations can be {{c/core|constexpr}} in C++20|after=made {{c/core|constexpr}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/optional/dsc swap2}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}