{{cpp/title|hash{{small|&lt;std::optional&gt;}}}}
{{cpp/utility/optional/navbar}}
{{ddcl|header=optional|since=c++17|1=
template&lt; class T &gt;
struct hash&lt;std::optional&lt;T&gt;&gt;;
}}

The template specialization of {{lc|std::hash}} for the {{lc|std::optional}} class allows users to obtain hashes of the values contained in {{tt|optional}} objects.

The specialization {{box|{{tt|std::hash}}{{co|&lt;std::optional&lt;T&gt;&gt;}}}} is enabled (see {{lc|std::hash}}) if {{c|std::hash&lt;std::remove_const_t&lt;T&gt;&gt;}} is enabled, and is disabled otherwise.

When enabled, for an object {{tt|o}} of type {{c|std::optional&lt;T&gt;}} that contains a value, {{box|{{tt|std::hash}}{{co|&lt;std::optional&lt;T&gt;&gt;()(o)}}}} evaluates to the same value as {{c|std::hash&lt;std::remove_const_t&lt;T&gt;&gt;()(*o)}}. For an optional that does not contain a value, the hash is unspecified.

The member functions of this specialization are not guaranteed to be noexcept because the hash of the underlying type might throw.

===Template parameters===
{{par begin}}
{{par|T|the type of the value contained in {{tt|optional}} object}}
{{par end}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;optional&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;

using namespace std::literals;

int main()
{
    using OptStr = std::optional&lt;std::string&gt;;

    // hash&lt;optional&gt; makes it possible to use unordered_set
    std::unordered_set&lt;OptStr&gt; s =
    {
        "ABC"s, "abc"s, std::nullopt, "def"s
    };

    for (const auto&amp; o : s)
        std::cout &lt;&lt; o.value_or("(null)") &lt;&lt; '\t' &lt;&lt; std::hash&lt;OptStr&gt;{}(o) &lt;&lt; '\n';
}
|p=true
|output=
def     11697390762615875584
(null)  18446744073709548283
abc     3663726644998027833
ABC     11746482041453314842
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/dsc hash}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}