{{cpp/utility/optional/title|operator{{=}}}}
{{cpp/utility/optional/navbar}}
{{dcl begin}}
{{dcla|num=1|since=c++17|constexpr=c++20|1=
optional&amp; operator=( std::nullopt_t ) noexcept;
}}
{{dcla|num=2|since=c++17|1=
constexpr optional&amp; operator=( const optional&amp; other );
}}
{{dcl|num=3|since=c++17|1=
constexpr optional&amp; operator=( optional&amp;&amp; other ) noexcept(/* see below */);
}}
{{dcla|num=4|since=c++17|constexpr=c++20|1=
template&lt; class U = T &gt;
optional&amp; operator=( U&amp;&amp; value );
}}
{{dcla|num=5|since=c++17|constexpr=c++20|1=
template&lt; class U &gt;
optional&amp; operator=( const optional&lt;U&gt;&amp; other );
}}
{{dcla|anchor=no|num=6|since=c++17|constexpr=c++20|1=
template&lt; class U &gt;
optional&amp; operator=( optional&lt;U&gt;&amp;&amp; other );
}}
{{dcl end}}

Replaces contents of {{c|*this}} with the contents of {{c|other}}.

@1@ If {{c|*this}} contains a value before the call, the contained value is destroyed by calling its destructor as if by {{c|value().T::~T()}}. {{c|*this}} does not contain a value after this call.

@2,3@ Assigns the state of {{c|other}}.&lt;br&gt;
* If both {{c|*this}} and {{c|other}} do not contain a value, the function has no effect.
* If {{c|*this}} contains a value, but {{c|other}} does not, then the contained value is destroyed by calling its destructor. {{c|*this}} does not contain a value after the call.
* If {{c|other}} contains a value, then depending on whether {{c|*this}} contains a value, the contained value is either [[cpp/language/direct initialization|direct-initialized]] or assigned from {{c|*other}} {{v|2}} or {{c|std::move(*other)}} {{v|3}}. Note that a moved-from optional still ''contains a value''.
* Overload {{v|2}} is deleted when either {{c|std::is_copy_constructible_v&lt;T&gt;}} or {{c|std::is_copy_assignable_v&lt;T&gt;}} is {{c|false}}. It is trivial if {{c|std::is_trivially_copy_constructible_v&lt;T&gt;}}, {{c|std::is_trivially_copy_assignable_v&lt;T&gt;}} and {{c|std::is_trivially_destructible_v&lt;T&gt;}} are all {{c|true}}.
* Overload {{v|3}} does not participate in overload resolution when either {{c|std::is_move_constructible_v&lt;T&gt;}} or {{c|std::is_move_assignable_v&lt;T&gt;}} is {{c|false}}. It is trivial if {{c|std::is_trivially_move_constructible_v&lt;T&gt;}}, {{c|std::is_trivially_move_assignable_v&lt;T&gt;}} and {{c|std::is_trivially_destructible_v&lt;T&gt;}} are all {{c|true}}.

@4@ Perfect-forwarded assignment: depending on whether {{c|*this}} contains a value before the call, the contained value is either direct-initialized from {{c|std::forward&lt;U&gt;(value)}} or assigned from {{c|std::forward&lt;U&gt;(value)}}. The function does not participate in overload resolution unless {{rev inl|until=c++20|{{c|std::decay_t&lt;U&gt;}}}}{{rev inl|since=c++20|{{c|std::remove_cvref_t&lt;U&gt;}}}} is not {{c|std::optional&lt;T&gt;}}, {{c|std::is_constructible_v&lt;T, U&gt;}} is {{c|true}}, {{c|std::is_assignable_v&lt;T&amp;, U&gt;}} is {{c|true}}, and at least one of the following is true:&lt;br&gt;
* {{tt|T}} is not a [[cpp/language/type|scalar type]];
* {{c|std::decay_t&lt;U&gt;}} is not {{tt|T}}.

@5,6@ Assigns the state of {{c|other}}.&lt;br&gt;
* If both {{c|*this}} and {{c|other}} do not contain a value, the function has no effect.
* If {{c|*this}} contains a value, but {{c|other}} does not, then the contained value is destroyed by calling its destructor. {{c|*this}} does not contain a value after the call.
* If {{c|other}} contains a value, then depending on whether {{c|*this}} contains a value, the contained value is either [[cpp/language/direct_initialization|direct-initialized]] or assigned from {{c|*other}} {{v|5}} or {{c|std::move(*other)}} {{v|6}}. Note that a moved-from optional still ''contains a value''.
* These overloads do not participate in overload resolution unless the following conditions are met:
** {{tt|T}} is not constructible, convertible, or assignable from any expression of type (possibly {{c/core|const}}) {{c|std::optional&lt;U&gt;}}, i.e., the following 12 type traits are all {{c|false}}:
*** {{c|std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&gt;}}
*** {{c|std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&gt;}}
*** {{c|std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;}}
*** {{c|std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;}}
*** {{c|std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;, T&gt;}}
*** {{c|std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;, T&gt;}}
*** {{c|std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;}}
*** {{c|std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;}}
*** {{c|std::is_assignable_v&lt;T&amp;, std::optional&lt;U&gt;&amp;&gt;}}
*** {{c|std::is_assignable_v&lt;T&amp;, const std::optional&lt;U&gt;&amp;&gt;}}
*** {{c|std::is_assignable_v&lt;T&amp;, std::optional&lt;U&gt;&amp;&amp;&gt;}}
*** {{c|std::is_assignable_v&lt;T&amp;, const std::optional&lt;U&gt;&amp;&amp;&gt;}}
** For overload {{v|5}}, {{c|std::is_constructible_v&lt;T, const U&amp;&gt;}} and {{c|std::is_assignable_v&lt;T&amp;, const U&amp;&gt;}} are both {{c|true}}.
** For overload {{v|6}}, {{c|std::is_constructible_v&lt;T, U&gt;}} and {{c|std::is_assignable_v&lt;T&amp;, U&gt;}} are both {{c|true}}.

===Parameters===
{{par begin}}
{{par|other|another {{tt|optional}} object whose contained value to assign}}
{{par|value|value to assign to the contained value}}
{{par end}}

===Return value===
{{c|*this}}

===Exceptions===
@2-6@ Throws any exception thrown by the constructor or assignment operator of {{tt|T}}. If an exception is thrown, the initialization state of {{c|*this}} (and of {{c|other}} in case of {{vl|2,3}} and {{vl|5,6}}) is unchanged, i.e. if the object contained a value, it still contains a value, and the other way round. The contents of {{c|value}} and the contained values of {{c|*this}} and {{c|other}} depend on the exception safety guarantees of the operation from which the exception originates (copy-constructor, move-assignment, etc.).

@3@ Has following {{noexcept|std::is_nothrow_move_assignable_v&lt;T&gt; &amp;&amp; std::is_nothrow_move_constructible_v&lt;T&gt;}}

===Notes===
An optional object {{tt|op}} may be turned into an empty optional with both {{c|1=op = {};}} and {{c|1=op = nullopt;}}. The first expression constructs an empty {{c|optional}} object with {{c|{}&lt;!----&gt;}} and assigns it to {{tt|op}}.

{{ftm begin}}
{{ftm|std=C++20|dr=20|value=202106L|__cpp_lib_optional|Fully {{c/core|constexpr}} {{vl|1}}, {{vl|4-6}}}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;optional&gt;

int main()
{
    std::optional&lt;const char*&gt; s1 = "abc", s2; // constructor
    s2 = s1; // assignment
    s1 = "def"; // decaying assignment (U = char[4], T = const char*)
    std::cout &lt;&lt; *s2 &lt;&lt; ' ' &lt;&lt; *s1 &lt;&lt; '\n';
}
|output=
abc def
}}

===Defect reports===
{{dr list begin}}
{{dr list item|paper=P0602R4|std=C++17|before=copy/move assignment operator may not be trivial&lt;br&gt;even if underlying operations are trivial|after=required to propagate triviality}}
{{dr list item|paper=P2231R1|std=C++20|before=converting assignment operators {{vl|1}} and {{vl|4-6}} were not {{c/core|constexpr}}&lt;br&gt;while the required operations can be in C++20|after=made {{c/core|constexpr}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/optional/dsc emplace}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}