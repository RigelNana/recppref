{{cpp/utility/optional/title|optional}}
{{cpp/utility/optional/navbar}}
{{dcl begin}}
{{dcl|num=1|since=c++17|
constexpr optional() noexcept;
constexpr optional( std::nullopt_t ) noexcept;
}}
{{dcl|num=2|since=c++17|
constexpr optional( const optional&amp; other );
}}
{{dcl|num=3|since=c++17|
constexpr optional( optional&amp;&amp; other ) noexcept(/* see below */);
}}
{{dcla|num=4|since=c++17|constexpr=c++20|notes={{mark|conditionally explicit}}|
template &lt; class U &gt;
optional( const optional&lt;U&gt;&amp; other );
}}
{{dcla|num=5|since=c++17|constexpr=c++20|notes={{mark|conditionally explicit}}|
template &lt; class U &gt;
optional( optional&lt;U&gt;&amp;&amp; other );
}}
{{dcl|num=6|since=c++17|
template&lt; class... Args &gt;
constexpr explicit optional( std::in_place_t, Args&amp;&amp;... args );
}}
{{dcl|num=7|since=c++17|
template&lt; class U, class... Args &gt;
constexpr explicit optional( std::in_place_t,
                             std::initializer_list&lt;U&gt; ilist,
                             Args&amp;&amp;... args );
}}
{{dcla|num=8|since=c++17|notes={{mark|conditionally explicit}}|1=
template &lt; class U = T &gt;
constexpr optional( U&amp;&amp; value );
}}
{{dcl end}}

Constructs a new optional object.

@1@ Constructs an object that ''does not contain'' a value.

@2@ Copy constructor: If {{c|other}} contains a value, initializes the contained value as if [[cpp/language/direct initialization|direct-initializing]] (but not direct-list-initializing) an object of type {{tt|T}} with the expression {{c|*other}}. If {{c|other}} does not contain a value, constructs an object that ''does not contain'' a value.
* This constructor is defined as deleted if {{c|std::is_copy_constructible_v&lt;T&gt;}} is {{c|false}}.
* It is a trivial constructor if {{c|std::is_trivially_copy_constructible_v&lt;T&gt;}} is {{c|true}}.

@3@ Move constructor: If {{c|other}} contains a value, initializes the contained value as if [[cpp/language/direct initialization|direct-initializing]] (but not direct-list-initializing) an object of type {{tt|T}} with the expression {{c|std::move(*other)}} and ''does not'' make {{c|other}} empty: a moved-from {{tt|std::optional}} still ''contains'' a value, but the value itself is moved from. If {{c|other}} does not contain a value, constructs an object that ''does not contain'' a value.
* This constructor does not participate in overload resolution unless {{c|std::is_move_constructible_v&lt;T&gt;}} is {{c|true}}.
* It is a trivial constructor if {{c|std::is_trivially_move_constructible_v&lt;T&gt;}} is {{c|true}}.

@4@ Converting copy constructor: If {{c|other}} does not contain a value, constructs an optional object that ''does not contain'' a value. Otherwise, constructs an optional object that ''contains'' a value, initialized as if [[cpp/language/direct initialization|direct-initializing]] (but not direct-list-initializing) an object of type {{tt|T}} with the expression {{c|*other}}.
* This constructor does not participate in overload resolution unless the following conditions are met:
** {{c|std::is_constructible_v&lt;T, const U&amp;&gt;}} is {{c|true}}.
** If {{tt|T}} is not (possibly cv-qualified) {{c/core|bool}}, {{tt|T}} is not constructible or convertible from any expression of type (possibly {{c/core|const}}) {{c/core|std::optional&lt;U&gt;}}, i.e., the following 8 values are all {{c|false}}:
*** {{c|std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&gt;}}
*** {{c|std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&gt;}}
*** {{c|std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;}}
*** {{c|std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;}}
*** {{c|std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;, T&gt;}}
*** {{c|std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;, T&gt;}}
*** {{c|std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;}}
*** {{c|std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;}}
* This constructor is {{c/core|explicit}} if and only if {{c|std::is_convertible_v&lt;const U&amp;, T&gt;}} is {{c|false}}.

@5@ Converting move constructor: If {{c|other}} does not contain a value, constructs an optional object that ''does not contain'' a value. Otherwise, constructs an optional object that ''contains'' a value, initialized as if [[cpp/language/direct initialization|direct-initializing]] (but not direct-list-initializing) an object of type {{tt|T}} with the expression {{c|std::move(*other)}}.
* This constructor does not participate in overload resolution unless the following conditions are met:
** {{c|std::is_constructible_v&lt;T, U&amp;&amp;&gt;}} is {{c|true}}.
** If {{tt|T}} is not (possibly cv-qualified) {{c/core|bool}}, {{tt|T}} is not constructible or convertible from any expression of type (possibly {{c/core|const}}) {{c/core|std::optional&lt;U&gt;}}, i.e., the following 8 values are all {{c|false}}:
*** {{c|std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&gt;}}
*** {{c|std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&gt;}}
*** {{c|std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;}}
*** {{c|std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;}}
*** {{c|std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;, T&gt;}}
*** {{c|std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;, T&gt;}}
*** {{c|std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;}}
*** {{c|std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;}}
* This constructor is {{c/core|explicit}} if and only if {{c|std::is_convertible_v&lt;U&amp;&amp;, T&gt;}} is {{c|false}}.

@6@ Constructs an optional object that ''contains'' a value, initialized as if [[cpp/language/direct initialization|direct-initializing]] (but not direct-list-initializing) an object of type {{tt|T}} from the arguments {{c|std::forward&lt;Args&gt;(args)...}}.
* If the selected constructor of {{tt|T}} is a {{c/core|constexpr}} constructor, this constructor is a {{c/core|constexpr}} constructor.
* The function does not participate in the overload resolution unless {{c|std::is_constructible_v&lt;T, Args...&gt;}} is {{c|true}}.

@7@ Constructs an optional object that ''contains'' a value, initialized as if [[cpp/language/direct initialization|direct-initializing]] (but not direct-list-initializing) an object of type {{tt|T}} from the arguments {{c|ilist, std::forward&lt;Args&gt;(args)...}}.
* If the selected constructor of {{tt|T}} is a {{c/core|constexpr}} constructor, this constructor is a {{c/core|constexpr}} constructor.
* The function does not participate in the overload resolution unless {{c|std::is_constructible_v&lt;T, std::initializer_list&lt;U&gt;&amp;, Args...&gt;}} is {{c|true}}.

@8@ Constructs an optional object that ''contains'' a value, initialized as if  [[cpp/language/direct initialization|direct-initializing]] (but not direct-list-initializing) an object of type {{tt|T}} with the expression {{c|std::forward&lt;U&gt;(value)}}.
* If the selected constructor of {{tt|T}} is a {{c/core|constexpr}} constructor, this constructor is a {{c/core|constexpr}} constructor.
* This constructor does not participate in overload resolution unless the following conditions are met:
** {{c|std::is_constructible_v&lt;T, U&amp;&amp;&gt;}} is {{c|true}}.
** {{rev inl|until=c++20|{{c/core|std::decay_t&lt;U&gt;}}}}{{rev inl|since=c++20|{{c/core|std::remove_cvref_t&lt;U&gt;}}}} is neither {{lc|std::in_place_t}} nor {{c/core|std::optional&lt;T&gt;}}.
** If {{tt|T}} is (possibly cv-qualified) {{c/core|bool}}, {{rev inl|until=c++20|{{c/core|std::decay_t&lt;U&gt;}}}}{{rev inl|since=c++20|{{c/core|std::remove_cvref_t&lt;U&gt;}}}} is not a specialization of {{tt|std::optional}}.
* This constructor is {{c/core|explicit}} if and only if {{c|std::is_convertible_v&lt;U&amp;&amp;, T&gt;}} is {{c|false}}.

===Parameters===
{{par begin}}
{{par|other|another optional object whose contained value is copied}}
{{par|value|value with which to initialize the contained value}}
{{par|args...|arguments with which to initialize the contained value}}
{{par|ilist|initializer list with which to initialize the contained value}}
{{par end}}

===Exceptions===
@2@ Throws any exception thrown by the constructor of {{tt|T}}.

@3@ Throws any exception thrown by the constructor of {{tt|T}}. Has the following {{noexcept|std::is_nothrow_move_constructible&lt;T&gt;::value}}

@4-8@ Throws any exception thrown by the constructor of {{tt|T}}.

===[[cpp/utility/optional/deduction guides|Deduction guides]]===

===Notes===
Before the resolution of {{lwg|3836}}, constructing an {{c/core|std::optional&lt;bool&gt;}} from {{c/core|std::optional&lt;U&gt;}} would select overload {{vl|8}} instead of overloads {{vl|4,5}} if {{tt|U}} is not {{c/core|bool}}. This is because overloads {{vl|4,5}} did not participate in overload resolution if {{tt|T}} ({{c/core|bool}} in this case) can be constructed or converted from {{c/core|std::optional&lt;U&gt;}}, but {{rlpt|operator bool|std::optional::operator bool}} makes the conversion possible for any {{tt|U}}.

As a result, the constructed {{c/core|std::optional&lt;bool&gt;}} always contains a value. That value is determined by whether the provided {{c/core|std::optional&lt;U&gt;}} object contains a value, rather than the {{c/core|bool}} value direct-initialized from the contained value:
{{source|
std::optional&lt;bool&gt; op_false(false);
std::optional&lt;int&gt; op_zero(0);

std::optional&lt;int&gt; from_bool(op_false); // OK: contains 0 (initialized from false)
std::optional&lt;bool&gt; from_int(op_zero);  // DEFECT (LWG 3836): contains true because
                                        // op_zero contains a value, even if initializing
                                        // bool from that value gives false
}}

{{ftm begin}}
{{ftm|std=C++20|dr=20|value=202106L|__cpp_lib_optional|Fully {{c/core|constexpr}} {{vl|4,5}}}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;optional&gt;
#include &lt;string&gt;

int main()
{
    std::optional&lt;int&gt; o1, // empty
                       o2 = 1, // init from rvalue
                       o3 = o2; // copy-constructor
    
    // calls std::string( initializer_list&lt;CharT&gt; ) constructor
    std::optional&lt;std::string&gt; o4(std::in_place, {'a', 'b', 'c'});
    
    // calls std::string( size_type count, CharT ch ) constructor
    std::optional&lt;std::string&gt; o5(std::in_place, 3, 'A');
    
    // Move-constructed from std::string using deduction guide to pick the type
    
    std::optional o6(std::string{"deduction"});
    
    std::cout &lt;&lt; *o2 &lt;&lt; ' ' &lt;&lt; *o3 &lt;&lt; ' ' &lt;&lt; *o4 &lt;&lt; ' ' &lt;&lt; *o5  &lt;&lt; ' ' &lt;&lt; *o6 &lt;&lt; '\n';
}
|output=
1 1 abc AAA deduction
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3836|std=C++17|before=when constructing an {{c/core|std::optional&lt;bool&gt;}}&lt;br&gt;from {{c/core|std::optional&lt;U&gt;}}, the overload resolution&lt;br&gt;would select overload {{vl|8}} if {{tt|U}} is not {{c/core|bool}}|after=always selects the&lt;br&gt;converting copy/move&lt;br&gt;constructor in this case}}
{{dr list item|paper=P0602R4|std=C++17|before=copy/move constructors might not be trivial&lt;br&gt;even if underlying constructor is trivial|after=required to&lt;br&gt;propagate triviality}}
{{dr list item|paper=P2231R1|std=C++20|before=converting constructors {{vl|4,5}} from another {{tt|std::optional}} was&lt;br&gt;not {{c/core|constexpr}} while the required operations can be in C++20|after=made {{c/core|constexpr}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/optional/dsc make_optional}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}