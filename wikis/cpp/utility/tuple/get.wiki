{{cpp/title|get{{petty|(std::tuple)}}}}
{{cpp/utility/tuple/navbar}}
{{dcl begin}}
{{dcl header|tuple}}
{{dcla|num=1|anchor=no|since=c++11|constexpr=c++14|
template&lt; std::size_t I, class... Types &gt;
typename std::tuple_element&lt;I, std::tuple&lt;Types...&gt;&gt;::type&amp;
    get( std::tuple&lt;Types...&gt;&amp; t ) noexcept;
}}
{{dcla|num=2|anchor=no|since=c++11|constexpr=c++14|
template&lt; std::size_t I, class... Types &gt;
typename std::tuple_element&lt;I, std::tuple&lt;Types...&gt;&gt;::type&amp;&amp;
    get( std::tuple&lt;Types...&gt;&amp;&amp; t ) noexcept;
}}
{{dcla|num=3|anchor=no|since=c++11|constexpr=c++14|
template&lt; std::size_t I, class... Types &gt;
const typename std::tuple_element&lt;I, std::tuple&lt;Types...&gt;&gt;::type&amp;
    get( const std::tuple&lt;Types...&gt;&amp; t ) noexcept;
}}
{{dcla|num=4|since=c++11|constexpr=c++14|
template&lt; std::size_t I, class... Types &gt;
const typename std::tuple_element&lt;I, std::tuple&lt;Types...&gt;&gt;::type&amp;&amp;
    get( const std::tuple&lt;Types...&gt;&amp;&amp; t ) noexcept;
}}
{{dcla|num=5|since=c++14|
template&lt; class T, class... Types &gt;
constexpr T&amp; get( std::tuple&lt;Types...&gt;&amp; t ) noexcept;
}}
{{dcl|num=6|since=c++14|
template&lt; class T, class... Types &gt;
constexpr T&amp;&amp; get( std::tuple&lt;Types...&gt;&amp;&amp; t ) noexcept;
}}
{{dcl|num=7|since=c++14|
template&lt; class T, class... Types &gt;
constexpr const T&amp; get( const std::tuple&lt;Types...&gt;&amp; t ) noexcept;
}}
{{dcla|num=8|since=c++14|
template&lt; class T, class... Types &gt;
constexpr const T&amp;&amp; get( const std::tuple&lt;Types...&gt;&amp;&amp; t ) noexcept;
}}
{{dcl end}}

@1-4@ Extracts the {{c|I}}{{sup|th}} element from the tuple. {{c|I}} must be an integer value in {{range|0|sizeof...(Types)}}.
@5-8@ Extracts the element of the tuple {{c|t}} whose type is {{tt|T}}. Fails to compile unless the tuple has exactly one element of that type.

===Parameters===
{{par begin}}
{{par|t|tuple whose contents to extract}}
{{par end}}

===Return value===
A reference to the selected element of {{c|t}}.

===Notes===
{{feature test macro|__cpp_lib_tuples_by_type|Addressing tuples by type {{vl|5-8}}|value=201304L|std=C++14}}

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

int main()
{
    auto x = std::make_tuple(1, "Foo", 3.14);
    
    // Index-based access
    std::cout &lt;&lt; "( " &lt;&lt; std::get&lt;0&gt;(x)
              &lt;&lt; ", " &lt;&lt; std::get&lt;1&gt;(x)
              &lt;&lt; ", " &lt;&lt; std::get&lt;2&gt;(x)
              &lt;&lt; " )\n";
    
    // Type-based access (since C++14)
    std::cout &lt;&lt; "( " &lt;&lt; std::get&lt;int&gt;(x)
              &lt;&lt; ", " &lt;&lt; std::get&lt;const char*&gt;(x)
              &lt;&lt; ", " &lt;&lt; std::get&lt;double&gt;(x)
              &lt;&lt; " )\n";

    const std::tuple&lt;int, const int, double, double&gt; y(1, 2, 6.9, 9.6);
    const int&amp; i1 = std::get&lt;int&gt;(y); // OK: not ambiguous
    assert(i1 == 1);
    const int&amp; i2 = std::get&lt;const int&gt;(y); // OK: not ambiguous
    assert(i2 == 2);
    // const double&amp; d = std::get&lt;double&gt;(y); // Error: ill-formed (ambiguous)

    // Note: std::tie and structured binding can be
    // used to unpack a tuple into individual objects.
}
|output=
( 1, Foo, 3.14 )
( 1, Foo, 3.14 )
}}

===Defect reports===
{{dr list begin}}
{{dr list item|dr=2485|wg=lwg|std=C++11 (by index)&lt;br&gt;C++14 (by type)|before=there are no overloads for {{c/core|const tuple&amp;&amp;}}|after=added these overloads ({{vl|4}} and {{vl|8}})}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/array/dsc get}}
{{dsc inc|cpp/utility/pair/dsc get}}
{{dsc inc|cpp/utility/variant/dsc get}}
{{dsc inc|cpp/ranges/subrange/dsc get}}
{{dsc inc|cpp/numeric/complex/dsc get}}
{{dsc inc|cpp/utility/tuple/dsc tie}}
{{dsc inc|cpp/language/dsc structured binding}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}