{{cpp/utility/tuple/title|tuple}}
{{cpp/utility/tuple/navbar}}
{{dcl begin}}
{{dcl header|tuple}}
{{dcl|num=1|since=c++11|notes={{mark|conditionally explicit}}|1=
constexpr tuple();
}}
{{dcl|num=2|since=c++11|notes={{mark|constexpr since C++14}}&lt;br&gt;{{mark|conditionally explicit}}|1=
tuple( const Types&amp;... args );
}}
{{dcl|num=3|since=c++11|notes={{mark|constexpr since C++14}}&lt;br&gt;{{mark|conditionally explicit}}|1=
template&lt; class... UTypes &gt;
tuple( UTypes&amp;&amp;... args );
}}
{{dcl|num=4|since=c++23|notes={{mark|conditionally explicit}}|1=
template&lt; class... UTypes &gt;
constexpr tuple( tuple&lt;UTypes...&gt;&amp; other );
}}
{{dcl|num=5|since=c++11|notes={{mark|constexpr since C++14}}&lt;br&gt;{{mark|conditionally explicit}}|1=
template&lt; class... UTypes &gt;
tuple( const tuple&lt;UTypes...&gt;&amp; other );
}}
{{dcl|num=6|since=c++11|notes={{mark|constexpr since C++14}}&lt;br&gt;{{mark|conditionally explicit}}|1=
template&lt; class... UTypes &gt;
tuple( tuple&lt;UTypes...&gt;&amp;&amp; other );
}}
{{dcl|num=7|since=c++23|notes={{mark|conditionally explicit}}|1=
template&lt; class... UTypes &gt;
constexpr tuple( const tuple&lt;UTypes...&gt;&amp;&amp; other );
}}
{{dcl|num=8|since=c++23|notes={{mark|conditionally explicit}}|1=
template&lt; class U1, class U2 &gt;
constexpr tuple( std::pair&lt;U1, U2&gt;&amp; p );
}}
{{dcl|num=9|since=c++11|notes={{mark|constexpr since C++14}}&lt;br&gt;{{mark|conditionally explicit}}|1=
template&lt; class U1, class U2 &gt;
tuple( const std::pair&lt;U1, U2&gt;&amp; p );
}}
{{dcl|num=10|since=c++11|notes={{mark|constexpr since C++14}}&lt;br&gt;{{mark|conditionally explicit}}|1=
template&lt; class U1, class U2 &gt;
tuple( std::pair&lt;U1, U2&gt;&amp;&amp; p );
}}
{{dcl|num=11|since=c++23|notes={{mark|conditionally explicit}}|1=
template&lt; class U1, class U2 &gt;
constexpr tuple( const std::pair&lt;U1, U2&gt;&amp;&amp; p );
}}
{{dcl|num=12|since=c++23|notes={{mark|conditionally explicit}}|1=
template&lt; tuple-like UTuple &gt;
constexpr tuple( UTuple&amp;&amp; u );
}}
{{dcl|num=13|since=c++11|1=
tuple( const tuple&amp; other ) = default;
}}
{{dcl|num=14|since=c++11|1=
tuple( tuple&amp;&amp; other ) = default;
}}
{{dcl h|Allocator-extended constructors}}
{{dcl|num=15|since=c++11|notes={{mark|constexpr since C++20}}&lt;br&gt;{{mark|conditionally explicit}}|1=
template&lt; class Alloc &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a );
}}
{{dcl|num=16|since=c++11|notes={{mark|constexpr since C++20}}&lt;br&gt;{{mark|conditionally explicit}}|1=
template&lt; class Alloc &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       const Types&amp;... args );
}}
{{dcl|num=17|since=c++11|notes={{mark|constexpr since C++20}}&lt;br&gt;{{mark|conditionally explicit}}|1=
template&lt; class Alloc, class... UTypes &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       UTypes&amp;&amp;... args );
}}
{{dcl|num=18|since=c++23|notes={{mark|conditionally explicit}}|1=
template&lt; class Alloc, class... UTypes &gt;
constexpr tuple( std::allocator_arg_t, const Alloc&amp; a,
                 tuple&lt;UTypes...&gt;&amp; other );
}}
{{dcl|num=19|since=c++11|notes={{mark|constexpr since C++20}}&lt;br&gt;{{mark|conditionally explicit}}|1=
template&lt; class Alloc, class... UTypes &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       const tuple&lt;UTypes...&gt;&amp; other );
}}
{{dcl|num=20|since=c++11|notes={{mark|constexpr since C++20}}&lt;br&gt;{{mark|conditionally explicit}}|1=
template&lt; class Alloc, class... UTypes &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       tuple&lt;UTypes...&gt;&amp;&amp; other );
}}
{{dcl|num=21|since=c++23|notes={{mark|conditionally explicit}}|1=
template&lt; class Alloc, class... UTypes &gt;
constexpr tuple( std::allocator_arg_t, const Alloc&amp; a,
                 const tuple&lt;UTypes...&gt;&amp;&amp; other );
}}
{{dcl|num=22|since=c++23|notes={{mark|conditionally explicit}}|1=
template&lt; class Alloc, class U1, class U2 &gt;
constexpr tuple( std::allocator_arg_t, const Alloc&amp; a,
                 std::pair&lt;U1, U2&gt;&amp; p );
}}
{{dcl|num=23|since=c++11|notes={{mark|constexpr since C++20}}&lt;br&gt;{{mark|conditionally explicit}}|1=
template&lt; class Alloc, class U1, class U2 &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       const std::pair&lt;U1, U2&gt;&amp; p );
}}
{{dcl|num=24|since=c++11|notes={{mark|constexpr since C++20}}&lt;br&gt;{{mark|conditionally explicit}}|1=
template&lt; class Alloc, class U1, class U2 &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       std::pair&lt;U1, U2&gt;&amp;&amp; p );
}}
{{dcl|num=25|since=c++23|notes={{mark|conditionally explicit}}|1=
template&lt; class Alloc, class U1, class U2 &gt;
constexpr tuple( std::allocator_arg_t, const Alloc&amp; a,
                 const std::pair&lt;U1, U2&gt;&amp;&amp; p );
}}
{{dcl|num=26|since=c++23|notes={{mark|conditionally explicit}}|1=
template&lt; class Alloc, tuple-like UTuple &gt;
constexpr tuple( std::allocator_arg_t, const Alloc&amp; a, UTuple&amp;&amp; u );
}}
{{dcl|num=27|since=c++11|notes={{mark|constexpr since C++20}}|1=
template&lt; class Alloc &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       const tuple&amp; other );
}}
{{dcl|num=28|since=c++11|notes={{mark|constexpr since C++20}}|1=
template&lt; class Alloc &gt;
tuple( std::allocator_arg_t, const Alloc&amp; a,
       tuple&amp;&amp; other );
}}
{{dcl end}}

Constructs a new tuple.

In the descriptions that follow, let
* {{c|i}} be in the range {{range|0|sizeof...(Types)}} in order,
* {{tt|Ti}} be the {{tt|i}}th type in {{tt|Types}}, and
* {{tt|Ui}} be the {{tt|i}}th type in a template parameter pack named {{tt|UTypes}},&lt;br&gt;
where indexing is zero-based.

@1@ Default constructor. [[cpp/language/value initialization|Value-initializes]] all elements, if any. The default constructor is trivial if {{c|1=sizeof...(Types) == 0}}.
* {{cpp/enable if|{{c|std::is_default_constructible&lt;Ti&gt;::value}} is {{c|true}} for all {{c|i}}}}.
* The constructor is {{c/core|explicit}} if and only if {{tt|Ti}} is not copy-list-initializable from {{c|{}&lt;!----&gt;}} for at least one {{c|i}}.

@2@ Direct constructor. Initializes each element of the tuple with the corresponding parameter.
* {{cpp/enable if|{{c|1=sizeof...(Types) &gt;= 1}} and {{c|std::is_copy_constructible&lt;Ti&gt;::value}} is {{c|true}} for all {{c|i}}}}.
* This constructor is {{c/core|explicit}} if and only if {{c|std::is_convertible&lt;const Ti&amp;, Ti&gt;::value}} is {{c|false}} for at least one {{c|i}}.

@3@ Converting constructor. Initializes each element of the tuple with the corresponding value in {{c|std::forward&lt;UTypes&gt;(args)}}.
&lt;!----&gt;
* {{cpp/enable if|
**{{c|1=sizeof...(Types) == sizeof...(UTypes)}},
** {{c|1=sizeof...(Types) &gt;= 1}},
** {{c|std::is_constructible&lt;Ti, Ui&gt;::value}} is {{c|true}} for all {{c|i}}, and
** let {{tt|D}} be {{rev inl|until=c++20|{{c/core|std::decay&lt;U0&gt;::type}}}}{{rev inl|since=c++20|{{c|std::remove_cvref_t&lt;U0&gt;}}}},
*** if {{c|1=sizeof...(Types) == 1}}, then {{tt|D}} is not {{tt|std::tuple}}, otherwise,
*** if {{c|1=sizeof...(Types) == 2}} or {{c|1=sizeof...(Types) == 3}}, then either {{tt|D}} is not {{lc|std::allocator_arg_t}}, or {{tt|T0}} is {{lc|std::allocator_arg_t}}}}.
* The constructor is {{c/core|explicit}} if and only if {{c|std::is_convertible&lt;Ui, Ti&gt;::value}} is {{c|false}} for at least one {{c|i}}.
{{rrev|since=c++23|
* This constructor is defined as deleted if the initialization of any element that is a reference would [[cpp/language/reference initialization#Lifetime of a temporary|bind it to a temporary object]].
}}

@4-7@ Converting constructor. Initializes each element of the tuple with the corresponding element of {{c|other}}.
&lt;!----&gt;
Formally, let {{c|FWD(other)}} be {{c|std::forward&lt;decltype(other)&gt;(other)}}, for all {{c|i}}, initializes {{tt|i}}th element of the tuple with {{c|std::get&lt;i&gt;(FWD(other))}}.
* {{cpp/enable if|
** {{c|1=sizeof...(Types) == sizeof...(UTypes)}},
** {{c|std::is_constructible_v&lt;Ti, decltype(std::get&lt;i&gt;(FWD(other)))&gt;}} is {{c|true}} for all {{c|i}}, and
** either
*** {{c|sizeof...(Types)}} is not {{c|1}}, or
*** (when {{tt|Types...}} expands to {{tt|T}} and {{tt|UTypes...}} expands to {{tt|U}}) {{c|std::is_convertible_v&lt;decltype(other), T&gt;}}, {{c|std::is_constructible_v&lt;T, decltype(other)&gt;}}, and {{c|std::is_same_v&lt;T, U&gt;}} are all {{c|false}}}}.
* These constructors are {{c/core|explicit}} if and only if {{c|std::is_convertible_v&lt;decltype(std::get&lt;i&gt;(FWD(other))), Ti&gt;}} is {{c|false}} for at least one {{c|i}}.
{{rrev|since=c++23|
* These constructors are defined as deleted if the initialization of any element that is a reference would bind it to a temporary object.
}}

@8-11@ Pair constructor. Constructs a 2-element tuple with each element constructed from the corresponding element of {{c|p}}.
&lt;!----&gt;
Formally, let {{c|FWD(p)}} be {{c|std::forward&lt;decltype(p)&gt;(p)}}, initializes the first element with {{c|std::get&lt;0&gt;(FWD(p))}} and the second element with {{c|std::get&lt;1&gt;(FWD(p))}}.
* {{cpp/enable if|
** {{c|1=sizeof...(Types) == 2}},
** {{c|std::is_constructible_v&lt;T0, decltype(std::get&lt;0&gt;(FWD(p)))&gt;}} is {{c|true}}, and
** {{c|std::is_constructible_v&lt;T1, decltype(std::get&lt;1&gt;(FWD(p)))&gt;}} is {{c|true}}}}.
* The constructor is {{c/core|explicit}} if and only if {{c|std::is_convertible_v&lt;decltype(std::get&lt;0&gt;(FWD(p))), T0&gt;}} or {{c|std::is_convertible_v&lt;decltype(std::get&lt;1&gt;(FWD(p))), T1&gt;}} is {{c|false}}.
{{rrev|since=c++23|
* These constructors are defined as deleted if the initialization of any element that is a reference would bind it to a temporary object.
}}

@12@ {{rlpi|tuple-like}} constructor. Constructs a tuple with each element constructed from the corresponding element of {{c|u}}.
&lt;!----&gt;
Formally, for all {{c|i}}, initializes {{tt|i}}th element of the tuple with {{c|std::get&lt;i&gt;(std::forward&lt;UTuple&gt;(u))}}.
* {{cpp/enable if|
** {{c|std::same_as&lt;std::remove_cvref_t&lt;UTuple&gt;, std::tuple&gt;}} is {{c|false}},
** {{c|std::remove_cvref_t&lt;UTuple&gt;}} is not a specialization of {{lc|std::ranges::subrange}},
** {{c|sizeof...(Types)}} equals {{c|std::tuple_size_v&lt;std::remove_cvref_t&lt;UTuple&gt;&gt;}},
** {{c|std::is_constructible_v&lt;Ti, decltype(std::get&lt;i&gt;(std::forward&lt;UTuple&gt;(u)))&gt;}} is {{c|true}} for all {{c|i}}, and
** either
*** {{c|sizeof...(Types)}} is not {{c|1}}, or
*** (when {{tt|Types...}} expands to {{tt|T}}) {{c|std::is_convertible_v&lt;UTuple, T&gt;}} and {{c|std::is_constructible_v&lt;T, UTuple&gt;}} are both {{c|false}}.}}
* This constructor is defined as deleted if the initialization of any element that is a reference would bind it to a temporary object.

@13@ Implicitly-defined copy constructor. Initializes each element of the tuple with the corresponding element of {{c|other}}.
* This constructor is {{c/core|constexpr}} if every operation it performs is {{c/core|constexpr}}. For the empty tuple {{c/core|std::tuple&lt;&gt;}}, it is {{c/core|constexpr}}.
* {{c|std::is_copy_constructible&lt;Ti&gt;::value}} must be {{c|true}} for all {{c|i}}, otherwise {{rev inl|until=c++20|the behavior is undefined}}{{rev inl|since=c++20|the program is ill-formed}}.

@14@ Implicitly-defined move constructor. For all {{c|i}}, initializes the {{tt|i}}th element of the tuple with {{c|std::forward&lt;Ui&gt;(std::get&lt;i&gt;(other))}}.
* This constructor is {{c/core|constexpr}} if every operation it performs is {{c/core|constexpr}}. For the empty tuple {{c/core|std::tuple&lt;&gt;}}, it is {{c/core|constexpr}}.
* {{c|std::is_move_constructible&lt;Ti&gt;::value}} must be {{c|true}} for all {{c|i}}, otherwise {{rev inl|until=c++20|the behavior is undefined}}{{rev inl|since=c++20|this overload does not participate in overload resolution}}.

@15-28@ Identical to {{v|1-14}} except each element is created by [[cpp/memory/uses_allocator#Uses-allocator_construction|uses-allocator construction]], that is, the Allocator object {{c|a}} is passed as an additional argument to the constructor of each element for which {{c|std::uses_allocator&lt;Ui, Alloc&gt;::value}} is {{c|true}}.

===Parameters===
{{par begin}}
{{par|args|values used to initialize each element of the tuple}}
{{par|other|the tuple of values used to initialize each element of the tuple}}
{{par|p|the pair of values used to initialize both elements of the 2-tuple}}
{{par|u|the {{rlpi|tuple-like}} object of values used to initialize each element of the tuple}}
{{par|a|the allocator to use in uses-allocator construction}}
{{par end}} 

===Notes===
Conditionally-explicit constructors make it possible to construct a tuple in copy-initialization context using list-initialization syntax:
{{source|1=
std::tuple&lt;int, int&gt; foo_tuple() 
{
    // return {1, -1};             // Error before N4387
    return std::make_tuple(1, -1); // Always works
}
}}

Note that if some element of the list is not implicitly convertible to the corresponding element of the target tuple, the constructors become explicit:
{{source|1=
using namespace std::chrono;
void launch_rocket_at(std::tuple&lt;hours, minutes, seconds&gt;);

launch_rocket_at({hours(1), minutes(2), seconds(3)}); // OK
launch_rocket_at({1, 2, 3}); // Error: int is not implicitly convertible to duration
launch_rocket_at(std::tuple&lt;hours, minutes, seconds&gt;{1, 2, 3}); // OK
}}

===Example===
{{example
|code=
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;tuple&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;

// helper function to print a vector to a stream
template&lt;class Os, class T&gt;
Os&amp; operator&lt;&lt;(Os&amp; os, std::vector&lt;T&gt; const&amp; v)
{
    os &lt;&lt; '{';
    for (auto i{v.size()}; const T&amp; e : v)
        os &lt;&lt; e &lt;&lt; (--i ? "," : "");
    return os &lt;&lt; '}';
}

template&lt;class T&gt;
void print_single(T const&amp; v)
{
    if constexpr (std::is_same_v&lt;T, std::decay_t&lt;std::string&gt;&gt;)
        std::cout &lt;&lt; std::quoted(v);
    else if constexpr (std::is_same_v&lt;std::decay_t&lt;T&gt;, char&gt;)
        std::cout &lt;&lt; "'" &lt;&lt; v &lt;&lt; "'";
    else
        std::cout &lt;&lt; v;
}

// helper function to print a tuple of any size
template&lt;class Tuple, std::size_t N&gt;
struct TuplePrinter
{
    static void print(const Tuple&amp; t)
    {
        TuplePrinter&lt;Tuple, N - 1&gt;::print(t);
        std::cout &lt;&lt; ", ";
        print_single(std::get&lt;N - 1&gt;(t));
    }
};

template&lt;class Tuple&gt;
struct TuplePrinter&lt;Tuple, 1&gt;
{
    static void print(const Tuple&amp; t)
    {
        print_single(std::get&lt;0&gt;(t));
    }
};

template&lt;class... Args&gt;
void print(std::string_view message, const std::tuple&lt;Args...&gt;&amp; t)
{
    std::cout &lt;&lt; message &lt;&lt; " (";
    TuplePrinter&lt;decltype(t), sizeof...(Args)&gt;::print(t);
    std::cout &lt;&lt; ")\n";
}
// end helper function

int main()
{
    std::tuple&lt;int, std::string, double&gt; t1;
    print("Value-initialized, t1:", t1);
    
    std::tuple&lt;int, std::string, double&gt; t2{42, "Test", -3.14};
    print("Initialized with values, t2:", t2);
    
    std::tuple&lt;char, std::string, int&gt; t3{t2};
    print("Implicitly converted, t3:", t3);
    
    std::tuple&lt;int, double&gt; t4{std::make_pair(42, 3.14)};
    print("Constructed from a pair, t4:", t4);
    
    // given Allocator my_alloc with a single-argument constructor
    // my_alloc(int); use my_alloc(1) to allocate 5 ints in a vector
    using my_alloc = std::allocator&lt;int&gt;;
    std::vector&lt;int, my_alloc&gt; v{5, 1, my_alloc{/* 1 */}&lt;!----&gt;};
    
    // use my_alloc(2) to allocate 5 ints in a vector in a tuple
    std::tuple&lt;int, std::vector&lt;int, my_alloc&gt;, double&gt; t5
        {std::allocator_arg, my_alloc{/* 2 */}, 42, v, -3.14};
    print("Constructed with allocator, t5:", t5);
}
|output=
Value-initialized, t1: (0, "", 0)
Initialized with values, t2: (42, "Test", -3.14)
Implicitly converted, t3: ('*', "Test", -3)
Constructed from a pair, t4: (42, 3.14)
Constructed with allocator, t5: (42, {1,1,1,1,1}, -3.14)
|p=true
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2510|std=C++11|before=default constructor was implicit|after=made conditionally-explicit}}
{{dr list item|wg=lwg|dr=3121|std=C++11|before=constructor of 1-tuple might recursively check the constraints;&lt;br&gt;{{tt|allocator_arg_t}} argument brought ambiguity|after=furtherly constrained&lt;br&gt;the constructor}}
{{dr list item|wg=lwg|dr=3158|std=C++11|before=the uses-allocator constructor corresponding&lt;br&gt;to default constructor was implicit|after=made conditionally-explicit}}
{{dr list item|wg=lwg|dr=3211|std=C++11|before=whether the default constructor of&lt;br&gt;{{tt|tuple&lt;&gt;}} is trivial was unspecified|after=require to be trivial}}
{{dr list item|wg=lwg|dr=4045|std=C++23|before={{tti|tuple-like}} constructor may potentially create dangling references|after=made defined as deleted}}
{{dr list item|paper=N4387|std=C++11|before=some constructors were explicit, preventing useful behavior|after=most constructors made&lt;br&gt;conditionally-explicit}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc operator{{=}}}}
{{dsc inc|cpp/utility/tuple/dsc make_tuple}}
{{dsc inc|cpp/utility/tuple/dsc tie}}
{{dsc inc|cpp/utility/tuple/dsc forward_as_tuple}}
{{dsc inc|cpp/utility/pair/dsc constructor}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}