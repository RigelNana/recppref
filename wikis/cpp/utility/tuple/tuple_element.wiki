{{cpp/title|tuple_element{{small|&lt;std::tuple&gt;}}}}
{{cpp/utility/tuple/navbar}}
{{ddcl|header=tuple|since=c++11|
template&lt; std::size_t I, class... Types &gt;
struct tuple_element&lt; I, std::tuple&lt;Types...&gt; &gt;;
}}

Provides compile-time indexed access to the types of the elements of the tuple.

===Member types===
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc|type|the type of {{tt|I}}{{sup|th}} element of the tuple, where {{tt|I}} is in {{range|0|sizeof...(Types)}}}}
{{dsc end}}

===Possible implementation===
{{eq fun
|1=
template&lt;std::size_t I, class T&gt;
struct tuple_element;

#ifndef __cpp_pack_indexing
// recursive case
template&lt;std::size_t I, class Head, class... Tail&gt;
struct tuple_element&lt;I, std::tuple&lt;Head, Tail...&gt;&gt;
    : std::tuple_element&lt;I - 1, std::tuple&lt;Tail...&gt;&gt;
{ };

// base case
template&lt;class Head, class... Tail&gt;
struct tuple_element&lt;0, std::tuple&lt;Head, Tail...&gt;&gt;
{
    using type = Head;
};

#else
// C++26 implementation using pack indexing
template&lt;std::size_t I, class... Ts&gt;
struct tuple_element&lt;I, std::tuple&lt;Ts...&gt;&gt;
{
    using type = Ts...[I];
};
#endif
}}

===Example===
{{example
|code=
#include &lt;boost/type_index.hpp&gt;
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;utility&gt;

template&lt;typename TupleLike, std::size_t I = 0&gt;
void printTypes()
{
    if constexpr (I == 0)
        std::cout &lt;&lt; boost::typeindex::type_id_with_cvr&lt;TupleLike&gt;() &lt;&lt; '\n';

    if constexpr (I &lt; std::tuple_size_v&lt;TupleLike&gt;)
    {
        using SelectedType = std::tuple_element_t&lt;I, TupleLike&gt;;

        std::cout &lt;&lt; "  The type at index " &lt;&lt; I &lt;&lt; " is: "
                  &lt;&lt; boost::typeindex::type_id_with_cvr&lt;SelectedType&gt;() &lt;&lt; '\n';
        printTypes&lt;TupleLike, I + 1&gt;();
    }
}

struct MyStruct {};

using MyTuple = std::tuple&lt;int, long&amp;, const char&amp;, bool&amp;&amp;,
                           std::string, volatile MyStruct&gt;;

using MyPair = std::pair&lt;char, bool&amp;&amp;&gt;;

static_assert(std::is_same_v&lt;std::tuple_element_t&lt;0, MyPair&gt;, char&gt;);
static_assert(std::is_same_v&lt;std::tuple_element_t&lt;1, MyPair&gt;, bool&amp;&amp;&gt;);

int main()
{
    printTypes&lt;MyTuple&gt;();
    printTypes&lt;MyPair&gt;();
}
|p=true
|output=
std::tuple&lt;int, long&amp;, char const&amp;, bool&amp;&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, MyStruct volatile&gt;
  The type at index 0 is: int
  The type at index 1 is: long&amp;
  The type at index 2 is: char const&amp;
  The type at index 3 is: bool&amp;&amp;
  The type at index 4 is: std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;
  The type at index 5 is: MyStruct volatile
std::pair&lt;char, bool&amp;&amp;&gt;
  The type at index 0 is: char
  The type at index 1 is: bool&amp;&amp;
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc structured binding}}
{{dsc inc|cpp/utility/dsc tuple_element}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}