{{cpp/utility/tuple/title|operator{{=}}}}
{{cpp/utility/tuple/navbar}}
{{dcl begin}}
{{dcla|num=1|since=c++11|constexpr=c++20|1=
tuple&amp; operator=( const tuple&amp; other );
}}
{{dcl|num=2|since=c++23|1=
constexpr const tuple&amp; operator=( const tuple&amp; other ) const;
}}
{{dcla|num=3|since=c++11|constexpr=c++20|1=
tuple&amp; operator=( tuple&amp;&amp; other ) noexcept(/* see below */);
}}
{{dcl|num=4|since=c++23|1=
constexpr const tuple&amp; operator=( tuple&amp;&amp; other ) const;
}}
{{dcla|num=5|since=c++11|constexpr=c++20|1=
template&lt; class... UTypes &gt;
tuple&amp; operator=( const tuple&lt;UTypes...&gt;&amp; other );
}}
{{dcl|num=6|since=c++23|1=
template&lt; class... UTypes &gt;
constexpr const tuple&amp; operator=( const tuple&lt;UTypes...&gt;&amp; other ) const;
}}
{{dcla|num=7|since=c++11|constexpr=c++20|1=
template&lt; class... UTypes &gt;
tuple&amp; operator=( tuple&lt;UTypes...&gt;&amp;&amp; other );
}}
{{dcl|num=8|since=c++23|1=
template&lt; class... UTypes &gt;
constexpr const tuple&amp; operator=( tuple&lt;UTypes...&gt;&amp;&amp; other ) const;
}}
{{dcla|num=9|since=c++11|constexpr=c++20|1=
template&lt; class E1, class E2 &gt;
tuple&amp; operator=( const std::pair&lt;E1, E2&gt;&amp; p );
}}
{{dcl|num=10|since=c++23|1=
template&lt; class E1, class E2 &gt;
constexpr const tuple&amp; operator=( const std::pair&lt;E1, E2&gt;&amp; p ) const;
}}
{{dcla|num=11|since=c++11|constexpr=c++20|1=
template&lt; class E1, class E2 &gt;
tuple&amp; operator=( std::pair&lt;E1, E2&gt;&amp;&amp; p );
}}
{{dcl|num=12|since=c++23|1=
template&lt; class E1, class E2 &gt;
constexpr const tuple&amp; operator=( std::pair&lt;E1, E2&gt;&amp;&amp; p ) const;
}}
{{dcl|num=13|since=c++23|1=
template&lt; tuple-like UTuple &gt;
constexpr tuple&amp; operator=( UTuple&amp;&amp; u );
}}
{{dcl|num=14|since=c++23|1=
template&lt; tuple-like UTuple &gt;
constexpr const tuple&amp; operator=( UTuple&amp;&amp; u ) const;
}}
{{dcl end}}

Replaces the contents of the tuple with the contents of another tuple-like object.

In the descriptions that follow, let
* {{c|i}} be in the range {{range|​0​|sizeof...(Types)}} in order,
* {{tt|Ti}} be the {{tt|i}}th type in the class template parameter pack {{tt|Types}}, and
* {{tt|Ui}} be the {{tt|i}}th type in a function template parameter pack named {{tt|UTypes}},
where indexing is zero-based.

@1@ Copy assignment operator. Assigns each element of {{c|other}} to the corresponding element of {{c|*this}}.
@@ This overload is defined as deleted unless {{c|std::is_copy_assignable&lt;Ti&gt;::value}} is {{c|true}} for all {{tt|Ti}}.

@2@ Copy assignment operator for const-qualified operand. Assigns each element of {{c|other}} to the corresponding element of {{c|*this}}.
@@ {{cpp/enable if|{{c|std::is_copy_assignable_v&lt;const Ti&gt;}} is {{c|true}} for all {{tt|Ti}}.}}
 
@3@ Move assignment operator. For all {{c|i}}, assigns {{c|std::forward&lt;Ti&gt;(std::get&lt;i&gt;(other))}} to {{c|std::get&lt;i&gt;(*this)}}.
@@ {{cpp/enable if|{{c|std::is_move_assignable&lt;Ti&gt;::value}} is {{c|true}} for all {{tt|Ti}}.}}
 
@4@ Move assignment operator for const-qualified operand. For all {{c|i}}, assigns {{c|std::forward&lt;Ti&gt;(std::get&lt;i&gt;(other))}} to {{c|std::get&lt;i&gt;(*this)}}.
@@ {{cpp/enable if|{{c|std::is_assignable_v&lt;const Ti&amp;, Ti&gt;}} is {{c|true}} for all {{tt|Ti}}.}}

@5@ For all {{c|i}}, assigns {{c|std::get&lt;i&gt;(other)}} to {{c|std::get&lt;i&gt;(*this)}}.
@@ {{cpp/enable if|{{c|1=sizeof...(Types) == sizeof...(UTypes)}}, and {{c|std::is_assignable&lt;Ti&amp;, const Ui&amp;&gt;::value}} is {{c|true}} for all corresponding pairs of types {{tt|Ti}} and {{tt|Ui}}.}}

@6@ For all {{c|i}}, assigns {{c|std::get&lt;i&gt;(other)}} to {{c|std::get&lt;i&gt;(*this)}}.
@@ {{cpp/enable if|{{c|1=sizeof...(Types) == sizeof...(UTypes)}}, and {{c|std::is_assignable_v&lt;const Ti&amp;, const Ui&amp;&gt;}} is {{c|true}} for all corresponding pairs of types {{tt|Ti}} and {{tt|Ui}}.}}

@7@ For all {{c|i}}, assigns {{c|std::forward&lt;Ui&gt;(std::get&lt;i&gt;(other))}} to {{c|std::get&lt;i&gt;(*this)}}.
@@ {{cpp/enable if|{{c|1=sizeof...(Types) == sizeof...(UTypes)}}, and {{c|std::is_assignable&lt;Ti&amp;, Ui&gt;::value}} is {{c|true}} for all corresponding pairs of types {{tt|Ti}}and {{tt|Ui}}.}}

@8@ For all {{c|i}}, assigns {{c|std::forward&lt;Ui&gt;(std::get&lt;i&gt;(other))}} to {{c|std::get&lt;i&gt;(*this)}}.
@@ {{cpp/enable if|{{c|1=sizeof...(Types) == sizeof...(UTypes)}}, and {{c|std::is_assignable_v&lt;const Ti&amp;, Ui&gt;}} is {{c|true}} for all corresponding pairs of types {{tt|Ti}} and {{tt|Ui}}.}}

@9@ Assigns {{c|p.first}} to the first element of {{c|*this}} and {{c|p.second}} to the second element of {{c|*this}}.
@@ {{cpp/enable if|
* {{c|1=sizeof...(Types) == 2}},
* {{c|std::is_assignable&lt;T0&amp;, const E1&amp;&gt;::value}} is {{c|true}}, and
* {{c|std::is_assignable&lt;T1&amp;, const E2&amp;&gt;::value}} is {{c|true}}.}}

@10@ Assigns {{c|p.first}} to the first element and {{c|p.second}} to the second element.
@@ {{cpp/enable if|
* {{c|1=sizeof...(Types) == 2}},
* {{c|std::is_assignable_v&lt;const T0&amp;, const E1&amp;&gt;}} is {{c|true}}, and
* {{c|std::is_assignable_v&lt;const T1&amp;, const E2&amp;&gt;}} is {{c|true}}.}}

@11@ Assigns {{c|std::forward&lt;E1&gt;(p.first)}} to the first element of {{c|*this}} and {{c|std::forward&lt;E2&gt;(p.second)}} to the second element of {{c|*this}}.
@@ {{cpp/enable if|
* {{c|1=sizeof...(Types) == 2}},
* {{c|std::is_assignable_v&lt;T0&amp;, E1&gt;}} is {{c|true}}, and
* {{c|std::is_assignable_v&lt;T1&amp;, E2&gt;}} is {{c|true}}.}}

@12@ Assigns {{c|std::forward&lt;E1&gt;(p.first)}} to the first element and {{c|std::forward&lt;E2&gt;(p.second)}} to the second element.
@@ {{cpp/enable if|
* {{c|1=sizeof...(Types) == 2}},
* {{c|std::is_assignable_v&lt;const T0&amp;, E1&gt;}} is {{c|true}}, and
* {{c|std::is_assignable_v&lt;const T1&amp;, E2&gt;}} is {{c|true}}.}}

@13@ For all {{c|i}}, assigns {{c|std::get&lt;i&gt;(std::forward&lt;UTuple&gt;(u))}} to {{c|std::get&lt;i&gt;(*this)}}.
@@ {{cpp/enable if|
* {{c|std::same_as&lt;std::remove_cvref_t&lt;UTuple&gt;, std::tuple&gt;}} is {{c|false}},
* {{c/core|std::remove_cvref_t&lt;UTuple&gt;}} is not a specialization of {{lc|std::ranges::subrange}},
* {{c|sizeof...(Types)}} equals {{c|std::tuple_size_v&lt;std::remove_cvref_t&lt;UTuple&gt;&gt;}}, and
* {{c|std::is_assignable_v&lt;Ti&amp;, decltype(std::get&lt;i&gt;(std::forward&lt;UTuple&gt;(u)))&gt;}} is {{c|true}} for all {{c|i}}.}}

@14@ For all {{c|i}}, assigns {{c|std::get&lt;i&gt;(std::forward&lt;UTuple&gt;(u))}} to {{c|std::get&lt;i&gt;(*this)}}.
@@ {{cpp/enable if|
* {{c|std::same_as&lt;std::remove_cvref_t&lt;UTuple&gt;, std::tuple&gt;}} is {{c|false}},
* {{c/core|std::remove_cvref_t&lt;UTuple&gt;}} is not a specialization of {{lc|std::ranges::subrange}},
* {{c|sizeof...(Types)}} equals {{c|std::tuple_size_v&lt;std::remove_cvref_t&lt;UTuple&gt;&gt;}}, and
* {{c|std::is_assignable_v&lt;const Ti&amp;, decltype(std::get&lt;i&gt;(std::forward&lt;UTuple&gt;(u)))&gt;}} is {{c|true}} for all {{c|i}}.}}

===Parameters===
{{par begin}}
{{par|other|tuple to replace the contents of this tuple}}
{{par|p|pair to replace the contents of this 2-tuple}}
{{par|u|{{rlpi|tuple-like}} object to replace the contents of this tuple}}
{{par end}} 

===Return value===
{{c|*this}}

===Exceptions===
@1,2@ {{cpp/impldef exception item|if=the assignment of one of the types in {{tt|Types}} throws an exception}}

@3@ {{noexcept|
    std::is_nothrow_move_assignable&lt;T0&gt;::value &amp;&amp;
    std::is_nothrow_move_assignable&lt;T1&gt;::value &amp;&amp;
    std::is_nothrow_move_assignable&lt;T2&gt;::value &amp;&amp;
    ...
}}

@4-14@ {{cpp/impldef exception item|if=the assignment of one of the types in {{tt|Types}} throws an exception}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;tuple&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

// helper function to print std::vector&lt;int&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, std::vector&lt;int&gt; const&amp; v)
{
    os &lt;&lt; '{';
    for (std::size_t t = 0; t != v.size(); ++t)
        os &lt;&lt; v[t] &lt;&lt; (t + 1 &lt; v.size() ? ", " : "");
    return os &lt;&lt; '}';
}

// helpers to print a tuple of any size
template&lt;class... Args&gt;
void print_tuple(std::string_view name, const std::tuple&lt;Args...&gt;&amp; t)
{
    std::cout &lt;&lt; name &lt;&lt; " = {";
    std::apply([&amp;](auto&amp;&amp; arg, auto&amp;&amp;... args)
    {
        std::cout &lt;&lt; arg;
        ((std::cout &lt;&lt; ", " &lt;&lt; args), ...);
    }, t);
    std::cout &lt;&lt; '}';
}

template&lt;class Tuple1, class Tuple2&gt;
void print_tuples(std::string_view name1, const Tuple1&amp; t1,
                  std::string_view name2, const Tuple2&amp; t2)
{
    print_tuple(name1, t1);
    std::cout &lt;&lt; ", ";
    print_tuple(name2, std::tuple(t2));
    std::cout &lt;&lt; "\n\n";
}

int main()
{
    // Tuple to tuple examples //
    std::tuple&lt;int, std::string, std::vector&lt;int&gt;&gt;
        t1{1, "alpha", {1, 2, 3}&lt;!----&gt;},
        t2{2, "beta", {4, 5}&lt;!----&gt;};
    print_tuples("1) t1", t1, "t2", t2);
    
    // Normal copy assignment
    // operator=( const tuple&amp; other );
    t1 = t2;
    print_tuples("2) t1 = t2;\n   t1", t1, "t2", t2);
    
    // Normal move assignment
    // operator=( tuple&amp;&amp; other );
    t1 = std::move(t2);
    print_tuples("3) t1 = std::move(t2);\n   t1", t1, "t2", t2);
    
    // Converting copy assignment
    // operator=( const tuple&lt;UTypes...&gt;&amp; other );
    std::tuple&lt;short, const char*, std::vector&lt;int&gt;&gt; t3{3, "gamma", {6, 7, 8}&lt;!----&gt;};
    t1 = t3;
    print_tuples("4) t1 = t3;\n   t1", t1, "t3", t3);
    
    // Converting move assignment
    // operator=( tuple&lt;UTypes...&gt;&amp;&amp; other );
    t1 = std::move(t3);
    print_tuples("5) t1 = std::move(t3);\n   t1", t1, "t3", t3);
    
    // Pair to tuple examples //
    std::tuple&lt;std::string, std::vector&lt;int&gt;&gt; t4{"delta", {10, 11, 12}&lt;!----&gt;};
    std::pair&lt;const char*, std::vector&lt;int&gt;&gt; p1{"epsilon", {14, 15, 16}&lt;!----&gt;};
    print_tuples("6) t4", t4, "p1", p1);
    
    // Converting copy assignment from std::pair
    // operator=( const std::pair&lt;U1, U2&gt;&amp; p );
    t4 = p1;
    print_tuples("7) t4 = p1;\n   t4", t4, "p1", p1);
    
    // Converting move assignment from std::pair
    // operator=( std::pair&lt;U1, U2&gt;&amp;&amp; p );
    t4 = std::move(p1);
    print_tuples("8) t4 = std::move(p1);\n   t4", t4, "p1", p1);
}
|p=true
|output=
1) t1 = {1, alpha, {1, 2, 3}&lt;!----&gt;}, t2 = {2, beta, {4, 5}&lt;!----&gt;}

2) t1 = t2;
   t1 = {2, beta, {4, 5}&lt;!----&gt;}, t2 = {2, beta, {4, 5}&lt;!----&gt;}

3) t1 = std::move(t2);
   t1 = {2, beta, {4, 5}&lt;!----&gt;}, t2 = {2, , {}&lt;!----&gt;}

4) t1 = t3;
   t1 = {3, gamma, {6, 7, 8}&lt;!----&gt;}, t3 = {3, gamma, {6, 7, 8}&lt;!----&gt;}

5) t1 = std::move(t3);
   t1 = {3, gamma, {6, 7, 8}&lt;!----&gt;}, t3 = {3, gamma, {}&lt;!----&gt;}

6) t4 = {delta, {10, 11, 12}&lt;!----&gt;}, p1 = {epsilon, {14, 15, 16}&lt;!----&gt;}

7) t4 = p1;
   t4 = {epsilon, {14, 15, 16}&lt;!----&gt;}, p1 = {epsilon, {14, 15, 16}&lt;!----&gt;}

8) t4 = std::move(p1);
   t4 = {epsilon, {14, 15, 16}&lt;!----&gt;}, p1 = {epsilon, {}&lt;!----&gt;}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2729|std=C++11|before={{c/core|1=operator=}} was unconstrained and might&lt;br&gt;result in unnecessary undefined behavior|after=constrained}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc constructor}}
{{dsc inc|cpp/utility/pair/dsc operator{{=}}}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}