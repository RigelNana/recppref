{{cpp/title|tuple_cat}}
{{cpp/utility/tuple/navbar}}
{{dcl begin}}
{{dcl header|tuple}}
{{dcl rev multi|since1=c++11|until1=c++14|dcl1=
template&lt; class... Tuples &gt;
std::tuple&lt;/* CTypes */...&gt; tuple_cat( Tuples&amp;&amp;... args );
|until2=c++23|dcl2=
template&lt; class... Tuples &gt;
constexpr std::tuple&lt;/* CTypes */...&gt; tuple_cat( Tuples&amp;&amp;... args );
|dcl3=
template&lt; tuple-like... Tuples &gt;
constexpr std::tuple&lt;/* CTypes */...&gt; tuple_cat( Tuples&amp;&amp;... args );
}}
{{dcl end}}

Constructs a tuple that is a concatenation of all tuples in {{c|args}}. The element types {{c/core|/* CTypes */ }} of the returned tuple is formed by concatenating the elements type packs of all {{rev inl|until=c++23|{{lc|std::tuple}}}}{{rev inl|since=c++23|{{rlpi|tuple-like}}}} types in {{tt|Tuples}} in order.

{{rrev multi|until1=c++23
|rev1=
The behavior is undefined if any type in {{c/core|std::decay_t&lt;Tuples&gt;...}} is not a specialization of {{lc|std::tuple}}. However, an implementation may choose to support types (such as {{lc|std::array}} and {{lc|std::pair}}) that follow the tuple-like protocol.
|rev2=
The types {{c/core|std::decay_t&lt;Tuples&gt;...}} are constrained to be tuple-like, i.e. each type therein is required to be a specialization of {{lc|std::tuple}} or another type (such as {{lc|std::array}} and {{lc|std::pair}}) that models {{rlpi|tuple-like}}.
}}

If any type in {{c/core|/* CTypes */}} is not constructible from the type of the corresponding element in the sequence of elements concatenated from {{c|args}}, {{rev inl|until=c++23|the behavior is undefined}}{{rev inl|since=c++23|the program is ill-formed}}.

===Parameters===
{{par begin}}
{{par|args|zero or more tuples to concatenate}}
{{par end}}

===Return value===
A {{lc|std::tuple}} object composed of all elements of all argument tuples constructed from {{c|std::get&lt;j&gt;(std::forward&lt;Ti&gt;(arg))}} for each individual element.

===Example===
{{example|
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

// helper function to print a tuple of any size
template&lt;class Tuple, std::size_t N&gt;
struct TuplePrinter
{
    static void print(const Tuple&amp; t)
    {
        TuplePrinter&lt;Tuple, N - 1&gt;::print(t);
        std::cout &lt;&lt; ", " &lt;&lt; std::get&lt;N-1&gt;(t);
    }
};

template&lt;class Tuple&gt;
struct TuplePrinter&lt;Tuple, 1&gt;
{
    static void print(const Tuple&amp; t)
    {
        std::cout &lt;&lt; std::get&lt;0&gt;(t);
    }
};

template&lt;typename... Args, std::enable_if_t&lt;sizeof...(Args) == 0, int&gt; = 0&gt;
void print(const std::tuple&lt;Args...&gt;&amp; t)
{
    std::cout &lt;&lt; "()\n";
}

template&lt;typename... Args, std::enable_if_t&lt;sizeof...(Args) != 0, int&gt; = 0&gt;
void print(const std::tuple&lt;Args...&gt;&amp; t)
{
    std::cout &lt;&lt; "(";
    TuplePrinter&lt;decltype(t), sizeof...(Args)&gt;::print(t);
    std::cout &lt;&lt; ")\n";
}
// end helper function

int main()
{
    std::tuple&lt;int, std::string, float&gt; t1(10, "Test", 3.14);
    int n = 7;
    auto t2 = std::tuple_cat(t1, std::make_tuple("Foo", "bar"), t1, std::tie(n));
    n = 42;
    print(t2);
}
|output=
(10, Test, 3.14, Foo, bar, 10, Test, 3.14, 42)
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/tuple/dsc make_tuple}}
{{dsc inc|cpp/utility/tuple/dsc tie}}
{{dsc inc|cpp/utility/tuple/dsc forward_as_tuple}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}