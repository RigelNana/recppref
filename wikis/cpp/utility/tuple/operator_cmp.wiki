{{title|1=operator==,!=,&lt;,&lt;=,&gt;,&gt;=,&lt;=&gt;{{petty|(std::tuple)}}}}
{{cpp/utility/tuple/navbar}}
{{dcl begin}}
{{dcl header|tuple}}
{{dcla|num=1|since=c++11|constexpr=c++14|1=
template&lt; class... TTypes, class... UTypes &gt;
bool operator==( const std::tuple&lt;TTypes...&gt;&amp; lhs,
                 const std::tuple&lt;UTypes...&gt;&amp; rhs );
}}
{{dcla|num=2|since=c++11|constexpr=c++14|until=c++20|1=
template&lt; class... TTypes, class... UTypes &gt;
bool operator!=( const std::tuple&lt;TTypes...&gt;&amp; lhs,
                 const std::tuple&lt;UTypes...&gt;&amp; rhs );
}}
{{dcla|num=3|since=c++11|constexpr=c++14|until=c++20|1=
template&lt; class... TTypes, class... UTypes &gt;
bool operator&lt;( const std::tuple&lt;TTypes...&gt;&amp; lhs,
                const std::tuple&lt;UTypes...&gt;&amp; rhs );
}}
{{dcla|num=4|since=c++11|constexpr=c++14|until=c++20|1=
template&lt; class... TTypes, class... UTypes &gt;
bool operator&lt;=( const std::tuple&lt;TTypes...&gt;&amp; lhs,
                 const std::tuple&lt;UTypes...&gt;&amp; rhs );
}}
{{dcla|num=5|since=c++11|constexpr=c++14|until=c++20|1=
template&lt; class... TTypes, class... UTypes &gt;
bool operator&gt;( const std::tuple&lt;TTypes...&gt;&amp; lhs,
                const std::tuple&lt;UTypes...&gt;&amp; rhs );
}}
{{dcla|num=6|since=c++11|constexpr=c++14|until=c++20|1=
template&lt; class... TTypes, class... UTypes &gt;
bool operator&gt;=( const std::tuple&lt;TTypes...&gt;&amp; lhs,
                 const std::tuple&lt;UTypes...&gt;&amp; rhs );
}}
{{dcl|num=7|since=c++20|1=
template&lt; class... TTypes, class... UTypes &gt;
constexpr std::common_comparison_category_t&lt;
    synth-three-way-result&lt;TTypes, Elems&gt;...&gt;
    operator&lt;=&gt;( const std::tuple&lt;TTypes...&gt;&amp; lhs,
                 const std::tuple&lt;UTypes...&gt;&amp; rhs );
}}
{{dcl|num=8|since=c++23|1=
template&lt; class... TTypes, tuple-like UTuple &gt;
constexpr bool operator==( const tuple&lt;TTypes...&gt;&amp; lhs, const UTuple&amp; rhs );
}}
{{dcl|num=9|since=c++23|1=
template&lt; class... TTypes, tuple-like UTuple &gt;
constexpr std::common_comparison_category_t&lt;
    synth-three-way-result&lt;TTypes, /* Elems */&gt;...&gt;
    operator&lt;=&gt;( const tuple&lt;TTypes...&gt;&amp; lhs, const UTuple&amp; rhs );
}}
{{dcl end}}

@1,2@ Compares every element of the tuple {{c|lhs}} with the corresponding element of the tuple {{c|rhs}} by {{c/core|1=operator==}}.
:@1@ Returns {{c|true}} if all pairs of corresponding elements are equal.
:@2@ Returns {{c|1=!(lhs == rhs)}}.

{{rrev multi|rev1=
@@ If {{c|sizeof...(TTypes)}} does not equal {{c|sizeof...(UTypes)}}, or {{c|1=std::get&lt;i&gt;(lhs) == std::get&lt;i&gt;(rhs)}} is not a valid expression for any {{c|i}} in {{range|0|sizeof...(Types)}}, the program is ill-formed.

@@ If the type and value category of {{c|1=std::get&lt;i&gt;(lhs) == std::get&lt;i&gt;(rhs)}} do not meet the {{named req|BooleanTestable}} requirements for any {{c|i}} in {{range|0|sizeof...(Types)}}, the behavior is undefined.
|since2=c++26|rev2=
@@ {{cpp/enable_if|{{c|sizeof...(TTypes)}} equals {{c|sizeof...(UTypes)}}, {{c|1=std::get&lt;i&gt;(lhs) == std::get&lt;i&gt;(rhs)}} is a valid expression and {{c|1=decltype(std::get&lt;i&gt;(lhs) == std::get&lt;i&gt;(rhs))}} model {{lconcept|boolean-testable}} for every {{c|i}} in {{range|0|sizeof...(Types)}}}}.
}}

@3-6@ Compares {{c|lhs}} and {{c|rhs}} lexicographically by {{c/core|operator&lt;}}, that is, compares the first elements, if they are equivalent, compares the second elements, if those are equivalent, compares the third elements, and so on.

:@3@ For empty tuples, returns {{c|false}}. For non-empty tuples, the effect is equivalent to&lt;br&gt;{{c|
if (std::get&lt;0&gt;(lhs) &lt; std::get&lt;0&gt;(rhs)) return true;
if (std::get&lt;0&gt;(rhs) &lt; std::get&lt;0&gt;(lhs)) return false;
if (std::get&lt;1&gt;(lhs) &lt; std::get&lt;1&gt;(rhs)) return true;
if (std::get&lt;1&gt;(rhs) &lt; std::get&lt;1&gt;(lhs)) return false;
...
return std::get&lt;N - 1&gt;(lhs) &lt; std::get&lt;N - 1&gt;(rhs);
}}
:@4@ Returns {{c|!(rhs &lt; lhs)}}.
:@5@ Returns {{c|rhs &lt; lhs}}.
:@6@ Returns {{c|!(lhs &lt; rhs)}}.

@@ If {{c|sizeof...(TTypes)}} does not equal {{c|sizeof...(UTypes)}}, or any of the comparison expression shown in the equivalent-to statements is not a valid expression, the program is ill-formed.

@@ If the type and value category of any of the comparison expression shown in the equivalent-to statements do not meet the {{named req|BooleanTestable}} requirements, the behavior is undefined.

@7@ Compares {{c|lhs}} and {{c|rhs}} lexicographically by {{lti|cpp/standard library/synth-three-way}}, that is, compares the first elements, if they are equivalent, compares the second elements, if those are equivalent, compares the third elements, and so on.
* For empty tuples, returns {{ltt|cpp/utility/compare/strong_ordering|std::strong_ordering::equal}}.
* For non-empty tuples, the effect is equivalent to
:@@ {{box|
{{c/core|1=if (auto c =}}{{nbspt}}{{lti|cpp/standard library/synth-three-way}}{{c/core|1=(std::get&lt;0&gt;(lhs), std::get&lt;0&gt;(rhs)); c != 0) return c;}}&lt;br&gt;
{{c/core|1=if (auto c =}}{{nbspt}}{{lti|cpp/standard library/synth-three-way}}{{c/core|1=(std::get&lt;1&gt;(lhs), std::get&lt;1&gt;(rhs)); c != 0) return c;}}&lt;br&gt;
{{tt|...}}&lt;br&gt;
{{c/core|return}}{{nbspt}}{{lti|cpp/standard library/synth-three-way}}{{c/core|(std::get&lt;N - 1&gt;(lhs), std::get&lt;N - 1&gt;(rhs));}}
}}

@8@ Same as {{v|1}}, except that {{c|rhs}} is a {{rlpi|tuple-like}} object, and the number of elements of {{c|rhs}} is determined by {{c|std::tuple_size_v&lt;UTuple&gt;}} instead. This overload can only be found via [[cpp/language/adl|argument-dependent lookup]].

@9@ Same as {{v|7}}, except that {{c|rhs}} is a {{rlpi|tuple-like}} object. {{c/core|/* Elems */}} denotes the pack of types {{c/core|std::tuple_element_t&lt;i, UTuple&gt;}} for each {{c|i}} in {{range|0|std::tuple_size_v&lt;UTuple&gt;}} in increasing order. This overload can only be found via [[cpp/language/adl|argument-dependent lookup]].

All comparison operators are short-circuited; they do not access tuple elements beyond what is necessary to determine the result of the comparison.

{{rrev|since=c++20|
{{cpp/note synthesized compare}}
}}

===Parameters===
{{par begin}}
{{par|lhs, rhs|tuples to compare}}
{{par end}}

===Return value===
@1,8@ {{c|true}} if {{c|1=std::get&lt;i&gt;(lhs) == std::get&lt;i&gt;(rhs)}} for all {{c|i}} in {{range|0|sizeof...(Types)}}, otherwise {{c|false}}. For two empty tuples returns {{c|true}}.

@2@ {{c|1=!(lhs == rhs)}}

@3@ {{c|true}} if the first non-equivalent element in {{c|lhs}} is less than the one in {{c|rhs}}, {{c|false}} if the first non-equivalent element in {{c|rhs}} is less than the one in {{c|lhs}} or there is no non-equivalent element. For two empty tuples, returns {{c|false}}.

@4@ {{c|!(rhs &lt; lhs)}}

@5@ {{c|rhs &lt; lhs}}

@6@ {{c|!(lhs &lt; rhs)}}

@7,9@ The relation between the first pair of non-equivalent elements if there is any, {{ltt|cpp/utility/compare/strong_ordering|std::strong_ordering::equal}} otherwise. For two empty tuples, returns {{ltt|cpp/utility/compare/strong_ordering|std::strong_ordering::equal}}.

===Notes===
{{rrev multi|rev1=
The relational operators are defined in terms of each element's {{c/core|operator&lt;}}.
|since2=c++20|rev2=
The relational operators are defined in terms of {{lti|cpp/standard library/synth-three-way}}, which uses {{c/core|1=operator&lt;=&gt;}} if possible, or {{c/core|operator&lt;}} otherwise.

Notably, if an element type does not itself provide {{c/core|1=operator&lt;=&gt;}}, but is implicitly convertible to a three-way comparable type, that conversion will be used instead of {{c/core|operator&lt;}}.
}}

{{feature test macro|__cpp_lib_constrained_equality|Constrained {{c/core|1=operator==}} for {{lc|std::tuple}}|value=202403L|std=C++26}}

===Example===
{{example
|Because {{c/core|operator&lt;}} is defined for tuples, containers of tuples can be sorted.
|code=
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;std::tuple&lt;int, std::string, float&gt;&gt; v
    {
        {2, "baz", -0.1},
        {2, "bar", 3.14},
        {1, "foo", 10.1},
        {2, "baz", -1.1},
    };
    std::sort(v.begin(), v.end());

    for (const auto&amp; p: v)
        std::cout &lt;&lt; "{ " &lt;&lt; get&lt;0&gt;(p)
                  &lt;&lt; ", " &lt;&lt; get&lt;1&gt;(p)
                  &lt;&lt; ", " &lt;&lt; get&lt;2&gt;(p)
                  &lt;&lt; " }\n";
}
|output=
{ 1, foo, 10.1 }
{ 2, bar, 3.14 }
{ 2, baz, -1.1 }
{ 2, baz, -0.1 }
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2114|paper=P2167R3|std=C++11|before=type preconditions for boolean operations were missing|after=added}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/pair/dsc operator cmp}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}