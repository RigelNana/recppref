{{cpp/title|tie}}
{{cpp/utility/tuple/navbar}}
{{dcl begin}}
{{dcl header|tuple}}
{{dcla|since=c++11|constexpr=c++14|1=
template&lt; class... Types &gt;
std::tuple&lt;Types&amp;...&gt; tie( Types&amp;... args ) noexcept;
}}
{{dcl end}}

Creates a tuple of lvalue references to its arguments or instances of {{lc|std::ignore}}.

===Parameters===
{{par begin}}
{{par|args|zero or more lvalue arguments to construct the tuple from.}}
{{par end}}

===Return value===
A {{lc|std::tuple}} object containing lvalue references.

===Possible implementation===
{{eq fun|1=
template &lt;typename... Args&gt;
constexpr // since C++14
std::tuple&lt;Args&amp;...&gt; tie(Args&amp;... args) noexcept
{
    return {args...};
}
}}

===Notes===
{{tt|std::tie}} may be used to unpack a {{lc|std::pair}} because {{lc|std::tuple}} has a [[cpp/utility/tuple/operator{{=}}|converting assignment]] from pairs:
{{source|1=
bool result;
std::tie(std::ignore, result) = set.insert(value);
}}

===Example===
{{example
|1) {{tt|std::tie}} can be used to introduce lexicographical comparison to a struct or to unpack a tuple;&lt;br&gt;
2) {{tt|std::tie}} can work with {{lt|cpp/language/structured binding}}s:
|code=
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

struct S
{
    int n;
    std::string s;
    float d;

    friend bool operator&lt;(const S&amp; lhs, const S&amp; rhs) noexcept
    {
        // compares lhs.n to rhs.n,
        // then lhs.s to rhs.s,
        // then lhs.d to rhs.d
        // in that order, first non-equal result is returned
        // or false if all elements are equal
        return std::tie(lhs.n, lhs.s, lhs.d) &lt; std::tie(rhs.n, rhs.s, rhs.d);
    }
};

int main()
{
    // Lexicographical comparison demo:
    std::set&lt;S&gt; set_of_s;

    S value{42, "Test", 3.14};
    std::set&lt;S&gt;::iterator iter;
    bool is_inserted;

    // Unpack a pair:
    std::tie(iter, is_inserted) = set_of_s.insert(value);
    assert(is_inserted);


    // std::tie and structured bindings:
    auto position = [](int w) { return std::tuple(1 * w, 2 * w); };

    auto [x, y] = position(1);
    assert(x == 1 &amp;&amp; y == 2);
    std::tie(x, y) = position(2); // reuse x, y with tie
    assert(x == 2 &amp;&amp; y == 4);


    // Implicit conversions are permitted:
    std::tuple&lt;char, short&gt; coordinates(6, 9);
    std::tie(x, y) = coordinates;
    assert(x == 6 &amp;&amp; y == 9);

    // Skip an element:
    std::string z;
    std::tie(x, std::ignore, z) = std::tuple(1, 2.0, "Test");
    assert(x == 1 &amp;&amp; z == "Test");
}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc structured binding}}
{{dsc inc|cpp/utility/tuple/dsc make_tuple}}
{{dsc inc|cpp/utility/tuple/dsc forward_as_tuple}}
{{dsc inc|cpp/utility/tuple/dsc tuple_cat}}
{{dsc inc|cpp/utility/tuple/dsc ignore}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}