{{cpp/title|as_const}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|utility}}
{{dcl|since=c++17|num=1|1=
template&lt; class T &gt;
constexpr std::add_const_t&lt;T&gt;&amp; as_const( T&amp; t ) noexcept;
}}
{{dcl|since=c++17|num=2|1=
template&lt; class T &gt;
void as_const( const T&amp;&amp; ) = delete;
}}
{{dcl end}}

@1@ Forms lvalue reference to const type of {{c|t}}.
@2@ const rvalue reference overload is deleted to disallow rvalue arguments.

===Possible implementation===
{{eq fun
|1=
template&lt;class T&gt;
constexpr std::add_const_t&lt;T&gt;&amp; as_const(T&amp; t) noexcept
{
    return t;
}
}}

===Notes===
{{feature test macro|__cpp_lib_as_const|value=201510L|std=C++17|[[#Top|{{tt|std::as_const}}]]}}

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;
#include &lt;utility&gt;

int main()
{
    std::string mutableString = "Hello World!";
    auto&amp;&amp; constRef = std::as_const(mutableString);

    mutableString.clear(); // OK
//  constRef.clear(); // Error: 'constRef' is 'const' qualified,
                      //        but 'clear' is not marked const

    assert(&amp;constRef == &amp;mutableString);
    assert(&amp;std::as_const(mutableString) == &amp;mutableString);

    using ExprType = std::remove_reference_t&lt;decltype(std::as_const(mutableString))&gt;;

    static_assert(std::is_same_v&lt;std::remove_const_t&lt;ExprType&gt;, std::string&gt;,
                  "ExprType should be some kind of string.");
    static_assert(!std::is_same_v&lt;ExprType, std::string&gt;,
                  "ExprType shouldn't be a mutable string.");
}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_const}}
{{dsc inc|cpp/types/dsc add_cv}}
{{dsc inc|cpp/types/dsc remove_cv}}
{{dsc inc|cpp/ranges/dsc as_const_view}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}