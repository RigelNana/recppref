{{cpp/utility/initializer_list/title|initializer_list}}
{{cpp/utility/initializer_list/navbar}}
{{ddcla|since=c++11|constexpr=c++14|
initializer_list() noexcept;
}}

Constructs an empty initializer list.

===Parameters===
(none)

===Complexity===
Constant

===Notes===
Despite a lack of constructors, it is possible to create non-empty initializer lists.  Instances of {{tt|std::initializer_list}} are implicitly constructed when:
* a ''braced-init-list'' is used in [[cpp/language/list_initialization|list-initialization]], including function-call list initialization and assignment expressions (not to be confused with [[cpp/language/initializer_list|constructor initializer lists]])
* a ''braced-init-list'' is bound to {{c/core|auto}}, including in a [[cpp/language/range-for|ranged for loop]]

===Example===
{{example
|
|code=
#include &lt;initializer_list&gt;
#include &lt;iostream&gt;

int main()
{
    std::initializer_list&lt;int&gt; empty_list;
    std::cout &lt;&lt; "empty_list.size(): " &lt;&lt; empty_list.size() &lt;&lt; '\n';

    // create initializer lists using list-initialization
    std::initializer_list&lt;int&gt; digits{1, 2, 3, 4, 5};
    std::cout &lt;&lt; "digits.size(): " &lt;&lt; digits.size() &lt;&lt; '\n';

    // special rule for auto means 'fractions' has the
    // type std::initializer_list&lt;double&gt;
    auto fractions = {3.14159, 2.71828};
    std::cout &lt;&lt; "fractions.size(): " &lt;&lt; fractions.size() &lt;&lt; '\n';

    // create constexpr initializer list (since C++14)
    static constexpr auto ab = {'a', 'b'};
    static_assert(ab.size() == 2 and *ab.begin() == 'a');
}
|output=
empty_list.size(): 0
digits.size(): 5
fractions.size(): 2
}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}