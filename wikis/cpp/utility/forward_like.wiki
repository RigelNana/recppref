{{cpp/title|forward_like}}
{{cpp/utility/navbar}}
{{ddcl|header=utility|since=c++23|
template&lt; class T, class U &gt;
constexpr auto&amp;&amp; forward_like( U&amp;&amp; x ) noexcept;
}}

Returns a reference to {{c|x}} which has similar properties to {{tt|T&amp;&amp;}}.

The return type is determined as below:
# If {{c/core|std::remove_reference_t&lt;T&gt;}} is a const-qualified type, then the referenced type of the return type is {{c/core|const std::remove_reference_t&lt;U&gt;}}. Otherwise, the referenced type is {{c/core|std::remove_reference_t&lt;U&gt;}}.
# If {{tt|T&amp;&amp;}} is an lvalue reference type, then the return type is also an lvalue reference type. Otherwise, the return type is an rvalue reference type.

If {{tt|T}} is not a [[cpp/meta#Definitions|referenceable type]], the program is ill-formed.

===Parameters===
{{par begin}}
{{par|x|a value needs to be forwarded like type {{tt|T}}}}
{{par end}}

===Return value===
A reference to {{c|x}} of the type determined as above.

===Notes===
Like {{lc|std::forward}}, {{ltt|cpp/utility/move|std::move}}, and {{lc|std::as_const}}, {{tt|std::forward_like}} is a type cast that only influences the {{lt|cpp/language/value category}} of an expression, or potentially adds const-qualification.

When {{tt|m}} is an actual member and thus {{c|o.m}} a valid expression, this is usually spelled as {{c|std::forward&lt;decltype(o)&gt;(o).m}} in C++20 code.

This leads to three possible models, called ''merge'', ''tuple'', and ''language''.
* ''merge'': merge the {{c/core|const}} qualifiers, and adopt the value category of the {{tt|Owner}}.
* ''tuple'': what {{c|std::get&lt;0&gt;(Owner)}} does, assuming {{tt|Owner}} is a {{c/core|std::tuple&lt;Member&gt;}}.
* ''language'': what {{c|std::forward&lt;decltype(Owner)&gt;(o).m}} does.

The main scenario that {{tt|std::forward_like}} caters to is adapting “far” objects. Neither the ''tuple'' nor the ''language'' scenarios do the right thing for that main use-case, so the ''merge'' model is used for {{tt|std::forward_like}}.

{{feature test macro|__cpp_lib_forward_like|[[#Top|{{tt|std::forward_like}}]]|value=202207L|std=C++23}}

===Possible implementation===
{{eq fun|1=
template&lt;class T, class U&gt;
constexpr auto&amp;&amp; forward_like(U&amp;&amp; x) noexcept
{
    constexpr bool is_adding_const = std::is_const_v&lt;std::remove_reference_t&lt;T&gt;&gt;;
    if constexpr (std::is_lvalue_reference_v&lt;T&amp;&amp;&gt;)
    {
        if constexpr (is_adding_const)
            return std::as_const(x);
        else
            return static_cast&lt;U&amp;&gt;(x);
    }
    else
    {
        if constexpr (is_adding_const)
            return std::move(std::as_const(x));
        else
            return std::move(x);
    }
}
}}

===Example===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;optional&gt;
#include &lt;type_traits&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

struct TypeTeller
{
    void operator()(this auto&amp;&amp; self)
    {
        using SelfType = decltype(self);
        using UnrefSelfType = std::remove_reference_t&lt;SelfType&gt;;
        if constexpr (std::is_lvalue_reference_v&lt;SelfType&gt;)
        {
            if constexpr (std::is_const_v&lt;UnrefSelfType&gt;)
                std::cout &lt;&lt; "const lvalue\n";
            else
                std::cout &lt;&lt; "mutable lvalue\n";
        }
        else
        {
            if constexpr (std::is_const_v&lt;UnrefSelfType&gt;)
                std::cout &lt;&lt; "const rvalue\n";
            else
                std::cout &lt;&lt; "mutable rvalue\n";
        }
    }
};

struct FarStates
{
    std::unique_ptr&lt;TypeTeller&gt; ptr;
    std::optional&lt;TypeTeller&gt; opt;
    std::vector&lt;TypeTeller&gt; container;
    
    auto&amp;&amp; from_opt(this auto&amp;&amp; self)
    {
        return std::forward_like&lt;decltype(self)&gt;(self.opt.value());
        // It is OK to use std::forward&lt;decltype(self)&gt;(self).opt.value(),
        // because std::optional provides suitable accessors.
    }
    
    auto&amp;&amp; operator[](this auto&amp;&amp; self, std::size_t i)
    {
        return std::forward_like&lt;decltype(self)&gt;(self.container.at(i));
        // It is not so good to use std::forward&lt;decltype(self)&gt;(self)[i], because
        // containers do not provide rvalue subscript access, although they could.
    }
    
    auto&amp;&amp; from_ptr(this auto&amp;&amp; self)
    {
        if (!self.ptr)
            throw std::bad_optional_access{};
        return std::forward_like&lt;decltype(self)&gt;(*self.ptr);
        // It is not good to use *std::forward&lt;decltype(self)&gt;(self).ptr, because
        // std::unique_ptr&lt;TypeTeller&gt; always dereferences to a non-const lvalue.
    }
};

int main()
{
    FarStates my_state
    {
        .ptr{std::make_unique&lt;TypeTeller&gt;()},
        .opt{std::in_place, TypeTeller{}&lt;!----&gt;},
        .container{std::vector&lt;TypeTeller&gt;(1)},
    };
    
    my_state.from_ptr()();
    my_state.from_opt()();
    my_state[0]();

    std::cout &lt;&lt; '\n';
    
    std::as_const(my_state).from_ptr()();
    std::as_const(my_state).from_opt()();
    std::as_const(my_state)[0]();
    
    std::cout &lt;&lt; '\n';
    
    std::move(my_state).from_ptr()();
    std::move(my_state).from_opt()();
    std::move(my_state)[0]();
    
    std::cout &lt;&lt; '\n';
    
    std::move(std::as_const(my_state)).from_ptr()();
    std::move(std::as_const(my_state)).from_opt()();
    std::move(std::as_const(my_state))[0]();
    
    std::cout &lt;&lt; '\n';
}
|output=
mutable lvalue
mutable lvalue
mutable lvalue

const lvalue
const lvalue
const lvalue

mutable rvalue
mutable rvalue
mutable rvalue

const rvalue
const rvalue
const rvalue
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/dsc move}}
{{dsc inc|cpp/utility/dsc forward}}
{{dsc inc|cpp/utility/dsc as_const}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}