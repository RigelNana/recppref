{{cpp/title|optional}}
{{cpp/utility/optional/navbar}}
{{ddcl|header=optional|since=c++17|
template&lt; class T &gt;
class optional;
}}

The class template {{tt|std::optional}} manages an ''optional'' contained value, i.e. a value that may or may not be present.

A common use case for {{tt|optional}} is the return value of a function that may fail. As opposed to other approaches, such as {{c/core|std::pair&lt;T, bool&gt;}}, {{tt|optional}} handles expensive-to-construct objects well and is more readable, as the intent is expressed explicitly.

Any instance of {{tt|optional&lt;T&gt;}} at any given point in time either ''contains a value'' or ''does not contain a value''.

If an {{tt|optional&lt;T&gt;}} ''contains a value'', the value is guaranteed to be [[cpp/language/object#Address|nested within]] the {{tt|optional}} object, which means that no dynamic memory allocation ever takes place. Thus, an {{tt|optional}} object models an object, not a pointer, even though {{lc|operator*()}} and {{lc|operator-&gt;()}} are defined.

When an object of type {{tt|optional&lt;T&gt;}} is [[cpp/language/implicit_conversion#Contextual conversions|contextually converted to {{c/core|bool}}]], the conversion returns {{c|true}} if the object ''contains a value'' and {{c|false}} if it ''does not contain a value''.

The {{tt|optional}} object ''contains a value'' in the following conditions:

* The object is initialized with/assigned from a value of type {{tt|T}} or another {{tt|optional}} that ''contains a value''.

The object ''does not contain a value'' in the following conditions:

* The object is default-initialized.
* The object is initialized with/assigned from a value of type {{lc|std::nullopt_t}} or an  {{tt|optional}} object that ''does not contain a value''.
* The member function {{lc|reset()}} is called.

{{rrev|since=c++26|1=
The {{tt|optional}} object is a {{lconcept|view}} that contains either one element if it ''contains a value'', or otherwise zero elements if it ''does not contain a value''. The lifetime of the contained element is bound to the object.
}}

There are no optional references, functions, arrays, or ''cv'' {{c/core|void}}; a program is ill-formed if it instantiates an {{tt|optional}} with such a type. In addition, a program is ill-formed if it instantiates an {{tt|optional}} with the (possibly cv-qualified) tag types {{lc|std::nullopt_t}} or {{lc|std::in_place_t}}.

===Template parameters===
{{par begin}}
{{par|T|the type of the value to manage initialization state for. The type must meet the requirements of {{named req|Destructible}} (in particular, array and reference types are not allowed).}}
{{par end}}

===Member types===
{{dsc begin}}
{{dsc hitem|Member name|Definition}}
{{dsc|{{tt|value_type}}|{{tt|T}}}}
{{dsc|{{tt|iterator}} {{mark since c++26}}|implementation-defined {{named req|RandomAccessIterator}}, {{named req|ConstexprIterator}}, and {{lconcept|contiguous_iterator}} whose {{tt|value_type}} and {{tt|reference}} are {{c/core|std::remove_cv_t&lt;T&gt;}} and {{c/core|T&amp;}}, respectively.}}
{{dsc|{{tt|const_iterator}} {{mark since c++26}}|implementation-defined {{named req|RandomAccessIterator}}, {{named req|ConstexprIterator}}, and {{lconcept|contiguous_iterator}} whose {{tt|value_type}} and {{tt|reference}} are {{c/core|std::remove_cv_t&lt;T&gt;}} and {{c/core|const T&amp;}}, respectively.}}
{{dsc end}}

All requirements on the iterator types of a {{named req|Container}} apply to the {{tt|iterator}} type of {{tt|optional}} as well.

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/utility/optional/dsc constructor}}
{{dsc inc|cpp/utility/optional/dsc destructor}}
{{dsc inc|cpp/utility/optional/dsc operator{{=}}}}

{{dsc h2|Iterators}}
{{dsc inc|cpp/utility/optional/dsc begin}}
{{dsc inc|cpp/utility/optional/dsc end}}

{{dsc h2|Observers}}
{{dsc inc|cpp/utility/optional/dsc operator*}}
{{dsc inc|cpp/utility/optional/dsc operator bool}}
{{dsc inc|cpp/utility/optional/dsc value}}
{{dsc inc|cpp/utility/optional/dsc value_or}}

{{dsc h2|Monadic operations}}
{{dsc inc|cpp/utility/optional/dsc and_then}}
{{dsc inc|cpp/utility/optional/dsc transform}}
{{dsc inc|cpp/utility/optional/dsc or_else}}

{{dsc h2|Modifiers}}
{{dsc inc|cpp/utility/optional/dsc swap}}
{{dsc inc|cpp/utility/optional/dsc reset}}
{{dsc inc|cpp/utility/optional/dsc emplace}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/utility/optional/dsc operator_cmp}}
{{dsc inc|cpp/utility/optional/dsc make_optional}}
{{dsc inc|cpp/utility/optional/dsc swap2}}
{{dsc end}}

===Helper classes===
{{dsc begin}}
{{dsc inc|cpp/utility/optional/dsc hash}}
{{dsc inc|cpp/utility/optional/dsc nullopt_t}}
{{dsc inc|cpp/utility/optional/dsc bad_optional_access}}
{{dsc end}}

===Helpers ===
{{dsc begin}}
{{dsc inc|cpp/utility/optional/dsc nullopt}}
{{dsc inc|cpp/utility/optional/dsc in_place}}
{{dsc end}}

===Helper specializations===
{{ddcl|since=c++26|1=
template&lt; class T &gt;
constexpr bool ranges::enable_view&lt;std::optional&lt;T&gt;&gt; = true;
}}
This specialization of {{lc|ranges::enable_view}} makes {{tt|optional}} satisfy {{lconcept|view}}.

{{ddcl|since=c++26|1=
template&lt; class T &gt;
constexpr auto format_kind&lt;std::optional&lt;T&gt;&gt; = range_format::disabled;
}}
This specialization of {{lc|format_kind}} disables the [[cpp/utility/format/ranges_formatter|range formatting support]] of {{tt|optional}}.

===[[cpp/utility/optional/deduction_guides|Deduction guides]]===

===Notes===
{{ftm begin|sort=yes}}
{{ftm|std=C++17|value=201606L|__cpp_lib_optional|{{tt|std::optional}}|rowspan="3"}}
{{ftm|std=C++23|dr=20|value=202106L|-|Fully {{c/core|constexpr}}}}
{{ftm|std=C++23|value=202110L|-|{{ls|#Monadic operations}}}}
{{ftm|std=C++26|value=202406L|__cpp_lib_optional_range_support|Range support for {{tt|std::optional}}}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;optional&gt;
#include &lt;string&gt;
 
// optional can be used as the return type of a factory that may fail
std::optional&lt;std::string&gt; create(bool b)
{
    if (b)
        return "Godzilla";
    return {};
}

// std::nullopt can be used to create any (empty) std::optional
auto create2(bool b)
{
    return b ? std::optional&lt;std::string&gt;{"Godzilla"} : std::nullopt;
}

int main()
{
    std::cout &lt;&lt; "create(false) returned "
              &lt;&lt; create(false).value_or("empty") &lt;&lt; '\n';
    
    // optional-returning factory functions are usable as conditions of while and if
    if (auto str = create2(true))
        std::cout &lt;&lt; "create2(true) returned " &lt;&lt; *str &lt;&lt; '\n';
}
|output=
create(false) returned empty
create2(true) returned Godzilla
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/dsc variant}}
{{dsc inc|cpp/utility/dsc any}}
{{dsc inc|cpp/utility/dsc expected}}
{{dsc inc|cpp/ranges/dsc single_view}}
{{dsc inc|cpp/ranges/dsc empty_view}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}