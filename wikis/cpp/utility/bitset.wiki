{{cpp/title|bitset}}
{{cpp/utility/bitset/navbar}}
{{ddcl|header=bitset|
template&lt; std::size_t N &gt;
class bitset;
}}

The class template {{tt|bitset}} represents a fixed-size sequence of {{tt|N}} bits. Bitsets can be manipulated by standard logic operators and converted to and from strings and integers. For the purpose of the string representation and of naming directions for shift operations, the sequence is thought of as having its lowest indexed elements at the ''right'', as in the binary representation of integers.

{{tt|bitset}} meets the requirements of {{named req|CopyConstructible}} and {{named req|CopyAssignable}}.

{{rrev|since=c++23|
All member functions of {{tt|std::bitset}} are {{c/core|constexpr}}: it is possible to create and use {{tt|std::bitset}} objects in the evaluation of a constant expression.}}

===Template parameters===
{{par begin}}
{{par|N|the number of bits to allocate storage for}}
{{par end}}

===Member types===
{{dsc begin}}
{{dsc class|cpp/utility/bitset/reference|proxy class representing a reference to a bit}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/utility/bitset/dsc constructor}}
{{dsc inc|cpp/utility/bitset/dsc operator_cmp}}
{{dsc h2|Element access}}
{{dsc inc|cpp/utility/bitset/dsc operator_at}}
{{dsc inc|cpp/utility/bitset/dsc test}}
{{dsc inc|cpp/utility/bitset/dsc all_any_none}}
{{dsc inc|cpp/utility/bitset/dsc count}}

{{dsc h2|Capacity}}
{{dsc inc|cpp/utility/bitset/dsc size}}

{{dsc h2|Modifiers}}
{{dsc inc|cpp/utility/bitset/dsc operator_logic}}
{{dsc inc|cpp/utility/bitset/dsc operator_ltltgtgt}}
{{dsc inc|cpp/utility/bitset/dsc set}}
{{dsc inc|cpp/utility/bitset/dsc reset}}
{{dsc inc|cpp/utility/bitset/dsc flip}}

{{dsc h2|Conversions}}
{{dsc inc|cpp/utility/bitset/dsc to_string}}
{{dsc inc|cpp/utility/bitset/dsc to_ulong}}
{{dsc inc|cpp/utility/bitset/dsc to_ullong}}

{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/utility/bitset/dsc operator_logic2}}
{{dsc inc|cpp/utility/bitset/dsc operator_ltltgtgt2}}
{{dsc end}}

===Helper classes===
{{dsc begin}}
{{dsc inc|cpp/utility/bitset/dsc hash}}
{{dsc end}}

===Notes===
If the size of a bit-set is not known at compile time, or it is necessary to change its size at run-time, the dynamic types such as {{ltt|cpp/container/vector bool|std::vector&lt;bool&gt;}} or [https://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html {{tt|boost::dynamic_bitset&lt;&gt;}}] may be used instead.

{{ftm begin}}
{{ftm|__cpp_lib_constexpr_bitset|std=C++23|value=202207L|A more constexpr {{tt|std::bitset}}}}
{{ftm|__cpp_lib_bitset|std=C++26|value=202306L|Interfacing {{tt|std::bitset}} with {{lc|std::string_view}}}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;cstddef&gt;
#include &lt;iostream&gt;

int main()
{
    typedef std::size_t length_t, position_t; // the hints

    // constructors:
    constexpr std::bitset&lt;4&gt; b1;
    constexpr std::bitset&lt;4&gt; b2{0xA}; // == 0B1010
    std::bitset&lt;4&gt; b3{"0011"}; // can also be constexpr since C++23
    std::bitset&lt;8&gt; b4{"ABBA", length_t(4), /*0:*/'A', /*1:*/'B'}; // == 0B0000'0110

    // bitsets can be printed out to a stream:
    std::cout &lt;&lt; "b1:" &lt;&lt; b1 &lt;&lt; "; b2:" &lt;&lt; b2 &lt;&lt; "; b3:" &lt;&lt; b3 &lt;&lt; "; b4:" &lt;&lt; b4 &lt;&lt; '\n';

    // bitset supports bitwise operations:
    b3 {{!}}= 0b0100; assert(b3 == 0b0111);
    b3 &amp;= 0b0011; assert(b3 == 0b0011);
    b3 ^= std::bitset&lt;4&gt;{0b1100}; assert(b3 == 0b1111);

    // operations on the whole set:
    b3.reset(); assert(b3 == 0);
    b3.set(); assert(b3 == 0b1111);
    assert(b3.all() &amp;&amp; b3.any() &amp;&amp; !b3.none());
    b3.flip(); assert(b3 == 0);

    // operations on individual bits:
    b3.set(position_t(1), true); assert(b3 == 0b0010);
    b3.set(position_t(1), false); assert(b3 == 0);
    b3.flip(position_t(2)); assert(b3 == 0b0100);
    b3.reset(position_t(2)); assert(b3 == 0);

    // subscript operator[] is supported:
    b3[2] = true; assert(true == b3[2]);

    // other operations:
    assert(b3.count() == 1);
    assert(b3.size() == 4);
    assert(b3.to_ullong() == 0b0100ULL);
    assert(b3.to_string() == "0100");
}
|output=b1:0000; b2:1010; b3:0011; b4:00000110
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/container/dsc vector_bool}}
{{dsc|[[cpp/numeric#Bit manipulation (since C++20)|'''Bit manipulation''']] {{mark c++20}}|utilities to access, manipulate, and process individual bits and bit sequences}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pl|pt|ru|zh}}