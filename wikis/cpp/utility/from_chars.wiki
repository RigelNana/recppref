{{cpp/title|from_chars}}
{{cpp/text/navbar}}
{{dcl begin}}
{{dcl header|charconv}}
{{dcl|num=1|since=c++17|notes={{mark constexpr since c++23}}|1=
std::from_chars_result
    from_chars( const char* first, const char* last,
                /* integer-type */&amp; value, int base = 10 );
}}
{{dcl|num=2|since=c++17|1=
std::from_chars_result
    from_chars( const char* first, const char* last,
                /* floating-point-type */&amp; value,
                std::chars_format fmt = std::chars_format::general );
}}
{{dcl end}}

Analyzes the character sequence {{range|first|last}} for a pattern described below. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of {{c|value}}, {{c|value}} is unmodified, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in {{c|value}}.

@1@ Integer parsers: Expects the pattern identical to the one used by {{lc|std::strtol}} in the default ("C") locale and the given non-zero numeric base, except that
* {{c|"0x"}} or {{c|"0X"}} prefixes are not recognized if {{c|base}} is 16
* only the minus sign is recognized (not the plus sign), and only for signed integer types of {{c|value}}
* leading whitespace is not ignored.
The library provides overloads for all{{rev inl|since=c++23| cv-unqualified}} signed and unsigned integer types and {{c/core|char}} as the referenced type of the parameter {{c|value}}.

@2@ Floating-point parsers: Expects the pattern identical to the one used by {{lc|std::strtod}} in the default ("C") locale, except that
* the plus sign is not recognized outside of the exponent (only the minus sign is permitted at the beginning) &lt;!-- LWG 3080 ---&gt;
* if {{tt|fmt}} has {{ltt|cpp/utility/chars_format|std::chars_format::scientific}} set but not {{ltt|cpp/utility/chars_format|std::chars_format::fixed}}, the exponent part is required (otherwise it is optional)
* if {{tt|fmt}} has {{ltt|cpp/utility/chars_format|std::chars_format::fixed}} set but not {{ltt|cpp/utility/chars_format|std::chars_format::scientific}}, the optional exponent is not permitted
* if {{tt|fmt}} is {{ltt|cpp/utility/chars_format|std::chars_format::hex}}, the prefix {{c|"0x"}} or {{c|"0X"}} is not permitted (the string {{c|"0x123"}} parses as the value {{c|"0"}} with unparsed remainder {{c|"x123"}})
* leading whitespace is not ignored.

@@ In any case, the resulting value is one of at most two floating-point values closest to the value of the string matching the pattern, after rounding according to {{lc|std::round_to_nearest}}.

@@ The library provides overloads for all cv-unqualified {{rev inl|until=c++23|standard}} floating-point types as the referenced type of the parameter {{c|value}}.

===Parameters===
{{par begin}}
{{par|first, last|valid character range to parse}}
{{par|value|the out-parameter where the parsed value is stored if successful}}
{{par|base|integer base to use: a value between 2 and 36 (inclusive).}}
{{par|fmt|floating-point formatting to use, a bitmask of type    {{ltt std|cpp/utility/chars_format}}}}
{{par end}}

===Return value===
On success, returns a value of type {{ltt std|cpp/utility/from_chars_result}} such that {{tt|ptr}} points at the first character not matching the pattern, or has the value equal to {{c|last}} if all characters match and {{tt|ec}} is value-initialized.

If there is no pattern match, returns a value of type {{ltt std|cpp/utility/from_chars_result}} such that {{tt|ptr}} equals {{c|first}} and {{tt|ec}} equals {{lc|std::errc::invalid_argument}}. {{c|value}} is unmodified.

If the pattern was matched, but the parsed value is not in the range representable by the type of {{c|value}}, returns value of type {{ltt std|cpp/utility/from_chars_result}} such that {{tt|ec}} equals {{lc|std::errc::result_out_of_range}} and {{tt|ptr}} points at the first character not matching the pattern. {{c|value}} is unmodified.

===Exceptions===
Throws nothing.

===Notes===
Unlike other parsing functions in C++ and C libraries, {{tt|std::from_chars}} is locale-independent, non-allocating, and non-throwing. Only a small subset of parsing policies used by other libraries (such as {{lc|std::sscanf}}) is provided. This is intended to allow the fastest possible implementation that is useful in common high-throughput contexts such as text-based interchange ({{enwiki|JSON}} or {{enwiki|XML}}).

The guarantee that {{tt|std::from_chars}} can recover every floating-point value formatted by {{ltt std|cpp/utility/to_chars}} exactly is only provided if both functions are from the same implementation.

A pattern consisting of a sign with no digits following it is treated as pattern that did not match anything.

{{ftm begin|std=yes}}
{{ftm|std=C++17|value=201611L|__cpp_lib_to_chars|rowspan="2"|Elementary string conversions ({{tt|std::from_chars}}, {{ltt std|cpp/utility/to_chars}})}}
{{ftm|std=C++26|value=202306L|-|Testing for success or failure of {{header|charconv}} functions}}
{{ftm|std=C++23|value=202207L|__cpp_lib_constexpr_charconv|Add {{co|constexpr}} modifiers to {{tt|std::from_chars}} and {{ltt std|cpp/utility/to_chars}} overloads for integral types}}
{{ftm end}}

===Example===
{{cpp/utility/example_from_chars}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2955|std=C++17|before=this function was in {{header|utility}} and used {{lc|std::error_code}}|after=moved to {{header|charconv}} and uses {{lc|std::errc}}}}
{{dr list item|wg=lwg|dr=3373|std=C++17|before={{tt|std::from_chars_result}} might have additional members|after=additional members are prohibited}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/dsc from_chars_result}}
{{dsc inc|cpp/utility/dsc to_chars}}
{{dsc inc|cpp/string/basic_string/dsc stol}}
{{dsc inc|cpp/string/basic_string/dsc stof}}
{{dsc inc|cpp/string/byte/dsc strtol}}
{{dsc inc|cpp/string/byte/dsc strtof}}
{{dsc inc|cpp/io/c/dsc fscanf}}
{{dsc inc|cpp/io/basic_istream/dsc operator_gtgt}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}