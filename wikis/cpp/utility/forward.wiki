{{cpp/title|forward}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|utility}}
{{dcl rev multi|num=1
|since1=c++11|dcl1=
template&lt; class T &gt;
T&amp;&amp; forward( typename std::remove_reference&lt;T&gt;::type&amp; t ) noexcept;
|since2=c++14|dcl2=
template&lt; class T &gt;
constexpr T&amp;&amp; forward( std::remove_reference_t&lt;T&gt;&amp; t ) noexcept;
}}
{{dcl rev multi|num=2
|since1=c++11|dcl1=
template&lt; class T &gt;
T&amp;&amp; forward( typename std::remove_reference&lt;T&gt;::type&amp;&amp; t ) noexcept;
|since2=c++14|dcl2=
template&lt; class T &gt;
constexpr T&amp;&amp; forward( std::remove_reference_t&lt;T&gt;&amp;&amp; t ) noexcept;
}}
{{dcl end}}

@1@ Forwards lvalues as either lvalues or as rvalues, depending on T.

When {{c|t}} is a [[cpp/language/reference#Forwarding_references|forwarding reference]] (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the [[cpp/language/value_category|value category]] it had when passed to the calling function.

For example, if used in a wrapper such as the following, the template behaves as described below:

{{source|1=
template&lt;class T&gt;
void wrapper(T&amp;&amp; arg)
{
    // arg is always lvalue
    foo(std::forward&lt;T&gt;(arg)); // Forward as lvalue or as rvalue, depending on T
}
}}

* If a call to {{tt|wrapper()}} passes an rvalue {{tt|std::string}}, then {{tt|T}} is deduced to {{tt|std::string}} (not {{tt|std::string&amp;}}, {{tt|const std::string&amp;}}, or {{tt|std::string&amp;&amp;}}), and {{tt|std::forward}} ensures that an rvalue reference is passed to {{tt|foo}}.
* If a call to {{tt|wrapper()}} passes a const lvalue {{tt|std::string}}, then {{tt|T}} is deduced to {{tt|const std::string&amp;}}, and {{tt|std::forward}} ensures that a const lvalue reference is passed to {{tt|foo}}.
* If a call to {{tt|wrapper()}} passes a non-const lvalue {{tt|std::string}}, then {{tt|T}} is deduced to {{tt|std::string&amp;}}, and {{tt|std::forward}} ensures that a non-const lvalue reference is passed to {{tt|foo}}.

@2@ Forwards rvalues as rvalues and prohibits forwarding of rvalues as lvalues.

This overload makes it possible to forward a result of an expression (such as function call), which may be rvalue or lvalue, as the original value category of a forwarding reference argument.

For example, if a wrapper does not just forward its argument, but calls a member function on the argument, and forwards its result:
{{source|1=
// transforming wrapper
template&lt;class T&gt;
void wrapper(T&amp;&amp; arg)
{&lt;!-- example from http://stackoverflow.com/a/29135871 --&gt;
    foo(forward&lt;decltype(forward&lt;T&gt;(arg).get())&gt;(forward&lt;T&gt;(arg).get()));
}
}}

where the type of arg may be
{{source|1=
struct Arg
{
    int i = 1;
    int  get() &amp;&amp; { return i; } // call to this overload is rvalue
    int&amp; get() &amp;  { return i; } // call to this overload is lvalue
};
}}

Attempting to forward an rvalue as an lvalue, such as by instantiating the form {{v|2}} with lvalue reference type T, is a compile-time error.

===Notes===
See [[cpp/language/template_argument_deduction|template argument deduction]] for the special rules behind forwarding references ({{tt|T&amp;&amp;}} used as a function parameter) and [[cpp/language/reference#Forwarding_references|forwarding references]] for other detail.

===Parameters===
{{par begin}}
{{par|t|the object to be forwarded}}
{{par end}}

===Return value===
{{c|static_cast&lt;T&amp;&amp;&gt;(t)}}

===Complexity===
Constant.

===Example===
{{example
|This example demonstrates perfect forwarding of the parameter(s) to the argument of the constructor of class {{tt|T}}. Also, perfect forwarding of parameter packs is demonstrated.
|code=
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;utility&gt;

struct A
{
    A(int&amp;&amp; n) { std::cout &lt;&lt; "rvalue overload, n=" &lt;&lt; n &lt;&lt; '\n'; }
    A(int&amp; n)  { std::cout &lt;&lt; "lvalue overload, n=" &lt;&lt; n &lt;&lt; '\n'; }
};

class B
{
public:
    template&lt;class T1, class T2, class T3&gt;
    B(T1&amp;&amp; t1, T2&amp;&amp; t2, T3&amp;&amp; t3) :
        a1_{std::forward&lt;T1&gt;(t1)},
        a2_{std::forward&lt;T2&gt;(t2)},
        a3_{std::forward&lt;T3&gt;(t3)}
    {}

private:
    A a1_, a2_, a3_;
};

template&lt;class T, class U&gt;
std::unique_ptr&lt;T&gt; make_unique1(U&amp;&amp; u)
{
    return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;U&gt;(u)));
}

template&lt;class T, class... U&gt;
std::unique_ptr&lt;T&gt; make_unique2(U&amp;&amp;... u)
{
    return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;U&gt;(u)...));
}

auto make_B(auto&amp;&amp;... args) // since C++20
{
    return B(std::forward&lt;decltype(args)&gt;(args)...);
}

int main()
{
    auto p1 = make_unique1&lt;A&gt;(2); // rvalue
    int i = 1;
    auto p2 = make_unique1&lt;A&gt;(i); // lvalue
 
    std::cout &lt;&lt; "B\n";
    auto t = make_unique2&lt;B&gt;(2, i, 3);
    
    std::cout &lt;&lt; "make_B\n";
    [[maybe_unused]] B b = make_B(4, i, 5);
}
|output=
rvalue overload, n=2
lvalue overload, n=1
B
rvalue overload, n=2
lvalue overload, n=1
rvalue overload, n=3
make_B
rvalue overload, n=4
lvalue overload, n=1
rvalue overload, n=5
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/dsc move}}
{{dsc inc|cpp/utility/dsc move_if_noexcept}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}