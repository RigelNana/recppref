{{cpp/title|move}}
{{cpp/utility/navbar}}
{{dcl begin}}
{{dcl header|utility}}
{{dcl rev begin}}
{{dcl|since=c++11|until=c++14|
template&lt; class T &gt;
typename std::remove_reference&lt;T&gt;::type&amp;&amp; move( T&amp;&amp; t ) noexcept;
}}
{{dcl|since=c++14|
template&lt; class T &gt;
constexpr std::remove_reference_t&lt;T&gt;&amp;&amp; move( T&amp;&amp; t ) noexcept;
}}
{{dcl rev end}}
{{dcl end}}

{{tt|std::move}} is used to ''indicate'' that an object {{c|t}} may be "moved from", i.e. allowing the efficient transfer of resources from {{c|t}} to another object.

In particular, {{tt|std::move}} produces an [[cpp/language/value_category|xvalue expression]] that identifies its argument {{c|t}}. It is exactly equivalent to a {{tt|static_cast}} to an rvalue reference type.

===Parameters===
{{par begin}}
{{par|t|the object to be moved}}
{{par end}}

===Return value===
{{c|static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t)}}

===Notes===
The functions that accept rvalue reference parameters (including [[cpp/language/move_constructor|move constructors]], [[cpp/language/move_operator|move assignment operators]], and regular member functions such as {{lc|std::vector::push_back}}) are selected, by [[cpp/language/overload_resolution|overload resolution]], when called with [[cpp/language/value_category|rvalue]] arguments (either  [[cpp/language/value_category|prvalues]] such as a temporary object or  [[cpp/language/value_category|xvalue]]s such as the one produced by {{tt|std::move}}). If the argument identifies a resource-owning object, these overloads have the option, but aren't required, to ''move'' any resources held by the argument. For example, a move constructor of a linked list might copy the pointer to the head of the list and store {{c|nullptr}} in the argument instead of allocating and copying individual nodes.

Names of [[cpp/language/reference|rvalue reference]] variables are [[cpp/language/value_category|lvalues]] and have to be converted to [[cpp/language/value_category|xvalues]] to be bound to the function overloads that accept rvalue reference parameters, which is why [[cpp/language/move_constructor|move constructors]] and [[cpp/language/move_operator|move assignment operators]] typically use {{tt|std::move}}:
{{source|1=
// Simple move constructor
A(A&amp;&amp; arg) : member(std::move(arg.member)) // the expression "arg.member" is lvalue
{}

// Simple move assignment operator
A&amp; operator=(A&amp;&amp; other)
{
    member = std::move(other.member);
    return *this;
}
}}
One exception is when the type of the function parameter is a [[cpp/language/reference#Forwarding_references|forwarding reference]] (which looks like an rvalue reference to type template parameter), in which case {{lc|std::forward}} is used instead.

Unless otherwise specified, all standard library objects that have been moved from are placed in a "valid but unspecified state", meaning the object's class invariants hold (so functions without preconditions, such as the assignment operator, can be safely used on the object after it was moved from):
{{source|1=
std::vector&lt;std::string&gt; v;
std::string str = "example";
v.push_back(std::move(str)); // str is now valid but unspecified
str.back(); // undefined behavior if size() == 0: back() has a precondition !empty()
if (!str.empty())
    str.back(); // OK, empty() has no precondition and back() precondition is met

str.clear(); // OK, clear() has no preconditions
}}

Also, the standard library functions called with xvalue arguments may assume the argument is the only reference to the object; if it was constructed from an lvalue with {{tt|std::move}}, no aliasing checks are made. However, self-move-assignment of standard library types is guaranteed to place the object in a valid (but usually unspecified) state:
{{source|1=
std::vector&lt;int&gt; v = {2, 3, 3};
v = std::move(v); // the value of v is unspecified
}}

===Example===
{{example
|code=
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

int main()
{
    std::string str = "Salut";
    std::vector&lt;std::string&gt; v;

    // uses the push_back(const T&amp;) overload, which means
    // we'll incur the cost of copying str
    v.push_back(str);
    std::cout &lt;&lt; "After copy, str is " &lt;&lt; std::quoted(str) &lt;&lt; '\n';

    // uses the rvalue reference push_back(T&amp;&amp;) overload,
    // which means no strings will be copied; instead, the contents
    // of str will be moved into the vector. This is less
    // expensive, but also means str might now be empty.
    v.push_back(std::move(str));
    std::cout &lt;&lt; "After move, str is " &lt;&lt; std::quoted(str) &lt;&lt; '\n';

    std::cout &lt;&lt; "The contents of the vector are {" &lt;&lt; std::quoted(v[0])
              &lt;&lt; ", " &lt;&lt; std::quoted(v[1]) &lt;&lt; "}\n";
}
|p=true
|output=
After copy, str is "Salut"
After move, str is ""
The contents of the vector are {"Salut", "Salut"}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/dsc forward}}
{{dsc inc|cpp/utility/dsc move_if_noexcept}}
{{dsc inc|cpp/algorithm/dsc move}}
{{dsc end}}

{{langlinks|de|en|fr|it|ja|pt|ru|zh}}