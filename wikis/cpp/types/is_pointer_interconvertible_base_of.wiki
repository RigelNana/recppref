{{cpp/title|is_pointer_interconvertible_base_of}}
{{cpp/meta/navbar}}
{{ddcl|header=type_traits|since=c++20|1=
template&lt; class Base, class Derived &gt;
struct is_pointer_interconvertible_base_of;
}}

If {{tt|Derived}} is unambiguously derived from {{tt|Base}} and every {{tt|Derived}} object is [[cpp/language/static_cast#pointer-interconvertible|pointer-interconvertible]] with its {{tt|Base}} subobject, or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant {{tt|value}} equal to {{c|true}}. Otherwise {{tt|value}} is {{c|false}}.

If both {{tt|Base}} and {{tt|Derived}} are non-union class types, and they are not the same type (ignoring cv-qualification), {{tt|Derived}} shall be a [[cpp/language/incomplete type|complete type]]; otherwise the behavior is undefined.

{{cpp/types/nospec|pv}}

===Helper variable template===
{{ddcl|since=c++20|1=
template&lt; class Base, class Derived &gt;
inline constexpr bool is_pointer_interconvertible_base_of_v =
    is_pointer_interconvertible_base_of&lt;Base, Derived&gt;::value;
}}
{{cpp/types/integral_constant/inherit|{{tt|Derived}} is unambiguously derived from {{tt|Base}} and every {{tt|Derived}} object is [[cpp/language/static_cast#pointer-interconvertible|pointer-interconvertible]] with its {{tt|Base}} subobject, or if both are the same non-union class (in both cases ignoring cv-qualification)}}

===Notes===
{{c|std::is_pointer_interconvertible_base_of_v&lt;T, U&gt;}} may be {{c|true}} even if {{tt|T}} is a private or protected base class of {{tt|U}}.

Let
* {{tt|U}} be a complete object type,
* {{tt|T}} be a complete object type with cv-qualification not less than {{tt|U}},
* {{tt|u}} be any valid lvalue of {{tt|U}},
{{c|reinterpret_cast&lt;T&amp;&gt;(u)}} always has well-defined result if {{c|std::is_pointer_interconvertible_base_of_v&lt;T, U&gt;}} is {{c|true}}.

If {{tt|T}} and {{tt|U}} are not the same type (ignoring cv-qualification) and {{tt|T}} is a pointer-interconvertible base class of {{tt|U}}, then both {{c|std::is_standard_layout_v&lt;T&gt;}} and {{c|std::is_standard_layout_v&lt;U&gt;}} are {{c|true}}.

If {{tt|T}} is standard layout class type, then all base classes of {{tt|T}} (if any) are pointer-interconvertible base class of {{tt|T}}.

{{feature test macro|__cpp_lib_is_pointer_interconvertible|value=201907L|std=C++20|Pointer-interconvertibility traits:
* {{tt|std::is_pointer_interconvertible_base_of}},
* {{lc|std::is_pointer_interconvertible_with_class}}}}

===Example===
{{example
|code=
#include &lt;type_traits&gt;

struct Foo {};

struct Bar {};

class Baz : Foo, public Bar { int x; };

class NonStdLayout : public Baz { int y; };

static_assert(std::is_pointer_interconvertible_base_of_v&lt;Bar, Baz&gt;);
static_assert(std::is_pointer_interconvertible_base_of_v&lt;Foo, Baz&gt;);
static_assert(not std::is_pointer_interconvertible_base_of_v&lt;Baz, NonStdLayout&gt;);
static_assert(std::is_pointer_interconvertible_base_of_v&lt;NonStdLayout, NonStdLayout&gt;);

int main() {}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_base_of}}
{{dsc inc|cpp/types/dsc is_empty}}
{{dsc inc|cpp/types/dsc is_standard_layout}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}