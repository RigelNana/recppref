{{cpp/title|size_t}}
{{cpp/types/navbar}}
{{dcl begin}}
{{dcl header|cstddef}}
{{dcl header|cstdio}}
{{dcl header|cstdlib}}
{{dcl header|cstring}}
{{dcl header|ctime}}
{{dcl sep}}
{{dcl header|cuchar|notes={{mark since c++17}}}}
{{dcl sep}}
{{dcl header|cwchar}}
{{dcl|
typedef /* implementation-defined */ size_t;
}}
{{dcl end}}

{{tt|std::size_t}} is the unsigned integer type of the result of the following operators:
* {{ltt|cpp/language/sizeof}}
{{rrev|since=c++11|
* {{ltt|cpp/language/sizeof...}}
* {{ltt|cpp/language/alignof}}
}}

If a program attempts to form an oversized type (i.e., the number of bytes in its [[cpp/language/object#Object representation and value representation|object representation]] exceeds the maximum value representable in {{tt|std::size_t}}), the program is ill-formed.

{{rrev|since=c++11|
The bit width of {{tt|std::size_t}} is not less than 16.
}}

===Notes===
{{tt|std::size_t}} can store the maximum size of a theoretically possible object of any type (including array). On many platforms (an exception is systems with segmented addressing) {{tt|std::size_t}} can safely store the value of any non-member pointer, in which case it is synonymous with {{lc|std::uintptr_t}}.

{{tt|std::size_t}} is commonly used for array indexing and loop counting. Programs that use other types, such as {{c/core|unsigned int}}, for array indexing may fail on, e.g. 64-bit systems when the index exceeds {{lc|UINT_MAX}} or if it relies on 32-bit modular arithmetic.

When indexing C++ containers, such as {{lc|std::string}}, {{lc|std::vector}}, etc, the appropriate type is the nested type {{tt|size_type}} provided by such containers. It is usually defined as a synonym for {{tt|std::size_t}}.

It is unspecified whether the declaration of {{tt|std::size_t}} is available in any other standard library header. An implementation may avoid introducing this name even when the standard requires {{tt|std::size_t}} to be used.

{{rrev|since=c++23|
The [[cpp/language/integer literal|integer literal suffix]] for {{tt|std::size_t}} is any combination of {{tt|z}} or {{tt|Z}} with {{tt|u}} or {{tt|U}} (i.e. {{tt|zu}}, {{tt|zU}}, {{tt|Zu}}, {{tt|ZU}}, {{tt|uz}}, {{tt|uZ}}, {{tt|Uz}}, or {{tt|UZ}}).
}}

===Example===
{{example
|code=
#include &lt;array&gt;
#include &lt;cstddef&gt;
#include &lt;iostream&gt;

int main()
{
    std::array&lt;std::size_t, 10&gt; a;
    
    // Example with C++23 std::size_t literal
    for (auto i = 0uz; i != a.size(); ++i)
        std::cout &lt;&lt; (a[i] = i) &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
    
    // Example of decrementing loop
    for (std::size_t i = a.size(); i--;)
        std::cout &lt;&lt; a[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
    
    // Note the naive decrementing loop:
    //  for (std::size_t i = a.size() - 1; i &gt;= 0; --i) ...
    // is an infinite loop, because unsigned numbers are always non-negative
}
|output=
0 1 2 3 4 5 6 7 8 9
9 8 7 6 5 4 3 2 1 0
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=1122|std=C++98|before={{tt|std::size_t}} was circularly defined&lt;ref&gt;The definition of {{tt|std::size_t}} was exactly the same as the definition of {{tt|size_t}} in C, which is “the result type of {{ltt|cpp/language/sizeof}}”. There is no circular definition in C because the result type of {{tt|sizeof}} in C is an implementation-defined unsigned integer type.&lt;/ref&gt;|after=it is implementation-defined}}
{{dr list item|wg=cwg|dr=1464|std=C++98|before=object size might be not representable in {{tt|std::size_t}}|after=such type is ill-formed}}
{{dr list end}}
&lt;references/&gt;

===References===
{{ref std c++23}}
{{ref std|section=6.8.4|title=Compound types|id=basic.compound|p=79-80}}
{{ref std|section=7.6.2.5|title=Sizeof|id=expr.sizeof|p=136}}
{{ref std|section=7.6.2.6|title=Alignof|id=expr.alignof|p=136}}
{{ref std|section=17.2.4|title=Sizes, alignments, and offsets|id=support.types.layout|p=504-505}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=6.8.3|title=Compound types|id=basic.compound|p=75-76}}
{{ref std|section=7.6.2.5|title=Sizeof|id=expr.sizeof|p=129-130}}
{{ref std|section=7.6.2.6|title=Alignof|id=expr.alignof|p=130}}
{{ref std|section=17.2.4|title=Sizes, alignments, and offsets|id=support.types.layout|p=507-508}}
{{ref std end}}
{{ref std c++17}}
{{ref std|section=6.9.2|title=Compound types|id=basic.compound|p=81-82}}
{{ref std|section=8.3.3|title=Sizeof|id=expr.sizeof|p=121-122}}
{{ref std|section=8.3.6|title=Alignof|id=expr.alignof|p=129}}
{{ref std|section=21.2.4|title=Sizes, alignments, and offsets|id=support.types.layout|p=479}}
{{ref std end}}
{{ref std c++14}}
{{ref std|section=3.9.2|title=Compound types|id=basic.compound|p=73-74}}
{{ref std|section=5.3.3|title=Sizeof|id=expr.sizeof|p=109-110}}
{{ref std|section=5.3.6|title=Alignof|id=expr.alignof|p=116}}
{{ref std|section=18.2|title=Types|id=support.types|p=443-444}}
{{ref std end}}
{{ref std c++11}}
{{ref std|section=5.3.3|title=Sizeof|id=expr.sizeof|p=111}}
{{ref std|section=5.3.6|title=Alignof|id=expr.alignof|p=116}}
{{ref std|section=18.2|title=Types|id=support.types|p=454-455}}
{{ref std end}}
{{ref std c++03}}
{{ref std|section=5.3.3|title=Sizeof|id=expr.sizeof|p=79}}
{{ref std end}}
{{ref std c++98}}
{{ref std|section=5.3.3|title=Sizeof|id=expr.sizeof|p=77}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc ptrdiff_t}}
{{dsc inc|cpp/types/dsc offsetof}}
{{dsc inc|cpp/language/dsc integer literal}}
{{dsc see c|c/types/size_t}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}