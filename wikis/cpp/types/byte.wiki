{{cpp/title|byte}}
{{cpp/types/navbar}}
{{ddcl|header=cstddef|since=c++17|
enum class byte : unsigned char {};
}}

{{tt|std::byte}} is a distinct type that implements the concept of byte as specified in the C++ language definition.

Like {{c/core|unsigned char}}, it can be used to access raw memory occupied by other objects ([[cpp/language/object|object representation]]), but unlike {{c/core|unsigned char}}, it is not a character type and is not an arithmetic type. {{tt|std::byte}} models a mere collection of bits, supporting only bitshift operations with an integer, and bitwise and comparison operations with another {{tt|std::byte}}.

===Non-member functions===
{{member|{{small|std::}}to_integer|2=
{{dcl begin}}
{{dcl|since=c++17|
template&lt; class IntegerType &gt;
constexpr IntegerType to_integer( std::byte b ) noexcept;
}}
{{dcl end}}
Equivalent to: {{c|return IntegerType(b);}}
{{cpp/enable_if|{{c|std::is_integral_v&lt;IntegerType&gt;}} is {{c|true}}.}}
}}

{{member|1={{small|std::}}operator&lt;&lt;=,operator&gt;&gt;=|2=
{{dcl begin}}
{{dcl|since=c++17|num=1|1=
template&lt; class IntegerType &gt;
constexpr std::byte&amp; operator&lt;&lt;=( std::byte&amp; b, IntegerType shift ) noexcept;
}}
{{dcl|since=c++17|num=2|1=
template&lt; class IntegerType &gt;
constexpr std::byte&amp; operator&gt;&gt;=( std::byte&amp; b, IntegerType shift ) noexcept;
}}
{{dcl end}}
@1@Equivalent to: {{c|1=return b = b &lt;&lt; shift;}}
{{cpp/enable_if|{{c|std::is_integral_v&lt;IntegerType&gt;}} is {{c|true}}}}.
@2@Equivalent to: {{c|1=return b = b &gt;&gt; shift;}}
{{cpp/enable_if|{{c|std::is_integral_v&lt;IntegerType&gt;}} is {{c|true}}}}.
}}

{{member|{{small|std::}}operator&lt;&lt;,operator&gt;&gt;|2=
{{dcl begin}}
{{dcl|since=c++17|num=1|
template&lt; class IntegerType &gt;
constexpr std::byte operator&lt;&lt;( std::byte b, IntegerType shift ) noexcept;
}}
{{dcl|since=c++17|num=2|
template&lt; class IntegerType &gt;
constexpr std::byte operator&gt;&gt;( std::byte b, IntegerType shift ) noexcept;
}}
{{dcl end}}
@1@Equivalent to: {{c|return std::byte(static_cast&lt;unsigned int&gt;(b) &lt;&lt; shift);}}
{{cpp/enable_if|{{c|std::is_integral_v&lt;IntegerType&gt;}} is {{c|true}}}}.
@2@Equivalent to: {{c|return std::byte(static_cast&lt;unsigned int&gt;(b) &gt;&gt; shift);}}
{{cpp/enable_if|{{c|std::is_integral_v&lt;IntegerType&gt;}} is {{c|true}}}}.
}}

{{member|1={{small|std::}}operator{{!}}=,operator&amp;=,operator^=|2=
{{dcl begin}}
{{dcl|since=c++17|num=1|1=
constexpr std::byte&amp; operator{{!}}=( std::byte&amp; l, std::byte r ) noexcept;
}}
{{dcl|since=c++17|num=2|1=
constexpr std::byte&amp; operator&amp;=( std::byte&amp; l, std::byte r ) noexcept;
}}
{{dcl|since=c++17|num=3|1=
constexpr std::byte&amp; operator^=( std::byte&amp; l, std::byte r ) noexcept;
}}
{{dcl end}}
@1@Equivalent to: {{c|1=return l = l {{!}} r;}}.
@2@Equivalent to: {{c|1=return l = l &amp; r;}}.
@3@Equivalent to: {{c|1=return l = l ^ r;}}.
}}

{{member|{{small|std::}}operator{{!}},operator&amp;,operator^,operator~|2=
{{dcl begin}}
{{dcl|since=c++17|num=1|1=
constexpr std::byte operator{{!}}( std::byte l, std::byte r ) noexcept;
}}
{{dcl|since=c++17|num=2|
constexpr std::byte operator&amp;( std::byte l, std::byte r ) noexcept;
}}
{{dcl|since=c++17|num=3|
constexpr std::byte operator^( std::byte l, std::byte r ) noexcept;
}}
{{dcl|since=c++17|num=4|
constexpr std::byte operator~( std::byte b ) noexcept;
}}
{{dcl end}}
@1@Equivalent to: {{c|1=return std::byte(static_cast&lt;unsigned int&gt;(l) {{!}} static_cast&lt;unsigned int&gt;(r));}}.
@2@Equivalent to: {{c|1=return std::byte(static_cast&lt;unsigned int&gt;(l) &amp; static_cast&lt;unsigned int&gt;(r));}}.
@3@Equivalent to: {{c|1=return std::byte(static_cast&lt;unsigned int&gt;(l) ^ static_cast&lt;unsigned int&gt;(r));}}.
@4@Equivalent to: {{c|1=return std::byte(~static_cast&lt;unsigned int&gt;(b));}}
}}

===Notes===
A numeric value {{c|n}} can be converted to a byte value using {{c|1=std::byte{n}&lt;!--_--&gt;}}, due to C++17 [[cpp/language/enum#enum relaxed init cpp17|relaxed enum class initialization]] rules.

A byte can be converted to a numeric value (such as to produce an integer hash of an object) the usual way with an [[cpp/language/explicit_cast|explicit conversion]] or alternatively with &lt;!--{{lc|std::to_integer}}--&gt;[[#Non-member functions|{{tt|std::to_integer}}]].

{{feature test macro|__cpp_lib_byte|{{tt|std::byte}}|std=C++17|value=201603L}}

===Example===
{{example
|code=
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, std::byte b)
{
    return os &lt;&lt; std::bitset&lt;8&gt;(std::to_integer&lt;int&gt;(b));
}

int main()
{
    // std::byte y = 1; // Error: cannot convert int to byte.
    std::byte y{1}; // OK

    // if (y == 13) {} // Error: cannot be compared.
    if (y == std::byte{13}) {} // OK, bytes are comparable

    int arr[]{1, 2, 3};
    // int c = a[y]; // Error: array subscript is not an integer
    [[maybe_unused]] int i = arr[std::to_integer&lt;int&gt;(y)]; // OK
    [[maybe_unused]] int j = arr[std::to_underlying(y)];   // OK

    auto to_int = [](std::byte b) { return std::to_integer&lt;int&gt;(b); };

    std::byte b{42};
    assert(to_int(b) == 0b00101010);
    std::cout &lt;&lt; b &lt;&lt; '\n';

    // b *= 2; // Error: b is not of arithmetic type
    b &lt;&lt;= 1;
    assert(to_int(b) == 0b01010100);

    b &gt;&gt;= 1;
    assert(to_int(b) == 0b00101010);

    assert(to_int(b &lt;&lt; 1) == 0b01010100);
    assert(to_int(b &gt;&gt; 1) == 0b00010101);

    b {{!}}= std::byte{0b11110000};
    assert(to_int(b) == 0b11111010);

    b &amp;= std::byte{0b11110000};
    assert(to_int(b) == 0b11110000);

    b ^= std::byte{0b11111111};
    assert(to_int(b) == 0b00001111);
}
|output=
00101010
}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}