{{cpp/title|reference_converts_from_temporary}}
{{cpp/meta/navbar}}
{{ddcl|header=type_traits|since=c++23|
template&lt; class T, class U &gt;
struct reference_converts_from_temporary;
}}

Let {{tt|V}} be {{c|std::remove_cv_t&lt;U&gt;}} if {{tt|U}} is a scalar type or ''cv''{{sep}} {{c/core|void}}, or {{tt|U}} otherwise. If {{tt|T}} is a reference type, and given a hypothetical expression {{c|e}} such that {{c|decltype(e)}} is {{tt|V}}, the variable definition {{c|1=T ref = e;}} is well-formed and [[cpp/language/reference_initialization#Lifetime_of_a_temporary|binds a temporary object]] to {{tt|ref}}, then provides the member constant {{tt|value}} equal to {{c|true}}. Otherwise, {{tt|value}} is {{c|false}}.

&lt;!-- LWG 3697, but the proposed resolution still seems wrong. ---&gt;If {{tt|T}} is an lvalue reference type to a const- but not volatile-qualified object type or an rvalue reference type, both {{c|std::remove_reference_t&lt;T&gt;}} and {{c|std::remove_reference_t&lt;U&gt;}} shall be [[cpp/language/type#Incomplete type|complete types]], ''cv'' {{c/core|void}}, or an {{lsd|cpp/language/array#Arrays of unknown bound}}; otherwise the behavior is undefined.

If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined.

{{cpp/types/nospec|pv}}

===Helper variable template===
{{ddcl|since=c++23|1=
template&lt; class T, class U &gt;
inline constexpr bool reference_converts_from_temporary_v =
    std::reference_converts_from_temporary&lt;T, U&gt;::value;
}}

{{cpp/types/integral_constant/inherit|{{tt|T}} is a reference type, a {{tt|U}} value can be bound to {{tt|T}} in copy-initialization, and a temporary object would be bound to the reference}}

===Notes===
{{tt|std::reference_converts_from_temporary}} can be used for rejecting some cases that always produce dangling references.

===Example===
{{example
|code=
#include &lt;type_traits&gt;

int main() {}

static_assert(
    std::reference_converts_from_temporary_v&lt;int&amp;&amp;, int&gt; == true &amp;&amp;
    std::reference_converts_from_temporary_v&lt;const int&amp;, int&gt; == true &amp;&amp;
    std::reference_converts_from_temporary_v&lt;int&amp;&amp;, int&amp;&amp;&gt; == false &amp;&amp;
    std::reference_converts_from_temporary_v&lt;const int&amp;, int&amp;&amp;&gt; == false &amp;&amp;
    std::reference_converts_from_temporary_v&lt;int&amp;&amp;, long&amp;&amp;&gt; == true &amp;&amp;
    std::reference_converts_from_temporary_v&lt;int&amp;&amp;, long&gt; == true);
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_convertible}}
{{dsc inc|cpp/utility/functional/dsc invoke}}
{{dsc inc|cpp/utility/functional/dsc bind}}
{{dsc inc|cpp/utility/variant/dsc visit2}}
{{dsc inc|cpp/utility/functional/function/dsc constructor}}
{{dsc inc|cpp/utility/functional/move_only_function/dsc constructor}}
{{dsc inc|cpp/thread/packaged_task/dsc constructor}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}