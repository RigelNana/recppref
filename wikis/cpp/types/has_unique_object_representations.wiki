{{cpp/types/traits/is|1=has_unique_object_representations
|std=c++17
|description=If {{tt|T}} is {{named req|TriviallyCopyable}} and if any two objects of type {{tt|T}} with the same value have the same [[cpp/language/object#Object representation and value representation|object representation]], provides the member constant {{tt|value}} equal {{c|true}}. For any other type, {{tt|value}} is {{c|false}}.

For the purpose of this trait, two arrays have the same value if their elements have the same values, two non-union classes have the same value if their direct subobjects have the same value, and two unions have the same value if they have the same active member and the value of that member is the same.

It is implementation-defined which scalar types satisfy this trait, but {{rev inl|until=c++20|unsigned}} integer types that do not use padding bits are guaranteed to have unique object representations.

The behavior is undefined if {{tt|T}} is an incomplete type other than (possibly cv-qualified) {{c|void}} or array of unknown bound.
|inherit_desc={{tt|T}} has unique object representations
}}

===Notes===
This trait was introduced to make it possible to determine whether a type can be correctly hashed by hashing its object representation as a byte array.

{{feature test macro|__cpp_lib_has_unique_object_representations|value=201606L|std=C++17|{{tt|std::has_unique_object_representations}}}}

===Example===
{{example
|
|code=
#include &lt;cstdint&gt;
#include &lt;type_traits&gt;

struct unpadded
{
    std::uint32_t a, b;
};

struct likely_padded
{
    std::uint8_t c;
    std::uint16_t st;
    std::uint32_t i;
};

int main()
{
    // Every value of a char corresponds to exactly one object representation.
    static_assert(std::has_unique_object_representations_v&lt;char&gt;);
    // For IEC 559 floats, assertion passes because the value NaN has
    // multiple object representations.
    static_assert(!std::has_unique_object_representations_v&lt;float&gt;);

    // Should succeed in any sane implementation because unpadded
    // is typically not padded, and std::uint32_t cannot contain padding bits.
    static_assert(std::has_unique_object_representations_v&lt;unpadded&gt;);
    // Fails in most implementations because padding bits are inserted
    // between the data members c and st for the purpose of aligning st to 16 bits.
    static_assert(!std::has_unique_object_representations_v&lt;likely_padded&gt;);

    // Notable architectural divergence:
    static_assert(std::has_unique_object_representations_v&lt;bool&gt;);  // x86
 // static_assert(!std::has_unique_object_representations_v&lt;bool&gt;); // ARM
}
|p=true
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_standard_layout}}
{{dsc inc|cpp/utility/dsc hash}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}