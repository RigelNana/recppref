{{cpp/title|max_align_t}}
{{cpp/types/navbar}}

{{ddcl|header=cstddef|since=c++11|
typedef /* implementation-defined */ max_align_t;
}}

{{tt|std::max_align_t}} is a [[cpp/named req/StandardLayoutType|standard-layout]] {{rev inl|until=c++26|{{named req|TrivialType}}}}{{rev inl|since=c++26|{{named req|TriviallyCopyable}} type}} whose [[cpp/language/object#Alignment|alignment requirement]] is at least as strict (as large) as that of every scalar type.

{{c|std::is_trivially_default_constructible_v&lt;std::max_align_t&gt;}} is {{c|true}}.

===Notes===
Pointers returned by allocation functions such as {{lc|std::malloc}} are suitably aligned for any object, which means they are aligned at least as strictly as {{tt|std::max_align_t}}.

===Example===
{{example
|&lt;!-- todo: smarter example, perhaps use as aligned storage? --&gt;
|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; alignof(std::max_align_t) &lt;&lt; '\n';
}
|p=true
|output=
16
}}

===References===
{{ref std c++23}}
{{ref std|section=17.2.4|title=Sizes, alignments, and offsets|id=support.types.layout|p=504-505}}
{{ref std c++20}}
{{ref std|section=17.2.4|title=Sizes, alignments, and offsets|id=support.types.layout|p=507-508}}
{{ref std c++17}}
{{ref std|section=21.2.4|title=Sizes, alignments, and offsets|id=support.types.layout|p=479}}
{{ref std c++14}}
{{ref std|section=18.2|title=Types|id=support.types|p=443-444}}
{{ref std c++11}}
{{ref std|section=18.2|title=Types|id=support.types|p=454-455}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc alignof}}
{{dsc inc|cpp/types/dsc alignment_of}}
{{dsc inc|cpp/types/dsc is_scalar}}
{{dsc see c|c/types/max_align_t}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}