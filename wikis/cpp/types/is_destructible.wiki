{{cpp/title|is_destructible|is_trivially_destructible|is_nothrow_destructible}}
{{cpp/meta/navbar}}
{{dcl begin}}
{{dcl header|type_traits}}
{{dcla|since=c++11|num=1|1=
template&lt; class T &gt;
struct is_destructible;
}}
{{dcla|since=c++11|num=2|1=
template&lt; class T &gt;
struct is_trivially_destructible;
}}
{{dcla|since=c++11|num=3|1=
template&lt; class T &gt;
struct is_nothrow_destructible;
}}
{{dcl end}}

@1@ If {{tt|T}} is a reference type, provides the member constant {{c|value}} equal to {{c|true}}.

@@ If {{tt|T}} is (possibly cv-qualified) {{c/core|void}}, a function type, or an array of unknown bound, {{c|value}} equals {{c|false}}.

@@ If {{tt|T}} is an object type, then, for the type {{tt|U}} that is {{c|std::remove_all_extents&lt;T&gt;::type}}, if the expression {{c|std::declval&lt;U&amp;&gt;().~U()}} is well-formed in unevaluated context, {{c|value}} equals {{c|true}}. Otherwise, {{c|value}} equals {{c|false}}.

@2@ Same as {{v|1}} and additionally {{c|std::remove_all_extents&lt;T&gt;::type}} is either a non-class type or a class type with a [[cpp/language/destructor#Trivial destructor|trivial destructor]].

@3@ Same as {{v|1}}, but the destructor is {{c/core|noexcept}}.

{{cpp/types/cvaub}}

{{cpp/types/nospec|any}}

===Helper variable templates===
{{dcl begin}}

{{dcl|since=c++17|1=
template&lt; class T &gt;
constexpr bool is_destructible_v = is_destructible&lt;T&gt;::value;
}}

{{dcl|since=c++17|1=
template&lt; class T &gt;
constexpr bool is_trivially_destructible_v = is_trivially_destructible&lt;T&gt;::value;
}}

{{dcl|since=c++17|1=
template&lt; class T &gt;
constexpr bool is_nothrow_destructible_v = is_nothrow_destructible&lt;T&gt;::value;
}}
{{dcl end}}
{{cpp/types/integral_constant/inherit|{{tt|T}} is destructible}}

===Notes===
Because the C++ program terminates if a destructor throws an exception during stack unwinding (which usually cannot be predicted), all practical destructors are non-throwing even if they are not declared noexcept. All destructors found in the C++ standard library are non-throwing.

Storage occupied by [[cpp/language/destructor#Trivial destructor|trivially destructible]] objects [[cpp/language/lifetime#Storage reuse|may be reused]] without calling the destructor.

===Possible implementation===
{{eq impl
|title1=is_destructible (1)|ver1=1|1=
// C++20 required
template&lt;typename t&gt;
struct is_destructible
    : std::integral_constant&lt;bool, requires(t object) { object.~t(); }&gt;
{};
|title2=is_trivially_destructible (2)|ver2=2|2=
// Not real C++. Shall P2996 be approved, the following implementation will be available:
template&lt;typename t&gt;
struct is_trivially_destructible
     : std::integral_constant&lt;bool, std::meta::type_is_trivially_destructible(^t)&gt;
{};
|title3=is_nothrow_destructible (3)|ver3=3|3=
// C++20 required
template&lt;typename t&gt;
struct is_nothrow_destructible
    : std::integral_constant&lt;bool, requires(t object) { {object.~t()} noexcept; }&gt;
{};
}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;

struct Foo
{
    std::string str;
    ~Foo() noexcept {};
};

struct Bar
{
    ~Bar() = default;
};

static_assert(std::is_destructible&lt;std::string&gt;::value == true);
static_assert(std::is_trivially_destructible_v&lt;Foo&gt; == false);
static_assert(std::is_nothrow_destructible&lt;Foo&gt;() == true);
static_assert(std::is_trivially_destructible&lt;Bar&gt;{} == true);

int main() {}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2049|std=c++11|before=the specification was incompletable because of the imaginary wrapping struct|after=made complete
}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_constructible}}
{{dsc inc|cpp/types/dsc has_virtual_destructor}}
{{dsc inc|cpp/concepts/dsc destructible}}
{{dsc inc|cpp/language/dsc destructor}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}