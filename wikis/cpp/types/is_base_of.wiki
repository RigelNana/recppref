{{cpp/title|is_base_of}}
{{cpp/meta/navbar}}
{{ddcl|header=type_traits|since=c++11|1=
template&lt; class Base, class Derived &gt;
struct is_base_of;
}}

{{tt|std::is_base_of}} is a {{named req|BinaryTypeTrait}}.

If {{tt|Derived}} is [[cpp/language/derived class|derived]] from {{tt|Base}} or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant {{c|value}} equal to {{c|true}}. Otherwise {{c|value}} is {{c|false}}.

If both {{tt|Base}} and {{tt|Derived}} are non-union class types, and they are not the same type (ignoring cv-qualification), {{tt|Derived}} should be a [[cpp/language/incomplete type|complete type]]; otherwise the behavior is undefined.

{{cpp/types/nospec|v}}

===Helper variable template===
{{ddcl|since=c++17|1=
template&lt; class Base, class Derived &gt;
constexpr bool is_base_of_v = is_base_of&lt;Base, Derived&gt;::value;
}}
{{cpp/types/integral_constant/inherit|{{tt|Derived}} is derived from {{tt|Base}} or if both are the same non-union class (in both cases ignoring cv-qualification)}}

===Notes===
{{c|std::is_base_of&lt;A, B&gt;::value}} is {{c|true}} even if {{tt|A}} is a private, protected, or ambiguous base class of {{tt|B}}. In many situations, {{c|std::is_convertible&lt;B*, A*&gt;}} is the more appropriate test.

Although no class is its own base, {{c|std::is_base_of&lt;T, T&gt;::value}} is true because the intent of the trait is to model the "is-a" relationship, and {{tt|T}} is a {{tt|T}}. Despite that, {{c|std::is_base_of&lt;int, int&gt;::value}} is {{c|false}} because only classes participate in the relationship that this trait models.

===Possible Implementation===
{{eq fun|1=
namespace details
{
    template&lt;typename B&gt;
    std::true_type test_ptr_conv(const volatile B*);
    template&lt;typename&gt;
    std::false_type test_ptr_conv(const volatile void*);

    template&lt;typename B, typename D&gt;
    auto test_is_base_of(int) -&gt; decltype(test_ptr_conv&lt;B&gt;(static_cast&lt;D*&gt;(nullptr)));
    template&lt;typename, typename&gt;
    auto test_is_base_of(...) -&gt; std::true_type; // private or ambiguous base
}

template&lt;typename Base, typename Derived&gt;
struct is_base_of :
    std::integral_constant&lt;
        bool,
        std::is_class&lt;Base&gt;::value &amp;&amp;
        std::is_class&lt;Derived&gt;::value &amp;&amp;
        decltype(details::test_is_base_of&lt;Base, Derived&gt;(0))::value
    &gt; {};
}}

===Example===
{{example
|code=
#include &lt;type_traits&gt;

class A {};
class B : A {};
class C : B {};
class D {};
union E {};
using I = int;

static_assert
(
    std::is_base_of_v&lt;A, A&gt; == true &amp;&amp;
    std::is_base_of_v&lt;A, B&gt; == true &amp;&amp;
    std::is_base_of_v&lt;A, C&gt; == true &amp;&amp;
    std::is_base_of_v&lt;A, D&gt; != true &amp;&amp;
    std::is_base_of_v&lt;B, A&gt; != true &amp;&amp;
    std::is_base_of_v&lt;E, E&gt; != true &amp;&amp;
    std::is_base_of_v&lt;I, I&gt; != true
);
 
int main() {}
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2015|std=C++11|before=the behavior might be undefined if&lt;br&gt;{{tt|Derived}} is an incomplete union type|after=the base characteristic is&lt;br&gt;{{lc|std::false_type}} in this case}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_virtual_base_of}}
{{dsc inc|cpp/types/dsc is_convertible}}
{{dsc inc|cpp/concepts/dsc derived_from}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}