{{cpp/title|is_pointer_interconvertible_with_class}}
{{cpp/meta/navbar}}
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++20|
template&lt; class S, class M &gt;
constexpr bool is_pointer_interconvertible_with_class( M S::* mp ) noexcept;
}}
{{dcl end}}

Given an object {{tt|s}} of type {{tt|S}}, determines whether {{c|s.*mp}} refers to a subobject of {{tt|s}} and {{tt|s}} is [[cpp/language/static_cast#pointer-interconvertible|pointer-interconvertible]] with its subobject {{c|s.*mp}}. The program is ill-formed if {{tt|S}} is not a [[cpp/language/type#Incomplete type|complete type]].

If {{tt|S}} is not a {{named req|StandardLayoutType}}, or {{tt|M}} is not an object type, or {{tt|mp}} is equal to {{c|nullptr}}, the result is always {{c|false}}.

===Parameters===
{{par begin}}
{{par|mp|a pointer-to-member to detect}}
{{par end}}

===Return value===
{{c|true}} if {{c|s.*mp}} refers a subobject of {{tt|s}} and {{tt|s}} is pointer-interconvertible with its subobject {{c|s.*mp}}, otherwise {{c|false}}, where {{tt|s}} is an object of type {{tt|S}}.

===Notes===
The type of a pointer-to-member expression {{c|&amp;S::m}} is not always {{c|M S::*}}, where {{tt|m}} is of type {{tt|M}}, because {{tt|m}} may be a member inherited from a base class of {{tt|S}}. The template arguments can be specified in order to avoid potentially surprising results.

If there is a value {{tt|mp}} of type {{c|M S::*}} such that {{c|1=std::is_pointer_interconvertible_with_class(mp) == true}}, then {{c|reinterpret_cast&lt;M&amp;&gt;(s)}} has well-defined result and it refers the same subobject as {{c|s.*mp}}, where {{tt|s}} is a valid lvalue of type {{tt|S}}.

On common platforms, the bit pattern of {{tt|mp}} is all zero if {{c|1=std::is_pointer_interconvertible_with_class(mp) == true}}.

{{feature test macro|__cpp_lib_is_pointer_interconvertible|value=201907L|std=C++20|Pointer-interconvertibility traits:
* {{lc|std::is_pointer_interconvertible_base_of}},
* {{tt|std::is_pointer_interconvertible_with_class}}}}

===Example===
{{example
|code=
#include &lt;type_traits&gt;

struct Foo { int x; };
struct Bar { int y; };

struct Baz : Foo, Bar {}; // not standard-layout

static_assert( not std::is_same_v&lt;decltype(&amp;Baz::x), int Baz::*&gt; );
static_assert( std::is_pointer_interconvertible_with_class(&amp;Baz::x) );
static_assert( not std::is_pointer_interconvertible_with_class&lt;Baz, int&gt;(&amp;Baz::x) );

int main() { }
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_standard_layout}}
{{dsc inc|cpp/types/dsc is_member_object_pointer}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}