{{cpp/title|is_within_lifetime}}
{{cpp/utility/navbar}}
{{ddcl|header=type_traits|since=c++26|
template&lt; class T &gt;
consteval bool is_within_lifetime( const T* ptr ) noexcept;
}}

Determines whether the pointer {{c|ptr}} points to an object that is within its {{lt|cpp/language/lifetime}}.

During the evaluation of an expression {{c|E}} as a core constant expression, a call to {{tt|std::is_within_lifetime}} is ill-formed unless {{c|ptr}} points to an object
* that is {{lsd|cpp/language/constant expression#Usable in constant expressions}}, or
* whose complete objectâ€™s lifetime began within {{c|E}}.

===Parameters===
{{par begin}}
{{par|p|pointer to detect}}
{{par end}}
 
===Return value===
{{c|true}} if pointer {{c|ptr}} points to an object that is within its lifetime; otherwise {{c|false}}.

===Notes===
{{feature test macro|__cpp_lib_is_within_lifetime|std=C++26|value=202306L|Checking if a union alternative is active}}

===Example===
{{example|{{tt|std::is_within_lifetime}} can be used to check whether a union member is active:
|code=
#include &lt;type_traits&gt;

// an optional boolean type occupying only one byte,
// assuming sizeof(bool) == sizeof(char)
struct optional_bool
{
    union { bool b; char c; };
    
    // assuming the value representations for true and false
    // are distinct from the value representation for 2
    constexpr optional_bool() : c(2) {}
    constexpr optional_bool(bool b) : b(b) {}
    
    constexpr auto has_value() const -&gt; bool
    {
        if consteval
        {
            return std::is_within_lifetime(&amp;b); // during constant evaluation,
                                                // cannot read from c
        }
        else
        {
            return c != 2; // during runtime, must read from c
        }
    }
    
    constexpr auto operator*() -&gt; bool&amp;
    {
        return b;
    }
};

int main()
{
    constexpr optional_bool disengaged;
    constexpr optional_bool engaged(true);
    
    static_assert(!disengaged.has_value());
    static_assert(engaged.has_value());
    static_assert(*engaged);
}
}}

{{langlinks|ar|ru|zh}}