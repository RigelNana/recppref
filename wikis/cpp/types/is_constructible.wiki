{{cpp/title|is_constructible|is_trivially_constructible|is_nothrow_constructible}}
{{cpp/meta/navbar}}
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++11|num=1|1=
template&lt; class T, class... Args &gt;
struct is_constructible;
}}
{{dcl|since=c++11|num=2|1=
template&lt; class T, class... Args &gt;
struct is_trivially_constructible;
}}
{{dcl|since=c++11|num=3|1=
template&lt; class T, class... Args &gt;
struct is_nothrow_constructible;
}}
{{dcl end}}

@1@ If {{tt|T}} is an object or reference type and the variable definition {{c|T obj(std::declval&lt;Args&gt;()...);}} is well-formed, provides the member constant {{tt|value}} equal to {{c|true}}. In all other cases, {{tt|value}} is {{c|false}}.&lt;br&gt;
For the purposes of this check, the variable definition is never interpreted as a function declaration, and the use of {{lc|std::declval}} is not considered an [[cpp/language/definition#ODR-use|odr-use]]. [[cpp/language/access|Access checks]] are performed as if from a context unrelated to {{tt|T}} and any of the types in {{tt|Args}}. Only the validity of the immediate context of the variable definition is considered.

@2@ Same as {{v|1}}, but the variable definition does not call any operation that is not trivial. For the purposes of this check, the call to {{lc|std::declval}} is considered trivial.

@3@ Same as {{v|1}}, but the variable definition is {{tt|noexcept}}.

{{cpp/types/cvaub|pack=Args}}

{{cpp/types/nospec|any}}

===Helper variable templates===
{{dcl begin}}

{{dcl|since=c++17|1=
template&lt; class T, class... Args &gt;
inline constexpr bool is_constructible_v =
    is_constructible&lt;T, Args...&gt;::value;
}}

{{dcl|since=c++17|1=
template&lt; class T, class... Args &gt;
inline constexpr bool is_trivially_constructible_v =
    is_trivially_constructible&lt;T, Args...&gt;::value;
}}

{{dcl|since=c++17|1=
template&lt; class T, class... Args &gt;
inline constexpr bool is_nothrow_constructible_v =
    is_nothrow_constructible&lt;T, Args...&gt;::value;
}}
{{dcl end}}

{{cpp/types/integral_constant/inherit|{{tt|T}} is constructible from {{tt|Args...}}}}

===Notes===
In many implementations, {{tt|is_nothrow_constructible}} also checks if the destructor throws because it is effectively {{c|noexcept(T(arg))}}. Same applies to {{tt|is_trivially_constructible}}, which, in these implementations, also requires that the destructor is trivial: [https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452 GCC bug 51452] {{lwg|2116}}.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;type_traits&gt;

class Foo
{
    int v1;
    double v2;
public:
    Foo(int n) : v1(n), v2() {}
    Foo(int n, double f) noexcept : v1(n), v2(f) {}
};

int main()
{
    auto is = [](bool o) { return (o ? "\t" "is " : "\t" "isn't "); };
    std::cout &lt;&lt; "Foo ...\n"
              &lt;&lt; is(std::is_trivially_constructible_v&lt;Foo, const Foo&amp;&gt;)
              &lt;&lt; "Trivially-constructible from const Foo&amp;\n"
              &lt;&lt; is(std::is_trivially_constructible_v&lt;Foo, int&gt;)
              &lt;&lt; "Trivially-constructible from int\n"
              &lt;&lt; is(std::is_constructible_v&lt;Foo, int&gt;)
              &lt;&lt; "Constructible from int\n"
              &lt;&lt; is(std::is_nothrow_constructible_v&lt;Foo, int&gt;)
              &lt;&lt; "Nothrow-constructible from int\n"
              &lt;&lt; is(std::is_nothrow_constructible_v&lt;Foo, int, double&gt;)
              &lt;&lt; "Nothrow-constructible from int and double\n";
}
|output=
Foo ...
        is Trivially-constructible from const Foo&amp;
        isn't Trivially-constructible from int
        is Constructible from int
        isn't Nothrow-constructible from int
        is Nothrow-constructible from int and double
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_default_constructible}}
{{dsc inc|cpp/types/dsc is_copy_constructible}}
{{dsc inc|cpp/types/dsc is_move_constructible}}
{{dsc inc|cpp/concepts/dsc constructible_from}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}