{{cpp/title|reference_constructs_from_temporary}}
{{cpp/meta/navbar}}
{{ddcl|header=type_traits|since=c++23|
template&lt; class T, class U &gt;
struct reference_constructs_from_temporary;
}}

Let {{tt|V}} be {{c|std::remove_cv_t&lt;U&gt;}} if {{tt|U}} is a scalar type or ''cv'' {{tt|void}}, or {{tt|U}} otherwise. If {{tt|T}} is a reference type, and given a hypothetic expression {{c|e}} such that {{c|decltype(e)}} is {{tt|V}}, the variable definition {{c|T ref(e);}} is well-formed and [[cpp/language/reference_initialization#Lifetime_of_a_temporary|binds a temporary object]] to {{tt|ref}}, then provides the member constant {{tt|value}} equal to {{c|true}}. Otherwise, {{tt|value}} is {{c|false}}.

&lt;!-- LWG 3697, but the proposed resolution still seems wrong. ---&gt;If {{tt|T}} is an lvalue reference type to a const- but not volatile-qualified object type or an rvalue reference type, both {{c|std::remove_reference_t&lt;T&gt;}} and {{c|std::remove_reference_t&lt;U&gt;}} shall be [[cpp/language/type#Incomplete_type|complete types]], ''cv'' {{c|void}}, or an {{lsd|cpp/language/array#Arrays of unknown bound}}; otherwise the behavior is undefined.

If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined.

{{cpp/types/nospec|pv}}

===Helper variable template===
{{ddcl|since=c++23|1=
template&lt; class T, class U &gt;
inline constexpr bool reference_constructs_from_temporary_v =
    std::reference_constructs_from_temporary&lt;T, U&gt;::value;
}}

{{cpp/types/integral_constant/inherit |{{tt|T}} is a reference type, a {{tt|U}} value can be bound to {{tt|T}} in direct-initialization, and a temporary object would be bound to the reference}}

===Notes===
{{tt|std::reference_constructs_from_temporary}} can be used for rejecting some cases that always produce dangling references.

It is also possible to use member initializer list to reject binding a temporary object to a reference if the compiler has implemented {{wg21|CWG1696}}.

===Example===
{{example
|code=
#include &lt;type_traits&gt;

static_assert(std::reference_constructs_from_temporary_v&lt;int&amp;&amp;, int&gt; == true);
static_assert(std::reference_constructs_from_temporary_v&lt;const int&amp;, int&gt; == true);
static_assert(std::reference_constructs_from_temporary_v&lt;int&amp;&amp;, int&amp;&amp;&gt; == false);
static_assert(std::reference_constructs_from_temporary_v&lt;const int&amp;, int&amp;&amp;&gt; == false);
static_assert(std::reference_constructs_from_temporary_v&lt;int&amp;&amp;, long&amp;&amp;&gt; == true);
static_assert(std::reference_constructs_from_temporary_v&lt;int&amp;&amp;, long&gt; == true);

int main() {}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_constructible}}
{{dsc inc|cpp/utility/tuple/dsc constructor}}
{{dsc inc|cpp/utility/pair/dsc constructor}}
{{dsc inc|cpp/utility/dsc make_from_tuple}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}