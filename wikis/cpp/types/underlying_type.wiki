{{cpp/title|underlying_type}}
{{cpp/meta/navbar}}
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++11|1=
template&lt; class T &gt;
struct underlying_type;
}}
{{dcl end}}

If {{tt|T}} is a complete enumeration (enum) type, provides a member typedef {{tt|type}} that names the underlying type of {{tt|T}}.

{{rrev multi|until1=c++20|rev1=
Otherwise, the behavior is undefined.
|rev2=
Otherwise, if {{tt|T}} is not an enumeration type, there is no member {{tt|type}}. Otherwise ({{tt|T}} is an incomplete enumeration type), the program is ill-formed.
}}

{{cpp/types/nospec}}

===Member types===
{{dsc begin}}
{{dsc hitem|Name|Definition}}
{{dsc|{{tt|type}}|the underlying type of {{tt|T}}}}
{{dsc end}}

===Helper types===
{{dcl begin}}
{{dcl|since=c++14|1=
template&lt; class T &gt;
using underlying_type_t = typename underlying_type&lt;T&gt;::type;
}}
{{dcl end}}

===Notes===
Each [[cpp/language/enum|enumeration type]] has an ''underlying type'', which can be

# Specified explicitly (both scoped and unscoped enumerations);
# Omitted, in which case it is {{c|int}} for scoped enumerations or an implementation-defined integral type capable of representing all values of the enum (for unscoped enumerations).

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;type_traits&gt;

enum e1 {};
enum class e2 {};
enum class e3 : unsigned {};
enum class e4 : int {};

int main()
{
    constexpr bool e1_t = std::is_same_v&lt;std::underlying_type_t&lt;e1&gt;, int&gt;;
    constexpr bool e2_t = std::is_same_v&lt;std::underlying_type_t&lt;e2&gt;, int&gt;;
    constexpr bool e3_t = std::is_same_v&lt;std::underlying_type_t&lt;e3&gt;, int&gt;;
    constexpr bool e4_t = std::is_same_v&lt;std::underlying_type_t&lt;e4&gt;, int&gt;;

    std::cout
        &lt;&lt; "underlying type for 'e1' is " &lt;&lt; (e1_t ? "int" : "non-int") &lt;&lt; '\n'
        &lt;&lt; "underlying type for 'e2' is " &lt;&lt; (e2_t ? "int" : "non-int") &lt;&lt; '\n'
        &lt;&lt; "underlying type for 'e3' is " &lt;&lt; (e3_t ? "int" : "non-int") &lt;&lt; '\n'
        &lt;&lt; "underlying type for 'e4' is " &lt;&lt; (e4_t ? "int" : "non-int") &lt;&lt; '\n';
}
|p=true &lt;!-- for unscoped enumerations: an implementation-defined integral type --&gt;
|output=
underlying type for 'e1' is non-int
underlying type for 'e2' is int
underlying type for 'e3' is non-int
underlying type for 'e4' is int
}}

=== Defect reports ===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2396|std=C++11|before=incomplete enumeration types were allowed|after=complete enumeration type required}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_enum}}
{{dsc inc|cpp/types/dsc is_scoped_enum}}
{{dsc inc|cpp/utility/dsc to_underlying}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}