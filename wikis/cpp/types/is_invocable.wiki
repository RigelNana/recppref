{{cpp/title|is_invocable|is_invocable_r|is_nothrow_invocable|is_nothrow_invocable_r}}
{{cpp/meta/navbar}}
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++17|num=1|1=
template&lt; class Fn, class... ArgTypes &gt;
struct is_invocable;
}}
{{dcl|since=c++17|num=2|1=
template&lt; class R, class Fn, class... ArgTypes &gt;
struct is_invocable_r;
}}
{{dcl|since=c++17|num=3|1=
template&lt; class Fn, class... ArgTypes &gt;
struct is_nothrow_invocable;
}}
{{dcl|since=c++17|num=4|1=
template&lt; class R, class Fn, class... ArgTypes &gt;
struct is_nothrow_invocable_r;
}}
{{dcl end}}

@1@ Determines whether {{box|{{lti|cpp/utility/functional|INVOKE}}{{c/core|(std::declval&lt;Fn&gt;(), std::declval&lt;ArgTypes&gt;()...)}}}} is well formed when treated as an unevaluated operand.
@2@ Determines whether {{box|{{lti|cpp/utility/functional|INVOKE&lt;R&gt;}}{{c/core|(std::declval&lt;Fn&gt;(), std::declval&lt;ArgTypes&gt;()...)}}}} is well formed when treated as an unevaluated operand.
@3@ Determines whether {{box|{{lti|cpp/utility/functional|INVOKE}}{{c/core|(std::declval&lt;Fn&gt;(), std::declval&lt;ArgTypes&gt;()...)}}}} is well formed when treated as an unevaluated operand, and is known not to throw any exceptions.
@4@ Determines whether {{box|{{lti|cpp/utility/functional|INVOKE&lt;R&gt;}}{{c/core|(std::declval&lt;Fn&gt;(), std::declval&lt;ArgTypes&gt;()...)}}}} is well formed when treated as an unevaluated operand, and is known not to throw any exceptions.

{{cpp/types/cvaub|type1=Fn, R|pack=ArgTypes}}

{{cpp/types/nospec|any}}

===Helper variable templates===
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++17|num=1|1=
template&lt; class Fn, class... ArgTypes &gt;
inline constexpr bool is_invocable_v =
    std::is_invocable&lt;Fn, ArgTypes...&gt;::value;
}}
{{dcl|since=c++17|num=2|1=
template&lt; class R, class Fn, class... ArgTypes &gt;
inline constexpr bool is_invocable_r_v =
    std::is_invocable_r&lt;R, Fn, ArgTypes...&gt;::value;
}}
{{dcl|since=c++17|num=3|1=
template&lt; class Fn, class... ArgTypes &gt;
inline constexpr bool is_nothrow_invocable_v =
    std::is_nothrow_invocable&lt;Fn, ArgTypes...&gt;::value;
}}
{{dcl|since=c++17|num=4|1=
template&lt; class R, class Fn, class... ArgTypes &gt;
inline constexpr bool is_nothrow_invocable_r_v =
    std::is_nothrow_invocable_r&lt;R, Fn, ArgTypes...&gt;::value;
}}
{{dcl end}}

{{cpp/types/integral_constant/inherit|(for overload {{v|1}}) {{box|{{lti|cpp/utility/functional|INVOKE}}{{c/core|(std::declval&lt;Fn&gt;(), std::declval&lt;ArgTypes&gt;()...)}}}} is well formed when treated as an unevaluated operand}}

===Notes===
{{ftm begin|std=1|comment=1}}
{{ftm|std=C++17|value=201703L|__cpp_lib_is_invocable|{{tt|std::is_invocable}}, {{lc|std::invoke_result}}}}
{{ftm end}}

===Examples===
{{example
|code=
#include &lt;type_traits&gt;

auto func2(char) -&gt; int (*)()
{
    return nullptr;
}

int main()
{
    static_assert(std::is_invocable_v&lt;int()&gt;);
    static_assert(not std::is_invocable_v&lt;int(), int&gt;);
    static_assert(std::is_invocable_r_v&lt;int, int()&gt;);
    static_assert(not std::is_invocable_r_v&lt;int*, int()&gt;);
    static_assert(std::is_invocable_r_v&lt;void, void(int), int&gt;);
    static_assert(not std::is_invocable_r_v&lt;void, void(int), void&gt;);
    static_assert(std::is_invocable_r_v&lt;int(*)(), decltype(func2), char&gt;);
    static_assert(not std::is_invocable_r_v&lt;int(*)(), decltype(func2), void&gt;);
}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/utility/functional/dsc invoke}}
{{dsc inc|cpp/types/dsc result_of}}
{{dsc inc|cpp/utility/dsc declval}}
{{dsc inc|cpp/concepts/dsc invocable}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}