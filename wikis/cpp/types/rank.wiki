{{cpp/title|rank}}
{{cpp/meta/navbar}}
{{ddcl|header=type_traits|since=c++11|
template&lt; class T &gt;
struct rank;
}}

If {{tt|T}} is an array type, provides the member constant {{c|value}} equal to the number of dimensions of the array. For any other type, {{c|value}} is {{c|0}}.

{{cpp/types/nospec|v}}

===Helper variable template===
{{ddcl|since=c++17|1=
template&lt; class T &gt;
constexpr std::size_t rank_v = rank&lt;T&gt;::value;
}}

{{cpp/types/integral_constant/inherit2|the number of dimensions of {{tt|T}} or zero|std::size_t}}

===Possible implementation===
{{eq fun
|1=
template&lt;class T&gt;
struct rank : public std::integral_constant&lt;std::size_t, 0&gt; {};

template&lt;class T&gt;
struct rank&lt;T[]&gt; : public std::integral_constant&lt;std::size_t, rank&lt;T&gt;::value + 1&gt; {};

template&lt;class T, std::size_t N&gt;
struct rank&lt;T[N]&gt; : public std::integral_constant&lt;std::size_t, rank&lt;T&gt;::value + 1&gt; {};
}}

===Example===
{{example
|code=
#include &lt;type_traits&gt;

static_assert(std::rank&lt;int&gt;{} == 0);
static_assert(std::rank&lt;int[5]&gt;{} == 1);
static_assert(std::rank&lt;int[5][5]&gt;{} == 2);
static_assert(std::rank&lt;int[][5][5]&gt;{} == 3);

int main()
{
    [[maybe_unused]] int ary[][3] = {&lt;!----&gt;{1, 2, 3}&lt;!----&gt;};

    // The rank of reference type, e.g., ary[0], that is int(&amp;)[3], is 0:
    static_assert(std::rank_v&lt;decltype(ary[0])&gt; == 0);
    static_assert(std::is_same_v&lt;decltype(ary[0]), int(&amp;)[3]&gt;);

    // The solution is to remove the reference type.
    static_assert(std::rank_v&lt;std::remove_cvref_t&lt;decltype(ary[0])&gt;&gt; == 1);
}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_array}}
{{dsc inc|cpp/types/dsc extent}}
{{dsc inc|cpp/types/dsc remove_extent}}
{{dsc inc|cpp/types/dsc remove_all_extents}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}