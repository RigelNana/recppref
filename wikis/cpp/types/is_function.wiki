{{cpp/types/traits/is|1=is_function
|description= 
Checks whether {{tt|T}} is a function type. Types like {{c|std::function}}, lambdas, classes with overloaded {{tt|operator()}} and pointers to functions don't count as function types. Provides the member constant {{tt|value}} which is equal to {{c|true}}, if {{tt|T}} is a function type. Otherwise, {{tt|value}} is equal to {{c|false}}.
|inherit_desc={{tt|T}} is a function type
}}

===Notes===
{{tt|std::is_function}} can be implemented in much simpler ways. Implementations similar to the following one are used by new versions of [https://github.com/llvm-mirror/libcxx/blob/master/include/type_traits#L889 libc++], [https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/type_traits#L538 libstdc++] and [https://github.com/microsoft/STL/pull/460 MS STL]:
{{source|
template&lt;class T&gt;
struct is_function : std::integral_constant&lt;
    bool,
    !std::is_const&lt;const T&gt;::value &amp;&amp; !std::is_reference&lt;T&gt;::value
&gt; {};
}}

The implementation shown below is for pedagogical purposes, since it exhibits the myriad kinds of function types.

===Possible implementation===
{{eq fun
|1=
// primary template
template&lt;class&gt;
struct is_function : std::false_type {};

// specialization for regular functions
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...)&gt; : std::true_type {};

// specialization for variadic functions such as std::printf
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......)&gt; : std::true_type {};

// specialization for function types that have cv-qualifiers
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) volatile&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const volatile&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) volatile&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const volatile&gt; : std::true_type {};

// specialization for function types that have ref-qualifiers
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) volatile &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const volatile &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) volatile &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const volatile &amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) &amp;&amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const &amp;&amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) volatile &amp;&amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const volatile &amp;&amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) &amp;&amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const &amp;&amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) volatile &amp;&amp;&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const volatile &amp;&amp;&gt; : std::true_type {};

// specializations for noexcept versions of all the above (C++17 and later)
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) volatile noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const volatile noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) volatile noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const volatile noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) volatile &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const volatile &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) volatile &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const volatile &amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) &amp;&amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const &amp;&amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) volatile &amp;&amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args...) const volatile &amp;&amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) &amp;&amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const &amp;&amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) volatile &amp;&amp; noexcept&gt; : std::true_type {};
template&lt;class Ret, class... Args&gt;
struct is_function&lt;Ret(Args......) const volatile &amp;&amp; noexcept&gt; : std::true_type {};
}}

===Example===
{{example
|code=
#include &lt;functional&gt;
#include &lt;type_traits&gt;

int f();
static_assert(std::is_function_v&lt;decltype(f)&gt;);

static_assert(std::is_function_v&lt;int(int)&gt;);
static_assert(!std::is_function_v&lt;int&gt;);
static_assert(!std::is_function_v&lt;decltype([]{})&gt;);
static_assert(!std::is_function_v&lt;std::function&lt;void()&gt;&gt;);

struct O { void operator()() {} };
static_assert(std::is_function_v&lt;O()&gt;);

struct A
{
    static int foo();
    int fun() const&amp;;
};
static_assert(!std::is_function_v&lt;A&gt;);
static_assert(std::is_function_v&lt;decltype(A::foo)&gt;);
static_assert(!std::is_function_v&lt;decltype(&amp;A::fun)&gt;);

template&lt;typename&gt;
struct PM_traits {};
template&lt;class T, class U&gt;
struct PM_traits&lt;U T::*&gt; { using member_type = U; };

int main()
{
    using T = PM_traits&lt;decltype(&amp;A::fun)&gt;::member_type; // T is int() const&amp;
    static_assert(std::is_function_v&lt;T&gt;);
}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_invocable}}
{{dsc inc|cpp/types/dsc is_object}}
{{dsc inc|cpp/types/dsc is_class}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}