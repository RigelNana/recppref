{{cpp/title|is_swappable_with|is_swappable|is_nothrow_swappable_with|is_nothrow_swappable}}
{{cpp/meta/navbar}}
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++17|num=1|1=
template&lt; class T, class U &gt;
struct is_swappable_with;
}}
{{dcl|since=c++17|num=2|1=
template&lt; class T &gt;
struct is_swappable;
}}
{{dcl|since=c++17|num=3|1=
template&lt; class T, class U &gt;
struct is_nothrow_swappable_with;
}}
{{dcl|since=c++17|num=4|1=
template&lt; class T &gt;
struct is_nothrow_swappable;
}}
{{dcl end}}

@1@ If the expressions {{c|swap(std::declval&lt;T&gt;(), std::declval&lt;U&gt;())}} and
{{c|swap(std::declval&lt;U&gt;(), std::declval&lt;T&gt;())}} are both well-formed in unevaluated context after {{c|using std::swap;}} (see {{named req|Swappable}}), provides the member constant {{tt|value}} equal {{c|true}}. Otherwise, {{tt|value}} is {{c|false}}.
@@ [[cpp/language/access|Access checks]] are performed as if from a context unrelated to either type. 

@3@ Same as {{v|1}}, but evaluations of both expressions from {{v|1}} are known not to throw exceptions.

{|class="wikitable" style="text-align: center;"
!rowspan=2|{{nbsp}}Type trait{{nbsp}}
!colspan=2|The value of the member constant {{tt|value}}
|-
!{{tt|T}} is a [[cpp/meta#Definitions|referenceable type]]
!{{nbsp}}{{tt|T}} is not a referenceable type{{nbsp}}
|-
|{{v|2}}
|style="text-align: left;"|{{c|std::is_swappable_with&lt;T&amp;, T&amp;&gt;::value}}
|rowspan=2|{{c|false}}
|-
|{{v|4}}
|{{c|std::is_nothrow_swappable_with&lt;T&amp;, T&amp;&gt;::value}}
|}

{{cpp/types/cvaub|type2=U}}

{{cpp/types/nospec|any}}

===Helper variable templates===
{{dcl begin}}
{{dcl|since=c++17|1=
template&lt; class T, class U &gt; 
inline constexpr bool is_swappable_with_v = is_swappable_with&lt;T, U&gt;::value;
}}
{{dcl|since=c++17|1=
template&lt; class T &gt; 
inline constexpr bool is_swappable_v = is_swappable&lt;T&gt;::value;
}}
{{dcl|since=c++17|1=
template&lt; class T, class U &gt;
inline constexpr bool is_nothrow_swappable_with_v =
    is_nothrow_swappable_with&lt;T, U&gt;::value;
}}
{{dcl|since=c++17|1=
template&lt; class T &gt;
inline constexpr bool is_nothrow_swappable_v =
    is_nothrow_swappable&lt;T&gt;::value;
}}
{{dcl end}}

{{cpp/types/integral_constant/inherit|{{tt|T}} is swappable with {{tt|U}}}}

===Notes===
This trait does not check anything outside the immediate context of the swap expressions: if the use of {{tt|T}} or {{tt|U}} would trigger template specializations, generation of implicitly-defined special member functions etc, and those have errors, the actual swap may not compile even if {{c|std::is_swappable_with&lt;T, U&gt;::value}} compiles and evaluates to {{c|true}}.

===Example===
{{example}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/algorithm/dsc swap}}
{{dsc inc|cpp/types/dsc is_move_assignable}}
{{dsc inc|cpp/concepts/dsc swappable}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}