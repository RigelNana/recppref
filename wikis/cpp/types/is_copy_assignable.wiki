{{cpp/title|is_copy_assignable|is_trivially_copy_assignable|is_nothrow_copy_assignable}}
{{cpp/meta/navbar}}
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++11|num=1|
template&lt; class T &gt;
struct is_copy_assignable;
}}
{{dcl|since=c++11|num=2|
template&lt; class T &gt;
struct is_trivially_copy_assignable;
}}
{{dcl|since=c++11|num=3|
template&lt; class T &gt;
struct is_nothrow_copy_assignable;
}}
{{dcl end}}

{|class="wikitable" style="text-align: center;"
!rowspan=2|{{nbsp}}Type trait{{nbsp}}
!colspan=2|The value of the member constant {{ttn|value}}
|-
!{{ttn|T}} is a [[cpp/meta#Definitions|referenceable type]]
!{{nbsp}}{{ttn|T}} is not a referenceable type{{nbsp}}
|-
|{{v|1}}
|{{c|std::is_assignable&lt;T&amp;, const T&amp;&gt;::value}}
|rowspan=3|{{c|false}}
|-
|{{v|2}}
|{{c|std::is_trivially_assignable&lt;T&amp;, const T&amp;&gt;::value}}
|-
|{{v|3}}
|{{c|std::is_nothrow_assignable&lt;T&amp;, const T&amp;&gt;::value}}
|}

{{cpp/types/cvaub}}

{{cpp/types/nospec|any}}

===Helper variable templates===
{{dcl begin}}
{{dcl|since=c++17|1=
template&lt; class T &gt;
inline constexpr bool is_copy_assignable_v =
    is_copy_assignable&lt;T&gt;::value;
}}
{{dcl|since=c++17|1=
template&lt; class T &gt;
inline constexpr bool is_trivially_copy_assignable_v =
    is_trivially_copy_assignable&lt;T&gt;::value;
}}
{{dcl|since=c++17|1=
template&lt; class T &gt;
inline constexpr bool is_nothrow_copy_assignable_v =
    is_nothrow_copy_assignable&lt;T&gt;::value;
}}
{{dcl end}}

{{cpp/types/integral_constant/inherit|{{tt|T}} is copy-assignable}}

===Possible implementation===
{{eq fun
|1=
template&lt;class T&gt;
struct is_copy_assignable
    : std::is_assignable&lt;typename std::add_lvalue_reference&lt;T&gt;::type,
                         typename std::add_lvalue_reference&lt;const T&gt;::type&gt; {};

template&lt;class T&gt;
struct is_trivially_copy_assignable
    : std::is_trivially_assignable&lt;typename std::add_lvalue_reference&lt;T&gt;::type,
                                   typename std::add_lvalue_reference&lt;const T&gt;::type&gt; {};

template&lt;class T&gt;
struct is_nothrow_copy_assignable
    : std::is_nothrow_assignable&lt;typename std::add_lvalue_reference&lt;T&gt;::type,
                                 typename std::add_lvalue_reference&lt;const T&gt;::type&gt; {};
}}

===Notes===
The trait {{tt|std::is_copy_assignable}} is less strict than {{named req|CopyAssignable}} because it does not check the type of the result of the assignment (which, for a {{named req|CopyAssignable}} type, must be an lvalue of type {{tt|T}}) and does not check the semantic requirement that the argument expression remains unchanged. It also does not check that {{tt|T}} satisfies {{named req|MoveAssignable}}, which is required of all {{named req|CopyAssignable}} types.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;utility&gt;

struct Foo { int n; };

int main()
{
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; "Foo is trivially copy-assignable? "
              &lt;&lt; std::is_trivially_copy_assignable&lt;Foo&gt;::value &lt;&lt; '\n'
              &lt;&lt; "int[2] is copy-assignable? "
              &lt;&lt; std::is_copy_assignable&lt;int[2]&gt;::value &lt;&lt; '\n'
              &lt;&lt; "int is nothrow copy-assignable? "
              &lt;&lt; std::is_nothrow_copy_assignable&lt;int&gt;::value &lt;&lt; '\n';
}
|output=
Foo is trivially copy-assignable? true
int[2] is copy-assignable? false
int is nothrow copy-assignable? true
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2196|std=C++11|before=the behavior was unclear if {{c/core|const T&amp;}} cannot be formed|after=the value produced is {{c|false}} in this case}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_assignable}}
{{dsc inc|cpp/types/dsc is_move_assignable}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}