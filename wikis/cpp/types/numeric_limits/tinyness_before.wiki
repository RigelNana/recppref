{{cpp/types/numeric_limits/title|tinyness_before}}
{{cpp/types/numeric_limits/navbar}}
{{dcl begin}}
{{dcl rev multi|until1=c++11
|dcl1=
static const bool tinyness_before;
|dcl2=
static constexpr bool tinyness_before;
}}
{{dcl end}}

The value of {{c|std::numeric_limits&lt;T&gt;::tinyness_before}} is {{c|true}} for all floating-point types {{tt|T}} that test results of floating-point expressions for underflow before rounding.

===Standard specializations===
{{dsc begin}}
{{dsc hitem | {{tt|T}} | value of {{c|std::numeric_limits&lt;T&gt;::tinyness_before}} }}
{{dsc | {{c/core|/* non-specialized */}}   | {{c|false}} }}
{{dsc | {{c/core|bool}}              | {{c|false}} }}
{{dsc | {{c/core|char}}              | {{c|false}} }}
{{dsc | {{c/core|signed char}}       | {{c|false}} }}
{{dsc | {{c/core|unsigned char}}     | {{c|false}} }}
{{dsc | {{c/core|wchar_t}}           | {{c|false}} }}
{{dsc | {{c/core|char8_t}} {{mark since c++20}}  | {{c|false}} }}
{{dsc | {{c/core|char16_t}} {{mark since c++11}} | {{c|false}} }}
{{dsc | {{c/core|char32_t}} {{mark since c++11}} | {{c|false}} }}
{{dsc | {{c/core|short}}             | {{c|false}} }}
{{dsc | {{c/core|unsigned short}}    | {{c|false}} }}
{{dsc | {{c/core|int}}               | {{c|false}} }}
{{dsc | {{c/core|unsigned int}}      | {{c|false}} }}
{{dsc | {{c/core|long}}              | {{c|false}} }}
{{dsc | {{c/core|unsigned long}}     | {{c|false}} }}
{{dsc | {{c/core|long long}} {{mark since c++11}}          | {{c|false}} }}
{{dsc | {{c/core|unsigned long long}} {{mark since c++11}} | {{c|false}} }}
{{dsc | {{c/core|float}}             | implementation-defined }}
{{dsc | {{c/core|double}}            | implementation-defined }}
{{dsc | {{c/core|long double}}       | implementation-defined }}
{{dsc end}}

===Notes===
Standard-compliant IEEE 754 floating-point implementations are required to detect the floating-point underflow, and have two alternative situations where this can be done
# Underflow occurs (and {{lc|FE_UNDERFLOW}} may be raised) if a computation produces a result whose absolute value, computed as though both the exponent range and the precision were unbounded, is smaller than {{c|std::numeric_limits&lt;T&gt;::min()}}. Such implementation detects tinyness before rounding (e.g. UltraSparc, POWER).
# Underflow occurs (and {{lc|FE_UNDERFLOW}} may be raised) if after the rounding of the result to the target floating-point type (that is, rounding to {{c|std::numeric_limits&lt;T&gt;::digits}} bits), the result's absolute value is smaller than {{c|std::numeric_limits&lt;T&gt;::min()}}. Formally, the absolute value of a nonzero result computed as though the exponent range were unbounded is smaller than {{c|std::numeric_limits&lt;T&gt;::min()}}. Such implementation detects tinyness after rounding (e.g. SuperSparc).

===Example===
{{example
|Multiplication of the largest subnormal number by the number one machine epsilon greater than 1.0 gives the tiny value 0x0.fffffffffffff8p-1022 before rounding, but normal value 1p-1022 after rounding. The implementation used to execute this test ({{enwiki|IBM Power microprocessors#POWER7|IBM Power7}}) detects tinyness before rounding.
|code=
#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;cmath&gt;
#include &lt;cfenv&gt;

int main()
{
    std::cout &lt;&lt; "Tinyness before: " &lt;&lt; std::boolalpha
              &lt;&lt; std::numeric_limits&lt;double&gt;::tinyness_before &lt;&lt; '\n';
    
    double denorm_max = std::nextafter(std::numeric_limits&lt;double&gt;::min(), 0);
    double multiplier = 1 + std::numeric_limits&lt;double&gt;::epsilon();
    
    std::feclearexcept(FE_ALL_EXCEPT);
    
    double result = denorm_max * multiplier; // Underflow only if tinyness_before
    
    if (std::fetestexcept(FE_UNDERFLOW))
        std::cout &lt;&lt; "Underflow detected\n";
    
    std::cout &lt;&lt; std::hexfloat &lt;&lt; denorm_max &lt;&lt; " x " &lt;&lt; multiplier  &lt;&lt;  " = "
              &lt;&lt; result &lt;&lt; '\n';
}
|p=true
|output=
Tinyness before: true
Underflow detected
0xf.ffffffffffffp-1030 x 0x1.0000000000001p+0 = 0x1p-1022
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/numeric_limits/dsc has_denorm_loss}}
{{dsc inc|cpp/types/numeric_limits/dsc has_denorm}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}