{{cpp/types/numeric_limits/title|min}}
{{cpp/types/numeric_limits/navbar}}
{{dcl begin}}
{{dcl header|limits}}
{{dcl rev multi|until1=c++11
|dcl1=
static T min() throw();
|dcl2=
static constexpr T min() noexcept; 
}}
{{dcl end}}

Returns the minimum finite value representable by the numeric type {{tt|T}}.  

For floating-point types with denormalization, {{tt|min()}} returns the minimum positive normalized value.  ''Note that this behavior may be unexpected'', especially when compared to the behavior of {{tt|min()}} for integral types. {{rev inl|since=c++11|To find the value that has no values less than it, use {{rlpf|lowest}}.}}

{{tt|min()}} is only meaningful for bounded types and for unbounded unsigned types.

===Return value===
{{dsc begin}}
{{dsc hitem|{{tt|T}}|{{c|std::numeric_limits&lt;T&gt;::min()}}}}
{{dsc|{{c/core|/* non-specialized */}}|{{c|T()}}}}
{{dsc|{{c/core|bool}}|{{c|false}}}}
{{dsc|{{c/core|char}}|{{c|CHAR_MIN}}}}
{{dsc|{{c/core|signed char}}|{{c|SCHAR_MIN}}}}
{{dsc|{{c/core|unsigned char}}|{{c|0}}}}
{{dsc|{{c/core|wchar_t}}|{{c|WCHAR_MIN}}}}
{{dsc|{{c/core|char8_t}} {{mark since c++20}}|{{c|0}}}}
{{dsc|{{c/core|char16_t}} {{mark since c++11}}|{{c|0}}}}
{{dsc|{{c/core|char32_t}} {{mark since c++11}}|{{c|0}}}}
{{dsc|{{c/core|short}}|{{c|SHRT_MIN}}}}
{{dsc|{{c/core|unsigned short}}|{{c|0}}}}
{{dsc|{{c/core|int}}|{{c|INT_MIN}}}}
{{dsc|{{c/core|unsigned int}}|{{c|0}}}}
{{dsc|{{c/core|long}}|{{c|LONG_MIN}}}}
{{dsc|{{c/core|unsigned long}}|{{c|0}}}}
{{dsc|{{c/core|long long}} {{mark since c++11}}|{{c|LLONG_MIN}}}}
{{dsc|{{c/core|unsigned long long}} {{mark since c++11}}|{{c|0}}}}
{{dsc|{{c/core|float}}|{{c|FLT_MIN}}}}
{{dsc|{{c/core|double}}|{{c|DBL_MIN}}}}
{{dsc|{{c/core|long double}}|{{c|LDBL_MIN}}}}
{{dsc end}}

===Example===
{{example
|Demonstrates the use with typedef types, and the difference in the sign of the result between integer and floating-point types:
|code=
#include &lt;cstddef&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;

// we want to print char types as an integer without leading Fs
auto p(auto x) { return x; }
auto p(char x) { return x &amp; static_cast&lt;unsigned char&gt;(-1); }
 
template &lt;typename T&gt;
void print_one(std::string_view type_name)
{
    constexpr T min = std::numeric_limits&lt;T&gt;::min();

    std::cout 
        &lt;&lt; std::dec &lt;&lt; std::defaultfloat &lt;&lt; std::setw(14) &lt;&lt; type_name
        &lt;&lt; " (" &lt;&lt; std::setw(2) &lt;&lt; sizeof(T) &lt;&lt; " bytes): " &lt;&lt; +min;
 
    if constexpr (min != 0)
        std::cout &lt;&lt; " or " &lt;&lt; std::showbase &lt;&lt; std::hex &lt;&lt; std::hexfloat &lt;&lt; p(min);
 
    std::cout &lt;&lt; '\n';
}
 
#define SHOW(T) print_one&lt;T&gt;(#T)
 
int main()
{
    SHOW(bool);
    SHOW(char);
    SHOW(unsigned char);
    SHOW(short);
    SHOW(unsigned short);
    SHOW(signed);
    SHOW(unsigned);
    SHOW(std::ptrdiff_t);
    SHOW(std::size_t);
    SHOW(float);
    SHOW(double);
    SHOW(long double);
}
|p=true
|output=&lt;nowiki/&gt;
          bool ( 1 bytes): 0
          char ( 1 bytes): -128 or 0x80
 unsigned char ( 1 bytes): 0
         short ( 2 bytes): -32768 or 0x8000
unsigned short ( 2 bytes): 0
        signed ( 4 bytes): -2147483648 or 0x80000000
      unsigned ( 4 bytes): 0
std::ptrdiff_t ( 8 bytes): -9223372036854775808 or 0x8000000000000000
   std::size_t ( 8 bytes): 0
         float ( 4 bytes): 1.17549e-38 or 0x1p-126
        double ( 8 bytes): 2.22507e-308 or 0x1p-1022
   long double (16 bytes): 3.3621e-4932 or 0x8p-16385
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/numeric_limits/dsc lowest}}
{{dsc inc|cpp/types/numeric_limits/dsc denorm_min}}
{{dsc inc|cpp/types/numeric_limits/dsc max}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}