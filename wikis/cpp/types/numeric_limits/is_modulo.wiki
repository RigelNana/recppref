{{cpp/types/numeric_limits/title|is_modulo}}
{{cpp/types/numeric_limits/navbar}}
{{dcl begin}}
{{dcl rev multi|until1=c++11
|dcl1=
static const bool is_modulo;
|dcl2=
static constexpr bool is_modulo;
}}
{{dcl end}}

The value of {{c|std::numeric_limits&lt;T&gt;::is_modulo}} is {{c|true}} for all arithmetic types {{tt|T}} that handle overflows with modulo arithmetic, that is, if the result of addition, subtraction, multiplication, or division of this type would fall outside the range {{tt|[}}{{lc|min()}}{{tt|,&amp;nbsp;}}{{lc|max()}}{{tt|]}}, the value returned by such operation differs from the expected value by a multiple of {{c|max() - min() + 1}}.

{{tt|is_modulo}} is {{c|false}} for signed integer types, unless the implementation defines signed integer overflow to wrap.

===Standard specializations===
{{dsc begin}}
{{dsc hitem | {{tt|T}} | value of {{c|std::numeric_limits&lt;T&gt;::is_modulo}} }}
{{dsc | {{c/core|/* non-specialized */}} | {{c|false}} }}
{{dsc | {{c/core|bool}}              | {{c|false}} }}
{{dsc | {{c/core|char}}              | implementation-defined }}
{{dsc | {{c/core|signed char}}       | implementation-defined }}
{{dsc | {{c/core|unsigned char}}     | {{c|true}} }}
{{dsc | {{c/core|wchar_t}}           | implementation-defined }}
{{dsc | {{c/core|char8_t}} {{mark since c++20}}  | {{c|true}} }}
{{dsc | {{c/core|char16_t}} {{mark since c++11}} | {{c|true}} }}
{{dsc | {{c/core|char32_t}} {{mark since c++11}} | {{c|true}} }}
{{dsc | {{c/core|short}}             | implementation-defined }}
{{dsc | {{c/core|unsigned short}}    | {{c|true}} }}
{{dsc | {{c/core|int}}               | implementation-defined }}
{{dsc | {{c/core|unsigned int}}      | {{c|true}} }}
{{dsc | {{c/core|long}}              | implementation-defined }}
{{dsc | {{c/core|unsigned long}}     | {{c|true}} }}
{{dsc | {{c/core|long long}} {{mark c++11}}          | implementation-defined }}
{{dsc | {{c/core|unsigned long long}} {{mark c++11}} | {{c|true}} }}
{{dsc | {{c/core|float}}             | {{c|false}} }}
{{dsc | {{c/core|double}}            | {{c|false}} }}
{{dsc | {{c/core|long double}}       | {{c|false}} }}
{{dsc end}}

===Notes===
The standard said "On most machines, this is {{c|true}} for signed integers." before the resolution of {{lwg|2422}}. See [http://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200 GCC PR 22200] for a related discussion.

===Example===
{{example
|Demonstrates the behavior of modulo types:
|code=
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;limits&gt;

template&lt;class T&gt;
typename std::enable_if&lt;std::numeric_limits&lt;T&gt;::is_modulo&gt;::type
    check_overflow()
{
    std::cout &lt;&lt; "max value is " &lt;&lt; std::numeric_limits&lt;T&gt;::max() &lt;&lt; '\n'
              &lt;&lt; "min value is " &lt;&lt; std::numeric_limits&lt;T&gt;::min() &lt;&lt; '\n'
              &lt;&lt; "max value + 1 is " &lt;&lt; std::numeric_limits&lt;T&gt;::max()+1 &lt;&lt; '\n';
}

int main()
{
    check_overflow&lt;int&gt;();
    std::cout &lt;&lt; '\n';
    check_overflow&lt;unsigned long&gt;();
//  check_overflow&lt;float&gt;(); // compile-time error, not a modulo type
}
|p=true
|output=
max value is 2147483647
min value is -2147483648
max value + 1 is -2147483648

max value is 18446744073709551615
min value is 0
max value + 1 is 0
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=612|std=C++98|before=the definition of "handle overflows&lt;br&gt;with modulo arithmetic" was poor&lt;ref&gt;The definition is "adding two positive numbers can have a result that wraps around to a third number that is less". It has the following problems:
* It does not define the wrapped value.
* It does not state whether result is repeatable.
* It does not require that doing addition, subtraction and other operations on all values have defined behavior.&lt;/ref&gt;|after=provided a&lt;br&gt;better definition}}
{{dr list item|wg=lwg|dr=2422|std=c++98|before={{tt|is_modulo}} was required to be {{c|true}} for&lt;br&gt;signed integer types on most machines|after=required to be {{c|false}} for signed integer types&lt;br&gt;unless signed integer overflow is defined to wrap}}
{{dr list end}}
&lt;references/&gt;

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/numeric_limits/dsc is_integer}}
{{dsc inc|cpp/types/numeric_limits/dsc is_iec559}}
{{dsc inc|cpp/types/numeric_limits/dsc is_exact}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}