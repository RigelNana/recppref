{{cpp/types/numeric_limits/title | digits10}}
{{cpp/types/numeric_limits/navbar}}
{{dcl begin}}
{{dcl rev multi | until1=c++11
| dcl1=
static const int digits10;
| dcl2=
static constexpr int digits10;
}}
{{dcl end}}

The value of {{c|std::numeric_limits&lt;T&gt;::digits10}} is the number of base-10 digits that can be represented by the type {{tt|T}} without change, that is, any number with this many significant decimal digits can be converted to a value of type {{tt|T}} and back to decimal form, without change due to rounding or overflow. For base-{{rlp|radix}} types, it is the value of {{rlpf|digits}} ({{c|digits - 1}} for floating-point types) multiplied by {{mathjax-or|\(\small \log_{10}{radix}\)|log{{su|b=10}}(radix)}} and rounded down.

===Standard specializations===
{{dsc begin}}
{{dsc hitem | {{tt|T}} | value of {{c|std::numeric_limits&lt;T&gt;::digits10}} }}
{{dsc | {{c/core|/* non-specialized */}}   | {{c|0}} }}
{{dsc | {{c/core|bool}}              | {{c|0}} }}
{{dsc | {{c/core|char}}              | {{c|std::numeric_limits&lt;char&gt;::digits * std::log10(2)}} }}
{{dsc | {{c/core|signed char}}       | {{c|std::numeric_limits&lt;signed char&gt;::digits * std::log10(2)}} }}
{{dsc | {{c/core|unsigned char}}     | {{c|std::numeric_limits&lt;unsigned char&gt;::digits * std::log10(2)}} }}
{{dsc | {{c/core|wchar_t}}           | {{c|std::numeric_limits&lt;wchar_t&gt;::digits * std::log10(2)}} }}
{{dsc | {{c/core|char8_t}} {{mark since c++20}}  | {{c|std::numeric_limits&lt;char8_t&gt;::digits * std::log10(2)}} }}
{{dsc | {{c/core|char16_t}} {{mark since c++11}} | {{c|std::numeric_limits&lt;char16_t&gt;::digits * std::log10(2)}} }}
{{dsc | {{c/core|char32_t}} {{mark since c++11}} | {{c|std::numeric_limits&lt;char32_t&gt;::digits * std::log10(2)}} }}
{{dsc | {{c/core|short}}             | {{c|std::numeric_limits&lt;short&gt;::digits * std::log10(2)}} }}
{{dsc | {{c/core|unsigned short}}    | {{c|std::numeric_limits&lt;unsigned short&gt;::digits * std::log10(2)}} }}
{{dsc | {{c/core|int}}               | {{c|std::numeric_limits&lt;int&gt;::digits * std::log10(2)}} }}
{{dsc | {{c/core|unsigned int}}      | {{c|std::numeric_limits&lt;unsigned int&gt;::digits * std::log10(2)}} }}
{{dsc | {{c/core|long}}              | {{c|std::numeric_limits&lt;long&gt;::digits * std::log10(2)}} }}
{{dsc | {{c/core|unsigned long}}     | {{c|std::numeric_limits&lt;unsigned long&gt;::digits * std::log10(2)}} }}
{{dsc | {{c/core|long long}} {{mark since c++11}}          | {{c|std::numeric_limits&lt;long long&gt;::digits * std::log10(2)}} }}
{{dsc | {{c/core|unsigned long long}} {{mark since c++11}} | {{c|std::numeric_limits&lt;unsigned long long&gt;::digits * std::log10(2)}} }}
{{dsc | {{c/core|float}}             | {{lc|FLT_DIG}} ({{c|6}} for IEEE {{c/core|float}}) }}
{{dsc | {{c/core|double}}            | {{lc|DBL_DIG}} ({{c|15}} for IEEE {{c/core|double}}) }}
{{dsc | {{c/core|long double}}       | {{lc|LDBL_DIG}} ({{c|18}} for 80-bit Intel {{c/core|long double}}; {{c|33}} for IEEE quadruple) }}
{{dsc end}}

===Example===
An 8-bit binary type can represent any two-digit decimal number exactly, but 3-digit decimal numbers 256..999 cannot be represented. The value of {{tt|digits10}} for an 8-bit type is 2 ({{c|1=8 * std::log10(2)}} is 2.41)

The standard 32-bit IEEE 754 floating-point type has a 24 bit fractional part (23 bits written, one implied), which may suggest that it can represent 7 digit decimals ({{c|1=24 * std::log10(2)}} is 7.22), but relative rounding errors are non-uniform and some floating-point values with 7 decimal digits do not survive conversion to 32-bit float and back: the smallest positive example is {{c|8.589973e9}}, which becomes {{c|8.589974e9}} after the roundtrip. These rounding errors cannot exceed one bit in the representation, and {{tt|digits10}} is calculated as {{c|1=(24 - 1) * std::log10(2)}}, which is 6.92. Rounding down results in the value 6.

Likewise, the 16-digit string {{c|9007199254740993}} does not survive text-&gt;double-&gt;text roundtrip, becoming {{c|9007199254740992}}: the 64-bit IEEE 754 type double guarantees this roundtrip only for 15 decimal digits.

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/numeric_limits/dsc max_digits10}}
{{dsc inc|cpp/types/numeric_limits/dsc radix}}
{{dsc inc|cpp/types/numeric_limits/dsc digits}}
{{dsc inc|cpp/types/numeric_limits/dsc min_exponent}}
{{dsc inc|cpp/types/numeric_limits/dsc max_exponent}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}