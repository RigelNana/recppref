{{cpp/types/numeric_limits/title|has_denorm_loss}}
{{cpp/types/numeric_limits/navbar}}
{{dcl begin}}
{{dcl rev begin}}
{{dcl | until=c++11 |
static const bool has_denorm_loss;
}}
{{dcl | since=c++11 | deprecated=c++23 |
static constexpr bool has_denorm_loss;
}}
{{dcl rev end}}
{{dcl end}}

The value of {{c|std::numeric_limits&lt;T&gt;::has_denorm_loss}} is {{c|true}} for all floating-point types {{tt|T}} that detect loss of precision when creating a subnormal number as denormalization loss rather than as inexact result (see below).

===Standard specializations===
{{dsc begin}}
{{dsc hitem | {{tt|T}} | value of {{c|std::numeric_limits&lt;T&gt;::has_denorm_loss}} }}
{{dsc | {{c/core|/* non-specialized */}}   | {{c|false}} }}
{{dsc | {{c/core|bool}}              | {{c|false}} }}
{{dsc | {{c/core|char}}              | {{c|false}} }}
{{dsc | {{c/core|signed char}}       | {{c|false}} }}
{{dsc | {{c/core|unsigned char}}     | {{c|false}} }}
{{dsc | {{c/core|wchar_t}}           | {{c|false}} }}
{{dsc | {{c/core|char8_t}} {{mark since c++20}}  | {{c|false}} }}
{{dsc | {{c/core|char16_t}} {{mark since c++11}} | {{c|false}} }}
{{dsc | {{c/core|char32_t}} {{mark since c++11}} | {{c|false}} }}
{{dsc | {{c/core|short}}             | {{c|false}} }}
{{dsc | {{c/core|unsigned short}}    | {{c|false}} }}
{{dsc | {{c/core|int}}               | {{c|false}} }}
{{dsc | {{c/core|unsigned int}}      | {{c|false}} }}
{{dsc | {{c/core|long}}              | {{c|false}} }}
{{dsc | {{c/core|unsigned long}}     | {{c|false}} }}
{{dsc | {{c/core|long long}} {{mark since c++11}}          | {{c|false}} }}
{{dsc | {{c/core|unsigned long long}} {{mark since c++11}} | {{c|false}} }}
{{dsc | {{c/core|float}}             | implementation-defined }}
{{dsc | {{c/core|double}}            | implementation-defined }}
{{dsc | {{c/core|long double}}       | implementation-defined }}
{{dsc end}}

===Notes===
Standard-compliant IEEE 754 floating-point implementations of subnormal numbers are required to detect the loss of accuracy associated with the creation of such number, if it occurs, and may do so in one of the two distinct ways:
# Denormalization loss: the delivered result differs from what would have been computed were exponent range unbounded.
# Inexact result: the delivered result differs from what would have been computed were both exponent range and precision unbounded.

No implementation of denormalization loss mechanism exists (accuracy loss is detected after rounding, as inexact result), and this option was removed in the 2008 revision of IEEE Std 754.

libstdc++, libc++, libCstd, and stlport4 define this constant as {{c|false}} for all floating-point types. Microsoft Visual Studio defines it as {{c|true}} for all floating-point types.

As with any floating-point computations, accuracy loss may raise {{lc|FE_INEXACT}}.

===Example===
{{example
|code=
|output=
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/numeric_limits/dsc tinyness_before}}
{{dsc inc|cpp/types/numeric_limits/dsc has_denorm}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}