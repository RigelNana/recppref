{{cpp/types/numeric_limits/title|epsilon}}
{{cpp/types/numeric_limits/navbar}}
{{dcl begin}}
{{dcl rev multi|until1=c++11
|dcl1=
static T epsilon() throw();
|dcl2=
static constexpr T epsilon() noexcept;
}}
{{dcl end}}

Returns the machine epsilon, that is, the difference between {{c|1.0}} and the next value representable by the floating-point type {{tt|T}}. It is only meaningful if {{c|1=std::numeric_limits&lt;T&gt;::is_integer == false}}.

===Return value===
{{dsc begin}}
{{dsc hitem|{{tt|T}}|{{c|std::numeric_limits&lt;T&gt;::epsilon()}}}}
{{dsc|{{c/core|/* non-specialized */}}|{{c|T()}}}}
{{dsc|{{c/core|bool}}|{{c|false}}}}
{{dsc|{{c/core|char}}|{{c|0}}}}
{{dsc|{{c/core|signed char}}|{{c|0}}}}
{{dsc|{{c/core|unsigned char}}|{{c|0}}}}
{{dsc|{{c/core|wchar_t}}|{{c|0}}}}
{{dsc|{{c/core|char8_t}} {{mark since c++20}}|{{c|0}}}}
{{dsc|{{c/core|char16_t}} {{mark since c++11}}|{{c|0}}}}
{{dsc|{{c/core|char32_t}} {{mark since c++11}}|{{c|0}}}}
{{dsc|{{c/core|short}}|{{c|0}}}}
{{dsc|{{c/core|unsigned short}}|{{c|0}}}}
{{dsc|{{c/core|int}}|{{c|0}}}}
{{dsc|{{c/core|unsigned int}}|{{c|0}}}}
{{dsc|{{c/core|long}}|{{c|0}}}}
{{dsc|{{c/core|unsigned long}}|{{c|0}}}}
{{dsc|{{c/core|long long}} {{mark since c++11}}|{{c|0}}}}
{{dsc|{{c/core|unsigned long long}}{{mark since c++11}}|{{c|0}}}}
{{dsc|{{c/core|float}}|{{lc|FLT_EPSILON}}}}
{{dsc|{{c/core|double}}|{{lc|DBL_EPSILON}}}}
{{dsc|{{c/core|long double}}|{{lc|LDBL_EPSILON}}}}
{{dsc end}}

===Example===
{{example
|Demonstrates the use of machine epsilon to compare floating-point values for equality:
|code=
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstddef&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;type_traits&gt;

template &lt;class T&gt;
std::enable_if_t&lt;not std::numeric_limits&lt;T&gt;::is_integer, bool&gt;
equal_within_ulps(T x, T y, std::size_t n)
{
    // Since `epsilon()` is the gap size (ULP, unit in the last place)
    // of floating-point numbers in interval [1, 2), we can scale it to
    // the gap size in interval [2^e, 2^{e+1}), where `e` is the exponent
    // of `x` and `y`.

    // If `x` and `y` have different gap sizes (which means they have
    // different exponents), we take the smaller one. Taking the bigger
    // one is also reasonable, I guess.
    const T m = std::min(std::fabs(x), std::fabs(y));

    // Subnormal numbers have fixed exponent, which is `min_exponent - 1`.
    const int exp = m &lt; std::numeric_limits&lt;T&gt;::min()
                  ? std::numeric_limits&lt;T&gt;::min_exponent - 1
                  : std::ilogb(m);

    // We consider `x` and `y` equal if the difference between them is
    // within `n` ULPs.
    return std::fabs(x - y) &lt;= n * std::ldexp(std::numeric_limits&lt;T&gt;::epsilon(), exp);
}

int main()
{
    double x = 0.3;
    double y = 0.1 + 0.2;
    std::cout &lt;&lt; std::hexfloat;
    std::cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; '\n';
    std::cout &lt;&lt; "y = " &lt;&lt; y &lt;&lt; '\n';
    std::cout &lt;&lt; (x == y ? "x == y" : "x != y") &lt;&lt; '\n';
    for (std::size_t n = 0; n &lt;= 10; ++n)
        if (equal_within_ulps(x, y, n))
        {
            std::cout &lt;&lt; "x equals y within " &lt;&lt; n &lt;&lt; " ulps" &lt;&lt; '\n';
            break;
        }
}
|output=
x = 0x1.3333333333333p-2
y = 0x1.3333333333334p-2
x != y
x equals y within 1 ulps
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc nextafter}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}