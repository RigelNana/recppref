{{cpp/title|enable_if}}
{{cpp/meta/navbar}}
{{ddcl|header=type_traits|since=c++11|1=
template&lt; bool B, class T = void &gt;
struct enable_if;
}}

If {{tt|B}} is {{c|true}}, {{tt|std::enable_if}} has a public member typedef {{tt|type}}, equal to {{tt|T}}; otherwise, there is no member typedef. 

This metafunction is a convenient way to leverage [[cpp/language/sfinae|SFINAE]] prior to C++20's [[cpp/language/constraints|concepts]], in particular for conditionally removing functions from the [[cpp/language/overload_resolution|candidate set]] based on type traits, allowing separate function overloads or specializations based on those different type traits.

{{tt|std::enable_if}} can be used in many forms, including:
* as an additional function argument (not applicable to most operator overloads),
* as a return type (not applicable to constructors and destructors),
* as a class template or function template parameter.

{{cpp/types/nospec}}

===Member types===
{{dsc begin}}
{{dsc hitem|Type|Definition}}
{{dsc|{{tt|type}}|either {{tt|T}} or no such member, depending on the value of {{tt|B}}}}
{{dsc end}}

===Helper types===
{{ddcl|since=c++14|1=
template&lt; bool B, class T = void &gt;
using enable_if_t = typename enable_if&lt;B,T&gt;::type;
}}

===Possible implementation===
{{eq fun
|1=
template&lt;bool B, class T = void&gt;
struct enable_if {};

template&lt;class T&gt;
struct enable_if&lt;true, T&gt; { typedef T type; };
}}

===Notes===
A common mistake is to declare two function templates that differ only in their default template arguments. This does not work because the declarations are treated as redeclarations of the same function template (default template arguments are not accounted for in [[cpp/language/function template#Function template overloading|function template equivalence]]).

{{source|1=
/* WRONG */

struct T
{
    enum { int_t, float_t } type;

    template&lt;typename Integer,
             typename = std::enable_if_t&lt;std::is_integral&lt;Integer&gt;::value&gt;&gt;
    T(Integer) : type(int_t) {}

    template&lt;typename Floating,
             typename = std::enable_if_t&lt;std::is_floating_point&lt;Floating&gt;::value&gt;&gt;
    T(Floating) : type(float_t) {} // error: treated as redefinition
};

/* RIGHT */

struct T
{
    enum { int_t, float_t } type;

    template&lt;typename Integer,
             std::enable_if_t&lt;std::is_integral&lt;Integer&gt;::value, bool&gt; = true&gt;
    T(Integer) : type(int_t) {}

    template&lt;typename Floating,
             std::enable_if_t&lt;std::is_floating_point&lt;Floating&gt;::value, bool&gt; = true&gt;
    T(Floating) : type(float_t) {} // OK
};
}}

Care should be taken when using {{tt|enable_if}} in the type of a template non-type parameter of a namespace-scope function template. Some ABI specifications like the Itanium ABI do not include the instantiation-dependent portions of non-type template parameters in the mangling, meaning that specializations of two distinct function templates might end up with the same mangled name and be erroneously linked together. For example:

{{source|1=
// first translation unit

struct X
{
    enum { value1 = true, value2 = true };
};

template&lt;class T, std::enable_if_t&lt;T::value1, int&gt; = 0&gt;
void func() {} // #1

template void func&lt;X&gt;(); // #2

// second translation unit

struct X
{
    enum { value1 = true, value2 = true };
};

template&lt;class T, std::enable_if_t&lt;T::value2, int&gt; = 0&gt;
void func() {} // #3

template void func&lt;X&gt;(); // #4
}}

The function templates #1 and #3 have different signatures and are distinct templates. Nonetheless, #2 and #4, despite being instantiations of different function templates, have the same mangled name [https://github.com/itanium-cxx-abi/cxx-abi/issues/20 in the Itanium C++ ABI] ({{tt|_Z4funcI1XLi0EEvv}}), meaning that the linker will erroneously consider them to be the same entity.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;new&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;

namespace detail
{ 
    void* voidify(const volatile void* ptr) noexcept { return const_cast&lt;void*&gt;(ptr); } 
}

// #1, enabled via the return type
template&lt;class T&gt;
typename std::enable_if&lt;std::is_trivially_default_constructible&lt;T&gt;::value&gt;::type 
    construct(T*) 
{
    std::cout &lt;&lt; "default constructing trivially default constructible T\n";
}

// same as above
template&lt;class T&gt;
typename std::enable_if&lt;!std::is_trivially_default_constructible&lt;T&gt;::value&gt;::type 
    construct(T* p) 
{
    std::cout &lt;&lt; "default constructing non-trivially default constructible T\n";
    ::new(detail::voidify(p)) T;
}

// #2
template&lt;class T, class... Args&gt;
std::enable_if_t&lt;std::is_constructible&lt;T, Args&amp;&amp;...&gt;::value&gt; // Using helper type
    construct(T* p, Args&amp;&amp;... args) 
{
    std::cout &lt;&lt; "constructing T with operation\n";
    ::new(detail::voidify(p)) T(static_cast&lt;Args&amp;&amp;&gt;(args)...);
}

// #3, enabled via a parameter
template&lt;class T&gt;
void destroy(
    T*, 
    typename std::enable_if&lt;
        std::is_trivially_destructible&lt;T&gt;::value
    &gt;::type* = 0)
{
    std::cout &lt;&lt; "destroying trivially destructible T\n";
}

// #4, enabled via a non-type template parameter
template&lt;class T,
         typename std::enable_if&lt;
             !std::is_trivially_destructible&lt;T&gt;{} &amp;&amp;
             (std::is_class&lt;T&gt;{} {{!!}} std::is_union&lt;T&gt;{}),
             bool&gt;::type = true&gt;
void destroy(T* t)
{
    std::cout &lt;&lt; "destroying non-trivially destructible T\n";
    t-&gt;~T();
}

// #5, enabled via a type template parameter
template&lt;class T,
	 typename = std::enable_if_t&lt;std::is_array&lt;T&gt;::value&gt;&gt;
void destroy(T* t) // note: function signature is unmodified
{
    for (std::size_t i = 0; i &lt; std::extent&lt;T&gt;::value; ++i)
        destroy((*t)[i]);
}

/*
template&lt;class T,
	 typename = std::enable_if_t&lt;std::is_void&lt;T&gt;::value&gt;&gt;
void destroy(T* t) {} // error: has the same signature with #5
*/

// the partial specialization of A is enabled via a template parameter
template&lt;class T, class Enable = void&gt;
class A {}; // primary template

template&lt;class T&gt;
class A&lt;T, typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value&gt;::type&gt;
{}; // specialization for floating point types

int main()
{
    union { int i; char s[sizeof(std::string)]; } u;

    construct(reinterpret_cast&lt;int*&gt;(&amp;u));
    destroy(reinterpret_cast&lt;int*&gt;(&amp;u));

    construct(reinterpret_cast&lt;std::string*&gt;(&amp;u), "Hello");
    destroy(reinterpret_cast&lt;std::string*&gt;(&amp;u));

    A&lt;int&gt;{}; // OK: matches the primary template
    A&lt;double&gt;{}; // OK: matches the partial specialization
}
|output=
default constructing trivially default constructible T
destroying trivially destructible T
constructing T with operation
destroying non-trivially destructible T
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc void_t}}
{{dsc end}}
* {{ltt|cpp/language/static_assert}}
* [[cpp/language/sfinae|SFINAE]]
* [[cpp/language/constraints|Constraints and Concepts]]

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}