{{cpp/title|is_assignable|is_trivially_assignable|is_nothrow_assignable}}
{{cpp/meta/navbar}}
{{dcl begin}}
{{dcl header|type_traits}}
{{dcl|since=c++11|num=1|1=
template&lt; class T, class U &gt;
struct is_assignable;
}}
{{dcl|since=c++11|num=2|1=
template&lt; class T, class U &gt;
struct is_trivially_assignable;
}}
{{dcl|since=c++11|num=3|1=
template&lt; class T, class U &gt;
struct is_nothrow_assignable;
}}
{{dcl end}}

@1@ If the expression {{c|1=std::declval&lt;T&gt;() = std::declval&lt;U&gt;()}} is well-formed in unevaluated context, provides the member constant {{c|value}} equal to {{c|true}}. Otherwise, {{c|value}} is {{c|false}}. [[cpp/language/access|Access checks]] are performed as if from a context unrelated to either type.
@2@ Same as {{v|1}}, but the evaluation of the assignment expression will not call any operation that is not trivial. For the purposes of this check, a call to {{lc|std::declval}} is considered trivial and not considered an [[cpp/language/definition#ODR-use|odr-use]] of {{lc|std::declval}}.
@3@ Same as {{v|1}}, but the evaluation of the assignment expression will not call any operation that is not noexcept.

{{cpp/types/cvaub|type2=U}}

{{cpp/types/nospec|any}}

===Helper variable templates===
{{dcl begin}}

{{dcl|since=c++17|1=
template&lt; class T, class U &gt;
constexpr bool is_assignable_v = is_assignable&lt;T, U&gt;::value;
}}

{{dcl|since=c++17|1=
template&lt; class T, class U &gt;
constexpr bool is_trivially_assignable_v = is_trivially_assignable&lt;T, U&gt;::value;
}}

{{dcl|since=c++17|1=
template&lt; class T, class U &gt;
constexpr bool is_nothrow_assignable_v = is_nothrow_assignable&lt;T, U&gt;::value;
}}
{{dcl end}}
{{cpp/types/integral_constant/inherit|{{tt|T}} is assignable from {{tt|U}}}}

===Notes===
This trait does not check anything outside the immediate context of the assignment expression: if the use of {{tt|T}} or {{tt|U}} would trigger template specializations, generation of implicitly-defined special member functions etc, and those have errors, the actual assignment may not compile even if {{c/core|std::is_assignable&lt;T,U&gt;::value}} compiles and evaluates to {{c|true}}.

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;

struct Ex1 { int n; };

int main()
{
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; "int is assignable from int? "
              &lt;&lt; std::is_assignable&lt;int, int&gt;::value &lt;&lt; '\n' // 1 = 1; wouldn't compile
              &lt;&lt; "int&amp; is assignable from int? "
              &lt;&lt; std::is_assignable&lt;int&amp;, int&gt;::value &lt;&lt; '\n' // int a; a = 1; works
              &lt;&lt; "int is assignable from double? "
              &lt;&lt; std::is_assignable&lt;int, double&gt;::value &lt;&lt; '\n'
              &lt;&lt; "int&amp; is nothrow assignable from double? "
              &lt;&lt; std::is_nothrow_assignable&lt;int&amp;, double&gt;::value &lt;&lt; '\n'
              &lt;&lt; "string is assignable from double? "
              &lt;&lt; std::is_assignable&lt;std::string, double&gt;::value &lt;&lt; '\n'
              &lt;&lt; "Ex1&amp; is trivially assignable from const Ex1&amp;? "
              &lt;&lt; std::is_trivially_assignable&lt;Ex1&amp;, const Ex1&amp;&gt;::value &lt;&lt; '\n';
}
|output=
int is assignable from int? false
int&amp; is assignable from int? true
int is assignable from double? false
int&amp; is nothrow assignable from double? true
string is assignable from double? true
Ex1&amp; is trivially assignable from const Ex1&amp;? true
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_copy_assignable}}
{{dsc inc|cpp/types/dsc is_move_assignable}}
{{dsc inc|cpp/concepts/dsc assignable_from}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}