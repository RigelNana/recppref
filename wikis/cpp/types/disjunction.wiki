{{cpp/title|disjunction}}
{{cpp/meta/navbar}}
{{ddcl|header=type_traits|since=c++17|
template&lt; class... B &gt;
struct disjunction;
}}

Forms the {{enwiki|Logical disjunction|logical disjunction}} of the type traits {{c|B...}}, effectively performing a logical OR on the sequence of traits.

The specialization {{c|std::disjunction&lt;B1, ..., BN&gt;}} has a public and unambiguous base that is
* if {{c|1=sizeof...(B) == 0}}, {{c|std::false_type}}; otherwise
* the first type {{tt|Bi}} in {{tt|B1, ..., BN}} for which {{c|1=bool(Bi::value) == true}}, or {{tt|BN}} if there is no such type.

The member names of the base class, other than {{tt|disjunction}} and {{tt|1=operator=}}, are not hidden and are unambiguously available in {{tt|disjunction}}.

Disjunction is short-circuiting: if there is a template type argument {{tt|Bi}} with {{c|1=bool(Bi::value) != false}}, then instantiating {{c|disjunction&lt;B1, ..., BN&gt;::value}} does not require the instantiation of {{c|Bj::value}} for {{tt|j &gt; i}}.

{{cpp/types/nospec|pv}}

===Template parameters===
{{par begin}}
{{par|B...|every template argument {{tt|Bi}} for which {{c|Bi::value}} is instantiated must be usable as a base class and define member {{tt|value}} that is convertible to {{c/core|bool}}}}
{{par end}}

===Helper variable template===
{{dcl begin}}
{{dcl|since=c++17|1=
template&lt; class... B &gt;
constexpr bool disjunction_v = disjunction&lt;B...&gt;::value;
}}
{{dcl end}}

===Possible implementation===
{{eq fun
|1=
template&lt;class...&gt;
struct disjunction : std::false_type {};

template&lt;class B1&gt;
struct disjunction&lt;B1&gt; : B1 {};

template&lt;class B1, class... Bn&gt;
struct disjunction&lt;B1, Bn...&gt;
    : std::conditional_t&lt;bool(B1::value), B1, disjunction&lt;Bn...&gt;&gt;  {};
}}

===Notes===
A specialization of {{tt|disjunction}} does not necessarily inherit from of either {{c|std::true_type}} or {{c|std::false_type}}: it simply inherits from the first {{tt|B}} whose {{tt|::value}}, explicitly converted to {{c/core|bool}}, is {{c|true}}, or from the very last {{tt|B}} when all of them convert to {{c|false}}. For example, {{c|std::disjunction&lt;std::integral_constant&lt;int, 2&gt;, std::integral_constant&lt;int, 4&gt;&gt;::value}} is {{c|2}}.

The short-circuit instantiation differentiates {{tt|disjunction}} from [[cpp/language/fold|fold expressions]]: a fold expression like {{c|(... {{!!}} Bs::value)}} instantiates every {{tt|B}} in {{tt|Bs}}, while {{c|std::disjunction_v&lt;Bs...&gt;}} stops instantiation once the value can be determined. This is particularly useful if the later type is expensive to instantiate or can cause a hard error when instantiated with the wrong type.

{{feature test macro|__cpp_lib_logical_traits|std=C++17|value=201510L|[[cpp/meta#Operations on traits|Logical operator type traits]]}}

===Example===
{{example|code=
#include &lt;cstdint&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;

// values_equal&lt;a, b, T&gt;::value is true if and only if a == b.
template&lt;auto V1, decltype(V1) V2, typename T&gt;
struct values_equal : std::bool_constant&lt;V1 == V2&gt;
{
    using type = T;
};

// default_type&lt;T&gt;::value is always true
template&lt;typename T&gt;
struct default_type : std::true_type
{
    using type = T;
};

// Now we can use disjunction like a switch statement:
template&lt;int I&gt;
using int_of_size = typename std::disjunction&lt; //
    values_equal&lt;I, 1, std::int8_t&gt;,           //
    values_equal&lt;I, 2, std::int16_t&gt;,          //
    values_equal&lt;I, 4, std::int32_t&gt;,          //
    values_equal&lt;I, 8, std::int64_t&gt;,          //
    default_type&lt;void&gt;                         // must be last!
    &gt;::type;

static_assert(sizeof(int_of_size&lt;1&gt;) == 1);
static_assert(sizeof(int_of_size&lt;2&gt;) == 2);
static_assert(sizeof(int_of_size&lt;4&gt;) == 4);
static_assert(sizeof(int_of_size&lt;8&gt;) == 8);
static_assert(std::is_same_v&lt;int_of_size&lt;13&gt;, void&gt;);

// checking if Foo is constructible from double will cause a hard error
struct Foo
{
    template&lt;class T&gt;
    struct sfinae_unfriendly_check { static_assert(!std::is_same_v&lt;T, double&gt;); };

    template&lt;class T&gt;
    Foo(T, sfinae_unfriendly_check&lt;T&gt; = {});
};

template&lt;class... Ts&gt;
struct first_constructible
{
    template&lt;class T, class...Args&gt;
    struct is_constructible_x : std::is_constructible&lt;T, Args...&gt;
    {
        using type = T;
    };

    struct fallback
    {
        static constexpr bool value = true;
        using type = void; // type to return if nothing is found
    };

    template&lt;class... Args&gt;
    using with = typename std::disjunction&lt;is_constructible_x&lt;Ts, Args...&gt;...,
                                           fallback&gt;::type;
};

// OK, is_constructible&lt;Foo, double&gt; not instantiated
static_assert(std::is_same_v&lt;first_constructible&lt;std::string, int, Foo&gt;::with&lt;double&gt;,
                             int&gt;);

static_assert(std::is_same_v&lt;first_constructible&lt;std::string, int&gt;::with&lt;&gt;, std::string&gt;);
static_assert(std::is_same_v&lt;first_constructible&lt;std::string, int&gt;::with&lt;const char*&gt;,
                             std::string&gt;);
static_assert(std::is_same_v&lt;first_constructible&lt;std::string, int&gt;::with&lt;void*&gt;, void&gt;);

int main() {}
|output=
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc negation}}
{{dsc inc|cpp/types/dsc conjunction}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}