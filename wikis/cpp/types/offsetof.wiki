{{title|offsetof}}
{{cpp/types/navbar}}
{{dcl begin}}
{{dcl header|cstddef}}
{{dcl|
#define offsetof(type, member) /* implementation-defined */
}}
{{dcl end}}

The macro {{lc|offsetof}} expands to an integral constant expression of type {{lc|std::size_t}}, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified subobject, including [[cpp/language/object#Object representation and value representation|padding bits]] if any.

Given an object {{c|o}} of type {{tt|type}} and static storage duration, {{c|o.member}} shall be an lvalue constant expression that refers to a subobject of {{c|o}}. Otherwise, the behavior is undefined. Particularly, if {{tt|member}} is a [[cpp/language/static|static data member]], a [[cpp/language/bit field|bit-field]], or a [[cpp/language/member functions|member function]], the behavior is undefined.

If {{tt|type}} is not a {{rev inl|until=c++11|{{named req|PODType}}}}{{rev inl|since=c++11|{{lsd|cpp/language/data members#Standard-layout}} type}}, {{rev inl|until=c++17|the result of {{tt|offsetof}} is undefined}}{{rev inl|since=c++17|use of the {{tt|offsetof}} macro is conditionally-supported}}.

The expression {{c|offsetof(type, member)}} is never [[cpp/language/dependent name#Dependent types|type-dependent]] and it is value-dependent if and only if {{tt|type}} is dependent.

===Exceptions===
{{tt|offsetof}} throws no exceptions.
{{rrev|since=c++11|
The expression {{c|noexcept(offsetof(type, member))}} always evaluates to {{c|true}}.
}}

===Notes===
{{rrev|since=c++11|
The offset of the first member of a standard-layout type is always zero ([[cpp/language/ebo|empty-base optimization]] is mandatory).
}}

{{tt|offsetof}} cannot be implemented in standard C++ and requires compiler support: [https://github.com/gcc-mirror/gcc/blob/68ec60c4a377b532ec2d265ea542107c36b1d15c/gcc/ginclude/stddef.h#L406 GCC], [https://github.com/llvm-mirror/clang/blob/release_70/lib/Headers/stddef.h#L120 LLVM].

{{tt|member}} is not restricted to a direct member. It can denote a subobject of a given member, such as an element of an array member. This is specified by {{stddoc|lang=c|n2396.htm#dr_496|C DR 496}}.

It is specified in C23 that defining a new type containing an unparenthesized comma in {{tt|offsetof}} is undefined behavior, and such usage is generally not supported by implementations in C++ modes: {{c|offsetof(struct Foo { int a, b; }, a)}} is rejected by all known implementations.

===Example===
{{example
| 
|code=
#include &lt;cstddef&gt;
#include &lt;iostream&gt;

struct S
{
    char   m0;
    double m1;
    short  m2;
    char   m3;
//  private: int z; // warning: 'S' is a non-standard-layout type
};

int main()
{
    std::cout
        &lt;&lt; "offset of char   m0 = " &lt;&lt; offsetof(S, m0) &lt;&lt; '\n'
        &lt;&lt; "offset of double m1 = " &lt;&lt; offsetof(S, m1) &lt;&lt; '\n'
        &lt;&lt; "offset of short  m2 = " &lt;&lt; offsetof(S, m2) &lt;&lt; '\n'
        &lt;&lt; "offset of char   m3 = " &lt;&lt; offsetof(S, m3) &lt;&lt; '\n';
}
|p=true
|output=
offset of char   m0 = 0
offset of double m1 = 8
offset of short  m2 = 16
offset of char   m3 = 18
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=cwg|dr=273|std=C++98|before={{tt|offsetof}} may not work if unary {{tt|operator&amp;}} is overloaded|after=required to work correctly even&lt;br&gt;if {{tt|operator&amp;}} is overloaded}}
{{dr list item|wg=lwg|dr=306|std=C++98|before=the behavior was not specified when {{tt|type}} is not a {{named req|PODType}}|after=the result is undefined in this case}}
{{dr list item|wg=lwg|dr=449|std=C++98|before=other requirements of {{tt|offsetof}} were&lt;br&gt;removed by the resolution of {{lwg|306}}|after=added them back}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc size_t}}
{{dsc inc|cpp/types/dsc is_standard_layout}}
{{dsc see c|c/types/offsetof}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}