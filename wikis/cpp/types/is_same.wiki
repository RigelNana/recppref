{{cpp/title|is_same}}
{{cpp/meta/navbar}}
{{ddcl|header=type_traits|since=c++11|
template&lt; class T, class U &gt;
struct is_same;
}}

If {{tt|T}} and {{tt|U}} name the same type (taking into account const/volatile qualifications), provides the member constant {{c|value}} equal to {{c|true}}. Otherwise {{c|value}} is {{c|false}}.

Commutativity is satisfied, i.e. for any two types {{tt|T}} and {{tt|U}}, {{c|1=is_same&lt;T, U&gt;::value == true}} if and only if {{c|1=is_same&lt;U, T&gt;::value == true}}.

{{cpp/types/nospec|v}}

===Helper variable template===
{{ddcl|since=c++17|1=
template&lt; class T, class U &gt;
constexpr bool is_same_v = is_same&lt;T, U&gt;::value;
}}
{{cpp/types/integral_constant/inherit|{{tt|T}} and {{tt|U}} are the same type}}

===Possible implementation===
{{eq fun
|1=
template&lt;class T, class U&gt;
struct is_same : std::false_type {};

template&lt;class T&gt;
struct is_same&lt;T, T&gt; : std::true_type {};
}}

===Example===
{{example
|code=
#include &lt;cstdint&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;

int main()
{
    std::cout &lt;&lt; std::boolalpha;

    // some implementation-defined facts

    // usually true if 'int' is 32 bit
    std::cout &lt;&lt; std::is_same&lt;int, std::int32_t&gt;::value &lt;&lt; ' '; // maybe true
    // possibly true if ILP64 data model is used
    std::cout &lt;&lt; std::is_same&lt;int, std::int64_t&gt;::value &lt;&lt; ' '; // maybe false

    // same tests as above, except using C++17's std::is_same_v&lt;T, U&gt; format
    std::cout &lt;&lt; std::is_same_v&lt;int, std::int32_t&gt; &lt;&lt; ' ';  // maybe true
    std::cout &lt;&lt; std::is_same_v&lt;int, std::int64_t&gt; &lt;&lt; '\n'; // maybe false

    // compare the types of a couple variables
    long double num1 = 1.0;
    long double num2 = 2.0;
    static_assert( std::is_same_v&lt;decltype(num1), decltype(num2)&gt; == true );

    // 'float' is never an integral type
    static_assert( std::is_same&lt;float, std::int32_t&gt;::value == false );

    // 'int' is implicitly 'signed'
    static_assert( std::is_same_v&lt;int, int&gt; == true );
    static_assert( std::is_same_v&lt;int, unsigned int&gt; == false );
    static_assert( std::is_same_v&lt;int, signed int&gt; == true );

    // unlike other types, 'char' is neither 'unsigned' nor 'signed'
    static_assert( std::is_same_v&lt;char, char&gt; == true );
    static_assert( std::is_same_v&lt;char, unsigned char&gt; == false );
    static_assert( std::is_same_v&lt;char, signed char&gt; == false );

    // const-qualified type T is not same as non-const T
    static_assert( !std::is_same&lt;const int, int&gt;() );
}
|p=true
|output=
true false true false
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/concepts/dsc same_as}}
{{dsc inc|cpp/language/dsc decltype}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}