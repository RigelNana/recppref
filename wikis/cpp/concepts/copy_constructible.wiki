{{cpp/title|copy_constructible}}
{{cpp/concepts/navbar}}
{{ddcl|header=concepts|since=c++20|1=
template&lt; class T &gt;
concept copy_constructible =
    std::move_constructible&lt;T&gt; &amp;&amp;
    std::constructible_from&lt;T, T&amp;&gt; &amp;&amp; std::convertible_to&lt;T&amp;, T&gt; &amp;&amp;
    std::constructible_from&lt;T, const T&amp;&gt; &amp;&amp; std::convertible_to&lt;const T&amp;, T&gt; &amp;&amp;
    std::constructible_from&lt;T, const T&gt; &amp;&amp; std::convertible_to&lt;const T, T&gt;;
}}

The concept {{tt|copy_constructible}} is satisfied if {{c|T}} is an lvalue reference type, or if it is a {{lconcept|move_constructible}} object type where an object of that type can constructed from a (possibly const) lvalue or const rvalue of that type in both direct- and copy-initialization contexts with the usual semantics (a copy is constructed with the source unchanged).

===Semantic requirements===
If {{c|T}} is an object type, then {{tt|copy_constructible&lt;T&gt;}} is modeled only if given
* {{c|v}}, an lvalue of type (possibly {{c|const}}) {{c|T}} or an rvalue of type {{c|const T}},
the following are true:
* After the definition {{c|1=T u = v;}}, {{c|u}} is equal to {{c|v}} and {{c|v}} is not modified;
* {{c|T(v)}} is equal to {{c|v}} and does not modify {{c|v}}.

===References===
{{ref std c++23}}
{{ref std|section=18.4.14|title=Concept {{tt|copy_constructible}}|id=concept.copyconstructible}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=18.4.14|title=Concept {{tt|copy_constructible}}|id=concept.copyconstructible}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_copy_constructible}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}