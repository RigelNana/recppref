{{cpp/title|common_reference_with}}
{{cpp/concepts/navbar}}
{{ddcl|header=concepts|since=c++20|1=
template&lt; class T, class U &gt;
concept common_reference_with =
    std::same_as&lt;std::common_reference_t&lt;T, U&gt;, std::common_reference_t&lt;U, T&gt;&gt; &amp;&amp;
    std::convertible_to&lt;T, std::common_reference_t&lt;T, U&gt;&gt; &amp;&amp;
    std::convertible_to&lt;U, std::common_reference_t&lt;T, U&gt;&gt;;
}}
The concept {{tt|common_reference_with&lt;T, U&gt;}} specifies that two types {{tt|T}} and {{tt|U}} share a ''common reference type'' (as computed by {{lc|std::common_reference_t}}) to which both can be converted.

===Semantic requirements===
T and U model {{co|std::common_reference_with&lt;T, U&gt;}} only if, given [[cpp/concepts#Equality preservation|equality-preserving]] expressions {{tt|t1}}, {{tt|t2}}, {{tt|u1}} and {{tt|u2}} such that {{c|decltype((t1))}} and {{c|decltype((t2))}} are both {{tt|T}} and {{c|decltype((u1))}} and {{c|decltype((u2))}} are both {{tt|U}},
* {{c|std::common_reference_t&lt;T, U&gt;(t1)}} equals {{c|std::common_reference_t&lt;T, U&gt;(t2)}} if and only if {{tt|t1}} equals {{tt|t2}}; and
* {{c|std::common_reference_t&lt;T, U&gt;(u1)}} equals {{c|std::common_reference_t&lt;T, U&gt;(u2)}} if and only if {{tt|u1}} equals {{tt|u2}}.

In other words, the conversion to the common reference type must [[cpp/concepts#Equality preservation|preserve equality]].

===References===
{{ref std c++23}}
{{ref std|section=18.4.5|title=Concept {{tt|common_reference_with}}|id=concept.commonref}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=18.4.5|title=Concept {{tt|common_reference_with}}|id=concept.commonref}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc common_reference}}
{{dsc inc|cpp/concepts/dsc common_with}}
{{dsc inc|cpp/types/dsc common_type}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}