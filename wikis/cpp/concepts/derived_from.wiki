{{cpp/title|derived_from}}
{{cpp/concepts/navbar}}
{{ddcl|header=concepts|since=c++20|1=
template&lt; class Derived, class Base &gt;
concept derived_from =
    std::is_base_of_v&lt;Base, Derived&gt; &amp;&amp;
    std::is_convertible_v&lt;const volatile Derived*, const volatile Base*&gt;;
}}

The concept {{c|derived_from&lt;Derived, Base&gt;}} is satisfied if and only if {{tt|Base}} is a class type that is either {{tt|Derived}} or a public and unambiguous base of {{tt|Derived}}, ignoring cv-qualifiers.

Note that this behavior is different to {{tt|std::is_base_of}} when {{tt|Base}} is a private or protected base of {{tt|Derived}}.

===Example===
{{example
|code=
#include &lt;concepts&gt;

class A {};

class B : public A {};

class C : private A {};

// std::derived_from == true only for public inheritance or exact same class
static_assert(std::derived_from&lt;B, B&gt; == true);      // same class: true
static_assert(std::derived_from&lt;int, int&gt; == false); // same primitive type: false
static_assert(std::derived_from&lt;B, A&gt; == true);      // public inheritance: true
static_assert(std::derived_from&lt;C, A&gt; == false);     // private inheritance: false

// std::is_base_of == true also for private inheritance
static_assert(std::is_base_of_v&lt;B, B&gt; == true);      // same class: true
static_assert(std::is_base_of_v&lt;int, int&gt; == false); // same primitive type: false
static_assert(std::is_base_of_v&lt;A, B&gt; == true);      // public inheritance: true
static_assert(std::is_base_of_v&lt;A, C&gt; == true);      // private inheritance: true

int main() {}
}}

===References===
{{ref std c++23}}
{{ref std|section=18.4.3|title=Concept {{tt|derived_from}}|id=concept.derived}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=18.4.3|title=Concept {{tt|derived_from}}|id=concept.derived}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_base_of}}
{{dsc inc|cpp/types/dsc is_convertible}}
{{dsc end}}

{{langlinks|es|ja|zh|ru}}