{{cpp/title|assignable_from}}
{{cpp/concepts/navbar}}
{{ddcl|header=concepts|since=c++20|1=
template&lt; class LHS, class RHS &gt;
concept assignable_from =
    std::is_lvalue_reference_v&lt;LHS&gt; &amp;&amp;
    std::common_reference_with&lt;
        const std::remove_reference_t&lt;LHS&gt;&amp;,
        const std::remove_reference_t&lt;RHS&gt;&amp;&gt; &amp;&amp;
    requires(LHS lhs, RHS&amp;&amp; rhs) {
        { lhs = std::forward&lt;RHS&gt;(rhs) } -&gt; std::same_as&lt;LHS&gt;;
    };
}}
The concept {{tt|assignable_from&lt;LHS, RHS&gt;}} specifies that an expression of the type and value category specified by {{tt|RHS}} can be assigned to an lvalue expression whose type is specified by {{tt|LHS}}.

===Semantic requirements===
Given
* {{tt|lhs}}, an lvalue that refers to an object {{tt|lcopy}} such that {{c|decltype((lhs))}} is {{tt|LHS}},
* {{tt|rhs}}, an expression such that {{c|decltype((rhs))}} is {{tt|RHS}},
* {{tt|rcopy}}, a distinct object that is equal to {{tt|rhs}},
{{tt|assignable_from&lt;LHS, RHS&gt;}} is modeled only if
* {{c|1=std::addressof(lhs = rhs) == std::addressof(lcopy)}} (i.e., the assignment expression yields an lvalue referring to the left operand);
* After evaluating {{c|1=lhs = rhs}}:
**  {{tt|lhs}} is equal to {{tt|rcopy}}, unless {{tt|rhs}} is a non-const xvalue that refers to {{tt|lcopy}} (i.e., the assignment is a self-move-assignment),
** if {{tt|rhs}} is a glvalue:
*** If it is a non-const xvalue, the object to which it refers is in a valid but unspecified state;
*** Otherwise, the object it refers to is not modified;

{{cpp/concepts/equality preservation}}

===Notes===
Assignment need not be a total function. In particular, if assigning to some object {{tt|x}} can cause some other object {{tt|y}} to be modified, then {{c|1=x = y}} is likely not in the domain of {{ttb|1==}}. This typically happens if the right operand is owned directly or indirectly by the left operand (e.g., with smart pointers to nodes in a node-based data structure, or with something like {{c/core|std::vector&lt;std::any&gt;}}).

===Example===
{{example
|code=
#include &lt;atomic&gt;
#include &lt;concepts&gt;
#include &lt;string&gt;

int main()
{
    // Normal basic usage, checks lvalue reference assignment
    static_assert(std::is_assignable_v&lt;int&amp;, int&gt;);
    static_assert(std::assignable_from&lt;int&amp;, int&gt;);

    static_assert(std::is_assignable_v&lt;std::string&amp;, std::string&gt;);
    static_assert(std::assignable_from&lt;std::string&amp;, std::string&gt;);

    // Fundamental types don't support assignment to an rvalue
    static_assert(!std::is_assignable_v&lt;int, int&gt;);
    static_assert(!std::assignable_from&lt;int, int&gt;);

    // std::assignable_from doesn't accept all valid assignment expressions:

    // rvalue reference assignment
    static_assert(std::is_assignable_v&lt;std::string&amp;&amp;, std::string&gt;);
    static_assert(!std::assignable_from&lt;std::string&amp;&amp;, std::string&gt;);

    // rvalue assignment
    static_assert(std::is_assignable_v&lt;std::string, std::string&gt;);
    static_assert(!std::assignable_from&lt;std::string, std::string&gt;);

    // std::atomic::operator= returns by value
    static_assert(std::is_assignable_v&lt;std::atomic&lt;int&gt;&amp;, int&gt;);
    static_assert(!std::assignable_from&lt;std::atomic&lt;int&gt;&amp;, int&gt;);
}
}}

===References===
{{ref std c++23}}
{{ref std|section=18.4.8|title=Concept {{tt|assignable_from}}|id=concept.assignable}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=18.4.8|title=Concept {{tt|assignable_from}}|id=concept.assignable}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_assignable}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}