{{cpp/title|convertible_to}}
{{cpp/concepts/navbar}}
{{ddcl|header=concepts|since=c++20|1=
template&lt; class From, class To &gt;
concept convertible_to =
    std::is_convertible_v&lt;From, To&gt; &amp;&amp;
    requires {
        static_cast&lt;To&gt;(std::declval&lt;From&gt;());&lt;!--LWG 3557--&gt;
    };
}}

The concept {{c|convertible_to&lt;From, To&gt;}} specifies that an expression of the same type and value category as those of {{c|std::declval&lt;From&gt;()}} can be implicitly and explicitly converted to the type {{tt|To}}, and the two forms of conversion produce equal results.

===Semantic requirements===
{{c|convertible_to&lt;From, To&gt;}} is modeled only if, given a function {{tt|fun}} of type {{c|std::add_rvalue_reference_t&lt;From&gt;()}} such that the expression {{c|fun()}} is [[cpp/concepts#Equality preservation|equality-preserving]],
* Either 
** {{tt|To}} is neither an object type nor a reference-to-object type, or
** {{c|static_cast&lt;To&gt;(fun())}} is equal to {{c|[]() -&gt; To { return fun(); }()}}, and

* One of the following is true:
** {{c|std::add_rvalue_reference_t&lt;From&gt;}} is not a reference-to-object type, or
** {{c|std::add_rvalue_reference_t&lt;From&gt;}} is an rvalue reference to a non-const-qualified type, and the resulting state of the object referenced by {{c|fun()}} is valid but unspecified after either expression above; or
** the object referred to by {{c|fun()}} is not modified by either expression above.

{{cpp/concepts/equality_preservation}}

===References===
{{ref std c++23}}
{{ref std|section=18.4.4|title=Concept {{tt|convertible_to}}|id=concept.convertible}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=18.4.4|title=Concept {{tt|convertible_to}}|id=concept.convertible}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc is_convertible}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}