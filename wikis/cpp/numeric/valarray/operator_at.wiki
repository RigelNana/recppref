{{cpp/numeric/valarray/title|operator[]}}
{{cpp/numeric/valarray/navbar}}
{{dcl begin}}
{{dcl|num=1|1=
const T&amp;               operator[]( std::size_t pos ) const;
}}
{{dcl|num=2|1=
T&amp;                     operator[]( std::size_t pos );
}}
{{dcl|num=3|1=
std::valarray&lt;T&gt;       operator[]( std::slice slicearr ) const;
}}
{{dcl|num=4|1=
std::slice_array&lt;T&gt;    operator[]( std::slice slicearr );
}}
{{dcl|num=5|1=
std::valarray&lt;T&gt;       operator[]( const std::gslice&amp; gslicearr ) const;
}}
{{dcl|num=6|1=
std::gslice_array&lt;T&gt;   operator[]( const std::gslice&amp; gslicearr );
}}
{{dcl|num=7|1=
std::valarray&lt;T&gt;       operator[]( const std::valarray&lt;bool&gt;&amp; boolarr ) const;
}}
{{dcl|num=8|1=
std::mask_array&lt;T&gt;     operator[]( const std::valarray&lt;bool&gt;&amp; boolarr );
}}
{{dcl|num=9|1=
std::valarray&lt;T&gt;       operator[]( const std::valarray&lt;std::size_t&gt;&amp; indarr ) const;
}}
{{dcl|num=10|1=
std::indirect_array&lt;T&gt; operator[]( const std::valarray&lt;std::size_t&gt;&amp; indarr );
}}
{{dcl end}}

Retrieve single elements or portions of the array.

The {{c/core|const}} overloads that return element sequences create a new {{lc|std::valarray}} object.
The non-{{c/core|const}} overloads return classes holding references to the array elements.

The selected elements(s) must exist:
* for overloads {{v|1,2}}, if {{c|pos}} is not less than {{rlpt|size|size()}}, the behavior is undefined; and
* for overloads {{v|3-10}}, if the argument does not specify a valid subset of {{c|*this}}, the behavior is undefined.

===Parameters===
{{par begin}}
{{par|pos|position of the element to return}}
{{par|slicearr|{{rlp|slice}} of the elements to return}}
{{par|gslicearr|{{rlp|gslice}} of the elements to return}}
{{par|boolarr|mask of the elements to return}}
{{par|indarr|indices of the elements to return}}
{{par end}}

===Return value===
@1,2@ A reference to the corresponding element.
@3,5,7,9@ A {{lc|std::valarray}} object containing copies of the selected items.
@4,6,8,10@ The corresponding data structure containing references to the selected items.

{{cpp/impldef exception}}

===Notes===
For proper {{lc|std::valarray}} values {{c|a}}, {{c|b}} and proper {{lc|std::size_t}} values {{c|i}}, {{c|j}}, all of the following expressions always evaluate to {{c|true}}:
@1@ {{c|1=(a[i] = q, a[i]) == q}} for non-const {{c|a}}
@2@ {{c|1=&amp;a[i + j] == &amp;a[i] + j}} 
*This means that {{lc|std::valarray}} elements are adjacent in memory.
@3@ {{c|1=&amp;a[i] != &amp;b[j]}} for every objects {{c|a}} and {{c|b}} that are not aliases of one another
*This means that there are no aliases in the elements and this property can be used to perform some kinds of optimization.

References become invalid on {{rlpt|resize|resize()}} or when the array is destructed.

For overloads {{v|3,5,7,9}}, {{cpp/numeric/valarray/notes_ret}}

Slice/mask/indirect index accesses do not chain: {{c|1=v[v == n][std::slice(0, 5, 2)] = x;}} is an error because {{lc|std::mask_array}} (the type of {{c|1=v[v == n]}}) does not have {{c/core|operator[]}}.

===Example===
{{example
|code=
#include &lt;cstddef&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;valarray&gt;

int main() 
{
    std::valarray&lt;int&gt; data = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    std::cout &lt;&lt; "Initial valarray:   ";
    for (int n : data)
        std::cout &lt;&lt; std::setw(3) &lt;&lt; n;
    std::cout &lt;&lt; '\n';
    
    data[data &gt; 5] = -1; // valarray&lt;bool&gt; overload of operator[]
    // the type of data &gt; 5 is std::valarray&lt;bool&gt;
    // the type of data[data &gt; 5] is std::mask_array&lt;int&gt;
    
    std::cout &lt;&lt; "After v[v &gt; 5] = -1:";
    for (std::size_t n = 0; n &lt; data.size(); ++n) 
        std::cout &lt;&lt; std::setw(3) &lt;&lt; data[n]; // regular operator[]
    std::cout &lt;&lt; '\n';
}
|output=
Initial valarray:     0  1  2  3  4  5  6  7  8  9
After v[v &gt; 5] = -1:  0  1  2  3  4  5 -1 -1 -1 -1
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=389|std=C++98|before=the return type of overload {{v|1}} was {{tt|T}}|after=corrected to {{c/core|const T&amp;}}}}
{{dr list item|wg=lwg|dr=430|std=C++98|before=the behavior was unclear for overloads&lt;br&gt;{{v|3-10}} if an invalid subset is specified|after=the behavior is&lt;br&gt; undefined in this case}}
{{dr list end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}