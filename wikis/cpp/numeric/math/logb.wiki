{{cpp/title|logb|logbf|logbl}}
{{cpp/numeric/math/navbar}}
{{cpp/numeric/math/declarations
|family=logb
|param1=num
|constexpr_since=23
|desc=Extracts the value of the unbiased radix-independent exponent from the floating-point argument {{c|num}}, and returns it as a floating-point value.
}}

Formally, the unbiased exponent is the signed integral part of {{math|log{{su|b=r}}{{!}}num{{!}}}} (returned by this function as a floating-point value), for non-zero {{c|num}}, where {{c|r}} is {{c|std::numeric_limits&lt;T&gt;::radix}} and {{tt|T}} is the floating-point type of {{c|num}}. If {{c|num}} is subnormal, it is treated as though it was normalized.

===Parameters===
{{par begin}}
{{par|num|floating-point or integer value}}
{{par end}}

===Return value===
If no errors occur, the unbiased exponent of {{c|num}} is returned as a signed floating-point value.

If a domain error occurs, an implementation-defined value is returned.

If a pole error occurs, {{lc|HUGE_VAL|-HUGE_VAL}}, {{tt|-HUGE_VALF}}, or {{tt|-HUGE_VALL}} is returned.

===Error handling===
Errors are reported as specified in {{lc|math_errhandling}}.

Domain or range error may occur if {{c|num}} is zero.

If the implementation supports IEEE floating-point arithmetic (IEC 60559),
* If {{c|num}} is ±0, -∞ is returned and {{lc|FE_DIVBYZERO}} is raised.
* If {{c|num}} is ±∞, +∞ is returned.
* If {{c|num}} is NaN, NaN is returned.
* In all other cases, the result is exact ({{lc|FE_INEXACT}} is never raised) and [[cpp/numeric/fenv/FE_round|the current rounding mode]] is ignored.

===Notes===
[https://pubs.opengroup.org/onlinepubs/9699919799/functions/logb.html POSIX requires] that a pole error occurs if {{c|num}} is ±0.

The value of the exponent returned by {{tt|std::logb}} is always 1 less than the exponent returned by {{lc|std::frexp}} because of the different normalization requirements: for the exponent {{c|e}} returned by {{tt|std::logb}}, {{math|{{!}}num*r{{su|p=-e}}{{!}}}} is between {{c|1}} and {{c|r}} (typically between {{c|1}} and {{c|2}}), but for the exponent {{c|e}} returned by {{lc|std::frexp}}, {{math|{{!}}num*2{{su|p=-e}}{{!}}}} is between {{c|0.5}} and {{c|1}}.

{{cpp/numeric/math/additional integer overload note|logb}}

===Example===
{{example
|Compares different floating-point decomposition functions:
|code=
#include &lt;cfenv&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;
// #pragma STDC FENV_ACCESS ON

int main()
{
    double f = 123.45;
    std::cout &lt;&lt; "Given the number " &lt;&lt; f &lt;&lt; " or " &lt;&lt; std::hexfloat
              &lt;&lt; f &lt;&lt; std::defaultfloat &lt;&lt; " in hex,\n";
    
    double f3;
    double f2 = std::modf(f, &amp;f3);
    std::cout &lt;&lt; "modf() makes " &lt;&lt; f3 &lt;&lt; " + " &lt;&lt; f2 &lt;&lt; '\n';
    
    int i;
    f2 = std::frexp(f, &amp;i);
    std::cout &lt;&lt; "frexp() makes " &lt;&lt; f2 &lt;&lt; " * 2^" &lt;&lt; i &lt;&lt; '\n';
    
    i = std::ilogb(f);
    std::cout &lt;&lt; "logb()/ilogb() make " &lt;&lt; f / std::scalbn(1.0, i) &lt;&lt; " * "
              &lt;&lt; std::numeric_limits&lt;double&gt;::radix
              &lt;&lt; "^" &lt;&lt; std::ilogb(f) &lt;&lt; '\n';
    
    // error handling
    std::feclearexcept(FE_ALL_EXCEPT);
    
    std::cout &lt;&lt; "logb(0) = " &lt;&lt; std::logb(0) &lt;&lt; '\n';
    if (std::fetestexcept(FE_DIVBYZERO))
        std::cout &lt;&lt; "    FE_DIVBYZERO raised\n";
}
|p=true
|output=
Given the number 123.45 or 0x1.edccccccccccdp+6 in hex,
modf() makes 123 + 0.45
frexp() makes 0.964453 * 2^7
logb()/ilogb() make 1.92891 * 2^6
logb(0) = -Inf
    FE_DIVBYZERO raised
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc frexp}}
{{dsc inc|cpp/numeric/math/dsc ilogb}}
{{dsc inc|cpp/numeric/math/dsc scalbn}}
{{dsc see c|c/numeric/math/logb}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}