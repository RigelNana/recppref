{{cpp/title|fmod|fmodf|fmodl}}
{{cpp/numeric/math/navbar}}
{{cpp/numeric/math/declarations
|family=fmod
|param1=x
|param2=y
|constexpr_since=23
|desc=Computes the floating-point remainder of the division operation {{c|x / y}}.
}}

The floating-point remainder of the division operation {{c|x / y}} calculated by this function is exactly the value {{c|x - iquot * y}}, where {{c|iquot}} is {{c|x / y}} with its fractional part truncated.

The returned value has the same sign as {{c|x}} and is less than {{c|y}} in magnitude.

===Parameters===
{{par begin}}
{{par|x, y|floating-point or integer values}}
{{par end}}

===Return value===
If successful, returns the floating-point remainder of the division {{c|x / y}} as defined above.

If a domain error occurs, an implementation-defined value is returned (NaN where supported).

If a range error occurs due to underflow, the correct result (after rounding) is returned.

===Error handling===
Errors are reported as specified in {{lc|math_errhandling}}.

Domain error may occur if {{c|y}} is zero.

If the implementation supports IEEE floating-point arithmetic (IEC 60559),
* If {{c|x}} is ±0 and {{c|y}} is not zero, ±0 is returned.
* If {{c|x}} is ±∞ and {{c|y}} is not NaN, NaN is returned and {{lc|FE_INVALID}} is raised.
* If {{c|y}} is ±0 and {{c|x}} is not NaN, NaN is returned and {{lc|FE_INVALID}} is raised.
* If {{c|y}} is ±∞ and {{c|x}} is finite, {{c|x}} is returned. 
* If either argument is NaN, NaN is returned.

===Notes===
[https://pubs.opengroup.org/onlinepubs/9699919799/functions/fmod.html POSIX requires] that a domain error occurs if {{c|x}} is infinite or {{c|y}} is zero.

{{tt|std::fmod}}, but not {{lc|std::remainder}} is useful for doing silent wrapping of floating-point types to unsigned integer types: {{c|1=(0.0 &lt;= (y = std::fmod(std::rint(x), 65536.0)) ? y : 65536.0 + y)}} is in the range {{closed range|-0.0|65535.0}}, which corresponds to {{c/core|unsigned short}}, but {{c|std::remainder(std::rint(x), 65536.0}} is in the range {{closed range|-32767.0|+32768.0}}, which is outside of the range of {{c/core|signed short}}.

The {{c/core|double}} version of {{tt|std::fmod}} behaves as if implemented as follows:
{{source|1=
double fmod(double x, double y)
{
#pragma STDC FENV_ACCESS ON
    double result = std::remainder(std::fabs(x), y = std::fabs(y));
    if (std::signbit(result))
        result += y;
    return std::copysign(result, x);
}
}}

The expression {{c|x - std::trunc(x / y) * y}} may not equal {{c|std::fmod(x, y)}}, when the rounding of {{c|x / y}} to initialize the argument of {{lc|std::trunc}} loses too much precision (example: {{c|1=x = 30.508474576271183309}}, {{c|1=y = 6.1016949152542370172}}).

{{cpp/numeric/math/additional overload note|fmod}}

===Example===
{{example
|code=
#include &lt;cfenv&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
// #pragma STDC FENV_ACCESS ON

int main()
{
    std::cout &lt;&lt; "fmod(+5.1, +3.0) = " &lt;&lt; std::fmod(5.1, 3) &lt;&lt; '\n'
              &lt;&lt; "fmod(-5.1, +3.0) = " &lt;&lt; std::fmod(-5.1, 3) &lt;&lt; '\n'
              &lt;&lt; "fmod(+5.1, -3.0) = " &lt;&lt; std::fmod(5.1, -3) &lt;&lt; '\n'
              &lt;&lt; "fmod(-5.1, -3.0) = " &lt;&lt; std::fmod(-5.1, -3) &lt;&lt; '\n';
    
    // special values
    std::cout &lt;&lt; "fmod(+0.0, 1.0) = " &lt;&lt; std::fmod(0, 1) &lt;&lt; '\n'
              &lt;&lt; "fmod(-0.0, 1.0) = " &lt;&lt; std::fmod(-0.0, 1) &lt;&lt; '\n'
              &lt;&lt; "fmod(5.1, Inf) = " &lt;&lt; std::fmod(5.1, INFINITY) &lt;&lt; '\n';
    
    // error handling
    std::feclearexcept(FE_ALL_EXCEPT);
    std::cout &lt;&lt; "fmod(+5.1, 0) = " &lt;&lt; std::fmod(5.1, 0) &lt;&lt; '\n';
    if (std::fetestexcept(FE_INVALID))
        std::cout &lt;&lt; "    FE_INVALID raised\n";
}
|p=true
|output=
fmod(+5.1, +3.0) = 2.1
fmod(-5.1, +3.0) = -2.1
fmod(+5.1, -3.0) = 2.1
fmod(-5.1, -3.0) = -2.1
fmod(+0.0, 1.0) = 0
fmod(-0.0, 1.0) = -0
fmod(5.1, Inf) = 5.1
fmod(+5.1, 0) = -nan
    FE_INVALID raised
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc div}}
{{dsc inc|cpp/numeric/math/dsc remainder}}
{{dsc inc|cpp/numeric/math/dsc remquo}}
{{dsc see c|c/numeric/math/fmod}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|ko|pl|pt|ru|zh}}