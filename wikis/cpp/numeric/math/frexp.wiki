{{cpp/title|frexp|frexpf|frexpl}}
{{cpp/numeric/math/navbar}}
{{dcl begin}}
{{dcl header|cmath}}
{{dcl rev multi|num=1|dcl1=
float       frexp ( float num, int* exp );
double      frexp ( double num, int* exp );
long double frexp ( long double num, int* exp );
|since2=c++23|dcl2=
constexpr /* floating-point-type */
            frexp ( /* floating-point-type */ num, int* exp );
}}
{{dcl|num=2|since=c++11|notes={{mark constexpr since c++23}}|
float       frexpf( float num, int* exp );
}}
{{dcl|num=3|since=c++11|notes={{mark constexpr since c++23}}|
long double frexpl( long double num, int* exp );
}}
{{dcl h|[[#Notes|Additional overloads]] {{mark since c++11}}}}
{{dcl header|cmath}}
{{dcl|num=A|notes={{mark constexpr since c++23}}|
template&lt; class Integer &gt;
double      frexp ( Integer num, int* exp );
}}
{{dcl end}}

@1-3@ Decomposes given floating point value {{c|num}} into a normalized fraction and an integral exponent of two.{{rev inl|since=c++23| The library provides overloads of {{tt|std::frexp}} for all cv-unqualified floating-point types as the type of the parameter {{c|num}}.}}

{{rrev|since=c++11|
@A@ Additional overloads are provided for all integer types, which are treated as {{c/core|double}}.
}}

===Parameters===
{{par begin}}
{{par|num|floating-point or integer value}}
{{par|exp|pointer to integer value to store the exponent to}}
{{par end}}

===Return value===
If {{c|num}} is zero, returns zero and stores zero in {{c|*exp}}.

Otherwise (if {{c|num}} is not zero), if no errors occur, returns the value {{c|x}} in the range {{tt|(-1, -0.5], [0.5, 1)}} and stores an integer value in {{c|*exp}} such that {{math|1=x&amp;times;2{{su|p=(*exp)}}== num}}.

If the value to be stored in {{c|*exp}} is outside the range of {{c/core|int}}, the behavior is unspecified.

===Error handling===
This function is not subject to any errors specified in {{lc|math_errhandling}}.

If the implementation supports IEEE floating-point arithmetic (IEC 60559),
* If {{c|num}} is ±0, it is returned, unmodified, and {{c|0}} is stored in {{c|*exp}}.
* If {{c|num}} is ±∞, it is returned, and an unspecified value is stored in {{c|*exp}}.
* If {{c|num}} is NaN, NaN is returned, and an unspecified value is stored in {{c|*exp}}.
* No floating-point exceptions are raised.
* If {{lc|FLT_RADIX}} is 2 (or a power of 2), the returned value is exact, [[cpp/numeric/fenv/FE_round|the current rounding mode]] is ignored.

===Notes===
On a binary system (where {{lc|FLT_RADIX}} is {{c|2}}), {{tt|std::frexp}} may be implemented as 
{{source|1={
    *exp = (value == 0) ? 0 : (int)(1 + std::logb(value));
    return std::scalbn(value, -(*exp));
}
}}

The function {{tt|std::frexp}}, together with its dual, {{lc|std::ldexp}}, can be used to manipulate the representation of a floating-point number without direct bit manipulations.

{{cpp/numeric/math/additional integer overload note|frexp}}

===Example===
{{example
|Compares different floating-point decomposition functions:
|code=
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;

int main()
{
    double f = 123.45;
    std::cout &lt;&lt; "Given the number " &lt;&lt; f &lt;&lt; " or " &lt;&lt; std::hexfloat
              &lt;&lt; f &lt;&lt; std::defaultfloat &lt;&lt; " in hex,\n";
    
    double f3;
    double f2 = std::modf(f, &amp;f3);
    std::cout &lt;&lt; "modf() makes " &lt;&lt; f3 &lt;&lt; " + " &lt;&lt; f2 &lt;&lt; '\n';
    
    int i;
    f2 = std::frexp(f, &amp;i);
    std::cout &lt;&lt; "frexp() makes " &lt;&lt; f2 &lt;&lt; " * 2^" &lt;&lt; i &lt;&lt; '\n';
    
    i = std::ilogb(f);
    std::cout &lt;&lt; "logb()/ilogb() make " &lt;&lt; f / std::scalbn(1.0, i)
              &lt;&lt; " * " &lt;&lt; std::numeric_limits&lt;double&gt;::radix
              &lt;&lt; "^" &lt;&lt; std::ilogb(f) &lt;&lt; '\n';
}
|p=true
|output=
Given the number 123.45 or 0x1.edccccccccccdp+6 in hex,
modf() makes 123 + 0.45
frexp() makes 0.964453 * 2^7
logb()/ilogb() make 1.92891 * 2^6
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc ldexp}}
{{dsc inc|cpp/numeric/math/dsc logb}}
{{dsc inc|cpp/numeric/math/dsc ilogb}}
{{dsc inc|cpp/numeric/math/dsc modf}}
{{dsc see c|c/numeric/math/frexp}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|tr|zh}}