{{cpp/title|log1p|log1pf|log1pl}}
{{cpp/numeric/math/navbar}}
{{cpp/numeric/math/declarations
|family=log1p
|param1=num
|constexpr_since=26
|desc=Computes the {{enwiki|Natural logarithm|natural (base ''e'') logarithm}} of {{c|1 + num}}. This function is more precise than the expression {{c|std::log(1 + num)}} if {{c|num}} is close to zero.
}}

===Parameters===
{{par begin}}
{{par|num|floating-point or integer value}}
{{par end}}

===Return value===
If no errors occur {{math|ln(1+num)}} is returned.

If a domain error occurs, an implementation-defined value is returned (NaN where supported).

If a pole error occurs, {{lc|HUGE_VAL|-HUGE_VAL}}, {{tt|-HUGE_VALF}}, or {{tt|-HUGE_VALL}} is returned.

If a range error occurs due to underflow, the correct result (after rounding) is returned.

===Error handling===
Errors are reported as specified in {{lc|math_errhandling}}.

Domain error occurs if {{c|num}} is less than {{math|-1}}.

Pole error may occur if {{c|num}} is {{math|-1}}.

If the implementation supports IEEE floating-point arithmetic (IEC 60559),
* If the argument is ±0, it is returned unmodified.
* If the argument is -1, -∞ is returned and {{lc|FE_DIVBYZERO}} is raised.
* If the argument is less than -1, NaN is returned and {{lc|FE_INVALID}} is raised.
* If the argument is +∞, +∞ is returned.
* If the argument is NaN, NaN is returned.

===Notes===
The functions {{lc|std::expm1}} and {{tt|std::log1p}} are useful for financial calculations, for example, when calculating small daily interest rates: {{math|(1 + x){{su|p=n}} - 1}} can be expressed as {{c|std::expm1(n * std::log1p(x))}}. These functions also simplify writing accurate inverse hyperbolic functions.

{{cpp/numeric/math/additional integer overload note|log1p}}

===Example===
{{example
|code=
#include &lt;cerrno&gt;
#include &lt;cfenv&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
// #pragma STDC FENV_ACCESS ON

int main()
{
    std::cout &lt;&lt; "log1p(0) = " &lt;&lt; log1p(0) &lt;&lt; '\n'
              &lt;&lt; "Interest earned in 2 days on $100, compounded daily at 1%\n"
              &lt;&lt; "    on a 30/360 calendar = "
              &lt;&lt; 100 * expm1(2 * log1p(0.01 / 360)) &lt;&lt; '\n'
              &lt;&lt; "log(1+1e-16) = " &lt;&lt; std::log(1 + 1e-16)
              &lt;&lt; ", but log1p(1e-16) = " &lt;&lt; std::log1p(1e-16) &lt;&lt; '\n';
    
    // special values
    std::cout &lt;&lt; "log1p(-0) = " &lt;&lt; std::log1p(-0.0) &lt;&lt; '\n'
              &lt;&lt; "log1p(+Inf) = " &lt;&lt; std::log1p(INFINITY) &lt;&lt; '\n';
    
    // error handling
    errno = 0;
    std::feclearexcept(FE_ALL_EXCEPT);
    
    std::cout &lt;&lt; "log1p(-1) = " &lt;&lt; std::log1p(-1) &lt;&lt; '\n';
    
    if (errno == ERANGE)
        std::cout &lt;&lt; "    errno == ERANGE: " &lt;&lt; std::strerror(errno) &lt;&lt; '\n';
    if (std::fetestexcept(FE_DIVBYZERO))
        std::cout &lt;&lt; "    FE_DIVBYZERO raised\n";
}
|p=true
|output=
log1p(0) = 0
Interest earned in 2 days on $100, compounded daily at 1%
    on a 30/360 calendar = 0.00555563
log(1+1e-16) = 0, but log1p(1e-16) = 1e-16
log1p(-0) = -0
log1p(+Inf) = inf
log1p(-1) = -inf
    errno == ERANGE: Result too large
    FE_DIVBYZERO raised
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc log}}
{{dsc inc|cpp/numeric/math/dsc log10}}
{{dsc inc|cpp/numeric/math/dsc log2}}
{{dsc inc|cpp/numeric/math/dsc expm1}}
{{dsc see c|c/numeric/math/log1p}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}