{{cpp/title|modf|modff|modfl}}
{{cpp/numeric/math/navbar}}
{{dcl begin}}
{{dcl header|cmath}}
{{dcl rev multi|num=1|dcl1=
float       modf ( float num, float* iptr );
double      modf ( double num, double* iptr );
long double modf ( long double num, long double* iptr );
|since2=c++23|dcl2=
constexpr /* floating-point-type */
            modf ( /* floating-point-type */ num,
                   /* floating-point-type */* iptr );
}}
{{dcl|num=2|since=c++11|notes={{mark constexpr since c++23}}|
float       modff( float num, float* iptr );
}}
{{dcl|num=3|since=c++11|notes={{mark constexpr since c++23}}|
long double modfl( long double num, long double* iptr );
}}
{{dcl h|[[#Notes|Additional overloads]] {{mark since c++11}}}}
{{dcl header|cmath}}
{{dcl|num=A|notes={{mark constexpr since c++23}}|
template&lt; class Integer &gt;
double      modf ( Integer num, double* iptr );
}}
{{dcl end}}

@1-3@ Decomposes given floating point value {{c|num}} into integral and fractional parts, each having the same type and sign as {{c|num}}. The integral part (in floating-point format) is stored in the object pointed to by {{c|iptr}}.{{rev inl|since=c++23|  The library provides overloads of {{tt|std::modf}} for all cv-unqualified floating-point types as the type of the parameter {{c|num}} and the pointed-to type of {{c|iptr}}.}}

{{rrev|since=c++11|
@A@ Additional overloads are provided for all integer types, which are treated as {{c/core|double}}.
}}

===Parameters===
{{par begin}}
{{par|num|floating-point or integer value}}
{{par|iptr|pointer to floating-point value to store the integral part to}}
{{par end}}

===Return value===
If no errors occur, returns the fractional part of {{c|num}} with the same sign as {{c|num}}. The integral part is put into the value pointed to by {{c|iptr}}.

The sum of the returned value and the value stored in {{c|*iptr}} gives {{c|num}} (allowing for rounding).

===Error handling===
This function is not subject to any errors specified in {{lc|math_errhandling}}.

If the implementation supports IEEE floating-point arithmetic (IEC 60559),
* If {{c|num}} is ±0, ±0 is returned, and ±0 is stored in {{c|*iptr}}.
* If {{c|num}} is ±∞, ±0 is returned, and ±∞ is stored in {{c|*iptr}}.
* If {{c|num}} is NaN, NaN is returned, and NaN is stored in {{c|*iptr}}.
* The returned value is exact, [[cpp/numeric/fenv/FE_round|the current rounding mode]] is ignored.

===Notes===
This function behaves as if implemented as follows:
{{source|1=
double modf(double num, double* iptr)
{
#pragma STDC FENV_ACCESS ON
    int save_round = std::fegetround();
    std::fesetround(FE_TOWARDZERO);
    *iptr = std::nearbyint(num);
    std::fesetround(save_round);
    return std::copysign(std::isinf(num) ? 0.0 : num - (*iptr), num);
}
}}

{{cpp/numeric/math/additional integer overload note|modf}}

===Example===
{{example
|Compares different floating-point decomposition functions:
|code=
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;

int main()
{
    double f = 123.45;
    std::cout &lt;&lt; "Given the number " &lt;&lt; f &lt;&lt; " or " &lt;&lt; std::hexfloat
              &lt;&lt; f &lt;&lt; std::defaultfloat &lt;&lt; " in hex,\n";
    
    double f3;
    double f2 = std::modf(f, &amp;f3);
    std::cout &lt;&lt; "modf() makes " &lt;&lt; f3 &lt;&lt; " + " &lt;&lt; f2 &lt;&lt; '\n';
    
    int i;
    f2 = std::frexp(f, &amp;i);
    std::cout &lt;&lt; "frexp() makes " &lt;&lt; f2 &lt;&lt; " * 2^" &lt;&lt; i &lt;&lt; '\n';
    
    i = std::ilogb(f);
    std::cout &lt;&lt; "logb()/ilogb() make " &lt;&lt; f / std::scalbn(1.0, i) &lt;&lt; " * "
              &lt;&lt; std::numeric_limits&lt;double&gt;::radix
              &lt;&lt; "^" &lt;&lt; std::ilogb(f) &lt;&lt; '\n';
    
    // special values
    f2 = std::modf(-0.0, &amp;f3);
    std::cout &lt;&lt; "modf(-0) makes " &lt;&lt; f3 &lt;&lt; " + " &lt;&lt; f2 &lt;&lt; '\n';
    f2 = std::modf(-INFINITY, &amp;f3);
    std::cout &lt;&lt; "modf(-Inf) makes " &lt;&lt; f3 &lt;&lt; " + " &lt;&lt; f2 &lt;&lt; '\n';
}
|p=true
|output=
Given the number 123.45 or 0x1.edccccccccccdp+6 in hex,
modf() makes 123 + 0.45
frexp() makes 0.964453 * 2^7
logb()/ilogb() make 1.92891 * 2^6
modf(-0) makes -0 + -0
modf(-Inf) makes -INF + -0
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc trunc}}
{{dsc see c|c/numeric/math/modf}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|tr|zh}}