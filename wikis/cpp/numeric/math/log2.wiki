{{cpp/title|log2|log2f|log2l}}
{{cpp/numeric/math/navbar}}
{{cpp/numeric/math/declarations
|family=log2
|param1=num
|constexpr_since=26
|desc=Computes the {{enwiki|Binary logarithm|binary (base-''2'') logarithm}} of {{c|num}}.
}}

===Parameters===
{{par begin}}
{{par|num|floating-point or integer value}}
{{par end}}

===Return value===
If no errors occur, the base-''2'' logarithm of {{c|num}} ({{math|log{{su|b=2}}(num)}} or {{math|lb(num)}}) is returned.

If a domain error occurs, an implementation-defined value is returned (NaN where supported).

If a pole error occurs, {{lc|HUGE_VAL|-HUGE_VAL}}, {{tt|-HUGE_VALF}}, or {{tt|-HUGE_VALL}} is returned.

===Error handling===
Errors are reported as specified in {{lc|math_errhandling}}.

Domain error occurs if {{c|num}} is less than zero.

Pole error may occur if {{c|num}} is zero.

If the implementation supports IEEE floating-point arithmetic (IEC 60559),
* If the argument is ±0, -∞ is returned and {{lc|FE_DIVBYZERO}} is raised.
* If the argument is 1, +0 is returned.
* If the argument is negative, NaN is returned and {{lc|FE_INVALID}} is raised.
* If the argument is +∞, +∞ is returned.
* If the argument is NaN, NaN is returned.

===Notes===
For integer {{c|num}}, the binary logarithm can be interpreted as the zero-based index of the most significant 1 bit in the input.

{{cpp/numeric/math/additional integer overload note|log2}}

===Example===
{{example
|code=
#include &lt;cerrno&gt;
#include &lt;cfenv&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
// #pragma STDC FENV_ACCESS ON

int main()
{
    std::cout &lt;&lt; "log2(65536) = " &lt;&lt; std::log2(65536) &lt;&lt; '\n'
              &lt;&lt; "log2(0.125) = " &lt;&lt; std::log2(0.125) &lt;&lt; '\n'
              &lt;&lt; "log2(0x020f) = " &lt;&lt; std::log2(0x020f)
              &lt;&lt; " (highest set bit is in position 9)\n"
              &lt;&lt; "base-5 logarithm of 125 = "
              &lt;&lt; std::log2(125) / std::log2(5) &lt;&lt; '\n';

    // special values
    std::cout &lt;&lt; "log2(1) = " &lt;&lt; std::log2(1) &lt;&lt; '\n'
              &lt;&lt; "log2(+Inf) = " &lt;&lt; std::log2(INFINITY) &lt;&lt; '\n';

    // error handling
    errno = 0;
    std::feclearexcept(FE_ALL_EXCEPT);

    std::cout &lt;&lt; "log2(0) = " &lt;&lt; std::log2(0) &lt;&lt; '\n';

    if (errno == ERANGE)
        std::cout &lt;&lt; "    errno == ERANGE: " &lt;&lt; std::strerror(errno) &lt;&lt; '\n';
    if (std::fetestexcept(FE_DIVBYZERO))
        std::cout &lt;&lt; "    FE_DIVBYZERO raised\n";
}
|p=true
|output=
log2(65536) = 16
log2(0.125) = -3
log2(0x020f) = 9.04166 (highest set bit is in position 9)
base-5 logarithm of 125 = 3
log2(1) = 0
log2(+Inf) = inf
log2(0) = -inf
    errno == ERANGE: Numerical result out of range
    FE_DIVBYZERO raised
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc log}}
{{dsc inc|cpp/numeric/math/dsc log10}}
{{dsc inc|cpp/numeric/math/dsc log1p}}
{{dsc inc|cpp/numeric/math/dsc exp2}}
{{dsc see c|c/numeric/math/log2}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}