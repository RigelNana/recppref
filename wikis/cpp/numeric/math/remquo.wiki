{{cpp/title|remquo|remquof|remquol}}
{{cpp/numeric/math/navbar}}
{{dcl begin}}
{{dcl header|cmath}}
{{dcl rev multi|num=1|since1=c++11|dcl1=
float       remquo ( float x, float y, int* quo );
double      remquo ( double x, double y, int* quo );
long double remquo ( long double x, long double y, int* quo );
|since2=c++23|dcl2=
constexpr /* floating-point-type */
            remquo ( /* floating-point-type */ x,
                     /* floating-point-type */ y, int* quo );
}}
{{dcl|num=2|since=c++11|notes={{mark|constexpr since C++23}}|
float       remquof( float x, float y, int* quo );
}}
{{dcl|num=3|since=c++11|notes={{mark|constexpr since C++23}}|
long double remquol( long double x, long double y, int* quo );
}}
{{dcl h|[[#Notes|Additional overloads]]}}
{{dcl header|cmath}}
{{dcl|num=A|since=c++11|notes={{mark|constexpr since C++23}}|
template&lt; class Arithmetic1, class Arithmetic2 &gt;
/* common-floating-point-type */
    remquo( Arithmetic1 x, Arithmetic2 y, int* quo );
}}
{{dcl end}}

@1-3@ Computes the floating-point remainder of the division operation {{c|x / y}} as the {{lc|std::remainder()}} function does. Additionally, the sign and at least the three of the last bits of {{c|x / y}} will be stored in {{c|quo}}, sufficient to determine the octant of the result within a period.{{rev inl|since=c++23| The library provides overloads of {{tt|std::remquo}} for all cv-unqualified floating-point types as the type of the parameters {{c|x}} and {{c|y}}.}}
@A@ Additional overloads are provided for all other combinations of arithmetic types.

===Parameters===
{{par begin}}
{{par|x, y|floating-point or integer values}}
{{par|quo|pointer to {{c/core|int}} to store the sign and some bits of {{c|x / y}}}}
{{par end}}

===Return value===
If successful, returns the floating-point remainder of the division {{c|x / y}} as defined in {{lc|std::remainder}}, and stores, in {{c|*quo}}, the sign and at least three of the least significant bits of {{c|x / y}} (formally, stores a value whose sign is the sign of {{c|x / y}} and whose magnitude is congruent {{math|modulo 2{{su|p=n}}}} to the magnitude of the integral quotient of {{c|x / y}}, where {{c|n}} is an implementation-defined integer greater than or equal to {{c|3}}).

If {{c|y}} is zero, the value stored in {{c|*quo}} is unspecified.

If a domain error occurs, an implementation-defined value is returned (NaN where supported).

If a range error occurs due to underflow, the correct result is returned if subnormals are supported.

If {{c|y}} is zero, but the domain error does not occur, zero is returned.

===Error handling===
Errors are reported as specified in {{lc|math_errhandling}}.

Domain error may occur if {{c|y}} is zero.

If the implementation supports IEEE floating-point arithmetic (IEC 60559),
* The current [[cpp/numeric/fenv/FE_round|rounding mode]] has no effect.
* {{lc|FE_INEXACT}} is never raised.
* If {{c|x}} is ±∞ and {{c|y}} is not NaN, NaN is returned and {{lc|FE_INVALID}} is raised.
* If {{c|y}} is ±0 and {{c|x}} is not NaN, NaN is returned and {{lc|FE_INVALID}} is raised.
* If either {{c|x}} or {{c|y}} is NaN, NaN is returned.

===Notes===
[https://pubs.opengroup.org/onlinepubs/9699919799/functions/remquo.html POSIX requires] that a domain error occurs if {{c|x}} is infinite or {{c|y}} is zero.

This function is useful when implementing periodic functions with the period exactly representable as a floating-point value: when calculating {{math|sin(πx)}} for a very large {{c|x}}, calling {{lc|std::sin}} directly may result in a large error, but if the function argument is first reduced with {{tt|std::remquo}}, the low-order bits of the quotient may be used to determine the sign and the octant of the result within the period, while the remainder may be used to calculate the value with high precision. 

On some platforms this operation is supported by hardware (and, for example, on Intel CPUs, {{tt|FPREM1}} leaves exactly 3 bits of precision in the quotient when complete).

{{cpp/numeric/math/additional overload note|remquo}}

===Example===
{{example
|code=
#include &lt;cfenv&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;

#ifndef __GNUC__
#pragma STDC FENV_ACCESS ON
#endif

const double pi = std::acos(-1); // or std::numbers::pi since C++20

double cos_pi_x_naive(double x)
{
    return std::cos(pi * x);
}

// the period is 2, values are (0;0.5) positive, (0.5;1.5) negative, (1.5,2) positive
double cos_pi_x_smart(double x)
{
    int quadrant;
    double rem = std::remquo(x, 1, &amp;quadrant);
    quadrant = static_cast&lt;unsigned&gt;(quadrant) % 2; // The period is 2.
    return quadrant == 0 ?  std::cos(pi * rem)
                         : -std::cos(pi * rem);
}

int main()
{
    std::cout &lt;&lt; std::showpos
              &lt;&lt; "naive:\n"
              &lt;&lt; "  cos(pi * 0.25) = " &lt;&lt; cos_pi_x_naive(0.25) &lt;&lt; '\n'
              &lt;&lt; "  cos(pi * 1.25) = " &lt;&lt; cos_pi_x_naive(1.25) &lt;&lt; '\n'
              &lt;&lt; "  cos(pi * 2.25) = " &lt;&lt; cos_pi_x_naive(2.25) &lt;&lt; '\n'
              &lt;&lt; "smart:\n"
              &lt;&lt; "  cos(pi * 0.25) = " &lt;&lt; cos_pi_x_smart(0.25) &lt;&lt; '\n'
              &lt;&lt; "  cos(pi * 1.25) = " &lt;&lt; cos_pi_x_smart(1.25) &lt;&lt; '\n'
              &lt;&lt; "  cos(pi * 2.25) = " &lt;&lt; cos_pi_x_smart(2.25) &lt;&lt; '\n'
              &lt;&lt; "naive:\n"
              &lt;&lt; "  cos(pi * 1000000000000.25) = "
              &lt;&lt; cos_pi_x_naive(1000000000000.25) &lt;&lt; '\n'
              &lt;&lt; "  cos(pi * 1000000000001.25) = "
              &lt;&lt; cos_pi_x_naive(1000000000001.25) &lt;&lt; '\n'
              &lt;&lt; "smart:\n"
              &lt;&lt; "  cos(pi * 1000000000000.25) = "
              &lt;&lt; cos_pi_x_smart(1000000000000.25) &lt;&lt; '\n'
              &lt;&lt; "  cos(pi * 1000000000001.25) = "
              &lt;&lt; cos_pi_x_smart(1000000000001.25) &lt;&lt; '\n';
    
    // error handling
    std::feclearexcept(FE_ALL_EXCEPT);
    
    int quo;
    std::cout &lt;&lt; "remquo(+Inf, 1) = " &lt;&lt; std::remquo(INFINITY, 1, &amp;quo) &lt;&lt; '\n';
    if (fetestexcept(FE_INVALID))
        std::cout &lt;&lt; "  FE_INVALID raised\n";
}
|p=true
|output=
naive:
  cos(pi * 0.25) = +0.707107
  cos(pi * 1.25) = -0.707107
  cos(pi * 2.25) = +0.707107
smart:
  cos(pi * 0.25) = +0.707107
  cos(pi * 1.25) = -0.707107
  cos(pi * 2.25) = +0.707107
naive:
  cos(pi * 1000000000000.25) = +0.707123
  cos(pi * 1000000000001.25) = -0.707117
smart:
  cos(pi * 1000000000000.25) = +0.707107
  cos(pi * 1000000000001.25) = -0.707107
&lt;!--note: this is exact output from:
 * Intel C++ on Linux, Oracle and GNU C++ on Sparc,
 * IBM and GNU C++ compilers on a Power platform,
 * GNU C++ and Clang C++ on Linux
--&gt;
remquo(+Inf, 1) = -nan
  FE_INVALID raised
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc div}}
{{dsc inc|cpp/numeric/math/dsc fmod}}
{{dsc inc|cpp/numeric/math/dsc remainder}}
{{dsc see c|c/numeric/math/remquo}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}