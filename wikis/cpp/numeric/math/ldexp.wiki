{{cpp/title|ldexp|ldexpf|ldexpl}}
{{cpp/numeric/math/navbar}}
{{dcl begin}}
{{dcl header|cmath}}
{{dcl rev multi|num=1|dcl1=
float       ldexp ( float num, int exp );
double      ldexp ( double num, int exp );
long double ldexp ( long double num, int exp );
|since2=c++23|dcl2=
constexpr /* floating-point-type */
            ldexp ( /* floating-point-type */ num, int exp );
}}
{{dcl|num=2|since=c++11|notes={{mark constexpr since c++23}}|
float       ldexpf( float num, int exp );
}}
{{dcl|num=3|since=c++11|notes={{mark constexpr since c++23}}|
long double ldexpl( long double num, int exp );
}}
{{dcl h|[[#Notes|Additional overloads]] {{mark since c++11}}}}
{{dcl header|cmath}}
{{dcl|num=A|since=c++11|notes={{mark constexpr since c++23}}|
template&lt; class Integer &gt;
double      ldexp ( Integer num, int exp );
}}
{{dcl end}}

@1-3@ Multiplies a floating point value {{c|num}} by the number {{c|2}} raised to the {{c|exp}} power.{{rev inl|since=c++23| The library provides overloads of {{tt|std::ldexp}} for all cv-unqualified floating-point types as the type of the parameter {{c|num}}.}}

{{rrev|since=c++11|
@A@ Additional overloads are provided for all integer types, which are treated as {{c/core|double}}.
}}

===Parameters===
{{par begin}}
{{par|num|floating-point or integer value}}
{{par|exp|integer value}}
{{par end}}

===Return value===
If no errors occur, {{c|num}} multiplied by 2 to the power of {{c|exp}} ({{math|num&amp;times;2{{su|p=exp}}}}) is returned.

If a range error due to overflow occurs, {{lc|HUGE_VAL|±HUGE_VAL}}, {{tt|±HUGE_VALF}}, or {{tt|±HUGE_VALL}} is returned.

If a range error due to underflow occurs, the correct result (after rounding) is returned.

===Error handling===
Errors are reported as specified in {{lc|math_errhandling}}.

If the implementation supports IEEE floating-point arithmetic (IEC 60559),
* Unless a range error occurs, {{lc|FE_INEXACT}} is never raised (the result is exact).
* Unless a range error occurs, [[cpp/numeric/fenv/FE_round|the current rounding mode]] is ignored.
* If {{c|num}} is ±0, it is returned, unmodified.
* If {{c|num}} is ±∞, it is returned, unmodified.
* If {{c|exp}} is 0, then {{c|num}} is returned, unmodified.
* If {{c|num}} is NaN, NaN is returned.

===Notes===
On binary systems (where {{lc|FLT_RADIX}} is {{c|2}}), {{tt|std::ldexp}} is equivalent to {{lc|std::scalbn}}.

The function {{tt|std::ldexp}} ("load exponent"), together with its dual, {{lc|std::frexp}}, can be used to manipulate the representation of a floating-point number without direct bit manipulations.

On many implementations, {{tt|std::ldexp}} is less efficient than multiplication or division by a power of two using arithmetic operators.

{{cpp/numeric/math/additional integer overload note|ldexp}}

For exponentiation of 2 by a floating point exponent, {{lc|std::exp2}} can be used.

===Example===
{{example
|code=
#include &lt;cerrno&gt;
#include &lt;cfenv&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
// #pragma STDC FENV_ACCESS ON

int main()
{
    std::cout
        &lt;&lt; "ldexp(5, 3) = 5 * 8 = " &lt;&lt; std::ldexp(5, 3) &lt;&lt; '\n'
        &lt;&lt; "ldexp(7, -4) = 7 / 16 = " &lt;&lt; std::ldexp(7, -4) &lt;&lt; '\n'
        &lt;&lt; "ldexp(1, -1074) = " &lt;&lt; std::ldexp(1, -1074)
        &lt;&lt; " (minimum positive subnormal float64_t)\n"
        &lt;&lt; "ldexp(nextafter(1,0), 1024) = "
        &lt;&lt; std::ldexp(std::nextafter(1,0), 1024)
        &lt;&lt; " (largest finite float64_t)\n";
    
    // special values
    std::cout &lt;&lt; "ldexp(-0, 10) = " &lt;&lt; std::ldexp(-0.0, 10) &lt;&lt; '\n'
              &lt;&lt; "ldexp(-Inf, -1) = " &lt;&lt; std::ldexp(-INFINITY, -1) &lt;&lt; '\n';
    
    // error handling
    std::feclearexcept(FE_ALL_EXCEPT);
    errno = 0;
    const double inf = std::ldexp(1, 1024);
    const bool is_range_error = errno == ERANGE;
    
    std::cout &lt;&lt; "ldexp(1, 1024) = " &lt;&lt; inf &lt;&lt; '\n';
    if (is_range_error)
        std::cout &lt;&lt; "    errno == ERANGE: " &lt;&lt; std::strerror(ERANGE) &lt;&lt; '\n';
    if (std::fetestexcept(FE_OVERFLOW))
        std::cout &lt;&lt; "    FE_OVERFLOW raised\n";
}
|p=true
|output=
ldexp(5, 3) = 5 * 8 = 40
ldexp(7, -4) = 7 / 16 = 0.4375
ldexp(1, -1074) = 4.94066e-324 (minimum positive subnormal float64_t)
ldexp(nextafter(1,0), 1024) = 1.79769e+308 (largest finite float64_t)
ldexp(-0, 10) = -0
ldexp(-Inf, -1) = -inf
ldexp(1, 1024) = inf
    errno == ERANGE: Numerical result out of range
    FE_OVERFLOW raised
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/math/dsc frexp}}
{{dsc inc|cpp/numeric/math/dsc scalbn}}
{{dsc inc|cpp/numeric/math/dsc exp2}}
{{dsc see c|c/numeric/math/ldexp}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}