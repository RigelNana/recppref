{{title|Pseudo-random number generation}}
{{cpp/numeric/random/navbar}}

The random number library provides classes that generate random and pseudo-random numbers. These classes include:
* Uniform random bit generators (URBGs), which include both random number engines, which are pseudo-random number generators that generate integer sequences with a uniform distribution, and true random number generators (if available).
* Random number distributions (e.g. {{rl|uniform int distribution|uniform}}, {{rl|normal distribution|normal}}, or {{rl|poisson distribution}}s) which convert the output of URBGs into various statistical distributions.

URBGs and distributions are designed to be used together to produce random values. All of the random number engines may be specifically seeded, serialized, and de-serialized for use with repeatable simulators.

===Uniform random bit generators===
A ''uniform random bit generator'' is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability of being returned.

All uniform random bit generators meet the {{named req|UniformRandomBitGenerator}} requirements.
C++20 also defines a {{lconcept|uniform_random_bit_generator}} concept.

{{dsc begin}}
{{dsc header|random}}
{{dsc inc|cpp/numeric/random/dsc uniform_random_bit_generator}}
{{dsc end}}

===Random number engines===
A ''random number engine'' (commonly shortened to ''engine''{{sep}}) is a uniform random bit generator which generates pseudo-random numbers using seed data as entropy source.

At any given time, an engine {{c|e}} of type {{tt|E}} has a state {{box|e{{sub|{{tt|i}}}}}} for some non-negative integer {{c|i}}. Upon construction, {{c|e}} has an initial state {{box|e{{sub|{{tt|0}}}}}}, which is determined by engine parameters and an initial seed (or seed sequence).

The following properties are always defined for any engine type {{tt|E}}:
* The ''size'' of {{tt|E}}’s state in multiples of the size of {{tt|E::result_type}} (i.e. {{box|{{c/core|(sizeof e}}{{sub|{{tt|i}}}}{{c/core|) / sizeof(E::result_type)}}}}).
* The ''transition algorithm'' {{c|TA}} by which {{c|e}}’s state {{box|e{{sub|{{tt|i}}}}}} is advanced to its successor state {{box|e{{sub|{{tt|i+1}}}}}} (i.e. {{box|{{c/core|TA(e}}{{sub|{{tt|i}}}}{{c/core|1=) == e}}{{sub|{{tt|i+1}}}}}}).
* The ''generation algorithm'' {{c|GA}} by which {{c|e}}’s state is mapped to a value of type {{tt|E::result_type}}, the result is a pseudo-random number.

A pseudo-random number sequence can be generated by calling {{c|TA}} and {{c|GA}} alternatively.

The standard library provides the implementations of three different classes of pseudo-random number generation algorithms as class templates, so that the algorithms can be customized. The choice of which engine to use involves a number of trade-offs:
* The {{rl|linear congruential engine}} is moderately fast and has a very small storage requirement for state.
* The {{rl|mersenne twister engine|Mersenne twister engine}} is slower and has greater state storage requirements but with the right parameters has the longest non-repeating sequence with the most desirable spectral characteristics (for a given definition of desirable).
* The {{rl|subtract with carry engine}} is very fast even on processors without advanced arithmetic instruction sets, at the expense of greater state storage and sometimes less desirable spectral characteristics.
{{rrev|since=c++26|
* The {{rl|philox engine|Philox engine}} is a {{enwiki|counter-based random number generator}}. It has a small state and a long period (not less than 2^130) and is intended for use in Monte-Carlo simulations which require massively parallel random number generation. It is easily vectorized and parallelized and is implemented in GPU-optimized libraries.
}}

None of these random number engines are {{enwiki|Cryptographically secure pseudorandom number generator|cryptographically secure}}. As with any secure operation, a crypto library should be used for the purpose (e.g. [https://www.openssl.org/docs/manmaster/man3/RAND_bytes.html OpenSSL {{tt|RAND_bytes}}]).

All types instantiated from these templates meet the {{named req|RandomNumberEngine}} requirements.

{{dsc begin}}
{{dsc header|random}}
{{dsc inc|cpp/numeric/random/dsc linear_congruential_engine}}
{{dsc inc|cpp/numeric/random/dsc mersenne_twister_engine}}
{{dsc inc|cpp/numeric/random/dsc subtract_with_carry_engine}}
{{dsc inc|cpp/numeric/random/dsc philox_engine}}
{{dsc end}}

===Random number engine adaptors===
Random number engine adaptors generate pseudo-random numbers using another random number engine as entropy source. They are generally used to alter the spectral characteristics of the underlying engine.

{{dsc begin}}
{{dsc header|random}}
{{dsc inc|cpp/numeric/random/dsc discard_block_engine}}
{{dsc inc|cpp/numeric/random/dsc independent_bits_engine}}
{{dsc inc|cpp/numeric/random/dsc shuffle_order_engine}}
{{dsc end}}

===Predefined random number generators===
Several specific popular algorithms are predefined.

{{dsc begin}}
{{dsc header|random}}
{{dsc hitem|Type|Definition}}
{{dsc inc|cpp/numeric/random/dsc minstd_rand0}}
{{dsc inc|cpp/numeric/random/dsc minstd_rand}}
{{dsc inc|cpp/numeric/random/dsc mt19937}}
{{dsc inc|cpp/numeric/random/dsc mt19937_64}}
{{dsc inc|cpp/numeric/random/dsc ranlux24_base}}
{{dsc inc|cpp/numeric/random/dsc ranlux48_base}}
{{dsc inc|cpp/numeric/random/dsc ranlux24}}
{{dsc inc|cpp/numeric/random/dsc ranlux48}}
{{dsc inc|cpp/numeric/random/dsc knuth_b}}
{{dsc inc|cpp/numeric/random/dsc philox4x32}}
{{dsc inc|cpp/numeric/random/dsc philox4x64}}
{{dsc|{{tt|default_random_engine}} {{mark c++11}}|''implementation-defined''}}
{{dsc end}}

===Non-deterministic random numbers===
{{lc|std::random_device}} is a non-deterministic uniform random bit generator, although implementations are allowed to implement {{lc|std::random_device}} using a pseudo-random number engine if there is no support for non-deterministic random number generation.

{{dsc begin}}
{{dsc inc|cpp/numeric/random/dsc random_device}}
{{dsc end}}

===Random number distributions===
A random number distribution post-processes the output of a URBG in such a way that resulting output is distributed according to a defined statistical probability density function.

Random number distributions satisfy {{named req|RandomNumberDistribution}}.

{{dsc begin}}
{{dsc header|random}}

{{dsc h2|Uniform distributions}}
{{dsc inc|cpp/numeric/random/dsc uniform_int_distribution}}
{{dsc inc|cpp/numeric/random/dsc uniform_real_distribution}}

{{dsc h2|Bernoulli distributions}}
{{dsc inc|cpp/numeric/random/dsc bernoulli_distribution}}
{{dsc inc|cpp/numeric/random/dsc binomial_distribution}}
{{dsc inc|cpp/numeric/random/dsc negative_binomial_distribution}}
{{dsc inc|cpp/numeric/random/dsc geometric_distribution}}

{{dsc h2|Poisson distributions}}
{{dsc inc|cpp/numeric/random/dsc poisson_distribution}}
{{dsc inc|cpp/numeric/random/dsc exponential_distribution}}
{{dsc inc|cpp/numeric/random/dsc gamma_distribution}}
{{dsc inc|cpp/numeric/random/dsc weibull_distribution}}
{{dsc inc|cpp/numeric/random/dsc extreme_value_distribution}}

{{dsc h2|Normal distributions}}
{{dsc inc|cpp/numeric/random/dsc normal_distribution}}
{{dsc inc|cpp/numeric/random/dsc lognormal_distribution}}
{{dsc inc|cpp/numeric/random/dsc chi_squared_distribution}}
{{dsc inc|cpp/numeric/random/dsc cauchy_distribution}}
{{dsc inc|cpp/numeric/random/dsc fisher_f_distribution}}
{{dsc inc|cpp/numeric/random/dsc student_t_distribution}}

{{dsc h2|Sampling distributions}}
{{dsc inc|cpp/numeric/random/dsc discrete_distribution}}
{{dsc inc|cpp/numeric/random/dsc piecewise_constant_distribution}}
{{dsc inc|cpp/numeric/random/dsc piecewise_linear_distribution}}
{{dsc end}}

===Utilities===
{{dsc begin}}
{{dsc header|random}}
{{dsc inc|cpp/numeric/random/dsc generate_canonical}}
{{dsc inc|cpp/numeric/random/dsc seed_seq}}
{{dsc end}}

===Random number algorithms===
{{dsc begin}}
{{dsc header|random}}
{{dsc inc|cpp/algorithm/ranges/dsc generate_random}}
{{dsc end}}

===C random library===
In addition to the engines and distributions described above, the functions and constants from the C random library are also available though not recommended:

{{dsc begin}}
{{dsc header|cstdlib}}
{{dsc inc|cpp/numeric/random/dsc rand}}
{{dsc inc|cpp/numeric/random/dsc srand}}
{{dsc inc|cpp/numeric/random/dsc RAND_MAX}}
{{dsc end}}

===Example===
{{example
|code=
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;random&gt;
#include &lt;string&gt;

int main()
{
    // Seed with a real random value, if available
    std::random_device r;
    
    // Choose a random mean between 1 and 6
    std::default_random_engine e1(r());
    std::uniform_int_distribution&lt;int&gt; uniform_dist(1, 6);
    int mean = uniform_dist(e1);
    std::cout &lt;&lt; "Randomly-chosen mean: " &lt;&lt; mean &lt;&lt; '\n';
    
    // Generate a normal distribution around that mean
    std::seed_seq seed2{r(), r(), r(), r(), r(), r(), r(), r()};
    std::mt19937 e2(seed2);
    std::normal_distribution&lt;&gt; normal_dist(mean, 2);
    
    std::map&lt;int, int&gt; hist;
    for (int n = 0; n != 10000; ++n)
        ++hist[std::round(normal_dist(e2))];
    
    std::cout &lt;&lt; "Normal distribution around " &lt;&lt; mean &lt;&lt; ":\n"
              &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);
    for (auto [x, y] : hist)
        std::cout &lt;&lt; std::setw(2) &lt;&lt; x &lt;&lt; ' ' &lt;&lt; std::string(y / 200, '*') &lt;&lt; '\n';
}
|p=true
|output=
Randomly-chosen mean: 4
Normal distribution around 4:
-4
-3
-2
-1
 0 *
 1 ***
 2 ******
 3 ********
 4 *********
 5 ********
 6 ******
 7 ***
 8 *
 9
10
11
12
}}

===See also===
{{dsc begin}}
{{dsc see c|c/numeric/random|Pseudo-random number generation|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}