{{title|Floating-point environment {{mark since c++11}}}}
{{cpp/numeric/fenv/navbar}}

The floating-point environment is the set of floating-point status flags and control modes supported by the implementation. It is thread-local. Each thread inherits the initial state of its floating-point environment from the parent thread. Floating-point operations modify the floating-point status flags to indicate abnormal results or auxiliary information. The state of floating-point control modes affects the outcomes of some floating-point operations.

The floating-point environment access and modification is only meaningful when {{ltt|cpp/preprocessor/impl|#pragma STDC FENV_ACCESS}} is supported and is set to {{tt|ON}}. Otherwise the implementation is free to assume that floating-point control modes are always the default ones and that floating-point status flags are never tested or modified. In practice, few current compilers, such as HP aCC, Oracle Studio, or IBM XL, support the {{tt|#pragma}} explicitly, but most compilers allow meaningful access to the floating-point environment anyway.

===Types===
{{dsc begin}}
{{dsc header|cfenv}}
{{dsc inc|cpp/numeric/fenv/dsc fenv_t}}
{{dsc inc|cpp/numeric/fenv/dsc fexcept_t}}
{{dsc end}}

===Functions===
{{dsc begin}}
{{dsc inc|cpp/numeric/fenv/dsc feclearexcept}}
{{dsc inc|cpp/numeric/fenv/dsc fetestexcept}}
{{dsc inc|cpp/numeric/fenv/dsc feraiseexcept}}
{{dsc inc|cpp/numeric/fenv/dsc feexceptflag}}
{{dsc inc|cpp/numeric/fenv/dsc feround}}
{{dsc inc|cpp/numeric/fenv/dsc feenv}}
{{dsc inc|cpp/numeric/fenv/dsc feholdexcept}}
{{dsc inc|cpp/numeric/fenv/dsc feupdateenv}}
{{dsc end}}

===Macros===
{{dsc begin}}
{{dsc inc|cpp/numeric/fenv/dsc FE_exceptions}}
{{dsc inc|cpp/numeric/fenv/dsc FE_round}}
{{dsc inc|cpp/numeric/fenv/dsc FE_DFL_ENV}}
{{dsc end}}

===Notes===
The floating-point exceptions are not related to the C++ exceptions. When a floating-point operation raises a floating-point exception, the status of the floating-point environment changes, which can be tested with {{lc|std::fetestexcept}}, but the execution of a C++ program on most implementations continues uninterrupted.

There are compiler extensions that may be used to generate C++ exceptions automatically whenever a floating-point exception is raised:

* GNU libc function [https://www.gnu.org/savannah-checkouts/gnu/libc/manual/html_node/Control-Functions.html {{tt|feenableexcept()}}] enables trapping of the floating-point exceptions, which generates the signal {{tt|SIGFPE}}. If the compiler option {{tt|-fnon-call-exceptions}} was used, the handler for that signal may throw a user-defined C++ exception.
* MSVC function [https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/control87-controlfp-control87-2 {{tt|_control87()}}] enables trapping of the floating-point exceptions, which generates a hardware exception, which can be converted to C++ exceptions with [https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/set-se-translator {{tt|_set_se_translator}}].

===See also===
{{dsc begin}}
{{dsc see c|c/numeric/fenv|Floating-point environment}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}