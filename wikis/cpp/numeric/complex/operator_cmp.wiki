{{title|1=operator==,!={{dsc small|(std::complex)}}}}
{{cpp/numeric/complex/navbar}}
{{dcl begin}}
{{dcl header|complex}}
{{dcl rev multi|num=1|until1=c++14|dcl1=
template&lt; class T &gt;
bool operator==( const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs );
|dcl2=
template&lt; class T &gt;
constexpr bool operator==( const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs );
}}
{{dcl rev multi|num=2|until1=c++14|dcl1=
template&lt; class T &gt;
bool operator==( const complex&lt;T&gt;&amp; lhs, const T&amp; rhs );
|dcl2=
template&lt; class T &gt;
constexpr bool operator==( const complex&lt;T&gt;&amp; lhs, const T&amp; rhs );
}}
{{dcl rev multi|num=3|until1=c++14|dcl1=
template&lt; class T &gt;
bool operator==( const T&amp; lhs, const complex&lt;T&gt;&amp; rhs );
|until2=c++20|dcl2=
template&lt; class T &gt;
constexpr bool operator==( const T&amp; lhs, const complex&lt;T&gt;&amp; rhs );
}}
{{dcl rev multi|num=4|until1=c++14|dcl1=
template&lt; class T &gt;
bool operator!=( const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs );
|until2=c++20|dcl2=
template&lt; class T &gt;
constexpr bool operator!=( const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs );
}}
{{dcl rev multi|num=5|until1=c++14|dcl1=
template&lt; class T &gt;
bool operator!=( const complex&lt;T&gt;&amp; lhs, const T&amp; rhs );
|until2=c++20|dcl2=
template&lt; class T &gt;
constexpr bool operator!=( const complex&lt;T&gt;&amp; lhs, const T&amp; rhs );
}}
{{dcl rev multi|num=6|until1=c++14|dcl1=
template&lt; class T &gt;
bool operator!=( const T&amp; lhs, const complex&lt;T&gt;&amp; rhs );
|until2=c++20|dcl2=
template&lt; class T &gt;
constexpr bool operator!=( const T&amp; lhs, const complex&lt;T&gt;&amp; rhs );
}}
{{dcl end}}
Compares two complex numbers. Scalar arguments are treated as complex numbers with the real part equal to the argument and the imaginary part set to zero.

@1-3@ Compares {{c|lhs}} and {{c|rhs}} for equality.
@4-6@ Compares {{c|lhs}} and {{c|rhs}} for inequality.

{{rrev|since=c++20|
{{cpp/note synthesized eq}}
}}

===Parameters===
{{par begin}}
{{par|lhs, rhs|the arguments to compare: either both complex numbers or one complex and one scalar of matching type ({{c|float}}, {{c|double}}, {{c|long double}})}}
{{par end}}

===Return value===
@1-3@ {{c|true}} if respective parts of {{c|lhs}} are equal to {{c|rhs}}, {{c|false}} otherwise.
@4-6@ {{c|1=!(lhs == rhs)}}

===Example===
{{example|code=
#include &lt;complex&gt;

int main()
{
    using std::operator""i; // or: using namespace std::complex_literals;

    static_assert(1.0i == 1.0i);
    static_assert(2.0i != 1.0i);

    constexpr std::complex z(1.0, 0.0);
    static_assert(z == 1.0);
    static_assert(1.0 == z);
    static_assert(2.0 != z);
    static_assert(z != 2.0);
}
}}

{{langlinks|es|ja|ru|zh}}