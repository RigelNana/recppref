{{cpp/title|log{{petty|(std::complex)}}}}
{{cpp/numeric/complex/navbar}}
{{ddcl|header=complex|1=
template&lt; class T &gt;
std::complex&lt;T&gt; log( const std::complex&lt;T&gt;&amp; z );
}}

Computes complex {{enwiki|Natural logarithm|natural (base ''e'') logarithm}} of a complex value {{c|z}} with a branch cut along the negative real axis.

===Parameters===
{{par begin}}
{{par|z|complex value}}
{{par end}}

===Return value===
If no errors occur, the complex natural logarithm of {{c|z}} is returned, in the range of a strip in the interval {{math|[−iπ, +iπ]}} along the imaginary axis and mathematically unbounded along the real axis.

===Error handling and special values===
Errors are reported consistent with {{lc|math_errhandling}}.

If the implementation supports IEEE floating-point arithmetic,
* The function is continuous onto the branch cut taking into account the sign of imaginary part
* {{c|std::log(std::conj(z)) {{==}} std::conj(std::log(z))}}
* If {{c|z}} is {{tt|(-0,+0)}}, the result is {{tt|(-∞,π)}} and {{lc|FE_DIVBYZERO}} is raised
* If {{c|z}} is {{tt|(+0,+0)}}, the result is {{tt|(-∞,+0)}} and {{lc|FE_DIVBYZERO}} is raised
* If {{c|z}} is {{tt|(x,+∞)}} (for any finite x), the result is {{tt|(+∞,π/2)}}
* If {{c|z}} is {{tt|(x,NaN)}} (for any finite x), the result is {{tt|(NaN,NaN)}} and {{lc|FE_INVALID}} may be raised
* If {{c|z}} is {{tt|(-∞,y)}} (for any finite positive y), the result is {{tt|(+∞,π)}}
* If {{c|z}} is {{tt|(+∞,y)}} (for any finite positive y), the result is {{tt|(+∞,+0)}}
* If {{c|z}} is {{tt|(-∞,+∞)}}, the result is {{tt|(+∞,3π/4)}}
* If {{c|z}} is {{tt|(+∞,+∞)}}, the result is {{tt|(+∞,π/4)}}
* If {{c|z}} is {{tt|(±∞,NaN)}}, the result is {{tt|(+∞,NaN)}}
* If {{c|z}} is {{tt|(NaN,y)}} (for any finite y), the result is {{tt|(NaN,NaN)}} and {{lc|FE_INVALID}} may be raised
* If {{c|z}} is {{tt|(NaN,+∞)}}, the result is {{tt|(+∞,NaN)}}
* If {{c|z}} is {{tt|(NaN,NaN)}}, the result is {{tt|(NaN,NaN)}}

===Notes===
The natural logarithm of a complex number {{c|z}} with polar coordinate components {{math|(r,θ)}} equals {{math|ln r + i(θ+2nπ)}}, with the principal value {{math|ln r + iθ}}.

The semantics of this function are intended to be consistent with the C function {{ltt|c/numeric/complex/clog}}.

===Example===
{{example
|code=
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;

int main()
{
    std::complex&lt;double&gt; z {0.0, 1.0}; // r = 1, θ = pi / 2
    std::cout &lt;&lt; "2 * log" &lt;&lt; z &lt;&lt; " = " &lt;&lt; 2.0 * std::log(z) &lt;&lt; '\n';

    std::complex&lt;double&gt; z2 {sqrt(2.0) / 2, sqrt(2.0) / 2}; // r = 1, θ = pi / 4
    std::cout &lt;&lt; "4 * log" &lt;&lt; z2 &lt;&lt; " = " &lt;&lt; 4.0 * std::log(z2) &lt;&lt; '\n';

    std::complex&lt;double&gt; z3 {-1.0, 0.0}; // r = 1, θ = pi
    std::cout &lt;&lt; "log" &lt;&lt; z3 &lt;&lt; " = " &lt;&lt; std::log(z3) &lt;&lt; '\n';
    std::complex&lt;double&gt; z4 {-1.0, -0.0}; // the other side of the cut
    std::cout &lt;&lt; "log" &lt;&lt; z4 &lt;&lt; " (the other side of the cut) = " &lt;&lt; std::log(z4) &lt;&lt; '\n';
}
|p=true
|output=
2 * log(0,1) = (0,3.14159)
4 * log(0.707107,0.707107) = (0,3.14159)
log(-1,0) = (0,3.14159)
log(-1,-0) (the other side of the cut) = (0,-3.14159)
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2597|std=C++98|before=specification mishandles signed zero imaginary parts|after=erroneous requirement removed}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/complex/dsc log10}}
{{dsc inc|cpp/numeric/complex/dsc exp}}
{{dsc inc|cpp/numeric/math/dsc log}}
{{dsc inc|cpp/numeric/valarray/dsc log}}
{{dsc see c|c/numeric/complex/clog}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}