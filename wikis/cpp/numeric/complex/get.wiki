{{cpp/title|get{{petty|(std::complex)}}}}
{{cpp/numeric/complex/navbar}}
{{dcl begin}}
{{dcl header|complex}}
{{dcl|num=1|since=c++26|
template&lt; std::size_t I &gt;
friend constexpr T&amp; get( std::complex&lt;T&gt;&amp; x );
}}
{{dcl|num=2|since=c++26|
template&lt; std::size_t I &gt;
friend constexpr const T&amp; get( const std::complex&lt;T&gt;&amp; x );
}}
{{dcl|num=3|since=c++26|
template&lt; std::size_t I &gt;
friend constexpr T&amp;&amp; get( std::complex&lt;T&gt;&amp;&amp; x );
}}
{{dcl|num=4|since=c++26|
template&lt; std::size_t I &gt;
friend constexpr const T&amp;&amp; get( const std::complex&lt;T&gt;&amp;&amp; x );
}}
{{dcl end}}

Returns the reference to real or imaginary part from a {{tt|complex}} when {{c|1=I == 0}} or {{c|1=I == 1}}, respectively. It is mainly provided for structured binding support.

===Parameters===
{{par begin}}
{{par|x|a {{tt|complex}}}}
{{par end}}

===Return value===
@1-4@ A reference to the real or imaginary part from the stored one when {{c|1=I == 0}} or {{c|1=I == 1}}, respectively.

===Notes===
{{feature test macro|__cpp_lib_tuple_like|std=C++26|value=202311L|Add tuple protocol to {{lc|std::complex}}}}

===Example===
{{example
|code=
#include &lt;complex&gt;

static_assert([z = std::complex(1.0, 2.0)]
{
#if __cpp_lib_tuple_like &gt;= 202311L
    return std::get&lt;0&gt;(z) == 1.0 and std::get&lt;1&gt;(z) == 2.0;
#else
    return z.real() == 1.0 and z.imag() == 2.0;
#endif
}());

int main() {}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc structured binding}}
{{dsc inc|cpp/utility/tuple/dsc get}}
{{dsc inc|cpp/utility/pair/dsc get}}
{{dsc inc|cpp/container/array/dsc get}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}