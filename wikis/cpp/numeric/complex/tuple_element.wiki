{{cpp/title|tuple_element{{small|&lt;std::complex&gt;}}}}
{{cpp/numeric/complex/navbar}}
{{dcl begin}}
{{dcl header|complex}}
{{dcl|since=c++26|
template&lt; std::size_t I, class T &gt;
struct tuple_element&lt;I, std::complex&lt;T&gt;&gt;;
}}
{{dcl end}}

The partial specializations of {{ltt|cpp/utility/tuple_element|std::tuple_element}} for {{lc|std::complex}} provide compile-time access to the underlying real and imaginary number type of a {{tt|complex}}, using tuple-like syntax. They are provided for structured binding support. The program is ill-formed if {{c|1=I &gt;= 2}}.

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc|{{tt|type}}|{{tt|T}}}}
{{dsc end}}

===Notes===
{{feature test macro|__cpp_lib_tuple_like|std=C++26|value=202311L|Add tuple protocol to {{lc|std::complex}}}}

===Example===
{{example
|code=
#include &lt;complex&gt;
#include &lt;type_traits&gt;

static_assert([z = std::complex&lt;float&gt;()]
{
    using T = decltype(z);
    return
#if __cpp_lib_tuple_like &gt;= 202311L
        std::is_same_v&lt;std::tuple_element_t&lt;0, T&gt;, float&gt; &amp;&amp;
        std::is_same_v&lt;std::tuple_element_t&lt;1, T&gt;, float&gt; &amp;&amp;
#endif
        std::is_same_v&lt;T::value_type, float&gt;;
}());

int main() {}
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/language/dsc structured binding}}
{{dsc inc|cpp/utility/dsc tuple_element}}
{{dsc inc|cpp/numeric/complex/dsc tuple_size}}
{{dsc inc|cpp/numeric/complex/dsc get}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}