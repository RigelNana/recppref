{{cpp/title|pow{{petty|(std::complex)}}}}
{{cpp/numeric/complex/navbar}}
{{dcl begin}}
{{dcl header|complex}}
{{dcl|num=1|until=c++11|1=
template&lt; class T &gt;
std::complex&lt;T&gt; pow( const std::complex&lt;T&gt;&amp; x, int y );
}}
{{dcl|num=2|1=
template&lt; class T &gt;
std::complex&lt;T&gt; pow( const std::complex&lt;T&gt;&amp; x, const std::complex&lt;T&gt;&amp; y );
}}
{{dcl|num=3|1=
template&lt; class T &gt;
std::complex&lt;T&gt; pow( const std::complex&lt;T&gt;&amp; x, const T&amp; y );
}}
{{dcl|num=4|1=
template&lt; class T &gt;
std::complex&lt;T&gt; pow( const T&amp; x, const std::complex&lt;T&gt;&amp; y );
}}
{{dcl h|[[#Notes|Additional overloads]] {{mark since c++11}}}}
{{dcl header|complex}}
{{dcl rev multi|num=A|dcl1=
template&lt; class T1, class T2 &gt;
std::complex&lt;/* common-type */&gt;
    pow( const std::complex&lt;T1&gt;&amp; x, const std::complex&lt;T2&gt;&amp; y );
|since2=c++23|dcl2=
template&lt; class T1, class T2 &gt;
std::complex&lt;std::common_type_t&lt;T1, T2&gt;&gt;
    pow( const std::complex&lt;T1&gt;&amp; x, const std::complex&lt;T2&gt;&amp; y );
}}
{{dcl rev multi|num=B|dcl1=
template&lt; class T, class NonComplex &gt;
std::complex&lt;/* common-type */&gt;
    pow( const std::complex&lt;T&gt;&amp; x, const NonComplex&amp; y );
|since2=c++23|dcl2=
template&lt; class T, class NonComplex &gt;
std::complex&lt;std::common_type_t&lt;T, NonComplex&gt;&gt;
    pow( const std::complex&lt;T&gt;&amp; x, const NonComplex&amp; y );
}}
{{dcl rev multi|num=C|dcl1=
template&lt; class T, class NonComplex &gt;
std::complex&lt;/* common-type */&gt;
    pow( const NonComplex&amp; x, const std::complex&lt;T&gt;&amp; y );
|since2=c++23|dcl2=
template&lt; class T, class NonComplex &gt;
std::complex&lt;std::common_type_t&lt;T, NonComplex&gt;&gt;
    pow( const NonComplex&amp; x, const std::complex&lt;T&gt;&amp; y );
}}
{{dcl end}}

@1-4@ Computes complex {{c|x}} raised to a complex power {{c|y}} with a branch cut along the negative real axis for the first argument. Non-complex arguments are treated as complex numbers with positive zero imaginary component.

{{rrev|since=c++11|
@A-C@ Additional overloads are provided. {{tt|NonComplex}} is not a specialization of {{lc|std::complex}}.
}}

===Parameters===
{{par begin}}
{{par|x|base}}
{{par|y|exponent}}
{{par end}}

===Return value===
@1-4@ If no errors occur, the complex power {{math|x{{su|p=y}}}}, is returned.
@@ Errors and special cases are handled as if the operation is implemented by {{c|std::exp(y * std::log(x))}}.
@@ The result of {{c|std::pow(0, 0)}} is implementation-defined.
@A-C@ Same as {{v|2-4}}.

===Notes===
Overload {{v|1}} was provided in C++98 to match the extra overloads {{v|2}} of {{lc|std::pow}}. Those overloads were removed by the resolution of {{lwg|550}}, and overload {{v|1}} was removed by the resolution of {{lwg|844}}.

The additional overloads are not required to be provided exactly as {{v|A-C}}. They only need to be sufficient to ensure that for their first argument {{c|base}} and second argument {{c|exponent}}:
{{rev begin}}
{{rev|until=c++23|
If {{c|base}} and/or {{c|exponent}} has type {{c/core|std::complex&lt;T&gt;}}:
* If {{c|base}} and/or {{c|exponent}} has type {{c/core|std::complex&lt;long double&gt;}} or {{c/core|long double}}, then {{box|{{tt|std::pow(base, exponent)}}}} has the same effect as {{box|{{tt|std::pow}}{{c/core|(std::complex&lt;long double&gt;(base),}}&lt;br&gt;{{c/core|         std::complex&lt;long double&gt;(exponent))}}}}.
* Otherwise, if {{c|base}} and/or {{c|exponent}} has type {{c/core|std::complex&lt;double&gt;}}, {{c/core|double}}, or an integer type, then {{box|{{tt|std::pow(base, exponent)}}}} has the same effect as {{box|{{tt|std::pow}}{{c/core|(std::complex&lt;double&gt;(base),}}&lt;br&gt;{{c/core|         std::complex&lt;double&gt;(exponent))}}}}.
* Otherwise, if {{c|base}} and/or {{c|exponent}} has type {{c/core|std::complex&lt;float&gt;}} or {{c/core|float}}, then {{box|{{tt|std::pow(base, exponent)}}}} has the same effect as {{box|{{tt|std::pow}}{{c/core|(std::complex&lt;float&gt;(base),}}&lt;br&gt;{{c/core|         std::complex&lt;float&gt;(exponent))}}}}.
}}
{{rev|since=c++23|
If one argument has type {{c/core|std::complex&lt;T1&gt;}} and the other argument has type {{tt|T2}} or {{c/core|std::complex&lt;T2&gt;}}, then {{box|{{tt|std::pow(base, exponent)}}}} has the same effect as {{box|{{tt|std::pow}}{{c/core|(std::complex&lt;std::common_type_t&lt;T1, T2&gt;&gt;(base),
         std::complex&lt;std::common_type_t&lt;T1, T2&gt;&gt;(exponent))}}}}.

If {{c/core|std::common_type_t&lt;T1, T2&gt;}} is not well-formed, then the program is ill-formed.
}}
{{rev end}}

===Example===
{{example|
|code=
#include &lt;complex&gt;
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; std::fixed;
    
    std::complex&lt;double&gt; z(1.0, 2.0);
    std::cout &lt;&lt; "(1,2)^2 = " &lt;&lt; std::pow(z, 2) &lt;&lt; '\n';
    
    std::complex&lt;double&gt; z2(-1.0, 0.0); // square root of -1
    std::cout &lt;&lt; "-1^0.5 = " &lt;&lt; std::pow(z2, 0.5) &lt;&lt; '\n';
    
    std::complex&lt;double&gt; z3(-1.0, -0.0); // other side of the cut
    std::cout &lt;&lt; "(-1,-0)^0.5 = " &lt;&lt; std::pow(z3, 0.5) &lt;&lt; '\n';
    
    std::complex&lt;double&gt; i(0.0, 1.0); // i^i = exp(-pi / 2)
    std::cout &lt;&lt; "i^i = " &lt;&lt; std::pow(i, i) &lt;&lt; '\n';
}
|output=
(1,2)^2 = (-3.000000,4.000000)
-1^0.5 = (0.000000,1.000000)
(-1,-0)^0.5 = (0.000000,-1.000000)
i^i = (0.207880,0.000000)
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/complex/dsc sqrt}}
{{dsc inc|cpp/numeric/math/dsc pow}}
{{dsc inc|cpp/numeric/valarray/dsc pow}}
{{dsc see c|c/numeric/complex/cpow}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}