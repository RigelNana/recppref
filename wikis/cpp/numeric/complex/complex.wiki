{{cpp/numeric/complex/title|complex}}
{{cpp/numeric/complex/navbar}}
{{dcl begin}}
{{dcl h|Primary template ({{c/core|std::complex&lt;T&gt;}})}}
{{dcl rev begin|num=1}}
{{dcl|until=c++14|1=
complex( const T&amp; re = T(), const T&amp; im = T() );
}}
{{dcl|since=c++14|1=
constexpr complex( const T&amp; re = T(), const T&amp; im = T() );
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|until=c++14|
complex( const complex&amp; other );
}}
{{dcl|since=c++14|until=c++23|
constexpr complex( const complex&amp; other );
}}
{{dcl|since=c++23|1=
constexpr complex( const complex&amp; other ) = default;
}}
{{dcl rev end}}
{{dcl rev begin|num=3}}
{{dcl|until=c++14|
template&lt; class X &gt;
complex( const complex&lt;X&gt;&amp; other );
}}
{{dcl|since=c++14|until=c++23|
template&lt; class X &gt;
constexpr complex( const complex&lt;X&gt;&amp; other );
}}
{{dcl|since=c++23|
template&lt; class X &gt;
constexpr explicit(/* see below */) complex( const complex&lt;X&gt;&amp; other );
}}
{{dcl rev end}}

{{dcl h|Standard explicit specialization {{c/core|std::complex&lt;float&gt;}} {{mark until c++23}}}}
{{dcl rev begin|num=1}}
{{dcl|until=c++11|1=
complex( float re = 0.0f, float im = 0.0f );
}}
{{dcl|since=c++11|1=
constexpr complex( float re = 0.0f, float im = 0.0f );
}}
{{dcl rev end}}
{{dcl|num=2|since=c++20|1=
constexpr complex( const complex&lt;float&gt;&amp; other ) = default;
}}
{{dcl rev begin|num=3}}
{{dcl|until=c++11|
explicit complex( const complex&lt;double&gt;&amp; other );
explicit complex( const complex&lt;long double&gt;&amp; other );
}}
{{dcl|since=c++11|
constexpr explicit complex( const complex&lt;double&gt;&amp; other );
constexpr explicit complex( const complex&lt;long double&gt;&amp; other );
}}
{{dcl rev end}}

{{dcl h|Standard explicit specialization {{c/core|std::complex&lt;double&gt;}} {{mark until c++23}}}}
{{dcl rev begin|num=1}}
{{dcl|until=c++11|1=
complex( double re = 0.0, double im = 0.0 );
}}
{{dcl|since=c++11|1=
constexpr complex( double re = 0.0, double im = 0.0 );
}}
{{dcl rev end}}
{{dcl|num=2|since=c++20|1=
constexpr complex( const complex&lt;double&gt;&amp; other ) = default;
}}
{{dcl rev begin|num=3}}
{{dcl|until=c++11|
complex( const complex&lt;float&gt;&amp; other );
explicit complex( const complex&lt;long double&gt;&amp; other );
}}
{{dcl|since=c++11|
constexpr complex( const complex&lt;float&gt;&amp; other );
constexpr explicit complex( const complex&lt;long double&gt;&amp; other );
}}

{{dcl h|Standard explicit specialization {{c/core|std::complex&lt;long double&gt;}} {{mark until c++23}}}}
{{dcl rev begin|num=1}}
{{dcl|until=c++11|1=
complex( long double re = 0.0L, long double im = 0.0L );
}}
{{dcl|since=c++11|1=
constexpr complex( long double re = 0.0L, long double im = 0.0L );
}}
{{dcl rev end}}
{{dcl|num=2|since=c++20|1=
constexpr complex( const complex&lt;long double&gt;&amp; other ) = default;
}}
{{dcl rev begin|num=3}}
{{dcl|until=c++11|
complex( const complex&lt;float&gt;&amp; other );
complex( const complex&lt;double&gt;&amp; other );
}}
{{dcl|since=c++11|
constexpr complex( const complex&lt;float&gt;&amp; other );
constexpr complex( const complex&lt;double&gt;&amp; other );
}}
{{dcl end}}

Constructs the {{c/core|std::complex}} object.{{rev inl|until=c++23| The standard explicit specializations ({{c/core|std::complex&lt;float&gt;}}, {{c/core|std::complex&lt;double&gt;}} and {{c/core|std::complex&lt;long double&gt;}}) have different constructor declarations from the main template.}}

@1@ Constructs the complex number from real part {{c|re}} and imaginary part {{c|im}}.
@2@ Copy constructor. Constructs the object with the copy of the contents of {{c|other}}.{{rev inl|until=c++20| The copy constructors are implicitly declared in the standard explicit specializations.}}
@3@ [[cpp/language/converting constructor|Converting constructor]]. Constructs the object from a complex number of a different type.
{{rev begin}}
{{rev|until=c++23|
The main template provides a converting constructor template, while each standard explicit specialization provides two non-template constructors for the two other standard explicit specializations.

The non-template constructors are converting constructors (i.e. non-explicit) if and only if the conversions of the real and imaginary parts are not narrowing.
}}
{{rev|since=c++23|
For the main template, the expression inside {{c/core|explicit}} evaluates to {{c/core|false}} if and only if the [[cpp/language/usual arithmetic conversions#Floating-point conversion rank|floating-point conversion rank]] of {{tt|T}} is greater than or equal to the floating-point conversion rank of {{tt|X}}.
}}
{{rev end}}

===Parameters===
{{par begin}}
{{par|re|the real part}}
{{par|im|the imaginary part}}
{{par|other|another complex number to use as source}}
{{par end}}

===Notes===
Since C++23, the copy constructor is required to be [[cpp/language/copy constructor#Trivial copy constructor|trivial]] in order to satisfy the {{named req|TriviallyCopyable}} requirement, but implementations generally make it trivial in all modes.

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/complex/dsc operator{{=}}}}
{{dsc inc|cpp/numeric/dsc operator""i}}
{{dsc see c|c/numeric/complex/CMPLX}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}