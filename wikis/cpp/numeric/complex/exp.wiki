{{cpp/title|exp&lt;small&gt;(std::complex)&lt;/small&gt;}}
{{cpp/numeric/complex/navbar}}
{{ddcl|header=complex|1=
template&lt; class T &gt; 
std::complex&lt;T&gt; exp( const std::complex&lt;T&gt;&amp; z );
}}

Compute base-e exponential of {{c|z}}, that is ''e'' (Euler's number, {{tt|2.7182818}}) raised to the {{c|z}} power.

===Parameters===
{{par begin}}
{{par|z|complex value}}
{{par end}}

===Return value===
If no errors occur, ''e'' raised to the power of {{c|z}}, {{mathjax-or|\(\small e^z\)|e{{su|p=z}}}}, is returned.

===Error handling and special values===
Errors are reported consistent with {{lc|math_errhandling}}.

If the implementation supports IEEE floating-point arithmetic,
* {{c|std::exp(std::conj(z)) {{==}} std::conj(std::exp(z))}}
* If {{c|z}} is {{tt|(±0,+0)}}, the result is {{tt|(1,+0)}}
* If {{c|z}} is {{tt|(x,+∞)}} (for any finite x), the result is {{tt|(NaN,NaN)}} and {{lc|FE_INVALID}} is raised.
* If {{c|z}} is {{tt|(x,NaN)}} (for any finite x), the result is {{tt|(NaN,NaN)}} and {{lc|FE_INVALID}} may be raised.
* If {{c|z}} is {{tt|(+∞,+0)}}, the result is {{tt|(+∞,+0)}}
* If {{c|z}} is {{tt|(-∞,y)}} (for any finite y), the result is {{tt|+0cis(y)}}
* If {{c|z}} is {{tt|(+∞,y)}} (for any finite nonzero y), the result is {{tt|+∞cis(y)}}
* If {{c|z}} is {{tt|(-∞,+∞)}}, the result is {{tt|(±0,±0)}} (signs are unspecified)
* If {{c|z}} is {{tt|(+∞,+∞)}}, the result is {{tt|(±∞,NaN)}} and {{lc|FE_INVALID}} is raised (the sign of the real part is unspecified)
* If {{c|z}} is {{tt|(-∞,NaN)}}, the result is {{tt|(±0,±0)}} (signs are unspecified)
* If {{c|z}} is {{tt|(+∞,NaN)}}, the result is {{tt|(±∞,NaN)}} (the sign of the real part is unspecified)
* If {{c|z}} is {{tt|(NaN,+0)}}, the result is {{tt|(NaN,+0)}}
* If {{c|z}} is {{tt|(NaN,y)}} (for any nonzero y), the result is {{tt|(NaN,NaN)}} and {{lc|FE_INVALID}} may be raised
* If {{c|z}} is {{tt|(NaN,NaN)}}, the result is {{tt|(NaN,NaN)}}

where {{mathjax-or|\(\small{\rm cis}(y)\)|cis(y)}} is {{mathjax-or|\(\small \cos(y)+{\rm i}\sin(y)\)|cos(y) + i sin(y)}}.

===Notes===
The complex exponential function {{mathjax-or|\(\small e^z\)|e{{su|p=z}}}} for {{mathjax-or|1=\(\small z = x + {\rm i}y\)|2=z = x+iy}} equals {{mathjax-or|\(\small e^x {\rm cis}(y)\)|e{{su|p=x}} cis(y)}}, or, {{mathjax-or|\(\small e^x (\cos(y)+{\rm i}\sin(y))\)|e{{su|p=x}} (cos(y) + i sin(y))}}.

The exponential function is an ''entire function'' in the complex plane and has no branch cuts.
  
The following have equivalent results when the real part is 0:
* {{c|std::exp(std::complex&lt;float&gt;(0, theta))}}
* {{c|std::complex&lt;float&gt;(cosf(theta), sinf(theta))}}
* {{c|std::polar(1.f, theta)}}

In this case {{tt|exp}} can be about 4.5x slower. One of the other forms should be used instead of calling {{tt|exp}} with an argument whose real part is literal 0. There is no benefit in trying to avoid {{tt|exp}} with a runtime check of {{c|1=z.real() == 0}} though.

===Example===
{{example|code=
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;

int main()
{
   const double pi = std::acos(-1.0);
   const std::complex&lt;double&gt; i(0.0, 1.0);

   std::cout &lt;&lt; std::fixed &lt;&lt; " exp(i * pi) = " &lt;&lt; std::exp(i * pi) &lt;&lt; '\n';
}
|output=
exp(i * pi) = (-1.000000,0.000000)
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/complex/dsc log}}
{{dsc inc|cpp/numeric/math/dsc exp}}
{{dsc inc|cpp/numeric/valarray/dsc exp}}
{{dsc inc|cpp/numeric/complex/dsc polar}}
{{dsc see c|c/numeric/complex/cexp}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}