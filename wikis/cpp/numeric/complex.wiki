{{cpp/title|complex}}
{{cpp/numeric/complex/navbar}}
{{dcl begin}}
{{dcl header|complex}}
{{dcl|num=1|1=
template&lt; class T &gt;
class complex;
}}
{{dcl|num=2|until=c++23|
template&lt;&gt; class complex&lt;float&gt;;
}}
{{dcl|num=3|until=c++23|
template&lt;&gt; class complex&lt;double&gt;;
}}
{{dcl|num=4|until=c++23|
template&lt;&gt; class complex&lt;long double&gt;;
}}
{{dcl end}}

Specializations of {{tt|std::complex}} for cv-unqualified {{rev inl|until=c++23|standard}} {{lsd|cpp/language/types#Floating-point types}} are {{rev inl|since=c++23|{{named req|TriviallyCopyable}}}} {{named req|LiteralType}}s for representing and manipulating {{enwiki|complex number}}.

===Template parameters===
{{par begin}}
{{par|T|the type of the real and imaginary parts. The behavior is unspecified (and may fail to compile) if {{tt|T}} is not a cv-unqualified {{rev inl|until=c++23|standard}} floating-point type and undefined if {{tt|T}} is not {{named req|NumericType}}.}}
{{par end}}

===Member types===
{{dsc begin}}
{{dsc hitem|Member type|Definition}}
{{dsc|{{tt|value_type}}|{{tt|T}}}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/numeric/complex/dsc complex}}
{{dsc inc|cpp/numeric/complex/dsc operator{{=}}}}
{{dsc inc|cpp/numeric/complex/dsc real}}
{{dsc inc|cpp/numeric/complex/dsc imag}}
{{dsc inc|cpp/numeric/complex/dsc operator_arith}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/numeric/complex/dsc operator_arith2}}
{{dsc inc|cpp/numeric/complex/dsc operator_arith3}}
{{dsc inc|cpp/numeric/complex/dsc operator_cmp}}
{{dsc inc|cpp/numeric/complex/dsc operator_ltltgtgt}}
{{dsc inc|cpp/numeric/complex/dsc get}}
{{dsc inc|cpp/numeric/complex/dsc real2}}
{{dsc inc|cpp/numeric/complex/dsc imag2}}
{{dsc inc|cpp/numeric/complex/dsc abs}}
{{dsc inc|cpp/numeric/complex/dsc arg}}
{{dsc inc|cpp/numeric/complex/dsc norm}}
{{dsc inc|cpp/numeric/complex/dsc conj}}
{{dsc inc|cpp/numeric/complex/dsc proj}}
{{dsc inc|cpp/numeric/complex/dsc polar}}

{{dsc h2|Exponential functions}}
{{dsc inc|cpp/numeric/complex/dsc exp}}
{{dsc inc|cpp/numeric/complex/dsc log}}
{{dsc inc|cpp/numeric/complex/dsc log10}}

{{dsc h2|Power functions}}
{{dsc inc|cpp/numeric/complex/dsc pow}}
{{dsc inc|cpp/numeric/complex/dsc sqrt}}

{{dsc h2|Trigonometric functions}}
{{dsc inc|cpp/numeric/complex/dsc sin}}
{{dsc inc|cpp/numeric/complex/dsc cos}}
{{dsc inc|cpp/numeric/complex/dsc tan}}
{{dsc inc|cpp/numeric/complex/dsc asin}}
{{dsc inc|cpp/numeric/complex/dsc acos}}
{{dsc inc|cpp/numeric/complex/dsc atan}}

{{dsc h2|Hyperbolic functions}}
{{dsc inc|cpp/numeric/complex/dsc sinh}}
{{dsc inc|cpp/numeric/complex/dsc cosh}}
{{dsc inc|cpp/numeric/complex/dsc tanh}}
{{dsc inc|cpp/numeric/complex/dsc asinh}}
{{dsc inc|cpp/numeric/complex/dsc acosh}}
{{dsc inc|cpp/numeric/complex/dsc atanh}}
{{dsc end}}

===Helper types===
{{dsc begin}}
{{dsc inc|cpp/numeric/complex/dsc tuple_size}}
{{dsc inc|cpp/numeric/complex/dsc tuple_element}}
{{dsc end}}

===Array-oriented access===
For any object {{c|z}} of type {{tt|std::complex&lt;T&gt;}}, {{c|reinterpret_cast&lt;T(&amp;)[2]&gt;(z)[0]}} is the real part of {{c|z}} and {{c|reinterpret_cast&lt;T(&amp;)[2]&gt;(z)[1]}} is the imaginary part of {{c|z}}.

For any pointer to an element of an array of {{tt|std::complex&lt;T&gt;}} named {{c|p}} and any valid array index {{c|i}}, {{c|reinterpret_cast&lt;T*&gt;(p)[2 * i]}} is the real part of the complex number {{c|p[i]}}, and {{c|reinterpret_cast&lt;T*&gt;(p)[2 * i + 1]}} is the imaginary part of the complex number {{c|p[i]}}.

The intent of this requirement is to preserve binary compatibility between the C++ library complex number types and the [[c/language/arithmetic types#Complex floating types|C language complex number types]] (and arrays thereof), which have an identical object representation requirement.

===Implementation notes===
In order to satisfy the requirements of array-oriented access, an implementation is constrained to store the real and imaginary parts of a {{tt|std::complex}} specialization in separate and adjacent memory locations. Possible declarations for its non-static data members include:

* an array of type {{tt|value_type[2]}}, with the first element holding the real part and the second element holding the imaginary part (e.g. Microsoft Visual Studio);
* a single member of type {{tt|value_type _Complex}} (encapsulating the corresponding [[c/language/arithmetic types#Complex floating types|C language complex number type]]) (e.g. GNU libstdc++);
* two members of type {{tt|value_type}}, with the same member access, holding the real and the imaginary parts respectively (e.g. LLVM libc++).

An implementation cannot declare additional non-static data members that would occupy storage disjoint from the real and imaginary parts, and must ensure that the class template specialization does not contain any [[cpp/language/object#Object representation and value representation|padding bit]]. The implementation must also ensure that optimizations to array access account for the possibility that a pointer to {{tt|value_type}} may be aliasing a {{tt|std::complex}} specialization or array thereof.

===Literals===
{{dsc begin}}
{{dsc namespace|std::literals::complex_literals|inline=true}}
{{dsc inc|cpp/numeric/dsc operator""i}}
{{dsc end}}

===Notes===
{{ftm begin|sort=yes}}
{{ftm|__cpp_lib_constexpr_complex|rowspan="2"|std=C++20|value=201711L|{{c/core|constexpr}} simple complex mathematical functions in {{header|complex}}}}
{{ftm|-|More {{c/core|constexpr}} for {{header|complex}}|std=C++26|value=202306L}}
{{ftm|__cpp_lib_tuple_like|std=C++26|value=202311L|Add tuple protocol to {{tt|std::complex}}}}
{{ftm end}}

===Example===
{{example
|code=
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;

int main()
{
    using namespace std::complex_literals;
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);

    std::complex&lt;double&gt; z1 = 1i * 1i; // imaginary unit squared
    std::cout &lt;&lt; "i * i = " &lt;&lt; z1 &lt;&lt; '\n';

    std::complex&lt;double&gt; z2 = std::pow(1i, 2); // imaginary unit squared
    std::cout &lt;&lt; "pow(i, 2) = " &lt;&lt; z2 &lt;&lt; '\n';

    const double PI = std::acos(-1); // or std::numbers::pi in C++20
    std::complex&lt;double&gt; z3 = std::exp(1i * PI); // Euler's formula
    std::cout &lt;&lt; "exp(i * pi) = " &lt;&lt; z3 &lt;&lt; '\n';

    std::complex&lt;double&gt; z4 = 1.0 + 2i, z5 = 1.0 - 2i; // conjugates
    std::cout &lt;&lt; "(1 + 2i) * (1 - 2i) = " &lt;&lt; z4 * z5 &lt;&lt; '\n';

    const auto zz = {0.0 + 1i, 2.0 + 3i, 4.0 + 5i};
#if __cpp_lib_tuple_like &gt;= 202311L
    for (double re : zz {{!}} std::views::keys)
        std::cout &lt;&lt; re &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
    for (double im : zz {{!}} std::views::values)
        std::cout &lt;&lt; im &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
#else
    for (double re : zz {{!}} std::views::transform([](auto z){ return z.real(); }))
        std::cout &lt;&lt; re &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
    for (double im : zz {{!}} std::views::transform([](auto z){ return z.imag(); }))
        std::cout &lt;&lt; im &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
#endif
}
|output=
i * i = (-1.0,0.0)
pow(i, 2) = (-1.0,0.0)
exp(i * pi) = (-1.0,0.0)
(1 + 2i) * (1 - 2i) = (5.0,0.0)
0.0 2.0 4.0
1.0 3.0 5.0
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=387|std=C++98|before={{tt|std::complex}} was not guaranteed to be compatible with C {{tt|complex}}|after=guaranteed to be compatible}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc see c|c/numeric/complex|Complex number arithmetic|nomono=true}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}