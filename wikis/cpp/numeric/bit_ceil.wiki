{{cpp/title|bit_ceil}}
{{cpp/utility/bit/navbar}}
{{ddcl|since=c++20|header=bit|
template&lt; class T &gt;
constexpr T bit_ceil( T x );
}}

Calculates the smallest integral power of two that is not smaller than {{c|x}}.

If that value is not representable in {{tt|T}}, the behavior is undefined. Call to this function is permitted in [[cpp/language/constant expression|constant evaluation]] only if the undefined behavior does not occur.

{{cpp/enable_if|{{tt|T}} is an unsigned integer type (that is, {{c/core|unsigned char}}, {{c/core|unsigned short}}, {{c/core|unsigned int}}, {{c/core|unsigned long}}, {{c/core|unsigned long long}}, or an extended unsigned integer type)}}.

===Parameters===
{{par begin}}
{{par|x|value of unsigned integer type}}
{{par end}}

===Return value===
The smallest integral power of two that is not smaller than {{c|x}}.

===Exceptions===
Throws nothing.

===Notes===
{{petty|Prior to {{stddoc|P1956R1}}, the proposed name for this function template was {{tt|ceil2}}.}}

{{feature test macro|__cpp_lib_int_pow2|std=C++20|value=202002L|[[cpp/numeric#Bit manipulation (since C++20)|Integral power-of-2 operations]]}}

===Possible implementation===
See possible implementations in [https://github.com/gcc-mirror/gcc/blob/62c25d7adb1a5664982449dda0e7f9ca63cf4735/libstdc%2B%2B-v3/include/std/bit#L217-L248 libstdc++ (gcc)] and [https://github.com/llvm/llvm-project/blob/llvmorg-14.0.4/libcxx/include/bit#L304-L321 libc++ (clang)].
{{eq fun|1=
template&lt;std::unsigned_integral T&gt;
    requires !std::same_as&lt;T, bool&gt; &amp;&amp; !std::same_as&lt;T, char&gt; &amp;&amp;
             !std::same_as&lt;T, char8_t&gt; &amp;&amp; !std::same_as&lt;T, char16_t&gt; &amp;&amp;
             !std::same_as&lt;T, char32_t&gt; &amp;&amp; !std::same_as&lt;T, wchar_t&gt;
constexpr T bit_ceil(T x) noexcept
{
    if (x &lt;= 1u)
        return T(1);
    if constexpr (std::same_as&lt;T, decltype(+x)&gt;)
        return T(1) &lt;&lt; std::bit_width(T(x - 1));
    else
    {   // for types subject to integral promotion
        constexpr int offset_for_ub =
            std::numeric_limits&lt;unsigned&gt;::digits - std::numeric_limits&lt;T&gt;::digits;
        return T(1u &lt;&lt; (std::bit_width(T(x - 1)) + offset_for_ub) &gt;&gt; offset_for_ub);
    }
}
}}

===Example===
{{example
|code=
#include &lt;bit&gt;
#include &lt;bitset&gt;
#include &lt;iostream&gt;

int main()
{
    using bin = std::bitset&lt;8&gt;;
    for (auto x{0U}; 0XA != x; ++x)
        std::cout &lt;&lt; "bit_ceil( " &lt;&lt; bin(x) &lt;&lt; " ) = "
                  &lt;&lt; bin(std::bit_ceil(x)) &lt;&lt; '\n';
}
|output=
bit_ceil( 00000000 ) = 00000001
bit_ceil( 00000001 ) = 00000001
bit_ceil( 00000010 ) = 00000010
bit_ceil( 00000011 ) = 00000100
bit_ceil( 00000100 ) = 00000100
bit_ceil( 00000101 ) = 00001000
bit_ceil( 00000110 ) = 00001000
bit_ceil( 00000111 ) = 00001000
bit_ceil( 00001000 ) = 00001000
bit_ceil( 00001001 ) = 00010000
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/dsc bit_floor}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}