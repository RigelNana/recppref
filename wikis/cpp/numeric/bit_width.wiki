{{cpp/title|bit_width}}
{{cpp/utility/bit/navbar}}
{{ddcl|since=c++20|header=bit|
template&lt; class T &gt;
constexpr int bit_width( T x ) noexcept;
}}

If {{c|x}} is not zero, calculates the number of bits needed to store the value {{c|x}}, that is, {{mathjax-or|1=\(1 + \lfloor \log_2(x) \rfloor\)|2=1 + floor(log{{su|b=2}}(x))}}. If {{c|x}} is zero, returns zero.

{{cpp/enable_if|{{tt|T}} is an unsigned integer type (that is, {{c/core|unsigned char}}, {{c/core|unsigned short}}, {{c/core|unsigned int}}, {{c/core|unsigned long}}, {{c/core|unsigned long long}}, or an extended unsigned integer type)}}.

===Parameters===
{{par begin}}
{{par|x|unsigned integer value}}
{{par end}}

===Return value===
Zero if {{c|x}} is zero; otherwise, one plus the base-2 logarithm of {{c|x}}, with any fractional part discarded.

===Notes===
This function is equivalent to {{c|return std::numeric_limits&lt;T&gt;::digits - std::countl_zero(x);}}.

{{feature test macro|__cpp_lib_int_pow2|std=C++20|value=202002L|[[cpp/numeric#Bit manipulation (since C++20)|Integral power-of-2 operations]]}}

===Example===
{{example
|code=
#include &lt;bit&gt;
#include &lt;bitset&gt;
#include &lt;iostream&gt;

int main()
{
    for (unsigned x{}; x != 010; ++x)
        std::cout &lt;&lt; "bit_width( "
                  &lt;&lt; std::bitset&lt;4&gt;{x} &lt;&lt; " ) = "
                  &lt;&lt; std::bit_width(x) &lt;&lt; '\n';
}
|output=
bit_width( 0000 ) = 0
bit_width( 0001 ) = 1
bit_width( 0010 ) = 2
bit_width( 0011 ) = 2
bit_width( 0100 ) = 3
bit_width( 0101 ) = 3
bit_width( 0110 ) = 3
bit_width( 0111 ) = 3
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3656|std=C++20|before=the return type of {{tt|bit_width}} is the same as the type of its function argument|after=made it {{c/core|int}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/dsc countl_zero}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}