{{cpp/title|lerp}}
{{cpp/numeric/navbar}}
{{dcl begin}}
{{dcl header|cmath}}
{{dcl rev multi|num=1|since1=c++20|dcl1=
constexpr float       lerp( float a, float b, float t ) noexcept;
constexpr double      lerp( double a, double b, double t ) noexcept;
constexpr long double lerp( long double a, long double b,
                            long double t ) noexcept;
|since2=c++23|dcl2=
constexpr /* floating-point-type */
    lerp( /* floating-point-type */ a,
          /* floating-point-type */ b,
          /* floating-point-type */ t ) noexcept;
}}
{{dcl h|[[#Notes|Additional overloads]]}}
{{dcl header|cmath}}
{{dcl|num=A|since=c++20|
template&lt; class Arithmetic1, class Arithmetic2, class Arithmetic3 &gt;
constexpr /* common-floating-point-type */
    lerp( Arithmetic1 a, Arithmetic2 b, Arithmetic3 t ) noexcept;
}}
{{dcl end}}

@1@ Computes the {{enwiki|Linear interpolation|linear interpolation}} between {{c|a}} and {{c|b}}, if the parameter {{c|t}} is inside {{range|0|1}} (the {{enwiki|Extrapolation#Linear|linear extrapolation}} otherwise), i.e. the result of {{mathjax-or|\(a+t(b−a)\)|a+t(b−a)}} with accounting for floating-point calculation imprecision.{{rev inl|since=c++23| The library provides overloads for all cv-unqualified floating-point types as the type of the parameters {{c|a}}, {{c|b}} and {{c|t}}.}}
@A@ Additional overloads are provided for all other combinations of arithmetic types.

===Parameters===
{{par begin}}
{{par|a, b, t|floating-point or integer values}}
{{par end}}

===Return value===
{{mathjax-or|\(a + t(b − a)\)|a + t(b − a)}}

When {{c|std::isfinite(a) &amp;&amp; std::isfinite(b)}} is {{c|true}}, the following properties are guaranteed:
* If {{c|1=t == 0}}, the result is equal to {{c|a}}.
* If {{c|1=t == 1}}, the result is equal to {{c|b}}.
* If {{c|1=t &gt;= 0 &amp;&amp; t &lt;= 1}}, the result is finite.
* If {{c|1=std::isfinite(t) &amp;&amp; a == b}}, the result is equal to {{c|a}}.
* If {{c|1=std::isfinite(t) {{!!}} (b - a != 0 &amp;&amp; std::isinf(t))}}, the result is not {{ltt|cpp/numeric/math/NAN|NaN}}.

Let {{c|CMP(x, y)}} be {{c|1}} if {{c|x &gt; y}}, {{c|-1}} if {{c|x &lt; y}}, and {{c|0}} otherwise. For any {{c|t1}} and {{c|t2}}, the product of
* {{c|CMP(std::lerp(a, b, t2), std::lerp(a, b, t1))}},
* {{c|CMP(t2, t1)}}, and
* {{c|CMP(b, a)}}
is non-negative. (That is, {{tt|std::lerp}} is monotonic.)

===Notes===
{{cpp/numeric/math/additional overload note|lerp}}

{{feature_test_macro|__cpp_lib_interpolate|value=201902L|std=C++20|{{tt|std::lerp}}, {{lc|std::midpoint}}}}

===Example===
{{example
|code=
#include &lt;cassert&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;

float naive_lerp(float a, float b, float t)
{
    return a + t * (b - a);
}

int main()
{
    std::cout &lt;&lt; std::boolalpha;
    
    const float a = 1e8f, b = 1.0f;
    const float midpoint = std::lerp(a, b, 0.5f);
    
    std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; ", " &lt;&lt; "b = " &lt;&lt; b &lt;&lt; '\n'
              &lt;&lt; "midpoint = " &lt;&lt; midpoint &lt;&lt; '\n';
    
    std::cout &lt;&lt; "std::lerp is exact: "
              &lt;&lt; (a == std::lerp(a, b, 0.0f)) &lt;&lt; ' '
              &lt;&lt; (b == std::lerp(a, b, 1.0f)) &lt;&lt; '\n';
    
    std::cout &lt;&lt; "naive_lerp is exact: "
              &lt;&lt; (a == naive_lerp(a, b, 0.0f)) &lt;&lt; ' '
              &lt;&lt; (b == naive_lerp(a, b, 1.0f)) &lt;&lt; '\n';
    
    std::cout &lt;&lt; "std::lerp(a, b, 1.0f) = " &lt;&lt; std::lerp(a, b, 1.0f) &lt;&lt; '\n'
              &lt;&lt; "naive_lerp(a, b, 1.0f) = " &lt;&lt; naive_lerp(a, b, 1.0f) &lt;&lt; '\n';
    
    assert(not std::isnan(std::lerp(a, b, INFINITY))); // lerp here can be -inf
    
    std::cout &lt;&lt; "Extrapolation demo, given std::lerp(5, 10, t):\n";
    for (auto t{-2.0}; t &lt;= 2.0; t += 0.5)
        std::cout &lt;&lt; std::lerp(5.0, 10.0, t) &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|p=true
|output=
a = 1e+08, b = 1
midpoint = 5e+07
std::lerp is exact?: true true
naive_lerp is exact?: true false
std::lerp(a, b, 1.0f) = 1
naive_lerp(a, b, 1.0f) = 0
Extrapolation demo, given std::lerp(5, 10, t):
-5 -2.5 0 2.5 5 7.5 10 12.5 15
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/dsc midpoint}}
{{dsc end}}

{{langlinks|es|ja|zh}}