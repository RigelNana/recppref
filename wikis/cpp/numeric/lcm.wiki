{{cpp/title|lcm}}
{{cpp/numeric/navbar}}
{{ddcl|header=numeric|since=c++17|
template&lt; class M, class N &gt;
constexpr std::common_type_t&lt;M, N&gt; lcm( M m, N n );
}}

Computes the {{enwiki|least common multiple}} of the integers {{c|m}} and {{c|n}}.

If either {{tt|M}} or {{tt|N}} is not an integer type, or if either is (possibly cv-qualified) {{c|bool}}, the program is ill-formed.

The behavior is undefined if {{c|{{!}}m{{!}}}}, {{c|{{!}}n{{!}}}}, or the least common multiple of {{c|{{!}}m{{!}}}} and {{c|{{!}}n{{!}}}} is not representable as a value of type {{c|std::common_type_t&lt;M, N&gt;}}.

===Parameters===
{{par begin}}
{{par|m, n|integer values}}
{{par end}}

===Return value===
If either {{c|m}} or {{c|n}} is zero, returns zero. Otherwise, returns the least common multiple of {{c|{{!}}m{{!}}}} and {{c|{{!}}n{{!}}}}.

===Exceptions===
Throws no exceptions.

===Notes===
{{feature test macro|__cpp_lib_gcd_lcm|{{lc|std::gcd}}, {{tt|std::lcm}}|value=201606L|std=C++17}}

===Example===
{{example|code=
#include &lt;iostream&gt;
#include &lt;numeric&gt;

#define OUT(...) std::cout &lt;&lt; #__VA_ARGS__ &lt;&lt; " = " &lt;&lt; __VA_ARGS__ &lt;&lt; '\n'

constexpr auto lcm(auto x, auto... xs)
{
    return ((x = std::lcm(x, xs)), ...);
}

int main()
{
    constexpr int p{2 * 2 * 3};
    constexpr int q{2 * 3 * 3};
    static_assert(2 * 2 * 3 * 3 == std::lcm(p, q));
    static_assert(225 == std::lcm(45, 75));

    static_assert(std::lcm( 6,  10) == 30);
    static_assert(std::lcm( 6, -10) == 30);
    static_assert(std::lcm(-6, -10) == 30);

    static_assert(std::lcm( 24, 0) == 0);
    static_assert(std::lcm(-24, 0) == 0);

    OUT(lcm(2 * 3, 3 * 4, 4 * 5));
    OUT(lcm(2 * 3 * 4, 3 * 4 * 5, 4 * 5 * 6));
    OUT(lcm(2 * 3 * 4, 3 * 4 * 5, 4 * 5 * 6, 5 * 6 * 7));
}
|output=
lcm(2 * 3, 3 * 4, 4 * 5) = 60
lcm(2 * 3 * 4, 3 * 4 * 5, 4 * 5 * 6) = 120
lcm(2 * 3 * 4, 3 * 4 * 5, 4 * 5 * 6, 5 * 6 * 7) = 840
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/dsc gcd}}
{{dsc end}}

{{langlinks|de|es|ja|ru|zh}}