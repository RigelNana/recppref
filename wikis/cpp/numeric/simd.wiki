{{title|Data-parallel types (SIMD) {{mark since c++26}}}}
{{cpp/numeric/simd/navbar}}

The library provides data-parallel types and operations on these types: portable types for explicitly stating data-parallelism and structuring data through data-parallel execution resources where available, such as {{enwiki|Single instruction, multiple data|SIMD}} registers and instructions or execution units that are driven by a common instruction decoder.

{{anchor|vectorizable types}}
All standard integer types, character types, and most floating-point types are ''vectorizable types''. Vectorizable floating-point types include {{c/core|float}}, {{c/core|double}}, and the selected extended floating-point types {{c/core|std::float16_t}}, {{c/core|std::float32_t}}, and {{c/core|std::float64_t}} if defined.

A ''data-parallel type'' consists of one or more elements of an underlying vectorizable type, called the ''element type''. The number of elements, called the ''width'', is constant for each data-parallel type.

The data-parallel type refers to all enabled specializations of the class templates {{tt|basic_simd}} and {{tt|basic_simd_mask}}.

A ''data-parallel object'' of data-parallel type behaves analogously to objects of type {{tt|T}}. But while {{tt|T}} stores and manipulates a single value, the data-parallel type with the element type {{tt|T}} stores and manipulates multiple values.

Every operation on a data-parallel object acts ''element-wise'' (except for horizontal operations, such as reductions, which are clearly marked as such) applying to each element of the object or to corresponding elements of two objects. Each such application is unsequenced with respect to the others. This simple rule expresses data-parallelism and will be used by the compiler to generate SIMD instructions and/or independent execution streams.

All operations (except non-{{c/core|constexpr}} math function overloads) on data-parallel objects are {{c/core|constexpr}}: it is possible to create and use data-parallel objects in the evaluation of a constant expression.

Alias templates {{tt|simd}} and {{tt|simd_mask}} are defined to allow users to specify the width to a certain size. The default width is determined by the implementation at compile-time.

{{dsc begin}}
{{dsc header|simd}}
{{dsc end}}

===Main classes===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/dsc basic_simd}}
{{dsc inc|cpp/numeric/simd/dsc simd}}
{{dsc inc|cpp/numeric/simd/dsc basic_simd_mask}}
{{dsc inc|cpp/numeric/simd/dsc simd_mask}}
{{dsc end}}

===Load and store flags===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/dsc simd_flags}}
{{dsc inc|cpp/numeric/simd/dsc simd_flag_default}}
{{dsc inc|cpp/numeric/simd/dsc simd_flag_convert}}
{{dsc inc|cpp/numeric/simd/dsc simd_flag_aligned}}
{{dsc inc|cpp/numeric/simd/dsc simd_flag_overaligned}}
{{dsc end}}

===Load and store operations===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/dsc simd_load}}
{{dsc inc|cpp/numeric/simd/dsc simd_store}}
{{dsc end}}

===Casts===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/dsc simd_split}}
{{dsc inc|cpp/numeric/simd/dsc simd_cat}}
{{dsc end}}

===Algorithms===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/dsc min_max}}
{{dsc inc|cpp/numeric/simd/dsc clamp}}
{{dsc inc|cpp/numeric/simd/dsc simd_select}}
{{dsc end}}

===Reductions===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/dsc reduce}}
{{dsc inc|cpp/numeric/simd/dsc all_any_none_of}}
{{dsc inc|cpp/numeric/simd/dsc reduce_count}}
{{dsc inc|cpp/numeric/simd/dsc reduce_min_max_index}}
{{dsc end}}

===Traits===
{{dsc begin}}
{{dsc inc|cpp/numeric/simd/dsc simd_alignment}}
{{dsc inc|cpp/numeric/simd/dsc rebind_simd}}
{{dsc inc|cpp/numeric/simd/dsc resize_simd}}
{{dsc end}}

===Math functions===
All functions in {{header|cmath}} are overloaded for {{tt|basic_simd}}.

{{todo|description}}

===Implementation details===
====ABI tags====
The data-parallel types {{tt|basic_simd}} and {{tt|basic_simd_mask}} are associated with ''ABI tags''. These tags are types that specify the size and binary representation of data-parallel objects. The design intends the size and binary representation to vary based on target architecture and compiler flags. The ABI tag, together with the element type, determines the width.

The ABI tag remains independent of machine instruction set selection. The chosen machine instruction set limits the usable ABI tag types. The ABI tags enable users to safely pass objects of data-parallel type across translation unit boundaries.
{{todo}}

====Exposition-only entities====
{{dcl begin}}
{{dcla|num=1|anchor=simd-size-type|expos=yes|1=
using /*simd-size-type*/ = /* see description */;
}}
{{dcla|num=2|anchor=integer-from|expos=yes|1=
template&lt; std::size_t Bytes &gt;
using /*integer-from*/ = /* see description */;
}}
{{dcla|num=3|anchor=simd-size-v|expos=yes|1=
template&lt; class T, class Abi &gt;
constexpr /*simd-size-type*/ /*simd-size-v*/ = /* see description */;
}}
{{dcla|num=4|anchor=mask-element-size|expos=yes|1=
template&lt; class T &gt;
constexpr std::size_t /*mask-element-size*/ = /* see description */;
}}
{{dcla|num=5|anchor=constexpr-wrapper-like|expos=yes|1=
template&lt; class T &gt;
concept /*constexpr-wrapper-like*/ = /* see description */;
}}
{{dcla|num=6|anchor=deduced-simd-t|expos=yes|1=
template&lt; class T &gt;
using /*deduced-simd-t*/ = /* see description */;
}}
{{dcla|num=7|anchor=make-compatible-simd-t|expos=yes|1=
template&lt; class V, class T &gt;
using /*make-compatible-simd-t*/ = /* see description */;
}}
{{dcl end}}
@1@ {{c/core|/*simd-size-type*/}} is an alias for for a signed integer type. The implementation is free to choose any signed integer type.
@2@ {{c/core|/*integer-from*/&lt;Bytes&gt;}} is an alias for a signed integer type {{tt|T}} such that {{c|sizeof(T)}} equals {{c|Bytes}}.
@3@ {{c/core|/*simd-size-v*/&lt;T, Abi&gt;}} denotes the width of the enabled specialization {{tt|basic_simd&lt;T, Abi&gt;}}, or {{c|0}} otherwise.
@4@ If {{tt|T}} denotes {{c/core|std::basic_simd_mask&lt;Bytes, Abi&gt;}}, {{c/core|/*mask-element-size*/&lt;T&gt;}} equals {{c|Bytes}}.
@5@ The concept {{c/core|/*constexpr-wrapper-like*/}} is defined as:
{{source|1=
template&lt; class T &gt;
concept /*constexpr-wrapper-like*/ =
    std::convertible_to&lt;T, decltype(T::value)&gt; &amp;&amp;
    std::equality_comparable_with&lt;T, decltype(T::value)&gt; &amp;&amp;
    std::bool_constant&lt;T() {{==}} T::value&gt;::value &amp;&amp;
    std::bool_constant&lt;static_cast&lt;decltype(T::value)&gt;(T()) {{==}} T::value&gt;::value;
}}
@6@ Let {{c|x}} be an lvalue of type {{c/core|const T}}. {{c/core|/*deduced-simd-t*/&lt;T&gt;}} is an alias equivalent to:
* {{c/core|decltype(x + x)}}, if the type of {{c|x + x}} is an enabled specialization of {{tt|basic_simd}}; otherwise
* {{c/core|void}}.
@7@ Let {{c|x}} be an lvalue of type {{c/core|const T}}. {{c/core|/*make-compatible-simd-t*/&lt;V, T&gt;}} is an alias equivalent to:
* {{c/core|/*deduced-simd-t*/&lt;T&gt;}}, if that type is not {{c/core|void}}, otherwise
* {{c/core|std::simd&lt;decltype(x + x), V​::​size()&gt;}}.

{{dcl begin}}
{{dcl h|Math functions requirements}}
{{dcla|num=8|anchor=simd-floating-point|expos=yes|1=
template&lt; class V &gt;
concept /*simd-floating-point*/ = /* see description */;
}}
{{dcla|num=9|anchor=math-floating-point|expos=yes|1=
template&lt; class... Ts &gt;
concept /*math-floating-point*/ = /* see description */;
}}
{{dcla|num=10|anchor=math-common-simd-t|expos=yes|1=
template&lt; class... Ts &gt;
  requires /*math-floating-point*/&lt;Ts...&gt;
using /*math-common-simd-t*/ = /* see description */;
}}
{{dcla|num=11|anchor=reduction-binary-operation|expos=yes|1=
template&lt; class BinaryOp, class T &gt;
concept /*reduction-binary-operation*/ = /* see description */;
}}
{{dcl end}}
@8@ The concept {{c/core|/*simd-floating-point*/}} is defined as:
{{source|1=
template&lt; class V &gt;
concept /*simd-floating-point*/ =
    std::same_as&lt;V, std::basic_simd&lt;typename V::value_type, typename V::abi_type&gt;&gt; &amp;&amp;
    std::is_default_constructible_v&lt;V&gt; &amp;&amp; 
    std::floating_point&lt;typename V::value_type&gt;;
}}
@9@ The concept {{c/core|/*math-floating-point*/}} is defined as:
{{source|1=
template&lt; class... Ts &gt;
concept /*math-floating-point*/ =
    (/*simd-floating-point*/&lt;/*deduced-simd-t*/&lt;Ts&gt;&gt; {{!!}} ...);
}}
@10@ Let {{tt|T0}} denote {{c/core|Ts...[0]}}, {{tt|T1}} denote {{c/core|Ts...[1]}}, and {{tt|TRest}} denote a pack such that {{c/core|T0, T1, TRest...}} is equivalent to {{c/core|Ts...}}. Then, {{c/core|/*math-common-simd-t*/&lt;Ts...&gt;}} is an alias equivalent to:
* {{c/core|/*deduced-simd-t*/&lt;T0&gt;}}, if {{c|1=sizeof...(Ts) == 1}} is {{c|true}}
* otherwise, {{c/core|std::common_type_t&lt;/*deduced-simd-t*/&lt;T0&gt;, /*deduced-simd-t*/&lt;T1&gt;&gt;}}, if {{c|1=sizeof...(Ts) == 2}} is {{c|true}} and {{c|1=/*math-floating-point*/&lt;T0&gt; &amp;&amp; /*math-floating-point*/&lt;T1&gt;}} is {{c|true}},
* otherwise, {{c/core|std::common_type_t&lt;/*deduced-simd-t*/&lt;T0&gt;, T1&gt;}} if {{c|1=sizeof...(Ts) == 2}} is {{c|true}} and {{c|1=/*math-floating-point*/&lt;T0&gt;}} is {{c|true}},
* otherwise, {{c/core|std::common_type_t&lt;T0, /*deduced-simd-t*/&lt;T1&gt;&gt;}} if {{c|1=sizeof...(Ts) == 2}} is {{c|true}},
* otherwise, {{c/core|std::common_type_t&lt;/*math-common-simd-t*/&lt;T0, T1&gt;, TRest...&gt;}}, if {{c/core|/*math-common-simd-t*/&lt;T0, T1&gt;}} is a valid type,
* otherwise, {{c/core|std::common_type_t&lt;/*math-common-simd-t*/&lt;TRest...&gt;, T0, T1&gt;}}.

@11@ The concept {{c/core|/*reduction-binary-operation*/}} is defined as:
{{source|1=
template&lt; class BinaryOp, class T &gt;
concept /*reduction-binary-operation*/ =
    requires (const BinaryOp binary_op, const std::simd&lt;T, 1&gt; v) {
        { binary_op(v, v) } -&gt; std::same_as&lt;std::simd&lt;T, 1&gt;&gt;;
    };
}}
{{c/core|/*reduction-binary-operation*/&lt;BinaryOp, T&gt;}} is modeled only if:
:* {{tt|BinaryOp}} is a binary element-wise operation that is commutative, and
:* An object of type {{tt|BinaryOp}} is invocable with two arguments of type {{c/core|std::basic_simd&lt;T, Abi&gt;}} for unspecified ABI tag {{tt|Abi}} that returns a {{c/core|std::basic_simd&lt;T, Abi&gt;}}.

{{dcl begin}}
{{dcl h|SIMD ABI tags}}
{{dcla|num=12|anchor=native-abi|expos=yes|1=
template&lt; class T &gt;
using /*native-abi*/ = /* see description */;
}}
{{dcla|num=13|anchor=deduce-abi-t|expos=yes|1=
template&lt; class T, /*simd-size-type*/ N &gt;
using /*deduce-abi-t*/ = /* see description */;
}}
{{dcl end}}
@12@ {{c/core|/*native-abi*/&lt;T&gt;}} is an implementation-defined alias for an ABI tag. This is the primary ABI tag to use for efficient explicit vectorization. As a result, {{c/core|basic_simd&lt;T, /*native-abi*/&lt;T&gt;&gt;}} is an enabled specialization.
@13@ {{c/core|/*deduce-abi-t*/&lt;T, N&gt;}} is an alias that names an ABI tag type such that:
* {{c/core|/*simd-size-v*/&lt;T, /*deduce-abi-t*/&lt;T, N&gt;&gt;}} equals {{c|N}},
* {{c/core|std::basic_simd&lt;T, /*deduce-abi-t*/&lt;T, N&gt;&gt;}} is an enabled specialization, and
* {{c/core|std::basic_simd_mask&lt;sizeof(T), /*deduce-abi-t*/&lt;/*integer-from*/&lt;sizeof(T)&gt;, N&gt;&gt;}} is an enabled specialization.
It is defined only if {{tt|T}} is a vectorizable type, and {{c|1=N &gt; 0 &amp;&amp; N &lt;= M}} is {{c|true}}, where {{c|M}} is an implementation-defined maximum that is at least {{c|64}} and can differ depending on {{tt|T}}.

{{dcl begin}}
{{dcl h|Load and store flags}}
{{dcla|num=14|anchor=convert-flag|expos=yes|1=
struct /*convert-flag*/;
}}
{{dcla|num=15|anchor=aligned-flag|expos=yes|1=
struct /*aligned-flag*/;
}}
{{dcla|num=16|anchor=overaligned-flag|expos=yes|1=
template&lt; std::size_t N &gt;
struct /*overaligned-flag*/;
}}
{{dcl end}}
@14-16@ These tag types are used as a template argument of {{tt|std::simd_flags}}. See {{rl|simd_flags|load and store flags}} for their corresponding uses.

===Notes===
{{feature test macro|__cpp_lib_simd|std=C++26|value=202411L|Data-parallel types and operations}}

===Example===
{{example
|code=
#include &lt;iostream&gt;
#include &lt;simd&gt;
#include &lt;string_view&gt;

void println(std::string_view name, auto const&amp; a)
{
    std::cout &lt;&lt; name &lt;&lt; ": ";
    for (std::size_t i{}; i != a.size(); ++i)
        std::cout &lt;&lt; a[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

template&lt;class A&gt;
constexpr std::basic_simd&lt;int, A&gt; my_abs(std::basic_simd&lt;int, A&gt; x)
{
    return std::simd_select(x &lt; 0, -x, x);
}

int main()
{
    constexpr std::simd&lt;int&gt; a = 1;
    println("a", a);

    constexpr std::simd&lt;int&gt; b([](int i) { return i - 2; });
    println("b", b);

    constexpr auto c = a + b;
    println("c", c);

    constexpr auto d = my_abs(c);
    println("d", d);

    constexpr auto e = d * d;
    println("e", e);

    constexpr auto inner_product = std::reduce(e);
    std::cout &lt;&lt; "inner product: " &lt;&lt; inner_product &lt;&lt; '\n';

    constexpr std::simd&lt;double, 16&gt; x([](int i) { return i; });
    println("x", x);
    // overloaded math functions are defined in &lt;simd&gt;
    println("cos²(x) + sin²(x)", std::pow(std::cos(x), 2) + std::pow(std::sin(x), 2));
}
|output=
a: 1 1 1 1 
b: -2 -1 0 1 
c: -1 0 1 2 
d: 1 0 1 2 
e: 1 0 1 4 
inner product: 6
x: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
cos²(x) + sin²(x): 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/dsc valarray}}
{{dsc end}}

===External links===
{{elink begin}}
{{elink|1=[https://github.com/VcDevel/std-simd The implementation of ISO/IEC TS 19570:2018 Section 9 "Data-Parallel Types"] — github.com}}
{{elink|1=TS implementation reach for [https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=libstdc%2B%2B-v3/include/experimental/simd;hb=HEAD GCC/libstdc++] ({{tt|std::experimental::simd}} is shipping with GCC-11) — gcc.gnu.org}}
{{elink end}}

{{langlinks|es|ja|ru|zh}}