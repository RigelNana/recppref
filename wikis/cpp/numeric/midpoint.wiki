{{cpp/title|midpoint}}
{{cpp/numeric/navbar}}
{{dcl begin}}
{{dcl header|numeric}}
{{dcl|since=c++20|num=1|1=
template&lt; class T &gt;
constexpr T midpoint( T a, T b ) noexcept;
}}
{{dcl|since=c++20|num=2|1=
template&lt; class T &gt;
constexpr T* midpoint( T* a, T* b );
}}
{{dcl end}}

Computes the midpoint of the integers, floating-points, or pointers {{c|a}} and {{c|b}}.

@1@ {{cpp/enable_if|{{tt|T}} is an arithmetic type other than {{c|bool}}}}.

@2@ {{cpp/enable_if|{{tt|T}} is an object type}}. Use of this overload is ill-formed if {{tt|T}} is an [[cpp/language/type#Incomplete type|incomplete type]].

=== Parameters ===
{{par begin}}
{{par|a, b|integers, floating-points, or pointer values}}
{{par end}}

===Return value===
@1@ Half the sum of {{c|a}} and {{c|b}}. No overflow occurs. If {{c|a}} and {{c|b}} have integer type and the sum is odd, the result is rounded towards {{c|a}}. If {{c|a}} and {{c|b}} have floating-point type, at most one inexact operation occurs.

@2@ If {{c|a}} and {{c|b}} point to, respectively, {{c|x[i]}} and {{c|x[j]}} of the same array object {{tt|x}} (for the purpose of [[cpp/language/operator arithmetic#Additive operators|pointer arithmetic]]), returns a pointer to {{c|x[i + (j - i) / 2]}} (or, equivalently {{c|x[std::midpoint(i, j)]}}) where the division rounds towards zero. If {{c|a}} and {{c|b}} do not point to elements of the same array object, the behavior is undefined.

=== Exceptions ===
Throws no exceptions.

===Notes===
Overload {{v|2}} can be simply implemented as {{c|return a + (b - a) / 2;}} on common platforms. However, such implementation is not guaranteed to be portable, because there may be some platforms where creating an array with number of elements greater than {{lc|PTRDIFF_MAX}} is possible, and {{c|b - a}} may result in undefined behavior even if both {{c|b}} and {{c|a}} point to elements in the same array.
{{feature_test_macro|__cpp_lib_interpolate|value=201902L|std=C++20|{{lc|std::lerp}}, {{tt|std::midpoint}}}}

===Example===
{{example
|code=
#include &lt;cstdint&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;numeric&gt;
 
int main()
{
    std::uint32_t a = std::numeric_limits&lt;std::uint32_t&gt;::max();
    std::uint32_t b = std::numeric_limits&lt;std::uint32_t&gt;::max() - 2;
 
    std::cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; '\n'
              &lt;&lt; "b: " &lt;&lt; b &lt;&lt; '\n'
              &lt;&lt; "Incorrect (overflow and wrapping): " &lt;&lt; (a + b) / 2 &lt;&lt; '\n'
              &lt;&lt; "Correct: " &lt;&lt; std::midpoint(a, b) &lt;&lt; "\n\n";

    auto on_pointers = [](int i, int j)
    {
        char const* text = "0123456789";
        char const* p = text + i;
        char const* q = text + j;
        std::cout &lt;&lt; "std::midpoint('" &lt;&lt; *p &lt;&lt; "', '" &lt;&lt; *q &lt;&lt; "'): '"
                  &lt;&lt; *std::midpoint(p, q) &lt;&lt; "'\n";
    };

    on_pointers(2, 4);
    on_pointers(2, 5);
    on_pointers(5, 2);
    on_pointers(2, 6);
}
|output=
a: 4294967295
b: 4294967293
Incorrect (overflow and wrapping): 2147483646
Correct: 4294967294

std::midpoint('2', '4'): '3'
std::midpoint('2', '5'): '3'
std::midpoint('5', '2'): '4'
std::midpoint('2', '6'): '4'
}}

===References===
{{ref std c++23}}
{{ref std|section=27.10.16|title=Midpoint|id=numeric.ops.midpoint}}
{{ref std end}}
{{ref std c++20}}
{{ref std|section=25.10.15|title=Midpoint|id=numeric.ops.midpoint}}
{{ref std end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/numeric/dsc lerp}}
{{dsc end}}

{{langlinks|es|ja|zh}}