{{cpp/numeric/random/seed_seq/title|generate}}
{{cpp/numeric/random/seed_seq/navbar}}
{{ddcl|since=c++11|1=
template&lt; class RandomIt &gt;
void generate( RandomIt begin, RandomIt end );
}}

Generate unbiased seeds by filling the output range {{range|begin|end}} with 32-bit unsigned integer values, based on the (possibly biased) seeds stored in {{rlpsi|/#v}}.
* If {{c|1=begin == end}} is {{c|true}}, does nothing.
* Otherwise, generates seeds by the generation algorithm described below.

If {{c/core|std::iterator_traits&lt;RandomIt&gt;::value_type}} is not an unsigned integer type, or its width is less than 32, the program is ill-formed.

If {{tt|RandomIt}} does not meet the requirements of {{named req|RandomAccessIterator}}, or it is not [[cpp/iterator|mutable]], the behavior is undefined.

===Generation algorithm===
Given the following values and operations:
{{dsc begin}}
{{dsc hitem|Value|Definition}}
{{dsc|{{c|z}}|{{box|{{rlpsi|/#v}}{{sep}}{{c/core|.size()}}}}}}
{{dsc|{{c|n}}|{{c|end - begin}}}}
{{dsc|{{c|m}}|{{c|std::max(z + 1, n)}}}}
{{dsc|{{c|t}}|{{c|1=(n &gt;= 623) ? 11 : (n &gt;= 68) ? 7 : (n &gt;= 39) ? 5 : (n &gt;= 7) ? 3 : (n - 1) / 2}}}}
{{dsc|{{c|p}}|{{c|(n - t) / 2}}}}
{{dsc|{{c|q}}|{{c|p + t}}}}
{{dsc hitem|Operation|Definition}}
{{dsc|{{mathjax-or|\(\scriptsize \mathsf{xor} \)|xor}}|built-in [[cpp/language/operator arithmetic#Bitwise logic operators|bitwise XOR]]}}
{{dsc|{{mathjax-or|\(\scriptsize \mathsf{rshift} \)|rshift}}|built-in [[cpp/language/operator arithmetic#Bitwise shift operators|bitwise right-shift]]}}
{{dsc|{{mathjax-or|\(\scriptsize T(x) \)|T(x)}}|{{mathjax-or|\(\scriptsize x\ \mathsf{xor}\ (x\ \mathsf{rshift}\ 27) \)|x xor (x rshift 27)}}}}
{{dsc end}}

The generation algorithm consists of the following steps, where {{mathjax-or|\(\scriptsize S_i \)|S{{su|b=i}}}} denotes {{c|begin[i % n]}}, {{mathjax-or|\(\scriptsize V_i \)|V{{su|b=i}}}} denotes {{box|{{rlpsi|/#v}}{{sep}}{{c/core|[i]}}}}:

@1@ Set each element of the output range to the value {{c|0x8b8b8b8b}}.

@2@ For each integer {{c|k}} in {{range|0|m}}, performs the following operations in order:

:@1@ Let {{mathjax-or|\(\scriptsize r_1 \)|r{{su|b=1}}}} be {{mathjax-or|\(\scriptsize 1664525 \cdot T(S_k\ \mathsf{xor}\ S_{k+p}\ \mathsf{xor}\ S_{k-1}) \)|1664525·T(S{{su|b=k}} xor S{{su|b=k+p}} xor S{{su|b=k-1}})}}.

:@2@ Let {{mathjax-or|\(\scriptsize r_2 \)|r{{su|b=2}}}} be {{mathjax-or|\(\scriptsize r_1 + j \)|r{{su|b=1}}+j}}, where {{mathjax-or|\(\scriptsize j \)|j}} is:
* {{mathjax-or|\(\scriptsize z \)|z}}, if {{mathjax-or|1=\(\scriptsize k=0 \)|2=k=0}}
* {{mathjax-or|\(\scriptsize (k \mod n)+V_{k-1} \)|(k mod n)+V{{su|b=k-1}}}}, if {{mathjax-or|\(\scriptsize 0&lt;k⩽z \)|0&lt;k⩽z}}
* {{mathjax-or|\(\scriptsize k \mod n \)|k mod n}}, if {{mathjax-or|\(\scriptsize z&lt;k \)|z&lt;k}}

:@3@ Set {{mathjax-or|\(\scriptsize S_{k+p} \)|S{{su|b=k+p}}}} to {{mathjax-or|\(\scriptsize (S_{k+p}+r_1) \mod 2^{32} \)|(S{{su|b=k+p}}+r{{su|b=1}}) mod 2{{su|p=32}}}}.

:@4@ Set {{mathjax-or|\(\scriptsize S_{k+q} \)|S{{su|b=k+q}}}} to {{mathjax-or|\(\scriptsize (S_{k+q}+r_2) \mod 2^{32} \)|(S{{su|b=k+q}}+r{{su|b=2}}) mod 2{{su|p=32}}}}.

:@5@ Set {{mathjax-or|\(\scriptsize S_k \)|S{{su|b=k}}}} to {{mathjax-or|\(\scriptsize r_2 \mod 2^{32} \)|r{{su|b=2}} mod 2{{su|p=32}}}}.

@3@ For each integer {{c|k}} in {{range|m|m + n}}, performs the following operations in order:

:@1@ Let {{mathjax-or|\(\scriptsize r_3 \)|r{{su|b=3}}}} be {{mathjax-or|\(\scriptsize 1566083941 \cdot T(S_k+S_{k+p}+S_{k-1}) \)|1566083941·T(S{{su|b=k}}+S{{su|b=k+p}}+S{{su|b=k-1}})}}.

:@2@ Let {{mathjax-or|\(\scriptsize r_4 \)|r{{su|b=4}}}} be {{mathjax-or|\(\scriptsize r_3-(k \mod n) \)|r{{su|b=3}}-(k mod n)}}.

:@3@ Set {{mathjax-or|\(\scriptsize S_{k+p} \)|S{{su|b=k+p}}}} to {{mathjax-or|\(\scriptsize (S_{k+p}\ \mathsf{xor}\ r_3) \mod 2^{32} \)|(S{{su|b=k+p}} xor r{{su|b=3}}) mod 2{{su|p=32}}}}.

:@4@ Set {{mathjax-or|\(\scriptsize S_{k+q} \)|S{{su|b=k+q}}}} to {{mathjax-or|\(\scriptsize (S_{k+q}\ \mathsf{xor}\ r_4) \mod 2^{32} \)|(S{{su|b=k+q}} xor r{{su|b=4}}) mod 2{{su|p=32}}}}.

:@5@ Set {{mathjax-or|\(\scriptsize S_k \)|S{{su|b=k}}}} to {{mathjax-or|\(\scriptsize r_4 \mod 2^{32} \)|r{{su|b=4}} mod 2{{su|p=32}}}}.

===Parameters===
{{par begin}}
{{par|begin, end|the iterators denoting the output range}}
{{par end}}

===Exceptions===
Only throws the exceptions thrown by the {{tt|RandomIt}} operations on {{c|begin}} and {{c|end}}.

===Notes===
The generation algorithm is adapted from the initialization sequence of the Mersenne Twister generator by [http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html Makoto Matsumoto and Takuji Nishimura], incorporating the improvements made by [http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/M062821.pdf Mutsuo Saito in 2007].

===Example===
{{example
|code=
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cstdint&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;

// Prototyping the main part of std::seed_seq...
struct seed_seq
{
    std::vector&lt;std::uint32_t&gt; v;
    
    seed_seq(std::initializer_list&lt;std::uint32_t&gt; const il) : v{il} {}
    
    template&lt;typename RandomIt&gt;
    void generate(RandomIt first, RandomIt last)
    {
        if (first == last)
            return;
        //
        // Assuming v = {1, 2, 3, 4, 5} and distance(first, last) == 10.
        //
        // Step 1: fill with 0x8b8b8b8b
        // seeds = {2341178251, 2341178251, 2341178251, 2341178251, 2341178251,
        //          2341178251, 2341178251, 2341178251, 2341178251, 2341178251}
        //
        std::fill(first, last, 0x8b8b8b8b);
        //
        // Step 2:
        // n = 10, s = 5, t = 3, p = 3, q = 6, m = 10
        //
        const std::uint32_t n = last - first;
        const std::uint32_t s = v.size();
        const std::uint32_t t = (n &lt; 7) ? (n - 1) / 2
                              : (n &lt; 39) ? 3
                              : (n &lt; 68) ? 5
                              : (n &lt; 623) ? 7
                              : 11;
        const std::uint32_t p = (n - t) / 2;
        const std::uint32_t q = p + t;
        const std::uint32_t m = std::max(s + 1, n);
        //
        // First iteration, k = 0; r1 = 1371501266, r2 = 1371501271
        //
        // seeds = {1371501271, 2341178251, 2341178251, 3712679517, 2341178251,
        //          2341178251, 3712679522, 2341178251, 2341178251, 2341178251}
        //
        // Iterations from k = 1 to k = 5 (r2 = r1 + k % n + v[k - 1])
        //
        // r1 = 2786190137, 3204727651, 4173325571, 1979226628, 401983366
        // r2 = 2786190139, 3204727655, 4173325577, 1979226636, 401983376
        //
        // seeds = {3350727907, 3188173515, 3204727655, 4173325577, 1979226636,
        //           401983376, 3591037797, 2811627722, 1652921976, 2219536532}
        //
        // Iterations from k = 6 to k = 9 (r2 = r1 + k % n)
        //
        // r1 = 2718637909, 1378394210, 2297813071, 1608643617
        // r2 = 2718637915, 1378394217, 2297813079, 1608643626
        //
        // seeds = { 434154821, 1191019290, 3237041891, 1256752498, 4277039715,
        //          2010627002, 2718637915, 1378394217, 2297813079, 1608643626}
        //
        auto begin_mod = [first, n](std::uint32_t u) -&gt; decltype(*first)&amp;
        {
            return first[u % n]; // i.e. begin[x] is taken modulo n
        };
        auto T = [](std::uint32_t x) { return x ^ (x &gt;&gt; 27); };
        
        for (std::uint32_t k = 0, r1, r2; k &lt; m; ++k)
        {
            r1 = 1664525 * T(begin_mod(k) ^ begin_mod(k + p) ^ begin_mod(k - 1));
            r2 = (k == 0) ? r1 + s
               : (k &lt;= s) ? r1 + k % n + v[k - 1]
               :            r1 + k % n;
            begin_mod(k + p) += r1;
            begin_mod(k + q) += r2;
            begin_mod(k) = r2;
        }
        //
        // Step 3
        // iterations from k = 10 to k = 19, using ^= to modify the output
        //
        // r1 = 1615303485, 3210438310, 893477041, 2884072672, 1918321961,
        // r2 = 1615303485, 3210438309, 893477039, 2884072669, 1918321957
        //
        // seeds = { 303093272, 3210438309,  893477039, 2884072669, 1918321957,
        //          1117182731, 1772877958, 2669970405, 3182737656, 4094066935}
        //
        // r1 =  423054846, 46783064, 3904109085, 1534123446, 1495905687
        // r2 =  423054841, 46783058, 3904109078, 1534123438, 1495905678
        //
        // seeds = { 4204997637, 4246533866, 1856049002, 1129615051, 690460811,
        //           1075771511,   46783058, 3904109078, 1534123438, 1495905678}
        //
        for (std::uint32_t k = m, r3, r4; k &lt; m + n; ++k)
        {
            r3 = 1566083941 * T(begin_mod(k) + begin_mod(k + p) + begin_mod(k - 1));
            r4 = r3 - k % n;
            begin_mod(k+p) ^= r3;
            begin_mod(k+q) ^= r4;
            begin_mod(k) = r4;
        }
    }
};

int main()
{
    const auto input = std::initializer_list&lt;std::uint32_t&gt;{1, 2, 3, 4, 5};
    const auto output_size = 10;
    
    // using std version of seed_seq
    std::seed_seq seq(input);
    std::vector&lt;std::uint32_t&gt; seeds(output_size);
    seq.generate(seeds.begin(), seeds.end());
    for (const std::uint32_t n : seeds)
        std::cout &lt;&lt; n &lt;&lt; '\n';
    
    // using custom version of seed_seq
    seed_seq seq2(input);
    std::vector&lt;std::uint32_t&gt; seeds2(output_size);
    seq2.generate(seeds2.begin(), seeds2.end());
    
    assert(seeds == seeds2);
}
|output=
4204997637
4246533866
1856049002
1129615051
690460811
1075771511
46783058
3904109078
1534123438
1495905678 
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2180|std=C++11|before={{tt|seed_seq::generate}} is non-throwing|after=it may throw exceptions}}
{{dr list end}}

{{langlinks|cs|de|es|fr|it|ja|ko|pl|pt|ru|zh}}