{{cpp/title|byteswap}}
{{cpp/utility/bit/navbar}}
{{ddcl|since=c++23|header=bit|
template&lt; class T &gt;
constexpr T byteswap( T n ) noexcept;
}}

Reverses the bytes in the given integer value {{c|n}}.

{{tt|std::byteswap}} participates in overload resolution only if {{tt|T}} satisfies {{lconcept|integral}}, i.e., {{tt|T}} is an integer type. The program is ill-formed if {{tt|T}} has padding bits.

===Parameters===
{{par begin}}
{{par|n|integer value}}
{{par end}}

===Return value===
An integer value of type {{tt|T}} whose object representation comprises the bytes of that of {{c|n}} in reversed order.

===Notes===
This function is useful for processing data of different endianness.
{{feature test macro|__cpp_lib_byteswap|std=C++23|value=202110L|{{tt|std::byteswap}}}}

===Possible implementation===
{{eq fun
|1=
template&lt;std::integral T&gt;
constexpr T byteswap(T value) noexcept
{
    static_assert(std::has_unique_object_representations_v&lt;T&gt;, 
                  "T may not have padding bits");
    auto value_representation = std::bit_cast&lt;std::array&lt;std::byte, sizeof(T)&gt;&gt;(value);
    std::ranges::reverse(value_representation);
    return std::bit_cast&lt;T&gt;(value_representation);
}
}}

===Example===
{{example|code=
#include &lt;bit&gt;
#include &lt;concepts&gt;
#include &lt;cstdint&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;

template&lt;std::integral T&gt;
void dump(T v, char term = '\n')
{
    std::cout &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; std::setfill('0')
              &lt;&lt; std::setw(sizeof(T) * 2) &lt;&lt; v &lt;&lt; " : ";
    for (std::size_t i{}; i != sizeof(T); ++i, v &gt;&gt;= 8)
        std::cout &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;unsigned&gt;(T(0xFF) &amp; v) &lt;&lt; ' ';
    std::cout &lt;&lt; std::dec &lt;&lt; term;
}

int main()
{
    static_assert(std::byteswap('a') == 'a');

    std::cout &lt;&lt; "byteswap for U16:\n";
    constexpr auto x = std::uint16_t(0xCAFE);
    dump(x);
    dump(std::byteswap(x));

    std::cout &lt;&lt; "\nbyteswap for U32:\n";
    constexpr auto y = std::uint32_t(0xDEADBEEFu);
    dump(y);
    dump(std::byteswap(y));

    std::cout &lt;&lt; "\nbyteswap for U64:\n";
    constexpr auto z = std::uint64_t{0x0123456789ABCDEFull};
    dump(z);
    dump(std::byteswap(z));
}
|p=true
|output=
byteswap for U16:
CAFE : FE CA
FECA : CA FE

byteswap for U32:
DEADBEEF : EF BE AD DE
EFBEADDE : DE AD BE EF

byteswap for U64:
0123456789ABCDEF : EF CD AB 89 67 45 23 01
EFCDAB8967452301 : 01 23 45 67 89 AB CD EF
}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/types/dsc endian}}
{{dsc inc|cpp/numeric/dsc rotl}}
{{dsc inc|cpp/numeric/dsc rotr}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}