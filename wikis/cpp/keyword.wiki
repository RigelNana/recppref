{{title|C++ keywords}}
{{cpp/keyword/navbar}}

This is a list of reserved keywords in C++. Since they are used by the language, these keywords are not available for re-definition or overloading.{{rev inl|since=c++11| As an exception, they are not considered reserved in {{lt|cpp/language/attributes}} (excluding attribute argument lists).}}

{|class="wikitable"
|-
!A – C!!D – P!!R – Z
|-style="vertical-align:top;"
|
{{rlt|alignas}} {{mark c++11}}&lt;br&gt;
{{rlt|alignof}} {{mark c++11}}&lt;br&gt;
{{rlt|and}}&lt;br&gt;
{{rlt|and_eq}}&lt;br&gt;
{{rlt|asm}}&lt;br&gt;
{{rlt|atomic_cancel}} {{mark since tm ts}}&lt;br&gt;
{{rlt|atomic_commit}} {{mark since tm ts}}&lt;br&gt;
{{rlt|atomic_noexcept}} {{mark since tm ts}}&lt;br&gt;
{{rlt|auto}} {{mark|1}} {{mark|3}} {{mark|4}} {{mark|5}}&lt;br&gt;
{{rlt|bitand}}&lt;br&gt;
{{rlt|bitor}}&lt;br&gt;
{{rlt|bool}}&lt;br&gt;
{{rlt|break}}&lt;br&gt;
{{rlt|case}}&lt;br&gt;
{{rlt|catch}}&lt;br&gt;
{{rlt|char}}&lt;br&gt;
{{rlt|char8_t}} {{mark c++20}}&lt;br&gt;
{{rlt|char16_t}} {{mark c++11}}&lt;br&gt;
{{rlt|char32_t}} {{mark c++11}}&lt;br&gt;
{{rlt|class}} {{mark|1}}&lt;br&gt;
{{rlt|compl}}&lt;br&gt;
{{rlt|concept}} {{mark c++20}}&lt;br&gt;
{{rlt|const}}&lt;br&gt;
{{rlt|consteval}} {{mark c++20}} {{mark|5}}&lt;br&gt;
{{rlt|constexpr}} {{mark c++11}} {{mark|3}}&lt;br&gt;
{{rlt|constinit}} {{mark c++20}}&lt;br&gt;
{{rlt|const_cast}}&lt;br&gt;
{{rlt|continue}}&lt;br&gt;
{{rlt|co_await}} {{mark c++20}}&lt;br&gt;
{{rlt|co_return}} {{mark c++20}}&lt;br&gt;
{{rlt|co_yield}} {{mark c++20}}&lt;br&gt;
|
{{rlt|decltype}} {{mark c++11}} {{mark|2}}&lt;br&gt;
{{rlt|default}} {{mark|1}}&lt;br&gt;
{{rlt|delete}} {{mark|1}}&lt;br&gt;
{{rlt|do}}&lt;br&gt;
{{rlt|double}}&lt;br&gt;
{{rlt|dynamic_cast}}&lt;br&gt;
{{rlt|else}}&lt;br&gt;
{{rlt|enum}} {{mark|1}}&lt;br&gt;
{{rlt|explicit}}&lt;br&gt;
{{rlt|export}} {{mark|1}} {{mark|4}}&lt;br&gt; 
{{rlt|extern}} {{mark|1}}&lt;br&gt;
{{rlt|false}}&lt;br&gt;
{{rlt|float}}&lt;br&gt;
{{rlt|for}} {{mark|1}}&lt;br&gt;
{{rlt|friend}}&lt;br&gt;
{{rlt|goto}}&lt;br&gt;
{{rlt|if}} {{mark|3}} {{mark|5}}&lt;br&gt;
{{rlt|inline}} {{mark|1}} {{mark|3}}&lt;br&gt;
{{rlt|int}} {{mark|1}}&lt;br&gt;
{{rlt|long}}&lt;br&gt;
{{rlt|mutable}} {{mark|1}}&lt;br&gt;
{{rlt|namespace}}&lt;br&gt;
{{rlt|new}}&lt;br&gt;
{{rlt|noexcept}} {{mark c++11}}&lt;br&gt;
{{rlt|not}}&lt;br&gt;
{{rlt|not_eq}}&lt;br&gt;
{{rlt|nullptr}} {{mark c++11}}&lt;br&gt;
{{rlt|operator}} {{mark|1}}&lt;br&gt;
{{rlt|or}}&lt;br&gt;
{{rlt|or_eq}}&lt;br&gt;
{{rlt|private}} {{mark|4}}&lt;br&gt;
{{rlt|protected}}&lt;br&gt;
{{rlt|public}}&lt;br&gt;
|
{{rlt|reflexpr}} {{mark since reflection ts}}&lt;br&gt;
{{rlt|register}} {{mark|3}}&lt;br&gt;
{{rlt|reinterpret_cast}}&lt;br&gt;
{{rlt|requires}} {{mark c++20}}&lt;br&gt;
{{rlt|return}}&lt;br&gt;
{{rlt|short}}&lt;br&gt;
{{rlt|signed}}&lt;br&gt;
{{rlt|sizeof}} {{mark|1}}&lt;br&gt;
{{rlt|static}}&lt;br&gt;
{{rlt|static_assert}} {{mark c++11}}&lt;br&gt;
{{rlt|static_cast}}&lt;br&gt;
{{rlt|struct}} {{mark|1}}&lt;br&gt;
{{rlt|switch}}&lt;br&gt;
{{rlt|synchronized}} {{mark since tm ts}}&lt;br&gt;
{{rlt|template}}&lt;br&gt;
{{rlt|this}} {{mark|5}}&lt;br&gt;
{{rlt|thread_local}} {{mark c++11}}&lt;br&gt;
{{rlt|throw}} {{mark|3}} {{mark|4}}&lt;br&gt;
{{rlt|true}}&lt;br&gt;
{{rlt|try}}&lt;br&gt;
{{rlt|typedef}}&lt;br&gt;
{{rlt|typeid}}&lt;br&gt;
{{rlt|typename}} {{mark|3}} {{mark|4}}&lt;br&gt;
{{rlt|union}}&lt;br&gt;
{{rlt|unsigned}}&lt;br&gt;
{{rlt|using}} {{mark|1}} {{mark|4}}&lt;br&gt;
{{rlt|virtual}}&lt;br&gt;
{{rlt|void}}&lt;br&gt;
{{rlt|volatile}}&lt;br&gt;
{{rlt|wchar_t}}&lt;br&gt;
{{rlt|while}}&lt;br&gt;
{{rlt|xor}}&lt;br&gt;
{{rlt|xor_eq}}
|}

* {{mark|1}} — meaning changed or new meaning added in C++11.
* {{mark|2}} — new meaning added in C++14.
* {{mark|3}} — meaning changed or new meaning added in C++17.
* {{mark|4}} — meaning changed or new meaning added in C++20.
* {{mark|5}} — new meaning added in C++23.
Note that: {{rlt|and}}, {{rlt|bitor}}, {{rlt|or}}, {{rlt|xor}}, {{rlt|compl}}, {{rlt|bitand}}, {{rlt|and_eq}}, {{rlt|or_eq}}, {{rlt|xor_eq}}, {{rlt|not}} and {{rlt|not_eq}} (along with digraphs: {{c|&lt;%}}, {{c|%&gt;}}, {{c|&lt;:}}, {{c|:&gt;}}, {{c|%:}}, {{c|%:%:}}{{rev inl|until=c++17|removed=yes| and trigraphs: {{c|??&lt;}}, {{c|??&gt;}}, {{c|??(}}, {{c|??)}}, {{c|1=??=}}, {{c|??/}}, {{c|??'}}, {{c|??!}}, {{c|??-}}}}) provide an [[cpp/language/operator alternative|alternative way to represent standard tokens]].{{rev inl|since=c++11| These keywords are also considered reserved in attributes (excluding attribute argument lists), but some implementations handle them the same as the others.}}

In addition to keywords, there are ''identifiers with special meaning'', which may be used as names of objects or functions, but have special meaning in certain contexts.

{|class="wikitable"
|-
|
[[cpp/identifier_with_special_meaning/final|{{tt|final}}]] {{mark c++11}}&lt;br&gt;
[[cpp/identifier_with_special_meaning/override|{{tt|override}}]] {{mark c++11}}&lt;br&gt;
{{rlt|transaction_safe}} {{mark since tm ts}}&lt;br&gt;
{{rlt|transaction_safe_dynamic}} {{mark since tm ts}}&lt;br&gt;
[[cpp/identifier_with_special_meaning/import|{{tt|import}}]] {{mark c++20}}&lt;br&gt;
[[cpp/identifier_with_special_meaning/module|{{tt|module}}]] {{mark c++20}}
|}

Also, all {{lt|cpp/language/identifiers}} that contain a double underscore {{tt|__}} in any position and each identifier that begins with an underscore followed by an uppercase letter is always reserved, and all identifiers that begin with an underscore are reserved for use as names in the global namespace. See {{lt|cpp/language/identifiers}} for more details.

The namespace {{tt|std}} is used to place names of the standard C++ library. See [[cpp/language/extending std|Extending namespace std]] for the rules about adding names to it.

{{rrev|since=c++11|The name {{tt|posix}} is reserved for a future top-level namespace. The behavior is undefined if a program declares or defines anything in that namespace.}}

The following tokens are recognized by the {{rlp|preprocessor}} when in context of a preprocessor directive:
{|class="wikitable"
|-
|
{{ltt|cpp/preprocessor/conditional|if}}&lt;br&gt;
{{ltt|cpp/preprocessor/conditional|elif}}&lt;br&gt;
{{ltt|cpp/preprocessor/conditional|else}}&lt;br&gt;
{{ltt|cpp/preprocessor/conditional|endif}}&lt;br&gt;
|
{{ltt|cpp/preprocessor/conditional|ifdef}}&lt;br&gt;
{{ltt|cpp/preprocessor/conditional|ifndef}}&lt;br&gt;
{{ltt|cpp/preprocessor/conditional|elifdef}} {{mark c++23}}&lt;br&gt;
{{ltt|cpp/preprocessor/conditional|elifndef}} {{mark c++23}}&lt;br&gt;
|
{{ltt|cpp/preprocessor/replace|define}}&lt;br&gt;
{{ltt|cpp/preprocessor/replace|undef}}&lt;br&gt;
{{ltt|cpp/preprocessor/include|include}}&lt;br&gt;
{{ltt|cpp/preprocessor/line|line}}&lt;br&gt;
|
{{ltt|cpp/preprocessor/error|error}}&lt;br&gt;
{{ltt|cpp/preprocessor/error|warning}} {{mark c++23}}&lt;br&gt;
{{ltt|cpp/preprocessor/impl|pragma}}&lt;br&gt;
|
{{ltt|cpp/preprocessor/conditional|defined}}&lt;br&gt;
{{ltt|cpp/feature test|__has_include}} {{mark c++17}}&lt;br&gt;
{{ltt|cpp/feature test|__has_cpp_attribute}} {{mark c++20}}
|
{{rlt|export}} {{mark c++20}}&lt;br&gt;
[[cpp/identifier_with_special_meaning/import|{{tt|import}}]] {{mark c++20}}&lt;br&gt;
[[cpp/identifier_with_special_meaning/module|{{tt|module}}]] {{mark c++20}}
|}

The following tokens are recognized by the {{rlp|preprocessor}} ''outside'' the context of a preprocessor directive:
{|class="wikitable"
|-
|
{{ltt|cpp/preprocessor/impl|_Pragma}} {{mark c++11}}
|}

===See also===
{{dsc begin}}
{{dsc see c|c/keyword|C keywords|nomono=true}}
{{dsc end}}

{{langlinks|ar|de|es|fr|it|ja|ko|pl|pt|ru|zh}}