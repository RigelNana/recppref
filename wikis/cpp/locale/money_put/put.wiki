{{cpp/locale/money_put/title|put, do_put}}
{{cpp/locale/money_put/navbar}}
{{dcl begin}}
{{dcl header|locale}}
{{dcl|num=1|1=
public:
iter_type put( iter_type out, bool intl, std::ios_base&amp; f,
               char_type fill, long double quant ) const;}}
{{dcl|num=2|1=
iter_type put( iter_type out, bool intl, std::ios_base&amp; f,
               char_type fill, const string_type&amp; quant ) const;}}
{{dcl|num=3|1=
protected:
virtual iter_type do_put( iter_type out, bool intl, std::ios_base&amp; str,
                          char_type fill, long double units ) const;}}
{{dcl|num=4|1=
virtual iter_type do_put( iter_type out, bool intl, std::ios_base&amp; str,
                          char_type fill, const string_type&amp; digits ) const;
}}
{{dcl end}}

Formats monetary value and writes the result to output stream.

@1,2@ Public member functions, call the member function {{tt|do_put}} of the most derived class.

@3@ The numeric arguments {{c|units}} is converted to a wide character string as if by
{{c|ct.widen(buf1, buf1 + std::sprintf(buf1, "%.0Lf", units), buf2)}}, where {{c|ct}} is the {{lc|std::ctype}} facet imbued in {{c|str.getloc()}} and {{c|buf1}} and {{c|buf2}} are sufficiently large character buffers. The resulting character string {{c|buf2}} is processed, formatted, and output to {{c|out}} as desribed below.

@4@ From the string argument {{c|digits}}, only the optional leading minus sign (as determined by comparing to {{c|ct.widen('-')}}, where {{c|ct}} is the {{lc|std::ctype}} facet imbued in {{c|str.getloc()}}) and the immediately following digit characters (as classified by {{c|ct}}) are taken as the character sequence to be processed, formatted, and output to {{c|out}} as described below.

Given the character sequence from the previous steps, if the first character equals {{c|ct.widen('-')}}, calls {{c|mp.neg_format()}} to obtain the formatting {{lc|pattern}}, otherwise calls {{c|mp.pos_format()}}, where {{c|mp}} is the {{c/core|std::moneypunct&lt;CharT, intl&gt;}} facet imbued in {{c|str.getloc()}}.

Thousands separator and decimal point characters are inserted as required by {{c|mp.grouping()}}, {{c|mp.frac_digits()}}, {{c|mp.decimal_point()}}, and {{c|mp.thousands_sep()}}, and the resulting string is placed in the output sequence where {{lc|value}} appears in the formatting pattern.

If {{c|str.flags() &amp; str.showbase}} is non-zero (the {{lc|std::showbase}} manipulator was used), then the currency symbol or string is generated by calling {{c|mp.curr_symbol()}} and placed in the output sequence where {{lc|symbol}} appears in the formatting pattern.

If {{c|mp.positive_sign()}} (in case positive format pattern is used) or {{c|mp.negative_sign()}} (in case negative format pattern is used) returns a string with more than one character, the first character returned is placed in the output sequence where {{lc|sign}} appears in the formatting pattern, and the rest of the characters are placed after all other characters, for example, formatting pattern {{c|{sign, value, space, symbol} }} with units {{c|123}} and negative_sign of {{c|"-"}} may result in {{c|"-1.23 €"}}, while negative_sign of {{c|"()"}} would generate {{c|"(1.23 €)"}}.

If the number of characters generated for the specified format is less than the value returned by {{c|str.width()}}, then copies of {{c|fill}} are inserted to bring the total length of the output sequence to exactly {{c|str.width()}}, as follows:
* If {{c|str.flags() &amp; str.adjustfield}} equals {{c|str.internal}}, the fill characters are inserted where {{tt|none}} or {{tt|space}} appears in the formatting pattern.
* Otherwise, if {{c|str.flags() &amp; str.adjustfield}} equals {{c|str.left}}, the copies of {{c|fill}} are appended after all other characters.
* Otherwise, the fill characters are placed before all other characters.

In the end, calls {{c|str.width(0)}} to cancel the effects of any {{lc|std::setw}}.

===Return value===
An iterator pointing immediately after the last character produced.

===Notes===
The currency units are assumed to be the smallest non-fractional units of the currency: cents in the U.S, yen in Japan.

===Example===
{{example
|code=
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;locale&gt;

struct my_punct : std::moneypunct_byname&lt;char, false&gt;
{
    my_punct(const char* name) : moneypunct_byname(name) {}
    string_type do_negative_sign() const { return "()"; }
};

int main()
{
    std::locale loc("ru_RU.utf8");
    std::cout.imbue(loc);
    long double units = -123.45;
    std::cout &lt;&lt; "In Russian locale, " &lt;&lt; units &lt;&lt; " prints as " &lt;&lt; std::showbase;
    
    // note, the following is equivalent to simply std::put_money(units)
    std::use_facet&lt;std::money_put&lt;char&gt;&gt;(loc).put(
        {std::cout}, false, std::cout, std::cout.fill(), units);
    std::cout &lt;&lt; '\n';
    
    std::cout.imbue(std::locale(std::cout.getloc(), new my_punct("ru_RU.utf8")));
    std::cout &lt;&lt; "With negative_sign set to \"()\", it prints as ";
    std::use_facet&lt;std::money_put&lt;char&gt;&gt;(loc).put(
        {std::cout}, false, std::cout, std::cout.fill(), units);
    std::cout &lt;&lt; '\n';
}
|output=
In Russian locale, -123,45 prints as -1.23 руб
With negative_sign set to "()", it prints as (1.23 руб)
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=328|std=C++98|before=the format string used for {{lc|std::sprintf}} was {{c|"%.01f"}}|after=corrected to {{c|"%.0Lf"}}}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/locale/dsc moneypunct}}
{{dsc inc|cpp/locale/dsc money_get}}
{{dsc inc|cpp/io/manip/dsc put_money}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}