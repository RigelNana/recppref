{{cpp/title|codecvt_utf16}}
{{cpp/locale/navbar}}
{{ddcl|header=codecvt|since=c++11|deprecated=c++17|removed=c++26|1=
template&lt;
    class Elem,
    unsigned long Maxcode = 0x10ffff,
    std::codecvt_mode Mode = (std::codecvt_mode)0 &gt;
class codecvt_utf16
    : public std::codecvt&lt;Elem, char, std::mbstate_t&gt;;
}}

{{tt|std::codecvt_utf16}} is a {{lc|std::codecvt}} facet which encapsulates conversion between a UTF-16 encoded byte string and UCS-2 or UTF-32 character string (depending on the type of {{tt|Elem}}). This {{lc|std::codecvt}} facet can be used to read and write UTF-16 files in binary mode.

UCS-2 is an archaic encoding that is a subset of UTF-16, which encodes scalar values in the range U+0000-U+FFFF (Basic Multilingual Plane) only.

===Template Parameters===
{{par begin}}
{{par|Elem|either {{c/core|char16_t}}, {{c/core|char32_t}}, or {{c/core|wchar_t}}}}
{{par|Maxcode|the largest value of {{tt|Elem}} that this facet will read or write without error }}
{{par|Mode|a constant of type {{lc|std::codecvt_mode}}}}
{{par end}}

===Member functions===
{{dsc begin}}
{{dsc mem ctor|cpp/locale/codecvt_utf16|inlinemem=true|constructs a new {{tt|codecvt_utf16}} facet }}
{{dsc mem dtor|cpp/locale/codecvt_utf16|inlinemem=true|destroys a {{tt|codecvt_utf16}} facet}}
{{dsc end}}

{{member|{{small|std::codecvt_utf16::}}codecvt_utf16|
{{dcl begin}}
{{dcl|1=
explicit codecvt_utf16( std::size_t refs = 0 );
}}
{{dcl end}}

Constructs a new {{tt|std::codecvt_utf16}} facet, passes the initial reference counter {{c|refs}} to the base class.

===Parameters===
{{par begin}}
{{par|refs|the number of references that link to the facet}}
{{par end}}
}}

{{member|{{small|std::codecvt_utf16::}}~codecvt_utf16|
{{dcl begin}}
{{dcl|1=
~codecvt_utf16();
}}
{{dcl end}}

Destroys the facet. Unlike the locale-managed facets, this facet's destructor is public.
}}

{{cpp/locale/codecvt/inherit}}
{{cpp/locale/codecvt_base/inherit}}

===Notes===
Although the standard requires that this facet works with UCS-2 when the size of {{tt|Elem}} is 16 bits, some implementations use UTF-16 instead, making this a non-converting locale. The term "UCS-2" was deprecated and removed from ISO 10646.

===Example===
{{example
|The following example demonstrates decoding of UTF-16le file on a system with 32-bit {{c/core|wchar_t}}. On a system with 16-bit {{c/core|wchar_t}}, decoding of the third character will fail because {{c/core|std::codecvt_utf16&lt;char16_t&gt;}} produces UCS-2, not UTF-16.
|code=
#include &lt;codecvt&gt;
#include &lt;cwchar&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &lt;string&gt;

void prepare_file()
{
    // UTF-16le data (if host system is little-endian)
    char16_t utf16le[4] = {0x007a,          // latin small letter 'z' U+007a
                           0x6c34,          // CJK ideograph "water"  U+6c34
                           0xd834, 0xdd0b}; // musical sign segno U+1d10b    
    
    // store in a file
    std::ofstream fout("text.txt");
    fout.write(reinterpret_cast&lt;char*&gt;(utf16le), sizeof utf16le);
}

int main()
{
    prepare_file();
    // open as a byte stream
    std::wifstream fin("text.txt", std::ios::binary);
    // apply facet
    fin.imbue(std::locale(fin.getloc(),
        new std::codecvt_utf16&lt;wchar_t, 0x10ffff, std::little_endian&gt;));
    
    wchar_t c = 0;
    for (std::cout &lt;&lt; std::showbase &lt;&lt; std::hex; fin.get(c);
         std::cout &lt;&lt; static_cast&lt;std::wint_t&gt;(c) &lt;&lt; '\n');
}
|output=
0x7a
0x6c34
0x1d10b
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=2229|std=C++98|before=the constructor and destructor were not specified|after=specifies them}}
{{dr list end}}

===See also===
{{cpp/locale/unicode string conversions}}
{{dsc begin}}
{{dsc inc|cpp/locale/dsc codecvt}}
{{dsc inc|cpp/locale/dsc codecvt_mode}}
{{dsc inc|cpp/locale/dsc codecvt_utf8}}
{{dsc inc|cpp/locale/dsc codecvt_utf8_utf16}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}