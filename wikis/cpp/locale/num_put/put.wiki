{{cpp/locale/num_put/title|put|do_put}}
{{cpp/locale/num_put/navbar}}
{{dcl begin}}
{{dcl header|locale}}
{{dcl rev begin|num=1}}
{{dcl|
public:
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, bool val ) const;
}}
{{dcl|
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, long val ) const;
}}
{{dcl|since=c++11|
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, long long val ) const;
}}
{{dcl|
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, unsigned long val ) const;
}}
{{dcl|since=c++11|
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, unsigned long long val ) const;
}}
{{dcl|
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, double val ) const;
}}
{{dcl|
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, long double val ) const;
}}
{{dcl|
iter_type put( iter_type out, std::ios_base&amp; str,
               char_type fill, const void* val ) const;
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|
protected:
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, bool val ) const;
}}
{{dcl|
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, long val ) const;
}}
{{dcl|since=c++11|
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, long long val ) const;
}}
{{dcl|
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, unsigned long val ) const;
}}
{{dcl|since=c++11|
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, unsigned long long val ) const;
}}
{{dcl|
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, double val ) const;
}}
{{dcl|
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, long double val ) const;
}}
{{dcl|
virtual iter_type do_put( iter_type out, std::ios_base&amp; str,
                          char_type fill, const void* val ) const;
}}
{{dcl rev end}}
{{dcl end}}

@1@ Public member function, calls the protected virtual member function {{tt|do_put}} of the most derived class.

@2@ Writes characters to the output sequence {{c|out}} which represent the value of {{c|val}}, formatted as requested by the formatting flags {{c|str.flags()}} and the {{lc|std::numpunct}} and {{lc|std::ctype}} facets of the locale imbued in the stream {{c|str}}. This function is called by all formatted output stream operators, such as {{c|std::cout &lt;&lt; n;}}.

Conversion occurs in four stages:

====Stage 1: conversion specifier selection==== 
* I/O format flags are obtained, as if by
: {{c|1=fmtflags basefield = (str.flags() &amp; std::ios_base::basefield);}}
: {{c|1=fmtflags uppercase = (str.flags() &amp; std::ios_base::uppercase);}}
: {{c|1=fmtflags floatfield = (str.flags() &amp; std::ios_base::floatfield);}}
: {{c|1=fmtflags showpos = (str.flags() &amp; std::ios_base::showpos);}}
: {{c|1=fmtflags showbase = (str.flags() &amp; std::ios_base::showbase);}}
: {{c|1=fmtflags showpoint = (str.flags() &amp; std::ios_base::showpoint);}}
* If the type of {{c|val}} is {{c|bool}}:
** If {{c|1=boolalpha == 0}}, then converts {{c|val}} to type {{c|int}} and performs integer output.
** If {{c|1=boolalpha != 0}}, obtains {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).truename()}} if {{c|1=val == true}} or {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).falsename()}} if {{c|1=val == false}}, and outputs each successive character {{c|c}} of that string to {{c|out}} with {{c|1=*out++ = c}}. No further processing is done in this case, the function returns {{c|out}}.
* If the type of {{c|val}} is an integer type, the first applicable choice of the following is selected:
** If {{c|1=basefield == oct}}, will use conversion specifier {{c|%o}}
** If {{c|1=basefield == hex &amp;&amp; !uppercase}}, will use conversion specifier {{c|%x}}
** If {{c|1=basefield == hex}}, will use conversion specifier {{c|%X}}
** If the type of {{c|val}} is signed, will use conversion specifier {{c|%d}}
** If the type of {{c|val}} is unsigned, will use conversion specifier {{c|%u}}
* For integer types, length modifier is added to the conversion specification if necessary: {{c|l}} for {{c|long}} and {{c|unsigned long}}{{rev inl|since=c++11|, {{c|ll}} for {{c|long long}} and {{c|unsigned long long}}}}.
* If the type of {{c|val}} is a floating-point type, the first applicable choice of the following is selected:
** If {{c|1=floatfield == std::ios_base::fixed}}, will use conversion specifier {{c|%f}}
** If {{c|1=floatfield == std::ios_base::scientific &amp;&amp; !uppercase}}, will use conversion specifier {{c|%e}}
** If {{c|1=floatfield == std::ios_base::scientific}}, will use conversion specifier {{c|%E}}
{{rrev|since=c++11|
:* If {{c|1=floatfield == (std::ios_base::fixed {{!}} std::ios_base::scientific) &amp;&amp; !uppercase}}, will use conversion specifier {{c|%a}}
:* If {{c|1=floatfield == (std::ios_base::fixed {{!}} std::ios_base::scientific)}}, will use conversion specifier {{c|%A}}
}}
:* If {{c|1=!uppercase}}, will use conversion specifier {{c|%g}}
:* Otherwise, will use conversion specifier {{c|%G}}
: Also:
:* If the type of {{c|val}} is {{c|long double}}, the length modifier {{c|L}} is added to the conversion specifier.
:* If the type of {{c|val}} is a floating-point type {{rev inl|since=c++11|and {{c|1=floatfield != (ios_base::fixed {{!}} ios_base::scientific)}}}}, the precision modifier is added and set to {{c|str.precision()}}. Otherwise, no precision is specified.
* For both integer and floating-point types, if {{c|showpos}} is set, the modifier {{c|+}} is prepended
* For integer types, if {{c|showbase}} is set, the modifier {{c|#}} is prepended.
* For floating-point types, if {{c|showpoint}} is set, the modifier {{c|#}} is prepended.
* If the type of {{c|val}} is {{c|void*}}, will use conversion specifier {{c|%p}}
* A narrow character string is created as if by a call to {{c|std::printf(spec, val)}} in the "C" locale, where {{c|spec}} is the chosen conversion specifier.

====Stage 2: locale-specific conversion==== 
* Every character {{c|c}} obtained in Stage 1, other than the decimal point {{c|'.'}}, is converted to {{c|CharT}} by calling {{c|std::use_facet&lt;std::ctype&lt;CharT&gt;&gt;(str.getloc()).widen(c)}}.
* For arithmetic types, the thousands separator character, obtained from {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).thousands_sep()}}, is inserted into the sequence according to the grouping rules provided by {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).grouping()}}
* Decimal point characters ({{c|'.'}}) are replaced by {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).decimal_point()}}
====Stage 3: padding====
* The adjustment flag is obtained as if by {{c|1=std::fmtflags adjustfield = (flags &amp; (std::ios_base::adjustfield))}} and examined to identify padding location, as follows:
** If {{c|1=adjustfield == std::ios_base::left}}, will pad after
** If {{c|1=adjustfield == std::ios_base::right}}, will pad before
** If {{c|1=adjustfield == std::ios_base::internal}} and a sign character occurs in the representation, will pad after the sign
** If {{c|1=adjustfield == std::ios_base::internal}} and Stage 1 representation began with 0x or 0X, will pad after the x or X
** Otherwise, will pad before
* If {{c|str.width()}} is non-zero (e.g. {{lc|std::setw}} was just used) and the number of {{c|CharT}}'s after Stage 2 is less than {{c|str.width()}}, then copies of the {{c|fill}} character are inserted at the position indicated by padding to bring the length of the sequence to {{c|str.width()}}.
In any case, {{c|str.width(0)}} is called to cancel the effects of {{lc|std::setw}}.

====Stage 4: output====
Every successive character {{c|c}} from the sequence of {{c|CharT}}'s from Stage 3 is output as if by {{c|1=*out++ = c}}.

===Parameters===
{{par begin}}
{{par|out|iterator pointing to the first character to be overwritten}}
{{par|str|stream to retrieve the formatting information from}}
{{par|fill|padding character used when the results needs to be padded to the field width}}
{{par|val|value to convert to string and output}}
{{par end}}

===Return value===
{{c|out}}

===Notes===
The leading zero generated by the conversion specification {{c|#o}} (resulting from the combination of {{lc|std::showbase}} and {{lc|std::oct}} for example) is not counted as a padding character.
{{rrev|since=c++11|1=
When formatting a floating point value as hexfloat (i.e., when {{c|1=floatfield == (std::ios_base::fixed {{!}} std::ios_base::scientific)}}), the stream's precision is not used; instead, the number is always printed with enough precision to exactly represent the value.
}}

===Example===
{{example
|Output a number using the facet directly, and demonstrate user-defined facet:
|code=
#include &lt;iostream&gt;
#include &lt;locale&gt;

// this custom num_put outputs squares of all integers (except long long)
struct squaring_num_put : std::num_put&lt;char&gt;
{
    iter_type do_put(iter_type out, std::ios_base&amp; str,
                     char_type fill, long val) const
    {
        return std::num_put&lt;char&gt;::do_put(out, str, fill, val * val);
    }
    
    iter_type do_put(iter_type out, std::ios_base&amp; str,
                     char_type fill, unsigned long val) const
    {
        return std::num_put&lt;char&gt;::do_put(out, str, fill, val * val);
    }
};

int main()
{
    auto&amp; facet = std::use_facet&lt;std::num_put&lt;char&gt;&gt;(std::locale());
    facet.put(std::cout, std::cout, '0', 2.71);
    std::cout &lt;&lt; '\n';
    
    std::cout.imbue(std::locale(std::cout.getloc(), new squaring_num_put));
    std::cout &lt;&lt; 6 &lt;&lt; ' ' &lt;&lt; -12 &lt;&lt; '\n';
} 
|output=
2.71
36 144
}}

{{example|
An implementation of {{lc|operator&lt;&lt;}} for a user-defined type.
|code=
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;locale&gt;

struct base { long x = 10; };

template&lt;class CharT, class Traits&gt;
std::basic_ostream&lt;CharT, Traits&gt;&amp;
    operator&lt;&lt;(std::basic_ostream&lt;CharT, Traits&gt;&amp; os, base const&amp; b)
{
    try
    {
        typename std::basic_ostream&lt;CharT, Traits&gt;::sentry s(os);
        
        if (s)
        {
            std::ostreambuf_iterator&lt;CharT, Traits&gt; it(os);
            std::use_facet&lt;std::num_put&lt;CharT&gt;&gt;(os.getloc())
                .put(it, os, os.fill(), b.x);
        }
    }
    catch (...)
    {
        // set badbit on os and rethrow if required
    }
    
    return os;
}

int main()
{
    base b;
    std::cout &lt;&lt; b;
}
|output=
10
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=34|std=C++98|before=the {{c|bool}} overload used non-existing members&lt;br&gt;{{c|truename}} and {{c|falsename}} of {{lc|std::ctype}}|after=use these members of {{lc|std::numpunct}}}}
{{dr list item|wg=lwg|dr=231|std=C++98|before=the precision modifier was only added if&lt;br&gt;{{c|1=(flags &amp; fixed) != 0}} or {{c|str.precision() &gt; 0}}|after=removed these conditions}}
{{dr list item|wg=lwg|dr=282|std=C++98|before=the thousand separators were only inserted for integral types in stage 2|after=also inserted for floating-point types}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/basic_ostream/dsc operator_ltlt}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}