{{cpp/locale/num_get/title|get|do_get}}
{{cpp/locale/num_get/navbar}}
{{dcl begin}}
{{dcl rev begin|num=1}}
{{dcl|
public:
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, bool&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, long&amp; v ) const;
}}
{{dcl|since=c++11|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, long long&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, unsigned short&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, unsigned int&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, unsigned long&amp; v ) const;
}}
{{dcl|since=c++11|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, unsigned long long&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, float&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, double&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, long double&amp; v ) const;
}}
{{dcl|
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, void*&amp; v ) const;
}}
{{dcl rev end}}
{{dcl rev begin|num=2}}
{{dcl|
protected:
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, bool&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, long&amp; v ) const;
}}
{{dcl|since=c++11|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, long long&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, unsigned short&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, unsigned int&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, unsigned long&amp; v ) const;
}}
{{dcl|since=c++11|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err,
                          unsigned long long&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, float&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, double&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, long double&amp; v ) const;
}}
{{dcl|
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, void*&amp; v ) const;
}}
{{dcl rev end}}
{{dcl end}}

@1@ Public member function, calls the member function {{tt|do_get}} of the most derived class.

@2@ Reads characters from the input iterator {{c|in}} and generates the value of the type of {{c|v}}, taking into account I/O stream formatting flags from {{c|str.flags()}}, character classification rules from {{c|std::use_facet&lt;std::ctype&lt;CharT&gt;&gt;(str.getloc())}}, and numeric punctuation characters from {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc())}}. This function is called by all formatted input stream operators such as {{c|std::cin &gt;&gt; n;}}.

Conversion occurs in three stages:

====Stage 1: conversion specifier selection==== 
* I/O format flags are obtained, as if by
: {{c|1=fmtflags basefield = (str.flags() &amp; std::ios_base::basefield);}}
: {{c|1=fmtflags boolalpha = (str.flags() &amp; std::ios_base::boolalpha);}}
* If the type of {{c|v}} is an integer type, the first applicable choice of the following five is selected:
: If {{c|1=basefield == oct}}, will use conversion specifier {{c|%o}}
: If {{c|1=basefield == hex}}, will use conversion specifier {{c|%X}}
: If {{c|1=basefield == 0}}, will use conversion specifier {{c|%i}}
: If the type of {{c|v}} is signed, will use conversion specifier {{c|%d}}
: If the type of {{c|v}} is unsigned, will use conversion specifier {{c|%u}}
* For integer types, length modifier is added to the conversion specification if necessary: {{c|h}} for {{c/core|short}} and {{c/core|unsigned short}}, {{c|l}} for {{c/core|long}} and {{c/core|unsigned long}}{{rev inl|since=c++11|, {{c|ll}} for {{c/core|long long}} and {{c/core|unsigned long long}}}}
* If the type of {{c|v}} is {{c/core|float}}, will use conversion specifier {{c|%g}}
* If the type of {{c|v}} is {{c/core|double}}, will use conversion specifier {{c|%lg}}
* If the type of {{c|v}} is {{c/core|long double}}, will use conversion specifier {{c|%Lg}}
* If the type of {{c|v}} is {{c/core|void*}}, will use conversion specifier {{c|%p}}
* If the type of {{c|v}} is {{c/core|bool}} and {{c|1=boolalpha == 0}}, proceeds as if the type of {{c|v}} is {{c/core|long}}, except for the value to be stored in {{c|v}} in stage 3.
* If the type of {{c|v}} is {{c/core|bool}} and {{c|1=boolalpha != 0}}, the following replaces stages 2 and 3:
** Successive characters obtained from the input iterator {{c|in}} are matched against the character sequences obtained from {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).falsename()}} and {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).truename()}} only as necessary as to identify the unique match. The input iterator {{c|in}} is compared to {{c|end}} only when necessary to obtain a character.
** If the target sequence is uniquely matched, {{c|v}} is set to the corresponding {{c/core|bool}} value. Otherwise {{c|false}} is stored in {{c|v}} and {{lc|std::ios_base::failbit}} is assigned to {{c|err}}. If unique match could not be found before the input ended ({{c|1=in == end}}), {{c|1=err {{!}}= std::ios_base::eofbit}} is executed.

====Stage 2: character extraction==== 
* If {{c|1=in == end}}, stage 2 is terminated immediately, no further characters are extracted.
* The next character is extracted from {{c|in}} as if by {{c|1=char_type ct = *in;}}:
** If the character matches one of {{rev inl|until=c++11|{{c|"0123456789abcdefxABCDEFX+-"}}}}{{rev inl|since=c++11|{{c|"0123456789abcdefpxABCDEFPX+-"}}}}, widened to the locale's char_type as if by {{c|std::use_facet&lt;std::ctype&lt;CharT&gt;&gt;(str.getloc()).widen()}}, it is converted to the corresponding {{c|char}}.
** If the character matches the decimal point separator ({{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).decimal_point())}}), it is replaced by {{c|'.'}}.
** If the character matches the thousands separator ({{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).thousands_sep()}}) and the thousands separation is in use (as determined by {{c|1=std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).grouping().length() != 0}}), then if the decimal point {{c|'.'}} has not yet been accumulated, the position of the character is remembered, but the character is otherwise ignored. If the decimal point has already been accumulated, the character is discarded and stage 2 terminates.
** In any case, the check is made whether the {{c/core|char}} obtained from the previous steps is allowed in the input field that would be parsed by {{lc|std::scanf}} given the conversion specifier selected in stage 1. If it is allowed, it is accumulated in a temporary buffer and stage 2 repeats. If it is not allowed, stage 2 terminates.

====Stage 3: conversion and storage====
* The sequence of {{c/core|char}}s accumulated in stage 2 is converted to a numeric value:
{{rev begin}}
{{rev|until=c++11|
: The input is parsed according to the rules of {{lc|std::scanf}}.
}}
{{rev|since=c++11|
: The input is parsed as if by
:* {{lc|std::strtoll}} for signed integer {{c|v}},
:* {{lc|std::strtoull}} for unsigned integer {{c|v}},
:* {{lc|std::strtof}} for {{c/core|float}} {{c|v}},
:* {{lc|std::strtod}} for {{c/core|double}} {{c|v}}, or
:* {{lc|std::strtold}} for {{c/core|long double}} {{c|v}}.
}}
{{rev end}}
* If the conversion function fails to convert the entire field, the value {{c|0}} is stored in {{c|v}}.
* If the type of {{c|v}} is a signed integer type and the conversion function results in a positive or negative value too large to fit in it, the most positive or negative representable value is stored in {{c|v}}, respectively.
* If the type of {{c|v}} is an unsigned integer type and the conversion function results in a value that does not fit in it, the most positive representable value is stored in {{c|v}}.
* In any case, if the conversion function fails {{lc|std::ios_base::failbit}} is assigned to {{c|err}}.
* Otherwise, the numeric result of the conversion is stored in {{c|v}}.
** If the type of {{c|v}} is {{c/core|bool}} and boolalpha is not set, then if the value to be stored is {{c|0}}, {{c|false}} is stored, if the value to be stored is {{c|1}}, {{c|true}} is stored, for any other value {{lc|std::ios_base::failbit}} is assigned to {{c|err}} and {{c|true}} is stored.
* After this, digit grouping is checked. if the position of any of the thousands separators discarded in stage 2 does not match the grouping provided by {{c|std::use_facet&lt;std::numpunct&lt;CharT&gt;&gt;(str.getloc()).grouping()}}, {{lc|std::ios_base::failbit}} is assigned to {{c|err}}.
* If stage 2 was terminated by the test {{c|1=in == end}}, {{c|1=err {{!}}= std::ios_base::eofbit}} is executed to set the eof bit.

===Return value===
{{c|in}}

===Notes===
Before the resolutions of {{lwg|23}} and {{lwg|696}}, {{c|v}} was left unchanged if an error occurs.

Before the resolution of {{lwg|221}}, strings representing hexadecimal integers (e.g. {{c|"0xA0"}}) were rejected by {{tt|do_get(int)}} even if they are valid input to {{ltt|cpp/string/byte/strtol}} because stage 2 filters out characters {{c|'X'}} and {{c|'x'}}.

Before the resolution of {{lwg|1169}}, converting a negative number string into an unsigned integer might produce zero (since the value represented by the string is smaller than what the target type can represent).

{{rrev|since=c++11|
Before the resolution of {{lwg|2381}}, strings representing hexadecimal floating-point numbers with exponents (e.g. {{c|"0x1.23p-10"}}) were rejected by {{tt|do_get(double)}} even if they are valid input to {{ltt|cpp/string/byte/strtof|strtod}} because stage 2 filters out characters {{c|'P'}} and {{c|'p'}}.

The strings representing infinity or not-a-number (e.g. {{c|"NaN"}} and {{c|"inf"}}) are rejected by {{tt|do_get(double)}} even if they are valid input to {{tt|strtod}} because stage 2 filters out characters such as {{c|'N'}} or {{c|'i'}}.
}}

===Example===
{{example
|An implementation of {{tt|operator&gt;&gt;}} for a user-defined type.
|code=
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;locale&gt;
 
struct base { long x; };
 
template&lt;class CharT, class Traits&gt;
std::basic_istream&lt;CharT, Traits&gt;&amp;
    operator &gt;&gt;(std::basic_istream&lt;CharT, Traits&gt;&amp; is, base&amp; b)
{
    std::ios_base::iostate err = std::ios_base::goodbit;
    
    try // setting err could throw
    {
        typename std::basic_istream&lt;CharT, Traits&gt;::sentry s(is);
        
        if (s) // if stream is ready for input
            std::use_facet&lt;std::num_get&lt;CharT&gt;&gt;(is.getloc()).get(is, {}, is, err, b.x);
    }
    catch (std::ios_base::failure&amp; error)
    {
        // handle the exception
    }
    
    return is;
}

int main()
{
    base b;
    std::cin &gt;&gt; b;
}
|output=
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=17|std=C++98|before=the process of parsing text boolean values was errornous|after=corrected}}
{{dr list item|wg=lwg|dr=18|std=C++98|before=the overload of {{tt|get}} taking {{c/core|bool&amp;}} value was missing|after=added}}
{{dr list item|wg=lwg|dr=23|std=C++98|before=overflowing input resulted in undefined behavior|after=overflow handled}}
{{dr list item|wg=lwg|dr=154|std=C++98|before=the conversion specifier for {{c/core|double}} was {{c|%g}} (same as {{c/core|float}})|after=changed to {{c|%lg}}}}
{{dr list item|wg=lwg|dr=221|std=C++98|before={{tt|do_get}} did not parse {{c|'x'}} and {{c|'X'}} while {{ltt|cpp/string/byte/strtol}} parsed them|after=made {{c|'x'}} and {{c|'X'}} parsed}}
{{dr list item|wg=lwg|dr=275|std=C++98|before={{tt|get}} had an overload taking {{c/core|short&amp;}} value instead of {{c/core|float&amp;}}|after=corrected}}
{{dr list item|wg=lwg|dr=358|std=C++98|before=thousand separators after the decimal point were ignored|after=stage 2 is terminated if encountered}}
{{dr list item|wg=lwg|dr=696|std=C++98|before=the result was unchanged on conversion failure|after=set to zero}}
{{dr list item|wg=lwg|dr=1169|std=C++98|before=overflow handling was inconsistent between floating-point types|after=made consistent&lt;br&gt;with {{tt|strtof}}/{{tt|strtod}}}}
{{dr list item|wg=lwg|dr=2381|std=C++11|before={{tt|do_get}} did not parse {{c|'p'}} and {{c|'P'}} while {{ltt|cpp/string/byte/strtof|strtod}} parsed them|after=made {{c|'p'}} and {{c|'P'}} parsed}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/io/basic_istream/dsc operator_gtgt}}
{{dsc end}}

{{langlinks|de|es|fr|it|ja|pt|ru|zh}}