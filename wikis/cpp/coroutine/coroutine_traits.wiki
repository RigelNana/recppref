{{cpp/title|coroutine_traits}}
{{cpp/coroutine/navbar}}
{{ddcl|header=coroutine|since=c++20|
template&lt; class R, class... Args &gt;
struct coroutine_traits;
}}

Determines the promise type from the return type and parameter types of a coroutine. The standard library implementation provides a publicly accessible member type {{tt|promise_type}} same as {{tt|R::promise_type}} if the qualified-id is valid and denotes a type. Otherwise, it has no such member.

[[cpp/language/type#Program-defined type|Program-defined specializations]] of {{tt|coroutine_traits}} must define a publicly accessible nested type {{tt|promise_type}}, otherwise the program is ill-formed.

===Template parameters===
{{par begin}}
{{par|R|return type of the coroutine}}
{{par|Args|parameter types of the coroutine, including the [[cpp/language/member functions#ref-qualified member functions|implicit object parameter]] if the coroutine is a non-static member function}}
{{par end}}

===Nested types===
{{dsc begin}}
{{dsc hitem|Name|Definition}}
{{dsc|{{tt|promise_type}}|{{tt|R::promise_type}} if it is valid, or provided by program-defined specializations}}
{{dsc end}}

===Possible implementation===
{{eq fun|1=
namespace detail {
template&lt;class, class...&gt;
struct coroutine_traits_base {};

template&lt;class R, class... Args&gt;
requires requires { typename R::promise_type; }
struct coroutine_traits_base &lt;R, Args...&gt;
{
    using promise_type = R::promise_type;
};
}

template&lt;class R, class... Args&gt;
struct coroutine_traits : detail::coroutine_traits_base&lt;R, Args...&gt; {};
}}

===Notes===
If the coroutine is a non-static member function, then the first type in {{tt|Args...}} is the type of the implicit object parameter, and the rest are parameter types of the function (if any).

If {{tt|std::coroutine_traits&lt;R, Args...&gt;::promise_type}} does not exist or is not a class type, the corresponding coroutine definition is ill-formed.

Users may define explicit or partial specializations of {{tt|coroutine_traits}} dependent on program-defined types to avoid modification to return types.

===Example===
{{example
|code=
#include &lt;chrono&gt;
#include &lt;coroutine&gt;
#include &lt;exception&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;type_traits&gt;

// A program-defined type on which the coroutine_traits specializations below depend
struct as_coroutine {};

// Enable the use of std::future&lt;T&gt; as a coroutine type
// by using a std::promise&lt;T&gt; as the promise type.
template&lt;typename T, typename... Args&gt;
    requires(!std::is_void_v&lt;T&gt; &amp;&amp; !std::is_reference_v&lt;T&gt;)
struct std::coroutine_traits&lt;std::future&lt;T&gt;, as_coroutine, Args...&gt;
{
    struct promise_type : std::promise&lt;T&gt;
    {
        std::future&lt;T&gt; get_return_object() noexcept
        {
            return this-&gt;get_future();
        }
        
        std::suspend_never initial_suspend() const noexcept { return {}; }
        std::suspend_never final_suspend() const noexcept { return {}; }
        
        void return_value(const T&amp; value)
            noexcept(std::is_nothrow_copy_constructible_v&lt;T&gt;)
        {
            this-&gt;set_value(value);
        }
        
        void return_value(T&amp;&amp; value) noexcept(std::is_nothrow_move_constructible_v&lt;T&gt;)
        {
            this-&gt;set_value(std::move(value));
        }
        
        void unhandled_exception() noexcept
        {
            this-&gt;set_exception(std::current_exception());
        }
    };
};

// Same for std::future&lt;void&gt;.
template&lt;typename... Args&gt;
struct std::coroutine_traits&lt;std::future&lt;void&gt;, as_coroutine, Args...&gt;
{
    struct promise_type : std::promise&lt;void&gt;
    {
        std::future&lt;void&gt; get_return_object() noexcept
        {
            return this-&gt;get_future();
        }
        
        std::suspend_never initial_suspend() const noexcept { return {}; }
        std::suspend_never final_suspend() const noexcept { return {}; }
        
        void return_void() noexcept
        {
            this-&gt;set_value();
        }
        
        void unhandled_exception() noexcept
        {
            this-&gt;set_exception(std::current_exception());
        }
    };
};

// Allow co_await'ing std::future&lt;T&gt; and std::future&lt;void&gt;
// by naively spawning a new thread for each co_await.
template&lt;typename T&gt;
auto operator co_await(std::future&lt;T&gt; future) noexcept
    requires(!std::is_reference_v&lt;T&gt;)
{
    struct awaiter : std::future&lt;T&gt;
    {
        bool await_ready() const noexcept
        {
            using namespace std::chrono_literals;
            return this-&gt;wait_for(0s) != std::future_status::timeout;
        }
        
        void await_suspend(std::coroutine_handle&lt;&gt; cont) const
        {
            std::thread([this, cont]
            {
                this-&gt;wait();
                cont();
            }).detach();
        }
        
        T await_resume() { return this-&gt;get(); }
    };
    
    return awaiter { std::move(future) };
}

// Utilize the infrastructure we have established.
std::future&lt;int&gt; compute(as_coroutine)
{
    int a = co_await std::async([] { return 6; });
    int b = co_await std::async([] { return 7; });
    co_return a * b;
}

std::future&lt;void&gt; fail(as_coroutine)
{
    throw std::runtime_error("bleah");
    co_return;
}

int main()
{
    std::cout &lt;&lt; compute({}).get() &lt;&lt; '\n';
    
    try
    {
        fail({}).get();
    }
    catch (const std::runtime_error&amp; e)
    {
        std::cout &lt;&lt; "error: " &lt;&lt; e.what() &lt;&lt; '\n';
    }
}
|output=
42
error: bleah
}}

{{langlinks|es|ja|zh}}