{{cpp/title|coroutine_handle|noop_coroutine_handle}}
{{cpp/coroutine/coroutine_handle/navbar}}
{{dcl begin}}
{{dcl header|coroutine}}
{{dcl|num=1|since=c++20|1=
template&lt; class Promise = void &gt;
struct coroutine_handle;
}}
{{dcl|num=2|since=c++20|
template&lt;&gt;
struct coroutine_handle&lt;void&gt;;
}}
{{dcl|num=3|since=c++20|
template&lt;&gt;
struct coroutine_handle&lt;std::noop_coroutine_promise&gt;;
}}
{{dcl|num=4|since=c++20|1=
using noop_coroutine_handle =
    std::coroutine_handle&lt;std::noop_coroutine_promise&gt;;
}}
{{dcl end}}

The class template {{tt|coroutine_handle}} can be used to refer to a suspended or executing coroutine. Every specialization of {{tt|coroutine_handle}} is a {{named req|LiteralType}}.

@1@ Primary template, can be created from the promise object of type {{tt|Promise}}.

@2@ Specialization {{c|std::coroutine_handle&lt;void&gt;}} erases the promise type. It is convertible from other specializations.

@3@ Specialization {{c|std::coroutine_handle&lt;std::noop_coroutine_promise&gt;}} refers to no-op coroutines. It cannot be created from a promise object.

On typical implementations, every specialization of {{tt|std::coroutine_handle}} is {{named req|TriviallyCopyable}}.

{{cpp/types/nospec}}

===Data members===
{{dsc begin}}
{{dsc hitem|Member name|Definition}}
{{dsc|{{tti|ptr}} {{mark|private}}|A pointer {{c|void*}} to the coroutine state.&lt;br&gt;{{mark expos mem obj}}}}
{{dsc end}}

===Member functions===
{{dsc begin}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc constructor}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc operator{{=}}}}

{{dsc h2|Conversion}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc operator coroutine_handle void}}

{{dsc h2|Observers}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc done}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc operator bool}}

{{dsc h2|Control}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc resume}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc destroy}}

{{dsc h2|Promise Access}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc promise}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc from_promise}}

{{dsc h2|Export/Import}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc address}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc from_address}}
{{dsc end}}

===Non-member functions===
{{dsc begin}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc operator_cmp}}
{{dsc end}}

===Helper classes===
{{dsc begin}}
{{dsc inc|cpp/coroutine/coroutine_handle/dsc hash}}
{{dsc end}}

===Notes===
A {{tt|coroutine_handle}} may be dangling, in which case the {{tt|coroutine_handle}} must be used carefully in order to avoid undefined behavior.

===Example===
{{example
|code=
#include &lt;coroutine&gt;
#include &lt;iostream&gt;
#include &lt;optional&gt;

template&lt;std::movable T&gt;
class Generator
{
public:
    struct promise_type
    {
        Generator&lt;T&gt; get_return_object()
        {
            return Generator{Handle::from_promise(*this)};
        }
        static std::suspend_always initial_suspend() noexcept
        {
            return {};
        }
        static std::suspend_always final_suspend() noexcept
        {
            return {};
        }
        std::suspend_always yield_value(T value) noexcept
        {
            current_value = std::move(value);
            return {};
        }
        // Disallow co_await in generator coroutines.
        void await_transform() = delete;
        [[noreturn]]
        static void unhandled_exception() { throw; }

        std::optional&lt;T&gt; current_value;
    };

    using Handle = std::coroutine_handle&lt;promise_type&gt;;

    explicit Generator(const Handle coroutine) :
        m_coroutine{coroutine}
    {}

    Generator() = default;
    ~Generator()
    {
        if (m_coroutine)
            m_coroutine.destroy();
    }

    Generator(const Generator&amp;) = delete;
    Generator&amp; operator=(const Generator&amp;) = delete;

    Generator(Generator&amp;&amp; other) noexcept :
        m_coroutine{other.m_coroutine}
    {
        other.m_coroutine = {};
    }
    Generator&amp; operator=(Generator&amp;&amp; other) noexcept
    {
        if (this != &amp;other)
        {
            if (m_coroutine)
                m_coroutine.destroy();
            m_coroutine = other.m_coroutine;
            other.m_coroutine = {};
        }
        return *this;
    }

    // Range-based for loop support.
    class Iter
    {
    public:
        void operator++()
        {
            m_coroutine.resume();
        }
        const T&amp; operator*() const
        {
            return *m_coroutine.promise().current_value;
        }
        bool operator==(std::default_sentinel_t) const
        {
            return !m_coroutine {{!!}} m_coroutine.done();
        }

        explicit Iter(const Handle coroutine) :
            m_coroutine{coroutine}
        {}

    private:
        Handle m_coroutine;
    };

    Iter begin()
    {
        if (m_coroutine)
            m_coroutine.resume();
        return Iter{m_coroutine};
    }

    std::default_sentinel_t end() { return {}; }

private:
    Handle m_coroutine;
};

template&lt;std::integral T&gt;
Generator&lt;T&gt; range(T first, const T last)
{
    while (first &lt; last)
        co_yield first++;
}

int main()
{
    for (const char i : range(65, 91))
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}
|output=
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
}}

===Defect reports===
{{dr list begin}}
{{dr list item|wg=lwg|dr=3460|std=C++20|before=the public base class of {{tt|coroutine_handle}} could leave it in an undesired state|after=inheritance removed}}
{{dr list end}}

===See also===
{{dsc begin}}
{{dsc inc|cpp/ranges/dsc generator}}
{{dsc end}}

{{langlinks|es|ja|ru|zh}}